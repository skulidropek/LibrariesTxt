[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class NPOI.DDF.AbstractEscherOptRecord : EscherRecord {
    protected List`1<EscherProperty> properties;
    public List`1<EscherProperty> EscherProperties { get; }
    private int PropertiesSize { get; }
    public int RecordSize { get; }
    public void AddEscherProperty(EscherProperty prop);
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public List`1<EscherProperty> get_EscherProperties();
    public EscherProperty GetEscherProperty(int index);
    private int get_PropertiesSize();
    public virtual int get_RecordSize();
    public EscherProperty Lookup(int propId);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public void SortProperties();
    public void SetEscherProperty(EscherProperty value);
    public void RemoveEscherProperty(int num);
    public virtual string ToString();
    public virtual string ToXml(string tab);
}
public class NPOI.DDF.DefaultEscherRecordFactory : object {
    private static Type[] escherRecordClasses;
    private static Dictionary`2<short, ConstructorInfo> recordsMap;
    private static DefaultEscherRecordFactory();
    public virtual EscherRecord CreateRecord(Byte[] data, int offset);
    private static Dictionary`2<short, ConstructorInfo> RecordsToMap(Type[] records);
    public static bool IsContainer(short options, short recordId);
}
public class NPOI.DDF.EscherArrayProperty : EscherComplexProperty {
    private static int FIXED_SIZE;
    private bool sizeIncludesHeaderSize;
    private bool emptyComplexPart;
    public int NumberOfElementsInArray { get; public set; }
    public int NumberOfElementsInMemory { get; public set; }
    public short SizeOfElements { get; public set; }
    public EscherArrayProperty(short id, Byte[] complexData);
    public EscherArrayProperty(short propertyNumber, bool isBlipId, Byte[] complexData);
    private static Byte[] CheckComplexData(Byte[] complexData);
    public int get_NumberOfElementsInArray();
    public void set_NumberOfElementsInArray(int value);
    public int get_NumberOfElementsInMemory();
    public void set_NumberOfElementsInMemory(int value);
    public short get_SizeOfElements();
    public void set_SizeOfElements(short value);
    public Byte[] GetElement(int index);
    public void SetElement(int index, Byte[] element);
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public int SetArrayData(Byte[] data, int offset);
    public virtual int SerializeSimplePart(Byte[] data, int pos);
    public static int GetActualSizeOfElements(short sizeOfElements);
    private static int GetArraySizeInBytes(int numberOfElements, int sizeOfElements);
    public sealed virtual IEnumerator`1<Byte[]> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NPOI.DDF.EscherBitmapBlip : EscherBlipRecord {
    public static short RECORD_ID_JPEG;
    public static short RECORD_ID_PNG;
    public static short RECORD_ID_DIB;
    private static int HEADER_SIZE;
    private Byte[] field_1_UID;
    private byte field_2_marker;
    public int RecordSize { get; }
    public Byte[] UID { get; public set; }
    public byte Marker { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public Byte[] get_UID();
    public void set_UID(Byte[] value);
    public byte get_Marker();
    public void set_Marker(byte value);
    public virtual string ToString();
    public virtual string ToXml(string tab);
}
public class NPOI.DDF.EscherBlipRecord : EscherRecord {
    public static short RECORD_ID_START;
    public static short RECORD_ID_END;
    public static string RECORD_DESCRIPTION;
    private static int HEADER_SIZE;
    private Byte[] field_pictureData;
    public int RecordSize { get; }
    public string RecordName { get; }
    public Byte[] PictureData { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual string get_RecordName();
    public Byte[] get_PictureData();
    public void set_PictureData(Byte[] value);
    public void SetPictureData(Byte[] pictureData, int offset, int length);
    public virtual string ToString();
    public virtual string ToXml(string tab);
}
public class NPOI.DDF.EscherBlipWMFRecord : EscherBlipRecord {
    public static string RECORD_DESCRIPTION;
    private static int HEADER_SIZE;
    private Byte[] field_1_secondaryUID;
    private int field_2_cacheOfSize;
    private int field_3_boundaryTop;
    private int field_4_boundaryLeft;
    private int field_5_boundaryWidth;
    private int field_6_boundaryHeight;
    private int field_7_width;
    private int field_8_height;
    private int field_9_cacheOfSavedSize;
    private byte field_10_compressionFlag;
    private byte field_11_filter;
    private Byte[] field_12_data;
    public int RecordSize { get; }
    public string RecordName { get; }
    public Byte[] SecondaryUID { get; public set; }
    public int CacheOfSize { get; public set; }
    public int BoundaryTop { get; public set; }
    public int BoundaryLeft { get; public set; }
    public int BoundaryWidth { get; public set; }
    public int BoundaryHeight { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public int CacheOfSavedSize { get; public set; }
    public byte CompressionFlag { get; public set; }
    public byte Filter { get; public set; }
    public Byte[] Data { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual string get_RecordName();
    public Byte[] get_SecondaryUID();
    public void set_SecondaryUID(Byte[] value);
    public int get_CacheOfSize();
    public void set_CacheOfSize(int value);
    public int get_BoundaryTop();
    public void set_BoundaryTop(int value);
    public int get_BoundaryLeft();
    public void set_BoundaryLeft(int value);
    public int get_BoundaryWidth();
    public void set_BoundaryWidth(int value);
    public int get_BoundaryHeight();
    public void set_BoundaryHeight(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public int get_CacheOfSavedSize();
    public void set_CacheOfSavedSize(int value);
    public byte get_CompressionFlag();
    public void set_CompressionFlag(byte value);
    public byte get_Filter();
    public void set_Filter(byte value);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public static Byte[] Compress(Byte[] data);
    public static Byte[] Decompress(Byte[] data, int pos, int Length);
}
public class NPOI.DDF.EscherBoolProperty : EscherSimpleProperty {
    public bool IsTrue { get; }
    public bool IsFalse { get; }
    public EscherBoolProperty(short propertyNumber, int value);
    public bool get_IsTrue();
    public bool get_IsFalse();
    public virtual string ToXml(string tab);
}
public class NPOI.DDF.EscherBSERecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    public static byte BT_ERROR;
    public static byte BT_UNKNOWN;
    public static byte BT_EMF;
    public static byte BT_WMF;
    public static byte BT_PICT;
    public static byte BT_JPEG;
    public static byte BT_PNG;
    public static byte BT_DIB;
    private byte field_1_blipTypeWin32;
    private byte field_2_blipTypeMacOS;
    private Byte[] field_3_uid;
    private short field_4_tag;
    private int field_5_size;
    private int field_6_ref;
    private int field_7_offset;
    private byte field_8_usage;
    private byte field_9_name;
    private byte field_10_unused2;
    private byte field_11_unused3;
    private EscherBlipRecord field_12_blipRecord;
    private Byte[] _remainingData;
    public int RecordSize { get; }
    public string RecordName { get; }
    public byte BlipTypeWin32 { get; public set; }
    public byte BlipTypeMacOS { get; public set; }
    public Byte[] UID { get; public set; }
    public short Tag { get; public set; }
    public int Size { get; public set; }
    public int Ref { get; public set; }
    public int Offset { get; public set; }
    public byte Usage { get; public set; }
    public byte Name { get; public set; }
    public byte Unused2 { get; public set; }
    public byte Unused3 { get; public set; }
    public EscherBlipRecord BlipRecord { get; public set; }
    public Byte[] RemainingData { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual string get_RecordName();
    public byte get_BlipTypeWin32();
    public void set_BlipTypeWin32(byte value);
    public byte get_BlipTypeMacOS();
    public void set_BlipTypeMacOS(byte value);
    public Byte[] get_UID();
    public void set_UID(Byte[] value);
    public short get_Tag();
    public void set_Tag(short value);
    public int get_Size();
    public void set_Size(int value);
    public int get_Ref();
    public void set_Ref(int value);
    public int get_Offset();
    public void set_Offset(int value);
    public byte get_Usage();
    public void set_Usage(byte value);
    public byte get_Name();
    public void set_Name(byte value);
    public byte get_Unused2();
    public void set_Unused2(byte value);
    public byte get_Unused3();
    public void set_Unused3(byte value);
    public EscherBlipRecord get_BlipRecord();
    public void set_BlipRecord(EscherBlipRecord value);
    public Byte[] get_RemainingData();
    public void set_RemainingData(Byte[] value);
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public string GetBlipType(byte b);
}
public class NPOI.DDF.EscherChildAnchorRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    private int field_1_dx1;
    private int field_2_dy1;
    private int field_3_dx2;
    private int field_4_dy2;
    public int RecordSize { get; }
    public short RecordId { get; }
    public string RecordName { get; }
    public int Dx1 { get; public set; }
    public int Dy1 { get; public set; }
    public int Dx2 { get; public set; }
    public int Dy2 { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public int get_Dx1();
    public void set_Dx1(int value);
    public int get_Dy1();
    public void set_Dy1(int value);
    public int get_Dx2();
    public void set_Dx2(int value);
    public int get_Dy2();
    public void set_Dy2(int value);
}
public class NPOI.DDF.EscherClientAnchorRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    private short field_1_flag;
    private short field_2_col1;
    private short field_3_dx1;
    private short field_4_row1;
    private short field_5_dy1;
    private short field_6_col2;
    private short field_7_dx2;
    private short field_8_row2;
    private short field_9_dy2;
    private Byte[] remainingData;
    private bool shortRecord;
    public int RecordSize { get; }
    public short RecordId { get; }
    public string RecordName { get; }
    public short Flag { get; public set; }
    public short Col1 { get; public set; }
    public short Dx1 { get; public set; }
    public short Row1 { get; public set; }
    public short Dy1 { get; public set; }
    public short Col2 { get; public set; }
    public short Dx2 { get; public set; }
    public short Row2 { get; public set; }
    public short Dy2 { get; public set; }
    public Byte[] RemainingData { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public short get_Flag();
    public void set_Flag(short value);
    public short get_Col1();
    public void set_Col1(short value);
    public short get_Dx1();
    public void set_Dx1(short value);
    public short get_Row1();
    public void set_Row1(short value);
    public short get_Dy1();
    public void set_Dy1(short value);
    public short get_Col2();
    public void set_Col2(short value);
    public short get_Dx2();
    public void set_Dx2(short value);
    public short get_Row2();
    public void set_Row2(short value);
    public short get_Dy2();
    public void set_Dy2(short value);
    public Byte[] get_RemainingData();
    public void set_RemainingData(Byte[] value);
}
public class NPOI.DDF.EscherClientDataRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    private Byte[] remainingData;
    public int RecordSize { get; }
    public short RecordId { get; }
    public string RecordName { get; }
    public Byte[] RemainingData { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public Byte[] get_RemainingData();
    public void set_RemainingData(Byte[] value);
}
public class NPOI.DDF.EscherColorRef : object {
    private int opid;
    private int colorRef;
    private static BitField FLAG_SYS_INDEX;
    private static BitField FLAG_SCHEME_INDEX;
    private static BitField FLAG_SYSTEM_RGB;
    private static BitField FLAG_PALETTE_RGB;
    private static BitField FLAG_PALETTE_INDEX;
    private static BitField FLAG_BLUE;
    private static BitField FLAG_GREEN;
    private static BitField FLAG_RED;
    public EscherColorRef(int colorRef);
    public EscherColorRef(Byte[] source, int start, int len);
    private static EscherColorRef();
    public bool HasSysIndexFlag();
    public void SetSysIndexFlag(bool flag);
    public bool HasSchemeIndexFlag();
    public void SetSchemeIndexFlag(bool flag);
    public bool HasSystemRGBFlag();
    public void SetSystemRGBFlag(bool flag);
    public bool HasPaletteRGBFlag();
    public void SetPaletteRGBFlag(bool flag);
    public bool HasPaletteIndexFlag();
    public void SetPaletteIndexFlag(bool flag);
    public Int32[] GetRGB();
    public SysIndexSource GetSysIndexSource();
    public SysIndexProcedure GetSysIndexProcedure();
    public int GetSysIndexInvert();
    public int GetSchemeIndex();
    public int GetPaletteIndex();
}
public class NPOI.DDF.EscherComplexProperty : EscherProperty {
    private Byte[] _complexData;
    public Byte[] ComplexData { get; }
    public int PropertySize { get; }
    public EscherComplexProperty(short id, Byte[] complexData);
    public EscherComplexProperty(short propertyNumber, bool isBlipId, Byte[] complexData);
    public virtual int SerializeSimplePart(Byte[] data, int pos);
    public virtual int SerializeComplexPart(Byte[] data, int pos);
    public Byte[] get_ComplexData();
    protected void ResizeComplexData(int newSize, int bytesToKeep);
    public virtual bool Equals(object o);
    public virtual int get_PropertySize();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string ToXml(string tab);
}
public class NPOI.DDF.EscherContainerRecord : EscherRecord {
    public static short DGG_CONTAINER;
    public static short BSTORE_CONTAINER;
    public static short DG_CONTAINER;
    public static short SPGR_CONTAINER;
    public static short SP_CONTAINER;
    public static short SOLVER_CONTAINER;
    private static POILogger log;
    private int _remainingLength;
    private List`1<EscherRecord> _childRecords;
    public int RecordSize { get; }
    public List`1<EscherRecord> ChildRecords { get; public set; }
    public IList`1<EscherContainerRecord> ChildContainers { get; }
    public string RecordName { get; }
    private static EscherContainerRecord();
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public bool HasChildOfType(short recordId);
    public virtual List`1<EscherRecord> get_ChildRecords();
    public virtual void set_ChildRecords(List`1<EscherRecord> value);
    public bool RemoveChildRecord(EscherRecord toBeRemoved);
    public Enumerator<EscherRecord> GetChildIterator();
    public IList`1<EscherContainerRecord> get_ChildContainers();
    public virtual string get_RecordName();
    public virtual void Display(int indent);
    public void AddChildRecord(EscherRecord record);
    public void AddChildBefore(EscherRecord record, int insertBeforeRecordId);
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public EscherRecord GetChildById(short recordId);
    public void GetRecordsById(short recordId, ArrayList& out1);
}
public class NPOI.DDF.EscherDggRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    private int field_1_shapeIdMax;
    private int field_3_numShapesSaved;
    private int field_4_drawingsSaved;
    private FileIdCluster[] field_5_fileIdClusters;
    private int maxDgId;
    public int RecordSize { get; }
    public short RecordId { get; }
    public string RecordName { get; }
    public int ShapeIdMax { get; public set; }
    public int NumIdClusters { get; }
    public int NumShapesSaved { get; public set; }
    public int DrawingsSaved { get; public set; }
    public int MaxDrawingGroupId { get; public set; }
    public FileIdCluster[] FileIdClusters { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public int get_ShapeIdMax();
    public void set_ShapeIdMax(int value);
    public int get_NumIdClusters();
    public int get_NumShapesSaved();
    public void set_NumShapesSaved(int value);
    public int get_DrawingsSaved();
    public void set_DrawingsSaved(int value);
    public int get_MaxDrawingGroupId();
    public void set_MaxDrawingGroupId(int value);
    public FileIdCluster[] get_FileIdClusters();
    public void set_FileIdClusters(FileIdCluster[] value);
    public void AddCluster(int dgId, int numShapedUsed);
    public void AddCluster(int dgId, int numShapedUsed, bool sort);
    public static void InsertionSort(List`1<T> list, IComparer`1<T> comparison);
}
public class NPOI.DDF.EscherDgRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    private int field_1_numShapes;
    private int field_2_lastMSOSPID;
    public int RecordSize { get; }
    public short RecordId { get; }
    public string RecordName { get; }
    public int NumShapes { get; public set; }
    public int LastMSOSPID { get; public set; }
    public short DrawingGroupId { get; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public int get_NumShapes();
    public void set_NumShapes(int value);
    public int get_LastMSOSPID();
    public void set_LastMSOSPID(int value);
    public short get_DrawingGroupId();
    public void IncrementShapeCount();
}
public class NPOI.DDF.EscherDump : object {
    public void Dump(Byte[] data, int offset, int size);
    public void DumpOld(long maxLength, Stream in1);
    private string PropertyName(short propertyId);
    private string GetBlipType(byte b);
    private string Dec1616(int n32);
    private void OutHex(int bytes, Stream in1);
    public void Dump(int recordSize, Byte[] data);
}
public class NPOI.DDF.EscherMetafileBlip : EscherBlipRecord {
    private static POILogger log;
    public static short RECORD_ID_EMF;
    public static short RECORD_ID_WMF;
    public static short RECORD_ID_PICT;
    public static short SIGNATURE_EMF;
    public static short SIGNATURE_WMF;
    public static short SIGNATURE_PICT;
    private static int HEADER_SIZE;
    private Byte[] field_1_UID;
    private Byte[] field_2_UID;
    private int field_2_cb;
    private int field_3_rcBounds_x1;
    private int field_3_rcBounds_y1;
    private int field_3_rcBounds_x2;
    private int field_3_rcBounds_y2;
    private int field_4_ptSize_w;
    private int field_4_ptSize_h;
    private int field_5_cbSave;
    private byte field_6_fCompression;
    private byte field_7_fFilter;
    private Byte[] raw_pictureData;
    private Byte[] remainingData;
    public int RecordSize { get; }
    public Byte[] UID { get; public set; }
    public Byte[] PrimaryUID { get; public set; }
    public int UncompressedSize { get; public set; }
    public Rectangle Bounds { get; public set; }
    public Size SizeEMU { get; public set; }
    public int CompressedSize { get; public set; }
    public bool IsCompressed { get; public set; }
    public Byte[] RemainingData { get; }
    public short Signature { get; }
    public byte Filter { get; public set; }
    private static EscherMetafileBlip();
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    private static Byte[] InflatePictureData(Byte[] data);
    public virtual int get_RecordSize();
    public Byte[] get_UID();
    public void set_UID(Byte[] value);
    public Byte[] get_PrimaryUID();
    public void set_PrimaryUID(Byte[] value);
    public int get_UncompressedSize();
    public void set_UncompressedSize(int value);
    public Rectangle get_Bounds();
    public void set_Bounds(Rectangle value);
    public Size get_SizeEMU();
    public void set_SizeEMU(Size value);
    public int get_CompressedSize();
    public void set_CompressedSize(int value);
    public bool get_IsCompressed();
    public void set_IsCompressed(bool value);
    public Byte[] get_RemainingData();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public short get_Signature();
    public void SetPictureData(Byte[] pictureData);
    public byte get_Filter();
    public void set_Filter(byte value);
}
public class NPOI.DDF.EscherOptRecord : AbstractEscherOptRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    public short Instance { get; }
    internal short Options { get; }
    public string RecordName { get; }
    public short Version { get; public set; }
    public virtual short get_Instance();
    internal virtual short get_Options();
    public virtual string get_RecordName();
    public virtual short get_Version();
    public virtual void set_Version(short value);
    public virtual string ToXml(string tab);
}
public class NPOI.DDF.EscherPictBlip : EscherBlipRecord {
    private static POILogger log;
    public static short RECORD_ID_EMF;
    public static short RECORD_ID_WMF;
    public static short RECORD_ID_PICT;
    private static int HEADER_SIZE;
    private Byte[] field_1_UID;
    private int field_2_cb;
    private int field_3_rcBounds_x1;
    private int field_3_rcBounds_y1;
    private int field_3_rcBounds_x2;
    private int field_3_rcBounds_y2;
    private int field_4_ptSize_w;
    private int field_4_ptSize_h;
    private int field_5_cbSave;
    private byte field_6_fCompression;
    private byte field_7_fFilter;
    private Byte[] raw_pictureData;
    public int RecordSize { get; }
    public Byte[] UID { get; public set; }
    public int UncompressedSize { get; public set; }
    public Rectangle Bounds { get; public set; }
    public Size SizeEMU { get; public set; }
    public int CompressedSize { get; public set; }
    public bool IsCompressed { get; public set; }
    private static EscherPictBlip();
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    private static Byte[] InflatePictureData(Byte[] data);
    public virtual int get_RecordSize();
    public Byte[] get_UID();
    public void set_UID(Byte[] value);
    public int get_UncompressedSize();
    public void set_UncompressedSize(int value);
    public Rectangle get_Bounds();
    public void set_Bounds(Rectangle value);
    public Size get_SizeEMU();
    public void set_SizeEMU(Size value);
    public int get_CompressedSize();
    public void set_CompressedSize(int value);
    public bool get_IsCompressed();
    public void set_IsCompressed(bool value);
    public virtual string ToString();
    public virtual string ToXml(string tab);
}
public class NPOI.DDF.EscherProperties : object {
    public static short TRANSFORM__ROTATION;
    public static short PROTECTION__LOCKROTATION;
    public static short PROTECTION__LOCKASPECTRATIO;
    public static short PROTECTION__LOCKPOSITION;
    public static short PROTECTION__LOCKAGAINSTSELECT;
    public static short PROTECTION__LOCKCROPPING;
    public static short PROTECTION__LOCKVERTICES;
    public static short PROTECTION__LOCKTEXT;
    public static short PROTECTION__LOCKADJUSTHANDLES;
    public static short PROTECTION__LOCKAGAINSTGROUPING;
    public static short TEXT__TEXTID;
    public static short TEXT__TEXTLEFT;
    public static short TEXT__TEXTTOP;
    public static short TEXT__TEXTRIGHT;
    public static short TEXT__TEXTBOTTOM;
    public static short TEXT__WRAPTEXT;
    public static short TEXT__SCALETEXT;
    public static short TEXT__ANCHORTEXT;
    public static short TEXT__TEXTFLOW;
    public static short TEXT__FONTROTATION;
    public static short TEXT__IDOFNEXTSHAPE;
    public static short TEXT__BIDIR;
    public static short TEXT__SINGLECLICKSELECTS;
    public static short TEXT__USEHOSTMARGINS;
    public static short TEXT__ROTATETEXTWITHSHAPE;
    public static short TEXT__SIZESHAPETOFITTEXT;
    public static short TEXT__SIZE_TEXT_TO_FIT_SHAPE;
    public static short GEOTEXT__UNICODE;
    public static short GEOTEXT__RTFTEXT;
    public static short GEOTEXT__ALIGNMENTONCURVE;
    public static short GEOTEXT__DEFAULTPOINTSIZE;
    public static short GEOTEXT__TEXTSPACING;
    public static short GEOTEXT__FONTFAMILYNAME;
    public static short GEOTEXT__REVERSEROWORDER;
    public static short GEOTEXT__HASTEXTEFFECT;
    public static short GEOTEXT__ROTATECHARACTERS;
    public static short GEOTEXT__KERNCHARACTERS;
    public static short GEOTEXT__TIGHTORTRACK;
    public static short GEOTEXT__STRETCHTOFITSHAPE;
    public static short GEOTEXT__CHARBOUNDINGBOX;
    public static short GEOTEXT__SCALETEXTONPATH;
    public static short GEOTEXT__STRETCHCHARHEIGHT;
    public static short GEOTEXT__NOMEASUREALONGPATH;
    public static short GEOTEXT__BOLDFONT;
    public static short GEOTEXT__ITALICFONT;
    public static short GEOTEXT__UNDERLINEFONT;
    public static short GEOTEXT__SHADOWFONT;
    public static short GEOTEXT__SMALLCAPSFONT;
    public static short GEOTEXT__STRIKETHROUGHFONT;
    public static short BLIP__CROPFROMTOP;
    public static short BLIP__CROPFROMBOTTOM;
    public static short BLIP__CROPFROMLEFT;
    public static short BLIP__CROPFROMRIGHT;
    public static short BLIP__BLIPTODISPLAY;
    public static short BLIP__BLIPFILENAME;
    public static short BLIP__BLIPFLAGS;
    public static short BLIP__TRANSPARENTCOLOR;
    public static short BLIP__CONTRASTSetTING;
    public static short BLIP__BRIGHTNESSSetTING;
    public static short BLIP__GAMMA;
    public static short BLIP__PICTUREID;
    public static short BLIP__DOUBLEMOD;
    public static short BLIP__PICTUREFillMOD;
    public static short BLIP__PICTURELINE;
    public static short BLIP__PRINTBLIP;
    public static short BLIP__PRINTBLIPFILENAME;
    public static short BLIP__PRINTFLAGS;
    public static short BLIP__NOHITTESTPICTURE;
    public static short BLIP__PICTUREGRAY;
    public static short BLIP__PICTUREBILEVEL;
    public static short BLIP__PICTUREACTIVE;
    public static short GEOMETRY__LEFT;
    public static short GEOMETRY__TOP;
    public static short GEOMETRY__RIGHT;
    public static short GEOMETRY__BOTTOM;
    public static short GEOMETRY__SHAPEPATH;
    public static short GEOMETRY__VERTICES;
    public static short GEOMETRY__SEGMENTINFO;
    public static short GEOMETRY__ADJUSTVALUE;
    public static short GEOMETRY__ADJUST2VALUE;
    public static short GEOMETRY__ADJUST3VALUE;
    public static short GEOMETRY__ADJUST4VALUE;
    public static short GEOMETRY__ADJUST5VALUE;
    public static short GEOMETRY__ADJUST6VALUE;
    public static short GEOMETRY__ADJUST7VALUE;
    public static short GEOMETRY__ADJUST8VALUE;
    public static short GEOMETRY__ADJUST9VALUE;
    public static short GEOMETRY__ADJUST10VALUE;
    public static short GEOMETRY__SHADOWok;
    public static short GEOMETRY__3DOK;
    public static short GEOMETRY__LINEOK;
    public static short GEOMETRY__GEOTEXTOK;
    public static short GEOMETRY__FILLSHADESHAPEOK;
    public static short GEOMETRY__FILLOK;
    public static short FILL__FILLTYPE;
    public static short FILL__FILLCOLOR;
    public static short FILL__FILLOPACITY;
    public static short FILL__FILLBACKCOLOR;
    public static short FILL__BACKOPACITY;
    public static short FILL__CRMOD;
    public static short FILL__PATTERNTEXTURE;
    public static short FILL__BLIPFILENAME;
    public static short FILL__BLIPFLAGS;
    public static short FILL__WIDTH;
    public static short FILL__HEIGHT;
    public static short FILL__ANGLE;
    public static short FILL__FOCUS;
    public static short FILL__TOLEFT;
    public static short FILL__TOTOP;
    public static short FILL__TORIGHT;
    public static short FILL__TOBOTTOM;
    public static short FILL__RECTLEFT;
    public static short FILL__RECTTOP;
    public static short FILL__RECTRIGHT;
    public static short FILL__RECTBOTTOM;
    public static short FILL__DZTYPE;
    public static short FILL__SHADEPRESet;
    public static short FILL__SHADECOLORS;
    public static short FILL__ORIGINX;
    public static short FILL__ORIGINY;
    public static short FILL__SHAPEORIGINX;
    public static short FILL__SHAPEORIGINY;
    public static short FILL__SHADETYPE;
    public static short FILL__FILLED;
    public static short FILL__HITTESTFILL;
    public static short FILL__SHAPE;
    public static short FILL__USERECT;
    public static short FILL__NOFILLHITTEST;
    public static short LINESTYLE__COLOR;
    public static short LINESTYLE__OPACITY;
    public static short LINESTYLE__BACKCOLOR;
    public static short LINESTYLE__CRMOD;
    public static short LINESTYLE__LINETYPE;
    public static short LINESTYLE__FILLBLIP;
    public static short LINESTYLE__FILLBLIPNAME;
    public static short LINESTYLE__FILLBLIPFLAGS;
    public static short LINESTYLE__FILLWIDTH;
    public static short LINESTYLE__FILLHEIGHT;
    public static short LINESTYLE__FILLDZTYPE;
    public static short LINESTYLE__LINEWIDTH;
    public static short LINESTYLE__LINEMITERLIMIT;
    public static short LINESTYLE__LINESTYLE;
    public static short LINESTYLE__LINEDASHING;
    public static short LINESTYLE__LINEDASHSTYLE;
    public static short LINESTYLE__LINESTARTARROWHEAD;
    public static short LINESTYLE__LINEENDARROWHEAD;
    public static short LINESTYLE__LINESTARTARROWWIDTH;
    public static short LINESTYLE__LINESTARTARROWLENGTH;
    public static short LINESTYLE__LINEENDARROWWIDTH;
    public static short LINESTYLE__LINEENDARROWLength;
    public static short LINESTYLE__LINEJOINSTYLE;
    public static short LINESTYLE__LINEENDCAPSTYLE;
    public static short LINESTYLE__ARROWHEADSOK;
    public static short LINESTYLE__ANYLINE;
    public static short LINESTYLE__HITLINETEST;
    public static short LINESTYLE__LINEFILLSHAPE;
    public static short LINESTYLE__NOLINEDRAWDASH;
    public static short LINESTYLE__NOLINEDRAWDASH_LEFT;
    public static short LINESTYLE__NOLINEDRAWDASH_TOP;
    public static short LINESTYLE__NOLINEDRAWDASH_BOTTOM;
    public static short LINESTYLE__NOLINEDRAWDASH_RIGHT;
    public static short SHADOWSTYLE__TYPE;
    public static short SHADOWSTYLE__COLOR;
    public static short SHADOWSTYLE__HIGHLIGHT;
    public static short SHADOWSTYLE__CRMOD;
    public static short SHADOWSTYLE__OPACITY;
    public static short SHADOWSTYLE__OFFSetX;
    public static short SHADOWSTYLE__OFFSetY;
    public static short SHADOWSTYLE__SECONDOFFSetX;
    public static short SHADOWSTYLE__SECONDOFFSetY;
    public static short SHADOWSTYLE__SCALEXTOX;
    public static short SHADOWSTYLE__SCALEYTOX;
    public static short SHADOWSTYLE__SCALEXTOY;
    public static short SHADOWSTYLE__SCALEYTOY;
    public static short SHADOWSTYLE__PERSPECTIVEX;
    public static short SHADOWSTYLE__PERSPECTIVEY;
    public static short SHADOWSTYLE__WEIGHT;
    public static short SHADOWSTYLE__ORIGINX;
    public static short SHADOWSTYLE__ORIGINY;
    public static short SHADOWSTYLE__SHADOW;
    public static short SHADOWSTYLE__SHADOWOBSURED;
    public static short PERSPECTIVE__TYPE;
    public static short PERSPECTIVE__OFFSetX;
    public static short PERSPECTIVE__OFFSetY;
    public static short PERSPECTIVE__SCALEXTOX;
    public static short PERSPECTIVE__SCALEYTOX;
    public static short PERSPECTIVE__SCALEXTOY;
    public static short PERSPECTIVE__SCALEYTOY;
    public static short PERSPECTIVE__PERSPECTIVEX;
    public static short PERSPECTIVE__PERSPECTIVEY;
    public static short PERSPECTIVE__WEIGHT;
    public static short PERSPECTIVE__ORIGINX;
    public static short PERSPECTIVE__ORIGINY;
    public static short PERSPECTIVE__PERSPECTIVEON;
    public static short THREED__SPECULARAMOUNT;
    public static short THREED__DIFFUSEAMOUNT;
    public static short THREED__SHININESS;
    public static short THREED__EDGetHICKNESS;
    public static short THREED__EXTRUDEFORWARD;
    public static short THREED__EXTRUDEBACKWARD;
    public static short THREED__EXTRUDEPLANE;
    public static short THREED__EXTRUSIONCOLOR;
    public static short THREED__CRMOD;
    public static short THREED__3DEFFECT;
    public static short THREED__METALLIC;
    public static short THREED__USEEXTRUSIONCOLOR;
    public static short THREED__LIGHTFACE;
    public static short THREEDSTYLE__YROTATIONANGLE;
    public static short THREEDSTYLE__XROTATIONANGLE;
    public static short THREEDSTYLE__ROTATIONAXISX;
    public static short THREEDSTYLE__ROTATIONAXISY;
    public static short THREEDSTYLE__ROTATIONAXISZ;
    public static short THREEDSTYLE__ROTATIONANGLE;
    public static short THREEDSTYLE__ROTATIONCENTERX;
    public static short THREEDSTYLE__ROTATIONCENTERY;
    public static short THREEDSTYLE__ROTATIONCENTERZ;
    public static short THREEDSTYLE__RENDERMODE;
    public static short THREEDSTYLE__TOLERANCE;
    public static short THREEDSTYLE__XVIEWPOINT;
    public static short THREEDSTYLE__YVIEWPOINT;
    public static short THREEDSTYLE__ZVIEWPOINT;
    public static short THREEDSTYLE__ORIGINX;
    public static short THREEDSTYLE__ORIGINY;
    public static short THREEDSTYLE__SKEWANGLE;
    public static short THREEDSTYLE__SKEWAMOUNT;
    public static short THREEDSTYLE__AMBIENTINTENSITY;
    public static short THREEDSTYLE__KEYX;
    public static short THREEDSTYLE__KEYY;
    public static short THREEDSTYLE__KEYZ;
    public static short THREEDSTYLE__KEYINTENSITY;
    public static short THREEDSTYLE__FillX;
    public static short THREEDSTYLE__FillY;
    public static short THREEDSTYLE__FillZ;
    public static short THREEDSTYLE__FillINTENSITY;
    public static short THREEDSTYLE__CONSTRAINROTATION;
    public static short THREEDSTYLE__ROTATIONCENTERAUTO;
    public static short THREEDSTYLE__PARALLEL;
    public static short THREEDSTYLE__KEYHARSH;
    public static short THREEDSTYLE__FillHARSH;
    public static short SHAPE__MASTER;
    public static short SHAPE__CONNECTORSTYLE;
    public static short SHAPE__BLACKANDWHITESetTINGS;
    public static short SHAPE__WMODEPUREBW;
    public static short SHAPE__WMODEBW;
    public static short SHAPE__OLEICON;
    public static short SHAPE__PREFERRELATIVERESIZE;
    public static short SHAPE__LOCKSHAPETYPE;
    public static short SHAPE__DELETEATTACHEDOBJECT;
    public static short SHAPE__BACKGROUNDSHAPE;
    public static short CALLOUT__CALLOUTTYPE;
    public static short CALLOUT__XYCALLOUTGAP;
    public static short CALLOUT__CALLOUTANGLE;
    public static short CALLOUT__CALLOUTDROPTYPE;
    public static short CALLOUT__CALLOUTDROPSPECIFIED;
    public static short CALLOUT__CALLOUTLENGTHSPECIFIED;
    public static short CALLOUT__ISCALLOUT;
    public static short CALLOUT__CALLOUTACCENTBAR;
    public static short CALLOUT__CALLOUTTEXTBORDER;
    public static short CALLOUT__CALLOUTMINUSX;
    public static short CALLOUT__CALLOUTMINUSY;
    public static short CALLOUT__DROPAUTO;
    public static short CALLOUT__LENGTHSPECIFIED;
    public static short GROUPSHAPE__SHAPENAME;
    public static short GROUPSHAPE__DESCRIPTION;
    public static short GROUPSHAPE__HYPERLINK;
    public static short GROUPSHAPE__WRAPPOLYGONVERTICES;
    public static short GROUPSHAPE__WRAPDISTLEFT;
    public static short GROUPSHAPE__WRAPDISTTOP;
    public static short GROUPSHAPE__WRAPDISTRIGHT;
    public static short GROUPSHAPE__WRAPDISTBOTTOM;
    public static short GROUPSHAPE__REGROUPID;
    public static short GROUPSHAPE__UNUSED906;
    public static short GROUPSHAPE__TOOLTIP;
    public static short GROUPSHAPE__SCRIPT;
    public static short GROUPSHAPE__POSH;
    public static short GROUPSHAPE__POSRELH;
    public static short GROUPSHAPE__POSV;
    public static short GROUPSHAPE__POSRELV;
    public static short GROUPSHAPE__HR_PCT;
    public static short GROUPSHAPE__HR_ALIGN;
    public static short GROUPSHAPE__HR_HEIGHT;
    public static short GROUPSHAPE__HR_WIDTH;
    public static short GROUPSHAPE__SCRIPTEXT;
    public static short GROUPSHAPE__SCRIPTLANG;
    public static short GROUPSHAPE__BORDERTOPCOLOR;
    public static short GROUPSHAPE__BORDERLEFTCOLOR;
    public static short GROUPSHAPE__BORDERBOTTOMCOLOR;
    public static short GROUPSHAPE__BORDERRIGHTCOLOR;
    public static short GROUPSHAPE__TABLEPROPERTIES;
    public static short GROUPSHAPE__TABLEROWPROPERTIES;
    public static short GROUPSHAPE__WEBBOT;
    public static short GROUPSHAPE__METROBLOB;
    public static short GROUPSHAPE__ZORDER;
    public static short GROUPSHAPE__FLAGS;
    public static short GROUPSHAPE__EDITEDWRAP;
    public static short GROUPSHAPE__BEHINDDOCUMENT;
    public static short GROUPSHAPE__ONDBLCLICKNOTIFY;
    public static short GROUPSHAPE__ISBUTTON;
    public static short GROUPSHAPE__1DADJUSTMENT;
    public static short GROUPSHAPE__HIDDEN;
    public static short GROUPSHAPE__PRINT;
    private static Hashtable properties;
    private static void InitProps();
    private static void AddProp(int s, EscherPropertyMetaData data);
    private static EscherPropertyMetaData GetData(string propName, byte type);
    private static EscherPropertyMetaData GetData(string propName);
    public static string GetPropertyName(short propertyId);
    public static byte GetPropertyType(short propertyId);
}
public abstract class NPOI.DDF.EscherProperty : object {
    protected short id;
    public short Id { get; }
    public short PropertyNumber { get; }
    public bool IsComplex { get; }
    public bool IsBlipId { get; }
    public string Name { get; }
    public int PropertySize { get; }
    public EscherProperty(short id);
    public EscherProperty(short propertyNumber, bool isComplex, bool isBlipId);
    public virtual short get_Id();
    public virtual short get_PropertyNumber();
    public virtual bool get_IsComplex();
    public virtual bool get_IsBlipId();
    public virtual string get_Name();
    public virtual int get_PropertySize();
    public virtual string ToXml(string tab);
    public abstract virtual int SerializeSimplePart(Byte[] data, int pos);
    public abstract virtual int SerializeComplexPart(Byte[] data, int pos);
}
public class NPOI.DDF.EscherPropertyFactory : object {
    public List`1<EscherProperty> CreateProperties(Byte[] data, int offset, short numProperties);
}
public class NPOI.DDF.EscherPropertyMetaData : object {
    public static byte TYPE_UNKNOWN;
    public static byte TYPE_BOOL;
    public static byte TYPE_RGB;
    public static byte TYPE_SHAPEPATH;
    public static byte TYPE_SIMPLE;
    public static byte TYPE_ARRAY;
    private string description;
    private byte type;
    public string Description { get; }
    public byte Type { get; }
    public EscherPropertyMetaData(string description);
    public EscherPropertyMetaData(string description, byte type);
    public string get_Description();
    public byte get_Type();
}
public abstract class NPOI.DDF.EscherRecord : object {
    private static BitField fInstance;
    private static BitField fVersion;
    private short _options;
    private short _recordId;
    public bool IsContainerRecord { get; }
    internal short Options { get; internal set; }
    public int RecordSize { get; }
    public short RecordId { get; public set; }
    public List`1<EscherRecord> ChildRecords { get; public set; }
    public string RecordName { get; }
    public short Instance { get; public set; }
    public short Version { get; public set; }
    private static EscherRecord();
    public int FillFields(Byte[] data, IEscherRecordFactory f);
    public abstract virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    protected int ReadHeader(Byte[] data, int offset);
    protected static short ReadInstance(Byte[] data, int offset);
    public bool get_IsContainerRecord();
    internal virtual short get_Options();
    internal virtual void set_Options(short value);
    public Byte[] Serialize();
    public int Serialize(int offset, Byte[] data);
    public abstract virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public abstract virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual void set_RecordId(short value);
    public virtual List`1<EscherRecord> get_ChildRecords();
    public virtual void set_ChildRecords(List`1<EscherRecord> value);
    public virtual object Clone();
    public EscherRecord GetChild(int index);
    public virtual void Display(int indent);
    public abstract virtual string get_RecordName();
    public virtual short get_Instance();
    public virtual void set_Instance(short value);
    public virtual short get_Version();
    public virtual void set_Version(short value);
    public virtual string ToXml(string tab);
    protected string FormatXmlRecordHeader(string className, string recordId, string version, string instance);
    public string ToXml();
}
public class NPOI.DDF.EscherRGBProperty : EscherSimpleProperty {
    public int RgbColor { get; }
    public byte Red { get; }
    public byte Green { get; }
    public byte Blue { get; }
    public EscherRGBProperty(short propertyNumber, int rgbColor);
    public int get_RgbColor();
    public byte get_Red();
    public byte get_Green();
    public byte get_Blue();
    public virtual string ToXml(string tab);
}
public interface NPOI.DDF.EscherSerializationListener {
    public abstract virtual void BeforeRecordSerialize(int offset, short recordId, EscherRecord record);
    public abstract virtual void AfterRecordSerialize(int offset, short recordId, int size, EscherRecord record);
}
public class NPOI.DDF.EscherShapePathProperty : EscherSimpleProperty {
    public static int LINE_OF_STRAIGHT_SEGMENTS;
    public static int CLOSED_POLYGON;
    public static int CURVES;
    public static int CLOSED_CURVES;
    public static int COMPLEX;
    public EscherShapePathProperty(short propertyNumber, int shapePath);
}
public class NPOI.DDF.EscherSimpleProperty : EscherProperty {
    private int propertyValue;
    public int PropertyValue { get; internal set; }
    public EscherSimpleProperty(short id, int propertyValue);
    public EscherSimpleProperty(short propertyNumber, bool isComplex, bool isBlipId, int propertyValue);
    public virtual int SerializeSimplePart(Byte[] data, int offset);
    public virtual int SerializeComplexPart(Byte[] data, int pos);
    public int get_PropertyValue();
    internal void set_PropertyValue(int value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string ToXml(string tab);
}
public class NPOI.DDF.EscherSpgrRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    private int field_1_rectX1;
    private int field_2_rectY1;
    private int field_3_rectX2;
    private int field_4_rectY2;
    public int RecordSize { get; }
    public short RecordId { get; }
    public string RecordName { get; }
    public int RectX1 { get; public set; }
    public int RectX2 { get; public set; }
    public int RectY1 { get; public set; }
    public int RectY2 { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public int get_RectX1();
    public void set_RectX1(int value);
    public int get_RectX2();
    public void set_RectX2(int value);
    public int get_RectY1();
    public void set_RectY1(int value);
    public int get_RectY2();
    public void set_RectY2(int value);
}
public class NPOI.DDF.EscherSplitMenuColorsRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    private int field_1_color1;
    private int field_2_color2;
    private int field_3_color3;
    private int field_4_color4;
    public int RecordSize { get; }
    public short RecordId { get; }
    public string RecordName { get; }
    public int Color1 { get; public set; }
    public int Color2 { get; public set; }
    public int Color3 { get; public set; }
    public int Color4 { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public int get_Color1();
    public void set_Color1(int value);
    public int get_Color2();
    public void set_Color2(int value);
    public int get_Color3();
    public void set_Color3(int value);
    public int get_Color4();
    public void set_Color4(int value);
}
public class NPOI.DDF.EscherSpRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    public static int FLAG_GROUP;
    public static int FLAG_CHILD;
    public static int FLAG_PATRIARCH;
    public static int FLAG_DELETED;
    public static int FLAG_OLESHAPE;
    public static int FLAG_HAVEMASTER;
    public static int FLAG_FLIPHORIZ;
    public static int FLAG_FLIPVERT;
    public static int FLAG_CONNECTOR;
    public static int FLAG_HAVEANCHOR;
    public static int FLAG_BACKGROUND;
    public static int FLAG_HASSHAPETYPE;
    private int field_1_shapeId;
    private int field_2_flags;
    public int RecordSize { get; }
    public short RecordId { get; }
    public string RecordName { get; }
    public int ShapeId { get; public set; }
    public int Flags { get; public set; }
    public short ShapeType { get; public set; }
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public virtual int get_RecordSize();
    public virtual short get_RecordId();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    private string DecodeFlags(int flags);
    public int get_ShapeId();
    public void set_ShapeId(int value);
    public int get_Flags();
    public void set_Flags(int value);
    public short get_ShapeType();
    public void set_ShapeType(short value);
}
public class NPOI.DDF.EscherTertiaryOptRecord : AbstractEscherOptRecord {
    public static short RECORD_ID;
    public string RecordName { get; }
    public virtual string get_RecordName();
}
public class NPOI.DDF.EscherTextboxRecord : EscherRecord {
    public static short RECORD_ID;
    public static string RECORD_DESCRIPTION;
    private static Byte[] NO_BYTES;
    private Byte[] _thedata;
    public Byte[] Data { get; }
    public int RecordSize { get; }
    public string RecordName { get; }
    private static EscherTextboxRecord();
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public Byte[] get_Data();
    public void SetData(Byte[] b, int start, int length);
    public void SetData(Byte[] b);
    public virtual int get_RecordSize();
    public virtual string get_RecordName();
    public virtual object Clone();
    public virtual string ToString();
    public virtual string ToXml(string tab);
}
public interface NPOI.DDF.IEscherRecordFactory {
    public abstract virtual EscherRecord CreateRecord(Byte[] data, int offset);
}
public class NPOI.DDF.NullEscherSerializationListener : object {
    public sealed virtual void BeforeRecordSerialize(int offset, short recordId, EscherRecord record);
    public sealed virtual void AfterRecordSerialize(int offset, short recordId, int size, EscherRecord record);
}
public class NPOI.DDF.SysIndexProcedure : object {
    public static SysIndexProcedure DARKEN_COLOR;
    public static SysIndexProcedure LIGHTEN_COLOR;
    public static SysIndexProcedure ADD_GRAY_LEVEL;
    public static SysIndexProcedure SUB_GRAY_LEVEL;
    public static SysIndexProcedure REVERSE_GRAY_LEVEL;
    public static SysIndexProcedure THRESHOLD;
    public static SysIndexProcedure INVERT_AFTER;
    public static SysIndexProcedure INVERT_HIGHBIT_AFTER;
    internal BitField mask;
    internal SysIndexProcedure(int mask);
    private static SysIndexProcedure();
    internal static SysIndexProcedure[] Values();
}
public class NPOI.DDF.SysIndexSource : object {
    private int opid;
    private int colorRef;
    public static SysIndexSource FILL_COLOR;
    public static SysIndexSource LINE_OR_FILL_COLOR;
    public static SysIndexSource LINE_COLOR;
    public static SysIndexSource SHADOW_COLOR;
    public static SysIndexSource CURRENT_OR_LAST_COLOR;
    public static SysIndexSource FILL_BACKGROUND_COLOR;
    public static SysIndexSource LINE_BACKGROUND_COLOR;
    public static SysIndexSource FILL_OR_LINE_COLOR;
    internal int value;
    internal SysIndexSource(int value);
    private static SysIndexSource();
    internal static SysIndexSource[] Values();
}
public class NPOI.DDF.UnknownEscherRecord : EscherRecord {
    private static Byte[] NO_BYTES;
    private Byte[] _thedata;
    private List`1<EscherRecord> _childRecords;
    public Byte[] Data { get; }
    public int RecordSize { get; }
    public List`1<EscherRecord> ChildRecords { get; public set; }
    public string RecordName { get; }
    private static UnknownEscherRecord();
    public virtual int FillFields(Byte[] data, int offset, IEscherRecordFactory recordFactory);
    public virtual int Serialize(int offset, Byte[] data, EscherSerializationListener listener);
    public Byte[] get_Data();
    public virtual int get_RecordSize();
    public virtual List`1<EscherRecord> get_ChildRecords();
    public virtual void set_ChildRecords(List`1<EscherRecord> value);
    public virtual object Clone();
    public virtual string get_RecordName();
    public virtual string ToString();
    public virtual string ToXml(string tab);
    public void AddChildRecord(EscherRecord childRecord);
}
public class NPOI.EmptyFileException : IOException {
    private static long serialVersionUID;
    public EmptyFileException(string message, Exception innerException);
}
public class NPOI.EncryptedDocumentException : InvalidOperationException {
    public EncryptedDocumentException(string message);
    public EncryptedDocumentException(string message, Exception cause);
    public EncryptedDocumentException(Exception cause);
}
public class NPOI.HPSF.Array : object {
    private ArrayHeader _header;
    private TypedPropertyValue[] _values;
    public Array(Byte[] data, int offset);
    public int Read(Byte[] data, int startOffset);
}
internal class NPOI.HPSF.Blob : object {
    private Byte[] _value;
    public int Size { get; }
    public Blob(Byte[] data, int offset);
    public int get_Size();
}
public class NPOI.HPSF.ClipboardData : object {
    private int _format;
    private Byte[] _value;
    public int Size { get; }
    public Byte[] Value { get; }
    public ClipboardData(Byte[] data, int offset);
    public int get_Size();
    public Byte[] get_Value();
    public Byte[] ToByteArray();
    public int Write(Stream out1);
}
public class NPOI.HPSF.CodePageString : object {
    private Byte[] _value;
    public int Size { get; }
    public CodePageString(Byte[] data, int startOffset);
    public CodePageString(string aString, int codepage);
    public string GetJavaValue(int codepage);
    public int get_Size();
    public void SetJavaValue(string aString, int codepage);
    public int Write(Stream out1);
}
internal class NPOI.HPSF.Currency : object {
    public static int SIZE;
    private Byte[] _value;
    public Currency(Byte[] data, int offset);
}
[DefaultMemberAttribute("Item")]
public class NPOI.HPSF.CustomProperties : Hashtable {
    private Hashtable dictionaryIDToName;
    private Hashtable dictionaryNameToID;
    private bool isPure;
    public object Item { get; }
    public IDictionary Dictionary { get; }
    public int Codepage { get; public set; }
    public bool IsPure { get; public set; }
    public CustomProperty Put(string name, CustomProperty cp);
    public ICollection KeySet();
    public ICollection NameSet();
    public ICollection IdSet();
    private object Put(CustomProperty customProperty);
    public object Remove(string name);
    public object Put(string name, string value);
    public object Put(string name, long value);
    public object Put(string name, double value);
    public object Put(string name, int value);
    public object Put(string name, bool value);
    public object Put(string name, DateTime value);
    public object get_Item(string name);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public IDictionary get_Dictionary();
    public int get_Codepage();
    public void set_Codepage(int value);
    public bool get_IsPure();
    public void set_IsPure(bool value);
}
public class NPOI.HPSF.CustomProperty : MutableProperty {
    private string name;
    public string Name { get; public set; }
    public CustomProperty(Property property);
    public CustomProperty(Property property, string name);
    public string get_Name();
    public void set_Name(string value);
    public bool EqualsContents(object o);
    public virtual int GetHashCode();
}
internal class NPOI.HPSF.Date : object {
    public static int SIZE;
    private Byte[] _value;
    public Date(Byte[] data, int offset);
}
public class NPOI.HPSF.Decimal : object {
    public static int SIZE;
    private short field_1_wReserved;
    private byte field_2_scale;
    private byte field_3_sign;
    private int field_4_hi32;
    private long field_5_lo64;
    public Decimal(Byte[] data, int startOffset);
}
public class NPOI.HPSF.DocumentSummaryInformation : SpecialPropertySet {
    public static string DEFAULT_STREAM_NAME;
    public PropertyIDMap PropertySetIDMap { get; }
    public string Category { get; public set; }
    public string PresentationFormat { get; public set; }
    public int ByteCount { get; public set; }
    public int LineCount { get; public set; }
    public int ParCount { get; public set; }
    public int SlideCount { get; public set; }
    public int NoteCount { get; public set; }
    public int HiddenCount { get; public set; }
    public int MMClipCount { get; public set; }
    public bool Scale { get; public set; }
    public Byte[] HeadingPair { get; public set; }
    public Byte[] Docparts { get; public set; }
    public string Manager { get; public set; }
    public string Company { get; public set; }
    public bool LinksDirty { get; public set; }
    public int CharCountWithSpaces { get; public set; }
    public bool HyperlinksChanged { get; public set; }
    public int ApplicationVersion { get; public set; }
    public Byte[] VBADigitalSignature { get; public set; }
    public string ContentType { get; public set; }
    public string ContentStatus { get; public set; }
    public string Language { get; public set; }
    public string DocumentVersion { get; public set; }
    public CustomProperties CustomProperties { get; public set; }
    public DocumentSummaryInformation(PropertySet ps);
    public virtual PropertyIDMap get_PropertySetIDMap();
    public string get_Category();
    public void set_Category(string value);
    public void RemoveCategory();
    public string get_PresentationFormat();
    public void set_PresentationFormat(string value);
    public void RemovePresentationFormat();
    public int get_ByteCount();
    public void set_ByteCount(int value);
    public void RemoveByteCount();
    public int get_LineCount();
    public void set_LineCount(int value);
    public void RemoveLineCount();
    public int get_ParCount();
    public void set_ParCount(int value);
    public void RemoveParCount();
    public int get_SlideCount();
    public void set_SlideCount(int value);
    public void RemoveSlideCount();
    public int get_NoteCount();
    public void set_NoteCount(int value);
    public void RemoveNoteCount();
    public int get_HiddenCount();
    public void set_HiddenCount(int value);
    public void RemoveHiddenCount();
    public int get_MMClipCount();
    public void set_MMClipCount(int value);
    public void RemoveMMClipCount();
    public bool get_Scale();
    public void set_Scale(bool value);
    public void RemoveScale();
    public Byte[] get_HeadingPair();
    public void set_HeadingPair(Byte[] value);
    public void RemoveHeadingPair();
    public Byte[] get_Docparts();
    public void set_Docparts(Byte[] value);
    public void RemoveDocparts();
    public string get_Manager();
    public void set_Manager(string value);
    public void RemoveManager();
    public string get_Company();
    public void set_Company(string value);
    public void RemoveCompany();
    public bool get_LinksDirty();
    public void set_LinksDirty(bool value);
    public void RemoveLinksDirty();
    public int get_CharCountWithSpaces();
    public void set_CharCountWithSpaces(int value);
    public void RemoveCharCountWithSpaces();
    public bool get_HyperlinksChanged();
    public void set_HyperlinksChanged(bool value);
    public void RemoveHyperlinksChanged();
    public int get_ApplicationVersion();
    public void set_ApplicationVersion(int value);
    public void RemoveApplicationVersion();
    public Byte[] get_VBADigitalSignature();
    public void set_VBADigitalSignature(Byte[] value);
    public void RemoveVBADigitalSignature();
    public string get_ContentType();
    public void set_ContentType(string value);
    public void RemoveContentType();
    public string get_ContentStatus();
    public void set_ContentStatus(string value);
    public void RemoveContentStatus();
    public string get_Language();
    public void set_Language(string value);
    public void RemoveLanguage();
    public string get_DocumentVersion();
    public void set_DocumentVersion(string value);
    public void RemoveDocumentVersion();
    public CustomProperties get_CustomProperties();
    public void set_CustomProperties(CustomProperties value);
    private void EnsureSection2();
    public void RemoveCustomProperties();
}
public class NPOI.HPSF.Extractor.HPSFPropertiesExtractor : POIOLE2TextExtractor {
    public string DocumentSummaryInformationText { get; }
    public string SummaryInformationText { get; }
    public string Text { get; }
    public POITextExtractor MetadataTextExtractor { get; }
    public HPSFPropertiesExtractor(POIOLE2TextExtractor mainExtractor);
    public HPSFPropertiesExtractor(POIDocument doc);
    public HPSFPropertiesExtractor(POIFSFileSystem fs);
    public HPSFPropertiesExtractor(NPOIFSFileSystem fs);
    public string get_DocumentSummaryInformationText();
    public string get_SummaryInformationText();
    private static string GetPropertiesText(SpecialPropertySet ps);
    public virtual string get_Text();
    public virtual POITextExtractor get_MetadataTextExtractor();
}
public class NPOI.HPSF.Filetime : object {
    public static int SIZE;
    private int _dwHighDateTime;
    private int _dwLowDateTime;
    public long High { get; }
    public long Low { get; }
    public Filetime(Byte[] data, int offset);
    public Filetime(int low, int high);
    public long get_High();
    public long get_Low();
    public Byte[] ToByteArray();
    public int Write(Stream out1);
}
public class NPOI.HPSF.GUID : object {
    public static int SIZE;
    private int _data1;
    private short _data2;
    private short _data3;
    private long _data4;
    public GUID(Byte[] data, int offset);
}
public class NPOI.HPSF.HPSFException : Exception {
    public Exception Reason { get; }
    public HPSFException(string msg);
    public HPSFException(Exception reason);
    public HPSFException(string msg, Exception reason);
    public Exception get_Reason();
}
public class NPOI.HPSF.HPSFPropertiesOnlyDocument : POIDocument {
    public HPSFPropertiesOnlyDocument(NPOIFSFileSystem fs);
    public HPSFPropertiesOnlyDocument(OPOIFSFileSystem fs);
    public HPSFPropertiesOnlyDocument(POIFSFileSystem fs);
    public virtual void Write();
    public virtual void Write(FileInfo newFile);
    public virtual void Write(Stream out1);
    private void Write(NPOIFSFileSystem fs);
}
public class NPOI.HPSF.HPSFRuntimeException : RuntimeException {
    public HPSFRuntimeException(string msg);
    public HPSFRuntimeException(Exception reason);
    public HPSFRuntimeException(string msg, Exception reason);
}
public class NPOI.HPSF.IllegalPropertySetDataException : HPSFRuntimeException {
    public IllegalPropertySetDataException(string msg);
    public IllegalPropertySetDataException(Exception reason);
    public IllegalPropertySetDataException(string msg, Exception reason);
}
public class NPOI.HPSF.IllegalVariantTypeException : VariantTypeException {
    public IllegalVariantTypeException(long variantType, object value, string msg);
    public IllegalVariantTypeException(long variantType, object value);
}
public class NPOI.HPSF.IndirectPropertyName : object {
    private CodePageString _value;
    public int Size { get; }
    public IndirectPropertyName(Byte[] data, int offset);
    public int get_Size();
}
public class NPOI.HPSF.MarkUnsupportedException : HPSFException {
    public MarkUnsupportedException(string msg);
    public MarkUnsupportedException(Exception reason);
    public MarkUnsupportedException(string msg, Exception reason);
}
public class NPOI.HPSF.MissingSectionException : HPSFRuntimeException {
    public MissingSectionException(string msg);
    public MissingSectionException(Exception reason);
    public MissingSectionException(string msg, Exception reason);
}
public class NPOI.HPSF.MutableProperty : Property {
    public MutableProperty(Property p);
    public int Write(Stream out1, int codepage);
}
public class NPOI.HPSF.MutablePropertySet : PropertySet {
    private int OFFSET_HEADER;
    public int ByteOrder { get; public set; }
    public int Format { get; public set; }
    public int OSVersion { get; public set; }
    public ClassID ClassID { get; public set; }
    public MutablePropertySet(PropertySet ps);
    public virtual int get_ByteOrder();
    public virtual void set_ByteOrder(int value);
    public virtual void set_Format(int value);
    public virtual int get_Format();
    public virtual void set_OSVersion(int value);
    public virtual int get_OSVersion();
    public virtual void set_ClassID(ClassID value);
    public virtual ClassID get_ClassID();
    public virtual void ClearSections();
    public virtual void AddSection(Section section);
    public virtual void Write(Stream out1);
    public virtual Stream ToInputStream();
    public virtual void Write(DirectoryEntry dir, string name);
}
public class NPOI.HPSF.MutableSection : Section {
    private bool dirty;
    private ArrayList preprops;
    private Byte[] sectionBytes;
    public int Size { get; }
    public int PropertyCount { get; }
    public Property[] Properties { get; }
    public IDictionary Dictionary { get; public set; }
    public int Codepage { get; public set; }
    public MutableSection(Section s);
    public void SetFormatID(ClassID formatID);
    public void SetFormatID(Byte[] formatID);
    public void SetProperties(Property[] properties);
    public void SetProperty(int id, string value);
    public void SetProperty(int id, int value);
    public void SetProperty(int id, long value);
    public void SetProperty(int id, bool value);
    public void SetProperty(int id, long variantType, object value);
    public void SetProperty(Property p);
    public void RemoveProperty(long id);
    protected void SetPropertyBooleanValue(int id, bool value);
    public virtual int get_Size();
    private int CalcSize();
    public int Write(Stream out1);
    private static int WriteDictionary(Stream out1, IDictionary dictionary, int codepage);
    public virtual int get_PropertyCount();
    public virtual Property[] get_Properties();
    public void EnsureProperties();
    public virtual object GetProperty(long id);
    public virtual IDictionary get_Dictionary();
    public virtual void set_Dictionary(IDictionary value);
    public void SetProperty(int id, object value);
    public void Clear();
    public int get_Codepage();
    public void set_Codepage(int value);
}
public class NPOI.HPSF.NoFormatIDException : HPSFRuntimeException {
    public NoFormatIDException(string msg);
    public NoFormatIDException(Exception reason);
    public NoFormatIDException(string msg, Exception reason);
}
public class NPOI.HPSF.NoPropertySetStreamException : HPSFException {
    public NoPropertySetStreamException(string msg);
    public NoPropertySetStreamException(Exception reason);
    public NoPropertySetStreamException(string msg, Exception reason);
}
public class NPOI.HPSF.NoSingleSectionException : HPSFRuntimeException {
    public NoSingleSectionException(string msg);
    public NoSingleSectionException(Exception reason);
    public NoSingleSectionException(string msg, Exception reason);
}
public class NPOI.HPSF.Property : object {
    protected long id;
    protected long type;
    protected object value;
    public long ID { get; public set; }
    public long Type { get; public set; }
    public object Value { get; public set; }
    public int Count { get; }
    public Property(long id, long type, object value);
    public Property(long id, Byte[] src, long offset, int Length, int codepage);
    public virtual long get_ID();
    public virtual void set_ID(long value);
    public virtual long get_Type();
    public virtual void set_Type(long value);
    public virtual object get_Value();
    public virtual void set_Value(object value);
    protected IDictionary ReadDictionary(Byte[] src, long offset, int Length, int codepage);
    public int get_Count();
    public virtual bool Equals(object o);
    private bool TypesAreEqual(long t1, long t2);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NPOI.HPSF.PropertySet : object {
    protected static Byte[] BYTE_ORDER_ASSERTION;
    protected int byteOrder;
    protected static Byte[] FORMAT_ASSERTION;
    protected int format;
    protected int osVersion;
    public static int OS_WIN16;
    public static int OS_MACINTOSH;
    public static int OS_WIN32;
    protected ClassID classID;
    protected List`1<Section> sections;
    public int ByteOrder { get; public set; }
    public int Format { get; public set; }
    public int OSVersion { get; public set; }
    public ClassID ClassID { get; public set; }
    public int SectionCount { get; }
    public List`1<Section> Sections { get; }
    public bool IsSummaryInformation { get; }
    public bool IsDocumentSummaryInformation { get; }
    public Property[] Properties { get; }
    public bool WasNull { get; }
    public Section FirstSection { get; }
    public Section SingleSection { get; }
    public PropertySet(Stream stream);
    public PropertySet(Byte[] stream, int offset, int Length);
    public PropertySet(Byte[] stream);
    private static PropertySet();
    public virtual int get_ByteOrder();
    public virtual void set_ByteOrder(int value);
    public virtual int get_Format();
    public virtual void set_Format(int value);
    public virtual int get_OSVersion();
    public virtual void set_OSVersion(int value);
    public virtual ClassID get_ClassID();
    public virtual void set_ClassID(ClassID value);
    public virtual int get_SectionCount();
    public virtual List`1<Section> get_Sections();
    public static bool IsPropertySetStream(Stream stream);
    public static bool IsPropertySetStream(Byte[] src, int offset, int Length);
    private void init(Byte[] src, int offset, int Length);
    public virtual bool get_IsSummaryInformation();
    public virtual bool get_IsDocumentSummaryInformation();
    public virtual Property[] get_Properties();
    public virtual object GetProperty(int id);
    public virtual bool GetPropertyBooleanValue(int id);
    public virtual int GetPropertyIntValue(int id);
    public virtual bool get_WasNull();
    public virtual Section get_FirstSection();
    public Section get_SingleSection();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NPOI.HPSF.PropertySetFactory : object {
    public static PropertySet Create(DirectoryEntry dir, string name);
    public static PropertySet Create(Stream stream);
    public static SummaryInformation CreateSummaryInformation();
    public static DocumentSummaryInformation CreateDocumentSummaryInformation();
    internal static DocumentSummaryInformation NewDocumentSummaryInformation();
}
public class NPOI.HPSF.ReadingNotSupportedException : UnsupportedVariantTypeException {
    public ReadingNotSupportedException(long variantType, object value);
}
public class NPOI.HPSF.Section : object {
    protected IDictionary dictionary;
    protected ClassID formatID;
    protected long offset;
    protected int size;
    protected Property[] properties;
    private bool wasNull;
    public ClassID FormatID { get; }
    public long OffSet { get; }
    public int Size { get; }
    public int PropertyCount { get; }
    public Property[] Properties { get; }
    public bool WasNull { get; }
    public IDictionary Dictionary { get; public set; }
    public int Codepage { get; }
    public Section(Byte[] src, int offset);
    public ClassID get_FormatID();
    public long get_OffSet();
    public virtual int get_Size();
    public virtual int get_PropertyCount();
    public virtual Property[] get_Properties();
    public virtual object GetProperty(long id);
    public virtual int GetPropertyIntValue(long id);
    public virtual bool GetPropertyBooleanValue(int id);
    public virtual bool get_WasNull();
    public string GetPIDString(long pid);
    public virtual bool Equals(object o);
    private Property[] Remove(Property[] pa, int i);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual IDictionary get_Dictionary();
    public virtual void set_Dictionary(IDictionary value);
    public int get_Codepage();
}
public abstract class NPOI.HPSF.SpecialPropertySet : MutablePropertySet {
    private MutablePropertySet delegate1;
    public PropertyIDMap PropertySetIDMap { get; }
    public int ByteOrder { get; public set; }
    public int Format { get; public set; }
    public ClassID ClassID { get; public set; }
    public int SectionCount { get; }
    public List`1<Section> Sections { get; }
    public bool IsSummaryInformation { get; }
    public bool IsDocumentSummaryInformation { get; }
    public Section FirstSection { get; }
    public int OSVersion { get; public set; }
    public Property[] Properties { get; }
    public bool WasNull { get; }
    public SpecialPropertySet(PropertySet ps);
    public SpecialPropertySet(MutablePropertySet ps);
    public abstract virtual PropertyIDMap get_PropertySetIDMap();
    public virtual int get_ByteOrder();
    public virtual void set_ByteOrder(int value);
    public virtual int get_Format();
    public virtual void set_Format(int value);
    public virtual ClassID get_ClassID();
    public virtual void set_ClassID(ClassID value);
    public virtual int get_SectionCount();
    public virtual List`1<Section> get_Sections();
    public virtual bool get_IsSummaryInformation();
    public virtual Stream ToInputStream();
    public virtual bool get_IsDocumentSummaryInformation();
    public virtual Section get_FirstSection();
    public virtual void AddSection(Section section);
    public virtual void ClearSections();
    public virtual void set_OSVersion(int value);
    public virtual int get_OSVersion();
    public virtual void Write(DirectoryEntry dir, string name);
    public virtual void Write(Stream out1);
    public virtual bool Equals(object o);
    public virtual Property[] get_Properties();
    public virtual object GetProperty(int id);
    public virtual bool GetPropertyBooleanValue(int id);
    public virtual int GetPropertyIntValue(int id);
    protected string GetPropertyStringValue(int propertyId);
    protected static string GetPropertyStringValue(object propertyValue);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool get_WasNull();
}
public class NPOI.HPSF.SummaryInformation : SpecialPropertySet {
    public static string DEFAULT_STREAM_NAME;
    public PropertyIDMap PropertySetIDMap { get; }
    public string Title { get; public set; }
    public string Subject { get; public set; }
    public string Author { get; public set; }
    public string Keywords { get; public set; }
    public string Comments { get; public set; }
    public string Template { get; public set; }
    public string LastAuthor { get; public set; }
    public string RevNumber { get; public set; }
    public long EditTime { get; public set; }
    public Nullable`1<DateTime> LastPrinted { get; public set; }
    public Nullable`1<DateTime> CreateDateTime { get; public set; }
    public Nullable`1<DateTime> LastSaveDateTime { get; public set; }
    public int PageCount { get; public set; }
    public int WordCount { get; public set; }
    public int CharCount { get; public set; }
    public Byte[] Thumbnail { get; public set; }
    public Thumbnail ThumbnailThumbnail { get; }
    public string ApplicationName { get; public set; }
    public int Security { get; public set; }
    public SummaryInformation(PropertySet ps);
    public virtual PropertyIDMap get_PropertySetIDMap();
    public string get_Title();
    public void set_Title(string value);
    public void RemoveTitle();
    public string get_Subject();
    public void set_Subject(string value);
    public void RemoveSubject();
    public string get_Author();
    public void set_Author(string value);
    public void RemoveAuthor();
    public string get_Keywords();
    public void set_Keywords(string value);
    public void RemoveKeywords();
    public string get_Comments();
    public void set_Comments(string value);
    public void RemoveComments();
    public string get_Template();
    public void set_Template(string value);
    public void RemoveTemplate();
    public string get_LastAuthor();
    public void set_LastAuthor(string value);
    public void RemoveLastAuthor();
    public string get_RevNumber();
    public void set_RevNumber(string value);
    public void RemoveRevNumber();
    public long get_EditTime();
    public void set_EditTime(long value);
    public void RemoveEditTime();
    public Nullable`1<DateTime> get_LastPrinted();
    public void set_LastPrinted(Nullable`1<DateTime> value);
    public void RemoveLastPrinted();
    public Nullable`1<DateTime> get_CreateDateTime();
    public void set_CreateDateTime(Nullable`1<DateTime> value);
    public void RemoveCreateDateTime();
    public Nullable`1<DateTime> get_LastSaveDateTime();
    public void set_LastSaveDateTime(Nullable`1<DateTime> value);
    public void RemoveLastSaveDateTime();
    public int get_PageCount();
    public void set_PageCount(int value);
    public void RemovePageCount();
    public int get_WordCount();
    public void set_WordCount(int value);
    public void RemoveWordCount();
    public int get_CharCount();
    public void set_CharCount(int value);
    public void RemoveCharCount();
    public Byte[] get_Thumbnail();
    public void set_Thumbnail(Byte[] value);
    public Thumbnail get_ThumbnailThumbnail();
    public void RemoveThumbnail();
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public void RemoveApplicationName();
    public int get_Security();
    public void set_Security(int value);
    public void RemoveSecurity();
}
public class NPOI.HPSF.Thumbnail : object {
    public static int OFFSet_CFTAG;
    public static int OFFSet_CF;
    public static int OFFSet_WMFDATA;
    public static int CFTAG_WINDOWS;
    public static int CFTAG_MACINTOSH;
    public static int CFTAG_FMTID;
    public static int CFTAG_NODATA;
    public static int CF_METAFILEPICT;
    public static int CF_DIB;
    public static int CF_ENHMETAFILE;
    [ObsoleteAttribute]
public static int CF_BITMAP;
    private Byte[] thumbnailData;
    public Byte[] ThumbnailData { get; public set; }
    public long ClipboardFormatTag { get; }
    public Thumbnail(Byte[] thumbnailData);
    public Byte[] get_ThumbnailData();
    public void set_ThumbnailData(Byte[] value);
    public long get_ClipboardFormatTag();
    public long GetClipboardFormat();
    public Byte[] GetThumbnailAsWMF();
}
public class NPOI.HPSF.TypedPropertyValue : object {
    private static POILogger logger;
    private int _type;
    private object _value;
    public object Value { get; }
    public TypedPropertyValue(Byte[] data, int startOffset);
    public TypedPropertyValue(int type, object value);
    private static TypedPropertyValue();
    public object get_Value();
    public int Read(Byte[] data, int startOffset);
    public int ReadValue(Byte[] data, int offset);
    internal int ReadValuePadded(Byte[] data, int offset);
}
public class NPOI.HPSF.TypeWriter : object {
    public static int WriteToStream(Stream out1, short n);
    public static int WriteToStream(Stream out1, int n);
    [ObsoleteAttribute]
public static int WriteToStream(Stream out1, UInt32 n);
    public static int WriteToStream(Stream out1, long n);
    public static void WriteUShortToStream(Stream out1, int n);
    public static int WriteUIntToStream(Stream out1, UInt32 n);
    public static int WriteToStream(Stream out1, ClassID n);
    public static void WriteToStream(Stream out1, Property[] properties, int codepage);
    public static int WriteToStream(Stream out1, double n);
}
public class NPOI.HPSF.UnexpectedPropertySetTypeException : HPSFException {
    public UnexpectedPropertySetTypeException(string msg);
    public UnexpectedPropertySetTypeException(Exception reason);
    public UnexpectedPropertySetTypeException(string msg, Exception reason);
}
public class NPOI.HPSF.UnicodeString : object {
    private Byte[] _value;
    public int Size { get; }
    public Byte[] Value { get; }
    public UnicodeString(Byte[] data, int offset);
    private bool validLength(int length, Byte[] data, int offset);
    public int get_Size();
    public Byte[] get_Value();
    public string ToJavaString();
}
public class NPOI.HPSF.UnsupportedEncodingException : IOException {
    public UnsupportedEncodingException(string s);
}
public abstract class NPOI.HPSF.UnsupportedVariantTypeException : VariantTypeException {
    public UnsupportedVariantTypeException(long variantType, object value);
}
public class NPOI.HPSF.Util : object {
    public static long EPOCH_DIFF;
    private static Util();
    public static void Copy(Byte[] src, int srcOffSet, int Length, Byte[] dst, int dstOffSet);
    public static Byte[] Cat(Byte[][] byteArrays);
    public static Byte[] Copy(Byte[] src, int offset, int Length);
    public static DateTime FiletimeToDate(int high, int low);
    public static DateTime FiletimeToDate(long filetime);
    public static long DateToFileTime(DateTime dateTime);
    public static bool AreEqual(IList c1, IList c2);
    private static bool internalEquals(IList c1, IList c2);
    public static Byte[] Pad4(Byte[] ba);
    public static Char[] Pad4(Char[] ca);
    public static Char[] Pad4(string s);
}
public class NPOI.HPSF.Variant : object {
    public static int VT_EMPTY;
    public static int VT_NULL;
    public static int VT_I2;
    public static int VT_I4;
    public static int VT_R4;
    public static int VT_R8;
    public static int VT_CY;
    public static int VT_DATE;
    public static int VT_BSTR;
    public static int VT_DISPATCH;
    public static int VT_ERROR;
    public static int VT_BOOL;
    public static int VT_VARIANT;
    public static int VT_UNKNOWN;
    public static int VT_DECIMAL;
    public static int VT_I1;
    public static int VT_UI1;
    public static int VT_UI2;
    public static int VT_UI4;
    public static int VT_I8;
    public static int VT_UI8;
    public static int VT_INT;
    public static int VT_UINT;
    public static int VT_VOID;
    public static int VT_HRESULT;
    public static int VT_PTR;
    public static int VT_SAFEARRAY;
    public static int VT_CARRAY;
    public static int VT_USERDEFINED;
    public static int VT_LPSTR;
    public static int VT_LPWSTR;
    public static int VT_FILETIME;
    public static int VT_BLOB;
    public static int VT_STREAM;
    public static int VT_STORAGE;
    public static int VT_STREAMED_OBJECT;
    public static int VT_STORED_OBJECT;
    public static int VT_BLOB_OBJECT;
    public static int VT_CF;
    public static int VT_CLSID;
    public static int VT_VERSIONED_STREAM;
    public static int VT_VECTOR;
    public static int VT_ARRAY;
    public static int VT_BYREF;
    public static int VT_RESERVED;
    public static int VT_ILLEGAL;
    public static int VT_ILLEGALMASKED;
    public static int VT_TYPEMASK;
    private static IDictionary numberToName;
    private static IDictionary numberToLength;
    public static int Length_UNKNOWN;
    public static int Length_VARIABLE;
    public static int Length_0;
    public static int Length_2;
    public static int Length_4;
    public static int Length_8;
    private static Variant();
    public static string GetVariantName(long variantType);
    public static int GetVariantLength(long variantType);
}
public class NPOI.HPSF.VariantBool : object {
    public static int SIZE;
    private bool _value;
    public bool Value { get; public set; }
    public VariantBool(Byte[] data, int offset);
    public bool get_Value();
    public void set_Value(bool value);
}
public class NPOI.HPSF.VariantSupport : Variant {
    private static bool logUnsupportedTypes;
    protected static List`1<long> unsupportedMessage;
    public static Int32[] SUPPORTED_TYPES;
    public static bool IsLogUnsupportedTypes { get; public set; }
    private static VariantSupport();
    public static bool get_IsLogUnsupportedTypes();
    public static void set_IsLogUnsupportedTypes(bool value);
    public static void WriteUnsupportedTypeMessage(UnsupportedVariantTypeException ex);
    public bool IsSupportedType(int variantType);
    public static object Read(Byte[] src, int offset, int length, long type, int codepage);
    public static string CodepageToEncoding(int codepage);
    public static int Write(Stream out1, long type, object value, int codepage);
}
public abstract class NPOI.HPSF.VariantTypeException : HPSFException {
    private object value;
    private long variantType;
    public long VariantType { get; }
    public object Value { get; }
    public VariantTypeException(long variantType, object value, string msg);
    public long get_VariantType();
    public object get_Value();
}
public class NPOI.HPSF.Vector : object {
    private short _type;
    private TypedPropertyValue[] _values;
    public TypedPropertyValue[] Values { get; }
    public Vector(Byte[] data, int startOffset, short type);
    public Vector(short type);
    public int Read(Byte[] data, int startOffset);
    public TypedPropertyValue[] get_Values();
}
public class NPOI.HPSF.VersionedStream : object {
    private GUID _versionGuid;
    private IndirectPropertyName _streamName;
    public int Size { get; }
    public VersionedStream(Byte[] data, int offset);
    public int get_Size();
}
public class NPOI.HPSF.Wellknown.PropertyIDMap : Hashtable {
    public static int PID_TITLE;
    public static int PID_SUBJECT;
    public static int PID_AUTHOR;
    public static int PID_KEYWORDS;
    public static int PID_COMMENTS;
    public static int PID_TEMPLATE;
    public static int PID_LASTAUTHOR;
    public static int PID_REVNUMBER;
    public static int PID_EDITTIME;
    public static int PID_LASTPRINTED;
    public static int PID_Create_DTM;
    public static int PID_LASTSAVE_DTM;
    public static int PID_PAGECOUNT;
    public static int PID_WORDCOUNT;
    public static int PID_CHARCOUNT;
    public static int PID_THUMBNAIL;
    public static int PID_APPNAME;
    public static int PID_SECURITY;
    public static int PID_DICTIONARY;
    public static int PID_CODEPAGE;
    public static int PID_CATEGORY;
    public static int PID_PRESFORMAT;
    public static int PID_BYTECOUNT;
    public static int PID_LINECOUNT;
    public static int PID_PARCOUNT;
    public static int PID_SLIDECOUNT;
    public static int PID_NOTECOUNT;
    public static int PID_HIDDENCOUNT;
    public static int PID_MMCLIPCOUNT;
    public static int PID_SCALE;
    public static int PID_HEADINGPAIR;
    public static int PID_DOCPARTS;
    public static int PID_MANAGER;
    public static int PID_COMPANY;
    public static int PID_LINKSDIRTY;
    public static int PID_CCHWITHSPACES;
    public static int PID_HYPERLINKSCHANGED;
    public static int PID_VERSION;
    public static int PID_DIGSIG;
    public static int PID_CONTENTTYPE;
    public static int PID_CONTENTSTATUS;
    public static int PID_LANGUAGE;
    public static int PID_DOCVERSION;
    public static int PID_MAX;
    private static PropertyIDMap summaryInformationProperties;
    private static PropertyIDMap documentSummaryInformationProperties;
    public static PropertyIDMap SummaryInformationProperties { get; }
    public static PropertyIDMap DocumentSummaryInformationProperties { get; }
    public PropertyIDMap(int initialCapacity, float loadFactor);
    public PropertyIDMap(IDictionary map);
    private static PropertyIDMap();
    public object Put(long id, string idString);
    public object Get(long id);
    public static PropertyIDMap get_SummaryInformationProperties();
    public static PropertyIDMap get_DocumentSummaryInformationProperties();
}
public class NPOI.HPSF.Wellknown.SectionIDMap : Hashtable {
    public static Byte[] SUMMARY_INFORMATION_ID;
    public static Byte[] DOCUMENT_SUMMARY_INFORMATION_ID1;
    public static Byte[] DOCUMENT_SUMMARY_INFORMATION_ID2;
    public static string UNDEFINED;
    private static SectionIDMap defaultMap;
    private static SectionIDMap();
    public static SectionIDMap GetInstance();
    public static string GetPIDString(Byte[] sectionFormatID, long pid);
    public PropertyIDMap Get(Byte[] sectionFormatID);
    public object Put(Byte[] sectionFormatID, PropertyIDMap propertyIDMap);
}
public class NPOI.HPSF.WritingNotSupportedException : UnsupportedVariantTypeException {
    public WritingNotSupportedException(long variantType, object value);
}
public class NPOI.HSSF.EventModel.EventRecordFactory : object {
    private IERFListener _listener;
    private ArrayList _sids;
    public EventRecordFactory(IERFListener listener, ArrayList sids);
    private bool IsSidIncluded(int sid);
    private bool ProcessRecord(Record record);
    public void ProcessRecords(Stream in1);
}
public interface NPOI.HSSF.EventModel.IERFListener {
    public abstract virtual bool ProcessRecord(Record rec);
}
public abstract class NPOI.HSSF.EventUserModel.AbortableHSSFListener : object {
    public virtual void ProcessRecord(Record record);
    public abstract virtual short AbortableProcessRecord(Record record);
}
public abstract class NPOI.HSSF.EventUserModel.DummyRecord.DummyRecordBase : Record {
    public short Sid { get; }
    public int RecordSize { get; }
    public virtual short get_Sid();
    public virtual int Serialize(int offset, Byte[] data);
    public virtual int get_RecordSize();
}
public class NPOI.HSSF.EventUserModel.DummyRecord.LastCellOfRowDummyRecord : DummyRecordBase {
    private int row;
    private int lastColumnNumber;
    public int Row { get; }
    public int LastColumnNumber { get; }
    public LastCellOfRowDummyRecord(int row, int lastColumnNumber);
    public int get_Row();
    public int get_LastColumnNumber();
}
public class NPOI.HSSF.EventUserModel.DummyRecord.MissingCellDummyRecord : DummyRecordBase {
    private int row;
    private int column;
    public int Row { get; }
    public int Column { get; }
    public MissingCellDummyRecord(int row, int column);
    public int get_Row();
    public int get_Column();
}
public class NPOI.HSSF.EventUserModel.DummyRecord.MissingRowDummyRecord : DummyRecordBase {
    private int rowNumber;
    public int RowNumber { get; }
    public MissingRowDummyRecord(int rowNumber);
    public int get_RowNumber();
}
public class NPOI.HSSF.EventUserModel.EventWorkbookBuilder : object {
    public static InternalWorkbook CreateStubWorkbook(ExternSheetRecord[] externs, BoundSheetRecord[] bounds, SSTRecord sst);
    public static InternalWorkbook CreateStubWorkbook(ExternSheetRecord[] externs, BoundSheetRecord[] bounds);
}
public class NPOI.HSSF.EventUserModel.FormatTrackingHSSFListener : object {
    private static POILogger logger;
    private IHSSFListener childListener;
    private Dictionary`2<int, FormatRecord> customFormatRecords;
    private DataFormatter formatter;
    private List`1<ExtendedFormatRecord> xfRecords;
    public int NumberOfCustomFormats { get; }
    public int NumberOfExtendedFormats { get; }
    public FormatTrackingHSSFListener(IHSSFListener childListener);
    private static FormatTrackingHSSFListener();
    public int get_NumberOfCustomFormats();
    public int get_NumberOfExtendedFormats();
    public sealed virtual void ProcessRecord(Record record);
    public void ProcessRecordInternally(Record record);
    public string FormatNumberDateCell(CellValueRecordInterface cell);
    public string GetFormatString(int formatIndex);
    public string GetFormatString(CellValueRecordInterface cell);
    public int GetFormatIndex(CellValueRecordInterface cell);
}
public class NPOI.HSSF.EventUserModel.HSSFEventFactory : object {
    public void ProcessWorkbookEvents(HSSFRequest req, POIFSFileSystem fs);
    public short AbortableProcessWorkbookEvents(HSSFRequest req, POIFSFileSystem fs);
    public void ProcessEvents(HSSFRequest req, Stream in1);
    public short AbortableProcessEvents(HSSFRequest req, Stream in1);
    protected short GenericProcessEvents(HSSFRequest req, RecordInputStream in1);
}
public class NPOI.HSSF.EventUserModel.HSSFRecordStream : object {
    private RecordInputStream in1;
    private bool hitEOS;
    private bool complete;
    private ArrayList bonusRecords;
    private Record rec;
    private Record lastRec;
    private DrawingRecord lastDrawingRecord;
    public HSSFRecordStream(RecordInputStream inp);
    public Record NextRecord();
    private Record GetBonusRecord();
    private Record GetNextRecord();
}
public class NPOI.HSSF.EventUserModel.HSSFRequest : object {
    private Hashtable records;
    public void AddListener(IHSSFListener lsnr, short sid);
    public void AddListenerForAllRecords(IHSSFListener lsnr);
    public short ProcessRecord(Record rec);
}
public class NPOI.HSSF.EventUserModel.HSSFUserException : Exception {
    public HSSFUserException(string msg);
    public HSSFUserException(Exception reason);
    public HSSFUserException(string msg, Exception reason);
}
public interface NPOI.HSSF.EventUserModel.IHSSFListener {
    public abstract virtual void ProcessRecord(Record record);
}
public class NPOI.HSSF.EventUserModel.MissingRecordAwareHSSFListener : object {
    private IHSSFListener childListener;
    private int lastRowRow;
    private int lastCellRow;
    private int lastCellColumn;
    public MissingRecordAwareHSSFListener(IHSSFListener listener);
    public sealed virtual void ProcessRecord(Record record);
    private void ResetCounts();
}
public class NPOI.HSSF.Extractor.EventBasedExcelExtractor : POIOLE2TextExtractor {
    private POIFSFileSystem fs;
    private bool includeSheetNames;
    private bool formulasNotResults;
    public DocumentSummaryInformation DocSummaryInformation { get; }
    public SummaryInformation SummaryInformation { get; }
    public bool IncludeSheetNames { get; public set; }
    public bool FormulasNotResults { get; public set; }
    public string Text { get; }
    public EventBasedExcelExtractor(POIFSFileSystem fs);
    public virtual DocumentSummaryInformation get_DocSummaryInformation();
    public virtual SummaryInformation get_SummaryInformation();
    public bool get_IncludeSheetNames();
    public void set_IncludeSheetNames(bool value);
    public bool get_FormulasNotResults();
    public void set_FormulasNotResults(bool value);
    public virtual string get_Text();
    private TextListener TriggerExtraction();
}
public class NPOI.HSSF.Extractor.ExcelExtractor : POIOLE2TextExtractor {
    private HSSFWorkbook wb;
    private HSSFDataFormatter _formatter;
    private bool includeSheetNames;
    private bool formulasNotResults;
    private bool includeCellComments;
    private bool includeBlankCells;
    private bool includeHeaderFooter;
    public bool IncludeHeaderFooter { get; public set; }
    public bool IncludeSheetNames { get; public set; }
    public bool FormulasNotResults { get; public set; }
    public bool IncludeCellComments { get; public set; }
    public bool IncludeBlankCells { get; public set; }
    public string Text { get; }
    public ExcelExtractor(HSSFWorkbook wb);
    public ExcelExtractor(POIFSFileSystem fs);
    public sealed virtual bool get_IncludeHeaderFooter();
    public sealed virtual void set_IncludeHeaderFooter(bool value);
    public sealed virtual bool get_IncludeSheetNames();
    public sealed virtual void set_IncludeSheetNames(bool value);
    public sealed virtual bool get_FormulasNotResults();
    public sealed virtual void set_FormulasNotResults(bool value);
    public sealed virtual bool get_IncludeCellComments();
    public sealed virtual void set_IncludeCellComments(bool value);
    public bool get_IncludeBlankCells();
    public void set_IncludeBlankCells(bool value);
    public virtual string get_Text();
    public static string ExtractHeaderFooter(IHeaderFooter hf);
}
public class NPOI.HSSF.Extractor.OldExcelExtractor : object {
    private static int FILE_PASS_RECORD_SID;
    private RecordInputStream ris;
    private ICloseable toClose;
    private Stream toCloseStream;
    private int biffVersion;
    private int fileType;
    public int BiffVersion { get; }
    public int FileType { get; }
    public string Text { get; }
    public OldExcelExtractor(Stream input);
    public OldExcelExtractor(FileInfo f);
    public OldExcelExtractor(NPOIFSFileSystem fs);
    public OldExcelExtractor(DirectoryNode directory);
    private void Open(Stream biffStream);
    private void Open(NPOIFSFileSystem fs);
    private void Open(DirectoryNode directory);
    public static void main(String[] args);
    private void Prepare();
    public int get_BiffVersion();
    public int get_FileType();
    public string get_Text();
    protected void handleNumericCell(StringBuilder text, double value);
    public void Close();
}
internal class NPOI.HSSF.FrtHeader : ValueType {
    public ushort rt;
    public ushort grbitFrt;
    public long reserved;
}
internal class NPOI.HSSF.FrtHeaderOld : ValueType {
    public ushort rt;
    public ushort grbitFrt;
}
internal class NPOI.HSSF.FrtRefHeader : ValueType {
    public ushort rt;
    public ushort grbitFrt;
    public Ref8 ref8;
}
public class NPOI.HSSF.Model.ConvertAnchor : object {
    public static EscherRecord CreateAnchor(HSSFAnchor userAnchor);
}
[ObsoleteAttribute("deprecated in POI 3.15-beta2, scheduled for removal in 3.17, use DrawingManager2 instead")]
public class NPOI.HSSF.Model.DrawingManager : object {
    private EscherDggRecord dgg;
    private Hashtable dgMap;
    public EscherDggRecord Dgg { get; }
    public DrawingManager(EscherDggRecord dgg);
    public EscherDgRecord CreateDgRecord();
    public int AllocateShapeId(short drawingGroupId);
    public short FindNewDrawingGroupId();
    public bool DrawingGroupExists(short dgId);
    public int FindFreeSPIDBlock();
    public EscherDggRecord get_Dgg();
}
public class NPOI.HSSF.Model.DrawingManager2 : object {
    private EscherDggRecord dgg;
    private IList drawingGroups;
    public DrawingManager2(EscherDggRecord dgg);
    public void ClearDrawingGroups();
    public virtual EscherDgRecord CreateDgRecord();
    public virtual int AllocateShapeId(short drawingGroupId);
    public virtual int AllocateShapeId(short drawingGroupId, EscherDgRecord dg);
    public short FindNewDrawingGroupId();
    private EscherDgRecord GetDrawingGroup(int drawingGroupId);
    private bool DrawingGroupExists(short dgId);
    private int FindFreeSPIDBlock();
    public EscherDggRecord GetDgg();
    public void IncrementDrawingsSaved();
}
public class NPOI.HSSF.Model.HSSFFormulaParser : object {
    private static IFormulaParsingWorkbook CreateParsingWorkbook(HSSFWorkbook book);
    public static Ptg[] Parse(string formula, HSSFWorkbook workbook);
    public static Ptg[] Parse(string formula, HSSFWorkbook workbook, FormulaType formulaType);
    public static Ptg[] Parse(string formula, HSSFWorkbook workbook, FormulaType formulaType, int sheetIndex);
    public static string ToFormulaString(HSSFWorkbook book, Ptg[] ptgs);
}
public class NPOI.HSSF.Model.InternalChart : object {
    private HeaderRecord header;
    private FooterRecord footer;
    private HCenterRecord _hCenter;
    private VCenterRecord _vCenter;
    private LeftMarginRecord _leftMargin;
    private RightMarginRecord _rightMargin;
    private TopMarginRecord _topMargin;
    private BottomMarginRecord _bottomMargin;
    private PrintSetupRecord printSetup;
    private HeaderFooterRecord _headerFooter;
    private PrintSizeRecord _printSize;
    private List`1<PLSAggregate> _plsRecords;
    private List`1<HeaderFooterRecord> _sviewHeaderFooters;
    private ProtectRecord _protect;
    private ChartFRTInfoRecord _chartFrtInfo;
    protected List`1<RecordBase> records;
    private List`1<Record> recores;
    public InternalChart(RecordStream rs);
    private void CheckNotPresent(Record rec);
    private IMargin GetMarginRec(MarginType margin);
    public double GetMargin(MarginType margin);
    public void SetMargin(MarginType margin, double size);
    private static InternalChart CreateChartSheet();
    private static AxesUsedRecord CreateAxisUsedRecord(short numAxis);
    private static void CreateRuleSERIESDATA(List`1<Record> records);
    private static void CreateRuleAXES();
    private static void CreateRuleAXISPARENT(List`1<Record> records);
    private static AxisParentRecord CreateAxisParentRecord();
    private static AxisRecord CreateAxisRecord(short axisType);
    private static AxisLineFormatRecord CreateAxisLineFormatRecord(short format);
    private static ValueRangeRecord CreateValueRangeRecord();
    private static TickRecord CreateTickRecord1();
    private static TickRecord CreateTickRecord2();
    private static AxcExtRecord CreateAxcExtRecord();
    private static CatSerRangeRecord CreateCatSerRangeRecord();
    private static LegendRecord CreateLegendRecord();
    private static BarRecord CreateBarRecord();
    private static ChartFormatRecord CreateChartFormatRecord();
    private static PlotAreaRecord CreatePlotAreaRecord();
    private static void CreateRuleDFTTEXT(List`1<Record> records);
    private static DefaultTextRecord CreateDefaultTextRecord();
    private static void CreateRuleATTACHEDLABEL(List`1<Record> records);
    private static BRAIRecord CreateBRAIRecord();
    private static TextRecord CreateTextRecord();
    private static PosRecord CreatePosRecord();
    private static FontIndexRecord CreateFontXRecord(int index);
    private static ShtPropsRecord CreateShtPropsRecord();
    private static void CreateRuleSERIESFORMAT(List`1<Record> records);
    private static SeriesRecord CreateSeriesRecord();
    private static DataFormatRecord CreateDataFormatRecord();
    private static void CreateRuleSS(List`1<Record> records);
    private static Chart3DBarShapeRecord CreateChart3DBarShapeRecord();
    private static DrawingRecord CreateDrawingRecord();
    private static HeaderFooterRecord CreateHeaderFooterRecord();
    private static IMargin CreateMarginRecord(MarginType margin, double size);
    private static PrintSetupRecord CreatePrintSetupRecord();
    private static BOFRecord CreateBOFRecord();
    private static PrintSizeRecord CreatePrintSizeRecord();
    private static ChartFRTInfoRecord CreateChartFRTInfoRecord();
    private static FooterRecord CreateFooterRecord();
    private static HCenterRecord CreateHCenterRecord();
    private static VCenterRecord CreateVCenterRecord();
    private static FbiRecord CreateFontBasisRecord1();
    private static FbiRecord CreateFontBasisRecord2();
    private static ChartRecord CreateChartRecord(int x, int y, int width, int height);
    private static PlotGrowthRecord CreatePlotGrowthRecord(int horizScale, int vertScale);
    private static SCLRecord CreateSCLRecord(short numerator, short denominator);
    private static FrameRecord CreateFrameRecord1();
    private static FrameRecord CreateFrameRecord2();
    private static AreaFormatRecord CreateAreaFormatRecord1();
    private static AreaFormatRecord CreateAreaFormatRecord2();
    private static LineFormatRecord CreateLineFormatRecord(bool drawTicks);
    private static LineFormatRecord CreateLineFormatRecord2();
}
public class NPOI.HSSF.Model.InternalSheet : object {
    private static POILogger log;
    private int preoffset;
    protected int dimsloc;
    protected DimensionsRecord dims;
    protected DefaultColWidthRecord defaultcolwidth;
    protected DefaultRowHeightRecord defaultrowheight;
    protected GridsetRecord gridset;
    protected PrintSetupRecord printSetup;
    protected HeaderRecord header;
    protected FooterRecord footer;
    protected PrintGridlinesRecord printGridlines;
    protected PrintHeadersRecord printHeaders;
    protected WindowTwoRecord windowTwo;
    protected MergeCellsRecord merged;
    private MergedCellsTable _mergedCellsTable;
    protected RowRecordsAggregate _rowsAggregate;
    private PageSettingsBlock _psBlock;
    protected IMargin[] margins;
    protected SelectionRecord _selection;
    internal ColumnInfoRecordsAggregate _columnInfos;
    private DimensionsRecord _dimensions;
    private DataValidityTable _dataValidityTable;
    private IEnumerator rowRecEnumerator;
    protected int eofLoc;
    private GutsRecord _gutsRecord;
    protected PageBreakRecord rowBreaks;
    protected PageBreakRecord colBreaks;
    protected ConditionalFormattingTable condFormatting;
    protected SheetExtRecord sheetext;
    protected List`1<RecordBase> records;
    protected bool _isUncalced;
    private WorksheetProtectionBlock _protectionBlock;
    public WindowTwoRecord WindowTwo { get; }
    public ColumnInfoRecordsAggregate ColumnInfos { get; }
    internal MergedCellsTable MergedRecords { get; }
    public int NumMergedRegions { get; }
    public int NumConditionalFormattings { get; }
    public int PreOffset { get; public set; }
    public RowRecord NextRow { get; }
    public PageSettingsBlock PageSettings { get; }
    public double DefaultColumnWidth { get; public set; }
    public short DefaultRowHeight { get; public set; }
    public short TopRow { get; public set; }
    public short LeftCol { get; public set; }
    public int ActiveCellRow { get; public set; }
    public int ActiveCellCol { get; public set; }
    public List`1<RecordBase> Records { get; }
    public GridsetRecord GridsetRecord { get; }
    private GutsRecord GutsRecord { get; }
    public HeaderRecord Header { get; public set; }
    public bool IsAutoTabColor { get; public set; }
    public short TabColorIndex { get; public set; }
    public FooterRecord Footer { get; public set; }
    public PrintSetupRecord PrintSetup { get; public set; }
    public bool IsGridsPrinted { get; public set; }
    public PrintGridlinesRecord PrintGridlines { get; public set; }
    public PrintHeadersRecord PrintHeaders { get; public set; }
    public PaneInformation PaneInformation { get; }
    public SelectionRecord Selection { get; public set; }
    public WorksheetProtectionBlock ProtectionBlock { get; }
    public bool DisplayGridlines { get; public set; }
    public bool DisplayFormulas { get; public set; }
    public bool DisplayRowColHeadings { get; public set; }
    public bool IsPrintRowColHeadings { get; public set; }
    public bool IsUncalced { get; public set; }
    public RowRecordsAggregate RowsAggregate { get; }
    public ConditionalFormattingTable ConditionalFormattingTable { get; }
    private InternalSheet(RecordStream rs);
    private static InternalSheet();
    public InternalSheet CloneSheet();
    public WindowTwoRecord get_WindowTwo();
    public static InternalSheet CreateSheet(RecordStream rs);
    private static void SpillAggregate(RecordAggregate ra, List`1<RecordBase> recs);
    public static InternalSheet CreateSheet();
    public int AddMergedRegion(int rowFrom, int colFrom, int rowTo, int colTo);
    public void RemoveMergedRegion(int index);
    public ColumnInfoRecordsAggregate get_ColumnInfos();
    internal MergedCellsTable get_MergedRecords();
    public CellRangeAddress GetMergedRegionAt(int index);
    public int get_NumMergedRegions();
    public int get_NumConditionalFormattings();
    public void SetDimensions(int firstrow, short firstcol, int lastrow, short lastcol);
    public int get_PreOffset();
    public void set_PreOffset(int value);
    public RowRecord CreateRow(int row);
    public LabelSSTRecord CreateLabelSST(int row, short col, int index);
    public NumberRecord CreateNumber(int row, short col, double value);
    public BlankRecord CreateBlank(int row, short col);
    public void AddValueRecord(int row, CellValueRecordInterface col);
    public void RemoveValueRecord(int row, CellValueRecordInterface col);
    public void ReplaceValueRecord(CellValueRecordInterface newval);
    public void AddRow(RowRecord row);
    public void RemoveRow(RowRecord row);
    public IEnumerator`1<CellValueRecordInterface> GetCellValueIterator();
    public RowRecord get_NextRow();
    public RowRecord GetRow(int rownum);
    public PageSettingsBlock get_PageSettings();
    public static BOFRecord CreateBOF();
    private static IndexRecord CreateIndex();
    private static CalcModeRecord CreateCalcMode();
    private static CalcCountRecord CreateCalcCount();
    private static RefModeRecord CreateRefMode();
    private static IterationRecord CreateIteration();
    private static DeltaRecord CreateDelta();
    private static SaveRecalcRecord CreateSaveRecalc();
    private static PrintHeadersRecord CreatePrintHeaders();
    private static PrintGridlinesRecord CreatePrintGridlines();
    private static GridsetRecord CreateGridset();
    private static GutsRecord CreateGuts();
    private static DefaultRowHeightRecord CreateDefaultRowHeight();
    private static WSBoolRecord CreateWSBool();
    private static HCenterRecord CreateHCenter();
    private static VCenterRecord CreateVCenter();
    private static PrintSetupRecord CreatePrintSetup();
    private static DefaultColWidthRecord CreateDefaultColWidth();
    public double get_DefaultColumnWidth();
    public void set_DefaultColumnWidth(double value);
    public short get_DefaultRowHeight();
    public void set_DefaultRowHeight(short value);
    public int GetColumnWidth(int columnIndex);
    public short GetXFIndexForColAt(short columnIndex);
    public void SetColumnWidth(int column, double width);
    public bool IsColumnHidden(int columnIndex);
    public void SetColumnHidden(int column, bool hidden);
    public void SetDefaultColumnStyle(int column, int styleIndex);
    public void SetColumn(int column, double width, int level, bool hidden, bool collapsed);
    public void SetColumn(int column, Nullable`1<short> xfStyle, Nullable`1<double> width, Nullable`1<int> level, Nullable`1<bool> hidden, Nullable`1<bool> collapsed);
    private GutsRecord GetGutsRecord();
    public void GroupColumnRange(int fromColumn, int toColumn, bool indent);
    private static DimensionsRecord CreateDimensions();
    private static WindowTwoRecord CreateWindowTwo();
    private static SelectionRecord CreateSelection();
    public short get_TopRow();
    public void set_TopRow(short value);
    public short get_LeftCol();
    public void set_LeftCol(short value);
    public void SetActiveCell(int row, int column);
    public void SetActiveCellRange(int firstRow, int lastRow, int firstColumn, int lastColumn);
    public void SetActiveCellRange(List`1<CellRangeAddress8Bit> cellranges, int activeRange, int activeRow, int activeColumn);
    public int get_ActiveCellRow();
    public void set_ActiveCellRow(int value);
    public int get_ActiveCellCol();
    public void set_ActiveCellCol(int value);
    protected Record CreateEOF();
    public List`1<RecordBase> get_Records();
    public GridsetRecord get_GridsetRecord();
    private GutsRecord get_GutsRecord();
    public Record FindFirstRecordBySid(short sid);
    public void SetSCLRecord(SCLRecord sclRecord);
    public int FindFirstRecordLocBySid(short sid);
    public HeaderRecord get_Header();
    public void set_Header(HeaderRecord value);
    public bool get_IsAutoTabColor();
    public void set_IsAutoTabColor(bool value);
    public short get_TabColorIndex();
    public void set_TabColorIndex(short value);
    public WindowTwoRecord GetWindowTwo();
    public FooterRecord get_Footer();
    public void set_Footer(FooterRecord value);
    public PrintSetupRecord get_PrintSetup();
    public void set_PrintSetup(PrintSetupRecord value);
    public bool get_IsGridsPrinted();
    public void set_IsGridsPrinted(bool value);
    public PrintGridlinesRecord get_PrintGridlines();
    public void set_PrintGridlines(PrintGridlinesRecord value);
    public PrintHeadersRecord get_PrintHeaders();
    public void set_PrintHeaders(PrintHeadersRecord value);
    public void SetSelected(bool sel);
    public void CreateFreezePane(int colSplit, int rowSplit, int topRow, int leftmostColumn);
    public void CreateSplitPane(int xSplitPos, int ySplitPos, int topRow, int leftmostColumn, PanePosition activePane);
    public PaneInformation get_PaneInformation();
    public SelectionRecord get_Selection();
    public void set_Selection(SelectionRecord value);
    protected static PasswordRecord CreatePassword();
    protected ProtectRecord CreateProtect();
    protected ObjectProtectRecord CreateObjectProtect();
    protected ScenarioProtectRecord CreateScenarioProtect();
    public WorksheetProtectionBlock get_ProtectionBlock();
    public bool get_DisplayGridlines();
    public void set_DisplayGridlines(bool value);
    public bool get_DisplayFormulas();
    public void set_DisplayFormulas(bool value);
    public bool get_DisplayRowColHeadings();
    public void set_DisplayRowColHeadings(bool value);
    public bool get_IsPrintRowColHeadings();
    public void set_IsPrintRowColHeadings(bool value);
    public bool get_IsUncalced();
    public void set_IsUncalced(bool value);
    public int AggregateDrawingRecords(DrawingManager2 drawingManager, bool CreateIfMissing);
    public void Preserialize();
    public void ShiftBreaks(PageBreakRecord breaks, short start, short stop, int count);
    public void ShiftRowBreaks(int startingRow, int endingRow, int count);
    public void ShiftColumnBreaks(short startingCol, short endingCol, short count);
    public void SetColumnGroupCollapsed(int columnNumber, bool collapsed);
    public RowRecordsAggregate get_RowsAggregate();
    public void UpdateFormulasAfterCellShift(FormulaShifter shifter, int externSheetIndex);
    public ConditionalFormattingTable get_ConditionalFormattingTable();
    public void VisitContainedRecords(RecordVisitor rv, int offset);
    private int GetSizeOfInitialSheetRecords(int bofRecordIndex);
    public void GroupRowRange(int fromRow, int toRow, bool indent);
    private void RecalcRowGutter();
    public DataValidityTable GetOrCreateDataValidityTable();
    public NoteRecord[] GetNoteRecords();
    public int GetColumnOutlineLevel(int columnIndex);
}
public class NPOI.HSSF.Model.InternalWorkbook : object {
    private static int MAX_SENSITIVE_SHEET_NAME_LEN;
    public static String[] WORKBOOK_DIR_ENTRY_NAMES;
    public static string OLD_WORKBOOK_DIR_ENTRY_NAME;
    private static short CODEPAGE;
    protected WorkbookRecordList records;
    protected SSTRecord sst;
    private LinkTable linkTable;
    protected List`1<BoundSheetRecord> boundsheets;
    protected List`1<FormatRecord> formats;
    protected List`1<HyperlinkRecord> hyperlinks;
    protected int numxfs;
    protected int numfonts;
    private int maxformatid;
    private bool uses1904datewindowing;
    private DrawingManager2 drawingManager;
    private IList escherBSERecords;
    private WindowOneRecord windowOne;
    private FileSharingRecord fileShare;
    private WriteAccessRecord writeAccess;
    private WriteProtectRecord writeProtect;
    private Dictionary`2<string, NameCommentRecord> commentRecords;
    public int NumRecords { get; }
    public int NumberOfFontRecords { get; }
    public BackupRecord BackupRecord { get; }
    public int NumSheets { get; }
    public int NumExFormats { get; }
    public int Size { get; }
    private LinkTable OrCreateLinkTable { get; }
    public int NumNames { get; }
    public List`1<FormatRecord> Formats { get; }
    public IList Hyperlinks { get; }
    public IList Records { get; }
    public bool IsUsing1904DateWindowing { get; }
    public PaletteRecord CustomPalette { get; }
    public WindowOneRecord WindowOne { get; }
    public DrawingManager2 DrawingManager { get; }
    public WriteProtectRecord WriteProtect { get; }
    public WriteAccessRecord WriteAccess { get; }
    public FileSharingRecord FileSharing { get; }
    public bool IsWriteProtected { get; }
    public RecalcIdRecord RecalcId { get; }
    private static InternalWorkbook();
    public static InternalWorkbook CreateWorkbook(List`1<Record> recs);
    public NameCommentRecord GetNameCommentRecord(NameRecord nameRecord);
    public static InternalWorkbook CreateWorkbook();
    public NameRecord GetSpecificBuiltinRecord(byte name, int sheetIndex);
    public ExternalName GetExternalName(int externSheetIndex, int externNameIndex);
    public void RemoveBuiltinRecord(byte name, int sheetIndex);
    public int get_NumRecords();
    public FontRecord GetFontRecordAt(int idx);
    public FontRecord CreateNewFont();
    public void CloneDrawings(InternalSheet sheet);
    public int get_NumberOfFontRecords();
    public void SetSheetBof(int sheetIndex, int pos);
    public BackupRecord get_BackupRecord();
    public void SetSheetName(int sheetnum, string sheetname);
    private BoundSheetRecord GetBoundSheetRec(int sheetIndex);
    public bool ContainsSheetName(string name, int excludeSheetIdx);
    public void SetSheetName(int sheetnum, string sheetname, short encoding);
    public void SetSheetOrder(string sheetname, int pos);
    public string GetSheetName(int sheetIndex);
    public bool IsSheetHidden(int sheetnum);
    public bool IsSheetVeryHidden(int sheetnum);
    public void SetSheetHidden(int sheetnum, bool hidden);
    public void SetSheetHidden(int sheetnum, int hidden);
    public int GetSheetIndex(string name);
    private void CheckSheets(int sheetnum);
    public void RemoveSheet(int sheetIndex);
    private void FixTabIdRecord();
    public int get_NumSheets();
    public int get_NumExFormats();
    public int GetFontIndex(FontRecord font);
    public StyleRecord GetStyleRecord(int xfIndex);
    public ExtendedFormatRecord GetExFormatAt(int index);
    public ExtendedFormatRecord CreateCellXF();
    public int AddSSTString(UnicodeString str);
    public UnicodeString GetSSTString(int str);
    public void InsertSST();
    public int Serialize(int offset, Byte[] data);
    public void PreSerialize();
    public int get_Size();
    private static Record CreateBOF();
    [ObsoleteAttribute]
protected Record CreateInterfaceHdr();
    private static Record CreateMMS();
    [ObsoleteAttribute]
protected Record CreateInterfaceEnd();
    private static Record CreateWriteAccess();
    private static Record CreateCodepage();
    private static Record CreateDSF();
    private static Record CreateTabId();
    private static Record CreateFnGroupCount();
    private static Record CreateWindowProtect();
    private static ProtectRecord CreateProtect();
    private static Record CreatePassword();
    private static ProtectionRev4Record CreateProtectionRev4();
    private static Record CreatePasswordRev4();
    private static Record CreateWindowOne();
    private static Record CreateBackup();
    private static Record CreateHideObj();
    private static Record CreateDateWindow1904();
    private static Record CreatePrecision();
    private static Record CreateRefreshAll();
    private static Record CreateBookBool();
    private static Record CreateFont();
    private static Record CreateExtendedFormat(int id);
    private static ExtendedFormatRecord CreateExtendedFormat();
    public StyleRecord CreateStyleRecord(int xfIndex);
    private static Record CreateStyle(int id);
    private static PaletteRecord CreatePalette();
    private static UseSelFSRecord CreateUseSelFS();
    private static Record CreateBoundSheet(int id);
    private static Record CreateCountry();
    private static Record CreateExtendedSST();
    private LinkTable get_OrCreateLinkTable();
    private LinkTable GetOrCreateLinkTable();
    public int LinkExternalWorkbook(string name, IWorkbook externalWorkbook);
    public string FindSheetFirstNameFromExternSheet(int externSheetIndex);
    public string FindSheetLastNameFromExternSheet(int externSheetIndex);
    private string FindSheetNameFromIndex(int internalSheetIndex);
    public ExternalSheet GetExternalSheet(int externSheetIndex);
    public int GetFirstSheetIndexFromExternSheetIndex(int externSheetNumber);
    public int GetLastSheetIndexFromExternSheetIndex(int externSheetNumber);
    public int CheckExternSheet(int sheetNumber);
    public short checkExternSheet(int firstSheetNumber, int lastSheetNumber);
    public int GetExternalSheetIndex(string workbookName, string sheetName);
    public int GetExternalSheetIndex(string workbookName, string firstSheetName, string lastSheetName);
    public int get_NumNames();
    public NameXPtg GetNameXPtg(string name, int sheetRefIndex, UDFFinder udf);
    public NameXPtg GetNameXPtg(string name, UDFFinder udf);
    public NameRecord GetNameRecord(int index);
    public NameRecord CreateName();
    public NameRecord AddName(NameRecord name);
    public NameRecord CreateBuiltInName(byte builtInName, int index);
    public void RemoveName(int namenum);
    public void UpdateNameCommentRecordCache(NameCommentRecord commentRecord);
    public short GetFormat(string format, bool CreateIfNotFound);
    public List`1<FormatRecord> get_Formats();
    public int CreateFormat(string formatString);
    private static FormatRecord CreateFormat(int id);
    public Record FindFirstRecordBySid(short sid);
    public int FindFirstRecordLocBySid(short sid);
    public Record FindNextRecordBySid(short sid, int pos);
    public IList get_Hyperlinks();
    public IList get_Records();
    public bool get_IsUsing1904DateWindowing();
    public PaletteRecord get_CustomPalette();
    public DrawingManager2 FindDrawingGroup();
    public void CreateDrawingGroup();
    public WindowOneRecord get_WindowOne();
    public void RemoveFontRecord(FontRecord rec);
    public void RemoveExFormatRecord(ExtendedFormatRecord rec);
    public void RemoveExFormatRecord(int index);
    public EscherBSERecord GetBSERecord(int pictureIndex);
    public int AddBSERecord(EscherBSERecord e);
    public DrawingManager2 get_DrawingManager();
    public WriteProtectRecord get_WriteProtect();
    public WriteAccessRecord get_WriteAccess();
    public FileSharingRecord get_FileSharing();
    public bool get_IsWriteProtected();
    public void WriteProtectWorkbook(string password, string username);
    public void UnwriteProtectWorkbook();
    public string ResolveNameXText(int reFindex, int definedNameIndex);
    public NameRecord CloneFilter(int filterDbNameIndex, int newSheetIndex);
    public void UpdateNamesAfterCellShift(FormulaShifter shifter);
    public RecalcIdRecord get_RecalcId();
    public bool ChangeExternalReference(string oldUrl, string newUrl);
}
public class NPOI.HSSF.Model.LinkTable : object {
    private ExternalBookBlock[] _externalBookBlocks;
    private ExternSheetRecord _externSheetRecord;
    private List`1<NameRecord> _definedNames;
    private int _recordCount;
    private WorkbookRecordList _workbookRecordList;
    public int RecordCount { get; }
    public int NumNames { get; }
    public LinkTable(List`1<Record> inputList, int startIndex, WorkbookRecordList workbookRecordList, Dictionary`2<string, NameCommentRecord> commentRecords);
    public LinkTable(int numberOfSheets, WorkbookRecordList workbookRecordList);
    private static ExternSheetRecord ReadExtSheetRecord(RecordStream rs);
    public int get_RecordCount();
    public NameRecord GetSpecificBuiltinRecord(byte builtInCode, int sheetNumber);
    public void RemoveBuiltinRecord(byte name, int sheetIndex);
    public int GetFirstInternalSheetIndexForExtIndex(int extRefIndex);
    public int GetLastInternalSheetIndexForExtIndex(int extRefIndex);
    public void RemoveSheet(int sheetIdx);
    public int get_NumNames();
    private int ExtendExternalBookBlocks(ExternalBookBlock newBlock);
    private int FindRefIndexFromExtBookIndex(int extBookIndex);
    public NameXPtg GetNameXPtg(string name, int sheetRefIndex);
    public NameRecord GetNameRecord(int index);
    public void AddName(NameRecord name);
    public NameXPtg AddNameXPtg(string name);
    public void RemoveName(int namenum);
    private static int GetSheetIndex(String[] sheetNames, string sheetName);
    private int GetExternalWorkbookIndex(string workbookName);
    public int LinkExternalWorkbook(string name, IWorkbook externalWorkbook);
    public int GetExternalSheetIndex(string workbookName, string firstSheetName, string lastSheetName);
    public String[] GetExternalBookAndSheetName(int extRefIndex);
    public int CheckExternSheet(int sheetIndex);
    public int CheckExternSheet(int firstSheetIndex, int lastSheetIndex);
    private int FindFirstRecordLocBySid(short sid);
    public string ResolveNameXText(int refIndex, int definedNameIndex, InternalWorkbook workbook);
    public int ResolveNameXIx(int refIndex, int definedNameIndex);
    public bool ChangeExternalReference(string oldUrl, string newUrl);
}
internal class NPOI.HSSF.Model.ParseNode : object {
    public static ParseNode[] EMPTY_ARRAY;
    private Ptg _token;
    private ParseNode[] _children;
    private bool _isIf;
    private int _tokenCount;
    public Ptg Token { get; }
    public ParseNode[] Children { get; }
    public ParseNode(Ptg token, ParseNode[] children);
    public ParseNode(Ptg token);
    public ParseNode(Ptg token, ParseNode child0);
    public ParseNode(Ptg token, ParseNode child0, ParseNode child1);
    private static ParseNode();
    private int GetTokenCount();
    public static Ptg[] ToTokenArray(ParseNode rootNode);
    private void CollectPtgs(TokenCollector temp);
    private void CollectIfPtgs(TokenCollector temp);
    private static bool IsIf(Ptg token);
    public Ptg get_Token();
    public ParseNode[] get_Children();
}
public class NPOI.HSSF.Model.RecordOrderer : object {
    public static void AddNewSheetRecord(List`1<RecordBase> sheetRecords, RecordBase newRecord);
    private static int FindSheetInsertPos(List`1<RecordBase> records, Type recClass);
    private static int GetWorksheetProtectionBlockInsertPos(List`1<RecordBase> records);
    private static bool IsProtectionSubsequentRecord(object rb);
    private static int GetPageBreakRecordInsertPos(List`1<RecordBase> records);
    private static bool IsPageBreakPriorRecord(RecordBase rb);
    private static int FindInsertPosForNewCondFormatTable(List`1<RecordBase> records);
    private static int FindInsertPosForNewMergedRecordTable(List`1<RecordBase> records);
    private static int FindDataValidationTableInsertPos(List`1<RecordBase> records);
    private static bool IsDVTPriorRecord(RecordBase rb);
    private static bool IsDVTSubsequentRecord(short sid);
    private static int GetDimensionsIndex(List`1<RecordBase> records);
    private static int GetGutsRecordInsertPos(List`1<RecordBase> records);
    private static bool IsGutsPriorRecord(RecordBase rb);
    public static bool IsEndOfRowBlock(int sid);
    public static bool IsRowBlockRecord(int sid);
}
public class NPOI.HSSF.Model.RecordStream : object {
    private IList _list;
    private int _nextIndex;
    private int _endIx;
    private int _countRead;
    public RecordStream(IList inputList, int startIndex, int endIx);
    public RecordStream(IList records, int startIx);
    public bool HasNext();
    public Record GetNext();
    public int PeekNextSid();
    public Type PeekNextClass();
    public int GetCountRead();
    public int PeekNextChartSid();
    public void FindChartSubStream();
}
public class NPOI.HSSF.Model.RowBlocksReader : object {
    private ArrayList _plainRecords;
    private SharedValueManager _sfm;
    private MergeCellsRecord[] _mergedCellsRecords;
    public MergeCellsRecord[] LooseMergedCells { get; }
    public SharedValueManager SharedFormulaManager { get; }
    public RecordStream PlainRecordStream { get; }
    public RowBlocksReader(RecordStream rs);
    public MergeCellsRecord[] get_LooseMergedCells();
    public SharedValueManager get_SharedFormulaManager();
    public RecordStream get_PlainRecordStream();
}
public class NPOI.HSSF.Model.UnsupportedBOFType : RecordFormatException {
    private BOFRecordType type;
    public BOFRecordType Type { get; }
    public UnsupportedBOFType(BOFRecordType type);
    public BOFRecordType get_Type();
}
[DefaultMemberAttribute("Item")]
public class NPOI.HSSF.Model.WorkbookRecordList : object {
    private List`1<Record> records;
    private int protpos;
    private int bspos;
    private int tabpos;
    private int fontpos;
    private int xfpos;
    private int backuppos;
    private int namepos;
    private int supbookpos;
    private int externsheetPos;
    private int palettepos;
    public List`1<Record> Records { get; public set; }
    public int Count { get; }
    public Record Item { get; }
    public int Protpos { get; public set; }
    public int Bspos { get; public set; }
    public int Tabpos { get; public set; }
    public int Fontpos { get; public set; }
    public int Xfpos { get; public set; }
    public int Backuppos { get; public set; }
    public int Palettepos { get; public set; }
    public int Namepos { get; public set; }
    public int Supbookpos { get; public set; }
    public int ExternsheetPos { get; public set; }
    public List`1<Record> get_Records();
    public void set_Records(List`1<Record> value);
    public int get_Count();
    public Record get_Item(int index);
    public void Add(int pos, Record r);
    public IEnumerator`1<Record> GetEnumerator();
    public void Remove(Record record);
    public void Remove(int pos);
    public int get_Protpos();
    public void set_Protpos(int value);
    public int get_Bspos();
    public void set_Bspos(int value);
    public int get_Tabpos();
    public void set_Tabpos(int value);
    public int get_Fontpos();
    public void set_Fontpos(int value);
    public int get_Xfpos();
    public void set_Xfpos(int value);
    public int get_Backuppos();
    public void set_Backuppos(int value);
    public int get_Palettepos();
    public void set_Palettepos(int value);
    public int get_Namepos();
    public void set_Namepos(int value);
    public int get_Supbookpos();
    public void set_Supbookpos(int value);
    public int get_ExternsheetPos();
    public void set_ExternsheetPos(int value);
}
public class NPOI.HSSF.OldExcelFormatException : Exception {
    public OldExcelFormatException(string s);
}
public abstract class NPOI.HSSF.Record.AbstractEscherHolderRecord : Record {
    private static bool DESERIALISE;
    private List`1<EscherRecord> escherRecords;
    private LazilyConcatenatedByteArray rawDataContainer;
    protected string RecordName { get; }
    public int RecordSize { get; }
    public List`1<EscherRecord> EscherRecords { get; }
    public Byte[] RawData { get; public set; }
    private static AbstractEscherHolderRecord();
    public AbstractEscherHolderRecord(RecordInputStream in1);
    protected void ConvertRawBytesToEscherRecords();
    private void ConvertToEscherRecords(int offset, int size, Byte[] data);
    public virtual string ToString();
    protected abstract virtual string get_RecordName();
    public virtual int Serialize(int offset, Byte[] data);
    public virtual int get_RecordSize();
    public virtual object Clone();
    public void AddEscherRecord(int index, EscherRecord element);
    public bool AddEscherRecord(EscherRecord element);
    public List`1<EscherRecord> get_EscherRecords();
    public void ClearEscherRecords();
    public EscherContainerRecord GetEscherContainer();
    public EscherRecord FindFirstWithId(short id);
    private EscherRecord FindFirstWithId(short id, List`1<EscherRecord> records);
    public EscherRecord GetEscherRecord(int index);
    public void Join(AbstractEscherHolderRecord record);
    public void ProcessContinueRecord(Byte[] record);
    public Byte[] get_RawData();
    public void set_RawData(Byte[] value);
    public void Decode();
}
public class NPOI.HSSF.Record.Aggregates.CFRecordsAggregate : RecordAggregate {
    private static int MAX_97_2003_CONDTIONAL_FORMAT_RULES;
    public static short sid;
    private CFHeaderBase header;
    private List`1<CFRuleBase> rules;
    public short Sid { get; }
    public CFHeaderBase Header { get; }
    public int NumberOfRules { get; }
    private CFRecordsAggregate(CFHeaderBase pHeader, CFRuleBase[] pRules);
    public CFRecordsAggregate(CellRangeAddress[] regions, CFRuleBase[] rules);
    private static CFHeaderBase CreateHeader(CellRangeAddress[] regions, CFRuleBase[] rules);
    public static CFRecordsAggregate CreateCFAggregate(RecordStream rs);
    [ObsoleteAttribute("Not found in poi(2015-07-14), maybe was removed")]
public static CFRecordsAggregate CreateCFAggregate(IList recs, int pOffset);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    public CFRecordsAggregate CloneCFAggregate();
    public virtual short get_Sid();
    public virtual int Serialize(int offset, Byte[] data);
    public CFHeaderBase get_Header();
    private void CheckRuleIndex(int idx);
    private void CheckRuleType(CFRuleBase r);
    public CFRuleBase GetRule(int idx);
    public void SetRule(int idx, CFRuleBase r);
    public bool UpdateFormulasAfterCellShift(FormulaShifter shifter, int currentExternSheetIx);
    private static CellRangeAddress ShiftRange(FormulaShifter shifter, CellRangeAddress cra, int currentExternSheetIx);
    public void AddRule(CFRuleBase r);
    public int get_NumberOfRules();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Aggregates.Chart.AttachedLabelAggregate : ChartRecordAggregate {
    private TextRecord text;
    private PosRecord pos;
    private FontIndexRecord fontX;
    private AlRunsRecord alRuns;
    private LinkedDataRecord brai;
    private SeriesTextRecord seriesText;
    private FrameAggregate frame;
    private ObjectLinkRecord objectLink;
    private DataLabExtContentsRecord dataLab;
    private CrtLayout12Record crtLayout;
    private TextPropsAggregate textProps;
    private CrtMlFrtAggregate crtMlFrt;
    private bool _isFirst;
    public bool IsFirst { get; public set; }
    public ObjectLinkRecord ObjectLink { get; }
    public AttachedLabelAggregate(RecordStream rs, ChartRecordAggregate container);
    public bool get_IsFirst();
    public void set_IsFirst(bool value);
    public ObjectLinkRecord get_ObjectLink();
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.AxesAggregate : ChartRecordAggregate {
    private IVAxisAggregate ivaxis;
    private DVAxisAggregate dvaxis;
    private DVAxisAggregate dvaxisSecond;
    private SeriesAxisAggregate seriesAxis;
    private List`1<AttachedLabelAggregate> attachedLabelList;
    private PlotAreaRecord plotArea;
    private FrameAggregate frame;
    public AxesAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.AxisParentAggregate : ChartRecordAggregate {
    private AxisParentRecord axisPraent;
    private PosRecord pos;
    private AxesAggregate axes;
    private List`1<CRTAggregate> crtList;
    public AxisParentRecord AxisParent { get; }
    public AxisParentAggregate(RecordStream rs, ChartRecordAggregate container);
    public AxisParentRecord get_AxisParent();
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.AXMAggregate : ChartRecordAggregate {
    private YMultRecord yMult;
    private ChartStartObjectRecord startObject;
    private AttachedLabelAggregate attachedLabel;
    private ChartEndObjectRecord endObject;
    public AXMAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.AXSAggregate : ChartRecordAggregate {
    private IFmtRecordRecord ifmt;
    private TickRecord tick;
    private FontIndexRecord fontx;
    private List`1<AxisLineFormatRecord> axisLines;
    private List`1<LineFormatRecord> lineFormats;
    private AreaFormatRecord areaFormat;
    private GelFrameAggregate gelFrame;
    private List`1<ShapePropsAggregate> shapes;
    private TextPropsStreamRecord textProps;
    private List`1<ContinueFrt12Record> continues;
    public AXSAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.ChartFormatsAggregate : ChartRecordAggregate {
    private ChartRecord chart;
    private List`1<FontListAggregate> fontList;
    private SCLRecord scl;
    private PlotGrowthRecord plotGrowth;
    private FrameAggregate frame;
    private List`1<SeriesFormatAggregate> seriesFormatList;
    private List`1<SSAggregate> ssList;
    private ShtPropsRecord shtProps;
    private List`1<DFTTextAggregate> dftTextList;
    private AxesUsedRecord axesUsed;
    private AxisParentAggregate axisParent1;
    private AxisParentAggregate axisParent2;
    private CrtLayout12ARecord crt12A;
    private DatAggregate dat;
    private List`1<AttachedLabelAggregate> attachedLabelList;
    private CrtMlFrtAggregate crtMlFrt;
    private List`1<ChartFormatsAttachedLabelAggregate> cfalList;
    private TextPropsAggregate textProps;
    private List`1<CrtMlFrtAggregate> mlfrtList;
    public ChartFormatsAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public abstract class NPOI.HSSF.Record.Aggregates.Chart.ChartRecordAggregate : RecordAggregate {
    public static string RuleName_DAT;
    public static string RuleName_TEXTPROPS;
    public static string RuleName_SS;
    public static string RuleName_SHAPEPROPS;
    public static string RuleName_SERIESFORMAT;
    public static string RuleName_SERIESAXIS;
    public static string RuleName_LD;
    public static string RuleName_IVAXIS;
    public static string RuleName_GELFRAME;
    public static string RuleName_FRAME;
    public static string RuleName_FONTLIST;
    public static string RuleName_DVAXIS;
    public static string RuleName_DROPBAR;
    public static string RuleName_DFTTEXT;
    public static string RuleName_CRTMLFRT;
    public static string RuleName_CRT;
    public static string RuleName_CHARTFOMATS;
    public static string RuleName_AXS;
    public static string RuleName_AXM;
    public static string RuleName_AXISPARENT;
    public static string RuleName_AXES;
    public static string RuleName_ATTACHEDLABEL;
    public static string RuleName_LEGENDEXCEPTION;
    public static string RuleName_CHARTSHEET;
    private string _rulename;
    private ChartRecordAggregate _container;
    private static StartBlockStack blocks;
    private bool _isInStartObject;
    public static short ChartSpecificFutureRecordLowerSid;
    public static short ChartSpecificFutureRecordHigherSid;
    protected string RuleName { get; private set; }
    protected ChartRecordAggregate Container { get; private set; }
    protected bool IsInStartObject { get; protected set; }
    protected ChartRecordAggregate(string ruleName, ChartRecordAggregate container);
    private static ChartRecordAggregate();
    protected string get_RuleName();
    private void set_RuleName(string value);
    protected ChartRecordAggregate get_Container();
    private void set_Container(ChartRecordAggregate value);
    protected bool get_IsInStartObject();
    protected void set_IsInStartObject(bool value);
    protected virtual bool ShoudWriteStartBlock();
    private bool IsInRule(string ruleName);
    protected T GetContainer(string ruleName);
    protected void WriteStartBlock(RecordVisitor rv);
    protected void WriteEndBlock(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.ChartSheetAggregate : ChartRecordAggregate {
    private BOFRecord _bofRec;
    private List`1<RecordBase> _recs;
    private PageSettingsBlock _psBlock;
    private ChartFormatsAggregate chartFormats;
    private SeriesDataAggregate seriesData;
    internal int AttachLabelCount;
    public ChartSheetAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.CRTAggregate : ChartRecordAggregate {
    private ChartFormatRecord chartForamt;
    private Record chartTypeRecord;
    private BopPopCustomRecord bopPopCustom;
    private CrtLinkRecord crtLink;
    private SeriesListRecord seriesList;
    private Chart3dRecord chart3d;
    private LDAggregate ld;
    private DropBarAggregate dropBar1;
    private DropBarAggregate dropBar2;
    private Dictionary`2<CrtLineRecord, LineFormatRecord> dicLines;
    private DFTTextAggregate dft1;
    private DFTTextAggregate dft2;
    private DataLabExtContentsRecord dataLabExtContents;
    private SSAggregate ss;
    private List`1<ShapePropsAggregate> shapeList;
    public CRTAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.CrtMlFrtAggregate : ChartRecordAggregate {
    private CrtMlFrtRecord crtmlFrt;
    private List`1<CrtMlFrtContinueRecord> continues;
    public CrtMlFrtAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.DatAggregate : ChartRecordAggregate {
    private DatRecord dat;
    private LDAggregate ld;
    public DatAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.DFTTextAggregate : ChartRecordAggregate {
    private DataLabExtRecord dataLabExt;
    private ChartStartObjectRecord startObject;
    private DefaultTextRecord defaultText;
    private AttachedLabelAggregate attachedLabel;
    private ChartEndObjectRecord endObject;
    public DefaultTextRecord DefaultText { get; }
    public DFTTextAggregate(RecordStream rs, ChartRecordAggregate container);
    public DefaultTextRecord get_DefaultText();
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.DropBarAggregate : ChartRecordAggregate {
    private DropBarRecord dropBar;
    private LineFormatRecord lineFormat;
    private AreaFormatRecord areaFormat;
    private GelFrameAggregate gelFrame;
    private ShapePropsAggregate shapProps;
    public DropBarAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.DVAxisAggregate : ChartRecordAggregate {
    private AxisRecord axis;
    private ValueRangeRecord valueRange;
    private AXMAggregate axm;
    private AXSAggregate axs;
    private CrtMlFrtAggregate crtmlfrt;
    public AxisRecord Axis { get; }
    public DVAxisAggregate(RecordStream rs, ChartRecordAggregate container, AxisRecord axis);
    public AxisRecord get_Axis();
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.FontListAggregate : ChartRecordAggregate {
    private FrtFontListRecord frtFontList;
    private ChartStartObjectRecord startObject;
    private Dictionary`2<FontRecord, FbiRecord> dicFonts;
    private ChartEndObjectRecord endObject;
    public FontListAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.FrameAggregate : ChartRecordAggregate {
    private FrameRecord frame;
    private LineFormatRecord lineFormat;
    private AreaFormatRecord areaFormat;
    private GelFrameAggregate gelFrame;
    private ShapePropsAggregate shapeProps;
    public FrameAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    protected virtual bool ShoudWriteStartBlock();
}
public class NPOI.HSSF.Record.Aggregates.Chart.GelFrameAggregate : ChartRecordAggregate {
    private GelFrameRecord gelFrame1;
    private GelFrameRecord gelFrame2;
    private List`1<ContinueRecord> continues;
    private PicFRecord picF;
    public GelFrameAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.IVAxisAggregate : ChartRecordAggregate {
    private AxisRecord axis;
    private CatSerRangeRecord catSerRange;
    private AxcExtRecord axcExt;
    private CatLabRecord catLab;
    private AXSAggregate axs;
    private List`1<CrtMlFrtAggregate> crtmlfrtList;
    public IVAxisAggregate(RecordStream rs, ChartRecordAggregate container, AxisRecord axis);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.LDAggregate : ChartRecordAggregate {
    private LegendRecord legend;
    private PosRecord pos;
    private AttachedLabelAggregate attachedLabel;
    private FrameAggregate frame;
    private CrtLayout12Record crtLayout;
    private TextPropsAggregate textProps;
    private CrtMlFrtAggregate crtMlFrt;
    public LDAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.SeriesAxisAggregate : ChartRecordAggregate {
    private AxisRecord axis;
    private CatSerRangeRecord catSerRange;
    private AXSAggregate axs;
    private CrtMlFrtAggregate crtmlfrt;
    public SeriesAxisAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.SeriesDataAggregate : RecordAggregate {
    private DimensionsRecord dimensions;
    private Dictionary`2<SeriesIndexRecord, List`1<Record>> dicData;
    public SeriesDataAggregate(RecordStream rs);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.SeriesFormatAggregate : ChartRecordAggregate {
    private SeriesRecord series;
    private Dictionary`2<LinkedDataRecord, SeriesTextRecord> dic4AI;
    private List`1<SSAggregate> ssList;
    private SerToCrtRecord serToCrt;
    private SerParentRecord serParent;
    private SerAuxTrendRecord serAuxTrend;
    private SerAuxErrBarRecord serAuxErrBar;
    private List`1<LegendExceptionAggregate> leList;
    private short _seriesIndex;
    public short SeriesIndex { get; public set; }
    public SeriesFormatAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    public short get_SeriesIndex();
    public void set_SeriesIndex(short value);
}
public class NPOI.HSSF.Record.Aggregates.Chart.ShapePropsAggregate : ChartRecordAggregate {
    private ShapePropsStreamRecord shapProps;
    private List`1<ContinueFrt12Record> continues;
    public ShapePropsAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.SSAggregate : ChartRecordAggregate {
    private DataFormatRecord dataFormat;
    private Chart3DBarShapeRecord chart3DBarShape;
    private LineFormatRecord lineFormat;
    private AreaFormatRecord areaFormat;
    private PieFormatRecord pieFormat;
    private SerFmtRecord serFmt;
    private GelFrameAggregate gelFrame;
    private MarkerFormatRecord markerFormat;
    private AttachedLabelRecord attachedLabel;
    private ShapePropsAggregate shapeProps1;
    private ShapePropsAggregate shapeProps2;
    private CrtMlFrtAggregate crtMlFrt;
    public DataFormatRecord DataFormat { get; }
    public SSAggregate(RecordStream rs, ChartRecordAggregate container);
    public DataFormatRecord get_DataFormat();
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.Chart.TextPropsAggregate : ChartRecordAggregate {
    private TextPropsStreamRecord textPropsStream;
    private RichTextStreamRecord richTextStream;
    private List`1<ContinueFrt12Record> continues;
    public TextPropsAggregate(RecordStream rs, ChartRecordAggregate container);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.ChartSubstreamRecordAggregate : RecordAggregate {
    private BOFRecord _bofRec;
    private List`1<RecordBase> _recs;
    private PageSettingsBlock _psBlock;
    public ChartSubstreamRecordAggregate(RecordStream rs);
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.ColumnInfoRecordsAggregate : RecordAggregate {
    private List`1<ColumnInfoRecord> records;
    public short Sid { get; }
    public int NumColumns { get; }
    public int RecordSize { get; }
    public int MaxOutlineLevel { get; }
    public ColumnInfoRecordsAggregate(RecordStream rs);
    public virtual short get_Sid();
    public int get_NumColumns();
    public virtual int get_RecordSize();
    public IEnumerator GetEnumerator();
    public sealed virtual object Clone();
    public void InsertColumn(ColumnInfoRecord col);
    public void InsertColumn(int idx, ColumnInfoRecord col);
    public virtual int Serialize(int offset, Byte[] data);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    public int FindStartOfColumnOutlineGroup(int idx);
    public int FindEndOfColumnOutlineGroup(int idx);
    public ColumnInfoRecord GetColInfo(int idx);
    public bool IsColumnGroupCollapsed(int idx);
    public bool IsColumnGroupHiddenByParent(int idx);
    public void CollapseColumn(int columnNumber);
    public void ExpandColumn(int columnNumber);
    private static void SetColumnInfoFields(ColumnInfoRecord ci, Nullable`1<short> xfStyle, Nullable`1<double> width, Nullable`1<int> level, Nullable`1<bool> hidden, Nullable`1<bool> collapsed);
    private void AttemptMergeColInfoRecords(int colInfoIx);
    private static bool MergeColInfoRecords(ColumnInfoRecord ciA, ColumnInfoRecord ciB);
    private int SetGroupHidden(int pIdx, int level, bool hidden);
    public void SetColumn(int targetColumnIx, Nullable`1<short> xfIndex, Nullable`1<double> width, Nullable`1<int> level, Nullable`1<bool> hidden, Nullable`1<bool> collapsed);
    private ColumnInfoRecord CopyColInfo(ColumnInfoRecord ci);
    private void SetColumnInfoFields(ColumnInfoRecord ci, short xfStyle, short width, int level, bool hidden, bool collapsed);
    [ObsoleteAttribute("Not found in poi")]
public void CollapseColInfoRecords(int columnIdx);
    public void GroupColumnRange(int fromColumnIx, int toColumnIx, bool indent);
    public ColumnInfoRecord FindColumnInfo(int columnIndex);
    private int FindColInfoIdx(int columnIx, int fromColInfoIdx);
    public int get_MaxOutlineLevel();
    public int GetOutlineLevel(int columnIndex);
}
public class NPOI.HSSF.Record.Aggregates.ConditionalFormattingTable : RecordAggregate {
    private IList`1<CFRecordsAggregate> _cfHeaders;
    public int Count { get; }
    public ConditionalFormattingTable(RecordStream rs);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    public int Add(CFRecordsAggregate cfAggregate);
    public int get_Count();
    public CFRecordsAggregate Get(int index);
    public void Remove(int index);
    private void CheckIndex(int index);
    public void UpdateFormulasAfterCellShift(FormulaShifter shifter, int externSheetIndex);
}
public class NPOI.HSSF.Record.Aggregates.CustomViewSettingsRecordAggregate : RecordAggregate {
    private Record _begin;
    private Record _end;
    private List`1<RecordBase> _recs;
    private PageSettingsBlock _psBlock;
    public CustomViewSettingsRecordAggregate(RecordStream rs);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    public static bool IsBeginRecord(int sid);
    public void Append(RecordBase r);
}
public class NPOI.HSSF.Record.Aggregates.DataValidityTable : RecordAggregate {
    private DVALRecord _headerRec;
    private IList _validationList;
    public DataValidityTable(RecordStream rs);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    public void AddDataValidation(DVRecord dvRecord);
    public void RemoveDataValidation(DVRecord dvRecord);
}
public class NPOI.HSSF.Record.Aggregates.FormulaRecordAggregate : RecordAggregate {
    public static short sid;
    private FormulaRecord _formulaRecord;
    private SharedValueManager _sharedValueManager;
    private StringRecord _stringRecord;
    private SharedFormulaRecord _sharedFormulaRecord;
    public bool IsPartOfArrayFormula { get; }
    public int RecordSize { get; }
    public short Sid { get; }
    public FormulaRecord FormulaRecord { get; public set; }
    public StringRecord StringRecord { get; public set; }
    public short XFIndex { get; public set; }
    public int Column { get; public set; }
    public int Row { get; public set; }
    public string StringValue { get; }
    public Ptg[] FormulaTokens { get; }
    public FormulaRecordAggregate(FormulaRecord formulaRec, StringRecord stringRec, SharedValueManager svm);
    public void NotifyFormulaChanging();
    public bool get_IsPartOfArrayFormula();
    public virtual int Serialize(int offset, Byte[] data);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    public virtual int get_RecordSize();
    public virtual short get_Sid();
    private static void HandleMissingSharedFormulaRecord(FormulaRecord formula);
    public FormulaRecord get_FormulaRecord();
    public void set_FormulaRecord(FormulaRecord value);
    public StringRecord get_StringRecord();
    public void set_StringRecord(StringRecord value);
    public sealed virtual short get_XFIndex();
    public sealed virtual void set_XFIndex(short value);
    public sealed virtual int get_Column();
    public sealed virtual void set_Column(int value);
    public sealed virtual int get_Row();
    public sealed virtual void set_Row(int value);
    public sealed virtual int CompareTo(object o);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string get_StringValue();
    public void SetCachedDoubleResult(double value);
    public void SetCachedStringResult(string value);
    public void SetCachedBooleanResult(bool value);
    public void SetCachedErrorResult(int errorCode);
    public void SetCachedErrorResult(FormulaError error);
    public sealed virtual object Clone();
    public Ptg[] get_FormulaTokens();
    public void SetParsedExpression(Ptg[] ptgs);
    public void UnlinkSharedFormula();
    public CellRangeAddress GetArrayFormulaRange();
    public void SetArrayFormula(CellRangeAddress r, Ptg[] ptgs);
    public CellRangeAddress RemoveArrayFormula(int rowIndex, int columnIndex);
}
public class NPOI.HSSF.Record.Aggregates.MergedCellsTable : RecordAggregate {
    private static int MAX_MERGED_REGIONS;
    private List`1<CellRangeAddress> _mergedRegions;
    public int RecordSize { get; }
    public List`1<CellRangeAddress> MergedRegions { get; }
    public int NumberOfMergedRegions { get; }
    public void Read(RecordStream rs);
    public virtual int get_RecordSize();
    public virtual void VisitContainedRecords(RecordVisitor rv);
    public void AddRecords(MergeCellsRecord[] mcrs);
    private void AddMergeCellsRecord(MergeCellsRecord mcr);
    public List`1<CellRangeAddress> get_MergedRegions();
    public CellRangeAddress Get(int index);
    public void Remove(int index);
    private void CheckIndex(int index);
    public void AddArea(int rowFrom, int colFrom, int rowTo, int colTo);
    public int get_NumberOfMergedRegions();
}
public class NPOI.HSSF.Record.Aggregates.PageSettingsBlock : RecordAggregate {
    private PageBreakRecord _rowBreaksRecord;
    private PageBreakRecord _columnBreaksRecord;
    private HeaderRecord header;
    private FooterRecord footer;
    private HCenterRecord _hCenter;
    private VCenterRecord _vCenter;
    private LeftMarginRecord _leftMargin;
    private RightMarginRecord _rightMargin;
    private TopMarginRecord _topMargin;
    private BottomMarginRecord _bottomMargin;
    private PrintSetupRecord printSetup;
    private Record _bitmap;
    private HeaderFooterRecord _headerFooter;
    private List`1<HeaderFooterRecord> _sviewHeaderFooters;
    private List`1<PLSAggregate> _plsRecords;
    private Record _printSize;
    private PageBreakRecord RowBreaksRecord { get; }
    private PageBreakRecord ColumnBreaksRecord { get; }
    public HeaderRecord Header { get; public set; }
    public FooterRecord Footer { get; public set; }
    public PrintSetupRecord PrintSetup { get; public set; }
    public Int32[] RowBreaks { get; }
    public int NumRowBreaks { get; }
    public Int32[] ColumnBreaks { get; }
    public int NumColumnBreaks { get; }
    public VCenterRecord VCenter { get; }
    public HCenterRecord HCenter { get; }
    public PageSettingsBlock(RecordStream rs);
    public static bool IsComponentRecord(int sid);
    private bool ReadARecord(RecordStream rs);
    private void CheckNotPresent(Record rec);
    private PageBreakRecord get_RowBreaksRecord();
    private PageBreakRecord get_ColumnBreaksRecord();
    public IEnumerator GetEnumerator();
    public void SetColumnBreak(int column, int fromRow, int toRow);
    public void RemoveColumnBreak(int column);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    private static void VisitIfPresent(Record r, RecordVisitor rv);
    private static void VisitIfPresent(PageBreakRecord r, RecordVisitor rv);
    private static HCenterRecord CreateHCenter();
    private static VCenterRecord CreateVCenter();
    private static PrintSetupRecord CreatePrintSetup();
    public HeaderRecord get_Header();
    public void set_Header(HeaderRecord value);
    public FooterRecord get_Footer();
    public void set_Footer(FooterRecord value);
    public PrintSetupRecord get_PrintSetup();
    public void set_PrintSetup(PrintSetupRecord value);
    private IMargin GetMarginRec(MarginType margin);
    public double GetMargin(MarginType margin);
    public void SetMargin(MarginType margin, double size);
    private static void ShiftBreaks(PageBreakRecord breaks, int start, int stop, int count);
    public void SetRowBreak(int row, short fromCol, short toCol);
    public void RemoveRowBreak(int row);
    public bool IsRowBroken(int row);
    public bool IsColumnBroken(int column);
    public void ShiftRowBreaks(int startingRow, int endingRow, int count);
    public void ShiftColumnBreaks(short startingCol, short endingCol, short count);
    public Int32[] get_RowBreaks();
    public int get_NumRowBreaks();
    public Int32[] get_ColumnBreaks();
    public int get_NumColumnBreaks();
    public VCenterRecord get_VCenter();
    public HCenterRecord get_HCenter();
    public void AddLateHeaderFooter(HeaderFooterRecord rec);
    public void AddLateRecords(RecordStream rs);
    public void PositionRecords(List`1<RecordBase> sheetRecords);
}
internal class NPOI.HSSF.Record.Aggregates.PLSAggregate : RecordAggregate {
    private static ContinueRecord[] EMPTY_CONTINUE_RECORD_ARRAY;
    private Record _pls;
    private ContinueRecord[] _plsContinues;
    public PLSAggregate(RecordStream rs);
    private static PLSAggregate();
    public virtual void VisitContainedRecords(RecordVisitor rv);
}
public class NPOI.HSSF.Record.Aggregates.PositionTrackingVisitor : object {
    private RecordVisitor _rv;
    private int _position;
    public int Position { get; public set; }
    public PositionTrackingVisitor(RecordVisitor rv, int initialPosition);
    public sealed virtual void VisitRecord(Record r);
    public int get_Position();
    public void set_Position(int value);
}
public abstract class NPOI.HSSF.Record.Aggregates.RecordAggregate : RecordBase {
    public short Sid { get; }
    public int RecordSize { get; }
    public virtual short get_Sid();
    public abstract virtual void VisitContainedRecords(RecordVisitor rv);
    public virtual int Serialize(int offset, Byte[] data);
    public virtual int get_RecordSize();
    public virtual Record CloneViaReserialise();
}
public interface NPOI.HSSF.Record.Aggregates.RecordVisitor {
    public abstract virtual void VisitRecord(Record r);
}
public class NPOI.HSSF.Record.Aggregates.RowRecordsAggregate : RecordAggregate {
    private int firstrow;
    private int lastrow;
    private SortedList _rowRecords;
    private ValueRecordsAggregate _valuesAgg;
    private List`1<HyperlinkRecord> _hyperlinkRecordRecords;
    private List`1<Record> _unknownRecords;
    private SharedValueManager _sharedValueManager;
    private RowRecord[] _rowRecordValues;
    public IEnumerable`1<HyperlinkRecord> HyperlinkRecordRecords { get; }
    public int PhysicalNumberOfRows { get; }
    public int FirstRowNum { get; }
    public int LastRowNum { get; }
    public int RowBlockCount { get; }
    private RowRecordsAggregate(SharedValueManager svm);
    public RowRecordsAggregate(RecordStream rs, SharedValueManager svm);
    public IEnumerable`1<HyperlinkRecord> get_HyperlinkRecordRecords();
    private int VisitRowRecordsForBlock(int blockIndex, RecordVisitor rv);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    private void AddUnknownRecord(Record rec);
    public void InsertRow(RowRecord row);
    public void RemoveRow(RowRecord row);
    public void InsertCell(CellValueRecordInterface cvRec);
    public void RemoveCell(CellValueRecordInterface cvRec);
    public RowRecord GetRow(int rowIndex);
    public FormulaRecordAggregate CreateFormula(int row, int col);
    public int get_PhysicalNumberOfRows();
    public int get_FirstRowNum();
    public int get_LastRowNum();
    public int get_RowBlockCount();
    public int GetRowBlockSize(int block);
    public int GetRowCountForBlock(int block);
    public int GetStartRowNumberForBlock(int block);
    public int GetEndRowNumberForBlock(int block);
    public IEnumerator GetEnumerator();
    public int FindStartOfRowOutlineGroup(int row);
    public int FindEndOfRowOutlineGroup(int row);
    public int WriteHidden(RowRecord rowRecord, int row, bool hidden);
    public void CollapseRow(int rowNumber);
    public DimensionsRecord CreateDimensions();
    public static RowRecord CreateRow(int rowNumber);
    public IEnumerator`1<CellValueRecordInterface> GetCellValueEnumerator();
    public IndexRecord CreateIndexRecord(int indexRecordOffset, int sizeOfInitialSheetRecords, int offsetDefaultColWidth);
    public bool IsRowGroupCollapsed(int row);
    public void ExpandRow(int rowNumber);
    public void UpdateFormulasAfterRowShift(FormulaShifter formulaShifter, int currentExternSheetIndex);
    public bool IsRowGroupHiddenByParent(int row);
}
public class NPOI.HSSF.Record.Aggregates.SharedValueManager : object {
    public static SharedValueManager EMPTY;
    private List`1<ArrayRecord> _arrayRecords;
    private List`1<TableRecord> _tableRecords;
    private Dictionary`2<SharedFormulaRecord, SharedFormulaGroup> _groupsBySharedFormulaRecord;
    private Dictionary`2<int, SharedFormulaGroup> _groupsCache;
    private SharedFormulaGroupComparator SVGComparator;
    private SharedValueManager(SharedFormulaRecord[] sharedFormulaRecords, CellReference[] firstCells, List`1<ArrayRecord> arrayRecords, List`1<TableRecord> tableRecords);
    private static SharedValueManager();
    public static SharedValueManager CreateEmpty();
    public static SharedValueManager Create(SharedFormulaRecord[] sharedFormulaRecords, CellReference[] firstCells, List`1<ArrayRecord> arrayRecords, List`1<TableRecord> tableRecords);
    public SharedFormulaRecord LinkSharedFormulaRecord(CellReference firstCell, FormulaRecordAggregate agg);
    private SharedFormulaGroup FindFormulaGroupForCell(CellReference cellRef);
    private int GetKeyForCache(CellReference cellRef);
    public SharedValueRecordBase GetRecordForFirstCell(FormulaRecordAggregate agg);
    public void Unlink(SharedFormulaRecord sharedFormulaRecord);
    public void AddArrayRecord(ArrayRecord ar);
    public CellRangeAddress8Bit RemoveArrayFormula(int rowIndex, int columnIndex);
    public ArrayRecord GetArrayRecord(int firstRow, int firstColumn);
}
public class NPOI.HSSF.Record.Aggregates.ValueRecordsAggregate : object {
    private static int MAX_ROW_INDEX;
    private static int INDEX_NOT_SET;
    public static short sid;
    private int firstcell;
    private int lastcell;
    private CellValueRecordInterface[][] records;
    public int PhysicalNumberOfCells { get; }
    public int FirstCellNum { get; }
    public int LastCellNum { get; }
    private ValueRecordsAggregate(int firstCellIx, int lastCellIx, CellValueRecordInterface[][] pRecords);
    public void InsertCell(CellValueRecordInterface cell);
    public void RemoveCell(CellValueRecordInterface cell);
    public void RemoveAllCellsValuesForRow(int rowIndex);
    public int get_PhysicalNumberOfCells();
    public int get_FirstCellNum();
    public int get_LastCellNum();
    public void AddMultipleBlanks(MulBlankRecord mbr);
    private MulBlankRecord CreateMBR(CellValueRecordInterface[] cellValues, int startIx, int nBlank);
    public void Construct(CellValueRecordInterface rec, RecordStream rs, SharedValueManager sfh);
    private static void HandleMissingSharedFormulaRecord(FormulaRecord formula);
    public int GetRowCellBlockSize(int startRow, int endRow);
    public bool RowHasCells(int row);
    public void UpdateFormulasAfterRowShift(FormulaShifter shifter, int currentExternSheetIndex);
    public void VisitCellsForRow(int rowIndex, RecordVisitor rv);
    private static int CountBlanks(CellValueRecordInterface[] rowCellValues, int startIx);
    public int SerializeCellRow(int row, int offset, Byte[] data);
    public sealed virtual IEnumerator`1<CellValueRecordInterface> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NPOI.HSSF.Record.Aggregates.WorksheetProtectionBlock : RecordAggregate {
    private ProtectRecord _protectRecord;
    private ObjectProtectRecord _objectProtectRecord;
    private ScenarioProtectRecord _scenarioProtectRecord;
    private PasswordRecord _passwordRecord;
    private ProtectRecord Protect { get; }
    public PasswordRecord Password { get; }
    public bool IsSheetProtected { get; }
    public bool IsObjectProtected { get; }
    public bool IsScenarioProtected { get; }
    public int PasswordHash { get; }
    public static bool IsComponentRecord(int sid);
    private bool ReadARecord(RecordStream rs);
    private void CheckNotPresent(Record rec);
    public virtual void VisitContainedRecords(RecordVisitor rv);
    private static void VisitIfPresent(Record r, RecordVisitor rv);
    public PasswordRecord GetPasswordRecord();
    public ScenarioProtectRecord GetHCenter();
    public void AddRecords(RecordStream rs);
    private ProtectRecord get_Protect();
    public PasswordRecord get_Password();
    public void ProtectSheet(string password, bool shouldProtectObjects, bool shouldProtectScenarios);
    public bool get_IsSheetProtected();
    public bool get_IsObjectProtected();
    public bool get_IsScenarioProtected();
    private static ObjectProtectRecord CreateObjectProtect();
    private static ScenarioProtectRecord CreateScenarioProtect();
    private static PasswordRecord CreatePassword();
    public int get_PasswordHash();
}
public class NPOI.HSSF.Record.ArrayRecord : SharedValueRecordBase {
    public static short sid;
    private static int OPT_ALWAYS_RECALCULATE;
    private static int OPT_CALCULATE_ON_OPEN;
    private int _options;
    private int _field3notUsed;
    private Formula _formula;
    public bool IsAlwaysRecalculate { get; }
    public bool IsCalculateOnOpen { get; }
    public Ptg[] FormulaTokens { get; }
    protected int ExtraDataSize { get; }
    public short Sid { get; }
    public ArrayRecord(RecordInputStream in1);
    public ArrayRecord(Formula formula, CellRangeAddress8Bit range);
    public bool get_IsAlwaysRecalculate();
    public bool get_IsCalculateOnOpen();
    public Ptg[] get_FormulaTokens();
    protected virtual int get_ExtraDataSize();
    protected virtual void SerializeExtraData(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.AutoFilter.AutoFilterInfoRecord : StandardRecord {
    private short field_1_cEntries;
    public static short sid;
    public short Sid { get; }
    protected int DataSize { get; }
    public short NumEntries { get; public set; }
    public AutoFilterInfoRecord(RecordInputStream in1);
    public virtual short get_Sid();
    protected virtual int get_DataSize();
    public short get_NumEntries();
    public void set_NumEntries(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.AutoFilter.AutoFilterRecord : StandardRecord {
    public static short sid;
    private short field_1_iEntry;
    private short field_2_grbit;
    private static BitField wJoinFlag;
    private static BitField fSimple1Flag;
    private static BitField fSimple2Flag;
    private static BitField fTop10Flag;
    private static BitField fTopFlag;
    private static BitField fPercentFlag;
    private static BitField wTop10Flag;
    private DOPERRecord field_3_doper1;
    private DOPERRecord field_4_doper2;
    private string field_5_rgch1;
    private string field_6_rgch2;
    private bool rgch1_multibyte;
    private bool rgch2_multibyte;
    public short Sid { get; }
    public short iEntry { get; public set; }
    public short wJoin { get; public set; }
    public bool IsFirstConditionSimple { get; public set; }
    public bool IsSecondConditionSimple { get; public set; }
    public DOPERRecord Doper1 { get; }
    public DOPERRecord Doper2 { get; }
    public string Doper1RGCH { get; public set; }
    public string Doper2RGCH { get; public set; }
    protected int DataSize { get; }
    public AutoFilterRecord(RecordInputStream in1);
    private static AutoFilterRecord();
    public virtual short get_Sid();
    public short get_iEntry();
    public void set_iEntry(short value);
    public short get_wJoin();
    public void set_wJoin(short value);
    public bool get_IsFirstConditionSimple();
    public void set_IsFirstConditionSimple(bool value);
    public bool get_IsSecondConditionSimple();
    public void set_IsSecondConditionSimple(bool value);
    public DOPERRecord get_Doper1();
    public DOPERRecord get_Doper2();
    public string get_Doper1RGCH();
    public void set_Doper1RGCH(string value);
    public string get_Doper2RGCH();
    public void set_Doper2RGCH(string value);
    protected virtual int get_DataSize();
    public virtual int Serialize(int offset, Byte[] data);
    public virtual object Clone();
    public virtual void Serialize(ILittleEndianOutput out1);
}
public enum NPOI.HSSF.Record.AutoFilter.DOPERComparisonCode : Enum {
    public byte value__;
    public static DOPERComparisonCode Unknown;
    public static DOPERComparisonCode Less;
    public static DOPERComparisonCode Equal;
    public static DOPERComparisonCode LessThan;
    public static DOPERComparisonCode More;
    public static DOPERComparisonCode NotEqual;
    public static DOPERComparisonCode GreaterThan;
}
public enum NPOI.HSSF.Record.AutoFilter.DOPERErrorValue : Enum {
    public byte value__;
    public static DOPERErrorValue NULL;
    public static DOPERErrorValue DIV0;
    public static DOPERErrorValue VALUE;
    public static DOPERErrorValue REF;
    public static DOPERErrorValue NAME;
    public static DOPERErrorValue NUM;
    public static DOPERErrorValue NA;
}
public class NPOI.HSSF.Record.AutoFilter.DOPERRecord : RecordBase {
    private DOPERType vt;
    private byte grbitSgn;
    private RKRecord _RK;
    private double _IEEENumber;
    private byte CCH;
    private byte fError;
    private byte bBoolErr;
    public int RecordSize { get; }
    public DOPERType DataType { get; public set; }
    public DOPERComparisonCode ComparisonCode { get; public set; }
    public double IEEENumber { get; public set; }
    public RKRecord RK { get; public set; }
    public byte LengthOfString { get; public set; }
    public bool IsBooleanValue { get; }
    public bool IsErrorValue { get; }
    public bool BooleanValue { get; public set; }
    public DOPERErrorValue ErrorValue { get; public set; }
    public DOPERRecord(RecordInputStream in1);
    public virtual int get_RecordSize();
    public int Serialize(ILittleEndianOutput out1);
    public virtual Record CloneViaReserialise();
    public virtual int Serialize(int offset, Byte[] data);
    public DOPERType get_DataType();
    public void set_DataType(DOPERType value);
    public DOPERComparisonCode get_ComparisonCode();
    public void set_ComparisonCode(DOPERComparisonCode value);
    public double get_IEEENumber();
    public void set_IEEENumber(double value);
    public RKRecord get_RK();
    public void set_RK(RKRecord value);
    public byte get_LengthOfString();
    public void set_LengthOfString(byte value);
    public bool get_IsBooleanValue();
    public bool get_IsErrorValue();
    public bool get_BooleanValue();
    public void set_BooleanValue(bool value);
    public DOPERErrorValue get_ErrorValue();
    public void set_ErrorValue(DOPERErrorValue value);
}
public enum NPOI.HSSF.Record.AutoFilter.DOPERType : Enum {
    public byte value__;
    public static DOPERType FilterCondition;
    public static DOPERType RKNumber;
    public static DOPERType IEEENumber;
    public static DOPERType String;
    public static DOPERType BooleanOrErrors;
    public static DOPERType MatchAllBlanks;
    public static DOPERType MatchNoneBlank;
}
public class NPOI.HSSF.Record.AutoFilter.FilterModeRecord : StandardRecord {
    public static short sid;
    public short Sid { get; }
    protected int DataSize { get; }
    public FilterModeRecord(RecordInputStream in1);
    public virtual short get_Sid();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.BackupRecord : StandardRecord {
    public static short sid;
    private short field_1_backup;
    public short Backup { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public BackupRecord(RecordInputStream in1);
    public short get_Backup();
    public void set_Backup(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public interface NPOI.HSSF.Record.BiffHeaderInput {
    public abstract virtual int ReadRecordSID();
    public abstract virtual int ReadDataSize();
    public abstract virtual int Available();
}
public class NPOI.HSSF.Record.BlankRecord : StandardRecord {
    public static short sid;
    private int field_1_row;
    private int field_2_col;
    private short field_3_xf;
    public int Row { get; public set; }
    public int Column { get; public set; }
    public short XFIndex { get; public set; }
    public short Sid { get; }
    protected int DataSize { get; }
    public BlankRecord(RecordInputStream in1);
    public sealed virtual int get_Row();
    public sealed virtual void set_Row(int value);
    public sealed virtual int get_Column();
    public sealed virtual void set_Column(int value);
    public sealed virtual void set_XFIndex(short value);
    public sealed virtual short get_XFIndex();
    public virtual short get_Sid();
    public virtual string ToString();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public sealed virtual int CompareTo(object obj);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.BOFRecord : StandardRecord {
    public static short sid;
    public static short biff2_sid;
    public static short biff3_sid;
    public static short biff4_sid;
    public static short biff5_sid;
    private int field_1_version;
    private int field_2_type;
    private int field_3_build;
    private int field_4_year;
    private int field_5_history;
    private int field_6_rversion;
    public static short VERSION;
    public static short BUILD;
    public static short BUILD_YEAR;
    public static short HISTORY_MASK;
    public int Version { get; public set; }
    public int HistoryBitMask { get; public set; }
    public int RequiredVersion { get; public set; }
    public BOFRecordType Type { get; public set; }
    private string TypeName { get; }
    public int Build { get; public set; }
    public int BuildYear { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    private BOFRecord(BOFRecordType type);
    public BOFRecord(RecordInputStream in1);
    public static BOFRecord CreateSheetBOF();
    public void set_Version(int value);
    public int get_Version();
    public void set_HistoryBitMask(int value);
    public int get_HistoryBitMask();
    public void set_RequiredVersion(int value);
    public int get_RequiredVersion();
    public BOFRecordType get_Type();
    public void set_Type(BOFRecordType value);
    private string get_TypeName();
    public int get_Build();
    public void set_Build(int value);
    public int get_BuildYear();
    public void set_BuildYear(int value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public enum NPOI.HSSF.Record.BOFRecordType : Enum {
    public int value__;
    public static BOFRecordType Workbook;
    public static BOFRecordType VBModule;
    public static BOFRecordType Worksheet;
    public static BOFRecordType Chart;
    public static BOFRecordType Excel4Macro;
    public static BOFRecordType WorkspaceFile;
}
public class NPOI.HSSF.Record.BookBoolRecord : StandardRecord {
    public static short sid;
    private short field_1_save_link_values;
    public short SaveLinkValues { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public BookBoolRecord(RecordInputStream in1);
    public short get_SaveLinkValues();
    public void set_SaveLinkValues(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.BoolErrRecord : CellRecord {
    public static short sid;
    private int _value;
    private bool _isError;
    public bool BooleanValue { get; }
    public byte ErrorValue { get; }
    public bool IsBoolean { get; }
    public bool IsError { get; }
    protected string RecordName { get; }
    protected int ValueDataSize { get; }
    public short Sid { get; }
    public BoolErrRecord(RecordInputStream in1);
    public void SetValue(bool value);
    public void SetValue(byte value);
    public void SetValue(FormulaError value);
    public bool get_BooleanValue();
    public byte get_ErrorValue();
    public bool get_IsBoolean();
    public bool get_IsError();
    protected virtual string get_RecordName();
    protected virtual void AppendValueText(StringBuilder buffer);
    protected virtual void SerializeValue(ILittleEndianOutput out1);
    protected virtual int get_ValueDataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.BottomMarginRecord : StandardRecord {
    public static short sid;
    private double field_1_margin;
    protected int DataSize { get; }
    public short Sid { get; }
    public double Margin { get; public set; }
    public BottomMarginRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public sealed virtual double get_Margin();
    public sealed virtual void set_Margin(double value);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.BoundSheetRecord : StandardRecord {
    public static short sid;
    private static BitField hiddenFlag;
    private static BitField veryHiddenFlag;
    private int field_1_position_of_BOF;
    private int field_2_option_flags;
    private int field_4_isMultibyteUnicode;
    private string field_5_sheetname;
    public int PositionOfBof { get; public set; }
    public bool IsVeryHidden { get; public set; }
    public string Sheetname { get; public set; }
    private bool IsMultibyte { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public bool IsHidden { get; public set; }
    public BoundSheetRecord(string sheetname);
    public BoundSheetRecord(RecordInputStream in1);
    private static BoundSheetRecord();
    public int get_PositionOfBof();
    public void set_PositionOfBof(int value);
    public bool get_IsVeryHidden();
    public void set_IsVeryHidden(bool value);
    public string get_Sheetname();
    public void set_Sheetname(string value);
    private bool get_IsMultibyte();
    public virtual string ToString();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public bool get_IsHidden();
    public void set_IsHidden(bool value);
    public static BoundSheetRecord[] OrderByBofPosition(List`1<BoundSheetRecord> boundSheetRecords);
}
public class NPOI.HSSF.Record.CalcCountRecord : StandardRecord {
    public static short sid;
    private short field_1_iterations;
    public short Iterations { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public CalcCountRecord(RecordInputStream in1);
    public short get_Iterations();
    public void set_Iterations(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.CalcModeRecord : StandardRecord {
    public static short sid;
    public static short MANUAL;
    public static short AUTOMATIC;
    public static short AUTOMATIC_EXCEPT_TABLES;
    private short field_1_calcmode;
    protected int DataSize { get; }
    public short Sid { get; }
    public CalcModeRecord(RecordInputStream in1);
    public void SetCalcMode(short calcmode);
    public short GetCalcMode();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public abstract class NPOI.HSSF.Record.CellRecord : StandardRecord {
    private int _rowIndex;
    private int _columnIndex;
    private int _formatIndex;
    public int Row { get; public set; }
    public int Column { get; public set; }
    public short XFIndex { get; public set; }
    protected string RecordName { get; }
    protected int ValueDataSize { get; }
    protected int DataSize { get; }
    protected CellRecord(RecordInputStream in1);
    public sealed virtual int get_Row();
    public sealed virtual void set_Row(int value);
    public sealed virtual int get_Column();
    public sealed virtual void set_Column(int value);
    public sealed virtual short get_XFIndex();
    public sealed virtual void set_XFIndex(short value);
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
    protected abstract virtual void AppendValueText(StringBuilder sb);
    protected abstract virtual string get_RecordName();
    protected abstract virtual void SerializeValue(ILittleEndianOutput out1);
    protected abstract virtual int get_ValueDataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    protected void CopyBaseFields(CellRecord rec);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface NPOI.HSSF.Record.CellValueRecordInterface {
    public int Row { get; public set; }
    public int Column { get; public set; }
    public short XFIndex { get; public set; }
    public abstract virtual int get_Row();
    public abstract virtual void set_Row(int value);
    public abstract virtual int get_Column();
    public abstract virtual void set_Column(int value);
    public abstract virtual short get_XFIndex();
    public abstract virtual void set_XFIndex(short value);
}
public class NPOI.HSSF.Record.CF.BorderFormatting : object {
    private int field_13_border_styles1;
    private static BitField bordLeftLineStyle;
    private static BitField bordRightLineStyle;
    private static BitField bordTopLineStyle;
    private static BitField bordBottomLineStyle;
    private static BitField bordLeftLineColor;
    private static BitField bordRightLineColor;
    private static BitField bordTlBrLineOnOff;
    private static BitField bordBlTrtLineOnOff;
    private int field_14_border_styles2;
    private static BitField bordTopLineColor;
    private static BitField bordBottomLineColor;
    private static BitField bordDiagLineColor;
    private static BitField bordDiagLineStyle;
    public int DataLength { get; }
    public BorderStyle BorderLeft { get; public set; }
    public BorderStyle BorderRight { get; public set; }
    public BorderStyle BorderTop { get; public set; }
    public BorderStyle BorderBottom { get; public set; }
    public BorderStyle BorderDiagonal { get; public set; }
    public short LeftBorderColor { get; public set; }
    public short RightBorderColor { get; public set; }
    public short TopBorderColor { get; public set; }
    public short BottomBorderColor { get; public set; }
    public short DiagonalBorderColor { get; public set; }
    public bool IsForwardDiagonalOn { get; public set; }
    public bool IsBackwardDiagonalOn { get; public set; }
    public BorderFormatting(RecordInputStream in1);
    private static BorderFormatting();
    public int get_DataLength();
    public BorderStyle get_BorderLeft();
    public void set_BorderLeft(BorderStyle value);
    public BorderStyle get_BorderRight();
    public void set_BorderRight(BorderStyle value);
    public BorderStyle get_BorderTop();
    public void set_BorderTop(BorderStyle value);
    public BorderStyle get_BorderBottom();
    public void set_BorderBottom(BorderStyle value);
    public BorderStyle get_BorderDiagonal();
    public void set_BorderDiagonal(BorderStyle value);
    public short get_LeftBorderColor();
    public void set_LeftBorderColor(short value);
    public short get_RightBorderColor();
    public void set_RightBorderColor(short value);
    public short get_TopBorderColor();
    public void set_TopBorderColor(short value);
    public short get_BottomBorderColor();
    public void set_BottomBorderColor(short value);
    public short get_DiagonalBorderColor();
    public void set_DiagonalBorderColor(short value);
    public bool get_IsForwardDiagonalOn();
    public void set_IsForwardDiagonalOn(bool value);
    public bool get_IsBackwardDiagonalOn();
    public void set_IsBackwardDiagonalOn(bool value);
    public virtual string ToString();
    public sealed virtual object Clone();
    public int Serialize(int offset, Byte[] data);
    public void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.CF.ColorGradientFormatting : object {
    private byte options;
    private ColorGradientThreshold[] thresholds;
    private ExtendedColor[] colors;
    private static BitField clamp;
    private static BitField background;
    public int NumControlPoints { get; public set; }
    public ColorGradientThreshold[] Thresholds { get; public set; }
    public ExtendedColor[] Colors { get; public set; }
    public bool IsClampToCurve { get; }
    public bool IsAppliesToBackground { get; }
    public int DataLength { get; }
    public ColorGradientFormatting(ILittleEndianInput in1);
    private static ColorGradientFormatting();
    public int get_NumControlPoints();
    public void set_NumControlPoints(int value);
    public ColorGradientThreshold[] get_Thresholds();
    public void set_Thresholds(ColorGradientThreshold[] value);
    public ExtendedColor[] get_Colors();
    public void set_Colors(ExtendedColor[] value);
    public bool get_IsClampToCurve();
    public bool get_IsAppliesToBackground();
    private bool GetOptionFlag(BitField field);
    private void updateThresholdPositions();
    public virtual string ToString();
    public sealed virtual object Clone();
    public int get_DataLength();
    public void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.CF.ColorGradientThreshold : Threshold {
    private double position;
    public double Position { get; public set; }
    public int DataLength { get; }
    public ColorGradientThreshold(ILittleEndianInput in1);
    public double get_Position();
    public void set_Position(double value);
    public virtual int get_DataLength();
    public sealed virtual object Clone();
    public virtual void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.CF.DataBarFormatting : object {
    private byte options;
    private byte percentMin;
    private byte percentMax;
    private ExtendedColor color;
    private DataBarThreshold thresholdMin;
    private DataBarThreshold thresholdMax;
    private static BitField iconOnly;
    private static BitField reversed;
    public bool IsIconOnly { get; public set; }
    public bool IsReversed { get; public set; }
    public byte PercentMin { get; public set; }
    public byte PercentMax { get; public set; }
    public ExtendedColor Color { get; public set; }
    public DataBarThreshold ThresholdMin { get; public set; }
    public DataBarThreshold ThresholdMax { get; public set; }
    public int DataLength { get; }
    public DataBarFormatting(ILittleEndianInput in1);
    private static DataBarFormatting();
    public bool get_IsIconOnly();
    public void set_IsIconOnly(bool value);
    public bool get_IsReversed();
    public void set_IsReversed(bool value);
    private bool GetOptionFlag(BitField field);
    private void SetOptionFlag(bool option, BitField field);
    public byte get_PercentMin();
    public void set_PercentMin(byte value);
    public byte get_PercentMax();
    public void set_PercentMax(byte value);
    public ExtendedColor get_Color();
    public void set_Color(ExtendedColor value);
    public DataBarThreshold get_ThresholdMin();
    public void set_ThresholdMin(DataBarThreshold value);
    public DataBarThreshold get_ThresholdMax();
    public void set_ThresholdMax(DataBarThreshold value);
    public virtual string ToString();
    public sealed virtual object Clone();
    public int get_DataLength();
    public void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.CF.DataBarThreshold : Threshold {
    public DataBarThreshold(ILittleEndianInput in1);
    public sealed virtual object Clone();
}
public class NPOI.HSSF.Record.CF.FontFormatting : object {
    private Byte[] _rawData;
    private static int OFFSET_FONT_NAME;
    private static int OFFSET_FONT_HEIGHT;
    private static int OFFSET_FONT_OPTIONS;
    private static int OFFSET_FONT_WEIGHT;
    private static int OFFSET_ESCAPEMENT_TYPE;
    private static int OFFSET_UNDERLINE_TYPE;
    private static int OFFSET_FONT_COLOR_INDEX;
    private static int OFFSET_OPTION_FLAGS;
    private static int OFFSET_ESCAPEMENT_TYPE_MODIFIED;
    private static int OFFSET_UNDERLINE_TYPE_MODIFIED;
    private static int OFFSET_FONT_WEIGHT_MODIFIED;
    private static int OFFSET_NOT_USED1;
    private static int OFFSET_NOT_USED2;
    private static int OFFSET_NOT_USED3;
    private static int OFFSET_FONT_FORMATING_END;
    private static int RAW_DATA_SIZE;
    public static int FONT_CELL_HEIGHT_PRESERVED;
    private static BitField posture;
    private static BitField outline;
    private static BitField shadow;
    private static BitField cancellation;
    private static BitField styleModified;
    private static BitField outlineModified;
    private static BitField shadowModified;
    private static BitField cancellationModified;
    private static short FONT_WEIGHT_NORMAL;
    private static short FONT_WEIGHT_BOLD;
    public Byte[] RawRecord { get; }
    public int DataLength { get; }
    public int FontHeight { get; public set; }
    public bool IsItalic { get; public set; }
    public bool IsOutlineOn { get; public set; }
    public bool IsShadowOn { get; public set; }
    public bool IsStruckout { get; public set; }
    public short FontWeight { get; public set; }
    public bool IsBold { get; public set; }
    public FontSuperScript EscapementType { get; public set; }
    public FontUnderlineType UnderlineType { get; public set; }
    public short FontColorIndex { get; public set; }
    public bool IsFontStyleModified { get; public set; }
    public bool IsFontOutlineModified { get; public set; }
    public bool IsFontShadowModified { get; public set; }
    public bool IsFontCancellationModified { get; public set; }
    public bool IsEscapementTypeModified { get; public set; }
    public bool IsUnderlineTypeModified { get; public set; }
    public bool IsFontWeightModified { get; public set; }
    public FontFormatting(RecordInputStream in1);
    private static FontFormatting();
    private short GetShort(int offset);
    private void SetShort(int offset, int value);
    private int GetInt(int offset);
    private void SetInt(int offset, int value);
    public Byte[] get_RawRecord();
    public int get_DataLength();
    public int get_FontHeight();
    public void set_FontHeight(int value);
    private void SetFontOption(bool option, BitField field);
    private bool GetFontOption(BitField field);
    public bool get_IsItalic();
    public void set_IsItalic(bool value);
    public bool get_IsOutlineOn();
    public void set_IsOutlineOn(bool value);
    public bool get_IsShadowOn();
    public void set_IsShadowOn(bool value);
    public bool get_IsStruckout();
    public void set_IsStruckout(bool value);
    public short get_FontWeight();
    public void set_FontWeight(short value);
    public bool get_IsBold();
    public void set_IsBold(bool value);
    public FontSuperScript get_EscapementType();
    public void set_EscapementType(FontSuperScript value);
    public FontUnderlineType get_UnderlineType();
    public void set_UnderlineType(FontUnderlineType value);
    public short get_FontColorIndex();
    public void set_FontColorIndex(short value);
    private bool GetOptionFlag(BitField field);
    private void SetOptionFlag(bool modified, BitField field);
    public bool get_IsFontStyleModified();
    public void set_IsFontStyleModified(bool value);
    public bool get_IsFontOutlineModified();
    public void set_IsFontOutlineModified(bool value);
    public bool get_IsFontShadowModified();
    public void set_IsFontShadowModified(bool value);
    public bool get_IsFontCancellationModified();
    public void set_IsFontCancellationModified(bool value);
    public bool get_IsEscapementTypeModified();
    public void set_IsEscapementTypeModified(bool value);
    public bool get_IsUnderlineTypeModified();
    public void set_IsUnderlineTypeModified(bool value);
    public bool get_IsFontWeightModified();
    public void set_IsFontWeightModified(bool value);
    public virtual string ToString();
    public sealed virtual object Clone();
}
public class NPOI.HSSF.Record.CF.IconMultiStateFormatting : object {
    private IconSet iconSet;
    private byte options;
    private Threshold[] thresholds;
    private static BitField iconOnly;
    private static BitField reversed;
    public IconSet IconSet { get; public set; }
    public Threshold[] Thresholds { get; public set; }
    public bool IsIconOnly { get; public set; }
    public bool IsReversed { get; public set; }
    public int DataLength { get; }
    public IconMultiStateFormatting(ILittleEndianInput in1);
    private static IconMultiStateFormatting();
    public IconSet get_IconSet();
    public void set_IconSet(IconSet value);
    public Threshold[] get_Thresholds();
    public void set_Thresholds(Threshold[] value);
    public bool get_IsIconOnly();
    public void set_IsIconOnly(bool value);
    public bool get_IsReversed();
    public void set_IsReversed(bool value);
    private bool GetOptionFlag(BitField field);
    private void SetOptionFlag(bool option, BitField field);
    public virtual string ToString();
    public sealed virtual object Clone();
    public int get_DataLength();
    public void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.CF.IconMultiStateThreshold : Threshold {
    public static byte EQUALS_EXCLUDE;
    public static byte EQUALS_INCLUDE;
    private byte equals;
    public int DataLength { get; }
    public IconMultiStateThreshold(ILittleEndianInput in1);
    private static IconMultiStateThreshold();
    public byte GetEquals();
    public void SetEquals(byte Equals);
    public virtual int get_DataLength();
    public sealed virtual object Clone();
    public virtual void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.CF.PatternFormatting : object {
    private short field_15_pattern_style;
    private static BitField FillPatternStyle;
    private short field_16_pattern_color_indexes;
    private static BitField patternColorIndex;
    private static BitField patternBackgroundColorIndex;
    public int DataLength { get; }
    public FillPattern FillPattern { get; public set; }
    public short FillBackgroundColor { get; public set; }
    public short FillForegroundColor { get; public set; }
    public PatternFormatting(RecordInputStream in1);
    private static PatternFormatting();
    public int get_DataLength();
    public FillPattern get_FillPattern();
    public void set_FillPattern(FillPattern value);
    public short get_FillBackgroundColor();
    public void set_FillBackgroundColor(short value);
    public short get_FillForegroundColor();
    public void set_FillForegroundColor(short value);
    public virtual string ToString();
    public sealed virtual object Clone();
    public int Serialize(int offset, Byte[] data);
    public void Serialize(ILittleEndianOutput out1);
}
public abstract class NPOI.HSSF.Record.CF.Threshold : object {
    private byte type;
    private Formula formula;
    private Nullable`1<double> value;
    public byte Type { get; public set; }
    protected Formula Formula { get; }
    public Ptg[] ParsedExpression { get; public set; }
    public Nullable`1<double> Value { get; public set; }
    public int DataLength { get; }
    protected Threshold(ILittleEndianInput in1);
    public byte get_Type();
    public void set_Type(byte value);
    public void SetType(int type);
    protected Formula get_Formula();
    public Ptg[] get_ParsedExpression();
    public void set_ParsedExpression(Ptg[] value);
    public Nullable`1<double> get_Value();
    public void set_Value(Nullable`1<double> value);
    public virtual int get_DataLength();
    public virtual string ToString();
    public void CopyTo(Threshold rec);
    public virtual void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.CFHeader12Record : CFHeaderBase {
    public static short sid;
    private FtrHeader futureHeader;
    protected string RecordName { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public CFHeader12Record(CellRangeAddress[] regions, int nRules);
    public CFHeader12Record(RecordInputStream in1);
    private static CFHeader12Record();
    protected virtual string get_RecordName();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public sealed virtual short GetFutureRecordType();
    public sealed virtual FtrHeader GetFutureHeader();
    public sealed virtual CellRangeAddress GetAssociatedRange();
    public virtual object Clone();
}
public abstract class NPOI.HSSF.Record.CFHeaderBase : StandardRecord {
    private int field_1_numcf;
    private int field_2_need_recalculation_and_id;
    private CellRangeAddress field_3_enclosing_cell_range;
    private CellRangeAddressList field_4_cell_ranges;
    public int NumberOfConditionalFormats { get; public set; }
    public bool NeedRecalculation { get; public set; }
    public int ID { get; public set; }
    public CellRangeAddress EnclosingCellRange { get; public set; }
    public CellRangeAddress[] CellRanges { get; public set; }
    protected string RecordName { get; }
    protected int DataSize { get; }
    protected CFHeaderBase(CellRangeAddress[] regions, int nRules);
    protected void CreateEmpty();
    protected void Read(RecordInputStream in1);
    public int get_NumberOfConditionalFormats();
    public void set_NumberOfConditionalFormats(int value);
    public bool get_NeedRecalculation();
    public void set_NeedRecalculation(bool value);
    public int get_ID();
    public void set_ID(int value);
    public CellRangeAddress get_EnclosingCellRange();
    public void set_EnclosingCellRange(CellRangeAddress value);
    public CellRangeAddress[] get_CellRanges();
    public void set_CellRanges(CellRangeAddress[] value);
    protected abstract virtual string get_RecordName();
    public virtual string ToString();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected void CopyTo(CFHeaderBase result);
}
public class NPOI.HSSF.Record.CFHeaderRecord : CFHeaderBase {
    public static short sid;
    protected string RecordName { get; }
    public short Sid { get; }
    public CFHeaderRecord(CellRangeAddress[] regions, int nRules);
    public CFHeaderRecord(RecordInputStream in1);
    private static CFHeaderRecord();
    protected virtual string get_RecordName();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.CFRule12Record : CFRuleBase {
    public static short sid;
    private FtrHeader futureHeader;
    private int ext_formatting_length;
    private Byte[] ext_formatting_data;
    private Formula formula_scale;
    private byte ext_opts;
    private int priority;
    private int template_type;
    private byte template_param_length;
    private Byte[] template_params;
    private DataBarFormatting data_bar;
    private IconMultiStateFormatting multistate;
    private ColorGradientFormatting color_gradient;
    private Byte[] filter_data;
    public DataBarFormatting DataBarFormatting { get; }
    public IconMultiStateFormatting MultiStateFormatting { get; }
    public ColorGradientFormatting ColorGradientFormatting { get; }
    public Ptg[] ParsedExpressionScale { get; public set; }
    public short Sid { get; }
    protected int DataSize { get; }
    public int Priority { get; public set; }
    private CFRule12Record(byte conditionType, byte comparisonOperation);
    private CFRule12Record(byte conditionType, byte comparisonOperation, Ptg[] formula1, Ptg[] formula2, Ptg[] formulaScale);
    public CFRule12Record(RecordInputStream in1);
    private static CFRule12Record();
    private void SetDefaults();
    public static CFRule12Record Create(HSSFSheet sheet, string formulaText);
    public static CFRule12Record Create(HSSFSheet sheet, byte comparisonOperation, string formulaText1, string formulaText2);
    public static CFRule12Record Create(HSSFSheet sheet, byte comparisonOperation, string formulaText1, string formulaText2, string formulaTextScale);
    public static CFRule12Record Create(HSSFSheet sheet, ExtendedColor color);
    public static CFRule12Record Create(HSSFSheet sheet, IconSet iconSet);
    public static CFRule12Record CreateColorScale(HSSFSheet sheet);
    public bool ContainsDataBarBlock();
    public DataBarFormatting get_DataBarFormatting();
    public DataBarFormatting CreateDataBarFormatting();
    public bool ContainsMultiStateBlock();
    public IconMultiStateFormatting get_MultiStateFormatting();
    public IconMultiStateFormatting CreateMultiStateFormatting();
    public bool ContainsColorGradientBlock();
    public ColorGradientFormatting get_ColorGradientFormatting();
    public ColorGradientFormatting CreateColorGradientFormatting();
    public Ptg[] get_ParsedExpressionScale();
    public void set_ParsedExpressionScale(Ptg[] value);
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual string ToString();
    public virtual object Clone();
    public sealed virtual short GetFutureRecordType();
    public sealed virtual FtrHeader GetFutureHeader();
    public sealed virtual CellRangeAddress GetAssociatedRange();
    public int get_Priority();
    public void set_Priority(int value);
}
public abstract class NPOI.HSSF.Record.CFRuleBase : StandardRecord {
    private byte condition_type;
    public static byte CONDITION_TYPE_CELL_VALUE_IS;
    public static byte CONDITION_TYPE_FORMULA;
    public static byte CONDITION_TYPE_COLOR_SCALE;
    public static byte CONDITION_TYPE_DATA_BAR;
    public static byte CONDITION_TYPE_FILTER;
    public static byte CONDITION_TYPE_ICON_SET;
    private byte comparison_operator;
    public static int TEMPLATE_CELL_VALUE;
    public static int TEMPLATE_FORMULA;
    public static int TEMPLATE_COLOR_SCALE_FORMATTING;
    public static int TEMPLATE_DATA_BAR_FORMATTING;
    public static int TEMPLATE_ICON_SET_FORMATTING;
    public static int TEMPLATE_FILTER;
    public static int TEMPLATE_UNIQUE_VALUES;
    public static int TEMPLATE_CONTAINS_TEXT;
    public static int TEMPLATE_CONTAINS_BLANKS;
    public static int TEMPLATE_CONTAINS_NO_BLANKS;
    public static int TEMPLATE_CONTAINS_ERRORS;
    public static int TEMPLATE_CONTAINS_NO_ERRORS;
    public static int TEMPLATE_TODAY;
    public static int TEMPLATE_TOMORROW;
    public static int TEMPLATE_YESTERDAY;
    public static int TEMPLATE_LAST_7_DAYS;
    public static int TEMPLATE_LAST_MONTH;
    public static int TEMPLATE_NEXT_MONTH;
    public static int TEMPLATE_THIS_WEEK;
    public static int TEMPLATE_NEXT_WEEK;
    public static int TEMPLATE_LAST_WEEK;
    public static int TEMPLATE_THIS_MONTH;
    public static int TEMPLATE_ABOVE_AVERAGE;
    public static int TEMPLATE_BELOW_AVERAGE;
    public static int TEMPLATE_DUPLICATE_VALUES;
    public static int TEMPLATE_ABOVE_OR_EQUAL_TO_AVERAGE;
    public static int TEMPLATE_BELOW_OR_EQUAL_TO_AVERAGE;
    internal static BitField modificationBits;
    internal static BitField alignHor;
    internal static BitField alignVer;
    internal static BitField alignWrap;
    internal static BitField alignRot;
    internal static BitField alignJustLast;
    internal static BitField alignIndent;
    internal static BitField alignShrin;
    internal static BitField mergeCell;
    internal static BitField protLocked;
    internal static BitField protHidden;
    internal static BitField bordLeft;
    internal static BitField bordRight;
    internal static BitField bordTop;
    internal static BitField bordBot;
    internal static BitField bordTlBr;
    internal static BitField bordBlTr;
    internal static BitField pattStyle;
    internal static BitField pattCol;
    internal static BitField pattBgCol;
    internal static BitField notUsed2;
    internal static BitField undocumented;
    internal static BitField fmtBlockBits;
    internal static BitField font;
    internal static BitField align;
    internal static BitField bord;
    internal static BitField patt;
    internal static BitField prot;
    internal static BitField alignTextDir;
    protected int formatting_options;
    protected short formatting_not_used;
    protected FontFormatting _fontFormatting;
    protected BorderFormatting _borderFormatting;
    protected PatternFormatting _patternFormatting;
    private Formula formula1;
    private Formula formula2;
    public byte ConditionType { get; public set; }
    public byte ComparisonOperation { get; public set; }
    public bool ContainsFontFormattingBlock { get; }
    public FontFormatting FontFormatting { get; public set; }
    public bool ContainsBorderFormattingBlock { get; }
    public BorderFormatting BorderFormatting { get; public set; }
    public bool ContainsPatternFormattingBlock { get; }
    public PatternFormatting PatternFormatting { get; public set; }
    public int Options { get; }
    public bool IsLeftBorderModified { get; public set; }
    public bool IsRightBorderModified { get; public set; }
    public bool IsTopBorderModified { get; public set; }
    public bool IsBottomBorderModified { get; public set; }
    public bool IsTopLeftBottomRightBorderModified { get; public set; }
    public bool IsBottomLeftTopRightBorderModified { get; public set; }
    public bool IsPatternStyleModified { get; public set; }
    public bool IsPatternColorModified { get; public set; }
    public bool IsPatternBackgroundColorModified { get; public set; }
    protected int FormattingBlockSize { get; }
    public Ptg[] ParsedExpression1 { get; public set; }
    protected Formula Formula1 { get; protected set; }
    public Ptg[] ParsedExpression2 { get; public set; }
    protected Formula Formula2 { get; protected set; }
    protected CFRuleBase(byte conditionType, byte comparisonOperation);
    protected CFRuleBase(byte conditionType, byte comparisonOperation, Ptg[] formula1, Ptg[] formula2);
    private static CFRuleBase();
    private static BitField bf(long i);
    protected int ReadFormatOptions(RecordInputStream in1);
    public byte get_ConditionType();
    public void set_ConditionType(byte value);
    public byte get_ComparisonOperation();
    public void set_ComparisonOperation(byte value);
    public bool get_ContainsFontFormattingBlock();
    public FontFormatting get_FontFormatting();
    public void set_FontFormatting(FontFormatting value);
    public bool ContainsAlignFormattingBlock();
    public void SetAlignFormattingUnChanged();
    public bool get_ContainsBorderFormattingBlock();
    public BorderFormatting get_BorderFormatting();
    public void set_BorderFormatting(BorderFormatting value);
    public bool get_ContainsPatternFormattingBlock();
    public PatternFormatting get_PatternFormatting();
    public void set_PatternFormatting(PatternFormatting value);
    public bool ContainsProtectionFormattingBlock();
    public void SetProtectionFormattingUnChanged();
    public int get_Options();
    private bool IsModified(BitField field);
    private void SetModified(bool modified, BitField field);
    public bool get_IsLeftBorderModified();
    public void set_IsLeftBorderModified(bool value);
    public bool get_IsRightBorderModified();
    public void set_IsRightBorderModified(bool value);
    public bool get_IsTopBorderModified();
    public void set_IsTopBorderModified(bool value);
    public bool get_IsBottomBorderModified();
    public void set_IsBottomBorderModified(bool value);
    public bool get_IsTopLeftBottomRightBorderModified();
    public void set_IsTopLeftBottomRightBorderModified(bool value);
    public bool get_IsBottomLeftTopRightBorderModified();
    public void set_IsBottomLeftTopRightBorderModified(bool value);
    public bool get_IsPatternStyleModified();
    public void set_IsPatternStyleModified(bool value);
    public bool get_IsPatternColorModified();
    public void set_IsPatternColorModified(bool value);
    public bool get_IsPatternBackgroundColorModified();
    public void set_IsPatternBackgroundColorModified(bool value);
    private bool GetOptionFlag(BitField field);
    private void SetOptionFlag(bool flag, BitField field);
    protected int get_FormattingBlockSize();
    protected void SerializeFormattingBlock(ILittleEndianOutput out1);
    public Ptg[] get_ParsedExpression1();
    public void set_ParsedExpression1(Ptg[] value);
    protected Formula get_Formula1();
    protected void set_Formula1(Formula value);
    public Ptg[] get_ParsedExpression2();
    public void set_ParsedExpression2(Ptg[] value);
    protected Formula get_Formula2();
    protected void set_Formula2(Formula value);
    protected static int GetFormulaSize(Formula formula);
    public static Ptg[] ParseFormula(string formula, HSSFSheet sheet);
    protected void CopyTo(CFRuleBase rec);
}
public class NPOI.HSSF.Record.CFRuleRecord : CFRuleBase {
    public static short sid;
    public short Sid { get; }
    protected int DataSize { get; }
    private CFRuleRecord(byte conditionType, byte comparisonOperation);
    private CFRuleRecord(byte conditionType, byte comparisonOperation, Ptg[] formula1, Ptg[] formula2);
    public CFRuleRecord(RecordInputStream in1);
    private static CFRuleRecord();
    private void SetDefaults();
    public static CFRuleRecord Create(HSSFSheet sheet, string formulaText);
    public static CFRuleRecord Create(HSSFSheet sheet, byte comparisonOperation, string formulaText1, string formulaText2);
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.Chart.AlRunsRecord : StandardRecord {
    public static short sid;
    private int m_recs;
    private ArrayList m_formats;
    protected int DataSize { get; }
    public short Sid { get; }
    public AlRunsRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public int GetFormatCount();
    public void ModifyFormatRun(short oldPos, short newLen);
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.AreaFormatRecord : StandardRecord {
    public static short FILL_PATTERN_NONE;
    public static short FILL_PATTERN_SOLID;
    public static short FILL_PATTERN_MEDIUM_GRAY;
    public static short FILL_PATTERN_DARK_GRAY;
    public static short FILL_PATTERN_LIGHT_GRAY;
    public static short FILL_PATTERN_HORIZONTAL_STRIPES;
    public static short FILL_PATTERN_VERTICAL_STRIPES;
    public static short FILL_PATTERN_DOWNWARD_DIAGONAL_STRIPES;
    public static short FILL_PATTERN_UPWARD_DIAGONAL_STRIPES;
    public static short FILL_PATTERN_GRID;
    public static short FILL_PATTERN_TRELLIS;
    public static short FILL_PATTERN_LIGHT_HORIZONTAL_STRIPES;
    public static short FILL_PATTERN_LIGHT_VERTICAL_STRIPES;
    public static short FILL_PATTERN_LIGHTDOWN;
    public static short FILL_PATTERN_LIGHTUP;
    public static short FILL_PATTERN_LIGHT_GRID;
    public static short FILL_PATTERN_LIGHT_TRELLIS;
    public static short FILL_PATTERN_GRAYSCALE_1_8;
    public static short FILL_PATTERN_GRAYSCALE_1_16;
    public static short sid;
    private int field_1_foregroundColor;
    private int field_2_backgroundColor;
    private short field_3_pattern;
    private short field_4_formatFlags;
    private BitField automatic;
    private BitField invert;
    private short field_5_forecolorIndex;
    private short field_6_backcolorIndex;
    protected int DataSize { get; }
    public short Sid { get; }
    public int ForegroundColor { get; public set; }
    public int BackgroundColor { get; public set; }
    public short Pattern { get; public set; }
    public short FormatFlags { get; public set; }
    public short ForecolorIndex { get; public set; }
    public short BackcolorIndex { get; public set; }
    public bool IsAutomatic { get; public set; }
    public bool IsInvert { get; public set; }
    public AreaFormatRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public int get_ForegroundColor();
    public void set_ForegroundColor(int value);
    public int get_BackgroundColor();
    public void set_BackgroundColor(int value);
    public short get_Pattern();
    public void set_Pattern(short value);
    public short get_FormatFlags();
    public void set_FormatFlags(short value);
    public short get_ForecolorIndex();
    public void set_ForecolorIndex(short value);
    public short get_BackcolorIndex();
    public void set_BackcolorIndex(short value);
    public bool get_IsAutomatic();
    public void set_IsAutomatic(bool value);
    public bool get_IsInvert();
    public void set_IsInvert(bool value);
}
public class NPOI.HSSF.Record.Chart.AreaRecord : StandardRecord {
    public static short sid;
    private short field_1_formatFlags;
    private BitField stacked;
    private BitField DisplayAsPercentage;
    private BitField shadow;
    protected int DataSize { get; }
    public short Sid { get; }
    public short FormatFlags { get; public set; }
    public bool IsStacked { get; public set; }
    public bool IsDisplayAsPercentage { get; public set; }
    public bool IsShadow { get; public set; }
    public AreaRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_FormatFlags();
    public void set_FormatFlags(short value);
    public bool get_IsStacked();
    public void set_IsStacked(bool value);
    public bool get_IsDisplayAsPercentage();
    public void set_IsDisplayAsPercentage(bool value);
    public bool get_IsShadow();
    public void set_IsShadow(bool value);
}
public class NPOI.HSSF.Record.Chart.AttachedLabelRecord : StandardRecord {
    public static short sid;
    private short field_1_formatFlags;
    private BitField showActual;
    private BitField showPercent;
    private BitField labelAsPercentage;
    private BitField smoothedLine;
    private BitField showLabel;
    private BitField showBubbleSizes;
    protected int DataSize { get; }
    public short Sid { get; }
    public short FormatFlags { get; public set; }
    public bool IsShowActual { get; public set; }
    public bool IsShowPercent { get; public set; }
    public bool IsLabelAsPercentage { get; public set; }
    public bool IsSmoothedLine { get; public set; }
    public bool IsShowLabel { get; public set; }
    public bool IsShowBubbleSizes { get; public set; }
    public AttachedLabelRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_FormatFlags();
    public void set_FormatFlags(short value);
    public bool get_IsShowActual();
    public void set_IsShowActual(bool value);
    public bool get_IsShowPercent();
    public void set_IsShowPercent(bool value);
    public bool get_IsLabelAsPercentage();
    public void set_IsLabelAsPercentage(bool value);
    public bool get_IsSmoothedLine();
    public void set_IsSmoothedLine(bool value);
    public bool get_IsShowLabel();
    public void set_IsShowLabel(bool value);
    public bool get_IsShowBubbleSizes();
    public void set_IsShowBubbleSizes(bool value);
}
public class NPOI.HSSF.Record.Chart.AxcExtRecord : StandardRecord {
    public static short sid;
    private short field_1_catMin;
    private short field_2_catMax;
    private short field_3_catMajor;
    private short field_4_duMajor;
    private short field_5_catMinor;
    private short field_6_duMinor;
    private short field_7_duBase;
    private short field_8_catCrossDate;
    private short field_9_options;
    private BitField fAutoMin;
    private BitField fAutoMax;
    private BitField fAutoMajor;
    private BitField fAutoMinor;
    private BitField fDateAxis;
    private BitField fAutoBase;
    private BitField fAutoCross;
    private BitField fAutoDate;
    protected int DataSize { get; }
    public short Sid { get; }
    public short MinimumDate { get; public set; }
    public short MaximumDate { get; public set; }
    public short MajorInterval { get; public set; }
    public DateUnit MajorUnit { get; public set; }
    public short MinorInterval { get; public set; }
    public DateUnit MinorUnit { get; public set; }
    public DateUnit BaseUnit { get; public set; }
    public short CrossDate { get; public set; }
    public short Options { get; public set; }
    public bool IsAutoMin { get; public set; }
    public bool IsAutoMax { get; public set; }
    public bool IsAutoMajor { get; public set; }
    public bool IsAutoMinor { get; public set; }
    public bool IsDateAxis { get; public set; }
    public bool IsAutoBase { get; public set; }
    public bool IsAutoCross { get; public set; }
    public bool IsAutoDate { get; public set; }
    public AxcExtRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_MinimumDate();
    public void set_MinimumDate(short value);
    public short get_MaximumDate();
    public void set_MaximumDate(short value);
    public short get_MajorInterval();
    public void set_MajorInterval(short value);
    public DateUnit get_MajorUnit();
    public void set_MajorUnit(DateUnit value);
    public short get_MinorInterval();
    public void set_MinorInterval(short value);
    public DateUnit get_MinorUnit();
    public void set_MinorUnit(DateUnit value);
    public DateUnit get_BaseUnit();
    public void set_BaseUnit(DateUnit value);
    public short get_CrossDate();
    public void set_CrossDate(short value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_IsAutoMin();
    public void set_IsAutoMin(bool value);
    public bool get_IsAutoMax();
    public void set_IsAutoMax(bool value);
    public bool get_IsAutoMajor();
    public void set_IsAutoMajor(bool value);
    public bool get_IsAutoMinor();
    public void set_IsAutoMinor(bool value);
    public bool get_IsDateAxis();
    public void set_IsDateAxis(bool value);
    public bool get_IsAutoBase();
    public void set_IsAutoBase(bool value);
    public bool get_IsAutoCross();
    public void set_IsAutoCross(bool value);
    public bool get_IsAutoDate();
    public void set_IsAutoDate(bool value);
}
public class NPOI.HSSF.Record.Chart.AxesUsedRecord : StandardRecord {
    public static short sid;
    private short field_1_numAxis;
    protected int DataSize { get; }
    public short Sid { get; }
    public short NumAxis { get; public set; }
    public AxesUsedRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_NumAxis();
    public void set_NumAxis(short value);
}
public class NPOI.HSSF.Record.Chart.AxisLineFormatRecord : StandardRecord {
    public static short sid;
    private short field_1_axisType;
    public static short AXIS_TYPE_AXIS_LINE;
    public static short AXIS_TYPE_MAJOR_GRID_LINE;
    public static short AXIS_TYPE_MINOR_GRID_LINE;
    public static short AXIS_TYPE_WALLS_OR_FLOOR;
    protected int DataSize { get; }
    public short Sid { get; }
    public short AxisType { get; public set; }
    public AxisLineFormatRecord(RecordInputStream in1);
    private static AxisLineFormatRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_AxisType();
    public void set_AxisType(short value);
}
public enum NPOI.HSSF.Record.Chart.AxisLineType : Enum {
    public int value__;
    public static AxisLineType AxisLine;
    public static AxisLineType MajorGridLine;
    public static AxisLineType MinorGridLine;
    public static AxisLineType WallsOrFloorOf3D;
}
public class NPOI.HSSF.Record.Chart.AxisOptionsRecord : StandardRecord {
    public static short sid;
    private static BitField defaultMinimum;
    private static BitField defaultMaximum;
    private static BitField defaultMajor;
    private static BitField defaultMinorUnit;
    private static BitField isDate;
    private static BitField defaultBase;
    private static BitField defaultCross;
    private static BitField defaultDateSettings;
    private short field_1_minimumCategory;
    private short field_2_maximumCategory;
    private short field_3_majorUnitValue;
    private short field_4_majorUnit;
    private short field_5_minorUnitValue;
    private short field_6_minorUnit;
    private short field_7_baseUnit;
    private short field_8_crossingPoint;
    private short field_9_options;
    protected int DataSize { get; }
    public short Sid { get; }
    public short MinimumCategory { get; public set; }
    public short MaximumCategory { get; public set; }
    public short MajorUnitValue { get; public set; }
    public short MajorUnit { get; public set; }
    public short MinorUnitValue { get; public set; }
    public short MinorUnit { get; public set; }
    public short BaseUnit { get; public set; }
    public short CrossingPoint { get; public set; }
    public short Options { get; public set; }
    public bool IsDefaultMinimum { get; public set; }
    public bool IsDefaultMaximum { get; public set; }
    public bool IsDefaultMajor { get; public set; }
    public bool IsDefaultMinorUnit { get; public set; }
    public bool IsIsDate { get; public set; }
    public bool IsDefaultBase { get; public set; }
    public bool IsDefaultCross { get; public set; }
    public bool IsDefaultDateSettings { get; public set; }
    public AxisOptionsRecord(RecordInputStream in1);
    private static AxisOptionsRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_MinimumCategory();
    public void set_MinimumCategory(short value);
    public short get_MaximumCategory();
    public void set_MaximumCategory(short value);
    public short get_MajorUnitValue();
    public void set_MajorUnitValue(short value);
    public short get_MajorUnit();
    public void set_MajorUnit(short value);
    public short get_MinorUnitValue();
    public void set_MinorUnitValue(short value);
    public short get_MinorUnit();
    public void set_MinorUnit(short value);
    public short get_BaseUnit();
    public void set_BaseUnit(short value);
    public short get_CrossingPoint();
    public void set_CrossingPoint(short value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_IsDefaultMinimum();
    public void set_IsDefaultMinimum(bool value);
    public bool get_IsDefaultMaximum();
    public void set_IsDefaultMaximum(bool value);
    public bool get_IsDefaultMajor();
    public void set_IsDefaultMajor(bool value);
    public bool get_IsDefaultMinorUnit();
    public void set_IsDefaultMinorUnit(bool value);
    public void SetIsDate(bool value);
    public bool get_IsIsDate();
    public void set_IsIsDate(bool value);
    public bool get_IsDefaultBase();
    public void set_IsDefaultBase(bool value);
    public bool get_IsDefaultCross();
    public void set_IsDefaultCross(bool value);
    public bool get_IsDefaultDateSettings();
    public void set_IsDefaultDateSettings(bool value);
}
public class NPOI.HSSF.Record.Chart.AxisParentRecord : StandardRecord {
    public static short sid;
    private short field_1_axisType;
    public static short AXIS_TYPE_MAIN;
    public static short AXIS_TYPE_SECONDARY;
    private int field_2_x;
    private int field_3_y;
    private int field_4_width;
    private int field_5_height;
    protected int DataSize { get; }
    public short Sid { get; }
    public short AxisType { get; public set; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public AxisParentRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_AxisType();
    public void set_AxisType(short value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
}
public class NPOI.HSSF.Record.Chart.AxisRecord : StandardRecord {
    public static short sid;
    private short field_1_axisType;
    public static short AXIS_TYPE_CATEGORY_OR_X_AXIS;
    public static short AXIS_TYPE_VALUE_AXIS;
    public static short AXIS_TYPE_SERIES_AXIS;
    private int field_2_reserved1;
    private int field_3_reserved2;
    private int field_4_reserved3;
    private int field_5_reserved4;
    protected int DataSize { get; }
    public short Sid { get; }
    public short AxisType { get; public set; }
    public int Reserved1 { get; public set; }
    public int Reserved2 { get; public set; }
    public int Reserved3 { get; public set; }
    public int Reserved4 { get; public set; }
    public AxisRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_AxisType();
    public void set_AxisType(short value);
    public int get_Reserved1();
    public void set_Reserved1(int value);
    public int get_Reserved2();
    public void set_Reserved2(int value);
    public int get_Reserved3();
    public void set_Reserved3(int value);
    public int get_Reserved4();
    public void set_Reserved4(int value);
}
public class NPOI.HSSF.Record.Chart.AxisUsedRecord : StandardRecord {
    public static short sid;
    private short field_1_numAxis;
    protected int DataSize { get; }
    public short Sid { get; }
    public short NumAxis { get; public set; }
    public AxisUsedRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_NumAxis();
    public void set_NumAxis(short value);
}
public class NPOI.HSSF.Record.Chart.BarRecord : StandardRecord {
    public static short sid;
    private short field_1_barSpace;
    private short field_2_categorySpace;
    private short field_3_formatFlags;
    private BitField horizontal;
    private BitField stacked;
    private BitField DisplayAsPercentage;
    private BitField shadow;
    protected int DataSize { get; }
    public short Sid { get; }
    public short BarSpace { get; public set; }
    public short CategorySpace { get; public set; }
    public short FormatFlags { get; public set; }
    public bool IsHorizontal { get; public set; }
    public bool IsStacked { get; public set; }
    public bool IsDisplayAsPercentage { get; public set; }
    public bool IsShadow { get; public set; }
    public BarRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_BarSpace();
    public void set_BarSpace(short value);
    public short get_CategorySpace();
    public void set_CategorySpace(short value);
    public short get_FormatFlags();
    public void set_FormatFlags(short value);
    public bool get_IsHorizontal();
    public void set_IsHorizontal(bool value);
    public bool get_IsStacked();
    public void set_IsStacked(bool value);
    public bool get_IsDisplayAsPercentage();
    public void set_IsDisplayAsPercentage(bool value);
    public bool get_IsShadow();
    public void set_IsShadow(bool value);
}
public class NPOI.HSSF.Record.Chart.BeginRecord : StandardRecord {
    public static short sid;
    public static BeginRecord instance;
    protected int DataSize { get; }
    public short Sid { get; }
    public BeginRecord(RecordInputStream in1);
    private static BeginRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.Chart.BopPopCustomRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public BopPopCustomRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.BopPopRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public BopPopRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.BRAIRecord : StandardRecord {
    private BitField customNumberFormat;
    public static short sid;
    private byte field_1_linkType;
    public static byte LINK_TYPE_TITLE_OR_TEXT;
    public static byte LINK_TYPE_VALUES;
    public static byte LINK_TYPE_CATEGORIES;
    public static byte LINK_TYPE_BUBBLESIZE_VALUE;
    private byte field_2_referenceType;
    public static byte REFERENCE_TYPE_DEFAULT_CATEGORIES;
    public static byte REFERENCE_TYPE_DIRECT;
    public static byte REFERENCE_TYPE_WORKSHEET;
    public static byte REFERENCE_TYPE_NOT_USED;
    public static byte REFERENCE_TYPE_ERROR_REPORTED;
    private short field_3_options;
    private short field_4_indexNumberFmtRecord;
    private Formula field_5_formulaOfLink;
    protected int DataSize { get; }
    public short Sid { get; }
    public byte LinkType { get; public set; }
    public byte ReferenceType { get; public set; }
    public short Options { get; public set; }
    public short IndexNumberFmtRecord { get; public set; }
    public Ptg[] FormulaOfLink { get; public set; }
    public bool IsCustomNumberFormat { get; public set; }
    public BRAIRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public byte get_LinkType();
    public void set_LinkType(byte value);
    public byte get_ReferenceType();
    public void set_ReferenceType(byte value);
    public short get_Options();
    public void set_Options(short value);
    public short get_IndexNumberFmtRecord();
    public void set_IndexNumberFmtRecord(short value);
    public Ptg[] get_FormulaOfLink();
    public void set_FormulaOfLink(Ptg[] value);
    public bool get_IsCustomNumberFormat();
    public void set_IsCustomNumberFormat(bool value);
}
public class NPOI.HSSF.Record.Chart.CategorySeriesAxisRecord : StandardRecord {
    public static short sid;
    private static BitField valueAxisCrossing;
    private static BitField crossesFarRight;
    private static BitField reversed;
    private short field_1_crossingPoint;
    private short field_2_labelFrequency;
    private short field_3_tickMarkFrequency;
    private short field_4_options;
    protected int DataSize { get; }
    public short Sid { get; }
    public short CrossingPoint { get; public set; }
    public short LabelFrequency { get; public set; }
    public short TickMarkFrequency { get; public set; }
    public short Options { get; public set; }
    public bool IsValueAxisCrossing { get; public set; }
    public bool IsCrossesFarRight { get; public set; }
    public bool IsReversed { get; public set; }
    public CategorySeriesAxisRecord(RecordInputStream in1);
    private static CategorySeriesAxisRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_CrossingPoint();
    public void set_CrossingPoint(short value);
    public short get_LabelFrequency();
    public void set_LabelFrequency(short value);
    public short get_TickMarkFrequency();
    public void set_TickMarkFrequency(short value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_IsValueAxisCrossing();
    public void set_IsValueAxisCrossing(bool value);
    public bool get_IsCrossesFarRight();
    public void set_IsCrossesFarRight(bool value);
    public bool get_IsReversed();
    public void set_IsReversed(bool value);
}
public class NPOI.HSSF.Record.Chart.CatLabRecord : StandardRecord {
    public static short sid;
    private short rt;
    private short grbitFrt;
    private short wOffset;
    private short at;
    private short grbit;
    private Nullable`1<short> unused;
    protected int DataSize { get; }
    public short Sid { get; }
    public CatLabRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.CatSerRangeRecord : StandardRecord {
    public static short sid;
    private short field_1_catCross;
    private short field_2_catLabel;
    private short field_3_catMark;
    private short field_4_options;
    private BitField fBetween;
    private BitField fMaxCross;
    private BitField fReverse;
    protected int DataSize { get; }
    public short Sid { get; }
    public short CrossPoint { get; public set; }
    public short LabelInterval { get; public set; }
    public short MarkInterval { get; public set; }
    public short Options { get; public set; }
    public bool IsBetween { get; public set; }
    public bool IsMaxCross { get; public set; }
    public bool IsReverse { get; public set; }
    public CatSerRangeRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_CrossPoint();
    public void set_CrossPoint(short value);
    public short get_LabelInterval();
    public void set_LabelInterval(short value);
    public short get_MarkInterval();
    public void set_MarkInterval(short value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_IsBetween();
    public void set_IsBetween(bool value);
    public bool get_IsMaxCross();
    public void set_IsMaxCross(bool value);
    public bool get_IsReverse();
    public void set_IsReverse(bool value);
}
public class NPOI.HSSF.Record.Chart.Chart3DBarShapeRecord : StandardRecord {
    public static short sid;
    private byte field_1_riser;
    private byte field_2_taper;
    protected int DataSize { get; }
    public short Sid { get; }
    public byte Riser { get; public set; }
    public byte Taper { get; public set; }
    public Chart3DBarShapeRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual object Clone();
    public virtual short get_Sid();
    public byte get_Riser();
    public void set_Riser(byte value);
    public byte get_Taper();
    public void set_Taper(byte value);
}
public class NPOI.HSSF.Record.Chart.Chart3dRecord : StandardRecord {
    public static short sid;
    private short field_1_anRot;
    private short field_2_anElev;
    private short field_3_pcDist;
    private short field_4_pcHeight;
    private short field_5_pcDepth;
    private short field_6_pcGap;
    private short field_7_option;
    private BitField fPerspective;
    private BitField fCluster;
    private BitField f3DScaling;
    private BitField reserved1;
    private BitField fNotPieChart;
    private BitField fWalls2D;
    protected int DataSize { get; }
    public short Sid { get; }
    public int Rotation { get; public set; }
    public int Elev { get; public set; }
    public int Dist { get; public set; }
    public int Height { get; public set; }
    public int Depth { get; public set; }
    public int Gap { get; public set; }
    public bool IsPerspective { get; public set; }
    public bool IsCluster { get; public set; }
    public bool Is3DScaling { get; public set; }
    public bool IsNotPieChart { get; public set; }
    public bool IsWalls2D { get; public set; }
    public Chart3dRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public int get_Rotation();
    public void set_Rotation(int value);
    public int get_Elev();
    public void set_Elev(int value);
    public int get_Dist();
    public void set_Dist(int value);
    public int get_Height();
    public void set_Height(int value);
    public int get_Depth();
    public void set_Depth(int value);
    public int get_Gap();
    public void set_Gap(int value);
    public bool get_IsPerspective();
    public void set_IsPerspective(bool value);
    public bool get_IsCluster();
    public void set_IsCluster(bool value);
    public bool get_Is3DScaling();
    public void set_Is3DScaling(bool value);
    public bool get_IsNotPieChart();
    public void set_IsNotPieChart(bool value);
    public bool get_IsWalls2D();
    public void set_IsWalls2D(bool value);
    public virtual object Clone();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.ChartEndBlockRecord : StandardRecord {
    public static short sid;
    private short rt;
    private short grbitFrt;
    private short iObjectKind;
    private Byte[] unused;
    protected int DataSize { get; }
    public short Sid { get; }
    public ChartEndBlockRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
    public ChartEndBlockRecord clone();
}
public class NPOI.HSSF.Record.Chart.ChartEndObjectRecord : StandardRecord {
    public static short sid;
    private short rt;
    private short grbitFrt;
    private short iObjectKind;
    private Byte[] reserved;
    protected int DataSize { get; }
    public short Sid { get; }
    public ChartEndObjectRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.ChartFRTInfoRecord : StandardRecord {
    public static short sid;
    private short rt;
    private short grbitFrt;
    private byte verOriginator;
    private byte verWriter;
    private CFRTID[] rgCFRTID;
    protected int DataSize { get; }
    public short Sid { get; }
    public ChartFRTInfoRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual object Clone();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.ChartRecord : StandardRecord {
    public static short sid;
    private int field_1_x;
    private int field_2_y;
    private int field_3_width;
    private int field_4_height;
    protected int DataSize { get; }
    public short Sid { get; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public ChartRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
}
public class NPOI.HSSF.Record.Chart.ChartStartBlockRecord : StandardRecord {
    public static short sid;
    private short rt;
    private short grbitFrt;
    private short iObjectKind;
    private short iObjectContext;
    private short iObjectInstance1;
    private short iObjectInstance2;
    protected int DataSize { get; }
    public short Sid { get; }
    public ChartStartBlockRecord(RecordInputStream in1);
    private static ChartStartBlockRecord();
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.Chart.ChartStartObjectRecord : StandardRecord {
    public static short sid;
    private short rt;
    private short grbitFrt;
    private short iObjectKind;
    private short iObjectContext;
    private short iObjectInstance1;
    private short iObjectInstance2;
    protected int DataSize { get; }
    public short Sid { get; }
    public ChartStartObjectRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.ChartTitleFormatRecord : StandardRecord {
    public static short sid;
    private int m_recs;
    private ArrayList m_formats;
    protected int DataSize { get; }
    public short Sid { get; }
    public ChartTitleFormatRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public int GetFormatCount();
    public void ModifyFormatRun(short oldPos, short newLen);
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.CrtLayout12ARecord : StandardRecord {
    public static short sid;
    private FrtHeader frtHeader;
    private int field_1_dwCheckSum;
    private short field_2_option;
    private short field_3_xTL;
    private short field_4_yTL;
    private short field_5_xBR;
    private short field_6_yBR;
    private short field_7_wXMode;
    private short field_8_wYMode;
    private short field_9_wWidthMode;
    private short field_10_wHeightMode;
    private double field_11_x;
    private double field_12_y;
    private double field_13_dx;
    private double field_14_dy;
    private short reserved2;
    private BitField fLayoutTargetInner;
    protected int DataSize { get; }
    public short Sid { get; }
    public bool IsLayoutTargetInner { get; public set; }
    public int CheckSum { get; public set; }
    public short XTL { get; public set; }
    public short YTL { get; public set; }
    public short XBR { get; public set; }
    public short YBR { get; public set; }
    public CrtLayout12Mode XMode { get; public set; }
    public CrtLayout12Mode YMode { get; public set; }
    public CrtLayout12Mode WidthMode { get; public set; }
    public CrtLayout12Mode HeightMode { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double DX { get; public set; }
    public double DY { get; public set; }
    public CrtLayout12ARecord(RecordInputStream ris);
    public virtual object Clone();
    public virtual string ToString();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public bool get_IsLayoutTargetInner();
    public void set_IsLayoutTargetInner(bool value);
    public int get_CheckSum();
    public void set_CheckSum(int value);
    public short get_XTL();
    public void set_XTL(short value);
    public short get_YTL();
    public void set_YTL(short value);
    public short get_XBR();
    public void set_XBR(short value);
    public short get_YBR();
    public void set_YBR(short value);
    public CrtLayout12Mode get_XMode();
    public void set_XMode(CrtLayout12Mode value);
    public CrtLayout12Mode get_YMode();
    public void set_YMode(CrtLayout12Mode value);
    public CrtLayout12Mode get_WidthMode();
    public void set_WidthMode(CrtLayout12Mode value);
    public CrtLayout12Mode get_HeightMode();
    public void set_HeightMode(CrtLayout12Mode value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_DX();
    public void set_DX(double value);
    public double get_DY();
    public void set_DY(double value);
}
public enum NPOI.HSSF.Record.Chart.CrtLayout12Mode : Enum {
    public short value__;
    public static CrtLayout12Mode L12MAUTO;
    public static CrtLayout12Mode L12MFACTOR;
    public static CrtLayout12Mode L12MEDGE;
}
public class NPOI.HSSF.Record.Chart.CrtLayout12Record : StandardRecord {
    public static short sid;
    private short field_1_frtHeader_rt;
    private short field_2_frtHeader_grbitFrt;
    private int field_5_dwCheckSum;
    private short field_6_option;
    private short field_7_wXMode;
    private short field_8_wYMode;
    private short field_9_wWidthMode;
    private short field_10_wHeightMode;
    private double field_11_x;
    private double field_12_y;
    private double field_13_dx;
    private double field_14_dy;
    public static int AutoLayoutType_Bottom;
    public static int AutoLayoutType_TopRightCorner;
    public static int AutoLayoutType_Top;
    public static int AutoLayoutType_Right;
    public static int AutoLayoutType_Left;
    private BitField autolayouttype;
    protected int DataSize { get; }
    public short Sid { get; }
    public int AutoLayoutType { get; public set; }
    public int CheckSum { get; public set; }
    public CrtLayout12Mode XMode { get; public set; }
    public CrtLayout12Mode YMode { get; public set; }
    public CrtLayout12Mode WidthMode { get; public set; }
    public CrtLayout12Mode HeightMode { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double DX { get; public set; }
    public double DY { get; public set; }
    public CrtLayout12Record(RecordInputStream ris);
    private static CrtLayout12Record();
    public virtual string ToString();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public virtual object Clone();
    public int get_AutoLayoutType();
    public void set_AutoLayoutType(int value);
    public int get_CheckSum();
    public void set_CheckSum(int value);
    public CrtLayout12Mode get_XMode();
    public void set_XMode(CrtLayout12Mode value);
    public CrtLayout12Mode get_YMode();
    public void set_YMode(CrtLayout12Mode value);
    public CrtLayout12Mode get_WidthMode();
    public void set_WidthMode(CrtLayout12Mode value);
    public CrtLayout12Mode get_HeightMode();
    public void set_HeightMode(CrtLayout12Mode value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_DX();
    public void set_DX(double value);
    public double get_DY();
    public void set_DY(double value);
}
public class NPOI.HSSF.Record.Chart.CrtLineRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public CrtLineRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.CrtLinkRecord : StandardRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public CrtLinkRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public virtual object Clone();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.CrtMlFrtContinueRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public CrtMlFrtContinueRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.CrtMlFrtRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public CrtMlFrtRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.DataFormatRecord : StandardRecord {
    public static short sid;
    private short field_1_pointNumber;
    private short field_2_seriesIndex;
    private short field_3_seriesNumber;
    private short field_4_formatFlags;
    private BitField useExcel4Colors;
    protected int DataSize { get; }
    public short Sid { get; }
    public short PointNumber { get; public set; }
    public short SeriesIndex { get; public set; }
    public short SeriesNumber { get; public set; }
    public short FormatFlags { get; public set; }
    public bool UseExcel4Colors { get; public set; }
    public DataFormatRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_PointNumber();
    public void set_PointNumber(short value);
    public short get_SeriesIndex();
    public void set_SeriesIndex(short value);
    public short get_SeriesNumber();
    public void set_SeriesNumber(short value);
    public short get_FormatFlags();
    public void set_FormatFlags(short value);
    public bool get_UseExcel4Colors();
    public void set_UseExcel4Colors(bool value);
}
public class NPOI.HSSF.Record.Chart.DataLabelExtensionRecord : StandardRecord {
    public static short sid;
    private int rt;
    private int grbitFrt;
    private Byte[] unused;
    protected int DataSize { get; }
    public short Sid { get; }
    public DataLabelExtensionRecord(RecordInputStream in1);
    private static DataLabelExtensionRecord();
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Chart.DataLabExtContentsRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public DataLabExtContentsRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.DataLabExtRecord : StandardRecord {
    public static short sid;
    private int rt;
    private int grbitFrt;
    private Byte[] unused;
    protected int DataSize { get; }
    public short Sid { get; }
    public DataLabExtRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
}
public enum NPOI.HSSF.Record.Chart.DateUnit : Enum {
    public int value__;
    public static DateUnit Days;
    public static DateUnit Months;
    public static DateUnit Years;
}
public class NPOI.HSSF.Record.Chart.DatRecord : StandardRecord {
    public static short sid;
    private short field_1_options;
    private BitField horizontalBorder;
    private BitField verticalBorder;
    private BitField border;
    private BitField showSeriesKey;
    protected int DataSize { get; }
    public short Sid { get; }
    public short Options { get; public set; }
    public DatRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_Options();
    public void set_Options(short value);
    public void SetHorizontalBorder(bool value);
    public bool IsHorizontalBorder();
    public void SetVerticalBorder(bool value);
    public bool IsVerticalBorder();
    public void SetBorder(bool value);
    public bool IsBorder();
    public void SetShowSeriesKey(bool value);
    public bool IsShowSeriesKey();
}
public class NPOI.HSSF.Record.Chart.DefaultDataLabelTextPropertiesRecord : StandardRecord {
    public static short sid;
    private short field_1_categoryDataType;
    public static short CATEGORY_DATA_TYPE_SHOW_LABELS_CHARACTERISTIC;
    public static short CATEGORY_DATA_TYPE_VALUE_AND_PERCENTAGE_CHARACTERISTIC;
    public static short CATEGORY_DATA_TYPE_ALL_TEXT_CHARACTERISTIC;
    protected int DataSize { get; }
    public short Sid { get; }
    public short CategoryDataType { get; public set; }
    public DefaultDataLabelTextPropertiesRecord(RecordInputStream in1);
    private static DefaultDataLabelTextPropertiesRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_CategoryDataType();
    public void set_CategoryDataType(short value);
}
public class NPOI.HSSF.Record.Chart.DefaultTextRecord : StandardRecord {
    public static short sid;
    private short field_1_categoryDataType;
    protected int DataSize { get; }
    public short Sid { get; }
    public TextFormatInfo FormatType { get; public set; }
    public DefaultTextRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public TextFormatInfo get_FormatType();
    public void set_FormatType(TextFormatInfo value);
}
public class NPOI.HSSF.Record.Chart.DropBarRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public DropBarRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.EndBlockRecord : StandardRecord {
    public static short sid;
    private short rt;
    private short grbitFrt;
    [CompilerGeneratedAttribute]
private ObjectKind <ObjectKind>k__BackingField;
    private Byte[] unused;
    public ObjectKind ObjectKind { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public EndBlockRecord(RecordInputStream in1);
    [CompilerGeneratedAttribute]
public ObjectKind get_ObjectKind();
    [CompilerGeneratedAttribute]
public void set_ObjectKind(ObjectKind value);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
    public EndBlockRecord clone();
    public static EndBlockRecord CreateEndBlock(ObjectKind objectKind);
}
public class NPOI.HSSF.Record.Chart.EndRecord : StandardRecord {
    public static short sid;
    public static EndRecord instance;
    protected int DataSize { get; }
    public short Sid { get; }
    public EndRecord(RecordInputStream in1);
    private static EndRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.Chart.Fbi2Record : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public Fbi2Record(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.FbiRecord : StandardRecord {
    public static short sid;
    private short field_1_xBasis;
    private short field_2_yBasis;
    private short field_3_heightBasis;
    private short field_4_scale;
    private short field_5_indexToFontTable;
    protected int DataSize { get; }
    public short Sid { get; }
    public short XBasis { get; public set; }
    public short YBasis { get; public set; }
    public short HeightBasis { get; public set; }
    public short Scale { get; public set; }
    public short IndexToFontTable { get; public set; }
    public FbiRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_XBasis();
    public void set_XBasis(short value);
    public short get_YBasis();
    public void set_YBasis(short value);
    public short get_HeightBasis();
    public void set_HeightBasis(short value);
    public short get_Scale();
    public void set_Scale(short value);
    public short get_IndexToFontTable();
    public void set_IndexToFontTable(short value);
}
public class NPOI.HSSF.Record.Chart.FontBasisRecord : StandardRecord {
    public static short sid;
    private short field_1_xBasis;
    private short field_2_yBasis;
    private short field_3_heightBasis;
    private short field_4_scale;
    private short field_5_indexToFontTable;
    protected int DataSize { get; }
    public short Sid { get; }
    public short XBasis { get; public set; }
    public short YBasis { get; public set; }
    public short HeightBasis { get; public set; }
    public short Scale { get; public set; }
    public short IndexToFontTable { get; public set; }
    public FontBasisRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_XBasis();
    public void set_XBasis(short value);
    public short get_YBasis();
    public void set_YBasis(short value);
    public short get_HeightBasis();
    public void set_HeightBasis(short value);
    public short get_Scale();
    public void set_Scale(short value);
    public short get_IndexToFontTable();
    public void set_IndexToFontTable(short value);
}
public class NPOI.HSSF.Record.Chart.FontIndexRecord : StandardRecord {
    public static short sid;
    private short field_1_fontIndex;
    protected int DataSize { get; }
    public short Sid { get; }
    public short FontIndex { get; public set; }
    public FontIndexRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_FontIndex();
    public void set_FontIndex(short value);
}
public class NPOI.HSSF.Record.Chart.FrameRecord : StandardRecord {
    public static short sid;
    private short field_1_borderType;
    public static short BORDER_TYPE_REGULAR;
    public static short BORDER_TYPE_SHADOW;
    private short field_2_options;
    private BitField autoSize;
    private BitField autoPosition;
    protected int DataSize { get; }
    public short Sid { get; }
    public short BorderType { get; public set; }
    public short Options { get; public set; }
    public bool IsAutoSize { get; public set; }
    public bool IsAutoPosition { get; public set; }
    public FrameRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_BorderType();
    public void set_BorderType(short value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_IsAutoSize();
    public void set_IsAutoSize(bool value);
    public bool get_IsAutoPosition();
    public void set_IsAutoPosition(bool value);
}
public class NPOI.HSSF.Record.Chart.FrtFontListRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public FrtFontListRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.GelFrameRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public GelFrameRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.IFmtRecordRecord : StandardRecord {
    public static short sid;
    private short field_1_formatIndex;
    protected int DataSize { get; }
    public short Sid { get; }
    public short FormatIndex { get; public set; }
    public IFmtRecordRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_FormatIndex();
    public void set_FormatIndex(short value);
}
public class NPOI.HSSF.Record.Chart.LegendExceptionRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public short LegendEntry { get; public set; }
    public LegendExceptionRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public short get_LegendEntry();
    public void set_LegendEntry(short value);
}
public class NPOI.HSSF.Record.Chart.LegendRecord : StandardRecord {
    public static short sid;
    private int field_1_xAxisUpperLeft;
    private int field_2_yAxisUpperLeft;
    private int field_3_xSize;
    private int field_4_ySize;
    private byte field_5_type;
    public static byte TYPE_BOTTOM;
    public static byte TYPE_CORNER;
    public static byte TYPE_TOP;
    public static byte TYPE_RIGHT;
    public static byte TYPE_LEFT;
    public static byte TYPE_UNDOCKED;
    private byte field_6_spacing;
    public static byte SPACING_CLOSE;
    public static byte SPACING_MEDIUM;
    public static byte SPACING_OPEN;
    private short field_7_options;
    private BitField autoPosition;
    private BitField autoSeries;
    private BitField autoXPositioning;
    private BitField autoYPositioning;
    private BitField vertical;
    private BitField dataTable;
    protected int DataSize { get; }
    public short Sid { get; }
    public int XAxisUpperLeft { get; public set; }
    public int YAxisUpperLeft { get; public set; }
    public int XSize { get; public set; }
    public int YSize { get; public set; }
    public byte Type { get; public set; }
    public byte Spacing { get; public set; }
    public short Options { get; public set; }
    public bool IsAutoPosition { get; public set; }
    public bool IsAutoSeries { get; public set; }
    public bool IsAutoXPositioning { get; public set; }
    public bool IsAutoYPositioning { get; public set; }
    public bool IsVertical { get; public set; }
    public bool IsDataTable { get; public set; }
    public LegendRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public int get_XAxisUpperLeft();
    public void set_XAxisUpperLeft(int value);
    public int get_YAxisUpperLeft();
    public void set_YAxisUpperLeft(int value);
    public int get_XSize();
    public void set_XSize(int value);
    public int get_YSize();
    public void set_YSize(int value);
    public byte get_Type();
    public void set_Type(byte value);
    public byte get_Spacing();
    public void set_Spacing(byte value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_IsAutoPosition();
    public void set_IsAutoPosition(bool value);
    public bool get_IsAutoSeries();
    public void set_IsAutoSeries(bool value);
    public bool get_IsAutoXPositioning();
    public void set_IsAutoXPositioning(bool value);
    public bool get_IsAutoYPositioning();
    public void set_IsAutoYPositioning(bool value);
    public bool get_IsVertical();
    public void set_IsVertical(bool value);
    public bool get_IsDataTable();
    public void set_IsDataTable(bool value);
}
public class NPOI.HSSF.Record.Chart.LineFormatRecord : StandardRecord {
    public static short sid;
    private int field_1_lineColor;
    private short field_2_linePattern;
    public static short LINE_PATTERN_SOLID;
    public static short LINE_PATTERN_DASH;
    public static short LINE_PATTERN_DOT;
    public static short LINE_PATTERN_DASH_DOT;
    public static short LINE_PATTERN_DASH_DOT_DOT;
    public static short LINE_PATTERN_NONE;
    public static short LINE_PATTERN_DARK_GRAY_PATTERN;
    public static short LINE_PATTERN_MEDIUM_GRAY_PATTERN;
    public static short LINE_PATTERN_LIGHT_GRAY_PATTERN;
    private short field_3_weight;
    public static short WEIGHT_HAIRLINE;
    public static short WEIGHT_NARROW;
    public static short WEIGHT_MEDIUM;
    public static short WEIGHT_WIDE;
    private short field_4_format;
    private BitField auto;
    private BitField drawTicks;
    private BitField Unknown;
    private short field_5_colourPaletteIndex;
    protected int DataSize { get; }
    public short Sid { get; }
    public int LineColor { get; public set; }
    public short LinePattern { get; public set; }
    public short Weight { get; public set; }
    public short Format { get; public set; }
    public short ColourPaletteIndex { get; public set; }
    public bool IsAuto { get; public set; }
    public bool IsDrawTicks { get; public set; }
    public bool IsUnknown { get; public set; }
    public LineFormatRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public int get_LineColor();
    public void set_LineColor(int value);
    public short get_LinePattern();
    public void set_LinePattern(short value);
    public short get_Weight();
    public void set_Weight(short value);
    public short get_Format();
    public void set_Format(short value);
    public short get_ColourPaletteIndex();
    public void set_ColourPaletteIndex(short value);
    public bool get_IsAuto();
    public void set_IsAuto(bool value);
    public bool get_IsDrawTicks();
    public void set_IsDrawTicks(bool value);
    public bool get_IsUnknown();
    public void set_IsUnknown(bool value);
}
public class NPOI.HSSF.Record.Chart.LinkedDataRecord : StandardRecord {
    public static short sid;
    private static BitField customNumberFormat;
    private byte field_1_linkType;
    public static byte LINK_TYPE_TITLE_OR_TEXT;
    public static byte LINK_TYPE_VALUES;
    public static byte LINK_TYPE_CATEGORIES;
    public static byte LINK_TYPE_SECONDARY_CATEGORIES;
    private byte field_2_referenceType;
    public static byte REFERENCE_TYPE_DEFAULT_CATEGORIES;
    public static byte REFERENCE_TYPE_DIRECT;
    public static byte REFERENCE_TYPE_WORKSHEET;
    public static byte REFERENCE_TYPE_NOT_USED;
    public static byte REFERENCE_TYPE_ERROR_REPORTED;
    private short field_3_options;
    private short field_4_indexNumberFmtRecord;
    private Formula field_5_formulaOfLink;
    protected int DataSize { get; }
    public short Sid { get; }
    public byte LinkType { get; public set; }
    public byte ReferenceType { get; public set; }
    public short Options { get; public set; }
    public short IndexNumberFmtRecord { get; public set; }
    public Ptg[] FormulaOfLink { get; public set; }
    public bool IsCustomNumberFormat { get; public set; }
    public LinkedDataRecord(RecordInputStream in1);
    private static LinkedDataRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public byte get_LinkType();
    public void set_LinkType(byte value);
    public byte get_ReferenceType();
    public void set_ReferenceType(byte value);
    public short get_Options();
    public void set_Options(short value);
    public short get_IndexNumberFmtRecord();
    public void set_IndexNumberFmtRecord(short value);
    public Ptg[] get_FormulaOfLink();
    public void set_FormulaOfLink(Ptg[] value);
    public bool get_IsCustomNumberFormat();
    public void set_IsCustomNumberFormat(bool value);
}
public class NPOI.HSSF.Record.Chart.MarkerFormatRecord : StandardRecord {
    public static short sid;
    private int field_1_rgbFore;
    private int field_2_rgbBack;
    private short field_3_imk;
    private short field_4_flag;
    private short field_5_icvFore;
    private short field_6_icvBack;
    private int field_7_miSize;
    private BitField fAuto;
    private BitField fNotShowInt;
    private BitField fNotShowBrd;
    protected int DataSize { get; }
    public short Sid { get; }
    public int RGBFore { get; public set; }
    public int RGBBack { get; public set; }
    public short DataMarkerType { get; public set; }
    public bool Auto { get; public set; }
    public bool NotShowInt { get; public set; }
    public bool NotShowBorder { get; public set; }
    public short IcvFore { get; public set; }
    public short IcvBack { get; public set; }
    public int Size { get; public set; }
    public MarkerFormatRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
    public virtual object Clone();
    public virtual short get_Sid();
    public int get_RGBFore();
    public void set_RGBFore(int value);
    public int get_RGBBack();
    public void set_RGBBack(int value);
    public short get_DataMarkerType();
    public void set_DataMarkerType(short value);
    public bool get_Auto();
    public void set_Auto(bool value);
    public bool get_NotShowInt();
    public void set_NotShowInt(bool value);
    public bool get_NotShowBorder();
    public void set_NotShowBorder(bool value);
    public short get_IcvFore();
    public void set_IcvFore(short value);
    public short get_IcvBack();
    public void set_IcvBack(short value);
    public int get_Size();
    public void set_Size(int value);
}
public enum NPOI.HSSF.Record.Chart.MarkerType : Enum {
    public int value__;
    public static MarkerType None;
    public static MarkerType Square;
    public static MarkerType DiamondShaped;
    public static MarkerType Triangular;
    public static MarkerType SquareWithX;
    public static MarkerType SquareWithAsterisk;
    public static MarkerType ShortBar;
    public static MarkerType LongBar;
    public static MarkerType Circular;
    public static MarkerType SquareWithPlus;
}
public class NPOI.HSSF.Record.Chart.NumberFormatIndexRecord : StandardRecord {
    public static short sid;
    private short field_1_formatIndex;
    protected int DataSize { get; }
    public short Sid { get; }
    public short FormatIndex { get; public set; }
    public NumberFormatIndexRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_FormatIndex();
    public void set_FormatIndex(short value);
}
public enum NPOI.HSSF.Record.Chart.ObjectKind : Enum {
    public short value__;
    public static ObjectKind AxisGroup;
    public static ObjectKind AttachedLabelRecord;
    public static ObjectKind Axis;
    public static ObjectKind ChartGroup;
    public static ObjectKind DatRecord;
    public static ObjectKind Frame;
    public static ObjectKind Legend;
    public static ObjectKind LegendException;
    public static ObjectKind Series;
    public static ObjectKind Sheet;
    public static ObjectKind DataFormatRecord;
    public static ObjectKind DropBarRecord;
}
public class NPOI.HSSF.Record.Chart.ObjectLinkRecord : StandardRecord {
    public static short sid;
    private short field_1_anchorId;
    public static short ANCHOR_ID_CHART_TITLE;
    public static short ANCHOR_ID_Y_AXIS;
    public static short ANCHOR_ID_X_AXIS;
    public static short ANCHOR_ID_SERIES_OR_POINT;
    public static short ANCHOR_ID_Z_AXIS;
    private short field_2_link1;
    private short field_3_link2;
    protected int DataSize { get; }
    public short Sid { get; }
    public short AnchorId { get; public set; }
    public short Link1 { get; public set; }
    public short Link2 { get; public set; }
    public ObjectLinkRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_AnchorId();
    public void set_AnchorId(short value);
    public short get_Link1();
    public void set_Link1(short value);
    public short get_Link2();
    public void set_Link2(short value);
}
public class NPOI.HSSF.Record.Chart.PicFRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public PicFRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.PieFormatRecord : StandardRecord {
    public static short sid;
    private short field_1_pcExplode;
    protected int DataSize { get; }
    public short Sid { get; }
    public int Explode { get; public set; }
    public PieFormatRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public virtual object Clone();
    public virtual string ToString();
    public int get_Explode();
    public void set_Explode(int value);
}
public class NPOI.HSSF.Record.Chart.PieRecord : StandardRecord {
    public static short sid;
    private short field_1_anStart;
    private short field_2_pcDonut;
    private short field_3_option;
    private BitField fHasShadow;
    private BitField fShowLdrLines;
    protected int DataSize { get; }
    public short Sid { get; }
    public int Start { get; public set; }
    public int Dount { get; public set; }
    public bool HasShadow { get; public set; }
    public bool ShowLdrLines { get; public set; }
    public PieRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public virtual object Clone();
    public virtual string ToString();
    public int get_Start();
    public void set_Start(int value);
    public int get_Dount();
    public void set_Dount(int value);
    public bool get_HasShadow();
    public void set_HasShadow(bool value);
    public bool get_ShowLdrLines();
    public void set_ShowLdrLines(bool value);
}
public class NPOI.HSSF.Record.Chart.PlotAreaRecord : StandardRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public PlotAreaRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.Chart.PlotGrowthRecord : StandardRecord {
    public static short sid;
    private int field_1_horizontalScale;
    private int field_2_verticalScale;
    protected int DataSize { get; }
    public short Sid { get; }
    public int HorizontalScale { get; public set; }
    public int VerticalScale { get; public set; }
    public PlotGrowthRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public int get_HorizontalScale();
    public void set_HorizontalScale(int value);
    public int get_VerticalScale();
    public void set_VerticalScale(int value);
}
public enum NPOI.HSSF.Record.Chart.PositionMode : Enum {
    public short value__;
    public static PositionMode MDFX;
    public static PositionMode MDABS;
    public static PositionMode MDPARENT;
    public static PositionMode MDKTH;
    public static PositionMode MDCHART;
}
public class NPOI.HSSF.Record.Chart.PosRecord : StandardRecord {
    public static short sid;
    private short mdTopLt;
    private short mdBotRt;
    private short x1;
    private short y1;
    private short x2;
    private short y2;
    protected int DataSize { get; }
    public short Sid { get; }
    public PositionMode MDTopLt { get; public set; }
    public PositionMode MdBotRt { get; public set; }
    public short X1 { get; public set; }
    public short X2 { get; public set; }
    public short Y1 { get; public set; }
    public short Y2 { get; public set; }
    public PosRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public virtual object Clone();
    public virtual string ToString();
    public PositionMode get_MDTopLt();
    public void set_MDTopLt(PositionMode value);
    public PositionMode get_MdBotRt();
    public void set_MdBotRt(PositionMode value);
    public short get_X1();
    public void set_X1(short value);
    public short get_X2();
    public void set_X2(short value);
    public short get_Y1();
    public void set_Y1(short value);
    public short get_Y2();
    public void set_Y2(short value);
}
public class NPOI.HSSF.Record.Chart.RadarAreaRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public RadarAreaRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.RadarRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public RadarRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.RichTextStreamRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public RichTextStreamRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.ScatterRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public ScatterRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.SerAuxErrBarRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public SerAuxErrBarRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.SerAuxTrendRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public SerAuxTrendRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.SerFmtRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public SerFmtRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.SeriesChartGroupIndexRecord : StandardRecord {
    public static short sid;
    private short field_1_chartGroupIndex;
    protected int DataSize { get; }
    public short Sid { get; }
    public short ChartGroupIndex { get; public set; }
    public SeriesChartGroupIndexRecord(RecordInputStream in1);
    private static SeriesChartGroupIndexRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_ChartGroupIndex();
    public void set_ChartGroupIndex(short value);
}
public class NPOI.HSSF.Record.Chart.SeriesIndexRecord : StandardRecord {
    public static short sid;
    private short field_1_index;
    protected int DataSize { get; }
    public short Sid { get; }
    public short Index { get; public set; }
    public SeriesIndexRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_Index();
    public void set_Index(short value);
}
public class NPOI.HSSF.Record.Chart.SeriesLabelsRecord : StandardRecord {
    public static short sid;
    private short field_1_formatFlags;
    private BitField showActual;
    private BitField showPercent;
    private BitField labelAsPercentage;
    private BitField smoothedLine;
    private BitField showLabel;
    private BitField showBubbleSizes;
    protected int DataSize { get; }
    public short Sid { get; }
    public short FormatFlags { get; public set; }
    public bool IsShowActual { get; public set; }
    public bool IsShowPercent { get; public set; }
    public bool IsLabelAsPercentage { get; public set; }
    public bool IsSmoothedLine { get; public set; }
    public bool IsShowLabel { get; public set; }
    public bool IsShowBubbleSizes { get; public set; }
    public SeriesLabelsRecord(RecordInputStream in1);
    private static SeriesLabelsRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_FormatFlags();
    public void set_FormatFlags(short value);
    public bool get_IsShowActual();
    public void set_IsShowActual(bool value);
    public bool get_IsShowPercent();
    public void set_IsShowPercent(bool value);
    public bool get_IsLabelAsPercentage();
    public void set_IsLabelAsPercentage(bool value);
    public bool get_IsSmoothedLine();
    public void set_IsSmoothedLine(bool value);
    public bool get_IsShowLabel();
    public void set_IsShowLabel(bool value);
    public bool get_IsShowBubbleSizes();
    public void set_IsShowBubbleSizes(bool value);
}
public class NPOI.HSSF.Record.Chart.SeriesListRecord : StandardRecord {
    public static short sid;
    private Int16[] field_1_seriesNumbers;
    protected int DataSize { get; }
    public short Sid { get; }
    public Int16[] SeriesNumbers { get; public set; }
    public SeriesListRecord(Int16[] seriesNumbers);
    public SeriesListRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public Int16[] get_SeriesNumbers();
    public void set_SeriesNumbers(Int16[] value);
}
public class NPOI.HSSF.Record.Chart.SeriesRecord : StandardRecord {
    public static short sid;
    private short field_1_categoryDataType;
    public static short CATEGORY_DATA_TYPE_DATES;
    public static short CATEGORY_DATA_TYPE_NUMERIC;
    public static short CATEGORY_DATA_TYPE_SEQUENCE;
    public static short CATEGORY_DATA_TYPE_TEXT;
    private short field_2_valuesDataType;
    public static short VALUES_DATA_TYPE_DATES;
    public static short VALUES_DATA_TYPE_NUMERIC;
    public static short VALUES_DATA_TYPE_SEQUENCE;
    public static short VALUES_DATA_TYPE_TEXT;
    private short field_3_numCategories;
    private short field_4_numValues;
    private short field_5_bubbleSeriesType;
    public static short BUBBLE_SERIES_TYPE_DATES;
    public static short BUBBLE_SERIES_TYPE_NUMERIC;
    public static short BUBBLE_SERIES_TYPE_SEQUENCE;
    public static short BUBBLE_SERIES_TYPE_TEXT;
    private short field_6_numBubbleValues;
    protected int DataSize { get; }
    public short Sid { get; }
    public short CategoryDataType { get; public set; }
    public short ValuesDataType { get; public set; }
    public short NumCategories { get; public set; }
    public short NumValues { get; public set; }
    public short BubbleSeriesType { get; public set; }
    public short NumBubbleValues { get; public set; }
    public SeriesRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_CategoryDataType();
    public void set_CategoryDataType(short value);
    public short get_ValuesDataType();
    public void set_ValuesDataType(short value);
    public short get_NumCategories();
    public void set_NumCategories(short value);
    public short get_NumValues();
    public void set_NumValues(short value);
    public short get_BubbleSeriesType();
    public void set_BubbleSeriesType(short value);
    public short get_NumBubbleValues();
    public void set_NumBubbleValues(short value);
}
public class NPOI.HSSF.Record.Chart.SeriesTextRecord : StandardRecord {
    private static int MAX_LEN;
    public static short sid;
    private short field_1_id;
    private bool is16bit;
    private string field_4_text;
    protected int DataSize { get; }
    public short Sid { get; }
    public short Id { get; public set; }
    public string Text { get; public set; }
    public SeriesTextRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_Id();
    public void set_Id(short value);
    public string get_Text();
    public void set_Text(string value);
}
[ObsoleteAttribute("duplication record, see SerToCrtRecord")]
public class NPOI.HSSF.Record.Chart.SeriesToChartGroupRecord : StandardRecord {
    public static short sid;
    private short field_1_chartGroupIndex;
    protected int DataSize { get; }
    public short Sid { get; }
    public short ChartGroupIndex { get; public set; }
    public SeriesToChartGroupRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_ChartGroupIndex();
    public void set_ChartGroupIndex(short value);
}
public class NPOI.HSSF.Record.Chart.SerParentRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public SerParentRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.SerToCrtRecord : StandardRecord {
    public static short sid;
    private short field_1_chartGroupIndex;
    protected int DataSize { get; }
    public short Sid { get; }
    public short ChartGroupIndex { get; public set; }
    public SerToCrtRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_ChartGroupIndex();
    public void set_ChartGroupIndex(short value);
}
public class NPOI.HSSF.Record.Chart.ShapePropsStreamRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public ShapePropsStreamRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.ShtPropsRecord : StandardRecord {
    public static short sid;
    private short field_1_flags;
    private BitField manSerAlloc;
    private BitField plotVisibleOnly;
    private BitField doNotSizeWithWindow;
    private BitField manPlotArea;
    private BitField alwaysAutoPlotArea;
    private byte field_2_mdBlank;
    private byte field_3_reserved;
    public static byte EMPTY_NOT_PLOTTED;
    public static byte EMPTY_ZERO;
    public static byte EMPTY_INTERPOLATED;
    protected int DataSize { get; }
    public short Sid { get; }
    public short Flags { get; public set; }
    public byte Blank { get; public set; }
    public bool IsManSerAlloc { get; public set; }
    public bool IsPlotVisibleOnly { get; public set; }
    public bool IsNotSizeWithWindow { get; public set; }
    public bool IsManPlotArea { get; public set; }
    public bool IsAlwaysAutoPlotArea { get; public set; }
    public ShtPropsRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_Flags();
    public void set_Flags(short value);
    public byte get_Blank();
    public void set_Blank(byte value);
    public bool get_IsManSerAlloc();
    public void set_IsManSerAlloc(bool value);
    public bool get_IsPlotVisibleOnly();
    public void set_IsPlotVisibleOnly(bool value);
    public bool get_IsNotSizeWithWindow();
    public void set_IsNotSizeWithWindow(bool value);
    public bool get_IsManPlotArea();
    public void set_IsManPlotArea(bool value);
    public bool get_IsAlwaysAutoPlotArea();
    public void set_IsAlwaysAutoPlotArea(bool value);
}
public class NPOI.HSSF.Record.Chart.StartBlockRecord : StandardRecord {
    public static short sid;
    private short rt;
    private short grbitFrt;
    [CompilerGeneratedAttribute]
private ObjectKind <ObjectKind>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ObjectContext>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ObjectInstance1>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ObjectInstance2>k__BackingField;
    public ObjectKind ObjectKind { get; public set; }
    public short ObjectContext { get; public set; }
    public short ObjectInstance1 { get; public set; }
    public short ObjectInstance2 { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public StartBlockRecord(RecordInputStream in1);
    private static StartBlockRecord();
    [CompilerGeneratedAttribute]
public ObjectKind get_ObjectKind();
    [CompilerGeneratedAttribute]
public void set_ObjectKind(ObjectKind value);
    [CompilerGeneratedAttribute]
public short get_ObjectContext();
    [CompilerGeneratedAttribute]
public void set_ObjectContext(short value);
    [CompilerGeneratedAttribute]
public short get_ObjectInstance1();
    [CompilerGeneratedAttribute]
public void set_ObjectInstance1(short value);
    [CompilerGeneratedAttribute]
public short get_ObjectInstance2();
    [CompilerGeneratedAttribute]
public void set_ObjectInstance2(short value);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
    public virtual object Clone();
    public static StartBlockRecord CreateStartBlock(ObjectKind objectKind);
    public static StartBlockRecord CreateStartBlock(ObjectKind objectKind, short objectContext);
    public static StartBlockRecord CreateStartBlock(ObjectKind objectKind, short objectContext, short objectInstance1);
    public static StartBlockRecord CreateStartBlock(ObjectKind objectKind, short objectContext, short objectInstance1, short objectInstance2);
}
public class NPOI.HSSF.Record.Chart.SurfRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public SurfRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public enum NPOI.HSSF.Record.Chart.TextFormatInfo : Enum {
    public short value__;
    public static TextFormatInfo ShowPercentOrValueNotSet;
    public static TextFormatInfo ShowPercentOrValueSet;
    public static TextFormatInfo FontScaleNotSet;
    public static TextFormatInfo FontScaleSet;
}
public class NPOI.HSSF.Record.Chart.TextPropsStreamRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public TextPropsStreamRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Chart.ValueRangeRecord : StandardRecord {
    public static short sid;
    private double field_1_minimumAxisValue;
    private double field_2_maximumAxisValue;
    private double field_3_majorIncrement;
    private double field_4_minorIncrement;
    private double field_5_categoryAxisCross;
    private short field_6_options;
    private BitField automaticMinimum;
    private BitField automaticMaximum;
    private BitField automaticMajor;
    private BitField automaticMinor;
    private BitField automaticCategoryCrossing;
    private BitField logarithmicScale;
    private BitField valuesInReverse;
    private BitField crossCategoryAxisAtMaximum;
    private BitField reserved;
    protected int DataSize { get; }
    public short Sid { get; }
    public double MinimumAxisValue { get; public set; }
    public double MaximumAxisValue { get; public set; }
    public double MajorIncrement { get; public set; }
    public double MinorIncrement { get; public set; }
    public double CategoryAxisCross { get; public set; }
    public short Options { get; public set; }
    public bool IsAutomaticMinimum { get; public set; }
    public bool IsAutomaticMaximum { get; public set; }
    public bool IsAutomaticMajor { get; public set; }
    public bool IsAutomaticMinor { get; public set; }
    public bool IsAutomaticCategoryCrossing { get; public set; }
    public bool IsLogarithmicScale { get; public set; }
    public bool IsValuesInReverse { get; public set; }
    public bool IsCrossCategoryAxisAtMaximum { get; public set; }
    public bool IsReserved { get; public set; }
    public ValueRangeRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public double get_MinimumAxisValue();
    public void set_MinimumAxisValue(double value);
    public double get_MaximumAxisValue();
    public void set_MaximumAxisValue(double value);
    public double get_MajorIncrement();
    public void set_MajorIncrement(double value);
    public double get_MinorIncrement();
    public void set_MinorIncrement(double value);
    public double get_CategoryAxisCross();
    public void set_CategoryAxisCross(double value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_IsAutomaticMinimum();
    public void set_IsAutomaticMinimum(bool value);
    public bool get_IsAutomaticMaximum();
    public void set_IsAutomaticMaximum(bool value);
    public bool get_IsAutomaticMajor();
    public void set_IsAutomaticMajor(bool value);
    public bool get_IsAutomaticMinor();
    public void set_IsAutomaticMinor(bool value);
    public bool get_IsAutomaticCategoryCrossing();
    public void set_IsAutomaticCategoryCrossing(bool value);
    public bool get_IsLogarithmicScale();
    public void set_IsLogarithmicScale(bool value);
    public bool get_IsValuesInReverse();
    public void set_IsValuesInReverse(bool value);
    public bool get_IsCrossCategoryAxisAtMaximum();
    public void set_IsCrossCategoryAxisAtMaximum(bool value);
    public bool get_IsReserved();
    public void set_IsReserved(bool value);
}
public class NPOI.HSSF.Record.Chart.YMultRecord : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public YMultRecord(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.ChartFormatRecord : StandardRecord {
    public static short sid;
    private int field1_x_position;
    private int field2_y_position;
    private int field3_width;
    private int field4_height;
    private short field5_grbit;
    private BitField varyDisplayPattern;
    private short field6_icrt;
    protected int DataSize { get; }
    public short Sid { get; }
    public int XPosition { get; public set; }
    public int YPosition { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public short Icrt { get; public set; }
    public bool VaryDisplayPattern { get; public set; }
    public ChartFormatRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual object Clone();
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public int get_XPosition();
    public void set_XPosition(int value);
    public int get_YPosition();
    public void set_YPosition(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public short get_Icrt();
    public void set_Icrt(short value);
    public bool get_VaryDisplayPattern();
    public void set_VaryDisplayPattern(bool value);
}
public class NPOI.HSSF.Record.CodepageRecord : StandardRecord {
    public static short sid;
    private short field_1_codepage;
    public static short CODEPAGE;
    public short Codepage { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public CodepageRecord(RecordInputStream in1);
    public short get_Codepage();
    public void set_Codepage(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.ColumnInfoRecord : StandardRecord {
    public static short sid;
    private int _first_col;
    private int _last_col;
    private int _col_width;
    private int _xf_index;
    private int _options;
    private static BitField hidden;
    private static BitField outlevel;
    private static BitField collapsed;
    private int field_6_reserved;
    public int FirstColumn { get; public set; }
    public int LastColumn { get; public set; }
    public int ColumnWidth { get; public set; }
    public int XFIndex { get; public set; }
    public int Options { get; public set; }
    public bool IsHidden { get; public set; }
    public int OutlineLevel { get; public set; }
    public bool IsCollapsed { get; public set; }
    public short Sid { get; }
    protected int DataSize { get; }
    public ColumnInfoRecord(RecordInputStream in1);
    private static ColumnInfoRecord();
    public bool FormatMatches(ColumnInfoRecord other);
    public int get_FirstColumn();
    public void set_FirstColumn(int value);
    public int get_LastColumn();
    public void set_LastColumn(int value);
    public int get_ColumnWidth();
    public void set_ColumnWidth(int value);
    public int get_XFIndex();
    public void set_XFIndex(int value);
    public int get_Options();
    public void set_Options(int value);
    public bool get_IsHidden();
    public void set_IsHidden(bool value);
    public int get_OutlineLevel();
    public void set_OutlineLevel(int value);
    public bool get_IsCollapsed();
    public void set_IsCollapsed(bool value);
    public virtual short get_Sid();
    public bool ContainsColumn(int columnIndex);
    public bool IsAdjacentBefore(ColumnInfoRecord other);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.Common.ExtendedColor : object {
    public static int TYPE_AUTO;
    public static int TYPE_INDEXED;
    public static int TYPE_RGB;
    public static int TYPE_THEMED;
    public static int TYPE_UNSET;
    public static int THEME_DARK_1;
    public static int THEME_LIGHT_1;
    public static int THEME_DARK_2;
    public static int THEME_LIGHT_2;
    public static int THEME_ACCENT_1;
    public static int THEME_ACCENT_2;
    public static int THEME_ACCENT_3;
    public static int THEME_ACCENT_4;
    public static int THEME_ACCENT_5;
    public static int THEME_ACCENT_6;
    public static int THEME_HYPERLINK;
    public static int THEME_FOLLOWED_HYPERLINK;
    public int type;
    public int colorIndex;
    public Byte[] rgba;
    public int themeIndex;
    private double tint;
    public int Type { get; public set; }
    public int ColorIndex { get; public set; }
    public Byte[] RGBA { get; public set; }
    public int ThemeIndex { get; public set; }
    public double Tint { get; public set; }
    public int DataLength { get; }
    public ExtendedColor(ILittleEndianInput in1);
    private static ExtendedColor();
    public int get_Type();
    public void set_Type(int value);
    public int get_ColorIndex();
    public void set_ColorIndex(int value);
    public Byte[] get_RGBA();
    public void set_RGBA(Byte[] value);
    public int get_ThemeIndex();
    public void set_ThemeIndex(int value);
    public double get_Tint();
    public void set_Tint(double value);
    public virtual string ToString();
    public sealed virtual object Clone();
    public int get_DataLength();
    public void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.Common.FeatFormulaErr2 : object {
    private static BitField CHECK_CALCULATION_ERRORS;
    private static BitField CHECK_EMPTY_CELL_REF;
    private static BitField CHECK_NUMBERS_AS_TEXT;
    private static BitField CHECK_INCONSISTENT_RANGES;
    private static BitField CHECK_INCONSISTENT_FORMULAS;
    private static BitField CHECK_DATETIME_FORMATS;
    private static BitField CHECK_UNPROTECTED_FORMULAS;
    private static BitField PERFORM_DATA_VALIDATION;
    private int errorCheck;
    public int DataSize { get; }
    public int RawErrorCheckValue { get; }
    public bool CheckCalculationErrors { get; public set; }
    public bool CheckEmptyCellRef { get; public set; }
    public bool CheckNumbersAsText { get; public set; }
    public bool CheckInconsistentRanges { get; public set; }
    public bool CheckInconsistentFormulas { get; public set; }
    public bool CheckDateTimeFormats { get; public set; }
    public bool CheckUnprotectedFormulas { get; public set; }
    public bool PerformDataValidation { get; public set; }
    public FeatFormulaErr2(RecordInputStream in1);
    private static FeatFormulaErr2();
    public virtual string ToString();
    public sealed virtual void Serialize(ILittleEndianOutput out1);
    public sealed virtual int get_DataSize();
    public int get_RawErrorCheckValue();
    public bool get_CheckCalculationErrors();
    public void set_CheckCalculationErrors(bool value);
    public bool get_CheckEmptyCellRef();
    public void set_CheckEmptyCellRef(bool value);
    public bool get_CheckNumbersAsText();
    public void set_CheckNumbersAsText(bool value);
    public bool get_CheckInconsistentRanges();
    public void set_CheckInconsistentRanges(bool value);
    public bool get_CheckInconsistentFormulas();
    public void set_CheckInconsistentFormulas(bool value);
    public bool get_CheckDateTimeFormats();
    public void set_CheckDateTimeFormats(bool value);
    public bool get_CheckUnprotectedFormulas();
    public void set_CheckUnprotectedFormulas(bool value);
    public bool get_PerformDataValidation();
    public void set_PerformDataValidation(bool value);
}
public class NPOI.HSSF.Record.Common.FeatProtection : object {
    public static long NO_SELF_RELATIVE_SECURITY_FEATURE;
    public static long HAS_SELF_RELATIVE_SECURITY_FEATURE;
    private int fSD;
    private int passwordVerifier;
    private string title;
    private Byte[] securityDescriptor;
    public int DataSize { get; }
    public FeatProtection(RecordInputStream in1);
    public virtual string ToString();
    public sealed virtual void Serialize(ILittleEndianOutput out1);
    public sealed virtual int get_DataSize();
    public int GetPasswordVerifier();
    public void SetPasswordVerifier(int passwordVerifier);
    public string GetTitle();
    public void SetTitle(string title);
    public int GetFSD();
}
public class NPOI.HSSF.Record.Common.FeatSmartTag : object {
    private Byte[] data;
    public int DataSize { get; }
    public FeatSmartTag(RecordInputStream in1);
    public virtual string ToString();
    public sealed virtual int get_DataSize();
    public sealed virtual void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.Common.FtrHeader : object {
    private short recordType;
    private short grbitFrt;
    private CellRangeAddress associatedRange;
    public short RecordType { get; public set; }
    public short GrbitFrt { get; public set; }
    public CellRangeAddress AssociatedRange { get; public set; }
    public FtrHeader(RecordInputStream in1);
    public virtual string ToString();
    public void Serialize(ILittleEndianOutput out1);
    public static int GetDataSize();
    public short get_RecordType();
    public void set_RecordType(short value);
    public short get_GrbitFrt();
    public void set_GrbitFrt(short value);
    public CellRangeAddress get_AssociatedRange();
    public void set_AssociatedRange(CellRangeAddress value);
    public sealed virtual object Clone();
}
public interface NPOI.HSSF.Record.Common.IFutureRecord {
    public abstract virtual short GetFutureRecordType();
    public abstract virtual FtrHeader GetFutureHeader();
    public abstract virtual CellRangeAddress GetAssociatedRange();
}
public interface NPOI.HSSF.Record.Common.SharedFeature {
    public int DataSize { get; }
    public abstract virtual string ToString();
    public abstract virtual void Serialize(ILittleEndianOutput out1);
    public abstract virtual int get_DataSize();
}
public class NPOI.HSSF.Record.CommonObjectDataSubRecord : SubRecord {
    public static short sid;
    private short field_1_objectType;
    private int field_2_objectId;
    private short field_3_option;
    private BitField locked;
    private BitField printable;
    private BitField autoFill;
    private BitField autoline;
    private int field_4_reserved1;
    private int field_5_reserved2;
    private int field_6_reserved3;
    public int DataSize { get; }
    public short Sid { get; }
    public CommonObjectType ObjectType { get; public set; }
    public int ObjectId { get; public set; }
    public short Option { get; public set; }
    public int Reserved1 { get; public set; }
    public int Reserved2 { get; public set; }
    public int Reserved3 { get; public set; }
    public bool IsLocked { get; public set; }
    public bool IsPrintable { get; public set; }
    public bool IsAutoFill { get; public set; }
    public bool IsAutoline { get; public set; }
    public CommonObjectDataSubRecord(ILittleEndianInput in1, int size);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public CommonObjectType get_ObjectType();
    public void set_ObjectType(CommonObjectType value);
    public int get_ObjectId();
    public void set_ObjectId(int value);
    public short get_Option();
    public void set_Option(short value);
    public int get_Reserved1();
    public void set_Reserved1(int value);
    public int get_Reserved2();
    public void set_Reserved2(int value);
    public int get_Reserved3();
    public void set_Reserved3(int value);
    public bool get_IsLocked();
    public void set_IsLocked(bool value);
    public bool get_IsPrintable();
    public void set_IsPrintable(bool value);
    public bool get_IsAutoFill();
    public void set_IsAutoFill(bool value);
    public bool get_IsAutoline();
    public void set_IsAutoline(bool value);
}
public enum NPOI.HSSF.Record.CommonObjectType : Enum {
    public short value__;
    public static CommonObjectType Group;
    public static CommonObjectType Line;
    public static CommonObjectType Rectangle;
    public static CommonObjectType Oval;
    public static CommonObjectType Arc;
    public static CommonObjectType Chart;
    public static CommonObjectType Text;
    public static CommonObjectType Button;
    public static CommonObjectType Picture;
    public static CommonObjectType Polygon;
    public static CommonObjectType Reserved1;
    public static CommonObjectType Checkbox;
    public static CommonObjectType OptionButton;
    public static CommonObjectType EditBox;
    public static CommonObjectType Label;
    public static CommonObjectType DialogBox;
    public static CommonObjectType Spinner;
    public static CommonObjectType ScrollBar;
    public static CommonObjectType ListBox;
    public static CommonObjectType GroupBox;
    public static CommonObjectType ComboBox;
    public static CommonObjectType Reserved2;
    public static CommonObjectType Reserved3;
    public static CommonObjectType Reserved4;
    public static CommonObjectType Reserved5;
    public static CommonObjectType Comment;
    public static CommonObjectType Reserved6;
    public static CommonObjectType Reserved7;
    public static CommonObjectType Reserved8;
    public static CommonObjectType Reserved9;
    public static CommonObjectType MicrosoftOfficeDrawing;
}
public abstract class NPOI.HSSF.Record.Cont.ContinuableRecord : Record {
    public int RecordSize { get; }
    protected abstract virtual void Serialize(ContinuableRecordOutput out1);
    public virtual int get_RecordSize();
    public virtual int Serialize(int offset, Byte[] data);
}
public class NPOI.HSSF.Record.Cont.ContinuableRecordInput : object {
    private RecordInputStream _in;
    public ContinuableRecordInput(RecordInputStream in1);
    public sealed virtual int Available();
    public sealed virtual int ReadByte();
    public sealed virtual int ReadUByte();
    public sealed virtual short ReadShort();
    public sealed virtual int ReadUShort();
    public sealed virtual int ReadInt();
    public sealed virtual long ReadLong();
    public sealed virtual double ReadDouble();
    public sealed virtual void ReadFully(Byte[] buf);
    public sealed virtual void ReadFully(Byte[] buf, int off, int len);
}
public class NPOI.HSSF.Record.Cont.ContinuableRecordOutput : object {
    private ILittleEndianOutput _out;
    private UnknownLengthRecordOutput _ulrOutput;
    private int _totalPreviousRecordsSize;
    private static ILittleEndianOutput NOPOutput;
    public int TotalSize { get; }
    public int AvailableSpace { get; }
    internal ContinuableRecordOutput(ILittleEndianOutput out1, int sid);
    private static ContinuableRecordOutput();
    public static ContinuableRecordOutput CreateForCountingOnly();
    public int get_TotalSize();
    public void Terminate();
    public int get_AvailableSpace();
    public void WriteContinue();
    public void WriteContinueIfRequired(int requiredContinuousSize);
    public void WriteStringData(string text);
    public void WriteString(string text, int numberOfRichTextRuns, int extendedDataSize);
    private void WriteCharacterData(string text, bool is16bitEncoded);
    public sealed virtual void Write(Byte[] b);
    public sealed virtual void Write(Byte[] b, int offset, int len);
    public sealed virtual void WriteByte(int v);
    public sealed virtual void WriteDouble(double v);
    public sealed virtual void WriteInt(int v);
    public sealed virtual void WriteLong(long v);
    public sealed virtual void WriteShort(int v);
}
internal class NPOI.HSSF.Record.Cont.UnknownLengthRecordOutput : object {
    private static int MAX_DATA_SIZE;
    private ILittleEndianOutput _originalOut;
    private ILittleEndianOutput _dataSizeOutput;
    private Byte[] _byteBuffer;
    private ILittleEndianOutput _out;
    private int _size;
    public int TotalSize { get; }
    public int AvailableSpace { get; }
    public UnknownLengthRecordOutput(ILittleEndianOutput out1, int sid);
    public int get_TotalSize();
    public int get_AvailableSpace();
    public void Terminate();
    public sealed virtual void Write(Byte[] b);
    public sealed virtual void Write(Byte[] b, int offset, int len);
    public sealed virtual void WriteByte(int v);
    public sealed virtual void WriteDouble(double v);
    public sealed virtual void WriteInt(int v);
    public sealed virtual void WriteLong(long v);
    public sealed virtual void WriteShort(int v);
}
public class NPOI.HSSF.Record.ContinueFrt12Record : RowDataRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public ContinueFrt12Record(RecordInputStream ris);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.ContinueRecord : StandardRecord {
    public static short sid;
    private Byte[] field_1_data;
    protected int DataSize { get; }
    public Byte[] Data { get; public set; }
    public short Sid { get; }
    public ContinueRecord(Byte[] data);
    public ContinueRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    [ObsoleteAttribute]
public static int Write(Byte[] destBuf, int destOffset, Nullable`1<byte> initialDataByte, Byte[] srcData);
    [ObsoleteAttribute]
public static int Write(Byte[] destBuf, int destOffset, Nullable`1<byte> initialDataByte, Byte[] srcData, int srcOffset, int len);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual string ToString();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.CountryRecord : StandardRecord {
    public static short sid;
    private short field_1_default_country;
    private short field_2_current_country;
    public short DefaultCountry { get; public set; }
    public short CurrentCountry { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public CountryRecord(RecordInputStream in1);
    public short get_DefaultCountry();
    public void set_DefaultCountry(short value);
    public short get_CurrentCountry();
    public void set_CurrentCountry(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.CRNCountRecord : StandardRecord {
    public static short sid;
    private static short DATA_SIZE;
    private int field_1_number_crn_records;
    private int field_2_sheet_table_index;
    public int NumberOfCRNs { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public CRNCountRecord(RecordInputStream in1);
    public int get_NumberOfCRNs();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.CRNRecord : StandardRecord {
    public static short sid;
    private int field_1_last_column_index;
    private int field_2_first_column_index;
    private int field_3_row_index;
    private Object[] field_4_constant_values;
    public int NumberOfCRNs { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public CRNRecord(RecordInputStream in1);
    public int get_NumberOfCRNs();
    public virtual string ToString();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.Crypto.Biff8DecryptingStream : object {
    private ILittleEndianInput _le;
    private Biff8RC4 _rc4;
    public Biff8DecryptingStream(Stream in1, int InitialOffSet, Biff8EncryptionKey key);
    public sealed virtual int Available();
    public sealed virtual int ReadRecordSID();
    public sealed virtual int ReadDataSize();
    public sealed virtual double ReadDouble();
    public sealed virtual void ReadFully(Byte[] buf);
    public sealed virtual void ReadFully(Byte[] buf, int off, int len);
    public sealed virtual int ReadUByte();
    public sealed virtual int ReadByte();
    public sealed virtual int ReadUShort();
    public sealed virtual short ReadShort();
    public sealed virtual int ReadInt();
    public sealed virtual long ReadLong();
}
public class NPOI.HSSF.Record.Crypto.Biff8EncryptionKey : object {
    private static int KEY_DIGEST_LENGTH;
    private static int PASSWORD_HASH_NUMBER_OF_BYTES_USED;
    private Byte[] _keyDigest;
    [ThreadStaticAttribute]
private static string _userPasswordTLS;
    public static string CurrentUserPassword { get; public set; }
    internal Biff8EncryptionKey(Byte[] keyDigest);
    public static Biff8EncryptionKey Create(Byte[] docId);
    public static Biff8EncryptionKey Create(string password, Byte[] docIdData);
    internal static Byte[] CreateKeyDigest(string password, Byte[] docIdData);
    public bool Validate(Byte[] saltData, Byte[] saltHash);
    private static Byte[] xor(Byte[] a, Byte[] b);
    private static void Check16Bytes(Byte[] data, string argName);
    internal RC4 CreateRC4(int keyBlockNo);
    public static string get_CurrentUserPassword();
    public static void set_CurrentUserPassword(string value);
}
public class NPOI.HSSF.Record.Crypto.Biff8RC4 : object {
    private static int RC4_REKEYING_INTERVAL;
    private RC4 _rc4;
    private int _streamPos;
    private int _nextRC4BlockStart;
    private int _currentKeyIndex;
    private bool _shouldSkipEncryptionOnCurrentRecord;
    private Biff8EncryptionKey _key;
    public Biff8RC4(int InitialOffset, Biff8EncryptionKey key);
    private void RekeyForNextBlock();
    private int GetNextRC4Byte();
    public void StartRecord(int currentSid);
    private static bool IsNeverEncryptedRecord(int sid);
    public void SkipTwoBytes();
    public void Xor(Byte[] buf, int pOffSet, int pLen);
    public int XorByte(int rawVal);
    public int Xorshort(int rawVal);
    public int XorInt(int rawVal);
    public long XorLong(long rawVal);
}
internal class NPOI.HSSF.Record.Crypto.RC4 : object {
    private int _i;
    private int _j;
    private Byte[] _s;
    public RC4(Byte[] key);
    public byte Output();
    public void Encrypt(Byte[] in1);
    public void Encrypt(Byte[] in1, int OffSet, int len);
    public virtual string ToString();
}
[ObsoleteAttribute("Not found in poi,is it useful?")]
public interface NPOI.HSSF.Record.CustomField {
    public int Size { get; }
    public abstract virtual int get_Size();
    public abstract virtual int FillField(RecordInputStream in1);
    public abstract virtual void ToString(StringBuilder str);
    public abstract virtual int SerializeField(int offset, Byte[] data);
}
public class NPOI.HSSF.Record.DateWindow1904Record : StandardRecord {
    public static short sid;
    private short field_1_window;
    public short Windowing { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public DateWindow1904Record(RecordInputStream in1);
    public short get_Windowing();
    public void set_Windowing(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.DBCellRecord : StandardRecord {
    public static int BLOCK_SIZE;
    public static short sid;
    private int field_1_row_offset;
    private Int16[] field_2_cell_offsets;
    public int RowOffset { get; public set; }
    public int NumCellOffsets { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public DBCellRecord(RecordInputStream in1);
    public DBCellRecord(int rowOffset, Int16[] cellOffsets);
    public void AddCellOffset(short offset);
    public int get_RowOffset();
    public void set_RowOffset(int value);
    public short GetCellOffsetAt(int index);
    public int get_NumCellOffsets();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public static int CalculateSizeOfRecords(int nBlocks, int nRows);
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.DConRefRecord : StandardRecord {
    public static short sid;
    private int firstRow;
    private int lastRow;
    private int firstCol;
    private int lastCol;
    private int charCount;
    private int charType;
    private Byte[] path;
    private Byte[] _unused;
    protected int DataSize { get; }
    public short Sid { get; }
    public int FirstColumn { get; }
    public int FirstRow { get; }
    public int LastColumn { get; }
    public int LastRow { get; }
    public string ReadablePath { get; }
    public bool IsExternalRef { get; }
    public DConRefRecord(Byte[] data);
    public DConRefRecord(RecordInputStream inStream);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public int get_FirstColumn();
    public int get_FirstRow();
    public int get_LastColumn();
    public int get_LastRow();
    public virtual string ToString();
    public Byte[] GetPath();
    public string get_ReadablePath();
    public bool get_IsExternalRef();
}
public class NPOI.HSSF.Record.DefaultColWidthRecord : StandardRecord {
    public static short sid;
    private int field_1_col_width;
    public static int DEFAULT_COLUMN_WIDTH;
    internal int offsetForFilePointer;
    public int ColWidth { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public DefaultColWidthRecord(RecordInputStream in1);
    public int get_ColWidth();
    public void set_ColWidth(int value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.DefaultRowHeightRecord : StandardRecord {
    public static short sid;
    private short field_1_option_flags;
    private short field_2_row_height;
    public static short DEFAULT_ROW_HEIGHT;
    internal short OptionFlags { get; internal set; }
    public short RowHeight { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public DefaultRowHeightRecord(RecordInputStream in1);
    internal short get_OptionFlags();
    internal void set_OptionFlags(short value);
    public short get_RowHeight();
    public void set_RowHeight(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.DeltaRecord : StandardRecord {
    public static short sid;
    public static double DEFAULT_VALUE;
    private double field_1_max_change;
    public double MaxChange { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public DeltaRecord(double maxChange);
    public DeltaRecord(RecordInputStream in1);
    public double get_MaxChange();
    public void set_MaxChange(double value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.DimensionsRecord : StandardRecord {
    public static short sid;
    private int field_1_first_row;
    private int field_2_last_row;
    private int field_3_first_col;
    private int field_4_last_col;
    private short field_5_zero;
    public int FirstRow { get; public set; }
    public int LastRow { get; public set; }
    public int FirstCol { get; public set; }
    public int LastCol { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public DimensionsRecord(RecordInputStream in1);
    public int get_FirstRow();
    public void set_FirstRow(int value);
    public int get_LastRow();
    public void set_LastRow(int value);
    public int get_FirstCol();
    public void set_FirstCol(int value);
    public int get_LastCol();
    public void set_LastCol(int value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.Drawing.OfficeArtFOPT : object {
    private OfficeArtRecordHeader _rh;
    private List`1<OfficeArtFOPTE> _fopt;
    private Dictionary`2<int, OfficeArtFOPTE> dictOptions;
    public int DataSize { get; }
    public OfficeArtFOPT(RecordInputStream ris);
    public OfficeArtFOPTE GetFillOptionElement(int opid);
    public int get_DataSize();
    public void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.Drawing.OfficeArtFOPTE : object {
    private Byte[] complexData;
    [CompilerGeneratedAttribute]
private OfficeArtFOPTEOPID <Opid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Op>k__BackingField;
    public int DataSize { get; }
    public OfficeArtFOPTEOPID Opid { get; public set; }
    public int Op { get; public set; }
    public Byte[] ComplexData { get; }
    public OfficeArtFOPTE(RecordInputStream ris);
    public int get_DataSize();
    public void Serialize(ILittleEndianOutput out1);
    [CompilerGeneratedAttribute]
public OfficeArtFOPTEOPID get_Opid();
    [CompilerGeneratedAttribute]
public void set_Opid(OfficeArtFOPTEOPID value);
    [CompilerGeneratedAttribute]
public int get_Op();
    [CompilerGeneratedAttribute]
public void set_Op(int value);
    public Byte[] get_ComplexData();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.Drawing.OfficeArtFOPTEOPID : object {
    protected ushort field_opid;
    [CompilerGeneratedAttribute]
private ushort <OpId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBlipId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplex>k__BackingField;
    public ushort FieldOpid { get; }
    public ushort OpId { get; private set; }
    public bool IsBlipId { get; private set; }
    public bool IsComplex { get; private set; }
    public OfficeArtFOPTEOPID(ushort value);
    public ushort get_FieldOpid();
    [CompilerGeneratedAttribute]
public ushort get_OpId();
    [CompilerGeneratedAttribute]
private void set_OpId(ushort value);
    [CompilerGeneratedAttribute]
public bool get_IsBlipId();
    [CompilerGeneratedAttribute]
private void set_IsBlipId(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsComplex();
    [CompilerGeneratedAttribute]
private void set_IsComplex(bool value);
}
public class NPOI.HSSF.Record.Drawing.OfficeArtRecordHeader : object {
    private short field_1_recVer_Instance;
    private ushort field_2_recType;
    private int field_3_recLen;
    private BitField recVer;
    private BitField recInstance;
    public int DataSize { get; }
    public short Ver { get; public set; }
    public short Instance { get; public set; }
    public ushort Type { get; public set; }
    public int Len { get; public set; }
    public OfficeArtRecordHeader(RecordInputStream ris);
    public int get_DataSize();
    public void Serialize(ILittleEndianOutput out1);
    public short get_Ver();
    public void set_Ver(short value);
    public short get_Instance();
    public void set_Instance(short value);
    public ushort get_Type();
    public void set_Type(ushort value);
    public int get_Len();
    public void set_Len(int value);
}
public class NPOI.HSSF.Record.Drawing.OfficeArtTertiaryFOPT : OfficeArtFOPT {
    public OfficeArtTertiaryFOPT(RecordInputStream ris);
}
public class NPOI.HSSF.Record.DrawingGroupRecord : AbstractEscherHolderRecord {
    public static short sid;
    private static int MAX_RECORD_SIZE;
    private static int MAX_DATA_SIZE;
    protected string RecordName { get; }
    public short Sid { get; }
    public int RecordSize { get; }
    public int RawDataSize { get; }
    public DrawingGroupRecord(RecordInputStream in1);
    protected virtual string get_RecordName();
    public virtual short get_Sid();
    public virtual int Serialize(int offset, Byte[] data);
    public void ProcessChildRecords();
    public virtual int get_RecordSize();
    public int get_RawDataSize();
    public static int GrossSizeFromDataSize(int dataSize);
    private int WriteData(int offset, Byte[] data, Byte[] rawData);
    private void WriteHeader(Byte[] data, int offset, int sizeExcludingHeader);
    private void WriteContinueHeader(Byte[] data, int offset, int sizeExcludingHeader);
}
public class NPOI.HSSF.Record.DrawingRecord : StandardRecord {
    public static short sid;
    private static Byte[] EMPTY_BYTE_ARRAY;
    private Byte[] recordData;
    private Byte[] contd;
    protected int DataSize { get; }
    public short Sid { get; }
    public Byte[] RecordData { get; }
    public DrawingRecord(RecordInputStream in1);
    private static DrawingRecord();
    [ObsoleteAttribute]
public void ProcessContinueRecord(Byte[] record);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public Byte[] get_RecordData();
    public void SetData(Byte[] thedata);
    public virtual object Clone();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.DrawingRecordForBiffViewer : AbstractEscherHolderRecord {
    public static short sid;
    protected string RecordName { get; }
    public short Sid { get; }
    public DrawingRecordForBiffViewer(RecordInputStream in1);
    public DrawingRecordForBiffViewer(DrawingRecord r);
    private static RecordInputStream ConvertToInputStream(DrawingRecord r);
    protected virtual string get_RecordName();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.DrawingSelectionRecord : AbstractEscherHolderRecord {
    public static short sid;
    protected string RecordName { get; }
    public short Sid { get; }
    public DrawingSelectionRecord(RecordInputStream in1);
    protected virtual string get_RecordName();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.DSFRecord : StandardRecord {
    public static short sid;
    private int _options;
    private static BitField biff5BookStreamFlag;
    public bool IsBiff5BookStreamPresent { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    private DSFRecord(int options);
    public DSFRecord(bool isBiff5BookStreamPresent);
    public DSFRecord(RecordInputStream in1);
    private static DSFRecord();
    public bool get_IsBiff5BookStreamPresent();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.DVALRecord : StandardRecord {
    public static short sid;
    private short field_1_options;
    private int field_2_horiz_pos;
    private int field_3_vert_pos;
    private int field_cbo_id;
    private int field_5_dv_no;
    public short Options { get; public set; }
    public int HorizontalPos { get; public set; }
    public int VerticalPos { get; public set; }
    public int ObjectID { get; public set; }
    public int DVRecNo { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public DVALRecord(RecordInputStream in1);
    public short get_Options();
    public void set_Options(short value);
    public int get_HorizontalPos();
    public void set_HorizontalPos(int value);
    public int get_VerticalPos();
    public void set_VerticalPos(int value);
    public int get_ObjectID();
    public void set_ObjectID(int value);
    public int get_DVRecNo();
    public void set_DVRecNo(int value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.DVRecord : StandardRecord {
    private static UnicodeString NULL_TEXT_STRING;
    public static short sid;
    private int _option_flags;
    private UnicodeString _promptTitle;
    private UnicodeString _errorTitle;
    private UnicodeString _promptText;
    private UnicodeString _errorText;
    private short _not_used_1;
    private Formula _formula1;
    private short _not_used_2;
    private Formula _formula2;
    private CellRangeAddressList _regions;
    public static int STRING_PROMPT_TITLE;
    public static int STRING_ERROR_TITLE;
    public static int STRING_PROMPT_TEXT;
    public static int STRING_ERROR_TEXT;
    private BitField opt_data_type;
    private BitField opt_error_style;
    private BitField opt_string_list_formula;
    private BitField opt_empty_cell_allowed;
    private BitField opt_suppress_dropdown_arrow;
    private BitField opt_show_prompt_on_cell_selected;
    private BitField opt_show_error_on_invalid_value;
    private BitField opt_condition_operator;
    public int DataType { get; public set; }
    public int ErrorStyle { get; public set; }
    public bool ListExplicitFormula { get; public set; }
    public bool EmptyCellAllowed { get; public set; }
    public bool SuppressDropdownArrow { get; }
    public bool ShowPromptOnCellSelected { get; }
    public bool ShowErrorOnInvalidValue { get; public set; }
    public int ConditionOperator { get; public set; }
    public string PromptTitle { get; }
    public string ErrorTitle { get; }
    public string PromptText { get; }
    public string ErrorText { get; }
    public Ptg[] Formula1 { get; }
    public Ptg[] Formula2 { get; }
    public CellRangeAddressList CellRangeAddress { get; public set; }
    public int OptionFlags { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public DVRecord(int validationType, int operator1, int errorStyle, bool emptyCellAllowed, bool suppressDropDownArrow, bool isExplicitList, bool showPromptBox, string promptTitle, string promptText, bool showErrorBox, string errorTitle, string errorText, Ptg[] formula1, Ptg[] formula2, CellRangeAddressList regions);
    public DVRecord(RecordInputStream in1);
    private static DVRecord();
    private static UnicodeString ResolveTitleText(string str);
    private static string ResolveTitleString(UnicodeString us);
    private static UnicodeString ReadUnicodeString(RecordInputStream in1);
    public int get_DataType();
    public void set_DataType(int value);
    public virtual bool Equals(object obj);
    public int get_ErrorStyle();
    public void set_ErrorStyle(int value);
    public bool get_ListExplicitFormula();
    public void set_ListExplicitFormula(bool value);
    public bool get_EmptyCellAllowed();
    public void set_EmptyCellAllowed(bool value);
    public bool get_SuppressDropdownArrow();
    public bool get_ShowPromptOnCellSelected();
    public bool get_ShowErrorOnInvalidValue();
    public void set_ShowErrorOnInvalidValue(bool value);
    public int get_ConditionOperator();
    public void set_ConditionOperator(int value);
    public string get_PromptTitle();
    public string get_ErrorTitle();
    public string get_PromptText();
    public string get_ErrorText();
    public Ptg[] get_Formula1();
    public Ptg[] get_Formula2();
    public CellRangeAddressList get_CellRangeAddress();
    public void set_CellRangeAddress(CellRangeAddressList value);
    public int get_OptionFlags();
    public virtual string ToString();
    private static string FormatTextTitle(UnicodeString us);
    private static void AppendFormula(StringBuilder sb, string label, Formula f);
    public virtual void Serialize(ILittleEndianOutput out1);
    private static void SerializeUnicodeString(UnicodeString us, ILittleEndianOutput out1);
    private static int GetUnicodeStringSize(UnicodeString us);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.EmbeddedObjectRefSubRecord : SubRecord {
    private static POILogger logger;
    public static short sid;
    private static Byte[] EMPTY_BYTE_ARRAY;
    private int field_1_unknown_int;
    private Ptg field_2_refPtg;
    private Byte[] field_2_unknownFormulaData;
    public bool field_3_unicode_flag;
    private string field_4_ole_classname;
    private Nullable`1<byte> field_4_unknownByte;
    private Nullable`1<int> field_5_stream_id;
    private Byte[] field_6_unknown;
    public short Sid { get; }
    public int DataSize { get; }
    public Nullable`1<int> StreamId { get; }
    public string OLEClassName { get; public set; }
    public Byte[] ObjectData { get; public set; }
    public EmbeddedObjectRefSubRecord(ILittleEndianInput in1, int size);
    private static EmbeddedObjectRefSubRecord();
    public virtual short get_Sid();
    private static Ptg ReadRefPtg(Byte[] formulaRawBytes);
    private static Byte[] ReadRawData(ILittleEndianInput in1, int size);
    private int GetStreamIDOffset(int formulaSize);
    private int GetDataSize(int idOffset);
    public virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public Nullable`1<int> get_StreamId();
    public string get_OLEClassName();
    public void set_OLEClassName(string value);
    public Byte[] get_ObjectData();
    public void set_ObjectData(Byte[] value);
    public virtual string ToString();
    public virtual object Clone();
    public void SetUnknownFormulaData(Byte[] formularData);
    public void SetStorageId(int storageId);
}
public class NPOI.HSSF.Record.EndSubRecord : SubRecord {
    public static short sid;
    private static int ENCODED_SIZE;
    public bool IsTerminating { get; }
    public int DataSize { get; }
    public short Sid { get; }
    public EndSubRecord(ILittleEndianInput in1, int size);
    public virtual bool get_IsTerminating();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.EOFRecord : StandardRecord {
    public static short sid;
    public static int ENCODED_SIZE;
    public static EOFRecord instance;
    protected int DataSize { get; }
    public short Sid { get; }
    public EOFRecord(RecordInputStream in1);
    private static EOFRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.EscherAggregate : AbstractEscherHolderRecord {
    public static short sid;
    private static POILogger log;
    public static short ST_MIN;
    public static short ST_NOT_PRIMATIVE;
    public static short ST_RECTANGLE;
    public static short ST_ROUNDRECTANGLE;
    public static short ST_ELLIPSE;
    public static short ST_DIAMOND;
    public static short ST_ISOCELESTRIANGLE;
    public static short ST_RIGHTTRIANGLE;
    public static short ST_PARALLELOGRAM;
    public static short ST_TRAPEZOID;
    public static short ST_HEXAGON;
    public static short ST_OCTAGON;
    public static short ST_PLUS;
    public static short ST_STAR;
    public static short ST_ARROW;
    public static short ST_THICKARROW;
    public static short ST_HOMEPLATE;
    public static short ST_CUBE;
    public static short ST_BALLOON;
    public static short ST_SEAL;
    public static short ST_ARC;
    public static short ST_LINE;
    public static short ST_PLAQUE;
    public static short ST_CAN;
    public static short ST_DONUT;
    public static short ST_TEXTSIMPLE;
    public static short ST_TEXTOCTAGON;
    public static short ST_TEXTHEXAGON;
    public static short ST_TEXTCURVE;
    public static short ST_TEXTWAVE;
    public static short ST_TEXTRING;
    public static short ST_TEXTONCURVE;
    public static short ST_TEXTONRING;
    public static short ST_STRAIGHTCONNECTOR1;
    public static short ST_BENTCONNECTOR2;
    public static short ST_BENTCONNECTOR3;
    public static short ST_BENTCONNECTOR4;
    public static short ST_BENTCONNECTOR5;
    public static short ST_CURVEDCONNECTOR2;
    public static short ST_CURVEDCONNECTOR3;
    public static short ST_CURVEDCONNECTOR4;
    public static short ST_CURVEDCONNECTOR5;
    public static short ST_CALLOUT1;
    public static short ST_CALLOUT2;
    public static short ST_CALLOUT3;
    public static short ST_ACCENTCALLOUT1;
    public static short ST_ACCENTCALLOUT2;
    public static short ST_ACCENTCALLOUT3;
    public static short ST_BORDERCALLOUT1;
    public static short ST_BORDERCALLOUT2;
    public static short ST_BORDERCALLOUT3;
    public static short ST_ACCENTBORDERCALLOUT1;
    public static short ST_ACCENTBORDERCALLOUT2;
    public static short ST_ACCENTBORDERCALLOUT3;
    public static short ST_RIBBON;
    public static short ST_RIBBON2;
    public static short ST_CHEVRON;
    public static short ST_PENTAGON;
    public static short ST_NOSMOKING;
    public static short ST_SEAL8;
    public static short ST_SEAL16;
    public static short ST_SEAL32;
    public static short ST_WEDGERECTCALLOUT;
    public static short ST_WEDGERRECTCALLOUT;
    public static short ST_WEDGEELLIPSECALLOUT;
    public static short ST_WAVE;
    public static short ST_FOLDEDCORNER;
    public static short ST_LEFTARROW;
    public static short ST_DOWNARROW;
    public static short ST_UPARROW;
    public static short ST_LEFTRIGHTARROW;
    public static short ST_UPDOWNARROW;
    public static short ST_IRREGULARSEAL1;
    public static short ST_IRREGULARSEAL2;
    public static short ST_LIGHTNINGBOLT;
    public static short ST_HEART;
    public static short ST_PICTUREFRAME;
    public static short ST_QUADARROW;
    public static short ST_LEFTARROWCALLOUT;
    public static short ST_RIGHTARROWCALLOUT;
    public static short ST_UPARROWCALLOUT;
    public static short ST_DOWNARROWCALLOUT;
    public static short ST_LEFTRIGHTARROWCALLOUT;
    public static short ST_UPDOWNARROWCALLOUT;
    public static short ST_QUADARROWCALLOUT;
    public static short ST_BEVEL;
    public static short ST_LEFTBRACKET;
    public static short ST_RIGHTBRACKET;
    public static short ST_LEFTBRACE;
    public static short ST_RIGHTBRACE;
    public static short ST_LEFTUPARROW;
    public static short ST_BENTUPARROW;
    public static short ST_BENTARROW;
    public static short ST_SEAL24;
    public static short ST_STRIPEDRIGHTARROW;
    public static short ST_NOTCHEDRIGHTARROW;
    public static short ST_BLOCKARC;
    public static short ST_SMILEYFACE;
    public static short ST_VERTICALSCROLL;
    public static short ST_HORIZONTALSCROLL;
    public static short ST_CIRCULARARROW;
    public static short ST_NOTCHEDCIRCULARARROW;
    public static short ST_UTURNARROW;
    public static short ST_CURVEDRIGHTARROW;
    public static short ST_CURVEDLEFTARROW;
    public static short ST_CURVEDUPARROW;
    public static short ST_CURVEDDOWNARROW;
    public static short ST_CLOUDCALLOUT;
    public static short ST_ELLIPSERIBBON;
    public static short ST_ELLIPSERIBBON2;
    public static short ST_FLOWCHARTProcess;
    public static short ST_FLOWCHARTDECISION;
    public static short ST_FLOWCHARTINPUTOUTPUT;
    public static short ST_FLOWCHARTPREDEFINEDProcess;
    public static short ST_FLOWCHARTINTERNALSTORAGE;
    public static short ST_FLOWCHARTDOCUMENT;
    public static short ST_FLOWCHARTMULTIDOCUMENT;
    public static short ST_FLOWCHARTTERMINATOR;
    public static short ST_FLOWCHARTPREPARATION;
    public static short ST_FLOWCHARTMANUALINPUT;
    public static short ST_FLOWCHARTMANUALOPERATION;
    public static short ST_FLOWCHARTCONNECTOR;
    public static short ST_FLOWCHARTPUNCHEDCARD;
    public static short ST_FLOWCHARTPUNCHEDTAPE;
    public static short ST_FLOWCHARTSUMMINGJUNCTION;
    public static short ST_FLOWCHARTOR;
    public static short ST_FLOWCHARTCOLLATE;
    public static short ST_FLOWCHARTSORT;
    public static short ST_FLOWCHARTEXTRACT;
    public static short ST_FLOWCHARTMERGE;
    public static short ST_FLOWCHARTOFFLINESTORAGE;
    public static short ST_FLOWCHARTONLINESTORAGE;
    public static short ST_FLOWCHARTMAGNETICTAPE;
    public static short ST_FLOWCHARTMAGNETICDISK;
    public static short ST_FLOWCHARTMAGNETICDRUM;
    public static short ST_FLOWCHARTDISPLAY;
    public static short ST_FLOWCHARTDELAY;
    public static short ST_TEXTPLAINTEXT;
    public static short ST_TEXTSTOP;
    public static short ST_TEXTTRIANGLE;
    public static short ST_TEXTTRIANGLEINVERTED;
    public static short ST_TEXTCHEVRON;
    public static short ST_TEXTCHEVRONINVERTED;
    public static short ST_TEXTRINGINSIDE;
    public static short ST_TEXTRINGOUTSIDE;
    public static short ST_TEXTARCHUPCURVE;
    public static short ST_TEXTARCHDOWNCURVE;
    public static short ST_TEXTCIRCLECURVE;
    public static short ST_TEXTBUTTONCURVE;
    public static short ST_TEXTARCHUPPOUR;
    public static short ST_TEXTARCHDOWNPOUR;
    public static short ST_TEXTCIRCLEPOUR;
    public static short ST_TEXTBUTTONPOUR;
    public static short ST_TEXTCURVEUP;
    public static short ST_TEXTCURVEDOWN;
    public static short ST_TEXTCASCADEUP;
    public static short ST_TEXTCASCADEDOWN;
    public static short ST_TEXTWAVE1;
    public static short ST_TEXTWAVE2;
    public static short ST_TEXTWAVE3;
    public static short ST_TEXTWAVE4;
    public static short ST_TEXTINFLATE;
    public static short ST_TEXTDEFLATE;
    public static short ST_TEXTINFLATEBOTTOM;
    public static short ST_TEXTDEFLATEBOTTOM;
    public static short ST_TEXTINFLATETOP;
    public static short ST_TEXTDEFLATETOP;
    public static short ST_TEXTDEFLATEINFLATE;
    public static short ST_TEXTDEFLATEINFLATEDEFLATE;
    public static short ST_TEXTFADERIGHT;
    public static short ST_TEXTFADELEFT;
    public static short ST_TEXTFADEUP;
    public static short ST_TEXTFADEDOWN;
    public static short ST_TEXTSLANTUP;
    public static short ST_TEXTSLANTDOWN;
    public static short ST_TEXTCANUP;
    public static short ST_TEXTCANDOWN;
    public static short ST_FLOWCHARTALTERNATEProcess;
    public static short ST_FLOWCHARTOFFPAGECONNECTOR;
    public static short ST_CALLOUT90;
    public static short ST_ACCENTCALLOUT90;
    public static short ST_BORDERCALLOUT90;
    public static short ST_ACCENTBORDERCALLOUT90;
    public static short ST_LEFTRIGHTUPARROW;
    public static short ST_SUN;
    public static short ST_MOON;
    public static short ST_BRACKETPAIR;
    public static short ST_BRACEPAIR;
    public static short ST_SEAL4;
    public static short ST_DOUBLEWAVE;
    public static short ST_ACTIONBUTTONBLANK;
    public static short ST_ACTIONBUTTONHOME;
    public static short ST_ACTIONBUTTONHELP;
    public static short ST_ACTIONBUTTONINFORMATION;
    public static short ST_ACTIONBUTTONFORWARDNEXT;
    public static short ST_ACTIONBUTTONBACKPREVIOUS;
    public static short ST_ACTIONBUTTONEND;
    public static short ST_ACTIONBUTTONBEGINNING;
    public static short ST_ACTIONBUTTONRETURN;
    public static short ST_ACTIONBUTTONDOCUMENT;
    public static short ST_ACTIONBUTTONSOUND;
    public static short ST_ACTIONBUTTONMOVIE;
    public static short ST_HOSTCONTROL;
    public static short ST_TEXTBOX;
    public static short ST_NIL;
    protected HSSFPatriarch patriarch;
    private Dictionary`2<EscherRecord, Record> shapeToObj;
    private DrawingManager2 drawingManager;
    internal Dictionary`2<int, NoteRecord> tailRec;
    public short Sid { get; }
    public int RecordSize { get; }
    public HSSFPatriarch Patriarch { get; public set; }
    protected string RecordName { get; }
    public Dictionary`2<int, NoteRecord> TailRecords { get; }
    public EscherAggregate(bool createDefaultTree);
    public EscherAggregate(DrawingManager2 drawingManager);
    private static EscherAggregate();
    public virtual short get_Sid();
    public virtual string ToString();
    public string ToXml(string tab);
    private static bool IsDrawingLayerRecord(short sid);
    public static EscherAggregate CreateAggregate(List`1<RecordBase> records, int locFirstDrawingRecord);
    public virtual int Serialize(int offset, Byte[] data);
    private int WriteDataIntoDrawingRecord(Byte[] drawingData, int writtenEscherBytes, int pos, Byte[] data, int i);
    private int GetEscherRecordSize(List`1<EscherRecord> records);
    private static short GetSid(List`1<RecordBase> records, int loc);
    public virtual int get_RecordSize();
    private void BuildBaseTree();
    public IList Children(Byte[] data, short size, int offset);
    public HSSFPatriarch get_Patriarch();
    public void set_Patriarch(HSSFPatriarch value);
    private EscherRecord GetEscherChild(EscherContainerRecord owner, int recordId);
    public void Clear();
    protected virtual string get_RecordName();
    private static bool IsObjectRecord(List`1<RecordBase> records, int loc);
    public void AssociateShapeToObjRecord(EscherRecord r, Record objRecord);
    public void RemoveShapeToObjRecord(EscherRecord rec);
    internal void SetDgId(short dgId);
    internal void SetMainSpRecordId(int shapeId);
    public void RemoveTailRecord(NoteRecord note);
    internal void AddTailRecord(NoteRecord note);
    public Dictionary`2<int, NoteRecord> get_TailRecords();
    internal Dictionary`2<EscherRecord, Record> GetShapeToObjMapping();
    internal NoteRecord GetNoteRecordByObj(ObjRecord obj);
}
public class NPOI.HSSF.Record.Excel9FileRecord : StandardRecord {
    public static short sid;
    public short Sid { get; }
    protected int DataSize { get; }
    public Excel9FileRecord(RecordInputStream in1);
    public virtual short get_Sid();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.ExtendedFormatRecord : StandardRecord {
    public static short sid;
    public static short NULL;
    public static short XF_STYLE;
    public static short XF_CELL;
    public static short NONE;
    public static short THIN;
    public static short MEDIUM;
    public static short DASHED;
    public static short DOTTED;
    public static short THICK;
    public static short DOUBLE;
    public static short HAIR;
    public static short MEDIUM_DASHED;
    public static short DASH_DOT;
    public static short MEDIUM_DASH_DOT;
    public static short DASH_DOT_DOT;
    public static short MEDIUM_DASH_DOT_DOT;
    public static short SLANTED_DASH_DOT;
    public static short GENERAL;
    public static short LEFT;
    public static short CENTER;
    public static short RIGHT;
    public static short FILL;
    public static short JUSTIFY;
    public static short CENTER_SELECTION;
    public static short VERTICAL_TOP;
    public static short VERTICAL_CENTER;
    public static short VERTICAL_BOTTOM;
    public static short VERTICAL_JUSTIFY;
    public static short NO_FILL;
    public static short SOLID_FILL;
    public static short FINE_DOTS;
    public static short ALT_BARS;
    public static short SPARSE_DOTS;
    public static short THICK_HORZ_BANDS;
    public static short THICK_VERT_BANDS;
    public static short THICK_BACKWARD_DIAG;
    public static short THICK_FORWARD_DIAG;
    public static short BIG_SPOTS;
    public static short BRICKS;
    public static short THIN_HORZ_BANDS;
    public static short THIN_VERT_BANDS;
    public static short THIN_BACKWARD_DIAG;
    public static short THIN_FORWARD_DIAG;
    public static short SQUARES;
    public static short DIAMONDS;
    private short field_1_font_index;
    private short field_2_format_index;
    private static BitField _locked;
    private static BitField _hidden;
    private static BitField _xf_type;
    private static BitField _123_prefix;
    private static BitField _parent_index;
    private short field_3_cell_options;
    private static BitField _alignment;
    private static BitField _wrap_text;
    private static BitField _vertical_alignment;
    private static BitField _justify_last;
    private static BitField _rotation;
    private short field_4_alignment_options;
    private static BitField _indent;
    private static BitField _shrink_to_fit;
    private static BitField _merge_cells;
    private static BitField _Reading_order;
    private static BitField _indent_not_parent_format;
    private static BitField _indent_not_parent_font;
    private static BitField _indent_not_parent_alignment;
    private static BitField _indent_not_parent_border;
    private static BitField _indent_not_parent_pattern;
    private static BitField _indent_not_parent_cell_options;
    private short field_5_indention_options;
    private static BitField _border_left;
    private static BitField _border_right;
    private static BitField _border_top;
    private static BitField _border_bottom;
    private short field_6_border_options;
    private static BitField _left_border_palette_idx;
    private static BitField _right_border_palette_idx;
    private static BitField _diag;
    private short field_7_palette_options;
    private static BitField _top_border_palette_idx;
    private static BitField _bottom_border_palette_idx;
    private static BitField _adtl_diag_border_palette_idx;
    private static BitField _adtl_diag_line_style;
    private static BitField _adtl_fill_pattern;
    private int field_8_adtl_palette_options;
    private static BitField _fill_foreground;
    private static BitField _fill_background;
    private short field_9_fill_palette_options;
    public short FontIndex { get; public set; }
    public short FormatIndex { get; public set; }
    public short CellOptions { get; public set; }
    public bool IsLocked { get; public set; }
    public bool IsHidden { get; public set; }
    public short XFType { get; public set; }
    public bool _123Prefix { get; public set; }
    public short ParentIndex { get; public set; }
    public short AlignmentOptions { get; public set; }
    public short Alignment { get; public set; }
    public bool WrapText { get; public set; }
    public short VerticalAlignment { get; public set; }
    public short JustifyLast { get; public set; }
    public short Rotation { get; public set; }
    public short IndentionOptions { get; public set; }
    public short Indent { get; public set; }
    public bool ShrinkToFit { get; public set; }
    public bool MergeCells { get; public set; }
    public short ReadingOrder { get; public set; }
    public bool IsIndentNotParentFormat { get; public set; }
    public bool IsIndentNotParentFont { get; public set; }
    public bool IsIndentNotParentAlignment { get; public set; }
    public bool IsIndentNotParentBorder { get; public set; }
    public bool IsIndentNotParentPattern { get; public set; }
    public bool IsIndentNotParentCellOptions { get; public set; }
    public short BorderOptions { get; public set; }
    public short BorderLeft { get; public set; }
    public short BorderRight { get; public set; }
    public short BorderTop { get; public set; }
    public short BorderBottom { get; public set; }
    public short PaletteOptions { get; public set; }
    public short LeftBorderPaletteIdx { get; public set; }
    public short RightBorderPaletteIdx { get; public set; }
    public int AdtlPaletteOptions { get; public set; }
    public short TopBorderPaletteIdx { get; public set; }
    public short BottomBorderPaletteIdx { get; public set; }
    public short AdtlDiagBorderPaletteIdx { get; public set; }
    public short AdtlDiagLineStyle { get; public set; }
    public short Diagonal { get; public set; }
    public short AdtlFillPattern { get; public set; }
    public short FillPaletteOptions { get; public set; }
    public short FillForeground { get; public set; }
    public short FillBackground { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public Int32[] StateSummary { get; }
    public ExtendedFormatRecord(RecordInputStream in1);
    private static ExtendedFormatRecord();
    public void CloneStyleFrom(ExtendedFormatRecord source);
    public short get_FontIndex();
    public void set_FontIndex(short value);
    public short get_FormatIndex();
    public void set_FormatIndex(short value);
    public short get_CellOptions();
    public void set_CellOptions(short value);
    public bool get_IsLocked();
    public void set_IsLocked(bool value);
    public bool get_IsHidden();
    public void set_IsHidden(bool value);
    public short get_XFType();
    public void set_XFType(short value);
    public bool get__123Prefix();
    public void set__123Prefix(bool value);
    public short get_ParentIndex();
    public void set_ParentIndex(short value);
    public short get_AlignmentOptions();
    public void set_AlignmentOptions(short value);
    public short get_Alignment();
    public void set_Alignment(short value);
    public bool get_WrapText();
    public void set_WrapText(bool value);
    public short get_VerticalAlignment();
    public void set_VerticalAlignment(short value);
    public short get_JustifyLast();
    public void set_JustifyLast(short value);
    public short get_Rotation();
    public void set_Rotation(short value);
    public short get_IndentionOptions();
    public void set_IndentionOptions(short value);
    public short get_Indent();
    public void set_Indent(short value);
    public bool get_ShrinkToFit();
    public void set_ShrinkToFit(bool value);
    public bool get_MergeCells();
    public void set_MergeCells(bool value);
    public short get_ReadingOrder();
    public void set_ReadingOrder(short value);
    public bool get_IsIndentNotParentFormat();
    public void set_IsIndentNotParentFormat(bool value);
    public bool get_IsIndentNotParentFont();
    public void set_IsIndentNotParentFont(bool value);
    public bool get_IsIndentNotParentAlignment();
    public void set_IsIndentNotParentAlignment(bool value);
    public bool get_IsIndentNotParentBorder();
    public void set_IsIndentNotParentBorder(bool value);
    public bool get_IsIndentNotParentPattern();
    public void set_IsIndentNotParentPattern(bool value);
    public bool get_IsIndentNotParentCellOptions();
    public void set_IsIndentNotParentCellOptions(bool value);
    public short get_BorderOptions();
    public void set_BorderOptions(short value);
    public short get_BorderLeft();
    public void set_BorderLeft(short value);
    public short get_BorderRight();
    public void set_BorderRight(short value);
    public short get_BorderTop();
    public void set_BorderTop(short value);
    public short get_BorderBottom();
    public void set_BorderBottom(short value);
    public short get_PaletteOptions();
    public void set_PaletteOptions(short value);
    public short get_LeftBorderPaletteIdx();
    public void set_LeftBorderPaletteIdx(short value);
    public short get_RightBorderPaletteIdx();
    public void set_RightBorderPaletteIdx(short value);
    public int get_AdtlPaletteOptions();
    public void set_AdtlPaletteOptions(int value);
    public short get_TopBorderPaletteIdx();
    public void set_TopBorderPaletteIdx(short value);
    public short get_BottomBorderPaletteIdx();
    public void set_BottomBorderPaletteIdx(short value);
    public short get_AdtlDiagBorderPaletteIdx();
    public void set_AdtlDiagBorderPaletteIdx(short value);
    public short get_AdtlDiagLineStyle();
    public void set_AdtlDiagLineStyle(short value);
    public short get_Diagonal();
    public void set_Diagonal(short value);
    public short get_AdtlFillPattern();
    public void set_AdtlFillPattern(short value);
    public short get_FillPaletteOptions();
    public void set_FillPaletteOptions(short value);
    public short get_FillForeground();
    public void set_FillForeground(short value);
    public short get_FillBackground();
    public void set_FillBackground(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public Int32[] get_StateSummary();
}
public class NPOI.HSSF.Record.ExternalNameRecord : StandardRecord {
    public static short sid;
    private static int OPT_BUILTIN_NAME;
    private static int OPT_AUTOMATIC_LINK;
    private static int OPT_PICTURE_LINK;
    private static int OPT_STD_DOCUMENT_NAME;
    private static int OPT_OLE_LINK;
    private static int OPT_ICONIFIED_PICTURE_LINK;
    private short field_1_option_flag;
    private short field_2_ixals;
    private short field_3_not_used;
    private string field_4_name;
    private Formula field_5_name_definition;
    private Object[] _ddeValues;
    private int _nColumns;
    private int _nRows;
    public bool IsBuiltInName { get; }
    public bool IsAutomaticLink { get; }
    public bool IsPicureLink { get; }
    public bool IsStdDocumentNameIdentifier { get; }
    public bool IsOLELink { get; }
    public bool IsIconifiedPictureLink { get; }
    public short Ix { get; public set; }
    public string Text { get; public set; }
    protected int DataSize { get; }
    private bool HasFormula { get; }
    public short Sid { get; }
    public ExternalNameRecord(RecordInputStream in1);
    public bool get_IsBuiltInName();
    public bool get_IsAutomaticLink();
    public bool get_IsPicureLink();
    public bool get_IsStdDocumentNameIdentifier();
    public bool get_IsOLELink();
    public bool get_IsIconifiedPictureLink();
    public short get_Ix();
    public void set_Ix(short value);
    public string get_Text();
    public void set_Text(string value);
    public Ptg[] GetParsedExpression();
    public void SetParsedExpression(Ptg[] ptgs);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    private Exception ReadFail(string msg);
    private bool get_HasFormula();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.ExternSheetRecord : StandardRecord {
    public static short sid;
    private IList`1<RefSubRecord> _list;
    public int NumOfREFRecords { get; }
    public int NumOfRefs { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public ExternSheetRecord(RecordInputStream in1);
    public int AddRef(int extBookIndex, int firstSheetIndex, int lastSheetIndex);
    public int GetRefIxForSheet(int externalBookIndex, int firstSheetIndex, int lastSheetIndex);
    public int get_NumOfREFRecords();
    public int get_NumOfRefs();
    public void AddREFRecord(RefSubRecord rec);
    private RefSubRecord GetRef(int i);
    public void RemoveSheet(int sheetIdx);
    public int GetExtbookIndexFromRefIndex(int refIndex);
    public int FindRefIndexFromExtBookIndex(int extBookIndex);
    public static ExternSheetRecord Combine(ExternSheetRecord[] esrs);
    public int GetFirstSheetIndexFromRefIndex(int extRefIndex);
    public int GetLastSheetIndexFromRefIndex(int extRefIndex);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.ExternSheetSubRecord : Record {
    public static short sid;
    private short field_1_index_to_supbook;
    private short field_2_index_to_first_supbook_sheet;
    private short field_3_index_to_last_supbook_sheet;
    public int RecordSize { get; }
    public short Sid { get; }
    public ExternSheetSubRecord(RecordInputStream in1);
    public void SetIndexToSupBook(short index);
    public short GetIndexToSupBook();
    public void SetIndexToFirstSupBook(short index);
    public short GetIndexToFirstSupBook();
    public void SetIndexToLastSupBook(short index);
    public short GetIndexToLastSupBook();
    public virtual string ToString();
    public virtual int Serialize(int offset, Byte[] data);
    public virtual int get_RecordSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.ExtSSTRecord : ContinuableRecord {
    public static short DEFAULT_BUCKET_SIZE;
    public static int MAX_BUCKETS;
    public static short sid;
    private short field_1_strings_per_bucket;
    private InfoSubRecord[] _sstInfos;
    public short NumStringsPerBucket { get; public set; }
    internal int DataSize { get; }
    internal InfoSubRecord[] InfoSubRecords { get; }
    public short Sid { get; }
    public ExtSSTRecord(RecordInputStream in1);
    public IEnumerator GetEnumerator();
    public short get_NumStringsPerBucket();
    public void set_NumStringsPerBucket(short value);
    public virtual string ToString();
    protected virtual void Serialize(ContinuableRecordOutput out1);
    internal int get_DataSize();
    internal InfoSubRecord[] get_InfoSubRecords();
    public static int GetNumberOfInfoRecsForStrings(int numStrings);
    public static int GetRecordSizeForStrings(int numStrings);
    public virtual short get_Sid();
    public void SetBucketOffsets(Int32[] bucketAbsoluteOffsets, Int32[] bucketRelativeOffsets);
}
public class NPOI.HSSF.Record.FeatHdrRecord : StandardRecord {
    public static int SHAREDFEATURES_ISFPROTECTION;
    public static int SHAREDFEATURES_ISFFEC2;
    public static int SHAREDFEATURES_ISFFACTOID;
    public static int SHAREDFEATURES_ISFLIST;
    public static short sid;
    private FtrHeader futureHeader;
    private int isf_sharedFeatureType;
    private byte reserved;
    private long cbHdrData;
    private Byte[] rgbHdrData;
    public short Sid { get; }
    protected int DataSize { get; }
    public FeatHdrRecord(RecordInputStream in1);
    public virtual short get_Sid();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.FeatRecord : StandardRecord {
    private static POILogger logger;
    public static short sid;
    public static short v11_sid;
    public static short v12_sid;
    private FtrHeader futureHeader;
    private int isf_sharedFeatureType;
    private byte reserved1;
    private long reserved2;
    private long cbFeatData;
    private int reserved3;
    private CellRangeAddress[] cellRefs;
    private SharedFeature sharedFeature;
    public short Sid { get; }
    protected int DataSize { get; }
    public int Isf_sharedFeatureType { get; }
    public long CbFeatData { get; public set; }
    public CellRangeAddress[] CellRefs { get; public set; }
    public SharedFeature SharedFeature { get; public set; }
    public FeatRecord(RecordInputStream in1);
    private static FeatRecord();
    public virtual short get_Sid();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public int get_Isf_sharedFeatureType();
    public long get_CbFeatData();
    public void set_CbFeatData(long value);
    public CellRangeAddress[] get_CellRefs();
    public void set_CellRefs(CellRangeAddress[] value);
    public SharedFeature get_SharedFeature();
    public void set_SharedFeature(SharedFeature value);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.FilePassRecord : StandardRecord {
    public static short sid;
    private static int ENCRYPTION_XOR;
    private static int ENCRYPTION_OTHER;
    private int _encryptionType;
    private KeyData _keyData;
    protected int DataSize { get; }
    public short Sid { get; }
    private FilePassRecord(FilePassRecord other);
    public FilePassRecord(RecordInputStream in1);
    private static Byte[] Read(RecordInputStream in1, int size);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public Rc4KeyData GetRc4KeyData();
    public XorKeyData GetXorKeyData();
    private Rc4KeyData CheckRc4();
    public virtual short get_Sid();
    public virtual object Clone();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.FileSharingRecord : StandardRecord {
    public static short sid;
    private short field_1_Readonly;
    private short field_2_password;
    private byte field_3_username_unicode_options;
    private string field_3_username_value;
    public short ReadOnly { get; public set; }
    public short Password { get; public set; }
    public string Username { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public FileSharingRecord(RecordInputStream in1);
    public short get_ReadOnly();
    public void set_ReadOnly(short value);
    public short get_Password();
    public void set_Password(short value);
    public string get_Username();
    public void set_Username(string value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.FnGroupCountRecord : StandardRecord {
    public static short sid;
    public static short COUNT;
    private short field_1_count;
    public short Count { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public FnGroupCountRecord(RecordInputStream in1);
    public short get_Count();
    public void set_Count(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.FontRecord : StandardRecord {
    public static short sid;
    private short field_1_font_height;
    private short field_2_attributes;
    private static BitField italic;
    private static BitField strikeout;
    private static BitField macoutline;
    private static BitField macshadow;
    private short field_3_color_palette_index;
    private short field_4_bold_weight;
    private short field_5_base_sub_script;
    private byte field_6_underline;
    private byte field_7_family;
    private byte field_8_charset;
    private byte field_9_zero;
    private string field_11_font_name;
    public bool IsItalic { get; public set; }
    public bool IsStrikeout { get; public set; }
    public bool IsMacoutlined { get; public set; }
    public bool IsMacshadowed { get; public set; }
    public FontUnderlineType Underline { get; public set; }
    public byte Family { get; public set; }
    public byte Charset { get; public set; }
    public string FontName { get; public set; }
    public short FontHeight { get; public set; }
    public short Attributes { get; public set; }
    public short ColorPaletteIndex { get; public set; }
    public short BoldWeight { get; public set; }
    public FontSuperScript SuperSubScript { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public FontRecord(RecordInputStream in1);
    private static FontRecord();
    public void CloneStyleFrom(FontRecord source);
    public void set_IsItalic(bool value);
    public bool get_IsItalic();
    public void set_IsStrikeout(bool value);
    public bool get_IsStrikeout();
    public void set_IsMacoutlined(bool value);
    public bool get_IsMacoutlined();
    public void set_IsMacshadowed(bool value);
    public bool get_IsMacshadowed();
    public FontUnderlineType get_Underline();
    public void set_Underline(FontUnderlineType value);
    public void set_Family(byte value);
    public byte get_Family();
    public void set_Charset(byte value);
    public byte get_Charset();
    public void set_FontName(string value);
    public string get_FontName();
    public short get_FontHeight();
    public void set_FontHeight(short value);
    public short get_Attributes();
    public void set_Attributes(short value);
    public short get_ColorPaletteIndex();
    public void set_ColorPaletteIndex(short value);
    public short get_BoldWeight();
    public void set_BoldWeight(short value);
    public FontSuperScript get_SuperSubScript();
    public void set_SuperSubScript(FontSuperScript value);
    public bool SameProperties(FontRecord other);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class NPOI.HSSF.Record.FooterRecord : HeaderFooterBase {
    public static short sid;
    public short Sid { get; }
    public FooterRecord(string text);
    public FooterRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.FormatRecord : StandardRecord {
    public static short sid;
    private int field_1_index_code;
    private bool field_3_hasMultibyte;
    private string field_4_formatstring;
    public int IndexCode { get; }
    public string FormatString { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    private FormatRecord(FormatRecord other);
    public FormatRecord(int indexCode, string fs);
    public FormatRecord(RecordInputStream in1);
    public int get_IndexCode();
    public string get_FormatString();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.FormulaRecord : CellRecord {
    public static short sid;
    private static int FIXED_SIZE;
    private double field_4_value;
    private short field_5_options;
    private BitField alwaysCalc;
    private BitField calcOnLoad;
    private BitField sharedFormula;
    private int field_6_zero;
    private Formula field_8_parsed_expr;
    private SpecialCachedValue specialCachedValue;
    public bool HasCachedResultString { get; }
    public double Value { get; public set; }
    public short Options { get; public set; }
    public bool IsSharedFormula { get; public set; }
    public bool IsAlwaysCalc { get; public set; }
    public bool IsCalcOnLoad { get; public set; }
    public Ptg[] ParsedExpression { get; public set; }
    public Formula Formula { get; }
    protected string RecordName { get; }
    protected int ValueDataSize { get; }
    public short Sid { get; }
    public bool CachedBooleanValue { get; }
    public int CachedErrorValue { get; }
    public CellType CachedResultType { get; }
    public FormulaRecord(RecordInputStream in1);
    public bool get_HasCachedResultString();
    public void SetParsedExpression(Ptg[] ptgs);
    public void SetSharedFormula(bool flag);
    public double get_Value();
    public void set_Value(double value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_IsSharedFormula();
    public void set_IsSharedFormula(bool value);
    public bool get_IsAlwaysCalc();
    public void set_IsAlwaysCalc(bool value);
    public bool get_IsCalcOnLoad();
    public void set_IsCalcOnLoad(bool value);
    public Ptg[] get_ParsedExpression();
    public void set_ParsedExpression(Ptg[] value);
    public Formula get_Formula();
    protected virtual string get_RecordName();
    protected virtual int get_ValueDataSize();
    public virtual short get_Sid();
    public void SetCachedResultTypeEmptyString();
    public void SetCachedResultTypeString();
    public void SetCachedResultErrorCode(int errorCode);
    public void SetCachedResultBoolean(bool value);
    public bool get_CachedBooleanValue();
    public int get_CachedErrorValue();
    public CellType get_CachedResultType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual void SerializeValue(ILittleEndianOutput out1);
    protected virtual void AppendValueText(StringBuilder buffer);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.FtCblsSubRecord : SubRecord {
    public static short sid;
    private static int ENCODED_SIZE;
    private Byte[] reserved;
    public int DataSize { get; }
    public short Sid { get; }
    public FtCblsSubRecord(ILittleEndianInput in1, int size);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.FtCfSubRecord : SubRecord {
    public static short sid;
    public static short length;
    public static short METAFILE_BIT;
    public static short BITMAP_BIT;
    public static short UNSPECIFIED_BIT;
    private short flags;
    public int DataSize { get; }
    public short Sid { get; }
    public short Flags { get; public set; }
    public FtCfSubRecord(ILittleEndianInput in1, int size);
    private static FtCfSubRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_Flags();
    public void set_Flags(short value);
}
public class NPOI.HSSF.Record.FtPioGrbitSubRecord : SubRecord {
    public static short sid;
    public static short length;
    public static int AUTO_PICT_BIT;
    public static int DDE_BIT;
    public static int PRINT_CALC_BIT;
    public static int ICON_BIT;
    public static int CTL_BIT;
    public static int PRSTM_BIT;
    public static int CAMERA_BIT;
    public static int DEFAULT_SIZE_BIT;
    public static int AUTO_LOAD_BIT;
    private short flags;
    public int DataSize { get; }
    public short Sid { get; }
    public short Flags { get; public set; }
    public FtPioGrbitSubRecord(ILittleEndianInput in1, int size);
    private static FtPioGrbitSubRecord();
    public void SetFlagByBit(int bitmask, bool enabled);
    public bool GetFlagByBit(int bitmask);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_Flags();
    public void set_Flags(short value);
}
public class NPOI.HSSF.Record.GridsetRecord : StandardRecord {
    public static short sid;
    public short field_1_gridset_flag;
    public bool Gridset { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public GridsetRecord(RecordInputStream in1);
    public bool get_Gridset();
    public void set_Gridset(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.GroupMarkerSubRecord : SubRecord {
    public static short sid;
    private Byte[] reserved;
    private static Byte[] EMPTY_BYTE_ARRAY;
    public int DataSize { get; }
    public short Sid { get; }
    public GroupMarkerSubRecord(ILittleEndianInput in1, int size);
    private static GroupMarkerSubRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.GutsRecord : StandardRecord {
    public static short sid;
    private short field_1_left_row_gutter;
    private short field_2_top_col_gutter;
    private short field_3_row_level_max;
    private short field_4_col_level_max;
    public short LeftRowGutter { get; public set; }
    public short TopColGutter { get; public set; }
    public short RowLevelMax { get; public set; }
    public short ColLevelMax { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public GutsRecord(RecordInputStream in1);
    public short get_LeftRowGutter();
    public void set_LeftRowGutter(short value);
    public short get_TopColGutter();
    public void set_TopColGutter(short value);
    public short get_RowLevelMax();
    public void set_RowLevelMax(short value);
    public short get_ColLevelMax();
    public void set_ColLevelMax(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.HCenterRecord : StandardRecord {
    public static short sid;
    private short field_1_hcenter;
    public bool HCenter { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public HCenterRecord(RecordInputStream in1);
    public bool get_HCenter();
    public void set_HCenter(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public abstract class NPOI.HSSF.Record.HeaderFooterBase : StandardRecord {
    private bool field_2_hasMultibyte;
    private string field_3_text;
    private int TextLength { get; }
    public string Text { get; public set; }
    protected int DataSize { get; }
    protected HeaderFooterBase(string text);
    protected HeaderFooterBase(RecordInputStream in1);
    private int get_TextLength();
    public string get_Text();
    public void set_Text(string value);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
}
public class NPOI.HSSF.Record.HeaderFooterRecord : StandardRecord {
    private static Byte[] BLANK_GUID;
    public static short sid;
    private Byte[] _rawData;
    protected int DataSize { get; }
    public short Sid { get; }
    public Byte[] Guid { get; }
    public bool IsCurrentSheet { get; }
    public HeaderFooterRecord(Byte[] data);
    public HeaderFooterRecord(RecordInputStream in1);
    private static HeaderFooterRecord();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public Byte[] get_Guid();
    public bool get_IsCurrentSheet();
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.HeaderRecord : HeaderFooterBase {
    public static short sid;
    public short Sid { get; }
    public HeaderRecord(string text);
    public HeaderRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.HideObjRecord : StandardRecord {
    public static short sid;
    public static short HIDE_ALL;
    public static short SHOW_PLACEHOLDERS;
    public static short SHOW_ALL;
    private short field_1_hide_obj;
    protected int DataSize { get; }
    public short Sid { get; }
    public HideObjRecord(RecordInputStream in1);
    public void SetHideObj(short hide);
    public short GetHideObj();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.HorizontalPageBreakRecord : PageBreakRecord {
    public static short sid;
    public short Sid { get; }
    public HorizontalPageBreakRecord(RecordInputStream in1);
    public virtual short get_Sid();
    public virtual object Clone();
}
public enum NPOI.HSSF.Record.HorizontalTextAlignment : Enum {
    public int value__;
    public static HorizontalTextAlignment Left;
    public static HorizontalTextAlignment Center;
    public static HorizontalTextAlignment Right;
    public static HorizontalTextAlignment Justify;
}
public class NPOI.HSSF.Record.HyperlinkRecord : StandardRecord {
    private static POILogger logger;
    public static int HLINK_URL;
    public static int HLINK_ABS;
    public static int HLINK_LABEL;
    public static int HLINK_PLACE;
    private static int HLINK_TARGET_FRAME;
    private static int HLINK_UNC_PATH;
    public static GUID STD_MONIKER;
    public static GUID URL_MONIKER;
    public static GUID FILE_MONIKER;
    public static Byte[] URL_uninterpretedTail;
    public static Byte[] FILE_uninterpretedTail;
    private static int TAIL_SIZE;
    public static short sid;
    private CellRangeAddress _range;
    private GUID _guid;
    private short _fileOpts;
    private int _linkOpts;
    private string _label;
    private string _targetFrame;
    private GUID _moniker;
    private string _shortFilename;
    private string _address;
    private string _textMark;
    private Byte[] _uninterpretedTail;
    public int FirstColumn { get; public set; }
    public int LastColumn { get; public set; }
    public int FirstRow { get; public set; }
    public int LastRow { get; public set; }
    public GUID Guid { get; }
    public GUID Moniker { get; }
    public string Label { get; public set; }
    public string Address { get; public set; }
    public string TextMark { get; public set; }
    public int LinkOptions { get; }
    public string TargetFrame { get; }
    public string ShortFilename { get; public set; }
    public int LabelOptions { get; }
    public int FileOptions { get; }
    public short Sid { get; }
    protected int DataSize { get; }
    public bool IsUrlLink { get; }
    public bool IsFileLink { get; }
    public bool IsDocumentLink { get; }
    public HyperlinkRecord(RecordInputStream in1);
    private static HyperlinkRecord();
    private static Byte[] ReadTail(Byte[] expectedTail, ILittleEndianInput in1);
    private static void WriteTail(Byte[] tail, ILittleEndianOutput out1);
    public int get_FirstColumn();
    public void set_FirstColumn(int value);
    public int get_LastColumn();
    public void set_LastColumn(int value);
    public int get_FirstRow();
    public void set_FirstRow(int value);
    public int get_LastRow();
    public void set_LastRow(int value);
    public GUID get_Guid();
    public GUID get_Moniker();
    private static string CleanString(string s);
    private static string AppendNullTerm(string s);
    public string get_Label();
    public void set_Label(string value);
    public string get_Address();
    public void set_Address(string value);
    public string get_TextMark();
    public void set_TextMark(string value);
    public int get_LinkOptions();
    public string get_TargetFrame();
    public string get_ShortFilename();
    public void set_ShortFilename(string value);
    public int get_LabelOptions();
    public int get_FileOptions();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual string ToString();
    public bool get_IsUrlLink();
    public bool get_IsFileLink();
    public bool get_IsDocumentLink();
    public void CreateUrlLink();
    public void CreateFileLink();
    public void CreateDocumentLink();
    public virtual object Clone();
}
public interface NPOI.HSSF.Record.IMargin {
    public double Margin { get; public set; }
    public abstract virtual double get_Margin();
    public abstract virtual void set_Margin(double value);
}
public class NPOI.HSSF.Record.IndexRecord : StandardRecord {
    public static short sid;
    public int field_1_zero;
    public int field_2_first_row;
    public int field_3_last_row_add1;
    public int field_4_zero;
    public IntList field_5_dbcells;
    public int FirstRow { get; public set; }
    public int LastRowAdd1 { get; public set; }
    public int NumDbcells { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public IndexRecord(RecordInputStream in1);
    public void AddDbcell(int cell);
    public void SetDbcell(int cell, int value);
    public int get_FirstRow();
    public void set_FirstRow(int value);
    public int get_LastRowAdd1();
    public void set_LastRowAdd1(int value);
    public int get_NumDbcells();
    public int GetDbcellAt(int cellnum);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public static int GetRecordSizeForBlockCount(int blockCount);
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.InfoSubRecord : object {
    public static int ENCODED_SIZE;
    public static short sid;
    private int field_1_stream_pos;
    private int field_2_bucket_sst_offset;
    private short field_3_zero;
    public int StreamPos { get; public set; }
    unknown short BucketRecordOffset {public set; }
    public int BucketSSTOffset { get; }
    public InfoSubRecord(int streamPos, int bucketSstOffset);
    public InfoSubRecord(RecordInputStream in1);
    public void set_StreamPos(int value);
    public int get_StreamPos();
    public void set_BucketRecordOffset(short value);
    public int get_BucketSSTOffset();
    public virtual string ToString();
    public void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.InterfaceEndRecord : StandardRecord {
    public static short sid;
    public static InterfaceEndRecord Instance;
    protected int DataSize { get; }
    public short Sid { get; }
    private static InterfaceEndRecord();
    public static Record Create(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public int GetDataSize();
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.InterfaceHdrRecord : StandardRecord {
    public static short sid;
    private int _codepage;
    public static short CODEPAGE;
    protected int DataSize { get; }
    public short Sid { get; }
    public InterfaceHdrRecord(int codePage);
    public InterfaceHdrRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.IterationRecord : StandardRecord {
    public static short sid;
    private static BitField iterationOn;
    private int _flags;
    public bool Iteration { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public IterationRecord(bool iterateOn);
    public IterationRecord(RecordInputStream in1);
    private static IterationRecord();
    public bool get_Iteration();
    public void set_Iteration(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.LabelRecord : Record {
    private static POILogger logger;
    public static short sid;
    private int field_1_row;
    private int field_2_column;
    private short field_3_xf_index;
    private short field_4_string_len;
    private byte field_5_unicode_flag;
    private string field_6_value;
    public int Row { get; public set; }
    public int Column { get; public set; }
    public short XFIndex { get; public set; }
    public short StringLength { get; }
    public bool IsUncompressedUnicode { get; }
    public string Value { get; }
    public int RecordSize { get; }
    public short Sid { get; }
    public LabelRecord(RecordInputStream in1);
    private static LabelRecord();
    public sealed virtual int get_Row();
    public sealed virtual void set_Row(int value);
    public sealed virtual int get_Column();
    public sealed virtual void set_Column(int value);
    public sealed virtual short get_XFIndex();
    public sealed virtual void set_XFIndex(short value);
    public short get_StringLength();
    public bool get_IsUncompressedUnicode();
    public string get_Value();
    public virtual int Serialize(int offset, Byte[] data);
    public virtual int get_RecordSize();
    public virtual short get_Sid();
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.LabelSSTRecord : CellRecord {
    public static short sid;
    private int field_4_sst_index;
    protected string RecordName { get; }
    public int SSTIndex { get; public set; }
    protected int ValueDataSize { get; }
    public short Sid { get; }
    public LabelSSTRecord(RecordInputStream in1);
    protected virtual string get_RecordName();
    public int get_SSTIndex();
    public void set_SSTIndex(int value);
    protected virtual void AppendValueText(StringBuilder sb);
    protected virtual void SerializeValue(ILittleEndianOutput out1);
    protected virtual int get_ValueDataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.LbsDataSubRecord : SubRecord {
    public static int sid;
    private int _cbFContinued;
    private int _unknownPreFormulaInt;
    private Ptg _linkPtg;
    private Nullable`1<byte> _unknownPostFormulaByte;
    private int _cLines;
    private int _iSel;
    private int _flags;
    private int _idEdit;
    private LbsDropData _dropData;
    private String[] _rgLines;
    private Boolean[] _bsels;
    public bool IsTerminating { get; }
    public Ptg Formula { get; }
    public int NumberOfItems { get; }
    public short Sid { get; }
    public int DataSize { get; }
    public LbsDataSubRecord(ILittleEndianInput in1, int cbFContinued, int cmoOt);
    public virtual bool get_IsTerminating();
    public Ptg get_Formula();
    public int get_NumberOfItems();
    public virtual short get_Sid();
    public virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    private static Ptg ReadRefPtg(Byte[] formulaRawBytes);
    public virtual object Clone();
    public virtual string ToString();
    public static LbsDataSubRecord CreateAutoFilterInstance();
}
public class NPOI.HSSF.Record.LbsDropData : object {
    public static int STYLE_COMBO_DROPDOWN;
    public static int STYLE_COMBO_EDIT_DROPDOWN;
    public static int STYLE_COMBO_SIMPLE_DROPDOWN;
    internal int _wStyle;
    internal int _cLine;
    private int _dxMin;
    private string _str;
    private byte _unused;
    public int DataSize { get; }
    public LbsDropData(ILittleEndianInput in1);
    public void Serialize(ILittleEndianOutput out1);
    public int get_DataSize();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.LeftMarginRecord : StandardRecord {
    public static short sid;
    private double field_1_margin;
    protected int DataSize { get; }
    public short Sid { get; }
    public double Margin { get; public set; }
    public LeftMarginRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public sealed virtual double get_Margin();
    public sealed virtual void set_Margin(double value);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.LeftoverDataException : Exception {
    public LeftoverDataException(int sid, int remainingByteCount);
    private static string getRecordName(int sid);
}
public class NPOI.HSSF.Record.LinkedDataFormulaField : object {
    private Ptg[] formulaTokens;
    public int Size { get; }
    public Ptg[] FormulaTokens { get; public set; }
    public int get_Size();
    public int FillField(RecordInputStream in1);
    public void toString(StringBuilder buffer);
    public virtual string ToString();
    public int SerializeField(int offset, Byte[] data);
    public Ptg[] get_FormulaTokens();
    public void set_FormulaTokens(Ptg[] value);
    public LinkedDataFormulaField Copy();
}
public class NPOI.HSSF.Record.MergeCellsRecord : StandardRecord {
    public static short sid;
    private CellRangeAddress[] _regions;
    private int _startIndex;
    private int _numberOfRegions;
    public short NumAreas { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public MergeCellsRecord(CellRangeAddress[] regions, int startIndex, int numberOfRegions);
    public MergeCellsRecord(RecordInputStream in1);
    public IEnumerator GetEnumerator();
    public short get_NumAreas();
    public void set_NumAreas(short value);
    public CellRangeAddress GetAreaAt(int index);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.MMSRecord : StandardRecord {
    public static short sid;
    private byte field_1_AddMenuCount;
    private byte field_2_delMenuCount;
    public byte AddMenuCount { get; public set; }
    public byte DelMenuCount { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public MMSRecord(RecordInputStream in1);
    public byte get_AddMenuCount();
    public void set_AddMenuCount(byte value);
    public byte get_DelMenuCount();
    public void set_DelMenuCount(byte value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.MulBlankRecord : StandardRecord {
    public static short sid;
    private int _row;
    private int _first_col;
    private Int16[] _xfs;
    private int _last_col;
    public int Row { get; }
    public int FirstColumn { get; }
    public int LastColumn { get; }
    public int NumColumns { get; }
    public short Sid { get; }
    protected int DataSize { get; }
    public MulBlankRecord(int row, int firstCol, Int16[] xfs);
    public MulBlankRecord(RecordInputStream in1);
    public int get_Row();
    public int get_FirstColumn();
    public int get_LastColumn();
    public int get_NumColumns();
    public short GetXFAt(int coffset);
    private Int16[] ParseXFs(RecordInputStream in1);
    public virtual string ToString();
    public virtual short get_Sid();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.MulRKRecord : StandardRecord {
    public static short sid;
    private int field_1_row;
    private short field_2_first_col;
    private RkRec[] field_3_rks;
    private short field_4_last_col;
    public int Row { get; }
    public short FirstColumn { get; }
    public short LastColumn { get; }
    public int NumColumns { get; }
    public short Sid { get; }
    protected int DataSize { get; }
    public MulRKRecord(RecordInputStream in1);
    public int get_Row();
    public short get_FirstColumn();
    public short get_LastColumn();
    public int get_NumColumns();
    public short GetXFAt(int coffset);
    public double GetRKNumberAt(int coffset);
    public virtual string ToString();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
}
public class NPOI.HSSF.Record.NameCommentRecord : StandardRecord {
    public static short sid;
    private short field_1_record_type;
    private short field_2_frt_cell_ref_flag;
    private long field_3_reserved;
    private string field_6_name_text;
    private string field_7_comment_text;
    protected int DataSize { get; }
    public short Sid { get; }
    public string NameText { get; public set; }
    public string CommentText { get; public set; }
    public short RecordType { get; }
    public NameCommentRecord(string name, string comment);
    public NameCommentRecord(RecordInputStream ris);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
    public string get_NameText();
    public void set_NameText(string value);
    public string get_CommentText();
    public void set_CommentText(string value);
    public short get_RecordType();
}
public class NPOI.HSSF.Record.NameRecord : ContinuableRecord {
    public static short sid;
    public static byte BUILTIN_CONSOLIDATE_AREA;
    public static byte BUILTIN_AUTO_OPEN;
    public static byte BUILTIN_AUTO_CLOSE;
    public static byte BUILTIN_EXTRACT;
    public static byte BUILTIN_DATABASE;
    public static byte BUILTIN_CRITERIA;
    public static byte BUILTIN_PRINT_AREA;
    public static byte BUILTIN_PRINT_TITLE;
    public static byte BUILTIN_RECORDER;
    public static byte BUILTIN_DATA_FORM;
    public static byte BUILTIN_AUTO_ACTIVATE;
    public static byte BUILTIN_AUTO_DEACTIVATE;
    public static byte BUILTIN_SHEET_TITLE;
    public static byte BUILTIN_FILTER_DB;
    private short field_1_option_flag;
    private byte field_2_keyboard_shortcut;
    private short field_5_externSheetIndex_plus1;
    private int field_6_sheetNumber;
    private bool field_11_nameIsMultibyte;
    private byte field_12_built_in_code;
    private string field_12_name_text;
    private Formula field_13_name_definition;
    private string field_14_custom_menu_text;
    private string field_15_description_text;
    private string field_16_help_topic_text;
    private string field_17_status_bar_text;
    protected int DataSize { get; }
    public byte FnGroup { get; }
    public short OptionFlag { get; public set; }
    public byte KeyboardShortcut { get; public set; }
    public byte NameTextLength { get; }
    private int NameRawSize { get; }
    public bool HasFormula { get; }
    public bool IsHiddenName { get; public set; }
    public bool IsFunctionName { get; public set; }
    public bool IsCommandName { get; }
    public bool IsMacro { get; }
    public bool IsComplexFunction { get; }
    public bool IsBuiltInName { get; }
    public string NameText { get; public set; }
    public byte BuiltInName { get; }
    public Ptg[] NameDefinition { get; public set; }
    public string CustomMenuText { get; public set; }
    public string DescriptionText { get; public set; }
    public string HelpTopicText { get; public set; }
    public string StatusBarText { get; public set; }
    public int SheetNumber { get; public set; }
    public int ExternSheetNumber { get; }
    public short Sid { get; }
    public NameRecord(RecordInputStream ris);
    public NameRecord(byte builtin, int sheetNumber);
    public static bool IsFormula(int optValue);
    protected int get_DataSize();
    public byte get_FnGroup();
    public short get_OptionFlag();
    public void set_OptionFlag(short value);
    public byte get_KeyboardShortcut();
    public void set_KeyboardShortcut(byte value);
    public byte get_NameTextLength();
    private int get_NameRawSize();
    public void SetFunction(bool function);
    public bool get_HasFormula();
    public bool get_IsHiddenName();
    public void set_IsHiddenName(bool value);
    public bool get_IsFunctionName();
    public void set_IsFunctionName(bool value);
    public bool get_IsCommandName();
    public bool get_IsMacro();
    public bool get_IsComplexFunction();
    public bool get_IsBuiltInName();
    public string get_NameText();
    public void set_NameText(string value);
    public byte get_BuiltInName();
    public Ptg[] get_NameDefinition();
    public void set_NameDefinition(Ptg[] value);
    public string get_CustomMenuText();
    public void set_CustomMenuText(string value);
    public string get_DescriptionText();
    public void set_DescriptionText(string value);
    public string get_HelpTopicText();
    public void set_HelpTopicText(string value);
    public string get_StatusBarText();
    public void set_StatusBarText(string value);
    public int get_SheetNumber();
    public void set_SheetNumber(int value);
    protected virtual void Serialize(ContinuableRecordOutput out1);
    public int get_ExternSheetNumber();
    private Ptg CreateNewPtg();
    public virtual short get_Sid();
    public virtual string ToString();
    protected string TranslateBuiltInName(byte name);
}
public class NPOI.HSSF.Record.NoteRecord : StandardRecord {
    public static NoteRecord[] EMPTY_ARRAY;
    public static short sid;
    public static short NOTE_HIDDEN;
    public static short NOTE_VISIBLE;
    private int field_1_row;
    private int field_2_col;
    private short field_3_flags;
    private int field_4_shapeid;
    private bool field_5_hasMultibyte;
    private string field_6_author;
    private static byte DEFAULT_PADDING;
    private Nullable`1<byte> field_7_padding;
    public short Sid { get; }
    protected int DataSize { get; }
    public int Row { get; public set; }
    public int Column { get; public set; }
    public short Flags { get; public set; }
    public int ShapeId { get; public set; }
    public string Author { get; public set; }
    internal bool AuthorIsMultibyte { get; }
    public NoteRecord(RecordInputStream in1);
    private static NoteRecord();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual string ToString();
    public int get_Row();
    public void set_Row(int value);
    public int get_Column();
    public void set_Column(int value);
    public short get_Flags();
    public void set_Flags(short value);
    public int get_ShapeId();
    public void set_ShapeId(int value);
    public string get_Author();
    public void set_Author(string value);
    internal bool get_AuthorIsMultibyte();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.NoteStructureSubRecord : SubRecord {
    public static short sid;
    private static int ENCODED_SIZE;
    private Byte[] reserved;
    public int DataSize { get; }
    public short Sid { get; }
    public NoteStructureSubRecord(ILittleEndianInput in1, int size);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.NumberRecord : CellRecord {
    public static short sid;
    private double field_4_value;
    protected string RecordName { get; }
    protected int ValueDataSize { get; }
    public double Value { get; public set; }
    public short Sid { get; }
    public NumberRecord(RecordInputStream in1);
    protected virtual string get_RecordName();
    protected virtual void AppendValueText(StringBuilder sb);
    protected virtual void SerializeValue(ILittleEndianOutput out1);
    protected virtual int get_ValueDataSize();
    public double get_Value();
    public void set_Value(double value);
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.ObjectProtectRecord : StandardRecord {
    public static short sid;
    private short field_1_protect;
    public bool Protect { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public ObjectProtectRecord(RecordInputStream in1);
    public bool get_Protect();
    public void set_Protect(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.ObjRecord : Record {
    private static int NORMAL_PAD_ALIGNMENT;
    private static int MAX_PAD_ALIGNMENT;
    public static short sid;
    private List`1<SubRecord> subrecords;
    private Byte[] _uninterpretedData;
    private bool _isPaddedToQuadByteMultiple;
    public int RecordSize { get; }
    public short Sid { get; }
    public List`1<SubRecord> SubRecords { get; }
    public ObjRecord(RecordInputStream in1);
    private static bool CanPaddingBeDiscarded(Byte[] data, int nRemainingBytes);
    public virtual string ToString();
    public virtual int Serialize(int offset, Byte[] data);
    public virtual int get_RecordSize();
    public virtual short get_Sid();
    public List`1<SubRecord> get_SubRecords();
    public void ClearSubRecords();
    public void AddSubRecord(int index, SubRecord element);
    public void AddSubRecord(SubRecord o);
    public virtual object Clone();
}
public abstract class NPOI.HSSF.Record.OldCellRecord : object {
    private short sid;
    private bool isBiff2;
    private int field_1_row;
    private short field_2_column;
    private int field_3_cell_attrs;
    private short field_3_xf_index;
    public int Row { get; }
    public short Column { get; }
    public short XFIndex { get; }
    public int CellAttrs { get; }
    public bool IsBiff2 { get; }
    public short Sid { get; }
    protected string RecordName { get; }
    protected OldCellRecord(RecordInputStream in1, bool isBiff2);
    public int get_Row();
    public short get_Column();
    public short get_XFIndex();
    public int get_CellAttrs();
    public virtual bool get_IsBiff2();
    public virtual short get_Sid();
    public virtual string ToString();
    protected abstract virtual void AppendValueText(StringBuilder sb);
    protected abstract virtual string get_RecordName();
}
public class NPOI.HSSF.Record.OldFormulaRecord : OldCellRecord {
    public static short biff2_sid;
    public static short biff3_sid;
    public static short biff4_sid;
    public static short biff5_sid;
    private SpecialCachedValue specialCachedValue;
    private double field_4_value;
    private short field_5_options;
    private Formula field_6_Parsed_expr;
    public double Value { get; }
    public short Options { get; }
    public Ptg[] ParsedExpression { get; }
    public Formula Formula { get; }
    protected string RecordName { get; }
    public OldFormulaRecord(RecordInputStream ris);
    public CellType GetCachedResultType();
    public bool GetCachedBooleanValue();
    public int GetCachedErrorValue();
    public double get_Value();
    public short get_Options();
    public Ptg[] get_ParsedExpression();
    public Formula get_Formula();
    protected virtual void AppendValueText(StringBuilder sb);
    protected virtual string get_RecordName();
}
public class NPOI.HSSF.Record.OldLabelRecord : OldCellRecord {
    private static POILogger logger;
    public static short biff2_sid;
    public static short biff345_sid;
    private short field_4_string_len;
    private Byte[] field_5_bytes;
    private CodepageRecord codepage;
    public short StringLength { get; }
    public string Value { get; }
    public int RecordSize { get; }
    protected string RecordName { get; }
    public OldLabelRecord(RecordInputStream in1);
    private static OldLabelRecord();
    public void SetCodePage(CodepageRecord codepage);
    public short get_StringLength();
    public string get_Value();
    public int Serialize(int offset, Byte[] data);
    public int get_RecordSize();
    protected virtual void AppendValueText(StringBuilder sb);
    protected virtual string get_RecordName();
}
public class NPOI.HSSF.Record.OldSheetRecord : object {
    public static short sid;
    private int field_1_position_of_BOF;
    private int field_2_visibility;
    private int field_3_type;
    private Byte[] field_5_sheetname;
    private CodepageRecord codepage;
    public short Sid { get; }
    public int PositionOfBof { get; }
    public string Sheetname { get; }
    public OldSheetRecord(RecordInputStream in1);
    public void SetCodePage(CodepageRecord codepage);
    public short get_Sid();
    public int get_PositionOfBof();
    public string get_Sheetname();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.OldStringRecord : object {
    public static short biff2_sid;
    public static short biff345_sid;
    private short sid;
    private short field_1_string_len;
    private Byte[] field_2_bytes;
    private CodepageRecord codepage;
    public bool IsBiff2 { get; }
    public short Sid { get; }
    public OldStringRecord(RecordInputStream in1);
    public bool get_IsBiff2();
    public short get_Sid();
    public void SetCodePage(CodepageRecord codepage);
    public string GetString();
    protected internal static string GetString(Byte[] data, CodepageRecord codepage);
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PageBreakRecord : StandardRecord {
    private static bool IS_EMPTY_RECORD_WRITTEN;
    private static Int32[] EMPTY_INT_ARRAY;
    public short sid;
    private IList`1<Break> _breaks;
    private Hashtable _breakMap;
    public short Sid { get; }
    protected int DataSize { get; }
    public int RecordSize { get; }
    public int NumBreaks { get; }
    public bool IsEmpty { get; }
    public PageBreakRecord(RecordInputStream in1);
    private static PageBreakRecord();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public IEnumerator`1<Break> GetBreaksEnumerator();
    public virtual string ToString();
    public void AddBreak(int main, int subFrom, int subTo);
    public void RemoveBreak(int main);
    public virtual int get_RecordSize();
    public int get_NumBreaks();
    public bool get_IsEmpty();
    public Break GetBreak(int main);
    public Int32[] GetBreaks();
}
public class NPOI.HSSF.Record.PaletteRecord : StandardRecord {
    public static short sid;
    public static byte STANDARD_PALETTE_SIZE;
    public static short FIRST_COLOR_INDEX;
    private List`1<PColor> field_2_colors;
    public short NumColors { get; }
    protected int DataSize { get; }
    public short Sid { get; }
    public PaletteRecord(RecordInputStream in1);
    public short get_NumColors();
    public void ClearColors();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public Byte[] GetColor(short byteIndex);
    public void SetColor(short byteIndex, byte red, byte green, byte blue);
    private static PColor[] CreateDefaultPalette();
    private static PColor pc(int r, int g, int b);
}
public class NPOI.HSSF.Record.PaneRecord : StandardRecord {
    public static short sid;
    private short field_1_x;
    private short field_2_y;
    private short field_3_topRow;
    private short field_4_leftColumn;
    private short field_5_activePane;
    public static short ACTIVE_PANE_LOWER_RIGHT;
    public static short ACTIVE_PANE_UPPER_RIGHT;
    public static short ACTIVE_PANE_LOWER_LEFT;
    public static short ACTIVE_PANE_UPPER_LEFT;
    protected int DataSize { get; }
    public short Sid { get; }
    public short X { get; public set; }
    public short Y { get; public set; }
    public short TopRow { get; public set; }
    public short LeftColumn { get; public set; }
    public short ActivePane { get; public set; }
    public PaneRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_X();
    public void set_X(short value);
    public short get_Y();
    public void set_Y(short value);
    public short get_TopRow();
    public void set_TopRow(short value);
    public short get_LeftColumn();
    public void set_LeftColumn(short value);
    public short get_ActivePane();
    public void set_ActivePane(short value);
}
public class NPOI.HSSF.Record.PasswordRecord : StandardRecord {
    public static short sid;
    private int field_1_password;
    public int Password { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public PasswordRecord(int password);
    public PasswordRecord(RecordInputStream in1);
    public int get_Password();
    public void set_Password(int value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.PasswordRev4Record : StandardRecord {
    public static short sid;
    private int field_1_password;
    protected int DataSize { get; }
    public short Sid { get; }
    public PasswordRev4Record(int pw);
    public PasswordRev4Record(RecordInputStream in1);
    public void SetPassword(short pw);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
internal class NPOI.HSSF.Record.PColor : object {
    public static short ENCODED_SIZE;
    public byte _red;
    public byte _green;
    public byte _blue;
    public PColor(int red, int green, int blue);
    public PColor(RecordInputStream in1);
    public void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PivotTable.DataItemRecord : StandardRecord {
    public static short sid;
    private int isxvdData;
    private int iiftab;
    private int df;
    private int isxvd;
    private int isxvi;
    private int ifmt;
    private string name;
    protected int DataSize { get; }
    public short Sid { get; }
    public DataItemRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PivotTable.ExtendedPivotTableViewFieldsRecord : StandardRecord {
    public static short sid;
    private static int STRING_NOT_PRESENT_LEN;
    private int grbit1;
    private int grbit2;
    private int citmShow;
    private int isxdiSort;
    private int isxdiShow;
    private int reserved1;
    private int reserved2;
    private string subName;
    protected int DataSize { get; }
    public short Sid { get; }
    public ExtendedPivotTableViewFieldsRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PivotTable.PageItemRecord : StandardRecord {
    public static short sid;
    private FieldInfo[] _fieldInfos;
    protected int DataSize { get; }
    public short Sid { get; }
    public PageItemRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PivotTable.StreamIDRecord : StandardRecord {
    public static short sid;
    private int idstm;
    protected int DataSize { get; }
    public short Sid { get; }
    public StreamIDRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PivotTable.ViewDefinitionRecord : StandardRecord {
    public static short sid;
    private int rwFirst;
    private int rwLast;
    private int colFirst;
    private int colLast;
    private int rwFirstHead;
    private int rwFirstData;
    private int colFirstData;
    private int iCache;
    private int reserved;
    private int sxaxis4Data;
    private int ipos4Data;
    private int cDim;
    private int cDimRw;
    private int cDimCol;
    private int cDimPg;
    private int cDimData;
    private int cRw;
    private int cCol;
    private int grbit;
    private int itblAutoFmt;
    private string dataField;
    private string name;
    protected int DataSize { get; }
    public short Sid { get; }
    public ViewDefinitionRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PivotTable.ViewFieldsRecord : StandardRecord {
    public static short sid;
    private static int STRING_NOT_PRESENT_LEN;
    private static int BASE_SIZE;
    private int sxaxis;
    private int cSub;
    private int grbitSub;
    private int cItm;
    private string _name;
    protected int DataSize { get; }
    public short Sid { get; }
    public ViewFieldsRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PivotTable.ViewSourceRecord : StandardRecord {
    public static short sid;
    private int vs;
    protected int DataSize { get; }
    public short Sid { get; }
    public ViewSourceRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.PrecisionRecord : StandardRecord {
    public static short sid;
    public short field_1_precision;
    public bool FullPrecision { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public PrecisionRecord(RecordInputStream in1);
    public bool get_FullPrecision();
    public void set_FullPrecision(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.PrintGridlinesRecord : StandardRecord {
    public static short sid;
    private short field_1_print_gridlines;
    public bool PrintGridlines { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public PrintGridlinesRecord(RecordInputStream in1);
    public bool get_PrintGridlines();
    public void set_PrintGridlines(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.PrintHeadersRecord : StandardRecord {
    public static short sid;
    private short field_1_print_headers;
    public bool PrintHeaders { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public PrintHeadersRecord(RecordInputStream in1);
    public bool get_PrintHeaders();
    public void set_PrintHeaders(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.PrintSetupRecord : StandardRecord {
    public static short sid;
    private short field_1_paper_size;
    private short field_2_scale;
    private short field_3_page_start;
    private short field_4_fit_width;
    private short field_5_fit_height;
    private short field_6_options;
    private BitField lefttoright;
    private BitField landscape;
    private BitField validSettings;
    private BitField nocolor;
    private BitField draft;
    private BitField notes;
    private BitField noOrientation;
    private BitField usepage;
    private BitField endnote;
    private BitField ierror;
    private short field_7_hresolution;
    private short field_8_vresolution;
    private double field_9_headermargin;
    private double field_10_footermargin;
    private short field_11_copies;
    public short PaperSize { get; public set; }
    public short Scale { get; public set; }
    public short PageStart { get; public set; }
    public short FitWidth { get; public set; }
    public short FitHeight { get; public set; }
    public short Options { get; public set; }
    public bool LeftToRight { get; public set; }
    public bool Landscape { get; public set; }
    public bool ValidSettings { get; public set; }
    public bool NoColor { get; public set; }
    public bool Draft { get; public set; }
    public bool Notes { get; public set; }
    public bool NoOrientation { get; public set; }
    public bool UsePage { get; public set; }
    public short HResolution { get; public set; }
    public short VResolution { get; public set; }
    public double HeaderMargin { get; public set; }
    public double FooterMargin { get; public set; }
    public bool EndNote { get; public set; }
    public short CellError { get; public set; }
    public short Copies { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public PrintSetupRecord(RecordInputStream in1);
    public short get_PaperSize();
    public void set_PaperSize(short value);
    public short get_Scale();
    public void set_Scale(short value);
    public short get_PageStart();
    public void set_PageStart(short value);
    public short get_FitWidth();
    public void set_FitWidth(short value);
    public short get_FitHeight();
    public void set_FitHeight(short value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_LeftToRight();
    public void set_LeftToRight(bool value);
    public bool get_Landscape();
    public void set_Landscape(bool value);
    public bool get_ValidSettings();
    public void set_ValidSettings(bool value);
    public bool get_NoColor();
    public void set_NoColor(bool value);
    public bool get_Draft();
    public void set_Draft(bool value);
    public bool get_Notes();
    public void set_Notes(bool value);
    public bool get_NoOrientation();
    public void set_NoOrientation(bool value);
    public bool get_UsePage();
    public void set_UsePage(bool value);
    public short get_HResolution();
    public void set_HResolution(short value);
    public short get_VResolution();
    public void set_VResolution(short value);
    public double get_HeaderMargin();
    public void set_HeaderMargin(double value);
    public double get_FooterMargin();
    public void set_FooterMargin(double value);
    public bool get_EndNote();
    public void set_EndNote(bool value);
    public short get_CellError();
    public void set_CellError(short value);
    public short get_Copies();
    public void set_Copies(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.PrintSizeRecord : StandardRecord {
    public static short sid;
    private short printSize;
    public short PrintSize { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public PrintSizeRecord(RecordInputStream in1);
    public short get_PrintSize();
    public void set_PrintSize(short value);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.ProtectionRev4Record : StandardRecord {
    public static short sid;
    private static BitField protectedFlag;
    private short _options;
    public bool Protect { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public ProtectionRev4Record(short options);
    public ProtectionRev4Record(bool protect);
    public ProtectionRev4Record(RecordInputStream in1);
    private static ProtectionRev4Record();
    public bool get_Protect();
    public void set_Protect(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.ProtectRecord : StandardRecord {
    public static short sid;
    private static BitField protectFlag;
    private short _options;
    public bool Protect { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public ProtectRecord(short options);
    public ProtectRecord(RecordInputStream in1);
    public ProtectRecord(bool isProtected);
    private static ProtectRecord();
    public bool get_Protect();
    public void set_Protect(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.RecalcIdRecord : StandardRecord {
    public static short sid;
    private int _reserved0;
    private int _engineId;
    public bool IsNeeded { get; }
    public int EngineId { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public RecalcIdRecord(RecordInputStream in1);
    public bool get_IsNeeded();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    public void set_EngineId(int value);
    public int get_EngineId();
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public abstract class NPOI.HSSF.Record.Record : RecordBase {
    public short Sid { get; }
    public Byte[] Serialize();
    public abstract virtual short get_Sid();
    public virtual object Clone();
    public Record CloneViaReserialise();
}
public abstract class NPOI.HSSF.Record.RecordBase : object {
    public int RecordSize { get; }
    public abstract virtual int Serialize(int offset, Byte[] data);
    public abstract virtual int get_RecordSize();
}
public class NPOI.HSSF.Record.RecordFactory : object {
    private static int NUM_RECORDS;
    private static Type[] recordClasses;
    private static Type[] CONSTRUCTOR_ARGS;
    private static Dictionary`2<short, I_RecordCreator> _recordCreatorsById;
    private static Int16[] _allKnownRecordSIDs;
    private static RecordFactory();
    public static Type GetRecordClass(int sid);
    public static void SetCapacity(int capacity);
    public static List`1<Record> CreateRecords(Stream in1);
    [ObsoleteAttribute]
private static void AddAll(List`1<Record> destList, Record[] srcRecs);
    public static Record[] CreateRecord(RecordInputStream in1);
    public static BlankRecord[] ConvertBlankRecords(MulBlankRecord mbk);
    public static Record CreateSingleRecord(RecordInputStream in1);
    public static NumberRecord ConvertToNumberRecord(RKRecord rk);
    public static NumberRecord[] ConvertRKRecords(MulRKRecord mrk);
    public static Int16[] GetAllKnownRecordSIDs();
    private static Dictionary`2<short, I_RecordCreator> RecordsToMap(Type[] records);
    [ObsoleteAttribute]
private static void CheckZeros(Stream in1, int avail);
    private static I_RecordCreator GetRecordCreator(Type recClass);
}
public class NPOI.HSSF.Record.RecordFactoryInputStream : object {
    private RecordInputStream _recStream;
    private bool _shouldIncludeContinueRecords;
    private Record[] _unreadRecordBuffer;
    private int _unreadRecordIndex;
    private Record _lastRecord;
    private DrawingRecord _lastDrawingRecord;
    private int _bofDepth;
    private bool _lastRecordWasEOFLevelZero;
    public RecordFactoryInputStream(Stream in1, bool shouldIncludeContinueRecords);
    public Record NextRecord();
    private Record GetNextUnreadRecord();
    private Record ReadNextRecord();
}
public class NPOI.HSSF.Record.RecordInputStream : Stream {
    public static short MAX_RECORD_DATA_SIZE;
    private static int INVALID_SID_VALUE;
    private static int DATA_LEN_NEEDS_TO_BE_READ;
    protected int _currentSid;
    protected int _currentDataLength;
    protected int _nextSid;
    private int _currentDataOffset;
    private long pos;
    private BiffHeaderInput _bhi;
    private ILittleEndianInput _dataInput;
    public short Sid { get; }
    public long Position { get; public set; }
    public long CurrentLength { get; }
    public int RecordOffset { get; }
    public bool HasNextRecord { get; }
    public int Remaining { get; }
    public bool IsContinueNext { get; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public RecordInputStream(Stream in1);
    public RecordInputStream(Stream in1, Biff8EncryptionKey key, int initialOffset);
    public sealed virtual int Available();
    public int Read();
    private int ReadNextSid();
    public short get_Sid();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public long get_CurrentLength();
    public int get_RecordOffset();
    public virtual long Seek(long offset, SeekOrigin origin);
    public bool get_HasNextRecord();
    public void NextRecord();
    protected void CheckRecordPosition(int requiredByteCount);
    public virtual int ReadByte();
    public sealed virtual short ReadShort();
    public sealed virtual int ReadInt();
    public sealed virtual long ReadLong();
    public sealed virtual int ReadUByte();
    public sealed virtual int ReadUShort();
    public sealed virtual double ReadDouble();
    public sealed virtual void ReadFully(Byte[] buf);
    public sealed virtual void ReadFully(Byte[] buf, int off, int len);
    public string ReadUnicodeLEString(int requestedLength);
    public string ReadCompressedUnicode(int requestedLength);
    private string ReadStringCommon(int requestedLength, bool pIsCompressedEncoding);
    public string ReadString();
    public Byte[] ReadRemainder();
    public Byte[] ReadAllContinuedRemainder();
    public int get_Remaining();
    public bool get_IsContinueNext();
    public virtual long get_Length();
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] b, int off, int len);
    public int GetNextSid();
}
internal class NPOI.HSSF.Record.RecordSizeListener : object {
    private IList`1<int> spEndingOffsets;
    private EscherRecord record;
    public RecordSizeListener(IList`1<int> spEndingOffsets, EscherRecord e);
    private sealed virtual override void NPOI.DDF.EscherSerializationListener.BeforeRecordSerialize(int offset, short recordId, EscherRecord record);
    private sealed virtual override void NPOI.DDF.EscherSerializationListener.AfterRecordSerialize(int offset, short recordId, int size, EscherRecord record);
}
public class NPOI.HSSF.Record.RefModeRecord : StandardRecord {
    public static short sid;
    public static short USE_A1_MODE;
    public static short USE_R1C1_MODE;
    private short field_1_mode;
    public short Mode { get; public set; }
    public short Sid { get; }
    protected int DataSize { get; }
    public RefModeRecord(RecordInputStream in1);
    public short get_Mode();
    public void set_Mode(short value);
    public virtual string ToString();
    public virtual short get_Sid();
    public virtual object Clone();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.RefreshAllRecord : StandardRecord {
    public static short sid;
    private static BitField refreshFlag;
    private int _options;
    public bool RefreshAll { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public RefreshAllRecord(int options);
    public RefreshAllRecord(RecordInputStream in1);
    public RefreshAllRecord(bool refreshAll);
    private static RefreshAllRecord();
    public bool get_RefreshAll();
    public void set_RefreshAll(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.RefSubRecord : object {
    public static int ENCODED_SIZE;
    private int _extBookIndex;
    private int _firstSheetIndex;
    private int _lastSheetIndex;
    public int ExtBookIndex { get; }
    public int FirstSheetIndex { get; }
    public int LastSheetIndex { get; }
    public RefSubRecord(int extBookIndex, int firstSheetIndex, int lastSheetIndex);
    public RefSubRecord(RecordInputStream in1);
    public void AdjustIndex(int offset);
    public int get_ExtBookIndex();
    public int get_FirstSheetIndex();
    public int get_LastSheetIndex();
    public virtual string ToString();
    public void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.RightMarginRecord : StandardRecord {
    public static short sid;
    private double field_1_margin;
    public short Sid { get; }
    protected int DataSize { get; }
    public double Margin { get; public set; }
    public RightMarginRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public sealed virtual double get_Margin();
    public sealed virtual void set_Margin(double value);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.RKRecord : CellRecord {
    public static short sid;
    public static short RK_IEEE_NUMBER;
    public static short RK_IEEE_NUMBER_TIMES_100;
    public static short RK_INTEGER;
    public static short RK_INTEGER_TIMES_100;
    private int field_4_rk_number;
    public int RKField { get; }
    public short RKType { get; }
    public double RKNumber { get; }
    protected string RecordName { get; }
    protected int ValueDataSize { get; }
    public short Sid { get; }
    public RKRecord(RecordInputStream in1);
    public int get_RKField();
    public short get_RKType();
    public double get_RKNumber();
    protected virtual string get_RecordName();
    protected virtual void AppendValueText(StringBuilder sb);
    protected virtual void SerializeValue(ILittleEndianOutput out1);
    protected virtual int get_ValueDataSize();
    public virtual short get_Sid();
    public object Clone();
}
public abstract class NPOI.HSSF.Record.RowDataRecord : StandardRecord {
    private Byte[] _rawData;
    protected int DataSize { get; }
    public short Sid { get; }
    public RowDataRecord(RecordInputStream in1);
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.RowRecord : StandardRecord {
    public static short sid;
    public static int ENCODED_SIZE;
    private static int OPTION_BITS_ALWAYS_SET;
    [ObsoleteAttribute]
public static int MAX_ROW_NUMBER;
    private int field_1_row_number;
    private int field_2_first_col;
    private int field_3_last_col;
    private short field_4_height;
    private short field_5_optimize;
    private short field_6_reserved;
    private int field_7_option_flags;
    private static BitField outlineLevel;
    private static BitField colapsed;
    private static BitField zeroHeight;
    private static BitField badFontHeight;
    private static BitField formatted;
    private int field_8_option_flags;
    private static BitField xfIndex;
    private static BitField topBorder;
    private static BitField bottomBorder;
    private static BitField phoeneticGuide;
    public bool IsEmpty { get; }
    public int RowNumber { get; public set; }
    public int FirstCol { get; public set; }
    public int LastCol { get; public set; }
    public short Height { get; public set; }
    public short Optimize { get; public set; }
    public short OptionFlags { get; public set; }
    public short OutlineLevel { get; public set; }
    public bool Colapsed { get; public set; }
    public bool ZeroHeight { get; public set; }
    public bool BadFontHeight { get; public set; }
    public bool Formatted { get; public set; }
    public short OptionFlags2 { get; }
    public short XFIndex { get; public set; }
    public bool TopBorder { get; public set; }
    public bool BottomBorder { get; public set; }
    public bool PhoeneticGuide { get; public set; }
    protected int DataSize { get; }
    public int RecordSize { get; }
    public short Sid { get; }
    public RowRecord(int rowNumber);
    public RowRecord(RecordInputStream in1);
    private static RowRecord();
    public void SetEmpty();
    public bool get_IsEmpty();
    public int get_RowNumber();
    public void set_RowNumber(int value);
    public int get_FirstCol();
    public void set_FirstCol(int value);
    public int get_LastCol();
    public void set_LastCol(int value);
    public short get_Height();
    public void set_Height(short value);
    public short get_Optimize();
    public void set_Optimize(short value);
    public short get_OptionFlags();
    public void set_OptionFlags(short value);
    public short get_OutlineLevel();
    public void set_OutlineLevel(short value);
    public bool get_Colapsed();
    public void set_Colapsed(bool value);
    public bool get_ZeroHeight();
    public void set_ZeroHeight(bool value);
    public bool get_BadFontHeight();
    public void set_BadFontHeight(bool value);
    public bool get_Formatted();
    public void set_Formatted(bool value);
    public short get_OptionFlags2();
    public short get_XFIndex();
    public void set_XFIndex(short value);
    public bool get_TopBorder();
    public void set_TopBorder(bool value);
    public bool get_BottomBorder();
    public void set_BottomBorder(bool value);
    public bool get_PhoeneticGuide();
    public void set_PhoeneticGuide(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual int get_RecordSize();
    public virtual short get_Sid();
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.SaveRecalcRecord : StandardRecord {
    public static short sid;
    private short field_1_recalc;
    public bool Recalc { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public SaveRecalcRecord(RecordInputStream in1);
    public bool get_Recalc();
    public void set_Recalc(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.ScenarioProtectRecord : StandardRecord {
    public static short sid;
    private short field_1_protect;
    public bool Protect { get; public set; }
    public short Sid { get; }
    protected int DataSize { get; }
    public ScenarioProtectRecord(RecordInputStream in1);
    public bool get_Protect();
    public void set_Protect(bool value);
    public virtual short get_Sid();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.SCLRecord : StandardRecord {
    public static short sid;
    private short field_1_numerator;
    private short field_2_denominator;
    protected int DataSize { get; }
    public short Sid { get; }
    public short Numerator { get; public set; }
    public short Denominator { get; public set; }
    public SCLRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_Numerator();
    public void set_Numerator(short value);
    public short get_Denominator();
    public void set_Denominator(short value);
}
public class NPOI.HSSF.Record.ScrollableObjectSubRecord : SubRecord {
    private short field_1_iVal;
    private short field_2_iMin;
    private short field_3_iMax;
    private short field_4_dInc;
    private short field_5_dPage;
    private short field_6_fHoriz;
    private short field_7_dxScroll;
    private short field_8_options;
    private BitField fDrawFlag;
    private BitField fDrawSliderOnly;
    private BitField fTrackElevator;
    private BitField fNo3d;
    public static short sid;
    public int DataSize { get; }
    public short Sid { get; }
    public short CurrentValue { get; public set; }
    public short MaxValue { get; public set; }
    public short MinValue { get; public set; }
    public short IncreaseAmountChanged { get; public set; }
    public short PageAmountChanged { get; public set; }
    public bool IsHorizontal { get; public set; }
    public short ScrollbarWidthInPixel { get; public set; }
    public bool IsVisible { get; public set; }
    public bool IsOnlySilderPortionVisible { get; public set; }
    public bool IsTrackElevator { get; public set; }
    public bool IsNo3D { get; public set; }
    public ScrollableObjectSubRecord(ILittleEndianInput in1, int size);
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public short get_CurrentValue();
    public void set_CurrentValue(short value);
    public short get_MaxValue();
    public void set_MaxValue(short value);
    public short get_MinValue();
    public void set_MinValue(short value);
    public short get_IncreaseAmountChanged();
    public void set_IncreaseAmountChanged(short value);
    public short get_PageAmountChanged();
    public void set_PageAmountChanged(short value);
    public bool get_IsHorizontal();
    public void set_IsHorizontal(bool value);
    public short get_ScrollbarWidthInPixel();
    public void set_ScrollbarWidthInPixel(short value);
    public bool get_IsVisible();
    public void set_IsVisible(bool value);
    public bool get_IsOnlySilderPortionVisible();
    public void set_IsOnlySilderPortionVisible(bool value);
    public bool get_IsTrackElevator();
    public void set_IsTrackElevator(bool value);
    public bool get_IsNo3D();
    public void set_IsNo3D(bool value);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.SelectionRecord : StandardRecord {
    public static short sid;
    private byte field_1_pane;
    private int field_2_row_active_cell;
    private int field_3_col_active_cell;
    private int field_4_ref_active_cell;
    private CellRangeAddress8Bit[] field_6_refs;
    public byte Pane { get; public set; }
    public int ActiveCellRow { get; public set; }
    public int ActiveCellCol { get; public set; }
    public int ActiveCellRef { get; public set; }
    public CellRangeAddress8Bit[] CellReferences { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public SelectionRecord(int activeCellRow, int activeCellCol);
    public SelectionRecord(RecordInputStream in1);
    public byte get_Pane();
    public void set_Pane(byte value);
    public int get_ActiveCellRow();
    public void set_ActiveCellRow(int value);
    public int get_ActiveCellCol();
    public void set_ActiveCellCol(int value);
    public int get_ActiveCellRef();
    public void set_ActiveCellRef(int value);
    public CellRangeAddress8Bit[] get_CellReferences();
    public void set_CellReferences(CellRangeAddress8Bit[] value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
internal class NPOI.HSSF.Record.SerializationListener : object {
    private IList`1<int> spEndingOffsets;
    private IList`1<EscherRecord> records;
    private EscherRecord record;
    public SerializationListener(IList`1<int> spEndingOffsets, IList`1<EscherRecord> records, EscherRecord e);
    private sealed virtual override void NPOI.DDF.EscherSerializationListener.BeforeRecordSerialize(int offset, short recordId, EscherRecord record);
    private sealed virtual override void NPOI.DDF.EscherSerializationListener.AfterRecordSerialize(int offset, short recordId, int size, EscherRecord record);
}
public class NPOI.HSSF.Record.SharedFormulaRecord : SharedValueRecordBase {
    public static short sid;
    private int field_5_reserved;
    private Formula field_7_parsed_expr;
    protected int ExtraDataSize { get; }
    public short Sid { get; }
    private SharedFormulaRecord(CellRangeAddress8Bit range);
    public SharedFormulaRecord(RecordInputStream in1);
    protected virtual int get_ExtraDataSize();
    public virtual string ToString();
    public virtual short get_Sid();
    public virtual object Clone();
    protected virtual void SerializeExtraData(ILittleEndianOutput out1);
    public Ptg[] GetFormulaTokens(FormulaRecord formula);
    public bool IsFormulaSame(SharedFormulaRecord other);
}
public abstract class NPOI.HSSF.Record.SharedValueRecordBase : StandardRecord {
    private CellRangeAddress8Bit _range;
    public CellRangeAddress8Bit Range { get; }
    public int FirstRow { get; }
    public int LastRow { get; }
    public int FirstColumn { get; }
    public int LastColumn { get; }
    protected int DataSize { get; }
    protected int ExtraDataSize { get; }
    protected SharedValueRecordBase(CellRangeAddress8Bit range);
    public SharedValueRecordBase(RecordInputStream in1);
    public CellRangeAddress8Bit get_Range();
    public virtual int get_FirstRow();
    public virtual int get_LastRow();
    public virtual int get_FirstColumn();
    public virtual int get_LastColumn();
    protected virtual int get_DataSize();
    protected abstract virtual int get_ExtraDataSize();
    protected abstract virtual void SerializeExtraData(ILittleEndianOutput out1);
    public virtual void Serialize(ILittleEndianOutput out1);
    public bool IsInRange(int rowIx, int colIx);
    public bool IsFirstCell(int rowIx, int colIx);
}
public class NPOI.HSSF.Record.SheetExtRecord : StandardRecord {
    private short rt;
    private short grbitFrt;
    private int cb;
    private BitField icvPlain;
    private short optionflag;
    private short optionflag2;
    private BitField icvPlain12;
    private BitField fCondFmtCalc;
    private BitField fNotPublished;
    private int xclrType;
    private int xclrValue;
    private long numTint;
    public static short sid;
    public short TabColorIndex { get; public set; }
    public bool IsAutoColor { get; public set; }
    public bool EvaluateConditionalFormatting { get; public set; }
    public bool IsSheetPublished { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public SheetExtRecord(RecordInputStream in1);
    public short get_TabColorIndex();
    public void set_TabColorIndex(short value);
    public bool get_IsAutoColor();
    public void set_IsAutoColor(bool value);
    public bool get_EvaluateConditionalFormatting();
    public void set_EvaluateConditionalFormatting(bool value);
    public bool get_IsSheetPublished();
    public void set_IsSheetPublished(bool value);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual string ToString();
    public virtual object Clone();
}
internal class NPOI.HSSF.Record.SimpleHeaderInput : object {
    private ILittleEndianInput _lei;
    public SimpleHeaderInput(Stream in1);
    internal static ILittleEndianInput GetLEI(Stream in1);
    public sealed virtual int Available();
    public sealed virtual int ReadDataSize();
    public sealed virtual int ReadRecordSID();
}
internal class NPOI.HSSF.Record.SpecialCachedValue : object {
    private static long BIT_MARKER;
    private static int VARIABLE_DATA_LENGTH;
    private static int DATA_INDEX;
    public static int STRING;
    public static int BOOLEAN;
    public static int ERROR_CODE;
    public static int EMPTY;
    private Byte[] _variableData;
    public string FormatDebugString { get; }
    private string FormatValue { get; }
    private int DataValue { get; }
    private SpecialCachedValue(Byte[] data);
    public int GetTypeCode();
    public static SpecialCachedValue Create(long valueLongBits);
    public void Serialize(ILittleEndianOutput out1);
    public string get_FormatDebugString();
    private string get_FormatValue();
    private int get_DataValue();
    public static SpecialCachedValue CreateCachedEmptyValue();
    public static SpecialCachedValue CreateForString();
    public static SpecialCachedValue CreateCachedBoolean(bool b);
    public static SpecialCachedValue CreateCachedErrorCode(int errorCode);
    private static SpecialCachedValue Create(int code, int data);
    public virtual string ToString();
    public CellType GetValueType();
    public bool GetBooleanValue();
    public int GetErrorValue();
}
public class NPOI.HSSF.Record.SSTDeserializer : object {
    private IntMapper`1<UnicodeString> strings;
    public SSTDeserializer(IntMapper`1<UnicodeString> strings);
    public void ManufactureStrings(int stringCount, RecordInputStream in1);
    public static void AddToStringTable(IntMapper`1<UnicodeString> strings, UnicodeString str);
}
public class NPOI.HSSF.Record.SSTRecord : ContinuableRecord {
    public static short sid;
    private static UnicodeString EMPTY_STRING;
    public static int MAX_RECORD_SIZE;
    public static int STD_RECORD_OVERHEAD;
    public static int SST_RECORD_OVERHEAD;
    public static int MAX_DATA_SPACE;
    private int field_1_num_strings;
    private int field_2_num_unique_strings;
    private IntMapper`1<UnicodeString> field_3_strings;
    private SSTDeserializer deserializer;
    private Int32[] bucketAbsoluteOffsets;
    private Int32[] bucketRelativeOffsets;
    public int NumStrings { get; public set; }
    public int NumUniqueStrings { get; public set; }
    public short Sid { get; }
    public int CountStrings { get; }
    public SSTRecord(RecordInputStream in1);
    private static SSTRecord();
    public int AddString(UnicodeString str);
    public int get_NumStrings();
    public void set_NumStrings(int value);
    public int get_NumUniqueStrings();
    public void set_NumUniqueStrings(int value);
    public UnicodeString GetString(int id);
    public bool IsString16bit(int id);
    public virtual string ToString();
    public virtual short get_Sid();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public IEnumerator GetStrings();
    public int get_CountStrings();
    protected virtual void Serialize(ContinuableRecordOutput out1);
    private SSTDeserializer GetDeserializer();
    public ExtSSTRecord CreateExtSSTRecord(int sstOffset);
    public int CalcExtSSTRecordSize();
}
public class NPOI.HSSF.Record.SSTSerializer : object {
    private int _numStrings;
    private int _numUniqueStrings;
    private IntMapper`1<UnicodeString> strings;
    private Int32[] bucketAbsoluteOffsets;
    private Int32[] bucketRelativeOffsets;
    public Int32[] BucketAbsoluteOffsets { get; }
    public Int32[] BucketRelativeOffsets { get; }
    public SSTSerializer(IntMapper`1<UnicodeString> strings, int numStrings, int numUniqueStrings);
    public void Serialize(ContinuableRecordOutput out1);
    private UnicodeString GetUnicodeString(int index);
    private static UnicodeString GetUnicodeString(IntMapper`1<UnicodeString> strings, int index);
    public Int32[] get_BucketAbsoluteOffsets();
    public Int32[] get_BucketRelativeOffsets();
}
public abstract class NPOI.HSSF.Record.StandardRecord : Record {
    protected int DataSize { get; }
    public int RecordSize { get; }
    protected abstract virtual int get_DataSize();
    public virtual int get_RecordSize();
    public virtual int Serialize(int offset, Byte[] data);
    public abstract virtual void Serialize(ILittleEndianOutput out1);
}
public class NPOI.HSSF.Record.StringRecord : ContinuableRecord {
    public static short sid;
    private bool _is16bitUnicode;
    private string _text;
    public short Sid { get; }
    public string String { get; public set; }
    public StringRecord(RecordInputStream in1);
    protected virtual void Serialize(ContinuableRecordOutput out1);
    public virtual short get_Sid();
    public string get_String();
    public void set_String(string value);
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.StyleRecord : StandardRecord {
    public static short sid;
    private static BitField styleIndexMask;
    private static BitField isBuiltinFlag;
    private int field_1_xf_index;
    private int field_2_builtin_style;
    private int field_3_outline_style_level;
    private bool field_3_stringHasMultibyte;
    private string field_4_name;
    public bool IsBuiltin { get; }
    public short XFIndex { get; public set; }
    public string Name { get; public set; }
    public int OutlineStyleLevel { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public StyleRecord(RecordInputStream in1);
    private static StyleRecord();
    public bool get_IsBuiltin();
    public void SetBuiltinStyle(int builtinStyleId);
    public short get_XFIndex();
    public void set_XFIndex(short value);
    public string get_Name();
    public void set_Name(string value);
    public int get_OutlineStyleLevel();
    public void set_OutlineStyleLevel(int value);
    public virtual string ToString();
    private short SetField(int fieldValue, int new_value, int mask, int ShiftLeft);
    public virtual void Serialize(ILittleEndianOutput o);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public abstract class NPOI.HSSF.Record.SubRecord : object {
    public short Sid { get; }
    public int DataSize { get; }
    public bool IsTerminating { get; }
    public static SubRecord CreateSubRecord(ILittleEndianInput in1, CommonObjectType cmoOt);
    public abstract virtual short get_Sid();
    public abstract virtual int get_DataSize();
    public abstract virtual void Serialize(ILittleEndianOutput out1);
    public Byte[] Serialize();
    public virtual bool get_IsTerminating();
    public abstract virtual object Clone();
}
public class NPOI.HSSF.Record.SupBookRecord : StandardRecord {
    private static POILogger logger;
    public static short sid;
    private static short SMALL_RECORD_SIZE;
    private static short TAG_INTERNAL_REFERENCES;
    private static short TAG_ADD_IN_FUNCTIONS;
    private short field_1_number_of_sheets;
    private string field_2_encoded_url;
    private String[] field_3_sheet_names;
    private bool _isAddInFunctions;
    public static char CH_VOLUME;
    public static char CH_SAME_VOLUME;
    public static char CH_DOWN_DIR;
    public static char CH_UP_DIR;
    public static char CH_LONG_VOLUME;
    public static char CH_STARTUP_DIR;
    public static char CH_ALT_STARTUP_DIR;
    public static char CH_LIB_DIR;
    public static char PATH_SEPERATOR;
    public bool IsExternalReferences { get; }
    public bool IsInternalReferences { get; }
    public bool IsAddInFunctions { get; }
    protected int DataSize { get; }
    public short NumberOfSheets { get; public set; }
    public short Sid { get; }
    public string URL { get; public set; }
    public String[] SheetNames { get; }
    private SupBookRecord(bool IsAddInFuncs, short numberOfSheets);
    public SupBookRecord(string url, String[] sheetNames);
    public SupBookRecord(RecordInputStream in1);
    private static SupBookRecord();
    public static SupBookRecord CreateInternalReferences(short numberOfSheets);
    public static SupBookRecord CreateAddInFunctions();
    public static SupBookRecord CreateExternalReferences(string url, String[] sheetNames);
    public bool get_IsExternalReferences();
    public bool get_IsInternalReferences();
    public bool get_IsAddInFunctions();
    public virtual string ToString();
    protected virtual int get_DataSize();
    public virtual void Serialize(ILittleEndianOutput out1);
    public short get_NumberOfSheets();
    public void set_NumberOfSheets(short value);
    public virtual short get_Sid();
    public string get_URL();
    public void set_URL(string value);
    private static string DecodeFileName(string encodedUrl);
    public String[] get_SheetNames();
}
public class NPOI.HSSF.Record.TabIdRecord : StandardRecord {
    public static short sid;
    private static Int16[] EMPTY_SHORT_ARRAY;
    public Int16[] _tabids;
    protected int DataSize { get; }
    public short Sid { get; }
    public TabIdRecord(RecordInputStream in1);
    private static TabIdRecord();
    public void SetTabIdArray(Int16[] array);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.TableRecord : SharedValueRecordBase {
    public static short sid;
    private static BitField alwaysCalc;
    private static BitField calcOnOpen;
    private static BitField rowOrColInpCell;
    private static BitField oneOrTwoVar;
    private static BitField rowDeleted;
    private static BitField colDeleted;
    private int field_5_flags;
    private int field_6_res;
    private int field_7_rowInputRow;
    private int field_8_colInputRow;
    private int field_9_rowInputCol;
    private int field_10_colInputCol;
    public int Flags { get; public set; }
    public int RowInputRow { get; public set; }
    public int ColInputRow { get; public set; }
    public int RowInputCol { get; public set; }
    public int ColInputCol { get; public set; }
    public bool IsAlwaysCalc { get; public set; }
    public bool IsRowOrColInpCell { get; public set; }
    public bool IsOneNotTwoVar { get; public set; }
    public bool IsColDeleted { get; public set; }
    public bool IsRowDeleted { get; public set; }
    public short Sid { get; }
    protected int ExtraDataSize { get; }
    public TableRecord(RecordInputStream in1);
    public TableRecord(CellRangeAddress8Bit range);
    private static TableRecord();
    public int get_Flags();
    public void set_Flags(int value);
    public int get_RowInputRow();
    public void set_RowInputRow(int value);
    public int get_ColInputRow();
    public void set_ColInputRow(int value);
    public int get_RowInputCol();
    public void set_RowInputCol(int value);
    public int get_ColInputCol();
    public void set_ColInputCol(int value);
    public bool get_IsAlwaysCalc();
    public void set_IsAlwaysCalc(bool value);
    public bool get_IsRowOrColInpCell();
    public void set_IsRowOrColInpCell(bool value);
    public bool get_IsOneNotTwoVar();
    public void set_IsOneNotTwoVar(bool value);
    public bool get_IsColDeleted();
    public void set_IsColDeleted(bool value);
    public bool get_IsRowDeleted();
    public void set_IsRowDeleted(bool value);
    public virtual short get_Sid();
    protected virtual int get_ExtraDataSize();
    protected virtual void SerializeExtraData(ILittleEndianOutput out1);
    public virtual string ToString();
    private static CellReference cr(int rowIx, int colIxAndFlags);
}
public class NPOI.HSSF.Record.TableStylesRecord : StandardRecord {
    public static short sid;
    private int rt;
    private int grbitFrt;
    private Byte[] unused;
    private int cts;
    private string rgchDefListStyle;
    private string rgchDefPivotStyle;
    protected int DataSize { get; }
    public short Sid { get; }
    public TableStylesRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.TextObjectRecord : ContinuableRecord {
    private IRichTextString _text;
    public static short sid;
    private static int FORMAT_RUN_ENCODED_SIZE;
    private BitField _HorizontalTextAlignment;
    private BitField _VerticalTextAlignment;
    private BitField textLocked;
    private int field_1_options;
    private int field_2_textOrientation;
    private int field_3_reserved4;
    private int field_4_reserved5;
    private int field_5_reserved6;
    private int field_8_reserved7;
    private int _unknownPreFormulaInt;
    private OperandPtg _linkRefPtg;
    private Nullable`1<byte> _unknownPostFormulaByte;
    private int TrailingRecordsSize { get; }
    private int FormattingDataLength { get; }
    public IRichTextString Str { get; public set; }
    public short Sid { get; }
    public TextOrientation TextOrientation { get; public set; }
    public HorizontalTextAlignment HorizontalTextAlignment { get; public set; }
    public VerticalTextAlignment VerticalTextAlignment { get; public set; }
    public bool IsTextLocked { get; public set; }
    public Ptg LinkRefPtg { get; }
    public TextObjectRecord(RecordInputStream in1);
    private static void ProcessFontRuns(RecordInputStream in1, IRichTextString str, int formattingRunDataLength);
    private int get_TrailingRecordsSize();
    private static Byte[] CreateFormatData(IRichTextString str);
    private void SerializeTrailingRecords(ContinuableRecordOutput out1);
    private void WriteFormatData(ContinuableRecordOutput out1, IRichTextString str);
    private int get_FormattingDataLength();
    private void SerializeTXORecord(ContinuableRecordOutput out1);
    protected virtual void Serialize(ContinuableRecordOutput out1);
    private void ProcessFontRuns(RecordInputStream in1);
    private static string ReadRawString(RecordInputStream in1, int textLength);
    public IRichTextString get_Str();
    public void set_Str(IRichTextString value);
    public virtual short get_Sid();
    public TextOrientation get_TextOrientation();
    public void set_TextOrientation(TextOrientation value);
    public HorizontalTextAlignment get_HorizontalTextAlignment();
    public void set_HorizontalTextAlignment(HorizontalTextAlignment value);
    public VerticalTextAlignment get_VerticalTextAlignment();
    public void set_VerticalTextAlignment(VerticalTextAlignment value);
    public bool get_IsTextLocked();
    public void set_IsTextLocked(bool value);
    public Ptg get_LinkRefPtg();
    public virtual string ToString();
    public virtual object Clone();
}
public enum NPOI.HSSF.Record.TextOrientation : Enum {
    public int value__;
    public static TextOrientation None;
    public static TextOrientation TopToBottom;
    public static TextOrientation RotRight;
    public static TextOrientation RotLeft;
}
public class NPOI.HSSF.Record.TextRecord : StandardRecord {
    public static short sid;
    private byte field_1_horizontalAlignment;
    public static byte HORIZONTAL_ALIGNMENT_LEFT;
    public static byte HORIZONTAL_ALIGNMENT_CENTER;
    public static byte HORIZONTAL_ALIGNMENT_BOTTOM;
    public static byte HORIZONTAL_ALIGNMENT_JUSTIFY;
    public static byte HORIZONTAL_ALIGNMENT_DISTRIBUTED;
    private byte field_2_verticalAlignment;
    public static byte VERTICAL_ALIGNMENT_TOP;
    public static byte VERTICAL_ALIGNMENT_CENTER;
    public static byte VERTICAL_ALIGNMENT_BOTTOM;
    public static byte VERTICAL_ALIGNMENT_JUSTIFY;
    public static byte VERTICAL_ALIGNMENT_DISTRIBUTED;
    private short field_3_DisplayMode;
    public static short DISPLAY_MODE_TRANSPARENT;
    public static short DISPLAY_MODE_OPAQUE;
    private int field_4_rgbColor;
    private int field_5_x;
    private int field_6_y;
    private int field_7_width;
    private int field_8_height;
    private short field_9_options1;
    private BitField autoColor;
    private BitField showKey;
    private BitField showValue;
    private BitField autoText;
    private BitField generated;
    private BitField autoLabelDeleted;
    private BitField autoBackground;
    public static short ROTATION_NONE;
    public static short ROTATION_TOP_TO_BOTTOM;
    public static short ROTATION_ROTATED_90_DEGREES;
    public static short ROTATION_ROTATED_90_DEGREES_CLOCKWISE;
    private BitField showCategoryLabelAsPercentage;
    private BitField showValueAsPercentage;
    private BitField showBubbleSizes;
    private BitField showLabel;
    private short field_10_IndexOfColorValue;
    private short field_11_options2;
    private BitField dataLabelPlacement;
    public static short DATA_LABEL_PLACEMENT_CHART_DEPENDENT;
    public static short DATA_LABEL_PLACEMENT_OUTSIDE;
    public static short DATA_LABEL_PLACEMENT_INSIDE;
    public static short DATA_LABEL_PLACEMENT_CENTER;
    public static short DATA_LABEL_PLACEMENT_AXIS;
    public static short DATA_LABEL_PLACEMENT_ABOVE;
    public static short DATA_LABEL_PLACEMENT_BELOW;
    public static short DATA_LABEL_PLACEMENT_LEFT;
    public static short DATA_LABEL_PLACEMENT_RIGHT;
    public static short DATA_LABEL_PLACEMENT_AUTO;
    public static short DATA_LABEL_PLACEMENT_USER_MOVED;
    private BitField readingOrder;
    public static short READING_ORDER_CONTEXT;
    public static short READING_ORDER_LTR;
    public static short READING_ORDER_RTL;
    private short field_12_textRotation;
    protected int DataSize { get; }
    public short Sid { get; }
    public byte HorizontalAlignment { get; public set; }
    public byte VerticalAlignment { get; public set; }
    public short DisplayMode { get; public set; }
    public int RgbColor { get; public set; }
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public short Options1 { get; public set; }
    public short IndexOfColorValue { get; public set; }
    public short Options2 { get; public set; }
    public short TextRotation { get; public set; }
    public bool IsAutoColor { get; public set; }
    public bool ShowKey { get; public set; }
    public bool ShowValue { get; public set; }
    public bool IsAutoGeneratedText { get; public set; }
    public bool IsGenerated { get; public set; }
    public bool IsAutoLabelDeleted { get; public set; }
    public bool IsAutoBackground { get; public set; }
    public bool ShowCategoryLabelAsPercentage { get; public set; }
    public bool ShowValueAsPercentage { get; public set; }
    public bool ShowBubbleSizes { get; public set; }
    public bool ShowLabel { get; public set; }
    public short DataLabelPlacement { get; public set; }
    public short ReadingOrder { get; public set; }
    public TextRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public byte get_HorizontalAlignment();
    public void set_HorizontalAlignment(byte value);
    public byte get_VerticalAlignment();
    public void set_VerticalAlignment(byte value);
    public short get_DisplayMode();
    public void set_DisplayMode(short value);
    public int get_RgbColor();
    public void set_RgbColor(int value);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public short get_Options1();
    public void set_Options1(short value);
    public short get_IndexOfColorValue();
    public void set_IndexOfColorValue(short value);
    public short get_Options2();
    public void set_Options2(short value);
    public short get_TextRotation();
    public void set_TextRotation(short value);
    public bool get_IsAutoColor();
    public void set_IsAutoColor(bool value);
    public bool get_ShowKey();
    public void set_ShowKey(bool value);
    public bool get_ShowValue();
    public void set_ShowValue(bool value);
    public bool get_IsAutoGeneratedText();
    public void set_IsAutoGeneratedText(bool value);
    public bool get_IsGenerated();
    public void set_IsGenerated(bool value);
    public bool get_IsAutoLabelDeleted();
    public void set_IsAutoLabelDeleted(bool value);
    public bool get_IsAutoBackground();
    public void set_IsAutoBackground(bool value);
    public bool get_ShowCategoryLabelAsPercentage();
    public void set_ShowCategoryLabelAsPercentage(bool value);
    public bool get_ShowValueAsPercentage();
    public void set_ShowValueAsPercentage(bool value);
    public bool get_ShowBubbleSizes();
    public void set_ShowBubbleSizes(bool value);
    public bool get_ShowLabel();
    public void set_ShowLabel(bool value);
    public short get_DataLabelPlacement();
    public void set_DataLabelPlacement(short value);
    public short get_ReadingOrder();
    public void set_ReadingOrder(short value);
}
public class NPOI.HSSF.Record.TickRecord : StandardRecord {
    public static short sid;
    private byte field_1_majorTickType;
    private byte field_2_minorTickType;
    private byte field_3_labelPosition;
    private byte field_4_background;
    private int field_5_labelColorRgb;
    private int field_6_zero1;
    private int field_7_zero2;
    private int field_8_zero3;
    private int field_9_zero4;
    private short field_10_options;
    private BitField autoTextColor;
    private BitField autoTextBackground;
    private BitField rotation;
    private BitField autorotate;
    private short field_11_tickColor;
    private short field_12_zero5;
    protected int DataSize { get; }
    public short Sid { get; }
    public byte MajorTickType { get; public set; }
    public byte MinorTickType { get; public set; }
    public byte LabelPosition { get; public set; }
    public byte Background { get; public set; }
    public int LabelColorRgb { get; public set; }
    public int Zero1 { get; public set; }
    public int Zero2 { get; public set; }
    public short Options { get; public set; }
    public short TickColor { get; public set; }
    public short Zero3 { get; public set; }
    public bool IsAutoTextColor { get; public set; }
    public bool IsAutoTextBackground { get; public set; }
    public short Rotation { get; public set; }
    public bool IsAutorotate { get; public set; }
    public TickRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public byte get_MajorTickType();
    public void set_MajorTickType(byte value);
    public byte get_MinorTickType();
    public void set_MinorTickType(byte value);
    public byte get_LabelPosition();
    public void set_LabelPosition(byte value);
    public byte get_Background();
    public void set_Background(byte value);
    public int get_LabelColorRgb();
    public void set_LabelColorRgb(int value);
    public int get_Zero1();
    public void set_Zero1(int value);
    public int get_Zero2();
    public void set_Zero2(int value);
    public short get_Options();
    public void set_Options(short value);
    public short get_TickColor();
    public void set_TickColor(short value);
    public short get_Zero3();
    public void set_Zero3(short value);
    public bool get_IsAutoTextColor();
    public void set_IsAutoTextColor(bool value);
    public bool get_IsAutoTextBackground();
    public void set_IsAutoTextBackground(bool value);
    public short get_Rotation();
    public void set_Rotation(short value);
    public bool get_IsAutorotate();
    public void set_IsAutorotate(bool value);
}
public class NPOI.HSSF.Record.TopMarginRecord : StandardRecord {
    public static short sid;
    private double field_1_margin;
    protected int DataSize { get; }
    public short Sid { get; }
    public double Margin { get; public set; }
    public TopMarginRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public sealed virtual double get_Margin();
    public sealed virtual void set_Margin(double value);
    public virtual object Clone();
}
public class NPOI.HSSF.Record.UncalcedRecord : StandardRecord {
    public static short sid;
    private short _reserved;
    public short Sid { get; }
    protected int DataSize { get; }
    public static int StaticRecordSize { get; }
    public UncalcedRecord(RecordInputStream in1);
    public virtual short get_Sid();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public static int get_StaticRecordSize();
}
public class NPOI.HSSF.Record.UnicodeString : object {
    private static POILogger _logger;
    private short field_1_charCount;
    private byte field_2_optionflags;
    private string field_3_string;
    private List`1<FormatRun> field_4_format_runs;
    private ExtRst field_5_ext_rst;
    private static BitField highByte;
    private static BitField extBit;
    private static BitField richText;
    public int CharCount { get; public set; }
    public short CharCountShort { get; }
    public byte OptionFlags { get; public set; }
    public string String { get; public set; }
    public int FormatRunCount { get; }
    public ExtRst ExtendedRst { get; public set; }
    private bool IsRichText { get; }
    private bool IsExtendedText { get; }
    public UnicodeString(string str);
    public UnicodeString(RecordInputStream in1);
    private static UnicodeString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public int get_CharCount();
    public void set_CharCount(int value);
    public short get_CharCountShort();
    public byte get_OptionFlags();
    public void set_OptionFlags(byte value);
    public string get_String();
    public void set_String(string value);
    public int get_FormatRunCount();
    public FormatRun GetFormatRun(int index);
    private int FindFormatRunAt(int characterPos);
    public void AddFormatRun(FormatRun r);
    public List`1<FormatRun> FormatIterator();
    public void RemoveFormatRun(FormatRun r);
    public void ClearFormatting();
    public ExtRst get_ExtendedRst();
    public void set_ExtendedRst(ExtRst value);
    public void SwapFontUse(short oldFontIndex, short newFontIndex);
    public virtual string ToString();
    public string GetDebugInfo();
    public void Serialize(ContinuableRecordOutput out1);
    public sealed virtual int CompareTo(UnicodeString str);
    private bool get_IsRichText();
    private bool get_IsExtendedText();
    public object Clone();
}
public class NPOI.HSSF.Record.UnitsRecord : StandardRecord {
    public static short sid;
    private short field_1_units;
    protected int DataSize { get; }
    public short Sid { get; }
    public short Units { get; public set; }
    public UnitsRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
    public short get_Units();
    public void set_Units(short value);
}
public class NPOI.HSSF.Record.UnknownRecord : StandardRecord {
    public static int PLS_004D;
    public static int SHEETPR_0081;
    public static int SORT_0090;
    public static int STANDARDWIDTH_0099;
    public static int BITMAP_00E9;
    public static int PHONETICPR_00EF;
    public static int LABELRANGES_015F;
    public static int QUICKTIP_0800;
    public static int SHEETPROTECTION_0867;
    public static int HEADER_FOOTER_089C;
    public static int CODENAME_1BA;
    public static int PLV_MAC;
    private int _sid;
    private Byte[] _rawData;
    protected int DataSize { get; }
    public short Sid { get; }
    public UnknownRecord(int id, Byte[] data);
    public UnknownRecord(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual string ToString();
    public static string GetBiffName(int sid);
    private static bool IsObservedButUnknown(int sid);
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.UnknownSubRecord : SubRecord {
    private int _sid;
    private Byte[] _data;
    public int DataSize { get; }
    public short Sid { get; }
    public UnknownSubRecord(ILittleEndianInput in1, int sid, int size);
    public virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual void Serialize(ILittleEndianOutput out1);
    public virtual object Clone();
    public virtual string ToString();
}
public class NPOI.HSSF.Record.UserSViewBegin : StandardRecord {
    public static short sid;
    private Byte[] _rawData;
    protected int DataSize { get; }
    public short Sid { get; }
    public Byte[] Guid { get; }
    public UserSViewBegin(Byte[] data);
    public UserSViewBegin(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public Byte[] get_Guid();
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.UserSViewEnd : StandardRecord {
    public static short sid;
    private Byte[] _rawData;
    protected int DataSize { get; }
    public short Sid { get; }
    public UserSViewEnd(Byte[] data);
    public UserSViewEnd(RecordInputStream in1);
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual string ToString();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.UseSelFSRecord : StandardRecord {
    public static short sid;
    private static BitField useNaturalLanguageFormulasFlag;
    private int _options;
    protected int DataSize { get; }
    public short Sid { get; }
    public UseSelFSRecord(int options);
    public UseSelFSRecord(RecordInputStream in1);
    public UseSelFSRecord(bool b);
    private static UseSelFSRecord();
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.VCenterRecord : StandardRecord {
    public static short sid;
    private short field_1_vcenter;
    public bool VCenter { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public VCenterRecord(RecordInputStream in1);
    public bool get_VCenter();
    public void set_VCenter(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.VerticalPageBreakRecord : PageBreakRecord {
    public static short sid;
    public short Sid { get; }
    public VerticalPageBreakRecord(RecordInputStream in1);
    public virtual short get_Sid();
    public virtual object Clone();
}
public enum NPOI.HSSF.Record.VerticalTextAlignment : Enum {
    public int value__;
    public static VerticalTextAlignment Top;
    public static VerticalTextAlignment Center;
    public static VerticalTextAlignment Bottom;
    public static VerticalTextAlignment Justify;
}
public class NPOI.HSSF.Record.WindowOneRecord : StandardRecord {
    public static short sid;
    private short field_1_h_hold;
    private short field_2_v_hold;
    private short field_3_width;
    private short field_4_height;
    private short field_5_options;
    private static BitField hidden;
    private static BitField iconic;
    private static BitField reserved;
    private static BitField hscroll;
    private static BitField vscroll;
    private static BitField tabs;
    private int field_6_active_sheet;
    private int field_7_first_visible_tab;
    private short field_8_num_selected_tabs;
    private short field_9_tab_width_ratio;
    public short HorizontalHold { get; public set; }
    public short VerticalHold { get; public set; }
    public short Width { get; public set; }
    public short Height { get; public set; }
    public short Options { get; public set; }
    public bool Hidden { get; public set; }
    public bool Iconic { get; public set; }
    public bool DisplayHorizontalScrollbar { get; public set; }
    public bool DisplayVerticalScrollbar { get; public set; }
    public bool DisplayTabs { get; public set; }
    public int ActiveSheetIndex { get; public set; }
    public int FirstVisibleTab { get; public set; }
    public short NumSelectedTabs { get; public set; }
    public short TabWidthRatio { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public WindowOneRecord(RecordInputStream in1);
    private static WindowOneRecord();
    public short get_HorizontalHold();
    public void set_HorizontalHold(short value);
    public short get_VerticalHold();
    public void set_VerticalHold(short value);
    public short get_Width();
    public void set_Width(short value);
    public short get_Height();
    public void set_Height(short value);
    public short get_Options();
    public void set_Options(short value);
    public bool get_Hidden();
    public void set_Hidden(bool value);
    public bool get_Iconic();
    public void set_Iconic(bool value);
    public bool get_DisplayHorizontalScrollbar();
    public void set_DisplayHorizontalScrollbar(bool value);
    public bool get_DisplayVerticalScrollbar();
    public void set_DisplayVerticalScrollbar(bool value);
    public bool get_DisplayTabs();
    public void set_DisplayTabs(bool value);
    public int get_ActiveSheetIndex();
    public void set_ActiveSheetIndex(int value);
    public int get_FirstVisibleTab();
    public void set_FirstVisibleTab(int value);
    public short get_NumSelectedTabs();
    public void set_NumSelectedTabs(short value);
    public short get_TabWidthRatio();
    public void set_TabWidthRatio(short value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.WindowProtectRecord : StandardRecord {
    public static short sid;
    private static BitField settingsProtectedFlag;
    private int _options;
    public bool Protect { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public WindowProtectRecord(int options);
    public WindowProtectRecord(RecordInputStream in1);
    public WindowProtectRecord(bool protect);
    private static WindowProtectRecord();
    public bool get_Protect();
    public void set_Protect(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.WindowTwoRecord : StandardRecord {
    public static short sid;
    private BitField displayFormulas;
    private BitField displayGridlines;
    private BitField displayRowColHeadings;
    private BitField freezePanes;
    private BitField displayZeros;
    private BitField defaultHeader;
    private BitField arabic;
    private BitField displayGuts;
    private BitField freezePanesNoSplit;
    private BitField selected;
    private BitField active;
    private BitField savedInPageBreakPreview;
    private short field_1_options;
    private short field_2_top_row;
    private short field_3_left_col;
    private int field_4_header_color;
    private short field_5_page_break_zoom;
    private short field_6_normal_zoom;
    private int field_7_reserved;
    public short Options { get; public set; }
    public bool DisplayFormulas { get; public set; }
    public bool DisplayGridlines { get; public set; }
    public bool DisplayRowColHeadings { get; public set; }
    public bool FreezePanes { get; public set; }
    public bool DisplayZeros { get; public set; }
    public bool DefaultHeader { get; public set; }
    public bool Arabic { get; public set; }
    public bool DisplayGuts { get; public set; }
    public bool FreezePanesNoSplit { get; public set; }
    public bool IsSelected { get; public set; }
    public bool IsActive { get; public set; }
    public bool SavedInPageBreakPreview { get; public set; }
    public short TopRow { get; public set; }
    public short LeftCol { get; public set; }
    public int HeaderColor { get; public set; }
    public short PageBreakZoom { get; public set; }
    public short NormalZoom { get; public set; }
    public int Reserved { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public WindowTwoRecord(RecordInputStream in1);
    public short get_Options();
    public void set_Options(short value);
    public bool get_DisplayFormulas();
    public void set_DisplayFormulas(bool value);
    public bool get_DisplayGridlines();
    public void set_DisplayGridlines(bool value);
    public bool get_DisplayRowColHeadings();
    public void set_DisplayRowColHeadings(bool value);
    public bool get_FreezePanes();
    public void set_FreezePanes(bool value);
    public bool get_DisplayZeros();
    public void set_DisplayZeros(bool value);
    public bool get_DefaultHeader();
    public void set_DefaultHeader(bool value);
    public bool get_Arabic();
    public void set_Arabic(bool value);
    public bool get_DisplayGuts();
    public void set_DisplayGuts(bool value);
    public bool get_FreezePanesNoSplit();
    public void set_FreezePanesNoSplit(bool value);
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public bool get_SavedInPageBreakPreview();
    public void set_SavedInPageBreakPreview(bool value);
    public short get_TopRow();
    public void set_TopRow(short value);
    public short get_LeftCol();
    public void set_LeftCol(short value);
    public int get_HeaderColor();
    public void set_HeaderColor(int value);
    public short get_PageBreakZoom();
    public void set_PageBreakZoom(short value);
    public short get_NormalZoom();
    public void set_NormalZoom(short value);
    public int get_Reserved();
    public void set_Reserved(int value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
public class NPOI.HSSF.Record.WriteAccessRecord : StandardRecord {
    public static short sid;
    private string field_1_username;
    private static byte PAD_CHAR;
    private static int DATA_SIZE;
    private static Byte[] PADDING;
    public string Username { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    private static WriteAccessRecord();
    public WriteAccessRecord(RecordInputStream in1);
    public string get_Username();
    public void set_Username(string value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.WriteProtectRecord : StandardRecord {
    public static short sid;
    protected int DataSize { get; }
    public short Sid { get; }
    public WriteProtectRecord(RecordInputStream in1);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
}
public class NPOI.HSSF.Record.WSBoolRecord : StandardRecord {
    public static short sid;
    private byte field_1_wsbool;
    private byte field_2_wsbool;
    private static BitField autobreaks;
    private static BitField dialog;
    private static BitField applystyles;
    private static BitField rowsumsbelow;
    private static BitField rowsumsright;
    private static BitField fittopage;
    private static BitField Displayguts;
    private static BitField alternateexpression;
    private static BitField alternateformula;
    public byte WSBool1 { get; public set; }
    public bool Autobreaks { get; public set; }
    public bool Dialog { get; public set; }
    public bool RowSumsBelow { get; public set; }
    public bool RowSumsRight { get; public set; }
    public byte WSBool2 { get; public set; }
    public bool FitToPage { get; public set; }
    public bool DisplayGuts { get; public set; }
    public bool AlternateExpression { get; public set; }
    public bool AlternateFormula { get; public set; }
    protected int DataSize { get; }
    public short Sid { get; }
    public WSBoolRecord(RecordInputStream in1);
    private static WSBoolRecord();
    public byte get_WSBool1();
    public void set_WSBool1(byte value);
    public bool get_Autobreaks();
    public void set_Autobreaks(bool value);
    public bool get_Dialog();
    public void set_Dialog(bool value);
    public bool get_RowSumsBelow();
    public void set_RowSumsBelow(bool value);
    public bool get_RowSumsRight();
    public void set_RowSumsRight(bool value);
    public byte get_WSBool2();
    public void set_WSBool2(byte value);
    public bool get_FitToPage();
    public void set_FitToPage(bool value);
    public bool get_DisplayGuts();
    public void set_DisplayGuts(bool value);
    public bool get_AlternateExpression();
    public void set_AlternateExpression(bool value);
    public bool get_AlternateFormula();
    public void set_AlternateFormula(bool value);
    public virtual string ToString();
    public virtual void Serialize(ILittleEndianOutput out1);
    protected virtual int get_DataSize();
    public virtual short get_Sid();
    public virtual object Clone();
}
internal class NPOI.HSSF.Ref8 : ValueType {
    public ushort rwFirst;
    public ushort rwLast;
    public ushort colFirst;
    public ushort colLast;
}
public class NPOI.HSSF.UserModel.DVConstraint : object {
    private int _validationType;
    private int _operator;
    private String[] _explicitListValues;
    private string _formula1;
    private string _formula2;
    private double _value1;
    private double _value2;
    public bool IsListValidationType { get; }
    public bool IsExplicitList { get; }
    public int Operator { get; public set; }
    public String[] ExplicitListValues { get; public set; }
    public string Formula1 { get; public set; }
    public string Formula2 { get; public set; }
    public double Value1 { get; public set; }
    public double Value2 { get; public set; }
    private DVConstraint(int validationType, int comparisonOperator, string formulaA, string formulaB, double value1, double value2, String[] excplicitListValues);
    private DVConstraint(string listFormula, String[] excplicitListValues);
    public static DVConstraint CreateNumericConstraint(int validationType, int comparisonOperator, string expr1, string expr2);
    public static DVConstraint CreateFormulaListConstraint(string listFormula);
    public static DVConstraint CreateExplicitListConstraint(String[] explicitListValues);
    public static DVConstraint CreateTimeConstraint(int comparisonOperator, string expr1, string expr2);
    public static DVConstraint CreateDateConstraint(int comparisonOperator, string expr1, string expr2, string dateFormat);
    private static string GetFormulaFromTextExpression(string textExpr);
    private static double ConvertNumber(string numberStr);
    private static double ConvertTime(string timeStr);
    private static double ConvertDate(string dateStr, SimpleDateFormat dateFormat);
    public static DVConstraint CreateCustomFormulaConstraint(string formula);
    public sealed virtual int GetValidationType();
    public bool get_IsListValidationType();
    public bool get_IsExplicitList();
    public sealed virtual int get_Operator();
    public sealed virtual void set_Operator(int value);
    public sealed virtual String[] get_ExplicitListValues();
    public sealed virtual void set_ExplicitListValues(String[] value);
    public sealed virtual string get_Formula1();
    public sealed virtual void set_Formula1(string value);
    public sealed virtual string get_Formula2();
    public sealed virtual void set_Formula2(string value);
    public double get_Value1();
    public void set_Value1(double value);
    public double get_Value2();
    public void set_Value2(double value);
    public FormulaPair CreateFormulas(HSSFSheet sheet);
    private Ptg[] CreateListFormula(HSSFSheet sheet);
    private static Ptg[] ConvertDoubleFormula(string formula, double value, HSSFSheet sheet);
    internal static DVConstraint CreateDVConstraint(DVRecord dvRecord, IFormulaRenderingWorkbook book);
    private static FormulaValuePair toFormulaString(Ptg[] ptgs, IFormulaRenderingWorkbook book);
}
public class NPOI.HSSF.UserModel.EscherGraphics : object {
    private HSSFShapeGroup escherGroup;
    private HSSFWorkbook workbook;
    private float verticalPointsPerPixel;
    private float verticalPixelsPerPoint;
    private Rgb24 foreground;
    private Rgb24 background;
    private Font font;
    private static POILogger Logger;
    private static int dpi;
    public Rectangle Clip { get; }
    public Rectangle ClipBounds { get; }
    public Color Color { get; }
    public Font Font { get; }
    public Color Background { get; public set; }
    public EscherGraphics(HSSFShapeGroup escherGroup, HSSFWorkbook workbook, Color forecolor, float verticalPointsPerPixel);
    private EscherGraphics(HSSFShapeGroup escherGroup, HSSFWorkbook workbook, Color foreground, Font font, float verticalPointsPerPixel);
    private static EscherGraphics();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void ClearRect(int x, int y, int width, int height);
    public void ClipRect(int x, int y, int width, int height);
    public void CopyArea(int x, int y, int width, int height, int dx, int dy);
    public EscherGraphics Create();
    public void DrawArc(int x, int y, int width, int height, int startAngle, int arcAngle);
    public bool DrawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgcolor);
    public bool DrawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2);
    public bool DrawImage(Image image, int i, int j, int k, int l, Color color);
    public bool DrawImage(Image image, int i, int j, int k, int l);
    public bool DrawImage(Image image, int i, int j, Color color);
    public bool DrawImage(Image image, int i, int j);
    public void DrawLine(int x1, int y1, int x2, int y2);
    public void DrawLine(int x1, int y1, int x2, int y2, int width);
    public void DrawOval(int x, int y, int width, int height);
    public void DrawPolygon(Int32[] xPoints, Int32[] yPoints, int nPoints);
    private Int32[] AddToAll(Int32[] values, int amount);
    public void DrawPolyline(Int32[] xPoints, Int32[] yPoints, int nPoints);
    public void DrawRect(int x, int y, int width, int height);
    public void DrawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight);
    public void DrawString(string str, int x, int y);
    private HSSFFont MatchFont(Font font);
    public void FillArc(int x, int y, int width, int height, int startAngle, int arcAngle);
    public void FillOval(int x, int y, int width, int height);
    public void FillPolygon(Int32[] xPoints, Int32[] yPoints, int nPoints);
    private int FindBiggest(Int32[] values);
    private int FindSmallest(Int32[] values);
    public void FillRect(int x, int y, int width, int height);
    public void FillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight);
    public Rectangle get_Clip();
    public Rectangle get_ClipBounds();
    public Color get_Color();
    public Font get_Font();
    public void SetClip(int x, int y, int width, int height);
    public void SetClip(Rectangle shape);
    public void SetColor(Color color);
    public void SetFont(Font f);
    public void SetPaintMode();
    public void SetXORMode(Color color);
    public void Translate(int x, int y);
    public Color get_Background();
    public void set_Background(Color value);
    private HSSFShapeGroup GetEscherGraphics();
}
internal class NPOI.HSSF.UserModel.EvaluationCycleDetector : object {
    private IList _evaluationFrames;
    public bool StartEvaluate(HSSFWorkbook workbook, HSSFSheet sheet, int srcRowNum, int srcColNum);
    public void EndEvaluate(HSSFWorkbook workbook, HSSFSheet sheet, int srcRowNum, int srcColNum);
}
internal class NPOI.HSSF.UserModel.EvaluationCycleDetectorManager : object {
    [ThreadStaticAttribute]
private static EvaluationCycleDetector ecd;
    private static EvaluationCycleDetectorManager();
    public static EvaluationCycleDetector GetTracker();
}
public class NPOI.HSSF.UserModel.FontDetails : object {
    private string fontName;
    private int height;
    private Hashtable charWidths;
    public FontDetails(string fontName, int height);
    public string GetFontName();
    public int GetHeight();
    public void AddChar(char c, int width);
    public int GetCharWidth(char c);
    public void AddChars(Char[] Chars, Int32[] widths);
    public static string BuildFontHeightProperty(string fontName);
    public static string BuildFontWidthsProperty(string fontName);
    public static string BuildFontCharsProperty(string fontName);
    public static FontDetails Create(string fontName, Properties fontMetricsProps);
    public int GetStringWidth(string str);
    private static String[] Split(string text, string separator, int max);
}
public abstract class NPOI.HSSF.UserModel.HeaderFooter : object {
    protected bool stripFields;
    public string RawText { get; }
    public string Left { get; public set; }
    public string Center { get; public set; }
    public string Right { get; public set; }
    public static string Page { get; }
    public static string NumPages { get; }
    public static string Date { get; }
    public static string Time { get; }
    public static string File { get; }
    public static string Tab { get; }
    public static string StartBold { get; }
    public static string EndBold { get; }
    public static string StartUnderline { get; }
    public static string EndUnderline { get; }
    public static string StartDoubleUnderline { get; }
    public static string EndDoubleUnderline { get; }
    public bool AreFieldsStripped { get; public set; }
    internal static Field SHEET_NAME_FIELD { get; }
    internal static Field DATE_FIELD { get; }
    internal static Field FILE_FIELD { get; }
    public static Field FULL_FILE_FIELD { get; }
    internal static Field PAGE_FIELD { get; }
    internal static Field TIME_FIELD { get; }
    internal static Field NUM_PAGES_FIELD { get; }
    public static Field PICTURE_FIELD { get; }
    internal static PairField BOLD_FIELD { get; }
    public static PairField ITALIC_FIELD { get; }
    public static PairField STRIKETHROUGH_FIELD { get; }
    public static PairField SUBSCRIPT_FIELD { get; }
    public static PairField SUPERSCRIPT_FIELD { get; }
    internal static PairField UNDERLINE_FIELD { get; }
    internal static PairField DOUBLE_UNDERLINE_FIELD { get; }
    public abstract virtual string get_RawText();
    private String[] SplitParts();
    private void UpdatePart(int partIndex, string newValue);
    private void UpdateHeaderFooterText(String[] parts);
    protected abstract virtual void SetHeaderFooterText(string text);
    public sealed virtual string get_Left();
    public sealed virtual void set_Left(string value);
    public sealed virtual string get_Center();
    public sealed virtual void set_Center(string value);
    public sealed virtual string get_Right();
    public sealed virtual void set_Right(string value);
    public static string FontSize(short size);
    public static string Font(string font, string style);
    public static string get_Page();
    public static string get_NumPages();
    public static string get_Date();
    public static string get_Time();
    public static string get_File();
    public static string get_Tab();
    public static string get_StartBold();
    public static string get_EndBold();
    public static string get_StartUnderline();
    public static string get_EndUnderline();
    public static string get_StartDoubleUnderline();
    public static string get_EndDoubleUnderline();
    public static string StripFields(string text);
    public bool get_AreFieldsStripped();
    public void set_AreFieldsStripped(bool value);
    internal static Field get_SHEET_NAME_FIELD();
    internal static Field get_DATE_FIELD();
    internal static Field get_FILE_FIELD();
    public static Field get_FULL_FILE_FIELD();
    internal static Field get_PAGE_FIELD();
    internal static Field get_TIME_FIELD();
    internal static Field get_NUM_PAGES_FIELD();
    public static Field get_PICTURE_FIELD();
    internal static PairField get_BOLD_FIELD();
    public static PairField get_ITALIC_FIELD();
    public static PairField get_STRIKETHROUGH_FIELD();
    public static PairField get_SUBSCRIPT_FIELD();
    public static PairField get_SUPERSCRIPT_FIELD();
    internal static PairField get_UNDERLINE_FIELD();
    internal static PairField get_DOUBLE_UNDERLINE_FIELD();
}
public class NPOI.HSSF.UserModel.Helpers.HSSFRowColShifter : object {
    private static POILogger log;
    private static HSSFRowColShifter();
    public static void UpdateFormulas(ISheet sheet, FormulaShifter formulaShifter);
    public static void UpdateSheetFormulas(ISheet sh, FormulaShifter formulashifter);
    public static void UpdateRowFormulas(IRow row, FormulaShifter formulaShifter);
    public static string ShiftFormula(IRow row, string formula, FormulaShifter formulaShifter);
}
public class NPOI.HSSF.UserModel.helpers.HSSFRowShifter : RowShifter {
    private static POILogger logger;
    public HSSFRowShifter(HSSFSheet sh);
    private static HSSFRowShifter();
    public virtual void UpdateNamedRanges(FormulaShifter Shifter);
    public virtual void UpdateFormulas(FormulaShifter Shifter);
    public virtual void UpdateRowFormulas(IRow row, FormulaShifter formulaShifter);
    public virtual void UpdateConditionalFormatting(FormulaShifter Shifter);
    public virtual void UpdateHyperlinks(FormulaShifter Shifter);
}
public abstract class NPOI.HSSF.UserModel.HSSFAnchor : object {
    protected bool _isHorizontallyFlipped;
    protected bool _isVerticallyFlipped;
    public int Dx1 { get; public set; }
    public int Dy1 { get; public set; }
    public int Dy2 { get; public set; }
    public int Dx2 { get; public set; }
    public bool IsHorizontallyFlipped { get; }
    public bool IsVerticallyFlipped { get; }
    public HSSFAnchor(int dx1, int dy1, int dx2, int dy2);
    public static HSSFAnchor CreateAnchorFromEscher(EscherContainerRecord container);
    public abstract virtual int get_Dx1();
    public abstract virtual void set_Dx1(int value);
    public abstract virtual int get_Dy1();
    public abstract virtual void set_Dy1(int value);
    public abstract virtual int get_Dy2();
    public abstract virtual void set_Dy2(int value);
    public abstract virtual int get_Dx2();
    public abstract virtual void set_Dx2(int value);
    public abstract virtual bool get_IsHorizontallyFlipped();
    public abstract virtual bool get_IsVerticallyFlipped();
    internal abstract virtual EscherRecord GetEscherAnchor();
    protected abstract virtual void CreateEscherAnchor();
}
public class NPOI.HSSF.UserModel.HSSFAutoFilter : object {
    private FilterModeRecord filtermode;
    private HSSFSheet _sheet;
    public HSSFAutoFilter(HSSFSheet sheet);
    public HSSFAutoFilter(string formula, HSSFWorkbook workbook);
    private void CreateFilterModeRecord(HSSFSheet sheet, int insertPos);
    private void CreateAutoFilterInfoRecord(HSSFSheet sheet, int insertPos, Area3DPtg ptg);
    private void RemoveFilterModeRecord(HSSFSheet sheet);
}
public class NPOI.HSSF.UserModel.HSSFBorderFormatting : object {
    private HSSFWorkbook workbook;
    private CFRuleBase cfRuleRecord;
    private BorderFormatting borderFormatting;
    public BorderStyle BorderBottom { get; public set; }
    public BorderStyle BorderDiagonal { get; public set; }
    public BorderStyle BorderLeft { get; public set; }
    public BorderStyle BorderRight { get; public set; }
    public BorderStyle BorderTop { get; public set; }
    public short BottomBorderColor { get; public set; }
    public IColor BottomBorderColorColor { get; public set; }
    public short DiagonalBorderColor { get; public set; }
    public IColor DiagonalBorderColorColor { get; public set; }
    public short LeftBorderColor { get; public set; }
    public IColor LeftBorderColorColor { get; public set; }
    public short RightBorderColor { get; public set; }
    public IColor RightBorderColorColor { get; public set; }
    public short TopBorderColor { get; public set; }
    public IColor TopBorderColorColor { get; public set; }
    public bool IsBackwardDiagonalOn { get; public set; }
    public bool IsForwardDiagonalOn { get; public set; }
    public HSSFBorderFormatting(CFRuleBase cfRuleRecord, HSSFWorkbook workbook);
    public BorderFormatting GetBorderFormattingBlock();
    public sealed virtual BorderStyle get_BorderBottom();
    public sealed virtual void set_BorderBottom(BorderStyle value);
    public sealed virtual BorderStyle get_BorderDiagonal();
    public sealed virtual void set_BorderDiagonal(BorderStyle value);
    public sealed virtual BorderStyle get_BorderLeft();
    public sealed virtual void set_BorderLeft(BorderStyle value);
    public sealed virtual BorderStyle get_BorderRight();
    public sealed virtual void set_BorderRight(BorderStyle value);
    public sealed virtual BorderStyle get_BorderTop();
    public sealed virtual void set_BorderTop(BorderStyle value);
    public sealed virtual short get_BottomBorderColor();
    public sealed virtual void set_BottomBorderColor(short value);
    public sealed virtual IColor get_BottomBorderColorColor();
    public sealed virtual void set_BottomBorderColorColor(IColor value);
    public sealed virtual short get_DiagonalBorderColor();
    public sealed virtual void set_DiagonalBorderColor(short value);
    public sealed virtual IColor get_DiagonalBorderColorColor();
    public sealed virtual void set_DiagonalBorderColorColor(IColor value);
    public sealed virtual short get_LeftBorderColor();
    public sealed virtual void set_LeftBorderColor(short value);
    public sealed virtual IColor get_LeftBorderColorColor();
    public sealed virtual void set_LeftBorderColorColor(IColor value);
    public sealed virtual short get_RightBorderColor();
    public sealed virtual void set_RightBorderColor(short value);
    public sealed virtual IColor get_RightBorderColorColor();
    public sealed virtual void set_RightBorderColorColor(IColor value);
    public sealed virtual short get_TopBorderColor();
    public sealed virtual void set_TopBorderColor(short value);
    public sealed virtual IColor get_TopBorderColorColor();
    public sealed virtual void set_TopBorderColorColor(IColor value);
    public bool get_IsBackwardDiagonalOn();
    public void set_IsBackwardDiagonalOn(bool value);
    public bool get_IsForwardDiagonalOn();
    public void set_IsForwardDiagonalOn(bool value);
}
public class NPOI.HSSF.UserModel.HSSFCell : object {
    public static short ENCODING_UNCHANGED;
    public static short ENCODING_COMPRESSED_UNICODE;
    public static short ENCODING_UTF_16;
    private CellType cellType;
    private HSSFRichTextString stringValue;
    private HSSFWorkbook book;
    private HSSFSheet _sheet;
    private CellValueRecordInterface _record;
    private IComment comment;
    private static string FILE_FORMAT_NAME;
    public static int LAST_COLUMN_NUMBER;
    private static string LAST_COLUMN_NAME;
    public InternalWorkbook BoundWorkbook { get; }
    public ISheet Sheet { get; }
    public IRow Row { get; }
    public CellType CellType { get; }
    public string CellFormula { get; public set; }
    public double NumericCellValue { get; }
    public Nullable`1<DateTime> DateCellValue { get; }
    public string StringCellValue { get; }
    public IRichTextString RichStringCellValue { get; }
    public bool BooleanCellValue { get; }
    public byte ErrorCellValue { get; }
    public ICellStyle CellStyle { get; public set; }
    public CellValueRecordInterface CellValueRecord { get; }
    public IComment CellComment { get; public set; }
    public int ColumnIndex { get; }
    public CellAddress Address { get; }
    public int RowIndex { get; }
    public IHyperlink Hyperlink { get; public set; }
    public CellType CachedFormulaResultType { get; }
    public bool IsPartOfArrayFormulaGroup { get; }
    public CellRangeAddress ArrayFormulaRange { get; }
    public bool IsMergedCell { get; }
    public HSSFCell(HSSFWorkbook book, HSSFSheet sheet, int row, short col);
    public HSSFCell(HSSFWorkbook book, HSSFSheet sheet, int row, short col, CellType type);
    public HSSFCell(HSSFWorkbook book, HSSFSheet sheet, CellValueRecordInterface cval);
    private static HSSFCell();
    private CellType DetermineType(CellValueRecordInterface cval);
    public InternalWorkbook get_BoundWorkbook();
    public sealed virtual ISheet get_Sheet();
    public sealed virtual IRow get_Row();
    public sealed virtual void SetCellType(CellType cellType);
    private void SetCellType(CellType cellType, bool setValue, int row, int col, short styleIndex);
    public sealed virtual CellType get_CellType();
    private string ConvertCellValueToString();
    public sealed virtual void SetCellValue(double value);
    public sealed virtual void SetCellValue(DateTime value);
    public sealed virtual void SetCellValue(string value);
    [ObsoleteAttribute("deprecated 3.15 beta 2. Use {@link #setCellErrorValue(FormulaError)} instead.")]
public sealed virtual void SetCellErrorValue(byte errorCode);
    public void SetCellErrorValue(FormulaError error);
    public sealed virtual void SetCellValue(IRichTextString value);
    private void NotifyFormulaChanging();
    public sealed virtual string get_CellFormula();
    public sealed virtual void set_CellFormula(string value);
    internal void TryToDeleteArrayFormula(string message);
    public sealed virtual void RemoveFormula();
    public sealed virtual void SetCellFormula(string formula);
    public sealed virtual double get_NumericCellValue();
    private string GetCellTypeName(CellType cellTypeCode);
    private Exception TypeMismatch(CellType expectedTypeCode, CellType actualTypeCode, bool isFormulaCell);
    private void CheckFormulaCachedValueType(CellType expectedTypeCode, FormulaRecord fr);
    public sealed virtual Nullable`1<DateTime> get_DateCellValue();
    public sealed virtual string get_StringCellValue();
    public sealed virtual IRichTextString get_RichStringCellValue();
    public sealed virtual void SetCellValue(bool value);
    private bool ConvertCellValueToBoolean();
    public sealed virtual bool get_BooleanCellValue();
    public sealed virtual byte get_ErrorCellValue();
    public sealed virtual ICellStyle get_CellStyle();
    public sealed virtual void set_CellStyle(ICellStyle value);
    private short ApplyUserCellStyle(HSSFCellStyle style);
    public CellValueRecordInterface get_CellValueRecord();
    private void CheckBounds(int cellIndex);
    public sealed virtual void SetAsActiveCell();
    public virtual string ToString();
    public sealed virtual IComment get_CellComment();
    public sealed virtual void set_CellComment(IComment value);
    public sealed virtual void RemoveCellComment();
    public sealed virtual int get_ColumnIndex();
    public sealed virtual CellAddress get_Address();
    internal void UpdateCellNum(int num);
    public sealed virtual int get_RowIndex();
    public sealed virtual IHyperlink get_Hyperlink();
    public sealed virtual void set_Hyperlink(IHyperlink value);
    public sealed virtual void RemoveHyperlink();
    public sealed virtual CellType get_CachedFormulaResultType();
    public sealed virtual bool get_IsPartOfArrayFormulaGroup();
    internal void SetCellArrayFormula(CellRangeAddress range);
    public sealed virtual CellRangeAddress get_ArrayFormulaRange();
    public sealed virtual ICell CopyCellTo(int targetIndex);
    internal void NotifyArrayFormulaChanging(string msg);
    internal void NotifyArrayFormulaChanging();
    [ObsoleteAttribute("Will be removed at NPOI 2.8, Use CachedFormulaResultType instead.")]
public sealed virtual CellType GetCachedFormulaResultTypeEnum();
    public sealed virtual void SetBlank();
    public sealed virtual bool get_IsMergedCell();
}
public class NPOI.HSSF.UserModel.HSSFCellStyle : object {
    private ExtendedFormatRecord _format;
    private short index;
    private InternalWorkbook _workbook;
    private static short lastDateFormat;
    private static List`1<FormatRecord> lastFormats;
    private static string getDataFormatStringCache;
    public short Index { get; }
    public HSSFCellStyle ParentStyle { get; }
    public short DataFormat { get; public set; }
    public short FontIndex { get; }
    public bool IsHidden { get; public set; }
    public bool IsLocked { get; public set; }
    public bool IsQuotePrefixed { get; public set; }
    public HorizontalAlignment Alignment { get; public set; }
    public bool WrapText { get; public set; }
    public VerticalAlignment VerticalAlignment { get; public set; }
    public short Rotation { get; public set; }
    public short Indention { get; public set; }
    public BorderStyle BorderLeft { get; public set; }
    public BorderStyle BorderRight { get; public set; }
    public BorderStyle BorderTop { get; public set; }
    public BorderStyle BorderBottom { get; public set; }
    public short LeftBorderColor { get; public set; }
    public short RightBorderColor { get; public set; }
    public short TopBorderColor { get; public set; }
    public short BottomBorderColor { get; public set; }
    public short BorderDiagonalColor { get; public set; }
    public BorderStyle BorderDiagonalLineStyle { get; public set; }
    public BorderDiagonal BorderDiagonal { get; public set; }
    public bool ShrinkToFit { get; public set; }
    public short ReadingOrder { get; public set; }
    public FillPattern FillPattern { get; public set; }
    public short FillBackgroundColor { get; public set; }
    public IColor FillBackgroundColorColor { get; }
    public short FillForegroundColor { get; public set; }
    public IColor FillForegroundColorColor { get; }
    public string UserStyleName { get; public set; }
    public HSSFCellStyle(short index, ExtendedFormatRecord rec, HSSFWorkbook workbook);
    public HSSFCellStyle(short index, ExtendedFormatRecord rec, InternalWorkbook workbook);
    private static HSSFCellStyle();
    public sealed virtual short get_Index();
    public HSSFCellStyle get_ParentStyle();
    public sealed virtual short get_DataFormat();
    public sealed virtual void set_DataFormat(short value);
    public sealed virtual string GetDataFormatString();
    public string GetDataFormatString(IWorkbook workbook);
    public string GetDataFormatString(InternalWorkbook workbook);
    public sealed virtual void SetFont(IFont font);
    public sealed virtual short get_FontIndex();
    public sealed virtual IFont GetFont(IWorkbook parentWorkbook);
    public sealed virtual bool get_IsHidden();
    public sealed virtual void set_IsHidden(bool value);
    public sealed virtual bool get_IsLocked();
    public sealed virtual void set_IsLocked(bool value);
    public sealed virtual bool get_IsQuotePrefixed();
    public sealed virtual void set_IsQuotePrefixed(bool value);
    public sealed virtual HorizontalAlignment get_Alignment();
    public sealed virtual void set_Alignment(HorizontalAlignment value);
    public sealed virtual bool get_WrapText();
    public sealed virtual void set_WrapText(bool value);
    public sealed virtual VerticalAlignment get_VerticalAlignment();
    public sealed virtual void set_VerticalAlignment(VerticalAlignment value);
    public sealed virtual short get_Rotation();
    public sealed virtual void set_Rotation(short value);
    public void VerifyBelongsToWorkbook(HSSFWorkbook wb);
    public sealed virtual short get_Indention();
    public sealed virtual void set_Indention(short value);
    public sealed virtual BorderStyle get_BorderLeft();
    public sealed virtual void set_BorderLeft(BorderStyle value);
    public sealed virtual BorderStyle get_BorderRight();
    public sealed virtual void set_BorderRight(BorderStyle value);
    public sealed virtual BorderStyle get_BorderTop();
    public sealed virtual void set_BorderTop(BorderStyle value);
    public sealed virtual BorderStyle get_BorderBottom();
    public sealed virtual void set_BorderBottom(BorderStyle value);
    public sealed virtual short get_LeftBorderColor();
    public sealed virtual void set_LeftBorderColor(short value);
    public sealed virtual short get_RightBorderColor();
    public sealed virtual void set_RightBorderColor(short value);
    public sealed virtual short get_TopBorderColor();
    public sealed virtual void set_TopBorderColor(short value);
    public sealed virtual short get_BottomBorderColor();
    public sealed virtual void set_BottomBorderColor(short value);
    public sealed virtual short get_BorderDiagonalColor();
    public sealed virtual void set_BorderDiagonalColor(short value);
    public sealed virtual BorderStyle get_BorderDiagonalLineStyle();
    public sealed virtual void set_BorderDiagonalLineStyle(BorderStyle value);
    public sealed virtual BorderDiagonal get_BorderDiagonal();
    public sealed virtual void set_BorderDiagonal(BorderDiagonal value);
    public sealed virtual bool get_ShrinkToFit();
    public sealed virtual void set_ShrinkToFit(bool value);
    public short get_ReadingOrder();
    public void set_ReadingOrder(short value);
    public sealed virtual FillPattern get_FillPattern();
    public sealed virtual void set_FillPattern(FillPattern value);
    private void CheckDefaultBackgroundFills();
    public sealed virtual void CloneStyleFrom(ICellStyle source);
    public void CloneStyleFrom(HSSFCellStyle source);
    public sealed virtual short get_FillBackgroundColor();
    public sealed virtual void set_FillBackgroundColor(short value);
    public sealed virtual IColor get_FillBackgroundColorColor();
    public sealed virtual short get_FillForegroundColor();
    public sealed virtual void set_FillForegroundColor(short value);
    public sealed virtual IColor get_FillForegroundColorColor();
    public string get_UserStyleName();
    public void set_UserStyleName(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class NPOI.HSSF.UserModel.HSSFChart : object {
    private HSSFSheet sheet;
    private ChartRecord chartRecord;
    private LegendRecord legendRecord;
    private AlRunsRecord chartTitleFormat;
    private SeriesTextRecord chartTitleText;
    private List`1<ValueRangeRecord> valueRanges;
    private HSSFChartType type;
    private List`1<HSSFSeries> series;
    public int ChartX { get; public set; }
    public int ChartY { get; public set; }
    public int ChartWidth { get; public set; }
    public int ChartHeight { get; public set; }
    public HSSFSeries[] Series { get; }
    public string ChartTitle { get; public set; }
    public HSSFChartType Type { get; }
    private HSSFChart(HSSFSheet sheet, ChartRecord chartRecord);
    public void CreateBarChart(HSSFWorkbook workbook, HSSFSheet sheet);
    public static HSSFChart[] GetSheetCharts(HSSFSheet sheet);
    public int get_ChartX();
    public void set_ChartX(int value);
    public int get_ChartY();
    public void set_ChartY(int value);
    public int get_ChartWidth();
    public void set_ChartWidth(int value);
    public int get_ChartHeight();
    public void set_ChartHeight(int value);
    public HSSFSeries[] get_Series();
    public string get_ChartTitle();
    public void set_ChartTitle(string value);
    public void SetValueRange(int axisIndex, Nullable`1<double> minimum, Nullable`1<double> maximum, Nullable`1<double> majorUnit, Nullable`1<double> minorUnit);
    private SeriesIndexRecord CreateSeriesIndexRecord(int index);
    private DimensionsRecord CreateDimensionsRecord();
    private HCenterRecord CreateHCenterRecord();
    private VCenterRecord CreateVCenterRecord();
    private PrintSetupRecord CreatePrintSetupRecord();
    private FbiRecord CreateFontBasisRecord1();
    private FbiRecord CreateFontBasisRecord2();
    private BOFRecord CreateBOFRecord();
    private UnknownRecord CreateOBJRecord();
    private UnknownRecord CreateMSDrawingObjectRecord();
    private void CreateAxisRecords(IList records);
    private LinkedDataRecord CreateLinkedDataRecord();
    private TextRecord CreateTextRecord();
    private LegendRecord CreateLegendRecord();
    private BarRecord CreateBarRecord();
    private ChartFormatRecord CreateChartFormatRecord();
    private PlotAreaRecord CreatePlotAreaRecord();
    private AxisLineFormatRecord CreateAxisLineFormatRecord(short format);
    private ValueRangeRecord CreateValueRangeRecord();
    private TickRecord CreateTickRecord1();
    private TickRecord CreateTickRecord2();
    private AxcExtRecord CreateAxisOptionsRecord();
    private CatSerRangeRecord CreateCategorySeriesAxisRecord();
    private AxisRecord CreateAxisRecord(short axisType);
    private AxisParentRecord CreateAxisParentRecord();
    private AxesUsedRecord CreateAxisUsedRecord(short numAxis);
    private LinkedDataRecord CreateDirectLinkRecord();
    private FontIndexRecord CreateFontIndexRecord(int index);
    private TextRecord CreateAllTextRecord();
    private TextRecord CreateUnknownTextRecord();
    private DefaultTextRecord CreateDefaultTextRecord(short categoryDataType);
    private ShtPropsRecord CreateSheetPropsRecord();
    private DataFormatRecord CreateDataFormatRecord();
    private LinkedDataRecord CreateCategoriesLinkedDataRecord();
    private LinkedDataRecord CreateValuesLinkedDataRecord();
    private LinkedDataRecord CreateTitleLinkedDataRecord();
    private SeriesRecord CreateSeriesRecord();
    private EndRecord CreateEndRecord();
    private AreaFormatRecord CreateAreaFormatRecord1();
    private AreaFormatRecord CreateAreaFormatRecord2();
    private LineFormatRecord CreateLineFormatRecord(bool drawTicks);
    private LineFormatRecord CreateLineFormatRecord2();
    private FrameRecord CreateFrameRecord1();
    private FrameRecord CreateFrameRecord2();
    private PlotGrowthRecord CreatePlotGrowthRecord(int horizScale, int vertScale);
    private SCLRecord CreateSCLRecord(short numerator, short denominator);
    private BeginRecord CreateBeginRecord();
    private ChartRecord CreateChartRecord(int x, int y, int width, int height);
    private UnitsRecord CreateUnitsRecord();
    public HSSFSeries CreateSeries();
    public bool RemoveSeries(HSSFSeries series);
    public HSSFChartType get_Type();
}
public enum NPOI.HSSF.UserModel.HSSFChartType : Enum {
    public int value__;
    public static HSSFChartType Area;
    public static HSSFChartType Bar;
    public static HSSFChartType Line;
    public static HSSFChartType Pie;
    public static HSSFChartType Scatter;
    public static HSSFChartType Unknown;
}
public class NPOI.HSSF.UserModel.HSSFChildAnchor : HSSFAnchor {
    private EscherChildAnchorRecord _escherChildAnchor;
    public bool IsHorizontallyFlipped { get; }
    public bool IsVerticallyFlipped { get; }
    public int Dx1 { get; public set; }
    public int Dx2 { get; public set; }
    public int Dy1 { get; public set; }
    public int Dy2 { get; public set; }
    public HSSFChildAnchor(EscherChildAnchorRecord escherChildAnchorRecord);
    public HSSFChildAnchor(int dx1, int dy1, int dx2, int dy2);
    public void SetAnchor(int dx1, int dy1, int dx2, int dy2);
    public virtual bool get_IsHorizontallyFlipped();
    public virtual bool get_IsVerticallyFlipped();
    public virtual int get_Dx1();
    public virtual void set_Dx1(int value);
    public virtual int get_Dx2();
    public virtual void set_Dx2(int value);
    public virtual int get_Dy1();
    public virtual void set_Dy1(int value);
    public virtual int get_Dy2();
    public virtual void set_Dy2(int value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual EscherRecord GetEscherAnchor();
    protected virtual void CreateEscherAnchor();
}
public class NPOI.HSSF.UserModel.HSSFClientAnchor : HSSFAnchor {
    public static int MAX_COL;
    public static int MAX_ROW;
    private EscherClientAnchorRecord _escherClientAnchor;
    public int Col1 { get; public set; }
    public int Col2 { get; public set; }
    public int Row1 { get; public set; }
    public int Row2 { get; public set; }
    public bool IsHorizontallyFlipped { get; }
    public bool IsVerticallyFlipped { get; }
    public AnchorType AnchorType { get; public set; }
    public int Dx1 { get; public set; }
    public int Dx2 { get; public set; }
    public int Dy1 { get; public set; }
    public int Dy2 { get; public set; }
    public HSSFClientAnchor(EscherClientAnchorRecord escherClientAnchorRecord);
    public HSSFClientAnchor(int dx1, int dy1, int dx2, int dy2, int col1, int row1, int col2, int row2);
    private static HSSFClientAnchor();
    public float GetAnchorHeightInPoints(ISheet sheet);
    private float GetRowHeightInPoints(ISheet sheet, int rowNum);
    public sealed virtual int get_Col1();
    public sealed virtual void set_Col1(int value);
    public sealed virtual int get_Col2();
    public sealed virtual void set_Col2(int value);
    public sealed virtual int get_Row1();
    public sealed virtual void set_Row1(int value);
    public sealed virtual int get_Row2();
    public sealed virtual void set_Row2(int value);
    public void SetAnchor(short col1, int row1, int x1, int y1, short col2, int row2, int x2, int y2);
    public virtual bool get_IsHorizontallyFlipped();
    public virtual bool get_IsVerticallyFlipped();
    public sealed virtual AnchorType get_AnchorType();
    public sealed virtual void set_AnchorType(AnchorType value);
    private void CheckRange(int value, int minRange, int maxRange, string varName);
    internal virtual EscherRecord GetEscherAnchor();
    protected virtual void CreateEscherAnchor();
    private static int unsignedValue(short s);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual int get_Dx1();
    public virtual void set_Dx1(int value);
    public virtual int get_Dx2();
    public virtual void set_Dx2(int value);
    public virtual int get_Dy1();
    public virtual void set_Dy1(int value);
    public virtual int get_Dy2();
    public virtual void set_Dy2(int value);
}
public class NPOI.HSSF.UserModel.HSSFColorScaleFormatting : object {
    private HSSFSheet sheet;
    private CFRule12Record cfRule12Record;
    private ColorGradientFormatting colorFormatting;
    public int NumControlPoints { get; public set; }
    public IColor[] Colors { get; public set; }
    public IConditionalFormattingThreshold[] Thresholds { get; public set; }
    protected internal HSSFColorScaleFormatting(CFRule12Record cfRule12Record, HSSFSheet sheet);
    public sealed virtual int get_NumControlPoints();
    public sealed virtual void set_NumControlPoints(int value);
    public sealed virtual IColor[] get_Colors();
    public sealed virtual void set_Colors(IColor[] value);
    public sealed virtual IConditionalFormattingThreshold[] get_Thresholds();
    public sealed virtual void set_Thresholds(IConditionalFormattingThreshold[] value);
    public sealed virtual IConditionalFormattingThreshold CreateThreshold();
}
public class NPOI.HSSF.UserModel.HSSFCombobox : HSSFSimpleShape {
    public int ShapeType { get; public set; }
    public HSSFCombobox(EscherContainerRecord spContainer, ObjRecord objRecord);
    public HSSFCombobox(HSSFShape parent, HSSFAnchor anchor);
    protected virtual TextObjectRecord CreateTextObjRecord();
    protected virtual EscherContainerRecord CreateSpContainer();
    protected virtual ObjRecord CreateObjRecord();
    public virtual int get_ShapeType();
    public virtual void set_ShapeType(int value);
}
public class NPOI.HSSF.UserModel.HSSFComment : HSSFTextbox {
    private static int FILL_TYPE_SOLID;
    private static int FILL_TYPE_PICTURE;
    private static int GROUP_SHAPE_PROPERTY_DEFAULT_VALUE;
    private static int GROUP_SHAPE_HIDDEN_MASK;
    private static int GROUP_SHAPE_NOT_HIDDEN_MASK;
    private NoteRecord _note;
    public int ShapeId { get; public set; }
    public bool Visible { get; public set; }
    public CellAddress Address { get; public set; }
    public int Row { get; public set; }
    public int Column { get; public set; }
    public string Author { get; public set; }
    internal NoteRecord NoteRecord { get; }
    public bool HasPosition { get; }
    public IClientAnchor ClientAnchor { get; }
    public int ShapeType { get; public set; }
    public HSSFComment(EscherContainerRecord spContainer, ObjRecord objRecord, TextObjectRecord textObjectRecord, NoteRecord _note);
    public HSSFComment(HSSFShape parent, HSSFAnchor anchor);
    private HSSFComment(HSSFShape parent, HSSFAnchor anchor, NoteRecord note);
    public HSSFComment(NoteRecord note, TextObjectRecord txo);
    internal virtual void AfterInsert(HSSFPatriarch patriarch);
    protected virtual EscherContainerRecord CreateSpContainer();
    protected virtual ObjRecord CreateObjRecord();
    private static NoteRecord CreateNoteRecord();
    public virtual int get_ShapeId();
    public virtual void set_ShapeId(int value);
    public sealed virtual bool get_Visible();
    public sealed virtual void set_Visible(bool value);
    public sealed virtual CellAddress get_Address();
    public sealed virtual void set_Address(CellAddress value);
    public sealed virtual void SetAddress(int row, int col);
    public sealed virtual int get_Row();
    public sealed virtual void set_Row(int value);
    public sealed virtual int get_Column();
    public sealed virtual void set_Column(int value);
    public sealed virtual string get_Author();
    public sealed virtual void set_Author(string value);
    internal NoteRecord get_NoteRecord();
    public bool get_HasPosition();
    public sealed virtual IClientAnchor get_ClientAnchor();
    public virtual int get_ShapeType();
    public virtual void set_ShapeType(int value);
    internal virtual void AfterRemove(HSSFPatriarch patriarch);
    internal virtual HSSFShape CloneShape();
    public void SetBackgroundImage(int pictureIndex);
    public void ResetBackgroundImage();
    public int GetBackgroundImageId();
    private void SetHidden(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NPOI.HSSF.UserModel.HSSFConditionalFormatting : object {
    private HSSFSheet sheet;
    private CFRecordsAggregate cfAggregate;
    public CFRecordsAggregate CFRecordsAggregate { get; }
    public int NumberOfRules { get; }
    public HSSFConditionalFormatting(HSSFSheet sheet, CFRecordsAggregate cfAggregate);
    public CFRecordsAggregate get_CFRecordsAggregate();
    public sealed virtual CellRangeAddress[] GetFormattingRanges();
    public sealed virtual void SetFormattingRanges(CellRangeAddress[] ranges);
    public void SetRule(int idx, HSSFConditionalFormattingRule cfRule);
    public sealed virtual void SetRule(int idx, IConditionalFormattingRule cfRule);
    public void AddRule(HSSFConditionalFormattingRule cfRule);
    public sealed virtual void AddRule(IConditionalFormattingRule cfRule);
    public sealed virtual IConditionalFormattingRule GetRule(int idx);
    public sealed virtual int get_NumberOfRules();
    public virtual string ToString();
}
public class NPOI.HSSF.UserModel.HSSFConditionalFormattingRule : object {
    private static byte CELL_COMPARISON;
    private CFRuleBase cfRuleRecord;
    private HSSFWorkbook workbook;
    private HSSFSheet sheet;
    public CFRuleBase CfRuleRecord { get; }
    public IFontFormatting FontFormatting { get; }
    public IBorderFormatting BorderFormatting { get; }
    public IPatternFormatting PatternFormatting { get; }
    public IDataBarFormatting DataBarFormatting { get; }
    public IIconMultiStateFormatting MultiStateFormatting { get; }
    public IColorScaleFormatting ColorScaleFormatting { get; }
    public ConditionType ConditionType { get; }
    public ComparisonOperator ComparisonOperation { get; }
    public string Formula1 { get; }
    public string Formula2 { get; }
    public bool StopIfTrue { get; }
    public string Text { get; }
    public int Priority { get; }
    public ExcelNumberFormat NumberFormat { get; }
    public Nullable`1<ConditionFilterType> ConditionFilterType { get; }
    public IConditionFilterData FilterConfiguration { get; }
    public HSSFConditionalFormattingRule(HSSFSheet pSheet, CFRuleBase pRuleRecord);
    public CFRuleBase get_CfRuleRecord();
    private CFRule12Record GetCFRule12Record(bool create);
    private HSSFFontFormatting GetFontFormatting(bool Create);
    public sealed virtual IFontFormatting get_FontFormatting();
    public sealed virtual IFontFormatting CreateFontFormatting();
    private HSSFBorderFormatting GetBorderFormatting(bool Create);
    public sealed virtual IBorderFormatting get_BorderFormatting();
    public sealed virtual IBorderFormatting CreateBorderFormatting();
    private HSSFPatternFormatting GetPatternFormatting(bool Create);
    public sealed virtual IPatternFormatting get_PatternFormatting();
    public sealed virtual IPatternFormatting CreatePatternFormatting();
    private HSSFDataBarFormatting GetDataBarFormatting(bool create);
    public sealed virtual IDataBarFormatting get_DataBarFormatting();
    public HSSFDataBarFormatting CreateDataBarFormatting();
    private HSSFIconMultiStateFormatting GetMultiStateFormatting(bool create);
    public sealed virtual IIconMultiStateFormatting get_MultiStateFormatting();
    public HSSFIconMultiStateFormatting CreateMultiStateFormatting();
    private HSSFColorScaleFormatting GetColorScaleFormatting(bool create);
    public sealed virtual IColorScaleFormatting get_ColorScaleFormatting();
    public HSSFColorScaleFormatting CreateColorScaleFormatting();
    public sealed virtual ConditionType get_ConditionType();
    public sealed virtual ComparisonOperator get_ComparisonOperation();
    public sealed virtual string get_Formula1();
    public sealed virtual string get_Formula2();
    protected internal string ToFormulaString(Ptg[] ParsedExpression);
    protected internal static string ToFormulaString(Ptg[] parsedExpression, HSSFWorkbook workbook);
    public sealed virtual bool get_StopIfTrue();
    public sealed virtual string get_Text();
    public sealed virtual int get_Priority();
    public sealed virtual ExcelNumberFormat get_NumberFormat();
    public sealed virtual Nullable`1<ConditionFilterType> get_ConditionFilterType();
    public sealed virtual IConditionFilterData get_FilterConfiguration();
}
public class NPOI.HSSF.UserModel.HSSFConditionalFormattingThreshold : object {
    private Threshold threshold;
    private HSSFSheet sheet;
    private HSSFWorkbook workbook;
    protected internal Threshold Threshold { get; }
    public RangeType RangeType { get; public set; }
    public string Formula { get; public set; }
    public Nullable`1<double> Value { get; public set; }
    protected internal HSSFConditionalFormattingThreshold(Threshold threshold, HSSFSheet sheet);
    protected internal Threshold get_Threshold();
    public sealed virtual RangeType get_RangeType();
    public sealed virtual void set_RangeType(RangeType value);
    public sealed virtual string get_Formula();
    public sealed virtual void set_Formula(string value);
    public sealed virtual Nullable`1<double> get_Value();
    public sealed virtual void set_Value(Nullable`1<double> value);
}
public class NPOI.HSSF.UserModel.HSSFCreationHelper : object {
    private HSSFWorkbook workbook;
    private HSSFDataFormat dataFormat;
    public HSSFCreationHelper(HSSFWorkbook wb);
    public sealed virtual IRichTextString CreateRichTextString(string text);
    public sealed virtual IDataFormat CreateDataFormat();
    public sealed virtual IHyperlink CreateHyperlink(HyperlinkType type);
    public sealed virtual IFormulaEvaluator CreateFormulaEvaluator();
    public sealed virtual IClientAnchor CreateClientAnchor();
    public sealed virtual ExtendedColor CreateExtendedColor();
}
public class NPOI.HSSF.UserModel.HSSFDataBarFormatting : object {
    private HSSFSheet sheet;
    private CFRule12Record cfRule12Record;
    private DataBarFormatting databarFormatting;
    public bool IsLeftToRight { get; public set; }
    public int WidthMin { get; public set; }
    public int WidthMax { get; public set; }
    public IColor Color { get; public set; }
    public IConditionalFormattingThreshold MinThreshold { get; }
    public IConditionalFormattingThreshold MaxThreshold { get; }
    public bool IsIconOnly { get; public set; }
    protected internal HSSFDataBarFormatting(CFRule12Record cfRule12Record, HSSFSheet sheet);
    public sealed virtual bool get_IsLeftToRight();
    public sealed virtual void set_IsLeftToRight(bool value);
    public sealed virtual int get_WidthMin();
    public sealed virtual void set_WidthMin(int value);
    public sealed virtual int get_WidthMax();
    public sealed virtual void set_WidthMax(int value);
    public sealed virtual IColor get_Color();
    public sealed virtual void set_Color(IColor value);
    public sealed virtual IConditionalFormattingThreshold get_MinThreshold();
    public sealed virtual IConditionalFormattingThreshold get_MaxThreshold();
    public sealed virtual bool get_IsIconOnly();
    public sealed virtual void set_IsIconOnly(bool value);
    public HSSFConditionalFormattingThreshold CreateThreshold();
}
public class NPOI.HSSF.UserModel.HSSFDataFormat : object {
    public static int FIRST_USER_DEFINED_FORMAT_INDEX;
    private static List`1<string> builtinFormats;
    private List`1<string> formats;
    private InternalWorkbook workbook;
    private bool movedBuiltins;
    public static int NumberOfBuiltinBuiltinFormats { get; }
    public HSSFDataFormat(InternalWorkbook workbook);
    private static HSSFDataFormat();
    public static List`1<string> GetBuiltinFormats();
    public static short GetBuiltinFormat(string format);
    public sealed virtual short GetFormat(string pFormat);
    public sealed virtual string GetFormat(short index);
    public static string GetBuiltinFormat(short index);
    public static int get_NumberOfBuiltinBuiltinFormats();
    private void EnsureFormatsSize(int index);
}
public class NPOI.HSSF.UserModel.HSSFDataFormatter : DataFormatter {
    public HSSFDataFormatter(CultureInfo locale);
}
public class NPOI.HSSF.UserModel.HSSFDataValidation : object {
    private string _prompt_title;
    private string _prompt_text;
    private string _error_title;
    private string _error_text;
    private int _errorStyle;
    private bool _emptyCellAllowed;
    private bool _suppress_dropdown_arrow;
    private bool _ShowPromptBox;
    private bool _ShowErrorBox;
    private CellRangeAddressList _regions;
    private DVConstraint _constraint;
    public IDataValidationConstraint ValidationConstraint { get; }
    public DVConstraint Constraint { get; }
    public CellRangeAddressList Regions { get; }
    public int ErrorStyle { get; public set; }
    public bool EmptyCellAllowed { get; public set; }
    public bool SuppressDropDownArrow { get; public set; }
    public bool ShowPromptBox { get; public set; }
    public bool ShowErrorBox { get; public set; }
    public string PromptBoxTitle { get; }
    public string PromptBoxText { get; }
    public string ErrorBoxTitle { get; }
    public string ErrorBoxText { get; }
    public HSSFDataValidation(CellRangeAddressList regions, IDataValidationConstraint constraint);
    public sealed virtual IDataValidationConstraint get_ValidationConstraint();
    public DVConstraint get_Constraint();
    public sealed virtual CellRangeAddressList get_Regions();
    public sealed virtual int get_ErrorStyle();
    public sealed virtual void set_ErrorStyle(int value);
    public sealed virtual bool get_EmptyCellAllowed();
    public sealed virtual void set_EmptyCellAllowed(bool value);
    public sealed virtual bool get_SuppressDropDownArrow();
    public sealed virtual void set_SuppressDropDownArrow(bool value);
    public sealed virtual bool get_ShowPromptBox();
    public sealed virtual void set_ShowPromptBox(bool value);
    public sealed virtual bool get_ShowErrorBox();
    public sealed virtual void set_ShowErrorBox(bool value);
    public sealed virtual void CreatePromptBox(string title, string text);
    public sealed virtual string get_PromptBoxTitle();
    public sealed virtual string get_PromptBoxText();
    public sealed virtual void CreateErrorBox(string title, string text);
    public sealed virtual string get_ErrorBoxTitle();
    public sealed virtual string get_ErrorBoxText();
    public DVRecord CreateDVRecord(HSSFSheet sheet);
}
public class NPOI.HSSF.UserModel.HSSFDataValidationHelper : object {
    public HSSFDataValidationHelper(HSSFSheet sheet);
    public sealed virtual IDataValidationConstraint CreateDateConstraint(int operatorType, string formula1, string formula2, string dateFormat);
    public sealed virtual IDataValidationConstraint CreateExplicitListConstraint(String[] listOfValues);
    public sealed virtual IDataValidationConstraint CreateFormulaListConstraint(string listFormula);
    public sealed virtual IDataValidationConstraint CreateNumericConstraint(int validationType, int operatorType, string formula1, string formula2);
    public sealed virtual IDataValidationConstraint CreateintConstraint(int operatorType, string formula1, string formula2);
    public sealed virtual IDataValidationConstraint CreateDecimalConstraint(int operatorType, string formula1, string formula2);
    public sealed virtual IDataValidationConstraint CreateTextLengthConstraint(int operatorType, string formula1, string formula2);
    public sealed virtual IDataValidationConstraint CreateTimeConstraint(int operatorType, string formula1, string formula2);
    public sealed virtual IDataValidationConstraint CreateCustomConstraint(string formula);
    public sealed virtual IDataValidation CreateValidation(IDataValidationConstraint constraint, CellRangeAddressList cellRangeAddressList);
}
public class NPOI.HSSF.UserModel.HSSFDateUtil : DateUtil {
    public static int AbsoluteDay(DateTime cal, bool use1904windowing);
}
public class NPOI.HSSF.UserModel.HSSFEvaluationCell : object {
    private IEvaluationSheet _evalSheet;
    private ICell _cell;
    public ICell HSSFCell { get; }
    public bool BooleanCellValue { get; }
    public CellType CellType { get; }
    public int ColumnIndex { get; }
    public int ErrorCellValue { get; }
    public double NumericCellValue { get; }
    public int RowIndex { get; }
    public IEvaluationSheet Sheet { get; }
    public string StringCellValue { get; }
    public object IdentityKey { get; }
    public CellType CachedFormulaResultType { get; }
    public bool IsPartOfArrayFormulaGroup { get; }
    public CellRangeAddress ArrayFormulaRange { get; }
    public HSSFEvaluationCell(ICell cell, IEvaluationSheet evalSheet);
    public HSSFEvaluationCell(ICell cell);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public ICell get_HSSFCell();
    public sealed virtual bool get_BooleanCellValue();
    public sealed virtual CellType get_CellType();
    public sealed virtual int get_ColumnIndex();
    public sealed virtual int get_ErrorCellValue();
    public sealed virtual double get_NumericCellValue();
    public sealed virtual int get_RowIndex();
    public sealed virtual IEvaluationSheet get_Sheet();
    public sealed virtual string get_StringCellValue();
    public sealed virtual object get_IdentityKey();
    public sealed virtual CellType get_CachedFormulaResultType();
    public sealed virtual bool get_IsPartOfArrayFormulaGroup();
    public sealed virtual CellRangeAddress get_ArrayFormulaRange();
}
public class NPOI.HSSF.UserModel.HSSFEvaluationSheet : object {
    private HSSFSheet _hs;
    public HSSFSheet HSSFSheet { get; }
    public HSSFEvaluationSheet(HSSFSheet hs);
    public HSSFSheet get_HSSFSheet();
    public sealed virtual IEvaluationCell GetCell(int rowIndex, int columnIndex);
    public sealed virtual void ClearAllCachedResultValues();
}
public class NPOI.HSSF.UserModel.HSSFEvaluationWorkbook : object {
    private static POILogger logger;
    private HSSFWorkbook _uBook;
    private InternalWorkbook _iBook;
    private HSSFEvaluationWorkbook(HSSFWorkbook book);
    private static HSSFEvaluationWorkbook();
    public static HSSFEvaluationWorkbook Create(IWorkbook book);
    public sealed virtual void ClearAllCachedResultValues();
    public sealed virtual IName CreateName();
    public sealed virtual int GetExternalSheetIndex(string sheetName);
    public sealed virtual int GetExternalSheetIndex(string workbookName, string sheetName);
    public sealed virtual ExternalName GetExternalName(int externSheetIndex, int externNameIndex);
    public sealed virtual ExternalName GetExternalName(string nameName, string sheetName, int externalWorkbookNumber);
    public sealed virtual Ptg Get3DReferencePtg(CellReference cr, SheetIdentifier sheet);
    public sealed virtual Ptg Get3DReferencePtg(AreaReference areaRef, SheetIdentifier sheet);
    public sealed virtual Ptg GetNameXPtg(string name, SheetIdentifier sheet);
    public sealed virtual IEvaluationName GetName(string name, int sheetIndex);
    public sealed virtual int GetSheetIndex(IEvaluationSheet evalSheet);
    public sealed virtual int GetSheetIndex(string sheetName);
    public sealed virtual string GetSheetName(int sheetIndex);
    public sealed virtual IEvaluationSheet GetSheet(int sheetIndex);
    public sealed virtual int ConvertFromExternSheetIndex(int externSheetIndex);
    public sealed virtual ExternalSheet GetExternalSheet(int externSheetIndex);
    public sealed virtual ExternalSheet GetExternalSheet(string firstSheetName, string lastSheetName, int externalWorkbookNumber);
    public sealed virtual string ResolveNameXText(NameXPtg n);
    public sealed virtual string GetSheetFirstNameByExternSheet(int externSheetIndex);
    public sealed virtual string GetSheetLastNameByExternSheet(int externSheetIndex);
    public sealed virtual string GetNameText(NamePtg namePtg);
    public sealed virtual IEvaluationName GetName(NamePtg namePtg);
    public sealed virtual Ptg[] GetFormulaTokens(IEvaluationCell evalCell);
    public sealed virtual UDFFinder GetUDFFinder();
    private int GetSheetExtIx(SheetIdentifier sheetIden);
    public sealed virtual SpreadsheetVersion GetSpreadsheetVersion();
    public sealed virtual ITable GetTable(string name);
}
public class NPOI.HSSF.UserModel.HSSFExtendedColor : ExtendedColor {
    private ExtendedColor color;
    public ExtendedColor ExtendedColor { get; }
    public bool IsAuto { get; public set; }
    public bool IsIndexed { get; }
    public bool IsRGB { get; }
    public bool IsThemed { get; }
    public short Index { get; }
    public int Theme { get; public set; }
    public Byte[] RGB { get; public set; }
    public Byte[] ARGB { get; }
    protected Byte[] StoredRGB { get; }
    public double Tint { get; public set; }
    public HSSFExtendedColor(ExtendedColor color);
    protected ExtendedColor GetExtendedColor();
    public ExtendedColor get_ExtendedColor();
    public virtual bool get_IsAuto();
    public virtual void set_IsAuto(bool value);
    public virtual bool get_IsIndexed();
    public virtual bool get_IsRGB();
    public virtual bool get_IsThemed();
    public virtual short get_Index();
    public virtual int get_Theme();
    public virtual void set_Theme(int value);
    public virtual Byte[] get_RGB();
    public virtual void set_RGB(Byte[] value);
    public virtual Byte[] get_ARGB();
    protected virtual Byte[] get_StoredRGB();
    public void SetRGB(Byte[] rgb);
    public virtual double get_Tint();
    public virtual void set_Tint(double value);
}
public class NPOI.HSSF.UserModel.HSSFFont : object {
    public static string FONT_ARIAL;
    private FontRecord font;
    private short index;
    public string FontName { get; public set; }
    public short Index { get; }
    public double FontHeight { get; public set; }
    public double FontHeightInPoints { get; public set; }
    public bool IsItalic { get; public set; }
    public bool IsStrikeout { get; public set; }
    public short Color { get; public set; }
    [ObsoleteAttribute("deprecated POI 3.15 beta 2. Use IsBold instead.")]
public short Boldweight { get; public set; }
    public bool IsBold { get; public set; }
    public FontSuperScript TypeOffset { get; public set; }
    public FontUnderlineType Underline { get; public set; }
    public short Charset { get; public set; }
    public HSSFFont(short index, FontRecord rec);
    public sealed virtual string get_FontName();
    public sealed virtual void set_FontName(string value);
    public sealed virtual short get_Index();
    public sealed virtual double get_FontHeight();
    public sealed virtual void set_FontHeight(double value);
    public sealed virtual double get_FontHeightInPoints();
    public sealed virtual void set_FontHeightInPoints(double value);
    public sealed virtual bool get_IsItalic();
    public sealed virtual void set_IsItalic(bool value);
    public sealed virtual bool get_IsStrikeout();
    public sealed virtual void set_IsStrikeout(bool value);
    public sealed virtual short get_Color();
    public sealed virtual void set_Color(short value);
    public HSSFColor GetHSSFColor(HSSFWorkbook wb);
    public sealed virtual short get_Boldweight();
    public sealed virtual void set_Boldweight(short value);
    public sealed virtual bool get_IsBold();
    public sealed virtual void set_IsBold(bool value);
    public sealed virtual FontSuperScript get_TypeOffset();
    public sealed virtual void set_TypeOffset(FontSuperScript value);
    public sealed virtual FontUnderlineType get_Underline();
    public sealed virtual void set_Underline(FontUnderlineType value);
    public sealed virtual short get_Charset();
    public sealed virtual void set_Charset(short value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual void CloneStyleFrom(IFont src);
}
public class NPOI.HSSF.UserModel.HSSFFontFormatting : object {
    private FontFormatting fontFormatting;
    private HSSFWorkbook workbook;
    public FontSuperScript EscapementType { get; public set; }
    public short FontColorIndex { get; public set; }
    public IColor FontColor { get; public set; }
    public int FontHeight { get; public set; }
    public short FontWeight { get; }
    public FontUnderlineType UnderlineType { get; public set; }
    public bool IsBold { get; }
    public bool IsEscapementTypeModified { get; public set; }
    public bool IsFontCancellationModified { get; public set; }
    public bool IsFontOutlineModified { get; public set; }
    public bool IsFontShadowModified { get; public set; }
    public bool IsFontStyleModified { get; public set; }
    public bool IsItalic { get; }
    public bool IsOutlineOn { get; public set; }
    public bool IsShadowOn { get; public set; }
    public bool IsStrikeout { get; public set; }
    public bool IsUnderlineTypeModified { get; public set; }
    public bool IsFontWeightModified { get; }
    public HSSFFontFormatting(CFRuleBase cfRuleRecord, HSSFWorkbook workbook);
    protected FontFormatting GetFontFormattingBlock();
    public sealed virtual FontSuperScript get_EscapementType();
    public sealed virtual void set_EscapementType(FontSuperScript value);
    public sealed virtual short get_FontColorIndex();
    public sealed virtual void set_FontColorIndex(short value);
    public sealed virtual IColor get_FontColor();
    public sealed virtual void set_FontColor(IColor value);
    public sealed virtual int get_FontHeight();
    public sealed virtual void set_FontHeight(int value);
    public short get_FontWeight();
    protected Byte[] GetRawRecord();
    public sealed virtual FontUnderlineType get_UnderlineType();
    public sealed virtual void set_UnderlineType(FontUnderlineType value);
    public sealed virtual bool get_IsBold();
    public bool get_IsEscapementTypeModified();
    public void set_IsEscapementTypeModified(bool value);
    public bool get_IsFontCancellationModified();
    public void set_IsFontCancellationModified(bool value);
    public bool get_IsFontOutlineModified();
    public void set_IsFontOutlineModified(bool value);
    public bool get_IsFontShadowModified();
    public void set_IsFontShadowModified(bool value);
    public bool get_IsFontStyleModified();
    public void set_IsFontStyleModified(bool value);
    public sealed virtual bool get_IsItalic();
    public bool get_IsOutlineOn();
    public void set_IsOutlineOn(bool value);
    public bool get_IsShadowOn();
    public void set_IsShadowOn(bool value);
    public bool get_IsStrikeout();
    public void set_IsStrikeout(bool value);
    public bool get_IsUnderlineTypeModified();
    public void set_IsUnderlineTypeModified(bool value);
    public bool get_IsFontWeightModified();
    public sealed virtual void SetFontStyle(bool italic, bool bold);
    public sealed virtual void ResetFontStyle();
}
public class NPOI.HSSF.UserModel.HSSFFooter : HeaderFooter {
    private PageSettingsBlock _psb;
    public string RawText { get; }
    public HSSFFooter(PageSettingsBlock psb);
    public virtual string get_RawText();
    protected virtual void SetHeaderFooterText(string text);
}
public class NPOI.HSSF.UserModel.HSSFFormulaEvaluator : BaseFormulaEvaluator {
    private static Type[] VALUE_CONTRUCTOR_CLASS_ARRAY;
    private static Type[] AREA3D_CONSTRUCTOR_CLASS_ARRAY;
    private static Type[] REFERENCE_CONSTRUCTOR_CLASS_ARRAY;
    private static Type[] REF3D_CONSTRUCTOR_CLASS_ARRAY;
    private static Hashtable VALUE_EVALS_MAP;
    protected IRow row;
    protected ISheet sheet;
    protected IWorkbook _book;
    private static HSSFFormulaEvaluator();
    public HSSFFormulaEvaluator(IWorkbook workbook);
    public HSSFFormulaEvaluator(IWorkbook workbook, IStabilityClassifier stabilityClassifier);
    public HSSFFormulaEvaluator(IWorkbook workbook, IStabilityClassifier stabilityClassifier, UDFFinder udfFinder);
    public static HSSFFormulaEvaluator Create(IWorkbook workbook, IStabilityClassifier stabilityClassifier, UDFFinder udfFinder);
    protected virtual IRichTextString CreateRichTextString(string str);
    public static void SetupEnvironment(String[] workbookNames, HSSFFormulaEvaluator[] evaluators);
    public virtual void SetupReferencedWorkbooks(Dictionary`2<string, IFormulaEvaluator> evaluators);
    public virtual void NotifyUpdateCell(ICell cell);
    public virtual void NotifyDeleteCell(ICell cell);
    public virtual void NotifySetFormula(ICell cell);
    protected virtual CellValue EvaluateFormulaCellValue(ICell cell);
    public virtual ICell EvaluateInCell(ICell cell);
    public static void EvaluateAllFormulaCells(HSSFWorkbook wb);
    public static void EvaluateAllFormulaCells(IWorkbook wb);
    public virtual void EvaluateAll();
}
public class NPOI.HSSF.UserModel.HSSFHeader : HeaderFooter {
    private PageSettingsBlock _psb;
    public string RawText { get; }
    public HSSFHeader(PageSettingsBlock psb);
    public virtual string get_RawText();
    protected virtual void SetHeaderFooterText(string text);
}
public class NPOI.HSSF.UserModel.HSSFHyperlink : object {
    public HyperlinkRecord record;
    protected HyperlinkType link_type;
    public int FirstRow { get; public set; }
    public int LastRow { get; public set; }
    public int FirstColumn { get; public set; }
    public int LastColumn { get; public set; }
    public string Address { get; public set; }
    public string TextMark { get; public set; }
    public string ShortFilename { get; public set; }
    public string Label { get; public set; }
    public HyperlinkType Type { get; }
    public HSSFHyperlink(HyperlinkType type);
    public HSSFHyperlink(HyperlinkRecord record);
    public HSSFHyperlink(IHyperlink other);
    private HyperlinkType getType(HyperlinkRecord record);
    public sealed virtual int get_FirstRow();
    public sealed virtual void set_FirstRow(int value);
    public sealed virtual int get_LastRow();
    public sealed virtual void set_LastRow(int value);
    public sealed virtual int get_FirstColumn();
    public sealed virtual void set_FirstColumn(int value);
    public sealed virtual int get_LastColumn();
    public sealed virtual void set_LastColumn(int value);
    public sealed virtual string get_Address();
    public sealed virtual void set_Address(string value);
    public sealed virtual string get_TextMark();
    public sealed virtual void set_TextMark(string value);
    public string get_ShortFilename();
    public void set_ShortFilename(string value);
    public sealed virtual string get_Label();
    public sealed virtual void set_Label(string value);
    public sealed virtual HyperlinkType get_Type();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NPOI.HSSF.UserModel.HSSFIconMultiStateFormatting : object {
    private HSSFSheet sheet;
    private CFRule12Record cfRule12Record;
    private IconMultiStateFormatting iconFormatting;
    public IconSet IconSet { get; public set; }
    public bool IsIconOnly { get; public set; }
    public bool IsReversed { get; public set; }
    public IConditionalFormattingThreshold[] Thresholds { get; public set; }
    protected internal HSSFIconMultiStateFormatting(CFRule12Record cfRule12Record, HSSFSheet sheet);
    public sealed virtual IconSet get_IconSet();
    public sealed virtual void set_IconSet(IconSet value);
    public sealed virtual bool get_IsIconOnly();
    public sealed virtual void set_IsIconOnly(bool value);
    public sealed virtual bool get_IsReversed();
    public sealed virtual void set_IsReversed(bool value);
    public sealed virtual IConditionalFormattingThreshold[] get_Thresholds();
    public sealed virtual void set_Thresholds(IConditionalFormattingThreshold[] value);
    public sealed virtual IConditionalFormattingThreshold CreateThreshold();
}
public class NPOI.HSSF.UserModel.HSSFName : object {
    private HSSFWorkbook book;
    private NameRecord _definedNameRec;
    private NameCommentRecord _commentRec;
    public string SheetName { get; }
    public string NameName { get; public set; }
    public string RefersToFormula { get; public set; }
    public int SheetIndex { get; public set; }
    public string Comment { get; public set; }
    public bool IsDeleted { get; }
    public bool IsFunctionName { get; }
    internal HSSFName(HSSFWorkbook book, NameRecord name);
    internal HSSFName(HSSFWorkbook book, NameRecord name, NameCommentRecord comment);
    public sealed virtual string get_SheetName();
    public sealed virtual string get_NameName();
    public sealed virtual void set_NameName(string value);
    private void ValidateName(string name);
    public sealed virtual string get_RefersToFormula();
    public sealed virtual void set_RefersToFormula(string value);
    public sealed virtual int get_SheetIndex();
    public sealed virtual void set_SheetIndex(int value);
    public sealed virtual string get_Comment();
    public sealed virtual void set_Comment(string value);
    public void SetNameDefinition(Ptg[] ptgs);
    public sealed virtual bool get_IsDeleted();
    public sealed virtual bool get_IsFunctionName();
    public sealed virtual void SetFunction(bool value);
    public virtual string ToString();
}
public class NPOI.HSSF.UserModel.HSSFObjectData : HSSFPicture {
    private DirectoryEntry _root;
    public string OLE2ClassName { get; }
    public HSSFObjectData(EscherContainerRecord spContainer, ObjRecord objRecord, DirectoryEntry _root);
    public string get_OLE2ClassName();
    public DirectoryEntry GetDirectory();
    public Byte[] GetObjectData();
    public bool HasDirectoryEntry();
    public EmbeddedObjectRefSubRecord FindObjectRecord();
    protected virtual EscherContainerRecord CreateSpContainer();
    protected virtual ObjRecord CreateObjRecord();
    internal virtual void AfterRemove(HSSFPatriarch patriarch);
    internal virtual void AfterInsert(HSSFPatriarch patriarch);
    internal virtual HSSFShape CloneShape();
}
public class NPOI.HSSF.UserModel.HSSFOptimiser : object {
    public static void OptimiseFonts(HSSFWorkbook workbook);
    public static void OptimiseCellStyles(HSSFWorkbook workbook);
}
public class NPOI.HSSF.UserModel.HSSFPalette : object {
    private PaletteRecord palette;
    public HSSFPalette(PaletteRecord palette);
    public HSSFColor GetColor(short index);
    public HSSFColor FindColor(byte red, byte green, byte blue);
    public HSSFColor FindSimilarColor(byte red, byte green, byte blue);
    public void SetColorAtIndex(short index, byte red, byte green, byte blue);
    public HSSFColor AddColor(byte red, byte green, byte blue);
}
public class NPOI.HSSF.UserModel.HSSFPatriarch : object {
    private List`1<HSSFShape> _shapes;
    private HSSFSheet _sheet;
    private EscherSpgrRecord _spgrRecord;
    private EscherContainerRecord _mainSpgrContainer;
    private EscherAggregate _boundAggregate;
    public IList`1<HSSFShape> Children { get; }
    public int CountOfAllChildren { get; }
    public int X1 { get; }
    public int Y1 { get; }
    public int X2 { get; }
    public int Y2 { get; }
    protected internal HSSFSheet Sheet { get; }
    public HSSFPatriarch(HSSFSheet sheet, EscherAggregate boundAggregate);
    public static HSSFPatriarch CreatePatriarch(HSSFPatriarch patriarch, HSSFSheet sheet);
    protected internal void PreSerialize();
    public sealed virtual bool RemoveShape(HSSFShape shape);
    internal void AfterCreate();
    public HSSFShapeGroup CreateGroup(HSSFClientAnchor anchor);
    public HSSFSimpleShape CreateSimpleShape(HSSFClientAnchor anchor);
    public IPicture CreatePicture(HSSFClientAnchor anchor, int pictureIndex);
    public sealed virtual IPicture CreatePicture(IClientAnchor anchor, int pictureIndex);
    public HSSFObjectData CreateObjectData(HSSFClientAnchor anchor, int storageId, int pictureIndex);
    public HSSFPolygon CreatePolygon(IClientAnchor anchor);
    public HSSFSimpleShape CreateTextbox(IClientAnchor anchor);
    public HSSFComment CreateComment(HSSFAnchor anchor);
    public HSSFSimpleShape CreateComboBox(HSSFAnchor anchor);
    public sealed virtual IComment CreateCellComment(IClientAnchor anchor);
    private void SetFlipFlags(HSSFShape shape);
    public sealed virtual IList`1<HSSFShape> get_Children();
    public sealed virtual void AddShape(HSSFShape shape);
    private void OnCreate(HSSFShape shape);
    public int get_CountOfAllChildren();
    public sealed virtual void SetCoordinates(int x1, int y1, int x2, int y2);
    public sealed virtual void Clear();
    internal int NewShapeId();
    public bool ContainsChart();
    public sealed virtual int get_X1();
    public sealed virtual int get_Y1();
    public sealed virtual int get_X2();
    public sealed virtual int get_Y2();
    internal EscherAggregate GetBoundAggregate();
    public sealed virtual IClientAnchor CreateAnchor(int dx1, int dy1, int dx2, int dy2, int col1, int row1, int col2, int row2);
    public sealed virtual IChart CreateChart(IClientAnchor anchor);
    public void BuildShapeTree();
    public List`1<HSSFShape> GetShapes();
    public sealed virtual IEnumerator`1<HSSFShape> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected internal HSSFSheet get_Sheet();
}
public class NPOI.HSSF.UserModel.HSSFPatternFormatting : object {
    private CFRuleBase cfRuleRecord;
    private HSSFWorkbook workbook;
    private PatternFormatting patternFormatting;
    public PatternFormatting PatternFormattingBlock { get; }
    public IColor FillBackgroundColorColor { get; public set; }
    public IColor FillForegroundColorColor { get; public set; }
    public short FillBackgroundColor { get; public set; }
    public short FillForegroundColor { get; public set; }
    public FillPattern FillPattern { get; public set; }
    public HSSFPatternFormatting(CFRuleBase cfRuleRecord, HSSFWorkbook workbook);
    public PatternFormatting get_PatternFormattingBlock();
    public sealed virtual IColor get_FillBackgroundColorColor();
    public sealed virtual void set_FillBackgroundColorColor(IColor value);
    public sealed virtual IColor get_FillForegroundColorColor();
    public sealed virtual void set_FillForegroundColorColor(IColor value);
    public sealed virtual short get_FillBackgroundColor();
    public sealed virtual void set_FillBackgroundColor(short value);
    public sealed virtual short get_FillForegroundColor();
    public sealed virtual void set_FillForegroundColor(short value);
    public sealed virtual FillPattern get_FillPattern();
    public sealed virtual void set_FillPattern(FillPattern value);
}
public class NPOI.HSSF.UserModel.HSSFPicture : HSSFSimpleShape {
    private static POILogger logger;
    public int PictureIndex { get; public set; }
    public IPictureData PictureData { get; }
    public string FileName { get; public set; }
    public int ShapeType { get; public set; }
    public IClientAnchor ClientAnchor { get; }
    public ISheet Sheet { get; }
    public HSSFPicture(EscherContainerRecord spContainer, ObjRecord objRecord);
    public HSSFPicture(HSSFShape parent, HSSFAnchor anchor);
    private static HSSFPicture();
    protected virtual EscherContainerRecord CreateSpContainer();
    public sealed virtual void Resize();
    public sealed virtual void Resize(double scale);
    public sealed virtual void Resize(double scaleX, double scaleY);
    public int get_PictureIndex();
    public void set_PictureIndex(int value);
    public IClientAnchor GetPreferredSize(double scale);
    public sealed virtual IClientAnchor GetPreferredSize(double scaleX, double scaleY);
    public sealed virtual IClientAnchor GetPreferredSize();
    protected Size GetResolution(Image r);
    public sealed virtual Size GetImageDimension();
    public sealed virtual IPictureData get_PictureData();
    internal virtual void AfterInsert(HSSFPatriarch patriarch);
    public string get_FileName();
    public void set_FileName(string value);
    private string Trim(string value);
    public virtual int get_ShapeType();
    public virtual void set_ShapeType(int value);
    internal virtual HSSFShape CloneShape();
    public sealed virtual IClientAnchor get_ClientAnchor();
    public sealed virtual ISheet get_Sheet();
}
public class NPOI.HSSF.UserModel.HSSFPictureData : object {
    public static short MSOBI_WMF;
    public static short MSOBI_EMF;
    public static short MSOBI_PICT;
    public static short MSOBI_PNG;
    public static short MSOBI_JPEG;
    public static short MSOBI_DIB;
    public static short FORMAT_MASK;
    private EscherBlipRecord blip;
    public Byte[] Data { get; }
    public int Format { get; }
    public string MimeType { get; }
    public PictureType PictureType { get; }
    public HSSFPictureData(EscherBlipRecord blip);
    public sealed virtual Byte[] get_Data();
    public int get_Format();
    public sealed virtual string SuggestFileExtension();
    public sealed virtual string get_MimeType();
    public sealed virtual PictureType get_PictureType();
}
public class NPOI.HSSF.UserModel.HSSFPolygon : HSSFSimpleShape {
    private static POILogger logger;
    public static short OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING;
    public Int32[] XPoints { get; }
    public Int32[] YPoints { get; }
    public int DrawAreaWidth { get; }
    public int DrawAreaHeight { get; }
    public HSSFPolygon(EscherContainerRecord spContainer, ObjRecord objRecord, TextObjectRecord _textObjectRecord);
    public HSSFPolygon(EscherContainerRecord spContainer, ObjRecord objRecord);
    public HSSFPolygon(HSSFShape parent, HSSFAnchor anchor);
    private static HSSFPolygon();
    protected virtual TextObjectRecord CreateTextObjRecord();
    protected virtual EscherContainerRecord CreateSpContainer();
    protected virtual ObjRecord CreateObjRecord();
    internal virtual void AfterRemove(HSSFPatriarch patriarch);
    public Int32[] get_XPoints();
    public Int32[] get_YPoints();
    public void SetPoints(Int32[] xPoints, Int32[] yPoints);
    public void SetPolygonDrawArea(int width, int height);
    public int get_DrawAreaWidth();
    public int get_DrawAreaHeight();
}
public class NPOI.HSSF.UserModel.HSSFPrintSetup : object {
    private PrintSetupRecord printSetupRecord;
    public short PaperSize { get; public set; }
    public short Scale { get; public set; }
    public short PageStart { get; public set; }
    public short FitWidth { get; public set; }
    public short FitHeight { get; public set; }
    public short Options { get; public set; }
    public bool LeftToRight { get; public set; }
    public bool Landscape { get; public set; }
    public bool ValidSettings { get; public set; }
    public bool NoColor { get; public set; }
    public bool EndNote { get; public set; }
    public DisplayCellErrorType CellError { get; public set; }
    public bool Draft { get; public set; }
    public bool Notes { get; public set; }
    public bool NoOrientation { get; public set; }
    public bool UsePage { get; public set; }
    public short HResolution { get; public set; }
    public short VResolution { get; public set; }
    public double HeaderMargin { get; public set; }
    public double FooterMargin { get; public set; }
    public short Copies { get; public set; }
    public HSSFPrintSetup(PrintSetupRecord printSetupRecord);
    public sealed virtual short get_PaperSize();
    public sealed virtual void set_PaperSize(short value);
    public sealed virtual short get_Scale();
    public sealed virtual void set_Scale(short value);
    public sealed virtual short get_PageStart();
    public sealed virtual void set_PageStart(short value);
    public sealed virtual short get_FitWidth();
    public sealed virtual void set_FitWidth(short value);
    public sealed virtual short get_FitHeight();
    public sealed virtual void set_FitHeight(short value);
    public short get_Options();
    public void set_Options(short value);
    public sealed virtual bool get_LeftToRight();
    public sealed virtual void set_LeftToRight(bool value);
    public sealed virtual bool get_Landscape();
    public sealed virtual void set_Landscape(bool value);
    public sealed virtual bool get_ValidSettings();
    public sealed virtual void set_ValidSettings(bool value);
    public sealed virtual bool get_NoColor();
    public sealed virtual void set_NoColor(bool value);
    public sealed virtual bool get_EndNote();
    public sealed virtual void set_EndNote(bool value);
    public sealed virtual DisplayCellErrorType get_CellError();
    public sealed virtual void set_CellError(DisplayCellErrorType value);
    public sealed virtual bool get_Draft();
    public sealed virtual void set_Draft(bool value);
    public sealed virtual bool get_Notes();
    public sealed virtual void set_Notes(bool value);
    public sealed virtual bool get_NoOrientation();
    public sealed virtual void set_NoOrientation(bool value);
    public sealed virtual bool get_UsePage();
    public sealed virtual void set_UsePage(bool value);
    public sealed virtual short get_HResolution();
    public sealed virtual void set_HResolution(short value);
    public sealed virtual short get_VResolution();
    public sealed virtual void set_VResolution(short value);
    public sealed virtual double get_HeaderMargin();
    public sealed virtual void set_HeaderMargin(double value);
    public sealed virtual double get_FooterMargin();
    public sealed virtual void set_FooterMargin(double value);
    public sealed virtual short get_Copies();
    public sealed virtual void set_Copies(short value);
}
public class NPOI.HSSF.UserModel.HSSFRichTextString : object {
    public static short NO_FONT;
    private UnicodeString _string;
    private InternalWorkbook _book;
    private LabelSSTRecord _record;
    public string String { get; }
    public UnicodeString RawUnicodeString { get; }
    public UnicodeString UnicodeString { get; public set; }
    public int Length { get; }
    public int NumFormattingRuns { get; }
    public HSSFRichTextString(string str);
    public HSSFRichTextString(InternalWorkbook book, LabelSSTRecord record);
    public void SetWorkbookReferences(InternalWorkbook book, LabelSSTRecord record);
    private UnicodeString CloneStringIfRequired();
    private void AddToSSTIfRequired();
    public sealed virtual void ApplyFont(int startIndex, int endIndex, short fontIndex);
    public sealed virtual void ApplyFont(int startIndex, int endIndex, IFont font);
    public sealed virtual void ApplyFont(IFont font);
    public sealed virtual void ClearFormatting();
    public sealed virtual string get_String();
    public UnicodeString get_RawUnicodeString();
    public UnicodeString get_UnicodeString();
    public void set_UnicodeString(UnicodeString value);
    public sealed virtual int get_Length();
    public short GetFontAtIndex(int index);
    public sealed virtual int get_NumFormattingRuns();
    public sealed virtual int GetIndexOfFormattingRun(int index);
    public short GetFontOfFormattingRun(int index);
    public sealed virtual int CompareTo(HSSFRichTextString other);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual void ApplyFont(short fontIndex);
}
public class NPOI.HSSF.UserModel.HSSFRow : object {
    public static int INITIAL_CAPACITY;
    private int rowNum;
    private SortedDictionary`2<int, ICell> cells;
    private RowRecord row;
    private HSSFWorkbook book;
    private HSSFSheet sheet;
    public bool IsHidden { get; public set; }
    public int RowNum { get; public set; }
    public int OutlineLevel { get; }
    public ISheet Sheet { get; }
    public short FirstCellNum { get; }
    public short LastCellNum { get; }
    public int PhysicalNumberOfCells { get; }
    public bool ZeroHeight { get; public set; }
    public short Height { get; public set; }
    public bool IsFormatted { get; }
    public ICellStyle RowStyle { get; public set; }
    public float HeightInPoints { get; public set; }
    public RowRecord RowRecord { get; }
    public List`1<ICell> Cells { get; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Collapsed { get; public set; }
    public HSSFRow(HSSFWorkbook book, HSSFSheet sheet, int rowNum);
    public HSSFRow(HSSFWorkbook book, HSSFSheet sheet, RowRecord record);
    public sealed virtual ICell CreateCell(int column);
    public sealed virtual ICell CreateCell(int columnIndex, CellType type);
    public sealed virtual IRow CopyRowTo(int targetIndex);
    public sealed virtual ICell CopyCell(int sourceIndex, int targetIndex);
    public sealed virtual void RemoveCell(ICell cell);
    private void RemoveCell(ICell cell, bool alsoRemoveRecords);
    private int CalculateNewLastCellPlusOne(int lastcell);
    private int CalculateNewFirstCell(int firstcell);
    public ICell CreateCellFromRecord(CellValueRecordInterface cell);
    public bool get_IsHidden();
    public void set_IsHidden(bool value);
    public void RemoveAllCells();
    public sealed virtual int get_RowNum();
    public sealed virtual void set_RowNum(int value);
    public sealed virtual int get_OutlineLevel();
    public sealed virtual void MoveCell(ICell cell, int newColumn);
    public sealed virtual ISheet get_Sheet();
    private void AddCell(ICell cell);
    private ICell RetrieveCell(int cellnum);
    public sealed virtual ICell GetCell(int cellnum);
    public sealed virtual ICell GetCell(int cellnum, MissingCellPolicy policy);
    public sealed virtual short get_FirstCellNum();
    public sealed virtual short get_LastCellNum();
    public sealed virtual int get_PhysicalNumberOfCells();
    public sealed virtual bool get_ZeroHeight();
    public sealed virtual void set_ZeroHeight(bool value);
    public sealed virtual short get_Height();
    public sealed virtual void set_Height(short value);
    public sealed virtual bool get_IsFormatted();
    public sealed virtual ICellStyle get_RowStyle();
    public sealed virtual void set_RowStyle(ICellStyle value);
    public sealed virtual float get_HeightInPoints();
    public sealed virtual void set_HeightInPoints(float value);
    public RowRecord get_RowRecord();
    [ObsoleteAttribute]
private short FindFirstCell(int firstcell);
    public sealed virtual List`1<ICell> get_Cells();
    public sealed virtual Nullable`1<bool> get_Hidden();
    public sealed virtual void set_Hidden(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_Collapsed();
    public sealed virtual void set_Collapsed(Nullable`1<bool> value);
    public sealed virtual IEnumerator`1<ICell> GetEnumerator();
    public sealed virtual int CompareTo(HSSFRow other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool HasCustomHeight();
}
public abstract class NPOI.HSSF.UserModel.HSSFShape : object {
    public static int LINEWIDTH_ONE_PT;
    public static int LINEWIDTH_DEFAULT;
    public static int LINESTYLE__COLOR_DEFAULT;
    public static int FILL__FILLCOLOR_DEFAULT;
    public static bool NO_FILL_DEFAULT;
    public static int LINESTYLE_SOLID;
    public static int LINESTYLE_DASHSYS;
    public static int LINESTYLE_DOTSYS;
    public static int LINESTYLE_DASHDOTSYS;
    public static int LINESTYLE_DASHDOTDOTSYS;
    public static int LINESTYLE_DOTGEL;
    public static int LINESTYLE_DASHGEL;
    public static int LINESTYLE_LONGDASHGEL;
    public static int LINESTYLE_DASHDOTGEL;
    public static int LINESTYLE_LONGDASHDOTGEL;
    public static int LINESTYLE_LONGDASHDOTDOTGEL;
    public static int LINESTYLE_NONE;
    public static int LINESTYLE_DEFAULT;
    public static int NO_FILLHITTEST_TRUE;
    public static int NO_FILLHITTEST_FALSE;
    private HSSFShape parent;
    protected HSSFAnchor anchor;
    protected internal HSSFPatriarch _patriarch;
    private EscherContainerRecord _escherContainer;
    private ObjRecord _objRecord;
    private EscherOptRecord _optRecord;
    public int ShapeId { get; public set; }
    public HSSFShape Parent { get; public set; }
    public HSSFAnchor Anchor { get; public set; }
    public int LineStyleColor { get; public set; }
    public int FillColor { get; public set; }
    public int LineWidth { get; public set; }
    public LineStyle LineStyle { get; public set; }
    public bool IsNoFill { get; public set; }
    public bool IsFlipVertical { get; public set; }
    public bool IsFlipHorizontal { get; public set; }
    public int RotationDegree { get; public set; }
    public int CountOfAllChildren { get; }
    public HSSFPatriarch Patriarch { get; public set; }
    public HSSFShape(EscherContainerRecord spContainer, ObjRecord objRecord);
    public HSSFShape(HSSFShape parent, HSSFAnchor anchor);
    protected abstract virtual EscherContainerRecord CreateSpContainer();
    protected abstract virtual ObjRecord CreateObjRecord();
    internal abstract virtual void AfterRemove(HSSFPatriarch patriarch);
    internal abstract virtual void AfterInsert(HSSFPatriarch patriarch);
    public virtual int get_ShapeId();
    public virtual void set_ShapeId(int value);
    public HSSFShape get_Parent();
    public void set_Parent(HSSFShape value);
    public HSSFAnchor get_Anchor();
    public void set_Anchor(HSSFAnchor value);
    public int get_LineStyleColor();
    public void set_LineStyleColor(int value);
    internal EscherContainerRecord GetEscherContainer();
    public void SetLineStyleColor(int red, int green, int blue);
    protected void SetPropertyValue(EscherProperty property);
    public int get_FillColor();
    public void set_FillColor(int value);
    public void SetFillColor(int red, int green, int blue);
    public int get_LineWidth();
    public void set_LineWidth(int value);
    public LineStyle get_LineStyle();
    public void set_LineStyle(LineStyle value);
    public bool get_IsNoFill();
    public void set_IsNoFill(bool value);
    public bool get_IsFlipVertical();
    public void set_IsFlipVertical(bool value);
    public bool get_IsFlipHorizontal();
    public void set_IsFlipHorizontal(bool value);
    public int get_RotationDegree();
    public void set_RotationDegree(int value);
    public virtual int get_CountOfAllChildren();
    internal abstract virtual HSSFShape CloneShape();
    public HSSFPatriarch get_Patriarch();
    public void set_Patriarch(HSSFPatriarch value);
    protected internal ObjRecord GetObjRecord();
    protected internal EscherOptRecord GetOptRecord();
}
public interface NPOI.HSSF.UserModel.HSSFShapeContainer {
    public IList`1<HSSFShape> Children { get; }
    public int X1 { get; }
    public int Y1 { get; }
    public int X2 { get; }
    public int Y2 { get; }
    public abstract virtual IList`1<HSSFShape> get_Children();
    public abstract virtual void AddShape(HSSFShape shape);
    public abstract virtual void SetCoordinates(int x1, int y1, int x2, int y2);
    public abstract virtual void Clear();
    public abstract virtual int get_X1();
    public abstract virtual int get_Y1();
    public abstract virtual int get_X2();
    public abstract virtual int get_Y2();
    public abstract virtual bool RemoveShape(HSSFShape shape);
}
public class NPOI.HSSF.UserModel.HSSFShapeFactory : object {
    public static void CreateShapeTree(EscherContainerRecord container, EscherAggregate agg, HSSFShapeContainer out1, DirectoryNode root);
    private static bool IsEmbeddedObject(ObjRecord obj);
}
public class NPOI.HSSF.UserModel.HSSFShapeGroup : HSSFShape {
    private List`1<HSSFShape> shapes;
    private EscherSpgrRecord _spgrRecord;
    public IList`1<HSSFShape> Children { get; }
    public int X1 { get; }
    public int Y1 { get; }
    public int X2 { get; }
    public int Y2 { get; }
    public int CountOfAllChildren { get; }
    public int ShapeId { get; public set; }
    public HSSFShapeGroup(EscherContainerRecord spgrContainer, ObjRecord objRecord);
    public HSSFShapeGroup(HSSFShape parent, HSSFAnchor anchor);
    protected virtual EscherContainerRecord CreateSpContainer();
    protected virtual ObjRecord CreateObjRecord();
    internal virtual void AfterRemove(HSSFPatriarch patriarch);
    private void OnCreate(HSSFShape shape);
    public HSSFShapeGroup CreateGroup(HSSFChildAnchor anchor);
    public sealed virtual void AddShape(HSSFShape shape);
    public HSSFSimpleShape CreateShape(HSSFChildAnchor anchor);
    public HSSFTextbox CreateTextbox(HSSFChildAnchor anchor);
    public HSSFPolygon CreatePolygon(HSSFChildAnchor anchor);
    public HSSFPicture CreatePicture(HSSFChildAnchor anchor, int pictureIndex);
    public sealed virtual IList`1<HSSFShape> get_Children();
    public sealed virtual void SetCoordinates(int x1, int y1, int x2, int y2);
    public sealed virtual void Clear();
    public sealed virtual int get_X1();
    public sealed virtual int get_Y1();
    public sealed virtual int get_X2();
    public sealed virtual int get_Y2();
    public virtual int get_CountOfAllChildren();
    internal virtual void AfterInsert(HSSFPatriarch patriarch);
    public virtual int get_ShapeId();
    public virtual void set_ShapeId(int value);
    internal virtual HSSFShape CloneShape();
    internal HSSFShape CloneShape(HSSFPatriarch patriarch);
    public sealed virtual bool RemoveShape(HSSFShape shape);
    public sealed virtual IEnumerator`1<HSSFShape> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum NPOI.HSSF.UserModel.HSSFShapeTypes : Enum {
    public int value__;
    public static HSSFShapeTypes NotPrimitive;
    public static HSSFShapeTypes Rectangle;
    public static HSSFShapeTypes RoundRectangle;
    public static HSSFShapeTypes Ellipse;
    public static HSSFShapeTypes Diamond;
    public static HSSFShapeTypes IsocelesTriangle;
    public static HSSFShapeTypes RightTriangle;
    public static HSSFShapeTypes Parallelogram;
    public static HSSFShapeTypes Trapezoid;
    public static HSSFShapeTypes Hexagon;
    public static HSSFShapeTypes Octagon;
    public static HSSFShapeTypes Plus;
    public static HSSFShapeTypes Star;
    public static HSSFShapeTypes Arrow;
    public static HSSFShapeTypes ThickArrow;
    public static HSSFShapeTypes HomePlate;
    public static HSSFShapeTypes Cube;
    public static HSSFShapeTypes Balloon;
    public static HSSFShapeTypes Seal;
    public static HSSFShapeTypes Arc;
    public static HSSFShapeTypes Line;
    public static HSSFShapeTypes Plaque;
    public static HSSFShapeTypes Can;
    public static HSSFShapeTypes Donut;
    public static HSSFShapeTypes TextSimple;
    public static HSSFShapeTypes TextOctagon;
    public static HSSFShapeTypes TextHexagon;
    public static HSSFShapeTypes TextCurve;
    public static HSSFShapeTypes TextWave;
    public static HSSFShapeTypes TextRing;
    public static HSSFShapeTypes TextOnCurve;
    public static HSSFShapeTypes TextOnRing;
    public static HSSFShapeTypes StraightConnector1;
    public static HSSFShapeTypes BentConnector2;
    public static HSSFShapeTypes BentConnector3;
    public static HSSFShapeTypes BentConnector4;
    public static HSSFShapeTypes BentConnector5;
    public static HSSFShapeTypes CurvedConnector2;
    public static HSSFShapeTypes CurvedConnector3;
    public static HSSFShapeTypes CurvedConnector4;
    public static HSSFShapeTypes CurvedConnector5;
    public static HSSFShapeTypes Callout1;
    public static HSSFShapeTypes Callout2;
    public static HSSFShapeTypes Callout3;
    public static HSSFShapeTypes AccentCallout1;
    public static HSSFShapeTypes AccentCallout2;
    public static HSSFShapeTypes AccentCallout3;
    public static HSSFShapeTypes BorderCallout1;
    public static HSSFShapeTypes BorderCallout2;
    public static HSSFShapeTypes BorderCallout3;
    public static HSSFShapeTypes AccentBorderCallout1;
    public static HSSFShapeTypes AccentBorderCallout2;
    public static HSSFShapeTypes AccentBorderCallout3;
    public static HSSFShapeTypes Ribbon;
    public static HSSFShapeTypes Ribbon2;
    public static HSSFShapeTypes Chevron;
    public static HSSFShapeTypes Pentagon;
    public static HSSFShapeTypes NoSmoking;
    public static HSSFShapeTypes Star8;
    public static HSSFShapeTypes Star16;
    public static HSSFShapeTypes Star32;
    public static HSSFShapeTypes WedgeRectCallout;
    public static HSSFShapeTypes WedgeRRectCallout;
    public static HSSFShapeTypes WedgeEllipseCallout;
    public static HSSFShapeTypes Wave;
    public static HSSFShapeTypes FoldedCorner;
    public static HSSFShapeTypes LeftArrow;
    public static HSSFShapeTypes DownArrow;
    public static HSSFShapeTypes UpArrow;
    public static HSSFShapeTypes LeftRightArrow;
    public static HSSFShapeTypes UpDownArrow;
    public static HSSFShapeTypes IrregularSeal1;
    public static HSSFShapeTypes IrregularSeal2;
    public static HSSFShapeTypes LightningBolt;
    public static HSSFShapeTypes Heart;
    public static HSSFShapeTypes PictureFrame;
    public static HSSFShapeTypes QuadArrow;
    public static HSSFShapeTypes LeftArrowCallout;
    public static HSSFShapeTypes RightArrowCallout;
    public static HSSFShapeTypes UpArrowCallout;
    public static HSSFShapeTypes DownArrowCallout;
    public static HSSFShapeTypes LeftRightArrowCallout;
    public static HSSFShapeTypes UpDownArrowCallout;
    public static HSSFShapeTypes QuadArrowCallout;
    public static HSSFShapeTypes Bevel;
    public static HSSFShapeTypes LeftBracket;
    public static HSSFShapeTypes RightBracket;
    public static HSSFShapeTypes LeftBrace;
    public static HSSFShapeTypes RightBrace;
    public static HSSFShapeTypes LeftUpArrow;
    public static HSSFShapeTypes BentUpArrow;
    public static HSSFShapeTypes BentArrow;
    public static HSSFShapeTypes Star24;
    public static HSSFShapeTypes StripedRightArrow;
    public static HSSFShapeTypes NotchedRightArrow;
    public static HSSFShapeTypes BlockArc;
    public static HSSFShapeTypes SmileyFace;
    public static HSSFShapeTypes VerticalScroll;
    public static HSSFShapeTypes HorizontalScroll;
    public static HSSFShapeTypes CircularArrow;
    public static HSSFShapeTypes NotchedCircularArrow;
    public static HSSFShapeTypes UturnArrow;
    public static HSSFShapeTypes CurvedRightArrow;
    public static HSSFShapeTypes CurvedLeftArrow;
    public static HSSFShapeTypes CurvedUpArrow;
    public static HSSFShapeTypes CurvedDownArrow;
    public static HSSFShapeTypes CloudCallout;
    public static HSSFShapeTypes EllipseRibbon;
    public static HSSFShapeTypes EllipseRibbon2;
    public static HSSFShapeTypes FlowChartProcess;
    public static HSSFShapeTypes FlowChartDecision;
    public static HSSFShapeTypes FlowChartInputOutput;
    public static HSSFShapeTypes FlowChartPredefinedProcess;
    public static HSSFShapeTypes FlowChartInternalStorage;
    public static HSSFShapeTypes FlowChartDocument;
    public static HSSFShapeTypes FlowChartMultidocument;
    public static HSSFShapeTypes FlowChartTerminator;
    public static HSSFShapeTypes FlowChartPreparation;
    public static HSSFShapeTypes FlowChartManualInput;
    public static HSSFShapeTypes FlowChartManualOperation;
    public static HSSFShapeTypes FlowChartConnector;
    public static HSSFShapeTypes FlowChartPunchedCard;
    public static HSSFShapeTypes FlowChartPunchedTape;
    public static HSSFShapeTypes FlowChartSummingJunction;
    public static HSSFShapeTypes FlowChartOr;
    public static HSSFShapeTypes FlowChartCollate;
    public static HSSFShapeTypes FlowChartSort;
    public static HSSFShapeTypes FlowChartExtract;
    public static HSSFShapeTypes FlowChartMerge;
    public static HSSFShapeTypes FlowChartOfflineStorage;
    public static HSSFShapeTypes FlowChartOnlineStorage;
    public static HSSFShapeTypes FlowChartMagneticTape;
    public static HSSFShapeTypes FlowChartMagneticDisk;
    public static HSSFShapeTypes FlowChartMagneticDrum;
    public static HSSFShapeTypes FlowChartDisplay;
    public static HSSFShapeTypes FlowChartDelay;
    public static HSSFShapeTypes TextPlainText;
    public static HSSFShapeTypes TextStop;
    public static HSSFShapeTypes TextTriangle;
    public static HSSFShapeTypes TextTriangleInverted;
    public static HSSFShapeTypes TextChevron;
    public static HSSFShapeTypes TextChevronInverted;
    public static HSSFShapeTypes TextRingInside;
    public static HSSFShapeTypes TextRingOutside;
    public static HSSFShapeTypes TextArchUpCurve;
    public static HSSFShapeTypes TextArchDownCurve;
    public static HSSFShapeTypes TextCircleCurve;
    public static HSSFShapeTypes TextButtonCurve;
    public static HSSFShapeTypes TextArchUpPour;
    public static HSSFShapeTypes TextArchDownPour;
    public static HSSFShapeTypes TextCirclePour;
    public static HSSFShapeTypes TextButtonPour;
    public static HSSFShapeTypes TextCurveUp;
    public static HSSFShapeTypes TextCurveDown;
    public static HSSFShapeTypes TextCascadeUp;
    public static HSSFShapeTypes TextCascadeDown;
    public static HSSFShapeTypes TextWave1;
    public static HSSFShapeTypes TextWave2;
    public static HSSFShapeTypes TextWave3;
    public static HSSFShapeTypes TextWave4;
    public static HSSFShapeTypes TextInflate;
    public static HSSFShapeTypes TextDeflate;
    public static HSSFShapeTypes TextInflateBottom;
    public static HSSFShapeTypes TextDeflateBottom;
    public static HSSFShapeTypes TextInflateTop;
    public static HSSFShapeTypes TextDeflateTop;
    public static HSSFShapeTypes TextDeflateInflate;
    public static HSSFShapeTypes TextDeflateInflateDeflate;
    public static HSSFShapeTypes TextFadeRight;
    public static HSSFShapeTypes TextFadeLeft;
    public static HSSFShapeTypes TextFadeUp;
    public static HSSFShapeTypes TextFadeDown;
    public static HSSFShapeTypes TextSlantUp;
    public static HSSFShapeTypes TextSlantDown;
    public static HSSFShapeTypes TextCanUp;
    public static HSSFShapeTypes TextCanDown;
    public static HSSFShapeTypes FlowChartAlternateProcess;
    public static HSSFShapeTypes FlowChartOffpageConnector;
    public static HSSFShapeTypes Callout90;
    public static HSSFShapeTypes AccentCallout90;
    public static HSSFShapeTypes BorderCallout90;
    public static HSSFShapeTypes AccentBorderCallout90;
    public static HSSFShapeTypes LeftRightUpArrow;
    public static HSSFShapeTypes Sun;
    public static HSSFShapeTypes Moon;
    public static HSSFShapeTypes BracketPair;
    public static HSSFShapeTypes BracePair;
    public static HSSFShapeTypes Star4;
    public static HSSFShapeTypes DoubleWave;
    public static HSSFShapeTypes ActionButtonBlank;
    public static HSSFShapeTypes ActionButtonHome;
    public static HSSFShapeTypes ActionButtonHelp;
    public static HSSFShapeTypes ActionButtonInformation;
    public static HSSFShapeTypes ActionButtonForwardNext;
    public static HSSFShapeTypes ActionButtonBackPrevious;
    public static HSSFShapeTypes ActionButtonEnd;
    public static HSSFShapeTypes ActionButtonBeginning;
    public static HSSFShapeTypes ActionButtonReturn;
    public static HSSFShapeTypes ActionButtonDocument;
    public static HSSFShapeTypes ActionButtonSound;
    public static HSSFShapeTypes ActionButtonMovie;
    public static HSSFShapeTypes HostControl;
    public static HSSFShapeTypes TextBox;
}
public class NPOI.HSSF.UserModel.HSSFSheet : object {
    private static float PX_DEFAULT;
    private static float PX_MODIFIED;
    public static int INITIAL_CAPACITY;
    private InternalSheet _sheet;
    private Dictionary`2<int, IRow> rows;
    public InternalWorkbook book;
    protected HSSFWorkbook _workbook;
    private int firstrow;
    private int lastrow;
    private HSSFPatriarch _patriarch;
    public bool DisplayZeros { get; public set; }
    public int PhysicalNumberOfRows { get; }
    public int FirstRowNum { get; }
    public int LastRowNum { get; }
    public double DefaultColumnWidth { get; public set; }
    public short DefaultRowHeight { get; public set; }
    public float DefaultRowHeightInPoints { get; public set; }
    [ObsoleteAttribute("Please use IsPrintGridlines instead")]
public bool IsGridsPrinted { get; public set; }
    public bool ForceFormulaRecalculation { get; public set; }
    public bool VerticallyCenter { get; public set; }
    public bool HorizontallyCenter { get; public set; }
    public int NumMergedRegions { get; }
    public InternalSheet Sheet { get; }
    public bool AlternativeExpression { get; public set; }
    public bool AlternativeFormula { get; public set; }
    public bool Autobreaks { get; public set; }
    public bool Dialog { get; public set; }
    public bool DisplayGuts { get; public set; }
    public bool FitToPage { get; public set; }
    public bool RowSumsBelow { get; public set; }
    public bool RowSumsRight { get; public set; }
    public bool IsPrintGridlines { get; public set; }
    public bool IsPrintRowAndColumnHeadings { get; public set; }
    public IPrintSetup PrintSetup { get; }
    public IHeader Header { get; }
    public IFooter Footer { get; }
    public bool IsRightToLeft { get; public set; }
    public bool IsSelected { get; public set; }
    public bool IsActive { get; public set; }
    private WorksheetProtectionBlock ProtectionBlock { get; }
    public bool Protect { get; }
    public short Password { get; }
    public bool ObjectProtect { get; }
    public bool ScenarioProtect { get; }
    public short TopRow { get; public set; }
    public short LeftCol { get; public set; }
    public PaneInformation PaneInformation { get; }
    public bool DisplayGridlines { get; public set; }
    public bool DisplayFormulas { get; public set; }
    public bool DisplayRowColHeadings { get; public set; }
    public Int32[] RowBreaks { get; }
    public Int32[] ColumnBreaks { get; }
    public EscherAggregate DrawingEscherAggregate { get; }
    public IDrawing DrawingPatriarch { get; }
    public short TabColorIndex { get; public set; }
    public bool IsAutoTabColor { get; public set; }
    public List`1<CellRangeAddress> MergedRegions { get; }
    public ISheetConditionalFormatting SheetConditionalFormatting { get; }
    public IList DVRecords { get; }
    public IWorkbook Workbook { get; }
    public string SheetName { get; }
    public CellRangeAddress RepeatingRows { get; public set; }
    public CellRangeAddress RepeatingColumns { get; public set; }
    public CellAddress ActiveCell { get; public set; }
    public HSSFSheet(HSSFWorkbook workbook);
    public HSSFSheet(HSSFWorkbook workbook, InternalSheet sheet);
    private static HSSFSheet();
    public ISheet CloneSheet(HSSFWorkbook workbook);
    internal void PreSerialize();
    public sealed virtual IRow CopyRow(int sourceIndex, int targetIndex);
    public sealed virtual IComment CopyComment(ICell sourceCell, ICell targetCell);
    private void SetPropertiesFromSheet(InternalSheet sheet);
    public sealed virtual bool get_DisplayZeros();
    public sealed virtual void set_DisplayZeros(bool value);
    public sealed virtual IRow CreateRow(int rownum);
    private HSSFRow CreateRowFromRecord(RowRecord row);
    public sealed virtual void RemoveRow(IRow row);
    private int FindLastRow(int lastrow);
    private int FindFirstRow(int firstrow);
    private void AddRow(HSSFRow row, bool addLow);
    public sealed virtual ICellStyle GetColumnStyle(int column);
    public sealed virtual IRow GetRow(int rowIndex);
    public sealed virtual int get_PhysicalNumberOfRows();
    public sealed virtual int get_FirstRowNum();
    public sealed virtual int get_LastRowNum();
    public sealed virtual List`1<IDataValidation> GetDataValidations();
    public sealed virtual void AddValidationData(IDataValidation dataValidation);
    public sealed virtual void RemoveDataValidation(IDataValidation dataValidation);
    public sealed virtual void SetColumnHidden(int column, bool hidden);
    public sealed virtual bool IsColumnHidden(int column);
    public sealed virtual void SetColumnWidth(int column, double width);
    public sealed virtual double GetColumnWidth(int column);
    public sealed virtual double GetColumnWidthInPixels(int column);
    public sealed virtual double get_DefaultColumnWidth();
    public sealed virtual void set_DefaultColumnWidth(double value);
    public sealed virtual short get_DefaultRowHeight();
    public sealed virtual void set_DefaultRowHeight(short value);
    public sealed virtual float get_DefaultRowHeightInPoints();
    public sealed virtual void set_DefaultRowHeightInPoints(float value);
    public bool get_IsGridsPrinted();
    public void set_IsGridsPrinted(bool value);
    public sealed virtual int AddMergedRegion(CellRangeAddress region);
    public sealed virtual int AddMergedRegionUnsafe(CellRangeAddress region);
    public sealed virtual void ValidateMergedRegions();
    private int AddMergedRegion(CellRangeAddress region, bool validate);
    private void ValidateArrayFormulas(CellRangeAddress region);
    private void CheckForMergedRegionsIntersectingArrayFormulas();
    private void ValidateMergedRegions(CellRangeAddress candidateRegion);
    private void CheckForIntersectingMergedRegions();
    public sealed virtual bool get_ForceFormulaRecalculation();
    public sealed virtual void set_ForceFormulaRecalculation(bool value);
    public sealed virtual bool get_VerticallyCenter();
    public sealed virtual void set_VerticallyCenter(bool value);
    public sealed virtual bool get_HorizontallyCenter();
    public sealed virtual void set_HorizontallyCenter(bool value);
    public sealed virtual void RemoveMergedRegion(int index);
    public sealed virtual void RemoveMergedRegions(IList`1<int> indices);
    public sealed virtual int get_NumMergedRegions();
    public sealed virtual IEnumerator GetRowEnumerator();
    public sealed virtual IEnumerator GetEnumerator();
    public InternalSheet get_Sheet();
    public void SetActiveCell(int row, int column);
    public sealed virtual void SetActiveCellRange(int firstRow, int lastRow, int firstColumn, int lastColumn);
    public sealed virtual void SetActiveCellRange(List`1<CellRangeAddress8Bit> cellranges, int activeRange, int activeRow, int activeColumn);
    public bool get_AlternativeExpression();
    public void set_AlternativeExpression(bool value);
    public bool get_AlternativeFormula();
    public void set_AlternativeFormula(bool value);
    public sealed virtual bool get_Autobreaks();
    public sealed virtual void set_Autobreaks(bool value);
    public bool get_Dialog();
    public void set_Dialog(bool value);
    public sealed virtual bool get_DisplayGuts();
    public sealed virtual void set_DisplayGuts(bool value);
    public sealed virtual bool get_FitToPage();
    public sealed virtual void set_FitToPage(bool value);
    public sealed virtual bool get_RowSumsBelow();
    public sealed virtual void set_RowSumsBelow(bool value);
    public sealed virtual bool get_RowSumsRight();
    public sealed virtual void set_RowSumsRight(bool value);
    public sealed virtual bool get_IsPrintGridlines();
    public sealed virtual void set_IsPrintGridlines(bool value);
    public sealed virtual bool get_IsPrintRowAndColumnHeadings();
    public sealed virtual void set_IsPrintRowAndColumnHeadings(bool value);
    public sealed virtual IPrintSetup get_PrintSetup();
    public sealed virtual IHeader get_Header();
    public sealed virtual IFooter get_Footer();
    public sealed virtual bool get_IsRightToLeft();
    public sealed virtual void set_IsRightToLeft(bool value);
    public sealed virtual bool get_IsSelected();
    public sealed virtual void set_IsSelected(bool value);
    public sealed virtual bool get_IsActive();
    public sealed virtual void set_IsActive(bool value);
    public sealed virtual void SetActive(bool sel);
    private WorksheetProtectionBlock get_ProtectionBlock();
    public sealed virtual bool get_Protect();
    public short get_Password();
    public bool get_ObjectProtect();
    public sealed virtual bool get_ScenarioProtect();
    public sealed virtual void ProtectSheet(string password);
    [ObsoleteAttribute("deprecated 2015-11-23 (circa POI 3.14beta1). Use {@link #setZoom(int)} instead.")]
public sealed virtual void SetZoom(int numerator, int denominator);
    public sealed virtual void SetZoom(int scale);
    public void SetEnclosedBorderOfRegion(CellRangeAddress region, BorderStyle borderType, short color);
    public void SetBorderRightOfRegion(CellRangeAddress region, BorderStyle borderType, short color);
    public void SetBorderLeftOfRegion(CellRangeAddress region, BorderStyle borderType, short color);
    public void SetBorderTopOfRegion(CellRangeAddress region, BorderStyle borderType, short color);
    public void SetBorderBottomOfRegion(CellRangeAddress region, BorderStyle borderType, short color);
    public sealed virtual short get_TopRow();
    public sealed virtual void set_TopRow(short value);
    public sealed virtual short get_LeftCol();
    public sealed virtual void set_LeftCol(short value);
    public sealed virtual void ShowInPane(int toprow, int leftcol);
    public void ShowInPane(short toprow, short leftcol);
    [ObsoleteAttribute("deprecated POI 3.15 beta 2. This will be made private in future releases.")]
protected void ShiftMerged(int startRow, int endRow, int n, bool IsRow);
    public sealed virtual void ShiftRows(int startRow, int endRow, int n);
    public sealed virtual void ShiftRows(int startRow, int endRow, int n, bool copyRowHeight, bool resetOriginalRowHeight);
    public void ShiftRows(int startRow, int endRow, int n, bool copyRowHeight, bool resetOriginalRowHeight, bool moveComments);
    private void updateFormulasForShift(FormulaShifter formulaShifter);
    private void recomputeFirstAndLastRowsForRowShift(int startRow, int endRow, int n);
    private void deleteOverwrittenHyperlinksForRowShift(int startRow, int endRow, int n);
    private void moveCommentsForRowShift(int startRow, int endRow, int n);
    private static int clip(int row);
    public void InsertChartRecords(List`1<RecordBase> records);
    private void NotifyRowShifting(HSSFRow row);
    public sealed virtual void CreateFreezePane(int colSplit, int rowSplit, int leftmostColumn, int topRow);
    public sealed virtual void CreateFreezePane(int colSplit, int rowSplit);
    public sealed virtual void CreateSplitPane(int xSplitPos, int ySplitPos, int leftmostColumn, int topRow, PanePosition activePane);
    public sealed virtual PaneInformation get_PaneInformation();
    public sealed virtual bool get_DisplayGridlines();
    public sealed virtual void set_DisplayGridlines(bool value);
    public sealed virtual bool get_DisplayFormulas();
    public sealed virtual void set_DisplayFormulas(bool value);
    public sealed virtual bool get_DisplayRowColHeadings();
    public sealed virtual void set_DisplayRowColHeadings(bool value);
    public sealed virtual double GetMargin(MarginType margin);
    public sealed virtual void SetMargin(MarginType margin, double size);
    public sealed virtual void SetRowBreak(int row);
    public sealed virtual bool IsRowBroken(int row);
    public sealed virtual void RemoveRowBreak(int row);
    public sealed virtual Int32[] get_RowBreaks();
    public sealed virtual Int32[] get_ColumnBreaks();
    public sealed virtual void SetColumnBreak(int column);
    public sealed virtual bool IsColumnBroken(int column);
    public sealed virtual void RemoveColumnBreak(int column);
    protected void ValidateRow(int row);
    protected void ValidateColumn(int column);
    public void DumpDrawingRecords(bool fat);
    public EscherAggregate get_DrawingEscherAggregate();
    public sealed virtual IDrawing get_DrawingPatriarch();
    public sealed virtual IDrawing CreateDrawingPatriarch();
    private HSSFPatriarch GetPatriarch(bool createIfMissing);
    public sealed virtual short get_TabColorIndex();
    public sealed virtual void set_TabColorIndex(short value);
    public bool get_IsAutoTabColor();
    public void set_IsAutoTabColor(bool value);
    public sealed virtual void SetColumnGroupCollapsed(int columnNumber, bool collapsed);
    public sealed virtual void GroupColumn(int fromColumn, int toColumn);
    public sealed virtual void UngroupColumn(int fromColumn, int toColumn);
    public sealed virtual void GroupRow(int fromRow, int toRow);
    public sealed virtual ICellRange`1<ICell> RemoveArrayFormula(ICell cell);
    private ICellRange`1<ICell> GetCellRange(CellRangeAddress range);
    public sealed virtual ICellRange`1<ICell> SetArrayFormula(string formula, CellRangeAddress range);
    public sealed virtual void UngroupRow(int fromRow, int toRow);
    public sealed virtual void SetRowGroupCollapsed(int row, bool collapse);
    public sealed virtual void SetDefaultColumnStyle(int column, ICellStyle style);
    public sealed virtual void AutoSizeColumn(int column);
    public sealed virtual void AutoSizeColumn(int column, bool useMergedCells);
    public sealed virtual void AutoSizeRow(int row);
    public sealed virtual void AutoSizeRow(int row, bool useMergedCells);
    public sealed virtual bool IsMergedRegion(CellRangeAddress mergedRegion);
    public sealed virtual CellRangeAddress GetMergedRegion(int index);
    public sealed virtual List`1<CellRangeAddress> get_MergedRegions();
    public Font HSSFFont2Font(HSSFFont font1);
    [ObsoleteAttribute("deprecated as of 2015-11-23 (circa POI 3.14beta1). Use {@link #getCellComment(CellAddress)} instead.")]
public sealed virtual IComment GetCellComment(int row, int column);
    public sealed virtual IComment GetCellComment(CellAddress ref1);
    public sealed virtual IHyperlink GetHyperlink(int row, int column);
    public sealed virtual IHyperlink GetHyperlink(CellAddress addr);
    public sealed virtual List`1<IHyperlink> GetHyperlinkList();
    protected void RemoveHyperlink(HSSFHyperlink link);
    protected void RemoveHyperlink(HyperlinkRecord link);
    public sealed virtual ISheetConditionalFormatting get_SheetConditionalFormatting();
    public IList get_DVRecords();
    public sealed virtual IWorkbook get_Workbook();
    public sealed virtual string get_SheetName();
    public sealed virtual IDataValidationHelper GetDataValidationHelper();
    public sealed virtual IAutoFilter SetAutoFilter(CellRangeAddress range);
    protected internal HSSFComment FindCellComment(int row, int column);
    private HSSFComment LookForComment(HSSFShapeContainer container, int row, int column);
    public sealed virtual Dictionary`2<CellAddress, IComment> GetCellComments();
    private void FindCellCommentLocations(HSSFShapeContainer container, Dictionary`2<CellAddress, IComment> locations);
    public sealed virtual CellRangeAddress get_RepeatingRows();
    public sealed virtual void set_RepeatingRows(CellRangeAddress value);
    public sealed virtual CellRangeAddress get_RepeatingColumns();
    public sealed virtual void set_RepeatingColumns(CellRangeAddress value);
    private void SetRepeatingRowsAndColumns(CellRangeAddress rowDef, CellRangeAddress colDef);
    private CellRangeAddress GetRepeatingRowsOrColums(bool rows);
    private NameRecord GetBuiltinNameRecord(byte builtinCode);
    public sealed virtual int GetColumnOutlineLevel(int columnIndex);
    public ISheet CopySheet();
    public ISheet CopySheet(bool CopyStyle);
    public sealed virtual ISheet CopySheet(string Name);
    public sealed virtual ISheet CopySheet(string Name, bool copyStyle);
    public sealed virtual void CopyTo(IWorkbook dest, string name, bool copyStyle, bool keepFormulas);
    private IEnumerable`1<int> FindUsedPictures(IEnumerable`1<EscherRecord> escherRecords);
    private void GetSheetImageIds(EscherRecord parent, List`1<int> usedIds);
    private void ApplyEscherRemap(EscherRecord parent, Dictionary`2<int, int> mappings);
    private static Dictionary`2<short, short> MergePalettes(HSSFWorkbook source, HSSFWorkbook dest);
    private static void CopyRow(HSSFSheet srcSheet, HSSFSheet destSheet, HSSFRow srcRow, HSSFRow destRow, IDictionary`2<int, HSSFCellStyle> styleMap, Dictionary`2<short, short> paletteMap, bool keepFormulas, bool keepMergedRegions);
    public static CellRangeAddress GetMergedRegion(HSSFSheet sheet, int rowNum, short cellNum);
    private static bool AreAllTrue(Boolean[] values);
    private static bool IsNewMergedRegion(CellRangeAddress newMergedRegion, List`1<CellRangeAddress> mergedRegions);
    public sealed virtual bool IsDate1904();
    public sealed virtual CellAddress get_ActiveCell();
    public sealed virtual void set_ActiveCell(CellAddress value);
}
public class NPOI.HSSF.UserModel.HSSFSheetConditionalFormatting : object {
    private HSSFSheet _sheet;
    private ConditionalFormattingTable _conditionalFormattingTable;
    public int NumConditionalFormattings { get; }
    public HSSFSheetConditionalFormatting(HSSFSheet sheet);
    public sealed virtual IConditionalFormattingRule CreateConditionalFormattingRule(ComparisonOperator comparisonOperation, string formula1, string formula2);
    public sealed virtual IConditionalFormattingRule CreateConditionalFormattingRule(ComparisonOperator comparisonOperation, string formula1);
    public sealed virtual IConditionalFormattingRule CreateConditionalFormattingRule(string formula);
    public sealed virtual IConditionalFormattingRule CreateConditionalFormattingRule(IconSet iconSet);
    public HSSFConditionalFormattingRule CreateConditionalFormattingRule(HSSFExtendedColor color);
    public sealed virtual IConditionalFormattingRule CreateConditionalFormattingRule(ExtendedColor color);
    public sealed virtual IConditionalFormattingRule CreateConditionalFormattingColorScaleRule();
    public int AddConditionalFormatting(HSSFConditionalFormatting cf);
    public sealed virtual int AddConditionalFormatting(IConditionalFormatting cf);
    public sealed virtual int AddConditionalFormatting(CellRangeAddress[] regions, IConditionalFormattingRule[] cfRules);
    public int AddConditionalFormatting(CellRangeAddress[] regions, HSSFConditionalFormattingRule rule1);
    public sealed virtual int AddConditionalFormatting(CellRangeAddress[] regions, IConditionalFormattingRule rule1);
    public sealed virtual int AddConditionalFormatting(CellRangeAddress[] regions, IConditionalFormattingRule rule1, IConditionalFormattingRule rule2);
    public sealed virtual IConditionalFormatting GetConditionalFormattingAt(int index);
    public sealed virtual int get_NumConditionalFormattings();
    public sealed virtual void RemoveConditionalFormatting(int index);
}
public class NPOI.HSSF.UserModel.HSSFSimpleShape : HSSFShape {
    public static short OBJECT_TYPE_LINE;
    public static short OBJECT_TYPE_RECTANGLE;
    public static short OBJECT_TYPE_OVAL;
    public static short OBJECT_TYPE_ARC;
    public static short OBJECT_TYPE_PICTURE;
    public static short OBJECT_TYPE_COMBO_BOX;
    public static short OBJECT_TYPE_COMMENT;
    public static short OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING;
    public static int WRAP_SQUARE;
    public static int WRAP_BY_POINTS;
    public static int WRAP_NONE;
    private TextObjectRecord _textObjectRecord;
    [CompilerGeneratedAttribute]
private bool <FlipVertical>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlipHorizontal>k__BackingField;
    public int ShapeType { get; public set; }
    public int WrapText { get; public set; }
    public IRichTextString String { get; public set; }
    public bool FlipVertical { get; public set; }
    public bool FlipHorizontal { get; public set; }
    public HSSFSimpleShape(EscherContainerRecord spContainer, ObjRecord objRecord, TextObjectRecord textObjectRecord);
    public HSSFSimpleShape(EscherContainerRecord spContainer, ObjRecord objRecord);
    public HSSFSimpleShape(HSSFShape parent, HSSFAnchor anchor);
    public virtual int get_ShapeType();
    public virtual void set_ShapeType(int value);
    public int get_WrapText();
    public void set_WrapText(int value);
    protected internal TextObjectRecord GetTextObjectRecord();
    protected virtual TextObjectRecord CreateTextObjRecord();
    public virtual IRichTextString get_String();
    public virtual void set_String(IRichTextString value);
    internal virtual HSSFShape CloneShape();
    internal virtual void AfterInsert(HSSFPatriarch patriarch);
    internal virtual void AfterRemove(HSSFPatriarch patriarch);
    protected virtual EscherContainerRecord CreateSpContainer();
    protected virtual ObjRecord CreateObjRecord();
    private TextObjectRecord GetOrCreateTextObjRecord();
    [CompilerGeneratedAttribute]
public bool get_FlipVertical();
    [CompilerGeneratedAttribute]
public void set_FlipVertical(bool value);
    [CompilerGeneratedAttribute]
public bool get_FlipHorizontal();
    [CompilerGeneratedAttribute]
public void set_FlipHorizontal(bool value);
}
public class NPOI.HSSF.UserModel.HSSFTextbox : HSSFSimpleShape {
    public static short OBJECT_TYPE_TEXT;
    public int MarginLeft { get; public set; }
    public int MarginRight { get; public set; }
    public int MarginTop { get; public set; }
    public int MarginBottom { get; public set; }
    public HorizontalTextAlignment HorizontalAlignment { get; public set; }
    public VerticalTextAlignment VerticalAlignment { get; public set; }
    public int ShapeType { get; public set; }
    public HSSFTextbox(EscherContainerRecord spContainer, ObjRecord objRecord, TextObjectRecord textObjectRecord);
    public HSSFTextbox(HSSFShape parent, HSSFAnchor anchor);
    protected virtual ObjRecord CreateObjRecord();
    protected virtual EscherContainerRecord CreateSpContainer();
    internal virtual void AfterInsert(HSSFPatriarch patriarch);
    internal virtual HSSFShape CloneShape();
    internal virtual void AfterRemove(HSSFPatriarch patriarch);
    public int get_MarginLeft();
    public void set_MarginLeft(int value);
    public int get_MarginRight();
    public void set_MarginRight(int value);
    public int get_MarginTop();
    public void set_MarginTop(int value);
    public int get_MarginBottom();
    public void set_MarginBottom(int value);
    public HorizontalTextAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(HorizontalTextAlignment value);
    public VerticalTextAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(VerticalTextAlignment value);
    public virtual int get_ShapeType();
    public virtual void set_ShapeType(int value);
}
[DefaultMemberAttribute("Item")]
public class NPOI.HSSF.UserModel.HSSFWorkbook : POIDocument {
    private static int MAX_STYLES;
    public static int INITIAL_CAPACITY;
    private InternalWorkbook workbook;
    protected List`1<HSSFSheet> _sheets;
    private List`1<HSSFName> names;
    private bool preserveNodes;
    private HSSFDataFormat formatter;
    private Dictionary`2<short, HSSFFont> fonts;
    private MissingCellPolicy missingCellPolicy;
    public static byte ENCODING_COMPRESSED_UNICODE;
    public static byte ENCODING_UTF_16;
    private UDFFinder _udfFinder;
    public MissingCellPolicy MissingCellPolicy { get; public set; }
    public int ActiveSheetIndex { get; }
    public int FirstVisibleTab { get; public set; }
    public int NumberOfSheets { get; }
    public bool BackupFlag { get; public set; }
    public short NumberOfFonts { get; }
    public bool IsHidden { get; public set; }
    public int NumCellStyles { get; }
    public InternalWorkbook Workbook { get; }
    public int NumberOfNames { get; }
    public bool IsWriteProtected { get; }
    public Byte[] NewUID { get; }
    public bool ForceFormulaRecalculation { get; public set; }
    public InternalWorkbook InternalWorkbook { get; }
    public SpreadsheetVersion SpreadsheetVersion { get; }
    [ObsoleteAttribute("use {@link POIDocument#getDirectory()} instead")]
public DirectoryNode RootDirectory { get; }
    public ISheet Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public HSSFWorkbook(InternalWorkbook book);
    public HSSFWorkbook(POIFSFileSystem fs);
    public HSSFWorkbook(NPOIFSFileSystem fs);
    public HSSFWorkbook(POIFSFileSystem fs, bool preserveNodes);
    public HSSFWorkbook(DirectoryNode directory, POIFSFileSystem fs, bool preserveNodes);
    public HSSFWorkbook(DirectoryNode directory, bool preserveNodes);
    public HSSFWorkbook(Stream s);
    public HSSFWorkbook(Stream s, bool preserveNodes);
    public sealed virtual ICreationHelper GetCreationHelper();
    public static HSSFWorkbook Create(InternalWorkbook book);
    private static string GetWorkbookDirEntryName(DirectoryNode directory);
    private void SetPropertiesFromWorkbook(InternalWorkbook book);
    private void ConvertLabelRecords(IList records, int offset);
    public sealed virtual MissingCellPolicy get_MissingCellPolicy();
    public sealed virtual void set_MissingCellPolicy(MissingCellPolicy value);
    public sealed virtual void SetSheetOrder(string sheetname, int pos);
    private void UpdateNamedRangesAfterSheetReorder(int oldIndex, int newIndex);
    private void UpdateActiveSheetAfterSheetReorder(int oldIndex, int newIndex);
    private void ValidateSheetIndex(int index);
    public void InsertChartRecord();
    public sealed virtual void SetSelectedTab(int index);
    public void SetSelectedTabs(Int32[] indexes);
    public void SetSelectedTabs(IList`1<int> indexes);
    public IList`1<int> GetSelectedTabs();
    public sealed virtual int get_ActiveSheetIndex();
    public sealed virtual void SetActiveSheet(int index);
    public sealed virtual int get_FirstVisibleTab();
    public sealed virtual void set_FirstVisibleTab(int value);
    public sealed virtual void SetSheetName(int sheetIx, string name);
    public sealed virtual string GetSheetName(int sheetIx);
    public sealed virtual bool IsSheetHidden(int sheetIx);
    public sealed virtual bool IsSheetVeryHidden(int sheetIx);
    public sealed virtual void SetSheetHidden(int sheetIx, SheetState hidden);
    public sealed virtual void SetSheetHidden(int sheetIx, int hidden);
    public void SetSheetHidden(int sheetIx, bool hidden);
    public sealed virtual int GetSheetIndex(string name);
    public sealed virtual int GetSheetIndex(ISheet sheet);
    public sealed virtual ISheet CreateSheet();
    public sealed virtual ISheet CloneSheet(int sheetIndex);
    private string GetUniqueSheetName(string srcName);
    public sealed virtual ISheet CreateSheet(string sheetname);
    public sealed virtual int get_NumberOfSheets();
    private List`1<HSSFSheet> GetSheets();
    public sealed virtual ISheet GetSheetAt(int index);
    public sealed virtual ISheet GetSheet(string name);
    public sealed virtual void RemoveSheetAt(int index);
    public bool get_BackupFlag();
    public void set_BackupFlag(bool value);
    internal int FindExistingBuiltinNameRecordIdx(int sheetIndex, byte builtinCode);
    internal HSSFName CreateBuiltInName(byte builtinCode, int sheetIndex);
    internal HSSFName GetBuiltInName(byte builtinCode, int sheetIndex);
    private bool IsRowColHeaderRecord(NameRecord r);
    public sealed virtual IFont CreateFont();
    [ObsoleteAttribute("deprecated 3.15 beta 2. Use {@link #findFont(boolean, short, short, String, boolean, boolean, short, byte)} instead.")]
public sealed virtual IFont FindFont(short boldWeight, short color, short fontHeight, string name, bool italic, bool strikeout, FontSuperScript typeOffset, FontUnderlineType underline);
    public sealed virtual IFont FindFont(bool bold, short color, short fontHeight, string name, bool italic, bool strikeout, FontSuperScript typeOffset, FontUnderlineType underline);
    public sealed virtual short get_NumberOfFonts();
    public sealed virtual bool get_IsHidden();
    public sealed virtual void set_IsHidden(bool value);
    public sealed virtual IFont GetFontAt(short idx);
    public void ResetFontCache();
    public sealed virtual ICellStyle CreateCellStyle();
    public sealed virtual int get_NumCellStyles();
    public sealed virtual ICellStyle GetCellStyleAt(int idx);
    public virtual void Close();
    public virtual void Write();
    public virtual void Write(FileInfo newFile);
    public virtual void Write(Stream stream);
    public sealed virtual void Write(Stream stream, bool leaveOpen);
    private void Write(NPOIFSFileSystem fs);
    public Byte[] GetBytes();
    public sealed virtual void AddToolPack(UDFFinder toopack);
    internal UDFFinder GetUDFFinder();
    public InternalWorkbook get_Workbook();
    public sealed virtual int get_NumberOfNames();
    public sealed virtual IName GetName(string name);
    public sealed virtual IList`1<IName> GetNames(string name);
    public sealed virtual IName GetNameAt(int nameIndex);
    public sealed virtual IList`1<IName> GetAllNames();
    public string GetNameName(int index);
    public NameRecord GetNameRecord(int nameIndex);
    public sealed virtual void SetPrintArea(int sheetIndex, string reference);
    public sealed virtual void SetPrintArea(int sheetIndex, int startColumn, int endColumn, int startRow, int endRow);
    public sealed virtual string GetPrintArea(int sheetIndex);
    public sealed virtual void RemovePrintArea(int sheetIndex);
    public sealed virtual IName CreateName();
    public sealed virtual int GetNameIndex(string name);
    public int GetNameIndex(HSSFName name);
    public sealed virtual void RemoveName(int index);
    public sealed virtual IDataFormat CreateDataFormat();
    public sealed virtual void RemoveName(string name);
    public sealed virtual void RemoveName(IName name);
    public HSSFPalette GetCustomPalette();
    public void DumpDrawingGroupRecords(bool fat);
    internal void InitDrawings();
    public sealed virtual int AddPicture(Byte[] pictureData, PictureType format);
    public sealed virtual IList GetAllPictures();
    private void SearchForPictures(IList escherRecords, List`1<HSSFPictureData> pictures);
    protected static Dictionary`2<string, ClassID> GetOleMap();
    public int AddOlePackage(POIFSFileSystem poiData, string label, string fileName, string command);
    public int AddOlePackage(Byte[] oleData, string label, string fileName, string command);
    public sealed virtual int LinkExternalWorkbook(string name, IWorkbook workbook);
    public bool get_IsWriteProtected();
    public void WriteProtectWorkbook(string password, string username);
    public void UnwriteProtectWorkbook();
    public IList`1<HSSFObjectData> GetAllEmbeddedObjects();
    private void GetAllEmbeddedObjects(HSSFSheet sheet, List`1<HSSFObjectData> objects);
    private void GetAllEmbeddedObjects(HSSFShapeContainer parent, List`1<HSSFObjectData> objects);
    public Byte[] get_NewUID();
    public sealed virtual IEnumerator`1<ISheet> GetEnumerator();
    public void set_ForceFormulaRecalculation(bool value);
    public bool get_ForceFormulaRecalculation();
    public InternalWorkbook get_InternalWorkbook();
    public sealed virtual SpreadsheetVersion get_SpreadsheetVersion();
    public bool ChangeExternalReference(string oldUrl, string newUrl);
    public DirectoryNode get_RootDirectory();
    public int IndexOf(ISheet item);
    public void Insert(int index, ISheet item);
    public void RemoveAt(int index);
    public ISheet get_Item(int index);
    public void set_Item(int index, ISheet value);
    public void Add(ISheet item);
    public void Clear();
    public bool Contains(ISheet item);
    public void CopyTo(ISheet[] array, int arrayIndex);
    public int get_Count();
    public bool get_IsReadOnly();
    public bool Remove(ISheet item);
    public sealed virtual bool IsDate1904();
    public sealed virtual void Dispose();
}
public interface NPOI.HSSF.UserModel.IHSSFShapeTypes {
}
internal class NPOI.HSSF.UserModel.OperationEvaluatorFactory : object {
    private static Type[] OPERATION_CONSTRUCTOR_CLASS_ARRAY;
    private static Hashtable _constructorsByPtgClass;
    private static OperationEvaluatorFactory();
    private static Hashtable InitialiseConstructorsMap();
    private static void Add(Hashtable m, Type ptgClass, Type evalClass);
    public static OperationEval Create(OperationPtg ptg);
}
internal class NPOI.HSSF.UserModel.StaticFontMetrics : object {
    private static string FONT_METRICS_PROPERTIES_FILE_NAME;
    private static Properties fontMetricsProps;
    private static Hashtable fontDetailsMap;
    private static StaticFontMetrics();
}
public class NPOI.HSSF.Util.GUID : object {
    private static int TEXT_FORMAT_LENGTH;
    public static int ENCODED_SIZE;
    private int _d1;
    private int _d2;
    private int _d3;
    private long _d4;
    public int D1 { get; }
    public int D2 { get; }
    public int D3 { get; }
    public long D4 { get; }
    public GUID(ILittleEndianInput in1);
    public GUID(int d1, int d2, int d3, long d4);
    public void Serialize(ILittleEndianOutput out1);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int get_D1();
    public int get_D2();
    public int get_D3();
    public long get_D4();
    public string FormatAsString();
    public virtual string ToString();
    public static GUID Parse(string rep);
    private static long ParseLELong(Char[] cc, int startIndex);
    private static int ParseShort(Char[] cc, int startIndex);
    private static int ParseHexChar(char c);
}
public class NPOI.HSSF.Util.HSSFCellRangeAddress : object {
    private static POILogger logger;
    private short field_Addr_number;
    private ArrayList field_regions_list;
    public short AddRStructureNumber { get; }
    public int Size { get; }
    public HSSFCellRangeAddress(RecordInputStream in1);
    private static HSSFCellRangeAddress();
    public void FillFields(RecordInputStream in1);
    public short get_AddRStructureNumber();
    public int AddAddRStructure(short first_row, short first_col, short last_row, short last_col);
    public void RemoveAddRStructureAt(int index);
    public AddrStructure GetAddRStructureAt(int index);
    public int Serialize(int offSet, Byte[] data);
    public int get_Size();
}
[ObsoleteAttribute("deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil} instead.")]
public class NPOI.HSSF.Util.HSSFCellUtil : object {
    [ObsoleteAttribute("@deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil#getRow} instead.")]
public static IRow GetRow(int rowIndex, HSSFSheet sheet);
    [ObsoleteAttribute("@deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil#getCell} instead.")]
public static ICell GetCell(IRow row, int columnIndex);
    [ObsoleteAttribute("@deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil#createCell} instead.")]
public static ICell CreateCell(IRow row, int column, string value, HSSFCellStyle style);
    [ObsoleteAttribute("@deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil#createCell} instead.")]
public static ICell CreateCell(IRow row, int column, string value);
    [ObsoleteAttribute("@deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil#setAlignment} instead.")]
public static void SetAlignment(ICell cell, HSSFWorkbook workbook, short align);
    [ObsoleteAttribute("@deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil#setFont} instead.")]
public static void SetFont(ICell cell, HSSFWorkbook workbook, HSSFFont font);
    [ObsoleteAttribute("@deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil#setCellStyleProperty} instead.")]
public static void SetCellStyleProperty(ICell cell, HSSFWorkbook workbook, string propertyName, object propertyValue);
    [ObsoleteAttribute("@deprecated 3.15 beta2. Removed in 3.17. Use {@link org.apache.poi.ss.util.CellUtil#translateUnicodeValues} instead.")]
public static ICell TranslateUnicodeValues(ICell cell);
    private static void RemapCellStyle(HSSFCellStyle stylish, Dictionary`2<short, short> paletteMap);
    public static void CopyCell(HSSFCell oldCell, HSSFCell newCell, IDictionary`2<int, HSSFCellStyle> styleMap, Dictionary`2<short, short> paletteMap, bool keepFormulas);
}
public class NPOI.HSSF.Util.HSSFColor : object {
    private static Dictionary`2<int, HSSFColor> indexHash;
    public static short COLOR_NORMAL;
    public short Indexed { get; }
    public short Indexed2 { get; }
    public Byte[] RGB { get; }
    public static Dictionary`2<int, HSSFColor> GetIndexHash();
    public static Dictionary`2<int, HSSFColor> GetMutableIndexHash();
    private static Dictionary`2<int, HSSFColor> CreateColorsByIndexMap();
    internal static HSSFColor[] GetAllColors();
    public static Dictionary`2<string, HSSFColor> GetTripletHash();
    private static Dictionary`2<string, HSSFColor> CreateColorsByHexStringMap();
    public virtual short get_Indexed();
    public virtual short get_Indexed2();
    public sealed virtual Byte[] get_RGB();
    public virtual Byte[] GetTriplet();
    public virtual string GetHexString();
    public static HSSFColor ToHSSFColor(IColor color);
}
public class NPOI.HSSF.Util.HSSFRegionUtil : object {
    public static void SetBorderLeft(BorderStyle border, CellRangeAddress region, HSSFSheet sheet, HSSFWorkbook workbook);
    public static void SetLeftBorderColor(int color, CellRangeAddress region, HSSFSheet sheet, HSSFWorkbook workbook);
    public static void SetBorderRight(BorderStyle border, CellRangeAddress region, HSSFSheet sheet, HSSFWorkbook workbook);
    public static void SetRightBorderColor(int color, CellRangeAddress region, HSSFSheet sheet, HSSFWorkbook workbook);
    public static void SetBorderBottom(BorderStyle border, CellRangeAddress region, HSSFSheet sheet, HSSFWorkbook workbook);
    public static void SetBottomBorderColor(int color, CellRangeAddress region, HSSFSheet sheet, HSSFWorkbook workbook);
    public static void SetBorderTop(BorderStyle border, CellRangeAddress region, HSSFSheet sheet, HSSFWorkbook workbook);
    public static void SetTopBorderColor(int color, CellRangeAddress region, HSSFSheet sheet, HSSFWorkbook workbook);
}
public class NPOI.HSSF.Util.LazilyConcatenatedByteArray : object {
    private List`1<Byte[]> arrays;
    public void Clear();
    public void Concatenate(Byte[] array);
    public Byte[] ToArray();
}
public class NPOI.HSSF.Util.RangeAddress : object {
    private static int WRONG_POS;
    private static int MAX_HEIGHT;
    private string m_sheetName;
    private string m_cellFrom;
    private string m_cellTo;
    public string Address { get; }
    public string SheetName { get; }
    public string Range { get; }
    public string FromCell { get; }
    public string ToCell { get; }
    public int Width { get; }
    public int Height { get; }
    public bool HasSheetName { get; }
    public bool HasRange { get; }
    public bool HasCell { get; }
    public RangeAddress(string _url);
    public RangeAddress(int _startCol, int _startRow, int _endCol, int _endRow);
    public string get_Address();
    public string get_SheetName();
    public string get_Range();
    public bool IsCellOk(string _cell);
    public bool IsSheetNameOk();
    private static bool intern_isSheetNameOk(string _sheetName, bool _canBeWaitSpace);
    public static bool IsSheetNameOk(string _sheetName);
    public string get_FromCell();
    public string get_ToCell();
    public int get_Width();
    public int get_Height();
    public void SetSize(int _width, int _height);
    public bool get_HasSheetName();
    public bool get_HasRange();
    public bool get_HasCell();
    private void init(string _url);
    private String[] ParseURL(string _url);
    public int GetYPosition(string _subrange);
    private static bool IsLetter(string _str);
    public int GetXPosition(string _subrange);
    public string GetDigitPart(string _value);
    public string GetCharPart(string _value);
    private string Filter(string _range);
    private int GetFirstDigitPosition(string _value);
    public int Get26Sys(string _s);
    public string NumTo26Sys(int _num);
    public string ReplaceString(string _source, string _oldPattern, string _newPattern);
    public string RemoveString(string _source, string _match);
}
public class NPOI.HSSF.Util.RKUtil : object {
    public static double DecodeNumber(int number);
}
internal class NPOI.HSSF.XmlTkBlob : ValueType {
    public XmlTkHeader xtHeader;
    public UInt32 cbBlob;
    public Byte[] rgbBlob;
}
internal class NPOI.HSSF.XmlTkBool : ValueType {
    public XmlTkHeader xtHeader;
    public byte dValue;
    public byte unused;
}
internal class NPOI.HSSF.XmlTkDouble : ValueType {
    public XmlTkHeader xtHeader;
    public int unused;
    public double dValue;
}
internal class NPOI.HSSF.XmlTkDWord : ValueType {
    public XmlTkHeader xtHeader;
    public int dValue;
}
internal class NPOI.HSSF.XmlTkEnd : ValueType {
    public XmlTkHeader xtHeader;
}
internal class NPOI.HSSF.XmlTkHeader : ValueType {
    public sbyte drType;
    public byte unused;
    public ushort xmlTkTag;
}
internal class NPOI.HSSF.XmlTkString : ValueType {
    public XmlTkHeader xtHeader;
    public UInt32 cchValue;
    public Char[] rgbValue;
}
internal class NPOI.HSSF.XmlTkStyle : ValueType {
    public XmlTkDWord chartStyle;
}
internal class NPOI.HSSF.XmlTkTickMarkSkipFrt : ValueType {
    public XmlTkDWord nInterval;
}
internal class NPOI.HSSF.XmlTkToken : ValueType {
    public XmlTkHeader xtHeader;
    public ushort dValue;
}
public class NPOI.OldFileFormatException : UnsupportedFileFormatException {
    public OldFileFormatException(string s);
}
public abstract class NPOI.POIDocument : object {
    private static POILogger logger;
    protected SummaryInformation sInf;
    protected DocumentSummaryInformation dsInf;
    private DirectoryNode directory;
    protected bool initialized;
    public DocumentSummaryInformation DocumentSummaryInformation { get; public set; }
    public SummaryInformation SummaryInformation { get; public set; }
    public DirectoryNode Directory { get; }
    protected POIDocument(DirectoryNode dir);
    protected POIDocument(OPOIFSFileSystem fs);
    public POIDocument(NPOIFSFileSystem fs);
    protected POIDocument(POIFSFileSystem fs);
    private static POIDocument();
    protected internal void SetDirectoryNode(DirectoryNode directory);
    public void CreateInformationProperties();
    public DocumentSummaryInformation get_DocumentSummaryInformation();
    public void set_DocumentSummaryInformation(DocumentSummaryInformation value);
    public SummaryInformation get_SummaryInformation();
    public void set_SummaryInformation(SummaryInformation value);
    protected internal void ReadProperties();
    protected PropertySet GetPropertySet(string setName);
    protected PropertySet GetPropertySet(string setName, EncryptionInfo encryptionInfo);
    protected internal void WriteProperties();
    protected internal void WriteProperties(NPOIFSFileSystem outFS);
    protected internal void WriteProperties(NPOIFSFileSystem outFS, IList writtenEntries);
    protected void WritePropertySet(string name, PropertySet Set, NPOIFSFileSystem outFS);
    protected void ValidateInPlaceWritePossible();
    public abstract virtual void Write();
    public abstract virtual void Write(FileInfo newFile);
    public abstract virtual void Write(Stream stream);
    public virtual void Close();
    public DirectoryNode get_Directory();
    protected internal void ClearDirectory();
    protected bool InitDirectory();
    protected internal DirectoryNode ReplaceDirectory(DirectoryNode newDirectory);
}
public class NPOI.POIFS.Common.POIFSBigBlockSize : object {
    private int bigBlockSize;
    private short headerValue;
    internal POIFSBigBlockSize(int bigBlockSize, short headerValue);
    public int GetBigBlockSize();
    public short GetHeaderValue();
    public int GetPropertiesPerBlock();
    public int GetBATEntriesPerBlock();
    public int GetXBATEntriesPerBlock();
    public int GetNextXBATChainOffset();
}
public class NPOI.POIFS.Common.POIFSConstants : object {
    public static int SMALLER_BIG_BLOCK_SIZE;
    public static POIFSBigBlockSize SMALLER_BIG_BLOCK_SIZE_DETAILS;
    public static int LARGER_BIG_BLOCK_SIZE;
    public static POIFSBigBlockSize LARGER_BIG_BLOCK_SIZE_DETAILS;
    public static int BIG_BLOCK_SIZE;
    public static int MINI_BLOCK_SIZE;
    public static int SMALL_BLOCK_SIZE;
    public static int PROPERTY_SIZE;
    public static int BIG_BLOCK_MINIMUM_DOCUMENT_SIZE;
    public static int LARGEST_REGULAR_SECTOR_NUMBER;
    public static int FAT_SECTOR_BLOCK;
    public static int DIFAT_SECTOR_BLOCK;
    public static int END_OF_CHAIN;
    public static int UNUSED_BLOCK;
    public static Byte[] OOXML_FILE_HEADER;
    public static Byte[] RAW_XML_FILE_HEADER;
    private static POIFSConstants();
}
public class NPOI.POIFS.Crypt.AlgorithmParameterSpec : object {
}
public class NPOI.POIFS.Crypt.BinaryRC4.BinaryRC4Decryptor : Decryptor {
    private long _length;
    protected internal BinaryRC4Decryptor(BinaryRC4EncryptionInfoBuilder builder);
    public virtual bool VerifyPassword(string password);
    protected internal static Cipher InitCipherForBlock(Cipher cipher, int block, IEncryptionInfoBuilder builder, ISecretKey skey, int encryptMode);
    protected internal static ISecretKey GenerateSecretKey(string password, EncryptionVerifier ver);
    public virtual InputStream GetDataStream(DirectoryNode dir);
    public virtual long GetLength();
}
public class NPOI.POIFS.Crypt.BinaryRC4.BinaryRC4EncryptionHeader : EncryptionHeader {
    public sealed virtual void Write(LittleEndianByteArrayOutputStream littleendianbytearrayoutputstream);
}
public class NPOI.POIFS.Crypt.BinaryRC4.BinaryRC4EncryptionInfoBuilder : object {
    private EncryptionInfo info;
    private BinaryRC4EncryptionHeader header;
    private BinaryRC4EncryptionVerifier verifier;
    private BinaryRC4Decryptor decryptor;
    private BinaryRC4Encryptor encryptor;
    public sealed virtual void Initialize(EncryptionInfo info, ILittleEndianInput dis);
    public sealed virtual void Initialize(EncryptionInfo info, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public BinaryRC4EncryptionHeader GetHeader();
    public BinaryRC4EncryptionVerifier GetVerifier();
    public BinaryRC4Decryptor GetDecryptor();
    public BinaryRC4Encryptor GetEncryptor();
    public EncryptionInfo GetEncryptionInfo();
    private sealed virtual override EncryptionHeader NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetHeader();
    private sealed virtual override EncryptionVerifier NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetVerifier();
    private sealed virtual override Decryptor NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetDecryptor();
    private sealed virtual override Encryptor NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetEncryptor();
}
public class NPOI.POIFS.Crypt.BinaryRC4.BinaryRC4EncryptionVerifier : EncryptionVerifier {
    protected internal BinaryRC4EncryptionVerifier(ILittleEndianInput is1);
    protected internal void SetSalt(Byte[] salt);
    public sealed virtual void Write(LittleEndianByteArrayOutputStream bos);
}
public class NPOI.POIFS.Crypt.BinaryRC4.BinaryRC4Encryptor : Encryptor {
    private BinaryRC4EncryptionInfoBuilder builder;
    protected internal BinaryRC4Encryptor(BinaryRC4EncryptionInfoBuilder builder);
    public virtual void ConfirmPassword(string password);
    public virtual void ConfirmPassword(string password, Byte[] keySpec, Byte[] keySalt, Byte[] verifier, Byte[] verifierSalt, Byte[] integritySalt);
    public virtual OutputStream GetDataStream(DirectoryNode dir);
    protected int GetKeySizeInBytes();
    protected internal void CreateEncryptionInfoEntry(DirectoryNode dir);
}
public class NPOI.POIFS.Crypt.ChainingMode : object {
    public static ChainingMode ecb;
    public static ChainingMode cbc;
    public static ChainingMode cfb;
    [CompilerGeneratedAttribute]
private string <jceId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ecmaId>k__BackingField;
    public string jceId { get; public set; }
    public int ecmaId { get; public set; }
    public ChainingMode(string jceId, int ecmaId);
    private static ChainingMode();
    [CompilerGeneratedAttribute]
public string get_jceId();
    [CompilerGeneratedAttribute]
public void set_jceId(string value);
    [CompilerGeneratedAttribute]
public int get_ecmaId();
    [CompilerGeneratedAttribute]
public void set_ecmaId(int value);
}
public abstract class NPOI.POIFS.Crypt.ChunkedCipherInputStream : LittleEndianInputStream {
    private int _chunkSize;
    private int _chunkBits;
    private long _size;
    private Byte[] _chunk;
    private Byte[] _plain;
    private Cipher _cipher;
    private int _lastIndex;
    private long _pos;
    private bool _chunkIsValid;
    protected IEncryptionInfoBuilder builder;
    protected Decryptor decryptor;
    protected ChunkedCipherInputStream(InputStream stream, long size, int chunkSize, IEncryptionInfoBuilder builder, Decryptor decryptor);
    protected ChunkedCipherInputStream(InputStream stream, long size, int chunkSize, int initialPos, IEncryptionInfoBuilder builder, Decryptor decryptor);
    public Cipher InitCipherForBlock(int block);
    protected abstract virtual Cipher InitCipherForBlock(Cipher existing, int block);
    public virtual int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public int Read(Byte[] b, int off, int len, bool readPlain);
    public virtual long Skip(long n);
    public virtual int Available();
    private int RemainingBytes();
    public virtual bool MarkSupported();
    public virtual void Mark(int readlimit);
    public virtual void Reset();
    protected int GetChunkMask();
    private void NextChunk();
    protected int InvokeCipher(int totalBytes, bool doFinal);
    public void ReadPlain(Byte[] b, int off, int len);
    public void SetNextRecordSize(int recordSize);
    protected Byte[] GetChunk();
    protected Byte[] GetPlain();
    public long GetPos();
}
public abstract class NPOI.POIFS.Crypt.ChunkedCipherOutputStream : LittleEndianOutputStream {
    protected int chunkSize;
    protected int chunkMask;
    protected int chunkBits;
    private Byte[] _chunk;
    private FileInfo fileOut;
    private DirectoryNode dir;
    private long _pos;
    private Cipher _cipher;
    protected IEncryptionInfoBuilder builder;
    protected Encryptor encryptor;
    public ChunkedCipherOutputStream(DirectoryNode dir, int chunkSize, IEncryptionInfoBuilder builder, Encryptor encryptor);
    public Stream GetStream();
    protected abstract virtual Cipher InitCipherForBlock(Cipher existing, int block, bool lastChunk);
    protected abstract virtual void CalculateChecksum(FileInfo fileOut, int oleStreamSize);
    protected abstract virtual void CreateEncryptionInfoEntry(DirectoryNode dir, FileInfo tmpFile);
    public void Write(int b);
    public void Write(Byte[] b);
    public void Write(Byte[] b, int off, int len);
    protected void WriteChunk();
    public void Close();
}
public class NPOI.POIFS.Crypt.Cipher : object {
    public static int DECRYPT_MODE;
    public static int ENCRYPT_MODE;
    public static int WRAP_MODE;
    public static int UNWRAP_MODE;
    public static int PUBLIC_KEY;
    public static int PRIVATE_KEY;
    public static int SECRET_KEY;
    protected IBufferedCipher cipherImpl;
    public static Cipher GetInstance(string transformation);
    public static Cipher GetInstance(string transformation, string provider);
    public void Init(int cipherMode, IKey key, AlgorithmParameterSpec aps);
    public void Init(int cipherMode, IKey key);
    public void Init(int cipherMode, ICipherParameters cipherParameters);
    public static int GetMaxAllowedKeyLength(string jceId);
    public int Update(Byte[] input, int inputOffset, int inputLen, Byte[] output);
    public int Update(Byte[] input, int inputOffset, int inputLen, Byte[] output, int outputOffset);
    public Byte[] Update(Byte[] ibuffer, int inOff, int length);
    public Byte[] DoFinal(Byte[] block);
    public int DoFinal(Byte[] input, int inputOffset, int inputLen, Byte[] output);
    public Byte[] DoFinal();
}
public class NPOI.POIFS.Crypt.CipherAlgorithm : object {
    public static CipherAlgorithm rc4;
    public static CipherAlgorithm aes128;
    public static CipherAlgorithm aes192;
    public static CipherAlgorithm aes256;
    public static CipherAlgorithm rc2;
    public static CipherAlgorithm des;
    public static CipherAlgorithm des3;
    public static CipherAlgorithm des3_112;
    public static CipherAlgorithm rsa;
    public static CipherAlgorithm[] Values;
    public CipherProvider provider;
    public string jceId;
    public int ecmaId;
    public int defaultKeySize;
    public Int32[] allowedKeySize;
    public int blockSize;
    public int encryptedVerifierHashLength;
    public string xmlId;
    public bool needsBouncyCastle;
    private string name;
    public CipherAlgorithm(CipherProvider provider, string jceId, int ecmaId, int defaultKeySize, Int32[] allowedKeySize, int blockSize, int encryptedVerifierHashLength, string xmlId, bool needsBouncyCastle);
    private static CipherAlgorithm();
    public static CipherAlgorithm ValueOf(string alg);
    public virtual string ToString();
    public static CipherAlgorithm FromEcmaId(int ecmaId);
    public static CipherAlgorithm FromXmlId(string xmlId, int keySize);
}
public class NPOI.POIFS.Crypt.CipherProvider : object {
    public static CipherProvider rc4;
    public static CipherProvider aes;
    public static CipherProvider[] Values;
    [CompilerGeneratedAttribute]
private string <jceId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ecmaId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <cipherProviderName>k__BackingField;
    public string jceId { get; public set; }
    public int ecmaId { get; public set; }
    public string cipherProviderName { get; public set; }
    public CipherProvider(string jceId, int ecmaId, string cipherProviderName);
    private static CipherProvider();
    public static CipherProvider FromEcmaId(int ecmaId);
    [CompilerGeneratedAttribute]
public string get_jceId();
    [CompilerGeneratedAttribute]
public void set_jceId(string value);
    [CompilerGeneratedAttribute]
public int get_ecmaId();
    [CompilerGeneratedAttribute]
public void set_ecmaId(int value);
    [CompilerGeneratedAttribute]
public string get_cipherProviderName();
    [CompilerGeneratedAttribute]
public void set_cipherProviderName(string value);
}
public class NPOI.POIFS.Crypt.CryptoAPI.CryptoAPIDecryptor : Decryptor {
    private long _length;
    protected internal CryptoAPIDecryptor(CryptoAPIEncryptionInfoBuilder builder);
    public virtual bool VerifyPassword(string password);
    public Cipher InitCipherForBlock(Cipher cipher, int block);
    protected internal static Cipher InitCipherForBlock(Cipher cipher, int block, IEncryptionInfoBuilder builder, ISecretKey skey, int encryptMode);
    protected internal static ISecretKey GenerateSecretKey(string password, EncryptionVerifier ver);
    public virtual InputStream GetDataStream(DirectoryNode dir);
    public virtual long GetLength();
}
public class NPOI.POIFS.Crypt.CryptoAPI.CryptoAPIEncryptionHeader : StandardEncryptionHeader {
    public CryptoAPIEncryptionHeader(ILittleEndianInput is1);
    protected internal CryptoAPIEncryptionHeader(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public void SetKeySize(int keyBits);
}
public class NPOI.POIFS.Crypt.CryptoAPI.CryptoAPIEncryptionInfoBuilder : object {
    private EncryptionInfo info;
    private CryptoAPIEncryptionHeader header;
    private CryptoAPIEncryptionVerifier verifier;
    private CryptoAPIDecryptor decryptor;
    private CryptoAPIEncryptor encryptor;
    public sealed virtual void Initialize(EncryptionInfo info, ILittleEndianInput dis);
    public sealed virtual void Initialize(EncryptionInfo info, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public CryptoAPIEncryptionHeader GetHeader();
    public CryptoAPIEncryptionVerifier GetVerifier();
    public CryptoAPIDecryptor GetDecryptor();
    public CryptoAPIEncryptor GetEncryptor();
    public EncryptionInfo GetEncryptionInfo();
    private sealed virtual override EncryptionHeader NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetHeader();
    private sealed virtual override EncryptionVerifier NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetVerifier();
    private sealed virtual override Decryptor NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetDecryptor();
    private sealed virtual override Encryptor NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetEncryptor();
}
public class NPOI.POIFS.Crypt.CryptoAPI.CryptoAPIEncryptionVerifier : StandardEncryptionVerifier {
    protected internal CryptoAPIEncryptionVerifier(ILittleEndianInput is1, CryptoAPIEncryptionHeader header);
    protected internal CryptoAPIEncryptionVerifier(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    protected void SetSalt(Byte[] salt);
    protected void SetEncryptedVerifier(Byte[] encryptedVerifier);
    protected void SetEncryptedVerifierHash(Byte[] encryptedVerifierHash);
}
public class NPOI.POIFS.Crypt.CryptoAPI.CryptoAPIEncryptor : Encryptor {
    private CryptoAPIEncryptionInfoBuilder builder;
    protected internal CryptoAPIEncryptor(CryptoAPIEncryptionInfoBuilder builder);
    public virtual void ConfirmPassword(string password);
    public virtual void ConfirmPassword(string password, Byte[] keySpec, Byte[] keySalt, Byte[] verifier, Byte[] verifierSalt, Byte[] integritySalt);
    public Cipher InitCipherForBlock(Cipher cipher, int block);
    public virtual OutputStream GetDataStream(DirectoryNode dir);
    protected int GetKeySizeInBytes();
    protected void CreateEncryptionInfoEntry(DirectoryNode dir);
}
public class NPOI.POIFS.Crypt.CryptoFunctions : object {
    private static int DEFAULT_MAX_RECORD_LENGTH;
    public static int MAX_RECORD_LENGTH;
    private static Int32[] INITIAL_CODE_ARRAY;
    private static Byte[] PAD_ARRAY;
    private static Int32[][] ENCRYPTION_MATRIX;
    private static CryptoFunctions();
    public static Byte[] HashPassword(string password, HashAlgorithm hashAlgorithm, Byte[] salt, int spinCount);
    public static Byte[] HashPassword(string password, HashAlgorithm hashAlgorithm, Byte[] salt, int spinCount, bool iteratorFirst);
    public static Byte[] GenerateIv(HashAlgorithm hashAlgorithm, Byte[] salt, Byte[] blockKey, int blockSize);
    public static Byte[] GenerateKey(Byte[] passwordHash, HashAlgorithm hashAlgorithm, Byte[] blockKey, int keySize);
    public static Cipher GetCipher(ISecretKey key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, Byte[] vec, int cipherMode);
    public static Cipher GetCipher(IKey key, CipherAlgorithm cipherAlgorithm, ChainingMode chain, Byte[] vec, int cipherMode, string padding);
    private static Byte[] GetBlock36(Byte[] hash, int size);
    public static Byte[] GetBlock0(Byte[] hash, int size);
    private static Byte[] GetBlockX(Byte[] hash, int size, byte Fill);
    public static MessageDigest GetMessageDigest(HashAlgorithm hashAlgorithm);
    public static Mac GetMac(HashAlgorithm hashAlgorithm);
    [ObsoleteAttribute("not necessary for npoi")]
public static void registerBouncyCastle();
    public static int CreateXorVerifier1(string password);
    public static int CreateXorVerifier2(string password);
    public static string XorHashPassword(string password);
    public static string XorHashPasswordReversed(string password);
    public static int CreateXorKey1(string password);
    public static Byte[] CreateXorArray1(string password);
    private static Byte[] toAnsiPassword(string password);
    private static byte rotateLeft(byte bits, int Shift);
    private static short rotateLeftBase15Bit(short verifier);
}
public class NPOI.POIFS.Crypt.DataSpaceMapUtils : object {
    public static void AddDefaultDataSpace(DirectoryEntry dir);
    public static DocumentEntry CreateEncryptionEntry(DirectoryEntry dir, string path, EncryptionRecord out1);
    public static string ReadUnicodeLPP4(ILittleEndianInput is1);
    public static void WriteUnicodeLPP4(ILittleEndianOutput os, string string1);
    public static string ReadUtf8LPP4(ILittleEndianInput is1);
    public static void WriteUtf8LPP4(ILittleEndianOutput os, string str);
}
public abstract class NPOI.POIFS.Crypt.Decryptor : object {
    public static string DEFAULT_PASSWORD;
    public static string DEFAULT_POIFS_ENTRY;
    protected internal IEncryptionInfoBuilder builder;
    private ISecretKey secretKey;
    private Byte[] verifier;
    private Byte[] integrityHmacKey;
    private Byte[] integrityHmacValue;
    protected Decryptor(IEncryptionInfoBuilder builder);
    private static Decryptor();
    public abstract virtual InputStream GetDataStream(DirectoryNode dir);
    public abstract virtual bool VerifyPassword(string password);
    public abstract virtual long GetLength();
    public static Decryptor GetInstance(EncryptionInfo info);
    public InputStream GetDataStream(NPOIFSFileSystem fs);
    public InputStream GetDataStream(OPOIFSFileSystem fs);
    public InputStream GetDataStream(POIFSFileSystem fs);
    public Byte[] GetVerifier();
    public ISecretKey GetSecretKey();
    public Byte[] GetIntegrityHmacKey();
    public Byte[] GetIntegrityHmacValue();
    protected void SetSecretKey(ISecretKey secretKey);
    protected void SetVerifier(Byte[] verifier);
    protected void SetIntegrityHmacKey(Byte[] integrityHmacKey);
    protected void SetIntegrityHmacValue(Byte[] integrityHmacValue);
    protected int GetBlockSizeInBytes();
    protected int GetKeySizeInBytes();
}
public abstract class NPOI.POIFS.Crypt.EncryptionHeader : object {
    public static int ALGORITHM_RC4;
    public static int ALGORITHM_AES_128;
    public static int ALGORITHM_AES_192;
    public static int ALGORITHM_AES_256;
    public static int HASH_NONE;
    public static int HASH_SHA1;
    public static int HASH_SHA256;
    public static int HASH_SHA384;
    public static int HASH_SHA512;
    public static int PROVIDER_RC4;
    public static int PROVIDER_AES;
    public static int MODE_ECB;
    public static int MODE_CBC;
    public static int MODE_CFB;
    [CompilerGeneratedAttribute]
private ChainingMode <ChainingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SizeExtra>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherAlgorithm <CipherAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithm <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlockSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <KeySalt>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherProvider <CipherProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CspName>k__BackingField;
    public ChainingMode ChainingMode { get; public set; }
    public int Flags { get; public set; }
    public int SizeExtra { get; public set; }
    public CipherAlgorithm CipherAlgorithm { get; public set; }
    public HashAlgorithm HashAlgorithm { get; public set; }
    public int KeySize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] KeySalt { get; public set; }
    public CipherProvider CipherProvider { get; public set; }
    public string CspName { get; public set; }
    private static EncryptionHeader();
    [ObsoleteAttribute("use ChainingMode.ecmaId", "True")]
public int GetCipherMode();
    [CompilerGeneratedAttribute]
public ChainingMode get_ChainingMode();
    [CompilerGeneratedAttribute]
public void set_ChainingMode(ChainingMode value);
    [CompilerGeneratedAttribute]
public int get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(int value);
    [CompilerGeneratedAttribute]
public int get_SizeExtra();
    [CompilerGeneratedAttribute]
public void set_SizeExtra(int value);
    [ObsoleteAttribute("use CipherAlgorithm")]
public int GetAlgorithm();
    [CompilerGeneratedAttribute]
public CipherAlgorithm get_CipherAlgorithm();
    [CompilerGeneratedAttribute]
public void set_CipherAlgorithm(CipherAlgorithm value);
    [ObsoleteAttribute("use HashAlgorithmEx")]
public int GetHashAlgorithm();
    [CompilerGeneratedAttribute]
public HashAlgorithm get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithm(HashAlgorithm value);
    [CompilerGeneratedAttribute]
public int get_KeySize();
    [CompilerGeneratedAttribute]
public void set_KeySize(int value);
    [CompilerGeneratedAttribute]
public int get_BlockSize();
    [CompilerGeneratedAttribute]
public void set_BlockSize(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_KeySalt();
    [CompilerGeneratedAttribute]
public void set_KeySalt(Byte[] value);
    [ObsoleteAttribute("use CipherProvider")]
public int GetProviderType();
    [CompilerGeneratedAttribute]
public CipherProvider get_CipherProvider();
    [CompilerGeneratedAttribute]
public void set_CipherProvider(CipherProvider value);
    [CompilerGeneratedAttribute]
public string get_CspName();
    [CompilerGeneratedAttribute]
public void set_CspName(string value);
}
public class NPOI.POIFS.Crypt.EncryptionInfo : object {
    public static BitField flagCryptoAPI;
    public static BitField flagDocProps;
    public static BitField flagExternal;
    public static BitField flagAES;
    private int _versionMajor;
    private int _versionMinor;
    private int _encryptionFlags;
    private EncryptionHeader _header;
    private EncryptionVerifier _verifier;
    private Decryptor _decryptor;
    private Encryptor _encryptor;
    public int VersionMajor { get; }
    public int VersionMinor { get; }
    public int EncryptionFlags { get; }
    public EncryptionHeader Header { get; }
    public EncryptionVerifier Verifier { get; }
    public Decryptor Decryptor { get; }
    public Encryptor Encryptor { get; }
    public EncryptionInfo(POIFSFileSystem fs);
    public EncryptionInfo(OPOIFSFileSystem fs);
    public EncryptionInfo(NPOIFSFileSystem fs);
    public EncryptionInfo(DirectoryNode dir);
    public EncryptionInfo(ILittleEndianInput dis, bool isCryptoAPI);
    public EncryptionInfo(POIFSFileSystem fs, EncryptionMode encryptionMode);
    public EncryptionInfo(NPOIFSFileSystem fs, EncryptionMode encryptionMode);
    public EncryptionInfo(DirectoryNode dir, EncryptionMode encryptionMode);
    public EncryptionInfo(POIFSFileSystem fs, EncryptionMode encryptionMode, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public EncryptionInfo(NPOIFSFileSystem fs, EncryptionMode encryptionMode, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public EncryptionInfo(DirectoryNode dir, EncryptionMode encryptionMode, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public EncryptionInfo(EncryptionMode encryptionMode);
    public EncryptionInfo(EncryptionMode encryptionMode, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    private static EncryptionInfo();
    protected static IEncryptionInfoBuilder GetBuilder(EncryptionMode encryptionMode);
    public int get_VersionMajor();
    public int get_VersionMinor();
    public int get_EncryptionFlags();
    public EncryptionHeader get_Header();
    public EncryptionVerifier get_Verifier();
    public Decryptor get_Decryptor();
    public Encryptor get_Encryptor();
}
public class NPOI.POIFS.Crypt.EncryptionMode : object {
    public static EncryptionMode BinaryRC4;
    public static EncryptionMode CryptoAPI;
    public static EncryptionMode Standard;
    public static EncryptionMode Agile;
    [CompilerGeneratedAttribute]
private string <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VersionMajor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VersionMinor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EncryptionFlags>k__BackingField;
    public string Builder { get; private set; }
    public int VersionMajor { get; private set; }
    public int VersionMinor { get; private set; }
    public int EncryptionFlags { get; private set; }
    public EncryptionMode(string builder, int versionMajor, int versionMinor, int encryptionFlags);
    private static EncryptionMode();
    [CompilerGeneratedAttribute]
public string get_Builder();
    [CompilerGeneratedAttribute]
private void set_Builder(string value);
    [CompilerGeneratedAttribute]
public int get_VersionMajor();
    [CompilerGeneratedAttribute]
private void set_VersionMajor(int value);
    [CompilerGeneratedAttribute]
public int get_VersionMinor();
    [CompilerGeneratedAttribute]
private void set_VersionMinor(int value);
    [CompilerGeneratedAttribute]
public int get_EncryptionFlags();
    [CompilerGeneratedAttribute]
private void set_EncryptionFlags(int value);
}
public abstract class NPOI.POIFS.Crypt.EncryptionVerifier : object {
    private Byte[] encryptedVerifier;
    private Byte[] encryptedVerifierHash;
    private Byte[] encryptedKey;
    private int spinCount;
    private CipherAlgorithm cipherAlgorithm;
    private ChainingMode chainingMode;
    private HashAlgorithm hashAlgorithm;
    [CompilerGeneratedAttribute]
private Byte[] <Salt>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EncryptedVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EncryptedVerifierHash>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpinCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EncryptedKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherAlgorithm <CipherAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithm <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ChainingMode <ChainingMode>k__BackingField;
    public Byte[] Salt { get; public set; }
    public Byte[] EncryptedVerifier { get; public set; }
    public Byte[] EncryptedVerifierHash { get; public set; }
    public int SpinCount { get; public set; }
    public Byte[] EncryptedKey { get; public set; }
    public CipherAlgorithm CipherAlgorithm { get; public set; }
    public HashAlgorithm HashAlgorithm { get; public set; }
    public ChainingMode ChainingMode { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Salt();
    [CompilerGeneratedAttribute]
public void set_Salt(Byte[] value);
    public Byte[] GetVerifier();
    [CompilerGeneratedAttribute]
public Byte[] get_EncryptedVerifier();
    [CompilerGeneratedAttribute]
public void set_EncryptedVerifier(Byte[] value);
    public Byte[] GetVerifierHash();
    [CompilerGeneratedAttribute]
public Byte[] get_EncryptedVerifierHash();
    [CompilerGeneratedAttribute]
public void set_EncryptedVerifierHash(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_SpinCount();
    [CompilerGeneratedAttribute]
public void set_SpinCount(int value);
    public int GetCipherMode();
    public int GetAlgorithm();
    public string GetAlgorithmName();
    [CompilerGeneratedAttribute]
public Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
public void set_EncryptedKey(Byte[] value);
    [CompilerGeneratedAttribute]
public CipherAlgorithm get_CipherAlgorithm();
    [CompilerGeneratedAttribute]
public void set_CipherAlgorithm(CipherAlgorithm value);
    [CompilerGeneratedAttribute]
public HashAlgorithm get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithm(HashAlgorithm value);
    [CompilerGeneratedAttribute]
public ChainingMode get_ChainingMode();
    [CompilerGeneratedAttribute]
public void set_ChainingMode(ChainingMode value);
}
public abstract class NPOI.POIFS.Crypt.Encryptor : object {
    internal static string DEFAULT_POIFS_ENTRY;
    private ISecretKey secretKey;
    private static Encryptor();
    public abstract virtual OutputStream GetDataStream(DirectoryNode dir);
    public abstract virtual void ConfirmPassword(string password, Byte[] keySpec, Byte[] keySalt, Byte[] verifier, Byte[] verifierSalt, Byte[] integritySalt);
    public abstract virtual void ConfirmPassword(string password);
    public static Encryptor GetInstance(EncryptionInfo info);
    public OutputStream GetDataStream(NPOIFSFileSystem fs);
    public OutputStream GetDataStream(OPOIFSFileSystem fs);
    public OutputStream GetDataStream(POIFSFileSystem fs);
    public ISecretKey GetSecretKey();
    protected void SetSecretKey(ISecretKey secretKey);
}
public class NPOI.POIFS.Crypt.HashAlgorithm : object {
    public static HashAlgorithm none;
    public static HashAlgorithm sha1;
    public static HashAlgorithm sha256;
    public static HashAlgorithm sha384;
    public static HashAlgorithm sha512;
    public static HashAlgorithm md5;
    public static HashAlgorithm md2;
    public static HashAlgorithm md4;
    public static HashAlgorithm ripemd128;
    public static HashAlgorithm ripemd160;
    public static HashAlgorithm whirlpool;
    public static HashAlgorithm sha224;
    public static HashAlgorithm[] values;
    public string jceId;
    public int ecmaId;
    public string ecmaString;
    public int hashSize;
    public string jceHmacId;
    public bool needsBouncyCastle;
    public HashAlgorithm(string jceId, int ecmaId, string ecmaString, int hashSize, string jceHmacId, bool needsBouncyCastle);
    private static HashAlgorithm();
    public static HashAlgorithm FromEcmaId(int ecmaId);
    public static HashAlgorithm FromEcmaId(string ecmaString);
    public static HashAlgorithm FromString(string string1);
}
public interface NPOI.POIFS.Crypt.IEncryptionInfoBuilder {
    public abstract virtual void Initialize(EncryptionInfo ei, ILittleEndianInput dis);
    public abstract virtual void Initialize(EncryptionInfo ei, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public abstract virtual EncryptionHeader GetHeader();
    public abstract virtual EncryptionVerifier GetVerifier();
    public abstract virtual Decryptor GetDecryptor();
    public abstract virtual Encryptor GetEncryptor();
}
public interface NPOI.POIFS.Crypt.IKey {
    public abstract virtual string GetAlgorithm();
    public abstract virtual string GetFormat();
    public abstract virtual Byte[] GetEncoded();
}
public interface NPOI.POIFS.Crypt.IKeySpec {
}
public interface NPOI.POIFS.Crypt.IPrivateKey {
}
public interface NPOI.POIFS.Crypt.ISecretKey {
}
public class NPOI.POIFS.Crypt.IvParameterSpec : AlgorithmParameterSpec {
    private Byte[] iv;
    public IvParameterSpec(Byte[] iv);
    public Byte[] GetIV();
}
public class NPOI.POIFS.Crypt.MessageDigest : object {
    private IDigest digestImpl;
    internal static MessageDigest GetInstance(string jceId, string v);
    internal static MessageDigest GetInstance(string jceId);
    internal void Update(Byte[] passwordHash);
    internal void Reset();
    internal int Digest(Byte[] buf, int offset, int len);
    internal Byte[] Digest();
    internal void Update(Byte[] hash, int v1, int v2);
    public Byte[] Digest(Byte[] input);
}
public class NPOI.POIFS.Crypt.RC2ParameterSpec : AlgorithmParameterSpec {
    private Byte[] iv;
    private int effectiveKeyBits;
    public RC2ParameterSpec(int v, Byte[] vec);
    public int GetEffectiveKeyBits();
    public Byte[] GetIV();
}
public class NPOI.POIFS.Crypt.SecretKeySpec : object {
    private Byte[] key;
    private string algorithm;
    public SecretKeySpec(Byte[] key, string algorithm);
    public sealed virtual string GetAlgorithm();
    public sealed virtual Byte[] GetEncoded();
    public sealed virtual string GetFormat();
}
public class NPOI.POIFS.Crypt.Standard.CipherInputStream : ByteArrayInputStream {
    private Cipher cipher;
    private ByteArrayInputStream input;
    private Byte[] ibuffer;
    private bool done;
    private Byte[] obuffer;
    private int ostart;
    private int ofinish;
    private bool closed;
    public CipherInputStream(ByteArrayInputStream paramInputStream, Cipher paramCipher);
    protected CipherInputStream(ByteArrayInputStream paramInputStream);
    private int getMoreData();
    public virtual int Read();
    public int Read(Byte[] b);
    public virtual int Read(Byte[] b, int off, int len);
    public long Skip(long paramLong);
    public virtual int Available();
    public virtual void Close();
    public bool MarkSupported();
}
internal class NPOI.POIFS.Crypt.Standard.CipherOutputStream : ByteArrayOutputStream {
    private Byte[] ibuffer;
    private Byte[] obuffer;
    private bool closed;
    private FileStream output;
    private Cipher cipher;
    public CipherOutputStream(FileStream rawStream, Cipher cipher);
    protected CipherOutputStream(FileStream rawStream);
    public virtual void Write(int paramInt);
    public virtual void Write(Byte[] b);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void Close();
}
public interface NPOI.POIFS.Crypt.Standard.EncryptionRecord {
    public abstract virtual void Write(LittleEndianByteArrayOutputStream os);
}
public class NPOI.POIFS.Crypt.Standard.NullBufferedCipher : object {
    public string AlgorithmName { get; }
    public sealed virtual string get_AlgorithmName();
    public sealed virtual Byte[] DoFinal();
    public sealed virtual Byte[] DoFinal(Byte[] input);
    public sealed virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public sealed virtual int DoFinal(Byte[] output, int outOff);
    public sealed virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public sealed virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public sealed virtual int GetBlockSize();
    public sealed virtual int GetOutputSize(int inputLen);
    public sealed virtual int GetUpdateOutputSize(int inputLen);
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual Byte[] ProcessByte(byte input);
    public sealed virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public sealed virtual Byte[] ProcessBytes(Byte[] input);
    public sealed virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public sealed virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public sealed virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public sealed virtual void Reset();
}
public class NPOI.POIFS.Crypt.Standard.NullCipher : Cipher {
}
public class NPOI.POIFS.Crypt.Standard.StandardDecryptor : Decryptor {
    private long _length;
    internal StandardDecryptor(IEncryptionInfoBuilder builder);
    public virtual bool VerifyPassword(string password);
    protected internal static ISecretKey GenerateSecretKey(string password, EncryptionVerifier ver, int keySize);
    protected static Byte[] FillAndXor(Byte[] hash, byte FillByte);
    private Cipher GetCipher(ISecretKey key);
    public virtual InputStream GetDataStream(DirectoryNode dir);
    public virtual long GetLength();
}
public class NPOI.POIFS.Crypt.Standard.StandardEncryptionHeader : EncryptionHeader {
    internal StandardEncryptionHeader(ILittleEndianInput is1);
    protected internal StandardEncryptionHeader(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public sealed virtual void Write(LittleEndianByteArrayOutputStream bos);
}
public class NPOI.POIFS.Crypt.Standard.StandardEncryptionInfoBuilder : object {
    private EncryptionInfo info;
    private StandardEncryptionHeader header;
    private StandardEncryptionVerifier verifier;
    private StandardDecryptor decryptor;
    private StandardEncryptor encryptor;
    public sealed virtual void Initialize(EncryptionInfo info, ILittleEndianInput dis);
    public sealed virtual void Initialize(EncryptionInfo info, CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    public StandardEncryptionHeader GetHeader();
    public StandardEncryptionVerifier GetVerifier();
    public StandardDecryptor GetDecryptor();
    public StandardEncryptor GetEncryptor();
    public EncryptionInfo GetEncryptionInfo();
    private sealed virtual override EncryptionHeader NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetHeader();
    private sealed virtual override EncryptionVerifier NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetVerifier();
    private sealed virtual override Decryptor NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetDecryptor();
    private sealed virtual override Encryptor NPOI.POIFS.Crypt.IEncryptionInfoBuilder.GetEncryptor();
}
public class NPOI.POIFS.Crypt.Standard.StandardEncryptionVerifier : EncryptionVerifier {
    private static int SPIN_COUNT;
    private int verifierHashSize;
    internal StandardEncryptionVerifier(ILittleEndianInput is1, StandardEncryptionHeader header);
    protected internal StandardEncryptionVerifier(CipherAlgorithm cipherAlgorithm, HashAlgorithm hashAlgorithm, int keyBits, int blockSize, ChainingMode chainingMode);
    private static StandardEncryptionVerifier();
    protected internal void SetSalt(Byte[] salt);
    protected internal void SetEncryptedVerifier(Byte[] encryptedVerifier);
    protected internal void SetEncryptedVerifierHash(Byte[] encryptedVerifierHash);
    public sealed virtual void Write(LittleEndianByteArrayOutputStream bos);
    protected int GetVerifierHashSize();
}
public class NPOI.POIFS.Crypt.Standard.StandardEncryptor : Encryptor {
    private StandardEncryptionInfoBuilder builder;
    protected internal StandardEncryptor(StandardEncryptionInfoBuilder builder);
    public virtual void ConfirmPassword(string password);
    public virtual void ConfirmPassword(string password, Byte[] keySpec, Byte[] keySalt, Byte[] verifier, Byte[] verifierSalt, Byte[] integritySalt);
    private Cipher GetCipher(ISecretKey key, string padding);
    public virtual OutputStream GetDataStream(DirectoryNode dir);
    protected int GetKeySizeInBytes();
    protected internal void CreateEncryptionInfoEntry(DirectoryNode dir);
}
public class NPOI.POIFS.Dev.POIFSLister : object {
    public static void ViewFile(string filename);
    public static void DisplayDirectory(DirectoryNode dir, string indent);
}
public interface NPOI.POIFS.Dev.POIFSViewable {
    public Object[] ViewableArray { get; }
    public IEnumerator`1<object> ViewableIterator { get; }
    public bool PreferArray { get; }
    public string ShortDescription { get; }
    public abstract virtual Object[] get_ViewableArray();
    public abstract virtual IEnumerator`1<object> get_ViewableIterator();
    public abstract virtual bool get_PreferArray();
    public abstract virtual string get_ShortDescription();
}
public class NPOI.POIFS.Dev.POIFSViewEngine : object {
    public static IList`1<string> InspectViewable(object viewable, bool drilldown, int indentLevel, string indentString);
    internal static void ProcessViewable(object viewable, bool drilldown, int indentLevel, string indentString, List`1<string> objects);
    private static string Indent(int indentLevel, string indentString, string data);
}
public class NPOI.POIFS.Dev.POIFSViewer : object {
    public static void ViewFile(string filename, bool printName);
}
public class NPOI.POIFS.EventFileSystem.POIFSReader : object {
    [CompilerGeneratedAttribute]
private POIFSReaderEventHandler StreamReaded;
    private POIFSReaderRegistry registry;
    private bool registryClosed;
    [CompilerGeneratedAttribute]
public void add_StreamReaded(POIFSReaderEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StreamReaded(POIFSReaderEventHandler value);
    protected virtual void OnStreamReaded(POIFSReaderEventArgs e);
    public List`1<DocumentDescriptor> Read(Stream stream);
    public void RegisterListener(POIFSReaderListener listener);
    public void RegisterListener(POIFSReaderListener listener, string name);
    public void RegisterListener(POIFSReaderListener listener, POIFSDocumentPath path, string name);
    private List`1<DocumentDescriptor> ProcessProperties(BlockList small_blocks, BlockList big_blocks, IEnumerator properties, POIFSDocumentPath path);
}
public class NPOI.POIFS.EventFileSystem.POIFSReaderEvent : object {
    private DocumentInputStream stream;
    private POIFSDocumentPath path;
    private string documentName;
    public DocumentInputStream Stream { get; }
    public POIFSDocumentPath Path { get; }
    public string Name { get; }
    public POIFSReaderEvent(DocumentInputStream stream, POIFSDocumentPath path, string documentName);
    public DocumentInputStream get_Stream();
    public POIFSDocumentPath get_Path();
    public string get_Name();
}
public class NPOI.POIFS.EventFileSystem.POIFSReaderEventArgs : EventArgs {
    private POIFSDocumentPath path;
    private OPOIFSDocument document;
    private string name;
    public POIFSDocumentPath Path { get; }
    public OPOIFSDocument Document { get; }
    public DocumentInputStream Stream { get; }
    public string Name { get; }
    public POIFSReaderEventArgs(string name, POIFSDocumentPath path, OPOIFSDocument document);
    public virtual POIFSDocumentPath get_Path();
    public virtual OPOIFSDocument get_Document();
    public virtual DocumentInputStream get_Stream();
    public virtual string get_Name();
}
public class NPOI.POIFS.EventFileSystem.POIFSReaderEventHandler : MulticastDelegate {
    public POIFSReaderEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, POIFSReaderEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, POIFSReaderEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface NPOI.POIFS.EventFileSystem.POIFSReaderListener {
    public abstract virtual void ProcessPOIFSReaderEvent(POIFSReaderEvent evt);
}
public class NPOI.POIFS.EventFileSystem.POIFSReaderRegistry : object {
    private ArrayList omnivorousListeners;
    private Hashtable selectiveListeners;
    private Hashtable chosenDocumentDescriptors;
    public void RegisterListener(POIFSReaderListener listener, POIFSDocumentPath path, string documentName);
    public void RegisterListener(POIFSReaderListener listener);
    public IEnumerator GetListeners(POIFSDocumentPath path, string name);
    private void RemoveSelectiveListener(POIFSReaderListener listener);
    private void DropDocument(POIFSReaderListener listener, DocumentDescriptor descriptor);
}
public class NPOI.POIFS.EventFileSystem.POIFSWriterEvent : object {
    private DocumentOutputStream stream;
    private POIFSDocumentPath path;
    private string documentName;
    private int limit;
    public DocumentOutputStream Stream { get; }
    public POIFSDocumentPath Path { get; }
    public string Name { get; }
    public int Limit { get; }
    public POIFSWriterEvent(DocumentOutputStream stream, POIFSDocumentPath path, string documentName, int limit);
    public DocumentOutputStream get_Stream();
    public POIFSDocumentPath get_Path();
    public string get_Name();
    public int get_Limit();
}
public class NPOI.POIFS.EventFileSystem.POIFSWriterEventArgs : EventArgs {
    private string documentName;
    private int limit;
    private POIFSDocumentPath path;
    private DocumentOutputStream stream;
    public int Limit { get; }
    public string Name { get; }
    public POIFSDocumentPath Path { get; }
    public DocumentOutputStream Stream { get; }
    public POIFSWriterEventArgs(DocumentOutputStream stream, POIFSDocumentPath path, string documentName, int limit);
    public virtual int get_Limit();
    public virtual string get_Name();
    public virtual POIFSDocumentPath get_Path();
    public virtual DocumentOutputStream get_Stream();
}
public class NPOI.POIFS.EventFileSystem.POIFSWriterEventHandler : MulticastDelegate {
    public POIFSWriterEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, POIFSWriterEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, POIFSWriterEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface NPOI.POIFS.EventFileSystem.POIFSWriterListener {
    public abstract virtual void ProcessPOIFSWriterEvent(POIFSWriterEvent event1);
}
public interface NPOI.POIFS.FileSystem.BATManaged {
    public int CountBlocks { get; }
    unknown int StartBlock {public set; }
    public abstract virtual int get_CountBlocks();
    public abstract virtual void set_StartBlock(int value);
}
public abstract class NPOI.POIFS.FileSystem.BlockStore : object {
    public abstract virtual int GetBlockStoreBlockSize();
    public abstract virtual ByteBuffer GetBlockAt(int offset);
    public abstract virtual bool TryGetBlockAt(int offset, ByteBuffer& byteBuffer);
    public abstract virtual ByteBuffer CreateBlockIfNeeded(int offset);
    public abstract virtual BATBlockAndIndex GetBATBlockAndIndex(int offset);
    public abstract virtual int GetNextBlock(int offset);
    public abstract virtual void SetNextBlock(int offset, int nextBlock);
    public abstract virtual int GetFreeBlock();
    public abstract virtual ChainLoopDetector GetChainLoopDetector();
}
public class NPOI.POIFS.FileSystem.ChainLoopDetector : object {
    private Boolean[] used_blocks;
    private BlockStore blockStore;
    public ChainLoopDetector(long rawSize, BlockStore blockStore);
    public void Claim(int offset);
}
internal class NPOI.POIFS.FileSystem.CloseIgnoringInputStream : Stream {
    private Stream _is;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CloseIgnoringInputStream(Stream stream);
    public int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public interface NPOI.POIFS.FileSystem.DirectoryEntry {
    public IEnumerator`1<Entry> Entries { get; }
    public List`1<string> EntryNames { get; }
    public bool IsEmpty { get; }
    public int EntryCount { get; }
    public ClassID StorageClsid { get; public set; }
    public abstract virtual IEnumerator`1<Entry> get_Entries();
    public abstract virtual List`1<string> get_EntryNames();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_EntryCount();
    public abstract virtual Entry GetEntry(string name);
    public abstract virtual DocumentEntry CreateDocument(string name, Stream stream);
    public abstract virtual DocumentEntry CreateDocument(string name, int size, POIFSWriterListener writer);
    public abstract virtual DirectoryEntry CreateDirectory(string name);
    public abstract virtual ClassID get_StorageClsid();
    public abstract virtual void set_StorageClsid(ClassID value);
    public abstract virtual bool HasEntry(string name);
}
public class NPOI.POIFS.FileSystem.DirectoryNode : EntryNode {
    private Dictionary`2<string, Entry> _byname;
    private List`1<Entry> _entries;
    private OPOIFSFileSystem _oFilesSystem;
    private NPOIFSFileSystem _nFilesSystem;
    private POIFSDocumentPath _path;
    public POIFSDocumentPath Path { get; }
    public NPOIFSFileSystem FileSystem { get; }
    public OPOIFSFileSystem OFileSystem { get; }
    public NPOIFSFileSystem NFileSystem { get; }
    public IEnumerator`1<Entry> Entries { get; }
    public List`1<string> EntryNames { get; }
    public bool IsEmpty { get; }
    public int EntryCount { get; }
    public ClassID StorageClsid { get; public set; }
    public bool IsDirectoryEntry { get; }
    protected bool IsDeleteOK { get; }
    public Object[] ViewableArray { get; }
    public IEnumerator`1<object> ViewableIterator { get; }
    public bool PreferArray { get; }
    public string ShortDescription { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal DirectoryNode(DirectoryProperty property, OPOIFSFileSystem fileSystem, DirectoryNode parent);
    internal DirectoryNode(DirectoryProperty property, NPOIFSFileSystem nFileSystem, DirectoryNode parent);
    private DirectoryNode(DirectoryProperty property, DirectoryNode parent, OPOIFSFileSystem oFileSystem, NPOIFSFileSystem nFileSystem);
    public DocumentInputStream CreatePOIFSDocumentReader(string documentName);
    public DocumentEntry CreateDocument(OPOIFSDocument document);
    public bool ChangeName(string oldName, string newName);
    public bool DeleteEntry(EntryNode entry);
    public POIFSDocumentPath get_Path();
    public NPOIFSFileSystem get_FileSystem();
    public OPOIFSFileSystem get_OFileSystem();
    public NPOIFSFileSystem get_NFileSystem();
    public sealed virtual IEnumerator`1<Entry> get_Entries();
    internal Entry GetEntry(int index);
    public sealed virtual List`1<string> get_EntryNames();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual int get_EntryCount();
    public sealed virtual bool HasEntry(string name);
    public sealed virtual Entry GetEntry(string name);
    public DocumentInputStream CreateDocumentInputStream(Entry document);
    public DocumentInputStream CreateDocumentInputStream(string documentName);
    public DocumentEntry CreateDocument(NPOIFSDocument document);
    public sealed virtual DirectoryEntry CreateDirectory(string name);
    public DocumentEntry CreateOrUpdateDocument(string name, Stream stream);
    public sealed virtual void set_StorageClsid(ClassID value);
    public sealed virtual ClassID get_StorageClsid();
    public virtual bool get_IsDirectoryEntry();
    protected virtual bool get_IsDeleteOK();
    public sealed virtual DocumentEntry CreateDocument(string name, Stream stream);
    public sealed virtual DocumentEntry CreateDocument(string name, int size, POIFSWriterListener writer);
    public sealed virtual Object[] get_ViewableArray();
    public sealed virtual IEnumerator`1<object> get_ViewableIterator();
    public sealed virtual bool get_PreferArray();
    public sealed virtual string get_ShortDescription();
    public sealed virtual IEnumerator`1<Entry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool get_CanRead();
    public bool get_CanSeek();
    public bool get_CanWrite();
    public void Flush();
    public long get_Length();
    public long get_Position();
    public void set_Position(long value);
    public int Read(Byte[] buffer, int offset, int count);
    public long Seek(long offset, SeekOrigin origin);
    public void SetLength(long value);
}
public class NPOI.POIFS.FileSystem.DocumentDescriptor : object {
    private POIFSDocumentPath path;
    private string name;
    private int hashcode;
    public string Path { get; }
    public string Name { get; }
    public DocumentDescriptor(POIFSDocumentPath path, string name);
    public string get_Path();
    public string get_Name();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface NPOI.POIFS.FileSystem.DocumentEntry {
    public int Size { get; }
    public abstract virtual int get_Size();
}
public static class NPOI.POIFS.FileSystem.DocumentFactoryHelper : object {
    public static InputStream GetDecryptedStream(NPOIFSFileSystem fs, string password);
    public static bool HasOOXMLHeader(Stream inp);
    public static bool IsPasswordProtected(string fileName);
    public static bool IsPasswordProtected(Stream stream);
    public static OfficeProtectType GetPasswordProtected(Stream stream);
    private static OfficeProtectType ScanForPassword(Stream stream, Byte[] buffer, int sectionSize);
    private static void ReadFromStream(Stream stream, Byte[] buffer);
}
public class NPOI.POIFS.FileSystem.DocumentInputStream : ByteArrayInputStream {
    protected static int EOF;
    protected static int SIZE_SHORT;
    protected static int SIZE_INT;
    protected static int SIZE_LONG;
    private DocumentInputStream delegate1;
    public long Length { get; }
    public long Position { get; public set; }
    public DocumentInputStream(DocumentEntry document);
    public DocumentInputStream(OPOIFSDocument document);
    public DocumentInputStream(NPOIFSDocument document);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Available();
    public virtual void Close();
    public virtual void Mark(int readlimit);
    public virtual bool MarkSupported();
    public virtual int Read();
    public virtual int Read(Byte[] b);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Reset();
    public virtual long Skip(long n);
    public virtual int ReadByte();
    public virtual double ReadDouble();
    public virtual short ReadShort();
    public virtual void ReadFully(Byte[] buf);
    public virtual void ReadFully(Byte[] buf, int off, int len);
    public virtual long ReadLong();
    public virtual int ReadInt();
    public virtual int ReadUShort();
    public virtual int ReadUByte();
}
public class NPOI.POIFS.FileSystem.DocumentNode : EntryNode {
    private OPOIFSDocument _document;
    public OPOIFSDocument Document { get; }
    public int Size { get; }
    public bool IsDocumentEntry { get; }
    protected bool IsDeleteOK { get; }
    public Object[] ViewableArray { get; }
    public IEnumerator`1<object> ViewableIterator { get; }
    public bool PreferArray { get; }
    public string ShortDescription { get; }
    public DocumentNode(DocumentProperty property, DirectoryNode parent);
    public OPOIFSDocument get_Document();
    public sealed virtual int get_Size();
    public virtual bool get_IsDocumentEntry();
    protected virtual bool get_IsDeleteOK();
    public sealed virtual Object[] get_ViewableArray();
    public sealed virtual IEnumerator`1<object> get_ViewableIterator();
    public sealed virtual bool get_PreferArray();
    public sealed virtual string get_ShortDescription();
}
public class NPOI.POIFS.FileSystem.DocumentOutputStream : MemoryStream {
    private Stream _stream;
    private int _limit;
    private int _written;
    public DocumentOutputStream(Stream stream, int limit);
    public void Write(int b);
    public void Write(Byte[] b);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void Close();
    public void WriteFiller(int totalLimit, byte Fill);
    private void LimitCheck(int toBeWritten);
}
public interface NPOI.POIFS.FileSystem.Entry {
    public string Name { get; }
    public bool IsDirectoryEntry { get; }
    public bool IsDocumentEntry { get; }
    public DirectoryEntry Parent { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_IsDirectoryEntry();
    public abstract virtual bool get_IsDocumentEntry();
    public abstract virtual DirectoryEntry get_Parent();
    public abstract virtual bool Delete();
    public abstract virtual bool RenameTo(string newName);
}
public abstract class NPOI.POIFS.FileSystem.EntryNode : object {
    protected Property _property;
    protected DirectoryNode _parent;
    public Property Property { get; }
    protected bool IsRoot { get; }
    protected bool IsDeleteOK { get; }
    public string Name { get; }
    public bool IsDirectoryEntry { get; }
    public bool IsDocumentEntry { get; }
    public DirectoryEntry Parent { get; }
    protected EntryNode(Property property, DirectoryNode parent);
    public Property get_Property();
    protected bool get_IsRoot();
    protected abstract virtual bool get_IsDeleteOK();
    public sealed virtual string get_Name();
    public virtual bool get_IsDirectoryEntry();
    public virtual bool get_IsDocumentEntry();
    public sealed virtual DirectoryEntry get_Parent();
    public sealed virtual bool Delete();
    public sealed virtual bool RenameTo(string newName);
    public virtual string ToString();
}
public class NPOI.POIFS.FileSystem.EntryUtils : object {
    public static void CopyNodeRecursively(Entry entry, DirectoryEntry target);
    public static void CopyNodes(DirectoryEntry sourceRoot, DirectoryEntry targetRoot);
    public static void CopyNodes(FilteringDirectoryNode filteredSource, FilteringDirectoryNode filteredTarget);
    [ObsoleteAttribute("To be removed NPOI 2.8.")]
public static void CopyNodes(DirectoryEntry sourceRoot, DirectoryEntry targetRoot, List`1<string> excepts);
    public static void CopyNodes(OPOIFSFileSystem source, OPOIFSFileSystem target);
    public static void CopyNodes(NPOIFSFileSystem source, NPOIFSFileSystem target);
    public static void CopyNodes(OPOIFSFileSystem source, OPOIFSFileSystem target, List`1<string> excepts);
    public static void CopyNodes(NPOIFSFileSystem source, NPOIFSFileSystem target, List`1<string> excepts);
    public static bool AreDirectoriesIdentical(DirectoryEntry dirA, DirectoryEntry dirB);
    public static bool AreDocumentsIdentical(DocumentEntry docA, DocumentEntry docB);
}
public class NPOI.POIFS.FileSystem.FilteringDirectoryNode : object {
    private List`1<string> excludes;
    private Dictionary`2<string, List`1<string>> childExcludes;
    private DirectoryEntry directory;
    public IEnumerator`1<Entry> Entries { get; }
    public List`1<string> EntryNames { get; }
    public bool IsEmpty { get; }
    public int EntryCount { get; }
    public ClassID StorageClsid { get; public set; }
    public string Name { get; }
    public bool IsDirectoryEntry { get; }
    public bool IsDocumentEntry { get; }
    public DirectoryEntry Parent { get; }
    public FilteringDirectoryNode(DirectoryEntry directory, ICollection`1<string> excludes);
    public sealed virtual IEnumerator`1<Entry> get_Entries();
    public sealed virtual List`1<string> get_EntryNames();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool HasEntry(string name);
    public sealed virtual int get_EntryCount();
    public IEnumerator`1<Entry> GetEntries();
    public sealed virtual Entry GetEntry(string name);
    private Entry WrapEntry(Entry entry);
    public sealed virtual DocumentEntry CreateDocument(string name, Stream stream);
    public sealed virtual DocumentEntry CreateDocument(string name, int size, POIFSWriterListener writer);
    public sealed virtual DirectoryEntry CreateDirectory(string name);
    public sealed virtual ClassID get_StorageClsid();
    public sealed virtual void set_StorageClsid(ClassID value);
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsDirectoryEntry();
    public sealed virtual bool get_IsDocumentEntry();
    public sealed virtual DirectoryEntry get_Parent();
    public sealed virtual bool Delete();
    public sealed virtual bool RenameTo(string newName);
    public sealed virtual IEnumerator`1<Entry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NPOI.POIFS.FileSystem.NDocumentInputStream : DocumentInputStream {
    private int _current_offset;
    private int _current_block_count;
    private int _marked_offset;
    private int _marked_offset_count;
    private int _document_size;
    private bool _closed;
    private NPOIFSDocument _document;
    private IEnumerator`1<ByteBuffer> _data;
    private ByteBuffer _buffer;
    public long Length { get; }
    public long Position { get; public set; }
    public NDocumentInputStream(DocumentEntry document);
    public NDocumentInputStream(NPOIFSDocument document);
    public virtual int Available();
    public virtual void Close();
    public virtual void Mark(int ignoredReadlimit);
    public virtual int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Reset();
    public virtual long Skip(long n);
    private void DieIfClosed();
    private bool atEOD();
    private void CheckAvaliable(int requestedSize);
    public virtual void ReadFully(Byte[] buf, int off, int len);
    public virtual int ReadByte();
    public virtual double ReadDouble();
    public virtual long ReadLong();
    public virtual void ReadFully(Byte[] buf);
    public virtual short ReadShort();
    public virtual int ReadInt();
    public virtual int ReadUShort();
    public virtual int ReadUByte();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
}
public class NPOI.POIFS.FileSystem.NDocumentOutputStream : MemoryStream {
    private int _document_size;
    private bool _closed;
    private NPOIFSDocument _document;
    private DocumentProperty _property;
    private MemoryStream _buffer;
    private NPOIFSStream _stream;
    private Stream _stream_output;
    public NDocumentOutputStream(DocumentEntry document);
    public NDocumentOutputStream(DirectoryEntry parent, string name);
    private void dieIfClosed();
    private void CheckBufferSize();
    public void Write(int b);
    public void Write(Byte[] b);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void Close();
}
public class NPOI.POIFS.FileSystem.NotOLE2FileException : IOException {
    public NotOLE2FileException(string s);
}
public class NPOI.POIFS.FileSystem.NPOIFSDocument : object {
    private DocumentProperty _property;
    private NPOIFSFileSystem _filesystem;
    private NPOIFSStream _stream;
    private int _block_size;
    internal NPOIFSFileSystem FileSystem { get; }
    public int Size { get; }
    public DocumentProperty DocumentProperty { get; }
    public bool PreferArray { get; }
    public string ShortDescription { get; }
    public Object[] ViewableArray { get; }
    public IEnumerator`1<object> ViewableIterator { get; }
    public NPOIFSDocument(DocumentNode document);
    public NPOIFSDocument(DocumentProperty property, NPOIFSFileSystem filesystem);
    public NPOIFSDocument(string name, NPOIFSFileSystem filesystem, Stream stream);
    public NPOIFSDocument(string name, int size, NPOIFSFileSystem filesystem, POIFSWriterListener Writer);
    private int Store(Stream inStream);
    internal void Free();
    internal NPOIFSFileSystem get_FileSystem();
    public int GetDocumentBlockSize();
    public IEnumerator`1<ByteBuffer> GetBlockIterator();
    public int get_Size();
    public void ReplaceContents(Stream stream);
    public DocumentProperty get_DocumentProperty();
    protected Object[] GetViewableArray();
    protected IEnumerator`1<object> GetViewableIterator();
    protected string GetShortDescription();
    public sealed virtual bool get_PreferArray();
    public sealed virtual string get_ShortDescription();
    public sealed virtual Object[] get_ViewableArray();
    public sealed virtual IEnumerator`1<object> get_ViewableIterator();
}
public class NPOI.POIFS.FileSystem.NPOIFSFileSystem : BlockStore {
    private static POILogger _logger;
    private NPOIFSMiniStore _mini_store;
    private NPropertyTable _property_table;
    private List`1<BATBlock> _xbat_blocks;
    private List`1<BATBlock> _bat_blocks;
    private HeaderBlock _header;
    private DirectoryNode _root;
    private DataSource _data;
    private POIFSBigBlockSize bigBlockSize;
    public DataSource Data { get; public set; }
    protected internal long Size { get; }
    public NPropertyTable PropertyTable { get; }
    public DirectoryNode Root { get; }
    public bool PreferArray { get; }
    public string ShortDescription { get; }
    public Object[] ViewableArray { get; }
    public IEnumerator`1<object> ViewableIterator { get; }
    private NPOIFSFileSystem(bool newFS);
    public NPOIFSFileSystem(FileInfo file);
    public NPOIFSFileSystem(FileInfo file, bool readOnly);
    public NPOIFSFileSystem(FileStream channel);
    public NPOIFSFileSystem(FileStream channel, bool readOnly);
    public NPOIFSFileSystem(FileStream channel, FileInfo srcFile, bool readOnly, bool closeChannelOnError);
    public NPOIFSFileSystem(Stream stream);
    private static NPOIFSFileSystem();
    public static Stream CreateNonClosingInputStream(Stream stream);
    public DataSource get_Data();
    public void set_Data(DataSource value);
    private void CloseInputStream(Stream stream, bool success);
    public static bool HasPOIFSHeader(Stream inp);
    public static bool HasPOIFSHeader(Byte[] header8Bytes);
    private void ReadCoreContents();
    private void ReadBAT(int batAt, ChainLoopDetector loopDetector);
    private BATBlock CreateBAT(int offset, bool isBAT);
    public virtual ByteBuffer GetBlockAt(int offset);
    public virtual bool TryGetBlockAt(int offset, ByteBuffer& buffer);
    public virtual ByteBuffer CreateBlockIfNeeded(int offset);
    public virtual BATBlockAndIndex GetBATBlockAndIndex(int offset);
    public virtual int GetNextBlock(int offset);
    public virtual void SetNextBlock(int offset, int nextBlock);
    public virtual int GetFreeBlock();
    protected internal long get_Size();
    public virtual ChainLoopDetector GetChainLoopDetector();
    public NPropertyTable get_PropertyTable();
    public NPOIFSMiniStore GetMiniStore();
    public void AddDocument(NPOIFSDocument document);
    public void AddDirectory(DirectoryProperty directory);
    public DocumentEntry CreateDocument(Stream stream, string name);
    public DocumentEntry CreateDocument(string name, int size, POIFSWriterListener writer);
    public DirectoryEntry CreateDirectory(string name);
    public DocumentEntry CreateOrUpdateDocument(Stream stream, string name);
    public bool IsInPlaceWriteable();
    public void WriteFileSystem();
    public void WriteFileSystem(Stream stream);
    private void syncWithDataSource();
    public sealed virtual void Close();
    public DirectoryNode get_Root();
    public DocumentInputStream CreateDocumentInputStream(string documentName);
    public void Remove(EntryNode entry);
    protected Object[] GetViewableArray();
    protected IEnumerator`1<object> GetViewableIterator();
    protected string GetShortDescription();
    public int GetBigBlockSize();
    public POIFSBigBlockSize GetBigBlockSizeDetails();
    public virtual int GetBlockStoreBlockSize();
    public sealed virtual bool get_PreferArray();
    public sealed virtual string get_ShortDescription();
    public sealed virtual Object[] get_ViewableArray();
    public sealed virtual IEnumerator`1<object> get_ViewableIterator();
}
public class NPOI.POIFS.FileSystem.NPOIFSMiniStore : BlockStore {
    private NPOIFSFileSystem _filesystem;
    private NPOIFSStream _mini_stream;
    private List`1<BATBlock> _sbat_blocks;
    private HeaderBlock _header;
    private RootProperty _root;
    public NPOIFSMiniStore(NPOIFSFileSystem filesystem, RootProperty root, List`1<BATBlock> sbats, HeaderBlock header);
    private ByteBuffer GetBlockAt(int offset, bool throwIfNotFound);
    public virtual ByteBuffer GetBlockAt(int offset);
    public virtual bool TryGetBlockAt(int offset, ByteBuffer& byteBuffer);
    public virtual ByteBuffer CreateBlockIfNeeded(int offset);
    public virtual BATBlockAndIndex GetBATBlockAndIndex(int offset);
    public virtual int GetNextBlock(int offset);
    public virtual void SetNextBlock(int offset, int nextBlock);
    public virtual int GetFreeBlock();
    public virtual ChainLoopDetector GetChainLoopDetector();
    public virtual int GetBlockStoreBlockSize();
    public void SyncWithDataSource();
}
public class NPOI.POIFS.FileSystem.NPOIFSStream : object {
    private BlockStore blockStore;
    private int startBlock;
    private MemoryStream outStream;
    public NPOIFSStream(BlockStore blockStore, int startBlock);
    public NPOIFSStream(BlockStore blockStore);
    public int GetStartBlock();
    public sealed virtual IEnumerator`1<ByteBuffer> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerator`1<ByteBuffer> GetBlockIterator();
    public void UpdateContents(Byte[] contents);
    public Stream GetOutputStream();
    public void Free();
    internal void Free(ChainLoopDetector loopDetector);
}
public class NPOI.POIFS.FileSystem.ODocumentInputStream : DocumentInputStream {
    private long _current_offset;
    private long _marked_offset;
    private int _document_size;
    private bool _closed;
    private OPOIFSDocument _document;
    private DataInputBlock _currentBlock;
    public long Length { get; }
    public long Position { get; public set; }
    public ODocumentInputStream(DocumentEntry document);
    public ODocumentInputStream(OPOIFSDocument document);
    public virtual long get_Length();
    public virtual int Available();
    public virtual void Close();
    public virtual void Mark(int ignoredReadlimit);
    private DataInputBlock GetDataInputBlock(long offset);
    public virtual int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Reset();
    public virtual long Skip(long n);
    private void dieIfClosed();
    private bool atEOD();
    private void CheckAvaliable(int requestedSize);
    public virtual int ReadByte();
    public virtual double ReadDouble();
    public virtual short ReadShort();
    public virtual void ReadFully(Byte[] buf, int off, int len);
    public virtual long ReadLong();
    public virtual int ReadInt();
    public virtual int ReadUShort();
    public virtual int ReadUByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class NPOI.POIFS.FileSystem.OfficeXmlFileException : UnsupportedFileFormatException {
    public OfficeXmlFileException(string s);
}
public class NPOI.POIFS.FileSystem.Ole10Native : object {
    public static string OLE10_NATIVE;
    protected static string ISO1;
    private int totalSize;
    private short flags1;
    private string label;
    private string fileName;
    private short flags2;
    private short unknown1;
    private string command;
    private Byte[] dataBuffer;
    private short flags3;
    private EncodingMode mode;
    public int TotalSize { get; }
    public short Flags1 { get; public set; }
    public string Label { get; public set; }
    public string FileName { get; public set; }
    public short Flags2 { get; public set; }
    public short Unknown1 { get; public set; }
    public string Command { get; public set; }
    public int DataSize { get; }
    public Byte[] DataBuffer { get; public set; }
    public short Flags3 { get; public set; }
    public Ole10Native(string label, string filename, string command, Byte[] data);
    public Ole10Native(Byte[] data, int offset);
    private static Ole10Native();
    public static Ole10Native CreateFromEmbeddedOleObject(POIFSFileSystem poifs);
    public static Ole10Native CreateFromEmbeddedOleObject(DirectoryNode directory);
    private static int GetStringLength(Byte[] data, int ofs);
    public int get_TotalSize();
    public short get_Flags1();
    public void set_Flags1(short value);
    public string get_Label();
    public void set_Label(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public short get_Flags2();
    public void set_Flags2(short value);
    public short get_Unknown1();
    public void set_Unknown1(short value);
    public string get_Command();
    public void set_Command(string value);
    public int get_DataSize();
    public Byte[] get_DataBuffer();
    public void set_DataBuffer(Byte[] value);
    public short get_Flags3();
    public void set_Flags3(short value);
    public void WriteOut(Stream out1);
}
public class NPOI.POIFS.FileSystem.Ole10NativeException : Exception {
    public Ole10NativeException(string message);
}
public class NPOI.POIFS.FileSystem.OPOIFSDocument : object {
    private static DocumentBlock[] EMPTY_BIG_BLOCK_ARRAY;
    private static SmallDocumentBlock[] EMPTY_SMALL_BLOCK_ARRAY;
    private DocumentProperty _property;
    private int _size;
    private POIFSBigBlockSize _bigBigBlockSize;
    private SmallBlockStore _small_store;
    private BigBlockStore _big_store;
    [CompilerGeneratedAttribute]
private POIFSWriterEventHandler BeforeWriting;
    public int CountBlocks { get; }
    public DocumentProperty DocumentProperty { get; }
    public bool PreferArray { get; }
    public string ShortDescription { get; }
    public int Size { get; }
    public SmallDocumentBlock[] SmallBlocks { get; }
    public int StartBlock { get; public set; }
    public Object[] ViewableArray { get; }
    public IEnumerator`1<object> ViewableIterator { get; }
    public OPOIFSDocument(string name, RawDataBlock[] blocks, int length);
    public OPOIFSDocument(string name, SmallDocumentBlock[] blocks, int length);
    public OPOIFSDocument(string name, POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, int length);
    public OPOIFSDocument(string name, POIFSBigBlockSize bigBlockSize, Stream stream);
    public OPOIFSDocument(string name, Stream stream);
    public OPOIFSDocument(string name, int size, POIFSBigBlockSize bigBlockSize, POIFSDocumentPath path, POIFSWriterListener writer);
    public OPOIFSDocument(string name, int size, POIFSDocumentPath path, POIFSWriterListener writer);
    public OPOIFSDocument(string name, ListManagedBlock[] blocks, int length);
    private static OPOIFSDocument();
    private static DocumentBlock[] ConvertRawBlocksToBigBlocks(ListManagedBlock[] blocks);
    private static SmallDocumentBlock[] ConvertRawBlocksToSmallBlocks(ListManagedBlock[] blocks);
    public virtual void Read(Byte[] buffer, int offset);
    public virtual void WriteBlocks(Stream stream);
    public DataInputBlock GetDataInputBlock(int offset);
    public virtual int get_CountBlocks();
    public virtual DocumentProperty get_DocumentProperty();
    public virtual bool get_PreferArray();
    public virtual string get_ShortDescription();
    public virtual int get_Size();
    public virtual SmallDocumentBlock[] get_SmallBlocks();
    public virtual int get_StartBlock();
    public virtual void set_StartBlock(int value);
    public sealed virtual Object[] get_ViewableArray();
    public virtual IEnumerator`1<object> get_ViewableIterator();
    [CompilerGeneratedAttribute]
public void add_BeforeWriting(POIFSWriterEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BeforeWriting(POIFSWriterEventHandler value);
    protected virtual void OnBeforeWriting(POIFSWriterEventArgs e);
}
public class NPOI.POIFS.FileSystem.OPOIFSFileSystem : object {
    private PropertyTable _property_table;
    private IList`1<OPOIFSDocument> _documents;
    private DirectoryNode _root;
    private POIFSBigBlockSize bigBlockSize;
    public DirectoryNode Root { get; }
    public Object[] ViewableArray { get; }
    public IEnumerator`1<object> ViewableIterator { get; }
    public bool PreferArray { get; }
    public string ShortDescription { get; }
    public int BigBlockSize { get; }
    public OPOIFSFileSystem(Stream stream);
    public static Stream CreateNonClosingInputStream(Stream stream);
    private void CloseInputStream(Stream stream, bool success);
    public static bool HasPOIFSHeader(InputStream inp);
    public static bool HasPOIFSHeader(Byte[] header8Bytes);
    public DocumentEntry CreateDocument(Stream stream, string name);
    public DocumentEntry CreateDocument(string name, int size, POIFSWriterListener writer);
    public DirectoryEntry CreateDirectory(string name);
    public DocumentInputStream CreateDocumentInputStream(string documentName);
    public void WriteFileSystem(Stream stream);
    public DirectoryNode get_Root();
    public void AddDocument(OPOIFSDocument document);
    public void AddDirectory(DirectoryProperty directory);
    public void Remove(EntryNode entry);
    private void ProcessProperties(BlockList small_blocks, BlockList big_blocks, IEnumerator properties, DirectoryNode dir, int headerPropertiesStartAt);
    public sealed virtual Object[] get_ViewableArray();
    public sealed virtual IEnumerator`1<object> get_ViewableIterator();
    public sealed virtual bool get_PreferArray();
    public sealed virtual string get_ShortDescription();
    public int get_BigBlockSize();
}
public class NPOI.POIFS.FileSystem.POIFSDocumentPath : object {
    private String[] components;
    private int hashcode;
    public int Length { get; }
    public POIFSDocumentPath Parent { get; }
    public string Name { get; }
    public POIFSDocumentPath(String[] components);
    public POIFSDocumentPath(POIFSDocumentPath path, String[] components);
    public virtual bool Equals(object o);
    public virtual string GetComponent(int n);
    public virtual int GetHashCode();
    private int ComputeHashCode();
    public virtual string ToString();
    public virtual int get_Length();
    public virtual POIFSDocumentPath get_Parent();
    public string get_Name();
}
[ObsoleteAttribute]
public class NPOI.POIFS.FileSystem.POIFSDocumentReader : Stream {
    private bool _closed;
    private int _current_offset;
    private OPOIFSDocument _document;
    private int _document_size;
    private Byte[] _tiny_buffer;
    private static int _EOD;
    private bool EOD { get; }
    public int Available { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public POIFSDocumentReader(DocumentEntry document);
    public POIFSDocumentReader(OPOIFSDocument document);
    private bool get_EOD();
    public int get_Available();
    public virtual void Close();
    private void DieIfClosed();
    public virtual void Flush();
    public int Read(Byte[] b);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public long Skip(long n);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
[ObsoleteAttribute]
public class NPOI.POIFS.FileSystem.POIFSDocumentWriter : Stream {
    private int limit;
    private Stream stream;
    private int written;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public POIFSDocumentWriter(Stream stream, int limit);
    public virtual void Close();
    public virtual void Flush();
    private void LimitCheck(int toBeWritten);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public void Write(int b);
    public void Write(Byte[] b);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void WriteByte(byte b);
    public virtual void WriteFiller(int totalLimit, byte fill);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class NPOI.POIFS.FileSystem.POIFSFileSystem : NPOIFSFileSystem {
    public POIFSFileSystem(Stream stream);
    public POIFSFileSystem(FileInfo file, bool readOnly);
    public POIFSFileSystem(FileInfo file);
    public static Stream CreateNonClosingInputStream(Stream stream);
    public static bool HasPOIFSHeader(Stream inp);
    public static bool HasPOIFSHeader(Byte[] header8Bytes);
    public static POIFSFileSystem Create(FileInfo file);
}
public class NPOI.POIFS.Macros.VBAMacroExtractor : object {
    public static void main(String[] args);
    public void Extract(FileInfo input, DirectoryInfo outputDir, string extension);
    public void Extract(FileInfo input, DirectoryInfo outputDir);
}
public class NPOI.POIFS.Macros.VBAMacroReader : object {
    protected static string VBA_PROJECT_OOXML;
    protected static string VBA_PROJECT_POIFS;
    private NPOIFSFileSystem fs;
    private static int EOF;
    private static int VERSION_INDEPENDENT_TERMINATOR;
    private static int VERSION_DEPENDENT_TERMINATOR;
    private static int PROJECTVERSION;
    private static int PROJECTCODEPAGE;
    private static int STREAMNAME;
    private static int MODULEOFFSET;
    private static int MODULETYPE_PROCEDURAL;
    private static int MODULETYPE_DOCUMENT_CLASS_OR_DESIGNER;
    private static int PROJECTLCID;
    private static int MODULE_NAME;
    private static int MODULE_NAME_UNICODE;
    private static int MODULE_DOC_STRING;
    private static int STREAMNAME_RESERVED;
    public VBAMacroReader(InputStream rstream);
    public VBAMacroReader(FileInfo file);
    public VBAMacroReader(NPOIFSFileSystem fs);
    private static VBAMacroReader();
    private void OpenOOXML(Stream zipFile);
    public sealed virtual void Close();
    public Dictionary`2<string, string> ReadMacros();
    protected void FindMacros(DirectoryNode dir, ModuleMap modules);
    private static string ReadString(InputStream stream, int length, Encoding charset);
    private static void ReadModule(RLEDecompressingInputStream in1, string streamName, ModuleMap modules);
    private static void ReadModule(DocumentInputStream dis, string name, ModuleMap modules);
    private static void TrySkip(InputStream in1, long n);
    protected void ReadMacros(DirectoryNode macroDir, ModuleMap modules);
    private string ReadUnicodeString(RLEDecompressingInputStream in1, int unicodeNameRecordLength);
}
public class NPOI.POIFS.NIO.ByteArrayBackedDataSource : DataSource {
    private Byte[] buffer;
    private long size;
    public long Size { get; }
    public ByteArrayBackedDataSource(Byte[] data, int size);
    public ByteArrayBackedDataSource(Byte[] data);
    public virtual ByteBuffer Read(int length, long position);
    public virtual void Write(ByteBuffer src, long position);
    private void Extend(long length);
    public virtual void CopyTo(Stream stream);
    public virtual long get_Size();
    public virtual void Close();
}
public abstract class NPOI.POIFS.NIO.DataSource : object {
    public long Size { get; }
    public abstract virtual ByteBuffer Read(int length, long position);
    public abstract virtual void Write(ByteBuffer src, long position);
    public abstract virtual long get_Size();
    public abstract virtual void Close();
    public abstract virtual void CopyTo(Stream stream);
}
public class NPOI.POIFS.NIO.FileBackedDataSource : DataSource {
    private MemoryStream fileStream;
    private FileInfo fileinfo;
    private bool writable;
    private List`1<ByteBuffer> buffersToClean;
    public bool IsWriteable { get; }
    public Stream Stream { get; }
    public long Size { get; }
    public FileBackedDataSource(FileInfo file);
    public FileBackedDataSource(FileInfo file, bool readOnly);
    public FileBackedDataSource(FileStream stream, bool readOnly);
    public void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public bool get_IsWriteable();
    public Stream get_Stream();
    public virtual ByteBuffer Read(int length, long position);
    public virtual void Write(ByteBuffer src, long position);
    public virtual void CopyTo(Stream stream);
    public virtual long get_Size();
    public virtual void Close();
    private static void unmap(ByteBuffer bb);
}
public interface NPOI.POIFS.Properties.Child {
    public Child PreviousChild { get; public set; }
    public Child NextChild { get; public set; }
    public abstract virtual Child get_PreviousChild();
    public abstract virtual void set_PreviousChild(Child value);
    public abstract virtual Child get_NextChild();
    public abstract virtual void set_NextChild(Child value);
}
public class NPOI.POIFS.Properties.DirectoryProperty : Property {
    private List`1<Property> _children;
    private List`1<string> _children_names;
    public bool IsDirectory { get; }
    public IEnumerator`1<Property> Children { get; }
    public DirectoryProperty(string name);
    public DirectoryProperty(int index, Byte[] array, int offset);
    public bool ChangeName(Property property, string newName);
    public bool DeleteChild(Property property);
    public virtual bool get_IsDirectory();
    public virtual void PreWrite();
    public sealed virtual IEnumerator`1<Property> get_Children();
    public sealed virtual void AddChild(Property property);
    public sealed virtual IEnumerator`1<Property> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NPOI.POIFS.Properties.DocumentProperty : Property {
    private OPOIFSDocument _document;
    public OPOIFSDocument Document { get; public set; }
    public bool IsDirectory { get; }
    public DocumentProperty(string name, int size);
    public DocumentProperty(int index, Byte[] array, int offset);
    public void set_Document(OPOIFSDocument value);
    public OPOIFSDocument get_Document();
    public virtual bool get_IsDirectory();
    public virtual void PreWrite();
    public void UpdateSize(int size);
}
public class NPOI.POIFS.Properties.NPropertyTable : PropertyTableBase {
    private POIFSBigBlockSize _bigBigBlockSize;
    public int CountBlocks { get; }
    public NPropertyTable(HeaderBlock headerBlock);
    public NPropertyTable(HeaderBlock headerBlock, NPOIFSFileSystem fileSystem);
    private static List`1<Property> BuildProperties(IEnumerator`1<ByteBuffer> dataSource, POIFSBigBlockSize bigBlockSize);
    public virtual int get_CountBlocks();
    public void PreWrite();
    public void Write(NPOIFSStream stream);
}
public interface NPOI.POIFS.Properties.Parent {
    public IEnumerator`1<Property> Children { get; }
    public Child PreviousChild { get; public set; }
    public Child NextChild { get; public set; }
    public abstract virtual IEnumerator`1<Property> get_Children();
    public abstract virtual void AddChild(Property property);
    public abstract virtual Child get_PreviousChild();
    public abstract virtual void set_PreviousChild(Child value);
    public abstract virtual Child get_NextChild();
    public abstract virtual void set_NextChild(Child value);
}
public abstract class NPOI.POIFS.Properties.Property : object {
    private static byte _default_fill;
    private static int _name_size_offset;
    private static int _max_name_length;
    protected static int _NO_INDEX;
    private static int _node_color_offset;
    private static int _previous_property_offset;
    private static int _next_property_offset;
    private static int _child_property_offset;
    private static int _storage_clsid_offset;
    private static int _user_flags_offset;
    private static int _seconds_1_offset;
    private static int _days_1_offset;
    private static int _seconds_2_offset;
    private static int _days_2_offset;
    private static int _start_block_offset;
    private static int _size_offset;
    protected static byte _NODE_BLACK;
    protected static byte _NODE_RED;
    private static int _big_block_minimum_bytes;
    private string _name;
    private ShortField _name_size;
    private ByteField _property_type;
    private ByteField _node_color;
    private IntegerField _previous_property;
    private IntegerField _next_property;
    private IntegerField _child_property;
    private ClassID _storage_clsid;
    private IntegerField _user_flags;
    private IntegerField _seconds_1;
    private IntegerField _days_1;
    private IntegerField _seconds_2;
    private IntegerField _days_2;
    private IntegerField _start_block;
    private IntegerField _size;
    private Byte[] _raw_data;
    private int _index;
    private Child _next_child;
    private Child _previous_child;
    public int StartBlock { get; public set; }
    public bool ShouldUseSmallBlocks { get; }
    public string Name { get; public set; }
    public bool IsDirectory { get; }
    public ClassID StorageClsid { get; public set; }
    unknown byte PropertyType {public set; }
    unknown byte NodeColor {public set; }
    unknown int ChildProperty {public set; }
    public int ChildIndex { get; }
    public int Size { get; public set; }
    public int Index { get; public set; }
    public int NextChildIndex { get; }
    public int PreviousChildIndex { get; }
    public Child PreviousChild { get; public set; }
    public Child NextChild { get; public set; }
    public Object[] ViewableArray { get; }
    public IEnumerator`1<object> ViewableIterator { get; }
    public bool PreferArray { get; }
    public string ShortDescription { get; }
    protected Property(int index, Byte[] array, int offset);
    public void WriteData(Stream stream);
    public void set_StartBlock(int value);
    public int get_StartBlock();
    public bool get_ShouldUseSmallBlocks();
    public static bool IsSmall(int length);
    public string get_Name();
    public void set_Name(string value);
    public virtual bool get_IsDirectory();
    public ClassID get_StorageClsid();
    public void set_StorageClsid(ClassID value);
    public void set_PropertyType(byte value);
    public void set_NodeColor(byte value);
    public void set_ChildProperty(int value);
    public int get_ChildIndex();
    public virtual void set_Size(int value);
    public virtual int get_Size();
    public int get_Index();
    public void set_Index(int value);
    public abstract virtual void PreWrite();
    public int get_NextChildIndex();
    public int get_PreviousChildIndex();
    public static bool IsValidIndex(int index);
    public sealed virtual void set_PreviousChild(Child value);
    public sealed virtual Child get_PreviousChild();
    public sealed virtual void set_NextChild(Child value);
    public sealed virtual Child get_NextChild();
    public sealed virtual Object[] get_ViewableArray();
    public sealed virtual IEnumerator`1<object> get_ViewableIterator();
    public sealed virtual bool get_PreferArray();
    public sealed virtual string get_ShortDescription();
}
public class NPOI.POIFS.Properties.PropertyConstants : object {
    public static int PROPERTY_TYPE_OFFSET;
    public static byte INVALID_TYPE;
    public static byte DIRECTORY_TYPE;
    public static byte DOCUMENT_TYPE;
    public static byte LOCKBYTES_TYPE;
    public static byte PROPERT_TYPE;
    public static byte ROOT_TYPE;
}
public class NPOI.POIFS.Properties.PropertyFactory : object {
    public static List`1<Property> ConvertToProperties(ListManagedBlock[] blocks);
    public static void ConvertToProperties(Byte[] data, List`1<Property> properties);
}
public class NPOI.POIFS.Properties.PropertyTable : PropertyTableBase {
    private POIFSBigBlockSize _bigBigBlockSize;
    private BlockWritable[] _blocks;
    public int CountBlocks { get; }
    public PropertyTable(HeaderBlock headerBlock);
    public PropertyTable(HeaderBlock headerBlock, RawDataBlockList blockList);
    public void PreWrite();
    public virtual int get_CountBlocks();
    public sealed virtual void WriteBlocks(Stream stream);
}
public abstract class NPOI.POIFS.Properties.PropertyTableBase : object {
    protected HeaderBlock _header_block;
    protected List`1<Property> _properties;
    public RootProperty Root { get; }
    public int StartBlock { get; public set; }
    public int CountBlocks { get; }
    public PropertyTableBase(HeaderBlock header_block);
    public PropertyTableBase(HeaderBlock header_block, List`1<Property> properties);
    public void AddProperty(Property property);
    public void RemoveProperty(Property property);
    public RootProperty get_Root();
    protected void PopulatePropertyTree(DirectoryProperty root);
    public virtual int get_StartBlock();
    public virtual void set_StartBlock(int value);
    public virtual int get_CountBlocks();
}
public class NPOI.POIFS.Properties.RootProperty : DirectoryProperty {
    private static string NAME;
    unknown int Size {public set; }
    public RootProperty(int index, Byte[] array, int offset);
    public virtual void set_Size(int value);
}
public class NPOI.POIFS.Storage.BATBlock : BigBlock {
    private static int _entries_per_block;
    private static int _entries_per_xbat_block;
    private static int _xbat_chain_offset;
    private static byte _default_value;
    private IntegerField[] _fields;
    private Byte[] _data;
    private Int32[] _values;
    private bool _has_free_sectors;
    private int ourBlockIndex;
    public static int EntriesPerBlock { get; }
    public static int EntriesPerXBATBlock { get; }
    public static int XBATChainOffset { get; }
    public bool HasFreeSectors { get; }
    public int OurBlockIndex { get; public set; }
    protected BATBlock(POIFSBigBlockSize bigBlockSize);
    protected BATBlock(POIFSBigBlockSize bigBlockSize, Int32[] entries, int start_index, int end_index);
    private BATBlock(Int32[] entries, int start_index, int end_index);
    private static BATBlock();
    private void RecomputeFree();
    public static BATBlock CreateBATBlock(POIFSBigBlockSize bigBlockSize, BinaryReader data);
    public static BATBlock CreateBATBlock(POIFSBigBlockSize bigBlockSize, ByteBuffer data);
    public static BATBlock CreateEmptyBATBlock(POIFSBigBlockSize bigBlockSize, bool isXBAT);
    public static BATBlock[] CreateBATBlocks(POIFSBigBlockSize bigBlockSize, Int32[] entries);
    public static BATBlock[] CreateXBATBlocks(POIFSBigBlockSize bigBlockSize, Int32[] entries, int startBlock);
    public static int CalculateStorageRequirements(int entryCount);
    public static int CalculateStorageRequirements(POIFSBigBlockSize bigBlockSize, int entryCount);
    public static int CalculateXBATStorageRequirements(int entryCount);
    public static int CalculateXBATStorageRequirements(POIFSBigBlockSize bigBlockSize, int entryCount);
    public static long CalculateMaximumSize(POIFSBigBlockSize bigBlockSize, int numBATs);
    public static long CalculateMaximumSize(HeaderBlock header);
    public static BATBlockAndIndex GetBATBlockAndIndex(int offset, HeaderBlock header, List`1<BATBlock> bats);
    public static BATBlockAndIndex GetSBATBlockAndIndex(int offset, HeaderBlock header, List`1<BATBlock> sbats);
    public static int get_EntriesPerBlock();
    public static int get_EntriesPerXBATBlock();
    public static int get_XBATChainOffset();
    private void SetXBATChain(int chainIndex);
    private void SetXBATChain(POIFSBigBlockSize bigBlockSize, int chainIndex);
    public bool get_HasFreeSectors();
    public int GetUsedSectors(bool isAnXBAT);
    public int GetValueAt(int relativeOffset);
    public void SetValueAt(int relativeOffset, int value);
    public int get_OurBlockIndex();
    public void set_OurBlockIndex(int value);
    public void WriteData(ByteBuffer block);
    public virtual void WriteData(Stream stream);
    public void WriteData(Byte[] block);
    private Byte[] Serialize();
}
public class NPOI.POIFS.Storage.BATBlockAndIndex : object {
    private int index;
    private BATBlock block;
    public int Index { get; }
    public BATBlock Block { get; }
    public BATBlockAndIndex(int index, BATBlock block);
    public int get_Index();
    public BATBlock get_Block();
}
public abstract class NPOI.POIFS.Storage.BigBlock : object {
    protected POIFSBigBlockSize bigBlockSize;
    protected BigBlock(POIFSBigBlockSize bigBlockSize);
    protected void WriteData(Stream stream, Byte[] data);
    public sealed virtual void WriteBlocks(Stream stream);
    public abstract virtual void WriteData(Stream stream);
}
public class NPOI.POIFS.Storage.BlockAllocationTableReader : object {
    private static POILogger _logger;
    private static int MAX_BLOCK_COUNT;
    private List`1<int> _entries;
    private POIFSBigBlockSize bigBlockSize;
    public BlockAllocationTableReader(POIFSBigBlockSize bigBlockSizse, int block_count, Int32[] block_array, int xbat_count, int xbat_index, BlockList raw_block_list);
    public BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks, BlockList raw_block_list);
    public BlockAllocationTableReader(POIFSBigBlockSize bigBlockSize);
    private static BlockAllocationTableReader();
    public ListManagedBlock[] FetchBlocks(int startBlock, int headerPropertiesStartBlock, BlockList blockList);
    public bool IsUsed(int index);
    public int GetNextBlockIndex(int index);
    private void SetEntries(ListManagedBlock[] blocks, BlockList raw_blocks);
    public static void SanityCheckBlockCount(int block_count);
}
public class NPOI.POIFS.Storage.BlockAllocationTableWriter : object {
    private List`1<int> _entries;
    private BATBlock[] _blocks;
    private int _start_block;
    private POIFSBigBlockSize _bigBlockSize;
    private static int _default_size;
    public int StartBlock { get; public set; }
    public int CountBlocks { get; }
    public BlockAllocationTableWriter(POIFSBigBlockSize bigBlockSize);
    private static BlockAllocationTableWriter();
    public int CreateBlocks();
    public int AllocateSpace(int blockCount);
    public int get_StartBlock();
    public sealed virtual void set_StartBlock(int value);
    internal void SimpleCreateBlocks();
    public sealed virtual void WriteBlocks(Stream stream);
    public static void WriteBlock(BATBlock bat, ByteBuffer block);
    public sealed virtual int get_CountBlocks();
}
public interface NPOI.POIFS.Storage.BlockList {
    unknown BlockAllocationTableReader BAT {public set; }
    public abstract virtual void Zap(int index);
    public abstract virtual ListManagedBlock Remove(int index);
    public abstract virtual ListManagedBlock[] FetchBlocks(int startBlock, int headerPropertiesStartBlock);
    public abstract virtual void set_BAT(BlockAllocationTableReader value);
    public abstract virtual int BlockCount();
}
public class NPOI.POIFS.Storage.BlockListImpl : object {
    private ListManagedBlock[] _blocks;
    private BlockAllocationTableReader _bat;
    unknown BlockAllocationTableReader BAT {public set; }
    public virtual void SetBlocks(ListManagedBlock[] blocks);
    public virtual void Zap(int index);
    protected ListManagedBlock Get(int index);
    public virtual ListManagedBlock Remove(int index);
    public virtual ListManagedBlock[] FetchBlocks(int startBlock, int headerPropertiesStartBlock);
    public virtual void set_BAT(BlockAllocationTableReader value);
    public virtual int BlockCount();
    protected int RemainingBlocks();
}
public interface NPOI.POIFS.Storage.BlockWritable {
    public abstract virtual void WriteBlocks(Stream stream);
}
public class NPOI.POIFS.Storage.DataInputBlock : object {
    private Byte[] _buf;
    private int _readIndex;
    private int _maxIndex;
    internal DataInputBlock(Byte[] data, int startOffset);
    public int Available();
    public int ReadUByte();
    public int ReadUshortLE();
    public int ReadUshortLE(DataInputBlock prevBlock);
    public int ReadIntLE();
    public int ReadIntLE(DataInputBlock prevBlock, int prevBlockAvailable);
    public long ReadLongLE();
    public long ReadLongLE(DataInputBlock prevBlock, int prevBlockAvailable);
    private void ReadSpanning(DataInputBlock prevBlock, int prevBlockAvailable, Byte[] buf);
    public void ReadFully(Byte[] buf, int off, int len);
}
public class NPOI.POIFS.Storage.DocumentBlock : BigBlock {
    private static byte _default_value;
    private Byte[] _data;
    private int _bytes_Read;
    public int Size { get; }
    public bool PartiallyRead { get; }
    public static byte FillByte { get; }
    public DocumentBlock(RawDataBlock block);
    public DocumentBlock(Stream stream, POIFSBigBlockSize bigBlockSize);
    public DocumentBlock(POIFSBigBlockSize bigBlockSize);
    private static DocumentBlock();
    public int get_Size();
    public bool get_PartiallyRead();
    public static byte get_FillByte();
    public static DocumentBlock[] Convert(POIFSBigBlockSize bigBlockSize, Byte[] array, int size);
    public static void Read(DocumentBlock[] blocks, Byte[] buffer, int offset);
    public static DataInputBlock GetDataInputBlock(DocumentBlock[] blocks, int offset);
    public virtual void WriteData(Stream stream);
}
public class NPOI.POIFS.Storage.HeaderBlock : HeaderBlockConstants {
    private static Byte[] MAGIC_BIFF2;
    private static Byte[] MAGIC_BIFF3;
    private static Byte[] MAGIC_BIFF4a;
    private static Byte[] MAGIC_BIFF4b;
    private static byte _default_value;
    private POIFSBigBlockSize bigBlockSize;
    private int _bat_count;
    private int _property_start;
    private int _sbat_start;
    private int _sbat_count;
    private int _xbat_start;
    private int _xbat_count;
    private Byte[] _data;
    public int PropertyStart { get; public set; }
    public int SBATStart { get; public set; }
    public int SBATCount { get; public set; }
    public int SBATBlockCount { get; public set; }
    public int BATCount { get; public set; }
    public Int32[] BATArray { get; public set; }
    public int XBATCount { get; public set; }
    public int XBATIndex { get; public set; }
    unknown int XBATStart {public set; }
    public POIFSBigBlockSize BigBlockSize { get; }
    public HeaderBlock(Stream stream);
    public HeaderBlock(ByteBuffer buffer);
    public HeaderBlock(Byte[] buffer);
    public HeaderBlock(POIFSBigBlockSize bigBlockSize);
    private static HeaderBlock();
    public void PrivateHeaderBlock(Byte[] data);
    private static Byte[] ReadFirst512(Stream stream);
    private static IOException AlertShortRead(int read, int expectedReadSize);
    public int get_PropertyStart();
    public void set_PropertyStart(int value);
    public int get_SBATStart();
    public void set_SBATStart(int value);
    public int get_SBATCount();
    public void set_SBATCount(int value);
    public int get_SBATBlockCount();
    public void set_SBATBlockCount(int value);
    public int get_BATCount();
    public void set_BATCount(int value);
    public Int32[] get_BATArray();
    public void set_BATArray(Int32[] value);
    public int get_XBATCount();
    public void set_XBATCount(int value);
    public int get_XBATIndex();
    public void set_XBATIndex(int value);
    public void set_XBATStart(int value);
    public POIFSBigBlockSize get_BigBlockSize();
    public void WriteData(Stream stream);
    private static bool cmp(Byte[] magic, Byte[] data);
}
public class NPOI.POIFS.Storage.HeaderBlockConstants : object {
    public static long _signature;
    public static int _bat_array_offset;
    public static int _max_bats_in_header;
    public static int _signature_offset;
    public static int _bat_count_offset;
    public static int _property_start_offset;
    public static int _sbat_start_offset;
    public static int _sbat_block_count_offset;
    public static int _xbat_start_offset;
    public static int _xbat_count_offset;
}
public class NPOI.POIFS.Storage.HeaderBlockReader : object {
    private POIFSBigBlockSize bigBlockSize;
    private int _bat_count;
    private int _property_start;
    private int _sbat_start;
    private int _sbat_count;
    private int _xbat_start;
    private int _xbat_count;
    private Byte[] _data;
    public int PropertyStart { get; }
    public int SBATStart { get; }
    public int BATCount { get; }
    public Int32[] BATArray { get; }
    public int XBATCount { get; }
    public int XBATIndex { get; }
    public POIFSBigBlockSize BigBlockSize { get; }
    public HeaderBlockReader(Stream stream);
    private Byte[] ReadFirst512(Stream stream);
    private static string LongToHex(long value);
    private void AlertShortRead(int read, int expectedReadSize);
    public int get_PropertyStart();
    public int get_SBATStart();
    public int get_BATCount();
    public Int32[] get_BATArray();
    public int get_XBATCount();
    public int get_XBATIndex();
    public POIFSBigBlockSize get_BigBlockSize();
}
public class NPOI.POIFS.Storage.HeaderBlockWriter : HeaderBlockConstants {
    private HeaderBlock _header_block;
    public int PropertyStart { get; public set; }
    public int SBAStart { get; public set; }
    public int SBATStart { get; public set; }
    public int SBATBlockCount { get; public set; }
    public HeaderBlockWriter(POIFSBigBlockSize bigBlockSize);
    public HeaderBlockWriter(HeaderBlock headerBlock);
    public BATBlock[] SetBATBlocks(int blockCount, int startBlock);
    public int get_PropertyStart();
    public void set_PropertyStart(int value);
    public int get_SBAStart();
    public void set_SBAStart(int value);
    public int get_SBATStart();
    public void set_SBATStart(int value);
    public int get_SBATBlockCount();
    public void set_SBATBlockCount(int value);
    public static int CalculateXBATStorageRequirements(POIFSBigBlockSize bigBlockSize, int blockCount);
    public sealed virtual void WriteBlocks(Stream stream);
    public void WriteBlock(ByteBuffer block);
    public void WriteBlock(Byte[] block);
}
public interface NPOI.POIFS.Storage.ListManagedBlock {
    public Byte[] Data { get; }
    public abstract virtual Byte[] get_Data();
}
public class NPOI.POIFS.Storage.PropertyBlock : BigBlock {
    private Property[] _properties;
    protected PropertyBlock(POIFSBigBlockSize bigBlockSize, Property[] properties, int offset);
    public static BlockWritable[] CreatePropertyBlockArray(POIFSBigBlockSize bigBlockSize, List`1<Property> properties);
    public virtual void WriteData(Stream stream);
}
public class NPOI.POIFS.Storage.RawDataBlock : object {
    private Byte[] _data;
    private bool _eof;
    private bool _hasData;
    private static POILogger log;
    public bool EOF { get; }
    public bool HasData { get; }
    public Byte[] Data { get; }
    public int BigBlockSize { get; }
    public RawDataBlock(Stream stream);
    public RawDataBlock(Stream stream, int blockSize);
    private static RawDataBlock();
    public bool get_EOF();
    public bool get_HasData();
    public sealed virtual Byte[] get_Data();
    public virtual string ToString();
    public int get_BigBlockSize();
}
public class NPOI.POIFS.Storage.RawDataBlockList : BlockListImpl {
    public RawDataBlockList(Stream stream, POIFSBigBlockSize bigBlockSize);
}
public class NPOI.POIFS.Storage.SmallBlockTableReader : object {
    private static BlockList prepareSmallDocumentBlocks(POIFSBigBlockSize bigBlockSize, RawDataBlockList blockList, RootProperty root, int sbatStart);
    private static BlockAllocationTableReader prepareReader(POIFSBigBlockSize bigBlockSize, RawDataBlockList blockList, BlockList list, RootProperty root, int sbatStart);
    public static BlockAllocationTableReader _getSmallDocumentBlockReader(POIFSBigBlockSize bigBlockSize, RawDataBlockList blockList, RootProperty root, int sbatStart);
    public static BlockList GetSmallDocumentBlocks(POIFSBigBlockSize bigBlockSize, RawDataBlockList blockList, RootProperty root, int sbatStart);
}
public class NPOI.POIFS.Storage.SmallBlockTableWriter : object {
    private BlockAllocationTableWriter _sbat;
    private IList`1<SmallDocumentBlock> _small_blocks;
    private int _big_block_count;
    private RootProperty _root;
    public int SBATBlockCount { get; }
    public BlockAllocationTableWriter SBAT { get; }
    public int CountBlocks { get; }
    unknown int StartBlock {public set; }
    public SmallBlockTableWriter(POIFSBigBlockSize bigBlockSize, IList`1<OPOIFSDocument> documents, RootProperty root);
    public int get_SBATBlockCount();
    public BlockAllocationTableWriter get_SBAT();
    public sealed virtual int get_CountBlocks();
    public sealed virtual void set_StartBlock(int value);
    public sealed virtual void WriteBlocks(Stream stream);
}
public class NPOI.POIFS.Storage.SmallDocumentBlock : object {
    private static int BLOCK_SHIFT;
    private Byte[] _data;
    private static byte _default_fill;
    private static int _block_size;
    private static int BLOCK_MASK;
    private static int _blocks_per_big_block;
    private POIFSBigBlockSize _bigBlockSize;
    protected int SmallBlocksPerBigBlock { get; }
    public Byte[] Data { get; }
    public POIFSBigBlockSize BigBlockSize { get; }
    public SmallDocumentBlock(POIFSBigBlockSize bigBlockSize, Byte[] data, int index);
    public SmallDocumentBlock(POIFSBigBlockSize bigBlockSize);
    private static SmallDocumentBlock();
    private static int GetBlocksPerBigBlock(POIFSBigBlockSize bigBlockSize);
    public static SmallDocumentBlock[] Convert(POIFSBigBlockSize bigBlockSize, Byte[] array, int size);
    public static int Fill(POIFSBigBlockSize bigBlockSize, IList`1<SmallDocumentBlock> blocks);
    public static SmallDocumentBlock[] Convert(POIFSBigBlockSize bigBlocksSize, BlockWritable[] store, int size);
    public static List`1<SmallDocumentBlock> Extract(POIFSBigBlockSize bigBlockSize, ListManagedBlock[] blocks);
    public static void Read(BlockWritable[] blocks, Byte[] buffer, int offset);
    public static DataInputBlock GetDataInputBlock(SmallDocumentBlock[] blocks, int offset);
    public static int CalcSize(int size);
    protected int get_SmallBlocksPerBigBlock();
    private static SmallDocumentBlock MakeEmptySmallDocumentBlock(POIFSBigBlockSize bigBlockSize);
    private static int ConvertToBlockCount(int size);
    public sealed virtual void WriteBlocks(Stream stream);
    public sealed virtual Byte[] get_Data();
    public POIFSBigBlockSize get_BigBlockSize();
}
public class NPOI.POIFS.Storage.SmallDocumentBlockList : BlockListImpl {
    public SmallDocumentBlockList(List`1<SmallDocumentBlock> blocks);
}
public abstract class NPOI.POIOLE2TextExtractor : POITextExtractor {
    protected POIDocument document;
    public DocumentSummaryInformation DocSummaryInformation { get; }
    public SummaryInformation SummaryInformation { get; }
    public POITextExtractor MetadataTextExtractor { get; }
    public DirectoryEntry Root { get; }
    public POIOLE2TextExtractor(POIDocument document);
    protected POIOLE2TextExtractor(POIOLE2TextExtractor otherExtractor);
    public virtual DocumentSummaryInformation get_DocSummaryInformation();
    public virtual SummaryInformation get_SummaryInformation();
    public virtual POITextExtractor get_MetadataTextExtractor();
    public DirectoryEntry get_Root();
}
public abstract class NPOI.POITextExtractor : object {
    private ICloseable fsToClose;
    public string Text { get; }
    public POITextExtractor MetadataTextExtractor { get; }
    public abstract virtual string get_Text();
    public abstract virtual POITextExtractor get_MetadataTextExtractor();
    public void SetFilesystem(ICloseable fs);
    public virtual void Close();
}
public interface NPOI.SS.Extractor.IExcelExtractor {
    public bool IncludeCellComments { get; public set; }
    public bool IncludeSheetNames { get; public set; }
    public bool FormulasNotResults { get; public set; }
    public bool IncludeHeaderFooter { get; public set; }
    public string Text { get; }
    public abstract virtual bool get_IncludeCellComments();
    public abstract virtual void set_IncludeCellComments(bool value);
    public abstract virtual bool get_IncludeSheetNames();
    public abstract virtual void set_IncludeSheetNames(bool value);
    public abstract virtual bool get_FormulasNotResults();
    public abstract virtual void set_FormulasNotResults(bool value);
    public abstract virtual bool get_IncludeHeaderFooter();
    public abstract virtual void set_IncludeHeaderFooter(bool value);
    public abstract virtual string get_Text();
}
public class NPOI.SS.Format.CellDateFormatter : CellFormatter {
    private bool amPmUpper;
    private bool ShowM;
    private bool ShowAmPm;
    private FormatBase dateFmt;
    private string sFmt;
    private int millisecondPartLength;
    private static TimeSpan EXCEL_EPOCH_TIME;
    private static DateTime EXCEL_EPOCH_DATE;
    private static CellFormatter SIMPLE_DATE;
    private static CellDateFormatter();
    public CellDateFormatter(string format);
    public virtual void FormatValue(StringBuilder toAppendTo, object value);
    public virtual void SimpleValue(StringBuilder toAppendTo, object value);
}
public class NPOI.SS.Format.CellElapsedFormatter : CellFormatter {
    private List`1<TimeSpec> specs;
    private TimeSpec topmost;
    private string printfFmt;
    private static Regex PERCENTS;
    private static double HOUR__FACTOR;
    private static double MIN__FACTOR;
    private static double SEC__FACTOR;
    public CellElapsedFormatter(string pattern);
    private static CellElapsedFormatter();
    private TimeSpec AssignSpec(char type, int pos, int len);
    private static double factorFor(char type, int len);
    private static double modFor(char type, int len);
    public virtual void FormatValue(StringBuilder toAppendTo, object value);
    public virtual void SimpleValue(StringBuilder toAppendTo, object value);
}
public class NPOI.SS.Format.CellFormat : object {
    private string format;
    private CellFormatPart posNumFmt;
    private CellFormatPart zeroNumFmt;
    private CellFormatPart negNumFmt;
    private CellFormatPart textFmt;
    private int formatPartCount;
    private static Regex ONE_PART;
    private static CellFormatPart DEFAULT_TEXT_FORMAT;
    private static string INVALID_VALUE_FOR_FORMAT;
    private static string QUOTE;
    private static CellFormat GENERAL_FORMAT;
    private static Dictionary`2<string, CellFormat> formatCache;
    private CellFormat(string format);
    private static CellFormat();
    public static CellFormat GetInstance(string format);
    public virtual CellFormatResult Apply(object value);
    private CellFormatResult Apply(DateTime date, double numericValue);
    public CellFormatResult Apply(ICell c);
    private CellFormatPart GetApplicableFormatPart(object value);
    public static CellType UltimateType(ICell cell);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class NPOI.SS.Format.CellFormatCondition : object {
    private static int LT;
    private static int LE;
    private static int GT;
    private static int GE;
    private static int EQ;
    private static int NE;
    private static Dictionary`2<string, int> TESTS;
    private static CellFormatCondition();
    public static CellFormatCondition GetInstance(string opString, string constStr);
    public abstract virtual bool Pass(double value);
}
public class NPOI.SS.Format.CellFormatPart : object {
    private Color color;
    private CellFormatCondition condition;
    private CellFormatter format;
    private CellFormatType type;
    private static Dictionary`2<string, Color> NAMED_COLORS;
    public static IEqualityComparer`1<string> CASE_INSENSITIVE_ORDER;
    public static Regex COLOR_PAT;
    public static Regex CONDITION_PAT;
    public static Regex SPECIFICATION_PAT;
    public static Regex CURRENCY_PAT;
    public static Regex FORMAT_PAT;
    public static int COLOR_GROUP;
    public static int CONDITION_OPERATOR_GROUP;
    public static int CONDITION_VALUE_GROUP;
    public static int SPECIFICATION_GROUP;
    internal CellFormatType CellFormatType { get; }
    internal bool HasCondition { get; }
    private static CellFormatPart();
    public CellFormatPart(string desc);
    public bool Applies(object valueObject);
    private static int FindGroup(Regex pat, string str, string marker);
    private static Color GetColor(Match m);
    private CellFormatCondition GetCondition(Match m);
    private CellFormatType GetCellFormatType(Match matcher);
    private CellFormatter GetFormatter(Match matcher);
    private CellFormatType formatType(string fdesc);
    private static string QuoteSpecial(string repl, CellFormatType type);
    public CellFormatResult Apply(object value);
    internal CellFormatType get_CellFormatType();
    internal bool get_HasCondition();
    public static StringBuilder ParseFormat(string fdesc, CellFormatType type, IPartHandler partHandler);
    public static string QuoteReplacement(string s);
    internal static string ExpandChar(string part);
    public static string Group(Match m, int g);
    public virtual string ToString();
}
public class NPOI.SS.Format.CellFormatResult : object {
    private bool _applies;
    private string _text;
    private Color _textcolor;
    public bool Applies { get; public set; }
    public string Text { get; public set; }
    public Rgb24 TextColor { get; public set; }
    public CellFormatResult(bool applies, string text, Rgb24 textColor);
    public bool get_Applies();
    public void set_Applies(bool value);
    public string get_Text();
    public void set_Text(string value);
    public Rgb24 get_TextColor();
    public void set_TextColor(Rgb24 value);
}
public abstract class NPOI.SS.Format.CellFormatter : object {
    protected string format;
    public static CultureInfo LOCALE;
    public CellFormatter(string format);
    private static CellFormatter();
    public abstract virtual void FormatValue(StringBuilder toAppendTo, object value);
    public abstract virtual void SimpleValue(StringBuilder toAppendTo, object value);
    public string Format(object value);
    public string SimpleFormat(object value);
    private static string Quote(string str);
    public virtual string ToString();
}
public abstract class NPOI.SS.Format.CellFormatType : object {
    public static CellFormatType GENERAL;
    public static CellFormatType NUMBER;
    public static CellFormatType DATE;
    public static CellFormatType ELAPSED;
    public static CellFormatType TEXT;
    private static CellFormatType();
    public abstract virtual bool IsSpecial(char ch);
    public abstract virtual CellFormatter Formatter(string pattern);
}
public class NPOI.SS.Format.CellGeneralFormatter : CellFormatter {
    public virtual void FormatValue(StringBuilder toAppendTo, object value);
    public virtual void SimpleValue(StringBuilder toAppendTo, object value);
}
public class NPOI.SS.Format.CellNumberFormatter : CellFormatter {
    private string desc;
    private string printfFmt;
    private double scale;
    private Special decimalPoint;
    private Special slash;
    private Special exponent;
    private Special numerator;
    private Special afterInteger;
    private Special afterFractional;
    private bool integerCommas;
    private List`1<Special> specials;
    private List`1<Special> integerSpecials;
    private List`1<Special> fractionalSpecials;
    private List`1<Special> numeratorSpecials;
    private List`1<Special> denominatorSpecials;
    private List`1<Special> exponentSpecials;
    private List`1<Special> exponentDigitSpecials;
    private int maxDenominator;
    private string numeratorFmt;
    private string denominatorFmt;
    private bool improperFraction;
    private DecimalFormat decimalFmt;
    private static List`1<Special> EmptySpecialList;
    private static CellFormatter SIMPLE_NUMBER;
    private static CellFormatter SIMPLE_INT;
    private static CellFormatter SIMPLE_FLOAT;
    public CellNumberFormatter(string format);
    private static CellNumberFormatter();
    private static void placeZeros(StringBuilder sb, List`1<Special> specials);
    private static Special firstDigit(List`1<Special> specials);
    private static CellNumberStringMod insertMod(Special special, string toAdd, int where);
    private static CellNumberStringMod deleteMod(Special start, bool startInclusive, Special end, bool endInclusive);
    private static CellNumberStringMod ReplaceMod(Special start, bool startInclusive, Special end, bool endInclusive, char withChar);
    private static string SingleNumberFormat(List`1<Special> numSpecials);
    private static int maxValue(List`1<Special> s);
    private List`1<Special> specialsFor(int pos, int takeFirst);
    private List`1<Special> specialsFor(int pos);
    private static bool IsDigitFmt(Special s);
    private int calculateintPartWidth();
    private static int interpretPrecision(Special decimalPoint, List`1<Special> specials);
    private static bool interpretIntegerCommas(StringBuilder sb, List`1<Special> specials, Special decimalPoint, int integerEnd, int fractionalEnd, Double[] scale);
    private int integerEnd();
    private int fractionalEnd();
    public virtual void FormatValue(StringBuilder toAppendTo, object valueObject);
    private void WriteScientific(double value, StringBuilder output, SortedList`2<CellNumberStringMod, object> mods);
    private void WriteFraction(double value, StringBuilder result, double fractional, StringBuilder output, SortedList`2<CellNumberStringMod, object> mods);
    private static bool HasChar(char ch, List`1[] numSpecials);
    private void WriteSingleint(string fmt, int num, StringBuilder output, List`1<Special> numSpecials, SortedList`2<CellNumberStringMod, object> mods);
    private void Writeint(StringBuilder result, StringBuilder output, List`1<Special> numSpecials, SortedList`2<CellNumberStringMod, object> mods, bool ShowCommas);
    private void WriteFractional(StringBuilder result, StringBuilder output);
    public virtual void SimpleValue(StringBuilder toAppendTo, object value);
    private static Special lastSpecial(List`1<Special> s);
}
public class NPOI.SS.Format.CellNumberPartHandler : object {
    private char insertSignForExponent;
    private double scale;
    private Special decimalPoint;
    private Special slash;
    private Special exponent;
    private Special numerator;
    private List`1<Special> specials;
    private bool improperFraction;
    public double Scale { get; }
    public Special DecimalPoint { get; }
    public Special Slash { get; }
    public Special Exponent { get; }
    public Special Numerator { get; }
    public List`1<Special> Specials { get; }
    public bool IsImproperFraction { get; }
    public sealed virtual string HandlePart(Match m, string part, CellFormatType type, StringBuilder descBuf);
    public double get_Scale();
    public Special get_DecimalPoint();
    public Special get_Slash();
    public Special get_Exponent();
    public Special get_Numerator();
    public List`1<Special> get_Specials();
    public bool get_IsImproperFraction();
    private Special PreviousNumber();
    private static bool IsDigitFmt(Special s);
    private static Special FirstDigit(List`1<Special> specials);
}
public class NPOI.SS.Format.CellNumberStringMod : object {
    public static int BEFORE;
    public static int AFTER;
    public static int REPLACE;
    private Special special;
    private int op;
    private string toAdd;
    private Special end;
    private bool startInclusive;
    private bool endInclusive;
    public int Op { get; }
    public string ToAdd { get; }
    public Special End { get; }
    public bool IsStartInclusive { get; }
    public bool IsEndInclusive { get; }
    public CellNumberStringMod(Special special, string toAdd, int op);
    public CellNumberStringMod(Special start, bool startInclusive, Special end, bool endInclusive, char toAdd);
    public CellNumberStringMod(Special start, bool startInclusive, Special end, bool endInclusive);
    public sealed virtual int CompareTo(CellNumberStringMod that);
    public virtual bool Equals(object that);
    public virtual int GetHashCode();
    public Special GetSpecial();
    public int get_Op();
    public string get_ToAdd();
    public Special get_End();
    public bool get_IsStartInclusive();
    public bool get_IsEndInclusive();
}
public class NPOI.SS.Format.CellTextFormatter : CellFormatter {
    private Int32[] textPos;
    private string desc;
    internal static CellFormatter SIMPLE_TEXT;
    public CellTextFormatter(string format);
    private static CellTextFormatter();
    public virtual void FormatValue(StringBuilder toAppendTo, object obj);
    public virtual void SimpleValue(StringBuilder toAppendTo, object value);
}
internal class NPOI.SS.Format.DateCellFormatType : CellFormatType {
    public virtual bool IsSpecial(char ch);
    public virtual CellFormatter Formatter(string pattern);
}
internal class NPOI.SS.Format.ElapsedCellFormatType : CellFormatType {
    public virtual bool IsSpecial(char ch);
    public virtual CellFormatter Formatter(string pattern);
}
internal class NPOI.SS.Format.GeneralCellFormatType : CellFormatType {
    public virtual CellFormatter Formatter(string pattern);
    public virtual bool IsSpecial(char ch);
}
internal class NPOI.SS.Format.NumberCellFormatType : CellFormatType {
    public virtual CellFormatter Formatter(string pattern);
    public virtual bool IsSpecial(char ch);
}
public class NPOI.SS.Format.SimpleFraction : object {
    private int denominator;
    private int numerator;
    public int Denominator { get; }
    public int Numerator { get; }
    public SimpleFraction(int numerator, int denominator);
    public static SimpleFraction BuildFractionExactDenominator(double val, int exactDenom);
    public static SimpleFraction BuildFractionMaxDenominator(double value, int maxDenominator);
    private static SimpleFraction BuildFractionMaxDenominator(double value, double epsilon, int maxDenominator, int maxIterations);
    public int get_Denominator();
    public int get_Numerator();
}
internal class NPOI.SS.Format.TextCellFormatType : CellFormatType {
    public virtual bool IsSpecial(char ch);
    public virtual CellFormatter Formatter(string pattern);
}
public class NPOI.SS.Formula.Atp.AnalysisToolPak : UDFFinder {
    public static UDFFinder instance;
    private static Dictionary`2<string, FreeRefFunction> _functionsByName;
    private static AnalysisToolPak();
    public virtual FreeRefFunction FindFunction(string name);
    private static Dictionary`2<string, FreeRefFunction> CreateFunctionsMap();
    private static void r(Dictionary`2<string, FreeRefFunction> m, string functionName, FreeRefFunction pFunc);
    public static bool IsATPFunction(string name);
    public static ReadOnlyCollection`1<string> GetSupportedFunctionNames();
    public static ReadOnlyCollection`1<string> GetNotSupportedFunctionNames();
    public static void RegisterFunction(string name, FreeRefFunction func);
}
internal class NPOI.SS.Formula.Atp.ArgumentsEvaluator : object {
    public static ArgumentsEvaluator instance;
    private static ArgumentsEvaluator();
    public double EvaluateDateArg(ValueEval arg, int srcCellRow, int srcCellCol);
    public Double[] EvaluateDatesArg(ValueEval arg, int srcCellRow, int srcCellCol);
    public double EvaluateNumberArg(ValueEval arg, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Atp.DateParser : object {
    public static DateTime ParseDate(string strVal);
    private static DateTime MakeDate(int year, int month, int day);
}
internal class NPOI.SS.Formula.Atp.IfError : object {
    public static FreeRefFunction Instance;
    private static IfError();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static ValueEval EvaluateInternal(ValueEval arg, ValueEval iferror, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Atp.IfNa : object {
    public static FreeRefFunction instance;
    private static IfNa();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
internal class NPOI.SS.Formula.Atp.Ifs : object {
    public static FreeRefFunction Instance;
    private static Ifs();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Atp.Maxifs : object {
    public static FreeRefFunction instance;
    private static Maxifs();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Atp.Minifs : object {
    public static FreeRefFunction instance;
    private static Minifs();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
internal class NPOI.SS.Formula.Atp.MRound : object {
    public static FreeRefFunction Instance;
    private static MRound();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Atp.NetworkdaysFunction : object {
    public static FreeRefFunction instance;
    private ArgumentsEvaluator evaluator;
    private NetworkdaysFunction(ArgumentsEvaluator anEvaluator);
    private static NetworkdaysFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Atp.NotImplemented : object {
    private string _functionName;
    public NotImplemented(string functionName);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Atp.ParityFunction : object {
    public static FreeRefFunction IS_EVEN;
    public static FreeRefFunction IS_ODD;
    private int _desiredParity;
    private ParityFunction(int desiredParity);
    private static ParityFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static int EvaluateArgParity(ValueEval arg, int srcCellRow, int srcCellCol);
}
internal class NPOI.SS.Formula.Atp.RandBetween : object {
    private Random _rnd;
    public static FreeRefFunction Instance;
    private static RandBetween();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Atp.Switch : object {
    public static FreeRefFunction instance;
    private static Switch();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Atp.TextJoinFunction : object {
    public static FreeRefFunction instance;
    private ArgumentsEvaluator evaluator;
    private TextJoinFunction(ArgumentsEvaluator anEvaluator);
    private static TextJoinFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private string LaxValueToString(ValueEval eval);
    private List`1<ValueEval> GetValues(ValueEval eval, int srcRowIndex, int srcColumnIndex, bool lastRowOnly);
}
public class NPOI.SS.Formula.Atp.WorkdayCalculator : object {
    public static WorkdayCalculator instance;
    private static Dictionary`2<int, List`1<int>> weekendTypeMap;
    private static WorkdayCalculator();
    public int CalculateWorkdays(double start, double end, Double[] holidays);
    public DateTime CalculateWorkdays(double start, int workdays, Double[] holidays);
    public DateTime CalculateWorkdays(double start, int workdays, int weekendType, Double[] holidays);
    private bool isWeekend(DateTime date, List`1<int> weekendDays);
    protected bool isHoliday(double aDate, Double[] holidays);
    public List`1<int> GetValidWeekendTypes();
    public int PastDaysOfWeek(double start, double end, DayOfWeek dayOfWeek);
    private int CalculateNonWeekendHolidays(double start, double end, Double[] holidays);
    private bool IsWeekend(double aDate);
    private bool IsHoliday(double aDate, Double[] holidays);
    private int IsNonWorkday(double aDate, Double[] holidays);
    private bool IsInARange(double start, double end, double aDate);
}
internal class NPOI.SS.Formula.Atp.WorkdayFunction : object {
    public static FreeRefFunction instance;
    private ArgumentsEvaluator evaluator;
    private WorkdayFunction(ArgumentsEvaluator anEvaluator);
    private static WorkdayFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Atp.WorkdayIntlFunction : object {
    public static FreeRefFunction instance;
    private ArgumentsEvaluator evaluator;
    private WorkdayIntlFunction(ArgumentsEvaluator anEvaluator);
    private static WorkdayIntlFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
internal class NPOI.SS.Formula.Atp.XLookupFunction : object {
    public static FreeRefFunction instance;
    private ArgumentsEvaluator evaluator;
    private XLookupFunction(ArgumentsEvaluator anEvaluator);
    private static XLookupFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    public sealed virtual ValueEval EvaluateArray(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    private string LaxValueToString(ValueEval eval);
    private ValueEval _evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex, bool isSingleValue);
    private ValueEval evaluate(int srcRowIndex, int srcColumnIndex, ValueEval lookupEval, ValueEval indexEval, ValueEval returnEval, string notFound, MatchMode matchMode, SearchMode searchMode, bool isSingleValue);
}
public class NPOI.SS.Formula.Atp.XMatchFunction : object {
    public static FreeRefFunction instance;
    private ArgumentsEvaluator evaluator;
    private XMatchFunction(ArgumentsEvaluator anEvaluator);
    private static XMatchFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private ValueEval _evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    private ValueEval evaluate(int srcRowIndex, int srcColumnIndex, ValueEval lookupEval, ValueEval indexEval, MatchMode matchMode, SearchMode searchMode);
}
internal class NPOI.SS.Formula.Atp.YearFrac : object {
    public static FreeRefFunction instance;
    private static YearFrac();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double EvaluateDateArg(ValueEval arg, int srcCellRow, int srcCellCol);
    private static int EvaluateIntArg(ValueEval arg, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Atp.YearFracCalculator : object {
    private static int MS_PER_HOUR;
    private static int MS_PER_DAY;
    private static int DAYS_PER_NORMAL_YEAR;
    private static int DAYS_PER_LEAP_YEAR;
    private static int LONG_MONTH_LEN;
    private static int SHORT_MONTH_LEN;
    private static int SHORT_FEB_LEN;
    private static int LONG_FEB_LEN;
    public static double Calculate(double pStartDateVal, double pEndDateVal, int basis);
    public static double Basis0(int startDateVal, int endDateVal);
    public static double Basis1(int startDateVal, int endDateVal);
    public static double Basis2(int startDateVal, int endDateVal);
    public static double Basis3(double startDateVal, double endDateVal);
    public static double Basis4(int startDateVal, int endDateVal);
    private static double CalculateAdjusted(SimpleDate startDate, SimpleDate endDate, int date1day, int date2day);
    private static bool IsLastDayOfMonth(SimpleDate date);
    private static int GetLastDayOfMonth(SimpleDate date);
    private static bool ShouldCountFeb29(SimpleDate start, SimpleDate end);
    private static double DateDiff(long startDateTicks, long endDateTicks);
    private static double AverageYearLength(int startYear, int endYear);
    private static bool IsLeapYear(int i);
    private static bool IsGreaterThanOneYear(SimpleDate start, SimpleDate end);
    private static SimpleDate CreateDate(int dayCount);
}
public abstract class NPOI.SS.Formula.BaseFormulaEvaluator : object {
    protected WorkbookEvaluator _bookEvaluator;
    public bool IgnoreMissingWorkbooks { get; public set; }
    public bool DebugEvaluationOutputForNextEval { get; public set; }
    protected BaseFormulaEvaluator(WorkbookEvaluator bookEvaluator);
    public static void SetupEnvironment(String[] workbookNames, BaseFormulaEvaluator[] Evaluators);
    public virtual void SetupReferencedWorkbooks(Dictionary`2<string, IFormulaEvaluator> evaluators);
    public sealed virtual WorkbookEvaluator GetWorkbookEvaluator();
    public sealed virtual void ClearAllCachedResultValues();
    public sealed virtual CellValue Evaluate(ICell cell);
    public virtual ICell EvaluateInCell(ICell cell);
    protected abstract virtual CellValue EvaluateFormulaCellValue(ICell cell);
    public sealed virtual CellType EvaluateFormulaCell(ICell cell);
    public virtual CellType EvaluateFormulaCellEnum(ICell cell);
    protected static void SetCellType(ICell cell, CellValue cv);
    protected abstract virtual IRichTextString CreateRichTextString(string str);
    protected void SetCellValue(ICell cell, CellValue cv);
    public static void EvaluateAllFormulaCells(IWorkbook wb);
    protected static void EvaluateAllFormulaCells(IWorkbook wb, IFormulaEvaluator evaluator);
    public abstract virtual void NotifySetFormula(ICell cell);
    public abstract virtual void NotifyDeleteCell(ICell cell);
    public abstract virtual void NotifyUpdateCell(ICell cell);
    public abstract virtual void EvaluateAll();
    public sealed virtual bool get_IgnoreMissingWorkbooks();
    public sealed virtual void set_IgnoreMissingWorkbooks(bool value);
    public sealed virtual bool get_DebugEvaluationOutputForNextEval();
    public sealed virtual void set_DebugEvaluationOutputForNextEval(bool value);
}
public class NPOI.SS.Formula.BookSheetKey : object {
    private int _bookIndex;
    private int _sheetIndex;
    public BookSheetKey(int bookIndex, int sheetIndex);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class NPOI.SS.Formula.CacheAreaEval : AreaEvalBase {
    private ValueEval[] _values;
    public CacheAreaEval(AreaI ptg, ValueEval[] values);
    public CacheAreaEval(int firstRow, int firstColumn, int lastRow, int lastColumn, ValueEval[] values);
    public virtual ValueEval GetRelativeValue(int relativeRowIndex, int relativeColumnIndex);
    public virtual ValueEval GetRelativeValue(int sheetIndex, int relativeRowIndex, int relativeColumnIndex);
    public virtual AreaEval Offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx);
    public virtual TwoDEval GetRow(int rowIndex);
    public virtual TwoDEval GetColumn(int columnIndex);
    public virtual string ToString();
}
public abstract class NPOI.SS.Formula.CellCacheEntry : object {
    public static CellCacheEntry[] EMPTY_ARRAY;
    private FormulaCellCacheEntrySet _consumingCells;
    private ValueEval _value;
    private static CellCacheEntry();
    protected void ClearValue();
    public bool UpdateValue(ValueEval value);
    public sealed virtual ValueEval GetValue();
    private static bool AreValuesEqual(ValueEval a, ValueEval b);
    public void AddConsumingCell(FormulaCellCacheEntry cellLoc);
    public FormulaCellCacheEntry[] GetConsumingCells();
    public void ClearConsumingCell(FormulaCellCacheEntry cce);
    public void RecurseClearCachedFormulaResults(IEvaluationListener listener);
    protected void RecurseClearCachedFormulaResults();
    protected void RecurseClearCachedFormulaResults(IEvaluationListener listener, int depth);
}
internal class NPOI.SS.Formula.CellEvaluationFrame : object {
    private FormulaCellCacheEntry _cce;
    private ArrayList _sensitiveInputCells;
    private FormulaUsedBlankCellSet _usedBlankCellGroup;
    public CellEvaluationFrame(FormulaCellCacheEntry cce);
    public CellCacheEntry GetCCE();
    public virtual string ToString();
    public void AddSensitiveInputCell(CellCacheEntry inputCell);
    private CellCacheEntry[] GetSensitiveInputCells();
    public void AddUsedBlankCell(int bookIndex, int sheetIndex, int rowIndex, int columnIndex);
    public void UpdateFormulaResult(ValueEval result);
}
public class NPOI.SS.Formula.CollaboratingWorkbooksEnvironment : object {
    public static CollaboratingWorkbooksEnvironment EMPTY;
    private Dictionary`2<string, WorkbookEvaluator> _evaluatorsByName;
    private WorkbookEvaluator[] _evaluators;
    private bool _unhooked;
    private CollaboratingWorkbooksEnvironment(String[] workbookNames, WorkbookEvaluator[] evaluators, int nItems);
    private CollaboratingWorkbooksEnvironment(Dictionary`2<string, WorkbookEvaluator> evaluatorsByName, WorkbookEvaluator[] evaluators);
    private static CollaboratingWorkbooksEnvironment();
    public static void Setup(String[] workbookNames, WorkbookEvaluator[] evaluators);
    public static void Setup(Dictionary`2<string, WorkbookEvaluator> evaluatorsByName);
    public static void SetupFormulaEvaluator(Dictionary`2<string, IFormulaEvaluator> evaluators);
    private static Dictionary`2<string, WorkbookEvaluator> ToUniqueMap(String[] workbookNames, WorkbookEvaluator[] evaluators, int nItems);
    private static void HookNewEnvironment(WorkbookEvaluator[] evaluators, CollaboratingWorkbooksEnvironment env);
    private void UnhookOldEnvironments(WorkbookEvaluator[] evaluators);
    private void Unhook();
    public WorkbookEvaluator GetWorkbookEvaluator(string workbookName);
}
public class NPOI.SS.Formula.ConditionalFormattingEvaluator : object {
    private WorkbookEvaluator workbookEvaluator;
    private IWorkbook workbook;
    private Dictionary`2<string, List`1<EvaluationConditionalFormatRule>> formats;
    private SortedDictionary`2<CellReference, List`1<EvaluationConditionalFormatRule>> values;
    protected WorkbookEvaluator WorkbookEvaluator { get; }
    public ConditionalFormattingEvaluator(IWorkbook wb, IWorkbookEvaluatorProvider provider);
    protected WorkbookEvaluator get_WorkbookEvaluator();
    public List`1<EvaluationConditionalFormatRule> GetConditionalFormattingForCell(CellReference cellRef);
    public List`1<EvaluationConditionalFormatRule> GetConditionalFormattingForCell(ICell cell);
    public static CellReference GetRef(ICell cell);
    protected List`1<EvaluationConditionalFormatRule> GetRules(ISheet sheet);
    public void ClearAllCachedFormats();
    public void ClearAllCachedValues();
}
public class NPOI.SS.Formula.Constant.ConstantValueParser : object {
    private static int TYPE_EMPTY;
    private static int TYPE_NUMBER;
    private static int TYPE_STRING;
    private static int TYPE_BOOLEAN;
    private static int TYPE_ERROR_CODE;
    private static int TRUE_ENCODING;
    private static int FALSE_ENCODING;
    private static object EMPTY_REPRESENTATION;
    public static Object[] Parse(ILittleEndianInput in1, int nValues);
    private static object ReadAConstantValue(ILittleEndianInput in1);
    private static object ReadBoolean(ILittleEndianInput in1);
    public static int GetEncodedSize(Array values);
    private static int GetEncodedSize(object obj);
    public static void Encode(ILittleEndianOutput out1, Array values);
    private static void EncodeSingleValue(ILittleEndianOutput out1, object value);
}
public class NPOI.SS.Formula.Constant.ErrorConstant : object {
    private static ErrorConstant NULL;
    private static ErrorConstant DIV_0;
    private static ErrorConstant VALUE;
    private static ErrorConstant REF;
    private static ErrorConstant NAME;
    private static ErrorConstant NUM;
    private static ErrorConstant NA;
    private int _errorCode;
    public int ErrorCode { get; }
    public string Text { get; }
    private ErrorConstant(int errorCode);
    private static ErrorConstant();
    public int get_ErrorCode();
    public string get_Text();
    public static ErrorConstant ValueOf(int errorCode);
    public virtual string ToString();
}
public class NPOI.SS.Formula.DataValidationEvaluator : object {
    public static bool IsType(ICell cell, CellType type);
}
public class NPOI.SS.Formula.Eval.AddEval : TwoOperandNumericOperation {
    public virtual double Evaluate(double d0, double d1);
}
public interface NPOI.SS.Formula.Eval.AreaEval {
    public int FirstRow { get; }
    public int LastRow { get; }
    public int FirstColumn { get; }
    public int LastColumn { get; }
    public abstract virtual int get_FirstRow();
    public abstract virtual int get_LastRow();
    public abstract virtual int get_FirstColumn();
    public abstract virtual int get_LastColumn();
    public abstract virtual bool Contains(int row, int col);
    public abstract virtual bool ContainsColumn(int col);
    public abstract virtual bool ContainsRow(int row);
    public abstract virtual ValueEval GetAbsoluteValue(int row, int col);
    public abstract virtual ValueEval GetRelativeValue(int relativeRowIndex, int relativeColumnIndex);
    public abstract virtual AreaEval Offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx);
}
public abstract class NPOI.SS.Formula.Eval.AreaEvalBase : object {
    private int _firstSheet;
    private int _firstColumn;
    private int _firstRow;
    private int _lastSheet;
    private int _lastColumn;
    private int _lastRow;
    private int _nColumns;
    private int _nRows;
    public int FirstColumn { get; }
    public int FirstRow { get; }
    public int LastColumn { get; }
    public int LastRow { get; }
    public int FirstSheetIndex { get; }
    public int LastSheetIndex { get; }
    public bool IsColumn { get; }
    public bool IsRow { get; }
    public int Width { get; }
    public int Height { get; }
    protected AreaEvalBase(ISheetRange sheets, int firstRow, int firstColumn, int lastRow, int lastColumn);
    protected AreaEvalBase(int firstRow, int firstColumn, int lastRow, int lastColumn);
    protected AreaEvalBase(AreaI ptg);
    protected AreaEvalBase(AreaI ptg, ISheetRange sheets);
    public sealed virtual int get_FirstColumn();
    public sealed virtual int get_FirstRow();
    public sealed virtual int get_LastColumn();
    public sealed virtual int get_LastRow();
    public sealed virtual int get_FirstSheetIndex();
    public sealed virtual int get_LastSheetIndex();
    public sealed virtual ValueEval GetValue(int row, int col);
    public sealed virtual ValueEval GetValue(int sheetIndex, int row, int col);
    public sealed virtual bool Contains(int row, int col);
    public sealed virtual bool ContainsRow(int row);
    public sealed virtual bool ContainsColumn(int col);
    public sealed virtual bool get_IsColumn();
    public sealed virtual bool get_IsRow();
    public sealed virtual ValueEval GetAbsoluteValue(int row, int col);
    public abstract virtual ValueEval GetRelativeValue(int relativeRowIndex, int relativeColumnIndex);
    public abstract virtual ValueEval GetRelativeValue(int sheetIndex, int relativeRowIndex, int relativeColumnIndex);
    public sealed virtual int get_Width();
    public sealed virtual int get_Height();
    public virtual bool IsSubTotal(int rowIndex, int columnIndex);
    public abstract virtual TwoDEval GetRow(int rowIndex);
    public abstract virtual TwoDEval GetColumn(int columnIndex);
    public abstract virtual AreaEval Offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx);
}
public class NPOI.SS.Formula.Eval.BlankEval : object {
    public static BlankEval instance;
    private static BlankEval();
}
public class NPOI.SS.Formula.Eval.BoolEval : object {
    private bool value;
    public static BoolEval FALSE;
    public static BoolEval TRUE;
    public bool BooleanValue { get; }
    public double NumberValue { get; }
    public string StringValue { get; }
    public BoolEval(Ptg ptg);
    private BoolEval(bool value);
    private static BoolEval();
    public static BoolEval ValueOf(bool b);
    public bool get_BooleanValue();
    public sealed virtual double get_NumberValue();
    public sealed virtual string get_StringValue();
    public virtual string ToString();
}
public class NPOI.SS.Formula.Eval.ConcatEval : Fixed2ArgFunction {
    public static Function instance;
    private static ConcatEval();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    private object GetText(ValueEval ve);
}
public class NPOI.SS.Formula.Eval.DivideEval : TwoOperandNumericOperation {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Eval.EqualEval : RelationalOperationEval {
    public virtual bool ConvertComparisonResult(int cmpResult);
}
public class NPOI.SS.Formula.Eval.ErrorEval : object {
    private static Dictionary`2<FormulaError, ErrorEval> evals;
    public static ErrorEval NULL_INTERSECTION;
    public static ErrorEval DIV_ZERO;
    public static ErrorEval VALUE_INVALID;
    public static ErrorEval REF_INVALID;
    public static ErrorEval NAME_INVALID;
    public static ErrorEval NUM_ERROR;
    public static ErrorEval NA;
    public static ErrorEval FUNCTION_NOT_IMPLEMENTED;
    public static ErrorEval CIRCULAR_REF_ERROR;
    private FormulaError _error;
    public int ErrorCode { get; }
    public string ErrorString { get; }
    private ErrorEval(FormulaError error);
    private static ErrorEval();
    public static ErrorEval ValueOf(int errorCode);
    public static string GetText(int errorCode);
    public int get_ErrorCode();
    public string get_ErrorString();
    public virtual string ToString();
}
public interface NPOI.SS.Formula.Eval.Eval {
}
public class NPOI.SS.Formula.Eval.EvaluationException : Exception {
    private ErrorEval _errorEval;
    public EvaluationException(ErrorEval errorEval);
    public static EvaluationException InvalidValue();
    public static EvaluationException InvalidRef();
    public static EvaluationException NumberError();
    public ErrorEval GetErrorEval();
}
public class NPOI.SS.Formula.Eval.ExternalNameEval : object {
    private IEvaluationName _name;
    public IEvaluationName Name { get; }
    public ExternalNameEval(IEvaluationName name);
    public IEvaluationName get_Name();
    public virtual string ToString();
}
internal class NPOI.SS.Formula.Eval.Forked.ForkedEvaluationCell : object {
    private IEvaluationSheet _sheet;
    private IEvaluationCell _masterCell;
    private bool _boolValue;
    private CellType _cellType;
    private int _errorValue;
    private double _numberValue;
    private string _stringValue;
    public object IdentityKey { get; }
    public CellType CellType { get; }
    public bool BooleanCellValue { get; }
    public int ErrorCellValue { get; }
    public double NumericCellValue { get; }
    public string StringCellValue { get; }
    public IEvaluationSheet Sheet { get; }
    public int RowIndex { get; }
    public int ColumnIndex { get; }
    public bool IsPartOfArrayFormulaGroup { get; }
    public CellRangeAddress ArrayFormulaRange { get; }
    public CellType CachedFormulaResultType { get; }
    public ForkedEvaluationCell(ForkedEvaluationSheet sheet, IEvaluationCell masterCell);
    public sealed virtual object get_IdentityKey();
    public void SetValue(ValueEval value);
    public void CopyValue(ICell destCell);
    private void CheckCellType(CellType expectedCellType);
    public sealed virtual CellType get_CellType();
    public sealed virtual bool get_BooleanCellValue();
    public sealed virtual int get_ErrorCellValue();
    public sealed virtual double get_NumericCellValue();
    public sealed virtual string get_StringCellValue();
    public sealed virtual IEvaluationSheet get_Sheet();
    public sealed virtual int get_RowIndex();
    public sealed virtual int get_ColumnIndex();
    public sealed virtual bool get_IsPartOfArrayFormulaGroup();
    public sealed virtual CellRangeAddress get_ArrayFormulaRange();
    public sealed virtual CellType get_CachedFormulaResultType();
}
internal class NPOI.SS.Formula.Eval.Forked.ForkedEvaluationSheet : object {
    private IEvaluationSheet _masterSheet;
    private Dictionary`2<RowColKey, ForkedEvaluationCell> _sharedCellsByRowCol;
    public ForkedEvaluationSheet(IEvaluationSheet masterSheet);
    public sealed virtual IEvaluationCell GetCell(int rowIndex, int columnIndex);
    public ForkedEvaluationCell GetOrCreateUpdatableCell(int rowIndex, int columnIndex);
    public void CopyUpdatedCells(ISheet sheet);
    public int GetSheetIndex(IEvaluationWorkbook mewb);
    public sealed virtual void ClearAllCachedResultValues();
}
internal class NPOI.SS.Formula.Eval.Forked.ForkedEvaluationWorkbook : object {
    private IEvaluationWorkbook _masterBook;
    private Dictionary`2<string, ForkedEvaluationSheet> _sharedSheetsByName;
    public ForkedEvaluationWorkbook(IEvaluationWorkbook master);
    public ForkedEvaluationCell GetOrCreateUpdatableCell(string sheetName, int rowIndex, int columnIndex);
    public IEvaluationCell GetEvaluationCell(string sheetName, int rowIndex, int columnIndex);
    private ForkedEvaluationSheet GetSharedSheet(string sheetName);
    public void CopyUpdatedCells(IWorkbook workbook);
    public sealed virtual int ConvertFromExternSheetIndex(int externSheetIndex);
    public sealed virtual ExternalSheet GetExternalSheet(int externSheetIndex);
    public sealed virtual ExternalSheet GetExternalSheet(string firstSheetName, string lastSheetName, int externalWorkbookNumber);
    public sealed virtual Ptg[] GetFormulaTokens(IEvaluationCell cell);
    public sealed virtual IEvaluationName GetName(NamePtg namePtg);
    public sealed virtual IEvaluationName GetName(string name, int sheetIndex);
    public sealed virtual IEvaluationSheet GetSheet(int sheetIndex);
    public sealed virtual ExternalName GetExternalName(int externSheetIndex, int externNameIndex);
    public sealed virtual ExternalName GetExternalName(string nameName, string sheetName, int externalWorkbookNumber);
    public sealed virtual int GetSheetIndex(IEvaluationSheet sheet);
    public sealed virtual int GetSheetIndex(string sheetName);
    public sealed virtual string GetSheetName(int sheetIndex);
    public sealed virtual string ResolveNameXText(NameXPtg ptg);
    public sealed virtual UDFFinder GetUDFFinder();
    public sealed virtual void ClearAllCachedResultValues();
    public sealed virtual SpreadsheetVersion GetSpreadsheetVersion();
}
public class NPOI.SS.Formula.Eval.Forked.ForkedEvaluator : object {
    private WorkbookEvaluator _evaluator;
    private ForkedEvaluationWorkbook _sewb;
    private ForkedEvaluator(IEvaluationWorkbook masterWorkbook, IStabilityClassifier stabilityClassifier, UDFFinder udfFinder);
    private static IEvaluationWorkbook CreateEvaluationWorkbook(IWorkbook wb);
    public static ForkedEvaluator Create(IWorkbook wb, IStabilityClassifier stabilityClassifier, UDFFinder udfFinder);
    public void UpdateCell(string sheetName, int rowIndex, int columnIndex, ValueEval value);
    public void CopyUpdatedCells(IWorkbook workbook);
    public ValueEval Evaluate(string sheetName, int rowIndex, int columnIndex);
    public static void SetupEnvironment(String[] workbookNames, ForkedEvaluator[] Evaluators);
}
public class NPOI.SS.Formula.Eval.FunctionEval : object {
    protected static Function[] functions;
    private static FunctionMetadataRegistry _instance;
    private static FunctionEval();
    private static FunctionMetadataRegistry GetInstance();
    public static Function GetBasicFunction(int functionIndex);
    private static Function[] ProduceFunctions();
    public static void RegisterFunction(string name, Function func);
    public static ReadOnlyCollection`1<string> GetSupportedFunctionNames();
    public static ReadOnlyCollection`1<string> GetNotSupportedFunctionNames();
}
public class NPOI.SS.Formula.Eval.FunctionNameEval : object {
    private string _functionName;
    public string FunctionName { get; }
    public FunctionNameEval(string functionName);
    public string get_FunctionName();
    public virtual string ToString();
}
public class NPOI.SS.Formula.Eval.GreaterEqualEval : RelationalOperationEval {
    public virtual bool ConvertComparisonResult(int cmpResult);
}
public class NPOI.SS.Formula.Eval.GreaterThanEval : RelationalOperationEval {
    public virtual bool ConvertComparisonResult(int cmpResult);
}
public class NPOI.SS.Formula.Eval.IntersectionEval : Fixed2ArgFunction {
    public static Function instance;
    private static IntersectionEval();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    private static AreaEval ResolveRange(AreaEval aeA, AreaEval aeB);
    private AreaEval EvaluateRef(ValueEval arg);
}
public class NPOI.SS.Formula.Eval.LessEqualEval : RelationalOperationEval {
    public virtual bool ConvertComparisonResult(int cmpResult);
}
public class NPOI.SS.Formula.Eval.LessThanEval : RelationalOperationEval {
    public virtual bool ConvertComparisonResult(int cmpResult);
}
public class NPOI.SS.Formula.Eval.MissingArgEval : object {
    public static MissingArgEval instance;
    private static MissingArgEval();
}
public class NPOI.SS.Formula.Eval.MultiplyEval : TwoOperandNumericOperation {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Eval.NotEqualEval : RelationalOperationEval {
    public virtual bool ConvertComparisonResult(int cmpResult);
}
public class NPOI.SS.Formula.Eval.NotImplementedFunctionException : NotImplementedException {
    private string functionName;
    public string FunctionName { get; }
    public NotImplementedFunctionException(string functionName);
    public NotImplementedFunctionException(string functionName, NotImplementedException cause);
    public string get_FunctionName();
}
public class NPOI.SS.Formula.Eval.NumberEval : object {
    public static NumberEval ZERO;
    private double _value;
    private string _stringValue;
    public double NumberValue { get; }
    public string StringValue { get; }
    public NumberEval(Ptg ptg);
    public NumberEval(double value);
    private static NumberEval();
    public sealed virtual double get_NumberValue();
    public sealed virtual string get_StringValue();
    protected void MakeString();
    public virtual string ToString();
}
public interface NPOI.SS.Formula.Eval.NumericValueEval {
    public double NumberValue { get; }
    public abstract virtual double get_NumberValue();
}
public class NPOI.SS.Formula.Eval.OperandResolver : object {
    private static string Digits;
    private static string Exp;
    private static string fpRegex;
    public static ValueEval GetSingleValue(ValueEval arg, int srcCellRow, int srcCellCol);
    public static ValueEval ChooseSingleElementFromArea(AreaEval ae, int srcCellRow, int srcCellCol);
    private static ValueEval ChooseSingleElementFromAreaInternal(AreaEval ae, int srcCellRow, int srcCellCol);
    private static ValueEval ChooseSingleElementFromRef(RefEval ref1);
    public static int CoerceValueToInt(ValueEval ev);
    public static double CoerceValueToDouble(ValueEval ev);
    public static double ParseDouble(string pText);
    public static string CoerceValueToString(ValueEval ve);
    public static Nullable`1<bool> CoerceValueToBoolean(ValueEval ve, bool stringsAreBlanks);
    public static ValueEval GetElementFromArray(AreaEval ae, IEvaluationCell cell);
}
public interface NPOI.SS.Formula.Eval.OperationEval {
    public int NumberOfOperands { get; }
    public abstract virtual Eval Evaluate(Eval[] evals, int srcCellRow, short srcCellCol);
    public abstract virtual int get_NumberOfOperands();
}
public class NPOI.SS.Formula.Eval.PercentEval : Fixed1ArgFunction {
    public static Function instance;
    private static PercentEval();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Eval.PowerEval : TwoOperandNumericOperation {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Eval.RangeEval : Fixed2ArgFunction {
    public static Function instance;
    private static RangeEval();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    private static AreaEval ResolveRange(AreaEval aeA, AreaEval aeB);
    private static AreaEval EvaluateRef(ValueEval arg);
}
public interface NPOI.SS.Formula.Eval.RefEval {
    public int Column { get; }
    public int Row { get; }
    public int NumberOfSheets { get; }
    public abstract virtual ValueEval GetInnerValueEval(int sheetIndex);
    public abstract virtual int get_Column();
    public abstract virtual int get_Row();
    public abstract virtual int get_NumberOfSheets();
    public abstract virtual AreaEval Offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx);
}
public abstract class NPOI.SS.Formula.Eval.RefEvalBase : object {
    private int _firstSheetIndex;
    private int _lastSheetIndex;
    private int _rowIndex;
    private int _columnIndex;
    public int NumberOfSheets { get; }
    public int FirstSheetIndex { get; }
    public int LastSheetIndex { get; }
    public int Row { get; }
    public int Column { get; }
    protected RefEvalBase(ISheetRange sheetRange, int rowIndex, int columnIndex);
    protected RefEvalBase(int firstSheetIndex, int lastSheetIndex, int rowIndex, int columnIndex);
    protected RefEvalBase(int onlySheetIndex, int rowIndex, int columnIndex);
    public sealed virtual int get_NumberOfSheets();
    public sealed virtual int get_FirstSheetIndex();
    public sealed virtual int get_LastSheetIndex();
    public sealed virtual int get_Row();
    public sealed virtual int get_Column();
    public abstract virtual ValueEval GetInnerValueEval(int sheetIndex);
    public abstract virtual AreaEval Offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx);
}
public class NPOI.SS.Formula.Eval.RefListEval : object {
    private List`1<ValueEval> list;
    public RefListEval(ValueEval v1, ValueEval v2);
    private void Add(ValueEval v);
    public List`1<ValueEval> GetList();
}
public abstract class NPOI.SS.Formula.Eval.RelationalOperationEval : Fixed2ArgFunction {
    public static Function EqualEval;
    public static Function NotEqualEval;
    public static Function LessEqualEval;
    public static Function LessThanEval;
    public static Function GreaterEqualEval;
    public static Function GreaterThanEval;
    private static RelationalOperationEval();
    private static int DoCompare(ValueEval va, ValueEval vb);
    private static int CompareBlank(ValueEval v);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public sealed virtual ValueEval EvaluateArray(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual bool ConvertComparisonResult(int cmpResult);
}
public class NPOI.SS.Formula.Eval.StringEval : object {
    public static StringEval EMPTY_INSTANCE;
    private string value;
    public string StringValue { get; }
    public StringEval(Ptg ptg);
    public StringEval(string value);
    private static StringEval();
    public sealed virtual string get_StringValue();
    public virtual string ToString();
}
public interface NPOI.SS.Formula.Eval.StringValueEval {
    public string StringValue { get; }
    public abstract virtual string get_StringValue();
}
public class NPOI.SS.Formula.Eval.SubtractEval : TwoOperandNumericOperation {
    public virtual double Evaluate(double d0, double d1);
}
public abstract class NPOI.SS.Formula.Eval.TwoOperandNumericOperation : Fixed2ArgFunction {
    public static Function AddEval;
    public static Function DivideEval;
    public static Function MultiplyEval;
    public static Function PowerEval;
    public static Function SubtractEval;
    private static TwoOperandNumericOperation();
    protected double SingleOperandEvaluate(ValueEval arg, int srcCellRow, int srcCellCol);
    public sealed virtual ValueEval EvaluateArray(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public abstract virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Eval.UnaryMinusEval : Fixed1ArgFunction {
    public static Function instance;
    private static UnaryMinusEval();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Eval.UnaryPlusEval : Fixed1ArgFunction {
    public static Function instance;
    private static UnaryPlusEval();
    public virtual ValueEval Evaluate(int srcCellRow, int srcCellCol, ValueEval arg0);
}
public interface NPOI.SS.Formula.Eval.ValueEval {
}
public class NPOI.SS.Formula.EvaluationCache : object {
    private PlainCellCache _plainCellCache;
    private FormulaCellCache _formulaCellCache;
    private IEvaluationListener _evaluationListener;
    public EvaluationCache(IEvaluationListener evaluationListener);
    public void NotifyUpdateCell(int bookIndex, int sheetIndex, IEvaluationCell cell);
    private void UpdateAnyBlankReferencingFormulas(int bookIndex, int sheetIndex, int rowIndex, int columnIndex);
    public PlainValueCellCacheEntry GetPlainValueEntry(int bookIndex, int sheetIndex, int rowIndex, int columnIndex, ValueEval value);
    private bool AreValuesEqual(ValueEval a, ValueEval b);
    public FormulaCellCacheEntry GetOrCreateFormulaCellEntry(IEvaluationCell cell);
    public void Clear();
    public void NotifyDeleteCell(int bookIndex, int sheetIndex, IEvaluationCell cell);
}
public class NPOI.SS.Formula.EvaluationConditionalFormatRule : object {
    private WorkbookEvaluator workbookEvaluator;
    private ISheet sheet;
    private IConditionalFormatting formatting;
    private IConditionalFormattingRule rule;
    private CellRangeAddress[] regions;
    private Dictionary`2<CellRangeAddress, List`1<ValueAndFormat>> meaningfulRegionValues;
    private int priority;
    private int formattingIndex;
    private int ruleIndex;
    private string formula1;
    private string formula2;
    private string text;
    private string lowerText;
    private OperatorEnum operator;
    private ConditionType type;
    private ExcelNumberFormat numberFormat;
    private DecimalFormat decimalTextFormat;
    public ISheet Sheet { get; }
    public IConditionalFormatting Formatting { get; }
    public int FormattingIndex { get; }
    public IConditionalFormattingRule Rule { get; }
    public int RuleIndex { get; }
    public CellRangeAddress[] Regions { get; }
    public int Priority { get; }
    public string Formula1 { get; }
    public string Formula2 { get; }
    public string Text { get; }
    public ConditionType Type { get; }
    public OperatorEnum Operator { get; }
    public ExcelNumberFormat NumberFormat { get; }
    public EvaluationConditionalFormatRule(WorkbookEvaluator workbookEvaluator, ISheet sheet, IConditionalFormatting formatting, int formattingIndex, IConditionalFormattingRule rule, int ruleIndex, CellRangeAddress[] regions);
    public ISheet get_Sheet();
    public IConditionalFormatting get_Formatting();
    public int get_FormattingIndex();
    public IConditionalFormattingRule get_Rule();
    public int get_RuleIndex();
    public CellRangeAddress[] get_Regions();
    public int get_Priority();
    public string get_Formula1();
    public string get_Formula2();
    public string get_Text();
    public ConditionType get_Type();
    public OperatorEnum get_Operator();
    public ExcelNumberFormat get_NumberFormat();
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(EvaluationConditionalFormatRule o);
    private ValueEval UnwrapEval(ValueEval eval);
    private bool CheckValue(ICell cell, CellRangeAddress region);
    private bool CheckFormula(CellReference reference, CellRangeAddress region);
    internal bool Matches(CellReference reference);
    private bool CheckFilter(ICell cell, CellReference reference, CellRangeAddress region);
    private List`1<ValueAndFormat> GetMeaningfulValues(CellRangeAddress region, bool withText, Func`2<List`1<ValueAndFormat>, List`1<ValueAndFormat>> func);
    private ValueAndFormat GetCellValue(ICell cell);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private List`1<ValueAndFormat> <CheckFilter>b__51_0(List`1<ValueAndFormat> allValues);
    [CompilerGeneratedAttribute]
private List`1<ValueAndFormat> <CheckFilter>b__51_3(List`1<ValueAndFormat> allValues);
}
public class NPOI.SS.Formula.EvaluationTracker : object {
    private IList _evaluationFrames;
    private IList _currentlyEvaluatingCells;
    private EvaluationCache _cache;
    public EvaluationTracker(EvaluationCache cache);
    public bool StartEvaluate(FormulaCellCacheEntry cce);
    public void UpdateCacheResult(ValueEval result);
    public void EndEvaluate(CellCacheEntry cce);
    public void AcceptFormulaDependency(CellCacheEntry cce);
    public void AcceptPlainValueDependency(int bookIndex, int sheetIndex, int rowIndex, int columnIndex, ValueEval value);
}
public class NPOI.SS.Formula.ExternalName : object {
    private string _nameName;
    private int _nameNumber;
    private int _ix;
    public string Name { get; }
    public int Number { get; }
    public int Ix { get; }
    public ExternalName(string nameName, int nameNumber, int ix);
    public string get_Name();
    public int get_Number();
    public int get_Ix();
}
public class NPOI.SS.Formula.ExternalSheet : object {
    private string _workbookName;
    private string _sheetName;
    public string WorkbookName { get; }
    public string SheetName { get; }
    public ExternalSheet(string workbookName, string sheetName);
    public string get_WorkbookName();
    public string get_SheetName();
}
public class NPOI.SS.Formula.ExternalSheetRange : ExternalSheet {
    private string _lastSheetName;
    public string FirstSheetName { get; }
    public string LastSheetName { get; }
    public ExternalSheetRange(string workbookName, string firstSheetName, string lastSheetName);
    public string get_FirstSheetName();
    public string get_LastSheetName();
}
public class NPOI.SS.Formula.Formula : object {
    private static Formula EMPTY;
    private Byte[] _byteEncoding;
    private int _encodedTokenLen;
    public Ptg[] Tokens { get; }
    public int EncodedSize { get; }
    public int EncodedTokenSize { get; }
    public CellReference ExpReference { get; }
    private Formula(Byte[] byteEncoding, int encodedTokenLen);
    private static Formula();
    public static Formula Read(int encodedTokenLen, ILittleEndianInput in1);
    public static Formula Read(int encodedTokenLen, ILittleEndianInput in1, int totalEncodedLen);
    public Ptg[] get_Tokens();
    public void Serialize(ILittleEndianOutput out1);
    public void SerializeTokens(ILittleEndianOutput out1);
    public void SerializeArrayConstantData(ILittleEndianOutput out1);
    public int get_EncodedSize();
    public int get_EncodedTokenSize();
    public static Formula Create(Ptg[] ptgs);
    public static Ptg[] GetTokens(Formula formula);
    public Formula Copy();
    public CellReference get_ExpReference();
    public bool IsSame(Formula other);
}
public class NPOI.SS.Formula.FormulaCellCache : object {
    private Hashtable _formulaEntriesByCell;
    public CellCacheEntry[] GetCacheEntries();
    public void Clear();
    public FormulaCellCacheEntry Get(IEvaluationCell cell);
    public void Put(IEvaluationCell cell, FormulaCellCacheEntry entry);
    public FormulaCellCacheEntry Remove(IEvaluationCell cell);
    public void ApplyOperation(IEntryOperation operation);
}
public class NPOI.SS.Formula.FormulaCellCacheEntry : CellCacheEntry {
    public static FormulaCellCacheEntry[] EMPTY_ARRAY;
    private CellCacheEntry[] _sensitiveInputCells;
    private FormulaUsedBlankCellSet _usedBlankCellGroup;
    public bool IsInputSensitive { get; }
    private static FormulaCellCacheEntry();
    public bool get_IsInputSensitive();
    public void SetSensitiveInputCells(CellCacheEntry[] sensitiveInputCells);
    public void ClearFormulaEntry();
    private void ChangeConsumingCells(CellCacheEntry[] usedCells);
    public void UpdateFormulaResult(ValueEval result, CellCacheEntry[] sensitiveInputCells, FormulaUsedBlankCellSet usedBlankAreas);
    public void NotifyUpdatedBlankCell(BookSheetKey bsk, int rowIndex, int columnIndex, IEvaluationListener evaluationListener);
}
internal class NPOI.SS.Formula.FormulaCellCacheEntrySet : object {
    private int _size;
    private FormulaCellCacheEntry[] _arr;
    public FormulaCellCacheEntry[] ToArray();
    public void Add(CellCacheEntry cce);
    private static bool AddInternal(CellCacheEntry[] arr, CellCacheEntry cce);
    public bool Remove(CellCacheEntry cce);
}
public class NPOI.SS.Formula.FormulaParseException : Exception {
    public FormulaParseException(string msg);
}
public class NPOI.SS.Formula.FormulaParser : object {
    private string _formulaString;
    private int _formulaLength;
    private int _pointer;
    private ParseNode _rootNode;
    private static char TAB;
    private static char CR;
    private static char LF;
    private char look;
    private bool _inIntersection;
    private IFormulaParsingWorkbook _book;
    private static SpreadsheetVersion _ssVersion;
    private int _sheetIndex;
    private int _rowIndex;
    private static string specHeaders;
    private static string specAll;
    private static string specData;
    private static string specTotals;
    private static string specThisRow;
    public FormulaParser(string formula, IFormulaParsingWorkbook book, int sheetIndex, int rowIndex);
    private static FormulaParser();
    public static Ptg[] Parse(string formula, IFormulaParsingWorkbook workbook, FormulaType formulaType, int sheetIndex, int rowIndex);
    public static Ptg[] Parse(string formula, IFormulaParsingWorkbook workbook, FormulaType formulaType, int sheetIndex);
    public static Area3DPxg ParseStructuredReference(string tableText, IFormulaParsingWorkbook workbook, int rowIndex);
    private void GetChar();
    private Exception expected(string s);
    private static bool IsAlpha(char c);
    private static bool IsDigit(char c);
    private static bool IsAlNum(char c);
    private static bool IsWhite(char c);
    private void SkipWhite();
    private void Match(char x);
    private string ParseUnquotedIdentifier();
    private string GetNum();
    private ParseNode ParseRangeExpression();
    private static ParseNode AugmentWithMemPtg(ParseNode root);
    private static bool NeedsMemFunc(ParseNode root);
    private static bool IsValidDefinedNameChar(char ch);
    private void CheckValidRangeOperand(string sideName, int currentParsePosition, ParseNode pn);
    private bool IsValidRangeOperand(ParseNode a);
    private ParseNode ParseRangeable();
    private ParseNode ParseStructuredReference(string tableName);
    private string ParseAsColumnQuantifier();
    private string ParseAsSpecialQuantifier();
    private ParseNode ParseNonRange(int savePointer);
    private string ParseAsName();
    private int GetSheetExtIx(SheetIdentifier sheetIden);
    private ParseNode CreateAreaRefParseNode(SheetIdentifier sheetIden, SimpleRangePart part1, SimpleRangePart part2);
    private static AreaReference CreateAreaRef(SimpleRangePart part1, SimpleRangePart part2);
    private SimpleRangePart ParseSimpleRangePart();
    private static Ptg ReduceRangeExpression(Ptg ptgA, Ptg ptgB);
    private SheetIdentifier ParseSheetName();
    private SheetIdentifier ParseSheetRange(string bookname, NameIdentifier sheet1Name);
    private bool IsUnquotedSheetNameChar(char ch);
    private void ResetPointer(int ptr);
    private bool IsValidCellReference(string str);
    private bool IsValidCellReference(ReadOnlySpan`1<char> str);
    private ParseNode Function(string name);
    private void AddName(string functionName);
    private ParseNode GetFunction(string name, Ptg namePtg, ParseNode[] args);
    private void ValidateNumArgs(int numArgs, FunctionMetadata fm);
    private static bool IsArgumentDelimiter(char ch);
    private ParseNode[] Arguments();
    private ParseNode PowerFactor();
    private ParseNode PercentFactor();
    private ParseNode ParseSimpleFactor();
    private ParseNode ParseUnary(bool isPlus);
    private ParseNode ParseArray();
    private void CheckRowLengths(Object[][] values2d, int nColumns);
    private Object[] ParseArrayRow();
    private object ParseArrayItem();
    private bool ParseBooleanLiteral();
    private static double ConvertArrayNumber(Ptg ptg, bool isPositive);
    private Ptg ParseNumber();
    private int ParseErrorLiteral();
    private static Ptg GetNumberPtgFromString(string number1, string number2, string exponent);
    private string ParseStringLiteral();
    private ParseNode Term();
    private ParseNode ComparisonExpression();
    private Ptg GetComparisonToken();
    private ParseNode ConcatExpression();
    private ParseNode AdditiveExpression();
    private void Parse();
    private ParseNode UnionExpression();
    private ParseNode IntersectionExpression();
    private Ptg[] GetRPNPtg(FormulaType formulaType);
}
public class NPOI.SS.Formula.FormulaRenderer : object {
    public static string ToFormulaString(IFormulaRenderingWorkbook book, Ptg[] ptgs);
    private static String[] GetOperands(Stack stack, int nOperands);
}
public class NPOI.SS.Formula.FormulaShifter : object {
    private int _externSheetIndex;
    private string _sheetName;
    private int _firstMovedIndex;
    private int _lastMovedIndex;
    private int _amountToMove;
    private int _srcSheetIndex;
    private int _dstSheetIndex;
    private SpreadsheetVersion _version;
    private ShiftMode _mode;
    private FormulaShifter(int externSheetIndex, string sheetName, int firstMovedIndex, int lastMovedIndex, int amountToMove, ShiftMode mode, SpreadsheetVersion version);
    private FormulaShifter(int srcSheetIndex, int dstSheetIndex);
    [ObsoleteAttribute("To be removed NPOI 2.8. deprecated As of 3.14 beta 1 (November 2015), replaced by CreateForRowShift(int, String, int, int, int, SpreadsheetVersion)")]
public static FormulaShifter CreateForRowShift(int externSheetIndex, string sheetName, int firstMovedRowIndex, int lastMovedRowIndex, int numberOfRowsToMove);
    public static FormulaShifter CreateForRowShift(int externSheetIndex, string sheetName, int firstMovedRowIndex, int lastMovedRowIndex, int numberOfRowsToMove, SpreadsheetVersion version);
    public static FormulaShifter CreateForRowCopy(int externSheetIndex, string sheetName, int firstMovedRowIndex, int lastMovedRowIndex, int numberOfRowsToMove, SpreadsheetVersion version);
    public static FormulaShifter CreateForSheetShift(int srcSheetIndex, int dstSheetIndex);
    public virtual string ToString();
    public bool AdjustFormula(Ptg[] ptgs, int currentExternSheetIx);
    private Ptg AdjustPtg(Ptg ptg, int currentExternSheetIx);
    private Ptg AdjustPtgDueToRowMove(Ptg ptg, int currentExternSheetIx);
    private Ptg AdjustPtgDueToRowCopy(Ptg ptg);
    private Ptg AdjustPtgDueToSheetMove(Ptg ptg);
    private Ptg RowMoveRefPtg(RefPtgBase rptg);
    private Ptg RowMoveAreaPtg(AreaPtgBase aptg);
    private Ptg RowCopyRefPtg(RefPtgBase rptg);
    private Ptg RowCopyAreaPtg(AreaPtgBase aptg);
    private static Ptg CreateDeletedRef(Ptg ptg);
}
public enum NPOI.SS.Formula.FormulaType : Enum {
    public int value__;
    [SingleValueAttribute("True")]
public static FormulaType Cell;
    [SingleValueAttribute("True")]
public static FormulaType Shared;
    [SingleValueAttribute("False")]
public static FormulaType Array;
    [SingleValueAttribute("True")]
public static FormulaType CondFormat;
    [SingleValueAttribute("False")]
public static FormulaType NamedRange;
    [SingleValueAttribute("False")]
public static FormulaType DataValidationList;
}
public class NPOI.SS.Formula.FormulaUsedBlankCellSet : object {
    private Hashtable _sheetGroupsByBookSheet;
    public bool IsEmpty { get; }
    public void AddCell(int bookIndex, int sheetIndex, int rowIndex, int columnIndex);
    private BlankCellSheetGroup GetSheetGroup(int bookIndex, int sheetIndex);
    public bool ContainsCell(BookSheetKey key, int rowIndex, int columnIndex);
    public bool get_IsEmpty();
}
internal class NPOI.SS.Formula.Function.FunctionDataBuilder : object {
    private int _maxFunctionIndex;
    private Dictionary`2<string, FunctionMetadata> _functionDataByName;
    private Dictionary`2<int, FunctionMetadata> _functionDataByIndex;
    private HashSet`1<int> _mutatingFunctionIndexes;
    public FunctionDataBuilder(int sizeEstimate);
    public void Add(int functionIndex, string functionName, int minParams, int maxParams, byte returnClassCode, Byte[] parameterClassCodes, bool hasFootnote);
    public FunctionMetadataRegistry Build();
}
public class NPOI.SS.Formula.Function.FunctionMetadata : object {
    private int _index;
    private string _name;
    private int _minParams;
    private int _maxParams;
    private byte _returnClassCode;
    private Byte[] _parameterClassCodes;
    private static short FUNCTION_MAX_PARAMS;
    public int Index { get; }
    public string Name { get; }
    public int MinParams { get; }
    public int MaxParams { get; }
    public bool HasFixedArgsLength { get; }
    public byte ReturnClassCode { get; }
    public Byte[] ParameterClassCodes { get; }
    public bool HasUnlimitedVarags { get; }
    internal FunctionMetadata(int index, string name, int minParams, int maxParams, byte returnClassCode, Byte[] parameterClassCodes);
    public int get_Index();
    public string get_Name();
    public int get_MinParams();
    public int get_MaxParams();
    public bool get_HasFixedArgsLength();
    public byte get_ReturnClassCode();
    public Byte[] get_ParameterClassCodes();
    public bool get_HasUnlimitedVarags();
    public virtual string ToString();
}
internal class NPOI.SS.Formula.Function.FunctionMetadataReader : object {
    private static string METADATA_FILE_NAME;
    private static string ELLIPSIS;
    private static string TAB_DELIM_PATTERN;
    private static string SPACE_DELIM_PATTERN;
    private static Byte[] EMPTY_BYTE_ARRAY;
    private static String[] DIGIT_ENDING_FUNCTION_NAMES;
    private static List`1<string> DIGIT_ENDING_FUNCTION_NAMES_Set;
    private static FunctionMetadataReader();
    public static FunctionMetadataRegistry CreateRegistry();
    private static void ProcessLine(FunctionDataBuilder fdb, string line);
    private static byte ParseReturnTypeCode(string code);
    private static Byte[] ParseOperandTypeCodes(string codes);
    private static bool IsDash(string codes);
    private static byte ParseOperandTypeCode(string code);
    private static void ValidateFunctionName(string functionName);
    private static int ParseInt(string valStr);
}
public class NPOI.SS.Formula.Function.FunctionMetadataRegistry : object {
    public static string FUNCTION_NAME_IF;
    public static int FUNCTION_INDEX_IF;
    public static short FUNCTION_INDEX_SUM;
    public static int FUNCTION_INDEX_CHOOSE;
    public static short FUNCTION_INDEX_INDIRECT;
    public static short FUNCTION_INDEX_EXTERNAL;
    private static FunctionMetadataRegistry _instance;
    private FunctionMetadata[] _functionDataByIndex;
    private Dictionary`2<string, FunctionMetadata> _functionDataByName;
    public FunctionMetadataRegistry(FunctionMetadata[] functionDataByIndex, Dictionary`2<string, FunctionMetadata> functionDataByName);
    private static FunctionMetadataRegistry GetInstance();
    public ICollection GetAllFunctionNames();
    public static FunctionMetadata GetFunctionByIndex(int index);
    private FunctionMetadata GetFunctionByIndexInternal(int index);
    public static short LookupIndexByName(string name);
    private FunctionMetadata GetFunctionByNameInternal(string name);
    public static FunctionMetadata GetFunctionByName(string name);
}
public class NPOI.SS.Formula.Functions.Abs : OneArg {
    public virtual double Evaluate(double d);
}
public interface NPOI.SS.Formula.Functions.Accumulator {
    public abstract virtual double Accumulate(double x, double y);
}
public class NPOI.SS.Formula.Functions.Acos : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Acosh : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Address : object {
    public static int REF_ABSOLUTE;
    public static int REF_ROW_ABSOLUTE_COLUMN_RELATIVE;
    public static int REF_ROW_RELATIVE_RELATIVE_ABSOLUTE;
    public static int REF_RELATIVE;
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public abstract class NPOI.SS.Formula.Functions.AggregateFunction : MultiOperandNumericFunction {
    public static Function AVEDEV;
    public static Function AVERAGE;
    public static Function DEVSQ;
    public static Function LARGE;
    public static Function MAX;
    public static Function MEDIAN;
    public static Function MIN;
    public static Function PRODUCT;
    public static Function SMALL;
    public static Function STDEV;
    public static Function SUM;
    public static Function SUMSQ;
    public static Function VAR;
    public static Function VARP;
    public static Function PERCENTILE;
    private static AggregateFunction();
    public static Function SubtotalInstance(Function func);
}
public class NPOI.SS.Formula.Functions.And : BooleanFunction {
    protected bool InitialResultValue { get; }
    protected virtual bool get_InitialResultValue();
    protected virtual bool PartialEvaluate(bool cumulativeResult, bool currentValue);
}
public class NPOI.SS.Formula.Functions.Areas : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public interface NPOI.SS.Formula.Functions.ArrayFunction {
    public abstract virtual ValueEval EvaluateArray(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Asin : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Asinh : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Atan : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Atan2 : TwoArg {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.Atanh : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.AVEDEV : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.AVERAGE : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.AverageIf : object {
    public static FreeRefFunction instance;
    private static AverageIf();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private ValueEval GetSumRange(ValueEval[] args);
}
public class NPOI.SS.Formula.Functions.AverageIfs : object {
    public static FreeRefFunction instance;
    private static AverageIfs();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private void ValidateCriteriaRanges(AreaEval[] criteriaRanges, AreaEval avgRange);
    private static double GetAvgFromMatchingCells(AreaEval[] ranges, IMatchPredicate[] predicates, AreaEval aeAvg);
    private static Nullable`1<double> Accumulate(AreaEval aeSum, int relRowIndex, int relColIndex);
    private static AreaEval ConvertRangeArg(ValueEval eval);
}
public abstract class NPOI.SS.Formula.Functions.Baseifs : object {
    public abstract virtual bool HasInitialRange();
    public abstract virtual IAggregator CreateAggregator();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static void validateCriteriaRanges(AreaEval sumRange, AreaEval[] criteriaRanges);
    private static void validateCriteria(IMatchPredicate[] criteria);
    private static ValueEval aggregateMatchingCells(IAggregator aggregator, AreaEval sumRange, AreaEval[] ranges, IMatchPredicate[] predicates);
    protected static AreaEval convertRangeArg(ValueEval eval);
}
public class NPOI.SS.Formula.Functions.BaseNumberUtils : object {
    public static double ConvertToDecimal(string value, int base1, int maxNumberOfPlaces);
    private static double GetTwoComplement(double base1, double maxNumberOfPlaces, double decimalValue);
}
public class NPOI.SS.Formula.Functions.BesselJ : Fixed2ArgFunction {
    public static FreeRefFunction instance;
    private static BesselJ();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double EvaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Bin2Dec : Fixed1ArgFunction {
    public static FreeRefFunction instance;
    private static Bin2Dec();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval numberVE);
    private int getDecimalValue(string unsigned);
    private static string toggleBits(string s);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
internal class NPOI.SS.Formula.Functions.BinarySearchIndexes : object {
    private int _lowIx;
    private int _highIx;
    public BinarySearchIndexes(int highIx);
    public int GetMidIx();
    public int GetLowIx();
    public int GetHighIx();
    public void NarrowSearch(int midIx, bool isLessThan);
}
public abstract class NPOI.SS.Formula.Functions.BooleanFunction : object {
    protected bool InitialResultValue { get; }
    protected abstract virtual bool get_InitialResultValue();
    protected abstract virtual bool PartialEvaluate(bool cumulativeResult, bool currentValue);
    private bool Calculate(ValueEval[] args);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRow, int srcCol);
}
internal class NPOI.SS.Formula.Functions.BooleanLookupComparer : LookupValueComparerBase {
    private bool _value;
    public BooleanLookupComparer(BoolEval be);
    protected virtual CompareResult CompareSameType(ValueEval other);
    protected virtual string GetValueAsString();
}
public class NPOI.SS.Formula.Functions.CalendarFieldFunction : Fixed1ArgFunction {
    public static int YEAR_ID;
    public static int MONTH_ID;
    public static int DAY_OF_MONTH_ID;
    public static int HOUR_OF_DAY_ID;
    public static int MINUTE_ID;
    public static int SECOND_ID;
    public static Function YEAR;
    public static Function MONTH;
    public static Function DAY;
    public static Function HOUR;
    public static Function MINUTE;
    public static Function SECOND;
    private int _dateFieldId;
    private CalendarFieldFunction(int dateFieldId);
    private static CalendarFieldFunction();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    private int GetCalField(double serialDate);
}
public class NPOI.SS.Formula.Functions.Ceiling : TwoArg {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.CeilingMath : FloorCeilingMathBase {
    public static CeilingMath Instance;
    private static CeilingMath();
    protected virtual double EvaluateMajorDirection(double number);
    protected virtual double EvaluateAlternativeDirection(double number);
}
public class NPOI.SS.Formula.Functions.Cell : object {
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.CHAR : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Functions.Choose : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public static int EvaluateFirstArg(ValueEval arg0, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Clean : SingleArgTextFunc {
    public virtual ValueEval Evaluate(string arg);
}
public class NPOI.SS.Formula.Functions.Code : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval textArg);
}
public class NPOI.SS.Formula.Functions.Column : object {
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Columns : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Functions.Combin : TwoArg {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.CompareResult : object {
    private bool _isTypeMismatch;
    private bool _isLessThan;
    private bool _isEqual;
    private bool _isGreaterThan;
    public static CompareResult TypeMismatch;
    public static CompareResult LessThan;
    public static CompareResult Equal;
    public static CompareResult GreaterThan;
    public bool IsTypeMismatch { get; }
    public bool IsLessThan { get; }
    public bool IsEqual { get; }
    public bool IsGreaterThan { get; }
    private string FormatAsString { get; }
    private CompareResult(bool IsTypeMismatch, int simpleCompareResult);
    private static CompareResult();
    public static CompareResult ValueOf(int simpleCompareResult);
    public static CompareResult ValueOf(bool matches);
    public bool get_IsTypeMismatch();
    public bool get_IsLessThan();
    public bool get_IsEqual();
    public bool get_IsGreaterThan();
    public virtual string ToString();
    private string get_FormatAsString();
}
public class NPOI.SS.Formula.Functions.Complex : Var2or3ArgFunction {
    public static FreeRefFunction Instance;
    public static string DEFAULT_SUFFIX;
    public static string SUPPORTED_SUFFIX;
    private static Complex();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval real_num, ValueEval i_num);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval real_num, ValueEval i_num, ValueEval suffix);
    private bool isDoubleAnInt(double number);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Concat : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Concatenate : TextFunction {
    public virtual ValueEval EvaluateFunc(ValueEval[] args, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.Cos : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Cosh : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Count : object {
    private IMatchPredicate _predicate;
    private static IMatchPredicate defaultPredicate;
    private static IMatchPredicate subtotalPredicate;
    private Count(IMatchPredicate criteriaPredicate);
    private static Count();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    public static Count SubtotalInstance();
}
public class NPOI.SS.Formula.Functions.Counta : object {
    private IMatchPredicate _predicate;
    private static IMatchPredicate defaultPredicate;
    private static IMatchPredicate subtotalPredicate;
    private Counta(IMatchPredicate criteriaPredicate);
    private static Counta();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    public static Counta SubtotalInstance();
}
public class NPOI.SS.Formula.Functions.Countblank : Fixed1ArgFunction {
    private static IMatchPredicate predicate;
    private static Countblank();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Functions.Countif : Fixed2ArgFunction {
    private double CountMatchingCellsInArea(ValueEval rangeArg, IMatchPredicate criteriaPredicate);
    private static ValueEval EvaluateCriteriaArg(ValueEval arg, int srcRowIndex, int srcColumnIndex);
    private static IMatchPredicate CreateGeneralMatchPredicate(StringEval stringEval);
    public static IMatchPredicate CreateCriteriaPredicate(ValueEval arg, int srcRowIndex, int srcColumnIndex);
    private static ErrorEval ParseError(string value);
    public static Nullable`1<bool> ParseBoolean(string strRep);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public class NPOI.SS.Formula.Functions.Countifs : Baseifs {
    public static FreeRefFunction instance;
    private static Countifs();
    public virtual bool HasInitialRange();
    public virtual IAggregator CreateAggregator();
}
internal class NPOI.SS.Formula.Functions.CountUtils : object {
    public static int CountMatchingCellsInRef(RefEval refEval, IMatchPredicate criteriaPredicate);
    public static int CountArg(ValueEval eval, IMatchPredicate criteriaPredicate);
    public static int CountMatchingCellsInArea(ThreeDEval areaEval, IMatchPredicate criteriaPredicate);
}
public class NPOI.SS.Formula.Functions.DateFunc : Fixed3ArgFunction {
    public static Function instance;
    private static DateFunc();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    public double Evaluate(int year, int month, int pDay);
    private int GetYear(double d);
}
public class NPOI.SS.Formula.Functions.DateValue : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval dateTextArg);
    private int parseMonth(string monthPart);
}
public class NPOI.SS.Formula.Functions.Days360 : Var2or3ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    private double Evaluate(double d0, double d1, bool method);
    private DateTime GetDate(double date);
    private Int32[] GetStartingDate(DateTime realStart, bool method);
    private static Int32[] GetEndingDate(DateTime realEnd, DateTime realStart, bool method);
    private static Int32[] GetEndingDate(DateTime realEnd, Int32[] startingDate, bool method);
    private DateTime GetEndingDateAccordingToStartingDate(double date, DateTime startingDate, bool method);
    private bool IsLastDayOfMonth(DateTime date);
    private DateTime GetFirstDayOfNextMonth(DateTime date);
}
public class NPOI.SS.Formula.Functions.Dec2Bin : Var1or2ArgFunction {
    public static FreeRefFunction instance;
    private static long MinValue;
    private static long MaxValue;
    private static int DEFAULT_PLACES_VALUE;
    private static Dec2Bin();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval numberVE, ValueEval placesVE);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval numberVE);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Dec2Hex : Var1or2ArgFunction {
    public static FreeRefFunction instance;
    private static long MinValue;
    private static long MaxValue;
    private static int DEFAULT_PLACES_VALUE;
    private static Dec2Hex();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval number, ValueEval places);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Degrees : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Delta : Fixed2ArgFunction {
    public static FreeRefFunction instance;
    private static NumberEval ONE;
    private static NumberEval ZERO;
    private static Delta();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.DEVSQ : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.DGet : object {
    private ValueEval result;
    public ValueEval Result { get; }
    public sealed virtual bool ProcessMatch(ValueEval eval);
    public sealed virtual ValueEval get_Result();
}
public class NPOI.SS.Formula.Functions.DMin : object {
    private ValueEval minimumValue;
    public ValueEval Result { get; }
    public sealed virtual bool ProcessMatch(ValueEval eval);
    public sealed virtual ValueEval get_Result();
}
public class NPOI.SS.Formula.Functions.Dollar : object {
    protected static double singleOperandEvaluate(ValueEval arg, int srcRowIndex, int srcColumnIndex);
    public static void checkValue(double result);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.DollarDe : Fixed2ArgFunction {
    public static FreeRefFunction instance;
    private static DollarDe();
    private static double evaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.DollarFr : Fixed2ArgFunction {
    public static FreeRefFunction instance;
    private static DollarFr();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double evaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.DStarRunner : object {
    private DStarAlgorithmEnum algoType;
    public DStarRunner(DStarAlgorithmEnum algorithm);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval database, ValueEval filterColumn, ValueEval conditionDatabase);
    private static int GetColumnForName(ValueEval nameValueEval, AreaEval db);
    private static int GetColumnForString(AreaEval db, string name);
    private static bool FullFillsConditions(AreaEval db, int row, AreaEval cdb);
    private static bool testNormalCondition(ValueEval value, ValueEval condition);
    private static bool testNumericCondition(ValueEval valueEval, Operator op, string condition);
    private static Nullable`1<double> GetNumberFromValueEval(ValueEval value);
    private static ValueEval ResolveReference(AreaEval db, int dbRow, int dbCol);
}
public class NPOI.SS.Formula.Functions.EDate : object {
    public static FreeRefFunction Instance;
    private static EDate();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private double GetValue(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.EOMonth : object {
    public static FreeRefFunction instance;
    private static EOMonth();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Errortype : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    private int TranslateErrorCodeToErrorTypeValue(int errorCode);
}
public class NPOI.SS.Formula.Functions.Even : OneArg {
    private static long PARITY_MASK;
    public virtual double Evaluate(double d);
    private static long calcEven(double d);
}
public class NPOI.SS.Formula.Functions.Exact : TextFunction {
    public virtual ValueEval EvaluateFunc(ValueEval[] args, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.Exp : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Fact : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.FactDouble : Fixed1ArgFunction {
    public static FreeRefFunction instance;
    private static Dictionary`2<int, BigInteger> cache;
    private static FactDouble();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval numberVE);
    public static BigInteger factorial(int n);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.False : Fixed0ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Finance : object {
    public static double PMT(double r, int nper, double pv, double fv, int type);
    public static double PMT(double r, int nper, double pv, double fv);
    public static double PMT(double r, int nper, double pv);
    public static double IPMT(double r, int per, int nper, double pv, double fv, int type);
    public static double IPMT(double r, int per, int nper, double pv, double fv);
    public static double IPMT(double r, int per, int nper, double pv);
    public static double PPMT(double r, int per, int nper, double pv, double fv, int type);
    public static double PPMT(double r, int per, int nper, double pv, double fv);
    public static double PPMT(double r, int per, int nper, double pv);
    public static double FV(double r, int nper, double pmt, double pv, int type);
    public static double FV(double r, int nper, double c, double pv);
}
public abstract class NPOI.SS.Formula.Functions.FinanceFunction : object {
    private static ValueEval DEFAULT_ARG3;
    private static ValueEval DEFAULT_ARG4;
    public static Function FV;
    public static Function NPER;
    public static Function PMT;
    public static Function PV;
    private static FinanceFunction();
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2, ValueEval arg3);
    public ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2, ValueEval arg3, ValueEval arg4);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public double Evaluate(Double[] ds);
    public abstract virtual double Evaluate(double rate, double arg1, double arg2, double arg3, bool type);
}
public class NPOI.SS.Formula.Functions.FinanceLib : object {
    public static double fv(double r, double n, double y, double p, bool t);
    public static double pv(double r, double n, double y, double f, bool t);
    public static double npv(double r, Double[] cfs);
    public static double pmt(double r, double n, double p, double f, bool t);
    public static double nper(double r, double y, double p, double f, bool t);
}
public class NPOI.SS.Formula.Functions.Fixed : object {
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    private ValueEval doFixed(ValueEval numberParam, ValueEval placesParam, ValueEval skipThousandsSeparatorParam, int srcRowIndex, int srcColumnIndex);
}
public abstract class NPOI.SS.Formula.Functions.Fixed0ArgFunction : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
}
public abstract class NPOI.SS.Formula.Functions.Fixed1ArgFunction : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public abstract class NPOI.SS.Formula.Functions.Fixed2ArgFunction : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public abstract class NPOI.SS.Formula.Functions.Fixed3ArgFunction : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
}
public abstract class NPOI.SS.Formula.Functions.Fixed4ArgFunction : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2, ValueEval arg3);
}
public class NPOI.SS.Formula.Functions.Floor : TwoArg {
    private static double ZERO;
    public virtual double Evaluate(double d0, double d1);
}
public abstract class NPOI.SS.Formula.Functions.FloorCeilingMathBase : object {
    private static int SignificantDigits;
    private static bool UseHighPrecisionCalculation;
    private static int SignificantDigitsForHighPrecision;
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    public double Evaluate(double number, double significance, bool mode);
    protected abstract virtual double EvaluateMajorDirection(double number);
    protected abstract virtual double EvaluateAlternativeDirection(double number);
}
public class NPOI.SS.Formula.Functions.FloorMath : FloorCeilingMathBase {
    public static FloorMath Instance;
    private static FloorMath();
    protected virtual double EvaluateMajorDirection(double number);
    protected virtual double EvaluateAlternativeDirection(double number);
}
public class NPOI.SS.Formula.Functions.Forecast : Fixed3ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    private static Double[] GetNumericArray(ValueEval arg);
    private static ValueVector CreateValueVector(ValueEval arg);
}
public interface NPOI.SS.Formula.Functions.FreeRefFunction {
    public abstract virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public interface NPOI.SS.Formula.Functions.Function {
    public abstract virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public interface NPOI.SS.Formula.Functions.Function0Arg {
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
}
public interface NPOI.SS.Formula.Functions.Function1Arg {
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public interface NPOI.SS.Formula.Functions.Function2Arg {
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public interface NPOI.SS.Formula.Functions.Function3Arg {
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
}
public interface NPOI.SS.Formula.Functions.Function4Arg {
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2, ValueEval arg3);
}
public class NPOI.SS.Formula.Functions.Fv : FinanceFunction {
    public virtual double Evaluate(double rate, double arg1, double arg2, double arg3, bool type);
}
public class NPOI.SS.Formula.Functions.Hex2Dec : Fixed1ArgFunction {
    public static FreeRefFunction instance;
    private static int HEXADECIMAL_BASE;
    private static int MAX_NUMBER_OF_PLACES;
    private static Hex2Dec();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval numberVE);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Hlookup : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    private ValueVector CreateResultColumnVector(AreaEval tableArray, int rowIndex);
}
public class NPOI.SS.Formula.Functions.Hyperlink : Var1or2ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public interface NPOI.SS.Formula.Functions.I_MatchAreaPredicate {
    public abstract virtual bool Matches(TwoDEval x, int rowIndex, int columnIndex);
}
public interface NPOI.SS.Formula.Functions.IDStarAlgorithm {
    public ValueEval Result { get; }
    public abstract virtual bool ProcessMatch(ValueEval Eval);
    public abstract virtual ValueEval get_Result();
}
public class NPOI.SS.Formula.Functions.IfFunc : Var2or3ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    public static bool EvaluateFirstArg(ValueEval arg, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.Imaginary : Fixed1ArgFunction {
    public static FreeRefFunction instance;
    public static string GROUP1_REAL_SIGN_REGEX;
    public static string GROUP2_REAL_INTEGER_OR_DOUBLE_REGEX;
    public static string GROUP3_IMAGINARY_SIGN_REGEX;
    public static string GROUP4_IMAGINARY_INTEGER_OR_DOUBLE_REGEX;
    public static string GROUP5_IMAGINARY_GROUP_REGEX;
    public static Regex COMPLEX_NUMBER_PATTERN;
    public static int GROUP1_REAL_SIGN;
    public static int GROUP2_IMAGINARY_INTEGER_OR_DOUBLE;
    public static int GROUP3_IMAGINARY_SIGN;
    public static int GROUP4_IMAGINARY_INTEGER_OR_DOUBLE;
    private static Imaginary();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval inumberVE);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public interface NPOI.SS.Formula.Functions.IMatchPredicate {
    public abstract virtual bool Matches(ValueEval x);
}
public class NPOI.SS.Formula.Functions.ImReal : Fixed1ArgFunction {
    public static FreeRefFunction instance;
    private static ImReal();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval inumberVE);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Index : object {
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2, ValueEval arg3);
    private static TwoDEval ConvertFirstArg(ValueEval arg0);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    private static ValueEval GetValueFromArea(TwoDEval ae, int pRowIx, int pColumnIx);
    [ObsoleteAttribute]
private static ValueEval GetValueFromArea(AreaEval ae, int pRowIx, int pColumnIx, bool colArgWasPassed, int srcRowIx, int srcColIx);
    private static int ResolveIndexArg(ValueEval arg, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.Indirect : object {
    public static FreeRefFunction instance;
    private static Indirect();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static bool EvaluateBooleanArg(ValueEval arg, OperationEvaluationContext ec);
    private static ValueEval EvaluateIndirect(OperationEvaluationContext ec, string text, bool isA1style);
    private static String[] ParseWorkbookAndSheetName(string text);
    private static string UnescapeString(string text);
    private static bool CanTrim(string text);
}
public class NPOI.SS.Formula.Functions.Int : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Intercept : Fixed2ArgFunction {
    private LinearRegressionFunction func;
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public class NPOI.SS.Formula.Functions.IPMT : NumericFunction {
    protected virtual double Eval(ValueEval[] args, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.Irr : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public static double irr(Double[] income);
    public static double irr(Double[] values, double guess);
}
public class NPOI.SS.Formula.Functions.Isblank : LogicalFunction {
    protected virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Iserr : LogicalFunction {
    protected virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Iserror : LogicalFunction {
    protected virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Islogical : LogicalFunction {
    protected virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Isna : LogicalFunction {
    protected virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Isnontext : LogicalFunction {
    protected virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Isnumber : LogicalFunction {
    protected virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Isref : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Functions.Istext : LogicalFunction {
    protected virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.LARGE : AggregateFunction {
    protected internal virtual double Evaluate(Double[] ops);
}
public class NPOI.SS.Formula.Functions.LargeSmall : Fixed2ArgFunction {
    private bool _isLarge;
    protected LargeSmall(bool isLarge);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public class NPOI.SS.Formula.Functions.LeftRight : Var1or2ArgFunction {
    private static ValueEval DEFAULT_ARG1;
    private bool _isLeft;
    public LeftRight(bool isLeft);
    private static LeftRight();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public class NPOI.SS.Formula.Functions.Len : SingleArgTextFunc {
    public virtual ValueEval Evaluate(string arg);
}
public class NPOI.SS.Formula.Functions.LinearRegressionFunction : Fixed2ArgFunction {
    public FUNCTION function;
    public LinearRegressionFunction(FUNCTION function);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    private double EvaluateInternal(ValueVector x, ValueVector y, int size);
    private ValueVector CreateValueVector(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Ln : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Log : Var1or2ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public class NPOI.SS.Formula.Functions.Log10 : OneArg {
    public virtual double Evaluate(double d);
}
public abstract class NPOI.SS.Formula.Functions.LogicalFunction : Fixed1ArgFunction {
    public static Function ISLOGICAL;
    public static Function ISNONTEXT;
    public static Function ISNUMBER;
    public static Function ISTEXT;
    public static Function ISBLANK;
    public static Function ISERROR;
    public static Function ISNA;
    public static Function ISREF;
    public static Function ISERR;
    private static LogicalFunction();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    protected abstract virtual bool Evaluate(ValueEval arg);
}
public class NPOI.SS.Formula.Functions.Lookup : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    private static ValueVector CreateVector(AreaEval ae);
}
internal class NPOI.SS.Formula.Functions.LookupUtils : object {
    private static Dictionary`2<int, MatchMode> matchModeMap;
    private static Dictionary`2<int, SearchMode> searchModeMap;
    private static LookupUtils();
    public static MatchMode GetMatchMode(int m);
    public static SearchMode GetSearchMode(int s);
    public static ValueVector CreateRowVector(TwoDEval tableArray, int relativeRowIndex);
    public static ValueVector CreateColumnVector(TwoDEval tableArray, int relativeColumnIndex);
    public static ValueVector CreateVector(TwoDEval ae);
    public static ValueVector CreateVector(RefEval re);
    public static int ResolveRowOrColIndexArg(ValueEval rowColIndexArg, int srcCellRow, int srcCellCol);
    public static AreaEval ResolveTableArrayArg(ValueEval eval);
    public static bool ResolveRangeLookupArg(ValueEval rangeLookupArg, int srcCellRow, int srcCellCol);
    public static int lookupFirstIndexOfValue(ValueEval lookupValue, ValueVector vector, bool isRangeLookup);
    public static int XlookupIndexOfValue(ValueEval lookupValue, ValueVector vector, MatchMode matchMode, SearchMode searchMode);
    private static int lookupFirstIndexOfValue(LookupValueComparer lookupComparer, ValueVector vector, MatchMode matchMode);
    private static int lookupLastIndexOfValue(LookupValueComparer lookupComparer, ValueVector vector, MatchMode matchMode);
    private static int PerformBinarySearch(ValueVector vector, LookupValueComparer lookupComparer);
    private static int HandleMidValueTypeMismatch(LookupValueComparer lookupComparer, ValueVector vector, BinarySearchIndexes bsi, int midIx);
    private static int FindLastIndexInRunOfEqualValues(LookupValueComparer lookupComparer, ValueVector vector, int firstFoundIndex, int maxIx);
    public static LookupValueComparer CreateLookupComparer(ValueEval lookupValue, bool matchExact, bool isMatchFunction);
    private static LookupValueComparer CreateTolerantLookupComparer(ValueEval lookupValue, bool matchExact, bool isMatchFunction);
}
public interface NPOI.SS.Formula.Functions.LookupValueComparer {
    public abstract virtual CompareResult CompareTo(ValueEval other);
}
internal abstract class NPOI.SS.Formula.Functions.LookupValueComparerBase : object {
    private Type _targetType;
    protected LookupValueComparerBase(ValueEval targetValue);
    public sealed virtual CompareResult CompareTo(ValueEval other);
    public virtual string ToString();
    protected abstract virtual CompareResult CompareSameType(ValueEval other);
    protected abstract virtual string GetValueAsString();
}
public class NPOI.SS.Formula.Functions.Lower : SingleArgTextFunc {
    public virtual ValueEval Evaluate(string arg);
}
public class NPOI.SS.Formula.Functions.Match : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    private static ValueVector EvaluateLookupRange(ValueEval eval);
    private static double EvaluateMatchTypeArg(ValueEval arg, int srcCellRow, int srcCellCol);
    private static int FindIndexOfValue(ValueEval lookupValue, ValueVector lookupRange, bool matchExact, bool FindLargestLessThanOrEqual);
    private static LookupValueComparer CreateLookupComparer(ValueEval lookupValue, bool matchExact);
}
public class NPOI.SS.Formula.Functions.MathX : object {
    public static double Round(double n, int p);
    public static double RoundUp(double n, int p);
    public static double RoundDown(double n, int p);
    public static short Sign(double d);
    public static double Average(Double[] values);
    public static double Sum(Double[] values);
    public static double Sumsq(Double[] values);
    public static double Product(Double[] values);
    public static double Min(Double[] values);
    public static double Max(Double[] values);
    public static double Floor(double n, double s);
    public static double Ceiling(double n, double s);
    public static double Factorial(int n);
    public static double Mod(double n, double d);
    public static double Acosh(double d);
    public static double Asinh(double d);
    public static double Atanh(double d);
    public static double Cosh(double d);
    public static double Sinh(double d);
    public static double Tanh(double d);
    public static double SumProduct(Double[][] arrays);
    public static double Sumx2my2(Double[] xarr, Double[] yarr);
    public static double Sumx2py2(Double[] xarr, Double[] yarr);
    public static double Sumxmy2(Double[] xarr, Double[] yarr);
    public static double NChooseK(int n, int k);
}
public class NPOI.SS.Formula.Functions.MatrixFunction : object {
    public static Function MDETERM;
    public static Function TRANSPOSE;
    public static Function MMULT;
    public static Function MINVERSE;
    private static MatrixFunction();
    private static Double[] extractDoubleArray(Double[0...,0...] matrix);
    public static void CheckValues(Double[] results);
    private static Double[0...,0...] fillDoubleArray(Double[] vector, int rows, int cols);
}
public class NPOI.SS.Formula.Functions.MAX : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.Maxa : MinaMaxa {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.Mdeterm : OneArrayArg {
    private MutableValueCollector instance;
    protected virtual Double[] CollectValues(ValueEval arg);
    protected virtual Double[0...,0...] Evaluate(Double[0...,0...] d1);
}
public class NPOI.SS.Formula.Functions.MEDIAN : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.Mid : TextFunction {
    public virtual ValueEval EvaluateFunc(ValueEval[] args, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.MIN : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.Mina : MinaMaxa {
    protected internal virtual double Evaluate(Double[] values);
}
public abstract class NPOI.SS.Formula.Functions.MinaMaxa : MultiOperandNumericFunction {
    public static Function MAXA;
    public static Function MINA;
    private static MinaMaxa();
}
public class NPOI.SS.Formula.Functions.Minverse : OneArrayArg {
    private MutableValueCollector instance;
    protected virtual Double[] CollectValues(ValueEval arg);
    protected virtual Double[0...,0...] Evaluate(Double[0...,0...] d1);
}
public class NPOI.SS.Formula.Functions.Mirr : MultiOperandNumericFunction {
    protected int MaxNumOperands { get; }
    protected virtual int get_MaxNumOperands();
    protected internal virtual double Evaluate(Double[] values);
    private static double mirr(Double[] in1, double financeRate, double reinvestRate);
}
public class NPOI.SS.Formula.Functions.MMulti : TwoArrayArg {
    private MutableValueCollector instance;
    protected virtual Double[] CollectValues(ValueEval arg);
    protected virtual Double[0...,0...] Evaluate(Double[0...,0...] d1, Double[0...,0...] d2);
}
public class NPOI.SS.Formula.Functions.Mod : TwoArg {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.Mode : object {
    public static double Evaluate(Double[] v);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    private static void CollectValues(ValueEval arg, IList temp);
    private static void CollectValue(ValueEval arg, IList temp, bool mustBeNumber);
}
public abstract class NPOI.SS.Formula.Functions.MultiOperandNumericFunction : object {
    private static Double[] EMPTY_DOUBLE_ARRAY;
    private bool _isReferenceBoolCounted;
    private bool _isBlankCounted;
    private static int DEFAULT_MAX_NUM_OPERANDS;
    protected int MaxNumOperands { get; }
    public bool IsSubtotalCounted { get; }
    protected MultiOperandNumericFunction(bool isReferenceBoolCounted, bool isBlankCounted);
    private static MultiOperandNumericFunction();
    protected internal abstract virtual double Evaluate(Double[] values);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    protected virtual int get_MaxNumOperands();
    public virtual bool get_IsSubtotalCounted();
    private void CollectValues(ValueEval operand, DoubleList temp);
    private void CollectValue(ValueEval ve, bool isViaReference, DoubleList temp);
    protected Double[] GetNumberArray(ValueEval[] operands);
    protected static bool AreSubArraysConsistent(Double[][] values);
}
public class NPOI.SS.Formula.Functions.Na : Fixed0ArgFunction {
    public virtual ValueEval Evaluate(int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.NormDist : Fixed4ArgFunction {
    public static NormDist instance;
    private static NormDist();
    internal static double probability(double x, double mean, double stdev, bool cumulative);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2, ValueEval arg3, ValueEval arg4);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double evaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.NormInv : Fixed3ArgFunction {
    public static NormInv instance;
    private static NormInv();
    internal static double inverse(double probability, double mean, double stdev);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2, ValueEval arg3);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double evaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.NormSDist : Fixed1ArgFunction {
    public static NormSDist instance;
    private static NormSDist();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double evaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.NormSInv : Fixed1ArgFunction {
    public static NormSInv instance;
    private static NormSInv();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double evaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Not : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Functions.NotImplementedFunction : object {
    private string _functionName;
    public string FunctionName { get; }
    public NotImplementedFunction(string name);
    public sealed virtual ValueEval Evaluate(ValueEval[] operands, int srcRow, int srcCol);
    public string get_FunctionName();
}
public class NPOI.SS.Formula.Functions.Now : Fixed0ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Nper : FinanceFunction {
    public virtual double Evaluate(double rate, double arg1, double arg2, double arg3, bool type);
}
public class NPOI.SS.Formula.Functions.Npv : object {
    [ObsoleteAttribute]
public ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    [ObsoleteAttribute]
public ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    [ObsoleteAttribute]
public ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2, ValueEval arg3);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    private static double Evaluate(double rate, Double[] ds);
}
public abstract class NPOI.SS.Formula.Functions.NumberListFuncBase : object {
    [CompilerGeneratedAttribute]
private bool <AllowEmptyList>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueEval <ErrorOnEmptyList>k__BackingField;
    public bool AllowEmptyList { get; public set; }
    public ValueEval ErrorOnEmptyList { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowEmptyList();
    [CompilerGeneratedAttribute]
public void set_AllowEmptyList(bool value);
    [CompilerGeneratedAttribute]
public ValueEval get_ErrorOnEmptyList();
    [CompilerGeneratedAttribute]
public void set_ErrorOnEmptyList(ValueEval value);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    public abstract virtual double CalculateFromNumberList(List`1<double> list);
}
public class NPOI.SS.Formula.Functions.NumberValueFunction : object {
    public static FreeRefFunction instance;
    private static NumberValueFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static void checkValue(double result);
}
public abstract class NPOI.SS.Formula.Functions.NumericFunction : object {
    public static double TEN;
    public static double LOG_10_TO_BASE_e;
    public static double E;
    public static double PI;
    public static double ZERO;
    public static Function ABS;
    public static Function COS;
    public static Function COSH;
    public static Function ACOS;
    public static Function ACOSH;
    public static Function ASIN;
    public static Function ASINH;
    public static Function SIN;
    public static Function SINH;
    public static Function TAN;
    public static Function TANH;
    public static Function ATAN;
    public static Function ATANH;
    public static Function ATAN2;
    public static Function DEGREES;
    public static Function DOLLAR;
    public static Function EXP;
    public static Function FACT;
    public static Function INT;
    public static Function LN;
    public static Function LOG10;
    public static Function RADIANS;
    public static Function SIGN;
    public static Function SQRT;
    public static Function CEILING;
    public static Function COMBIN;
    public static Function FLOOR;
    public static Function MOD;
    public static Function POWER;
    public static Function ROUND;
    public static Function ROUNDDOWN;
    public static Function ROUNDUP;
    public static Function LOG;
    public static Function TRUNC;
    public static Function POISSON;
    private static NumericFunction();
    public static double SingleOperandEvaluate(ValueEval arg, int srcCellRow, int srcCellCol);
    public static void CheckValue(double result);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    protected abstract virtual double Eval(ValueEval[] evals, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.Oct2Dec : Fixed1ArgFunction {
    public static FreeRefFunction instance;
    private static int MAX_NUMBER_OF_PLACES;
    private static int OCTAL_BASE;
    private static Oct2Dec();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval numberVE);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Odd : OneArg {
    private static long PARITY_MASK;
    public virtual double Evaluate(double d);
    private static long CalcOdd(double d);
}
public class NPOI.SS.Formula.Functions.Offset : object {
    private static int LAST_VALID_ROW_INDEX;
    private static int LAST_VALID_COLUMN_INDEX;
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    private static AreaEval CreateOffset(BaseRef baseRef, LinearOffsetRange orRow, LinearOffsetRange orCol);
    private static BaseRef EvaluateBaseRef(ValueEval eval);
    public static int EvaluateIntArg(ValueEval eval, int srcCellRow, int srcCellCol);
    public static int ConvertDoubleToInt(double d);
    private static double EvaluateDoubleArg(ValueEval eval, int srcCellRow, int srcCellCol);
}
public abstract class NPOI.SS.Formula.Functions.OneArg : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    protected double Eval(ValueEval[] args, int srcCellRow, short srcCellCol);
    public abstract virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Or : BooleanFunction {
    protected bool InitialResultValue { get; }
    protected virtual bool get_InitialResultValue();
    protected virtual bool PartialEvaluate(bool cumulativeResult, bool currentValue);
}
public class NPOI.SS.Formula.Functions.Percentile : Fixed2ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public class NPOI.SS.Formula.Functions.PercentRank : object {
    public static Function instance;
    private static PercentRank();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    private ValueEval calculateRank(List`1<double> numbers, double x, int significance, bool recurse);
    private List`1<ValueEval> getValues(ValueEval eval, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Pi : Fixed0ArgFunction {
    private static NumberEval PI_EVAL;
    private static Pi();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Pmt : FinanceFunction {
    public virtual double Evaluate(double rate, double arg1, double arg2, double arg3, bool type);
}
public class NPOI.SS.Formula.Functions.Poisson : Fixed3ArgFunction {
    private static double DEFAULT_RETURN_RESULT;
    private Int64[] FACTORIALS;
    private bool IsDefaultResult(double x, double mean);
    private bool CheckArgument(double aDouble);
    private double probability(int k, double lambda);
    private double cumulativeProbability(int x, double lambda);
    public long Factorial(int n);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
}
public class NPOI.SS.Formula.Functions.Power : TwoArg {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.PPMT : NumericFunction {
    protected virtual double Eval(ValueEval[] args, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.PRODUCT : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.Proper : SingleArgTextFunc {
    public virtual ValueEval Evaluate(string text);
}
public class NPOI.SS.Formula.Functions.Pv : FinanceFunction {
    public virtual double Evaluate(double rate, double arg1, double arg2, double arg3, bool type);
}
public class NPOI.SS.Formula.Functions.Quotient : Fixed2ArgFunction {
    public static FreeRefFunction instance;
    private static Quotient();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval venumerator, ValueEval vedenominator);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Radians : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Rand : Fixed0ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Rank : Var2or3ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    private static ValueEval eval(double arg0, AreaEval aeRange, bool descending_order);
    private static ValueEval eval(double arg0, RefListEval aeRange, bool descending_order);
    private static double GetValue(AreaEval aeRange, int relRowIndex, int relColIndex);
    private static AreaEval ConvertRangeArg(ValueEval eval);
}
public class NPOI.SS.Formula.Functions.Rate : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    private double CalculateRate(double nper, double pmt, double pv, double fv, double type, double guess);
    private static void CheckValue(double result);
}
public class NPOI.SS.Formula.Functions.Replace : TextFunction {
    public virtual ValueEval EvaluateFunc(ValueEval[] args, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.Rept : Fixed2ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval text, ValueEval number_times);
}
public class NPOI.SS.Formula.Functions.Roman : Fixed2ArgFunction {
    public static Int32[] VALUES;
    public static String[] ROMAN;
    private static Roman();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval numberVE, ValueEval formVE);
    private string integerToRoman(int number);
    public string MakeConcise(string result, int form);
}
public class NPOI.SS.Formula.Functions.Round : TwoArg {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.Rounddown : TwoArg {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.Roundup : TwoArg {
    public virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.Row : object {
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
    public sealed virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Rows : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Functions.SearchFind : Var2or3ArgFunction {
    private bool _isCaseSensitive;
    public SearchFind(bool isCaseSensitive);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    private ValueEval Eval(string haystack, string needle, int startIndex);
}
public class NPOI.SS.Formula.Functions.Sign : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.SimpleValueVector : object {
    private ValueEval[] _values;
    public int Size { get; }
    public SimpleValueVector(ValueEval[] values);
    public sealed virtual ValueEval GetItem(int index);
    public sealed virtual int get_Size();
}
public class NPOI.SS.Formula.Functions.Sin : OneArg {
    public virtual double Evaluate(double d);
}
public abstract class NPOI.SS.Formula.Functions.SingleArgTextFunc : TextFunction {
    public virtual ValueEval EvaluateFunc(ValueEval[] args, int srcCellRow, int srcCellCol);
    public abstract virtual ValueEval Evaluate(string arg);
}
public class NPOI.SS.Formula.Functions.SingleValueVector : object {
    private ValueEval _value;
    public int Size { get; }
    public SingleValueVector(ValueEval value);
    public sealed virtual ValueEval GetItem(int index);
    public sealed virtual int get_Size();
}
public class NPOI.SS.Formula.Functions.Sinh : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Slope : Fixed2ArgFunction {
    private LinearRegressionFunction func;
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public class NPOI.SS.Formula.Functions.SMALL : AggregateFunction {
    protected internal virtual double Evaluate(Double[] ops);
}
public class NPOI.SS.Formula.Functions.Sqrt : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Standardize : Fixed3ArgFunction {
    public static Standardize instance;
    private static Standardize();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2, ValueEval arg3);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double evaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.StatsLib : object {
    public static double avedev(Double[] v);
    public static double stdev(Double[] v);
    public static double var(Double[] v);
    public static double varp(Double[] v);
    public static double mode(Double[] v);
    public static double median(Double[] v);
    public static double devsq(Double[] v);
    public static double kthLargest(Double[] v, int k);
    public static double kthSmallest(Double[] v, int k);
}
public class NPOI.SS.Formula.Functions.STDEV : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.StdevP : NumberListFuncBase {
    public static StdevP Instance;
    private static StdevP();
    public virtual double CalculateFromNumberList(List`1<double> list);
}
public class NPOI.SS.Formula.Functions.StdevS : NumberListFuncBase {
    public static StdevS Instance;
    private static StdevS();
    public virtual double CalculateFromNumberList(List`1<double> list);
}
public class NPOI.SS.Formula.Functions.Substitute : TextFunction {
    public virtual ValueEval EvaluateFunc(ValueEval[] args, int srcCellRow, int srcCellCol);
    private static string ReplaceAllOccurrences(string oldStr, string searchStr, string newStr);
    private static string ReplaceOneOccurrence(string oldStr, string searchStr, string newStr, int instanceNumber);
}
public class NPOI.SS.Formula.Functions.Subtotal : object {
    private static Function FindFunction(int functionCode);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.SubtotalInstance : AggregateFunction {
    private AggregateFunction _func;
    public bool IsSubtotalCounted { get; }
    public SubtotalInstance(AggregateFunction func);
    protected internal virtual double Evaluate(Double[] values);
    public virtual bool get_IsSubtotalCounted();
}
public class NPOI.SS.Formula.Functions.SUM : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.Sumif : Var2or3ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    private static ValueEval Eval(int srcRowIndex, int srcColumnIndex, ValueEval arg1, AreaEval aeRange, AreaEval aeSum);
    private static double SumMatchingCells(AreaEval aeRange, IMatchPredicate mp, AreaEval aeSum);
    private static double Accumulate(AreaEval aeRange, IMatchPredicate mp, AreaEval aeSum, int relRowIndex, int relColIndex);
    private static AreaEval CreateSumRange(ValueEval eval, AreaEval aeRange);
    private static AreaEval ConvertRangeArg(ValueEval eval);
}
public class NPOI.SS.Formula.Functions.Sumifs : object {
    public static FreeRefFunction instance;
    private static Sumifs();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    internal static void ValidateCriteria(IMatchPredicate[] criteria);
    internal static void ValidateCriteriaRanges(AreaEval[] criteriaRanges, AreaEval sumRange);
    internal static double CalcMatchingCells(AreaEval[] ranges, IMatchPredicate[] predicates, AreaEval aeSum, double initialValue, Func`3<double, Nullable`1<double>, double> calc);
    private static Nullable`1<double> ReadValue(AreaEval aeSum, int relRowIndex, int relColIndex);
    internal static AreaEval ConvertRangeArg(ValueEval eval);
}
public class NPOI.SS.Formula.Functions.Sumproduct : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    private ValueEval EvaluateSingleProduct(ValueEval[] evalArgs);
    private static double GetScalarValue(ValueEval arg);
    private ValueEval EvaluateAreaSumProduct(ValueEval[] evalArgs);
    private static void ThrowFirstError(TwoDEval areaEval);
    private static bool AreasAllSameSize(TwoDEval[] args, int height, int width);
    private static double GetProductTerm(ValueEval ve, bool IsScalarProduct);
}
public class NPOI.SS.Formula.Functions.SUMSQ : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.Sumx2my2 : XYNumericFunction {
    private static Accumulator XSquaredMinusYSquaredAccumulator;
    private static Sumx2my2();
    public virtual Accumulator CreateAccumulator();
}
public class NPOI.SS.Formula.Functions.Sumx2py2 : XYNumericFunction {
    private static Accumulator XSquaredPlusYSquaredAccumulator;
    private static Sumx2py2();
    public virtual Accumulator CreateAccumulator();
}
public class NPOI.SS.Formula.Functions.Sumxmy2 : XYNumericFunction {
    private static Accumulator XMinusYSquaredAccumulator;
    private static Sumxmy2();
    public virtual Accumulator CreateAccumulator();
}
public class NPOI.SS.Formula.Functions.T : Fixed1ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
}
public class NPOI.SS.Formula.Functions.Tan : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.Tanh : OneArg {
    public virtual double Evaluate(double d);
}
public class NPOI.SS.Formula.Functions.TDist : Fixed3ArgFunction {
    public static TDist instance;
    private static TDist();
    private static double tdistOneTail(double x, int degreesOfFreedom);
    private static double tdistTwoTails(double x, int degreesOfFreedom);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2, ValueEval arg3);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
    private static double evaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Text : Fixed2ArgFunction {
    public static DataFormatter Formatter;
    private static Text();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public abstract class NPOI.SS.Formula.Functions.TextFunction : object {
    protected static string EMPTY_STRING;
    public static Function LEN;
    public static Function LOWER;
    public static Function UPPER;
    public static Function TRIM;
    public static Function MID;
    public static Function LEFT;
    public static Function RIGHT;
    public static Function CONCATENATE;
    public static FreeRefFunction CONCAT;
    public static Function EXACT;
    public static Function TEXT;
    public static Function FIND;
    public static Function SEARCH;
    public static Function CLEAN;
    public static Function CHAR;
    public static Function PROPER;
    private static TextFunction();
    public static string EvaluateStringArg(ValueEval eval, int srcRow, int srcCol);
    public static int EvaluateIntArg(ValueEval arg, int srcCellRow, int srcCellCol);
    public static double EvaluateDoubleArg(ValueEval arg, int srcCellRow, int srcCellCol);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcCellRow, int srcCellCol);
    internal static bool IsPrintable(char c);
    public abstract virtual ValueEval EvaluateFunc(ValueEval[] args, int srcCellRow, int srcCellCol);
}
public class NPOI.SS.Formula.Functions.TimeFunc : Fixed3ArgFunction {
    private static int SECONDS_PER_MINUTE;
    private static int SECONDS_PER_HOUR;
    private static int HOURS_PER_DAY;
    private static int SECONDS_PER_DAY;
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    private int EvalArg(ValueEval arg, int srcRowIndex, int srcColumnIndex);
    private double Evaluate(int hours, int minutes, int seconds);
}
public class NPOI.SS.Formula.Functions.TInv : Fixed2ArgFunction {
    public static FreeRefFunction instance;
    private static TInv();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg1, ValueEval arg2);
    private static double EvaluateValue(ValueEval arg, int srcRowIndex, int srcColumnIndex);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public class NPOI.SS.Formula.Functions.Today : Fixed0ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Transpose : OneArrayArg {
    private MutableValueCollector instance;
    protected virtual Double[] CollectValues(ValueEval arg);
    protected virtual Double[0...,0...] Evaluate(Double[0...,0...] d1);
}
public class NPOI.SS.Formula.Functions.Trim : SingleArgTextFunc {
    public virtual ValueEval Evaluate(string arg);
}
public class NPOI.SS.Formula.Functions.True : Fixed0ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.Trunc : Var1or2ArgFunction {
    private static NumberEval TRUNC_ARG2_DEFAULT;
    private static Trunc();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public abstract class NPOI.SS.Formula.Functions.TwoArg : Fixed2ArgFunction {
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public abstract virtual double Evaluate(double d0, double d1);
}
public class NPOI.SS.Formula.Functions.Upper : SingleArgTextFunc {
    public virtual ValueEval Evaluate(string arg);
}
public class NPOI.SS.Formula.Functions.Value : Fixed1ArgFunction {
    private static int MIN_DISTANCE_BETWEEN_THOUSANDS_SEPARATOR;
    private static double ZERO;
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    private static double ConvertTextToNumber(string strText);
}
internal static class NPOI.SS.Formula.Functions.ValueEvaluationHelper : object {
    public static Nullable`1<double> GetScalarValue(ValueEval arg);
    public static void GetArrayValues(AreaEval evalArg, List`1& numList);
    private static Nullable`1<double> GetSingleValue(ValueEval ve);
}
public interface NPOI.SS.Formula.Functions.ValueVector {
    public int Size { get; }
    public abstract virtual ValueEval GetItem(int index);
    public abstract virtual int get_Size();
}
public class NPOI.SS.Formula.Functions.VAR : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public abstract class NPOI.SS.Formula.Functions.Var1or2ArgFunction : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
}
public abstract class NPOI.SS.Formula.Functions.Var2or3ArgFunction : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
}
public abstract class NPOI.SS.Formula.Functions.Var3or4ArgFunction : object {
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    public abstract virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2, ValueEval arg3);
}
public class NPOI.SS.Formula.Functions.VarP : NumberListFuncBase {
    public static VarP Instance;
    private static VarP();
    public virtual double CalculateFromNumberList(List`1<double> list);
}
public class NPOI.SS.Formula.Functions.VARP : AggregateFunction {
    protected internal virtual double Evaluate(Double[] values);
}
public class NPOI.SS.Formula.Functions.VarS : NumberListFuncBase {
    public static VarS Instance;
    private static VarS();
    public virtual double CalculateFromNumberList(List`1<double> list);
}
public class NPOI.SS.Formula.Functions.Vlookup : Var3or4ArgFunction {
    private static ValueEval DEFAULT_ARG3;
    private static Vlookup();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1, ValueEval arg2);
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval lookup_value, ValueEval table_array, ValueEval col_index, ValueEval range_lookup);
    private ValueVector CreateResultColumnVector(TwoDEval tableArray, int colIndex);
}
public class NPOI.SS.Formula.Functions.WeekdayFunc : object {
    public static Function instance;
    private static WeekdayFunc();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex);
}
public class NPOI.SS.Formula.Functions.WeekNum : Fixed2ArgFunction {
    public static FreeRefFunction instance;
    private static NumberEval DEFAULT_RETURN_TYPE;
    private static List`1<int> VALID_RETURN_TYPES;
    private static WeekNum();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval serialNumVE, ValueEval returnTypeVE);
    public int getWeekNo(DateTime dt, int weekStartOn);
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public abstract class NPOI.SS.Formula.Functions.XYNumericFunction : Fixed2ArgFunction {
    protected static int X;
    protected static int Y;
    private static XYNumericFunction();
    public virtual ValueEval Evaluate(int srcRowIndex, int srcColumnIndex, ValueEval arg0, ValueEval arg1);
    public abstract virtual Accumulator CreateAccumulator();
    private double EvaluateInternal(ValueVector x, ValueVector y, int size);
    private static Double[] TrimToSize(Double[] arr, int len);
    private static bool IsNumberEval(Eval eval);
    private static double GetDoubleValue(Eval eval);
    private static ValueVector CreateValueVector(ValueEval arg);
}
public interface NPOI.SS.Formula.ICacheEntry {
    public abstract virtual ValueEval GetValue();
}
public interface NPOI.SS.Formula.IEntryOperation {
    public abstract virtual void ProcessEntry(FormulaCellCacheEntry entry);
}
public interface NPOI.SS.Formula.IEvaluationCell {
    public IEvaluationSheet Sheet { get; }
    public int RowIndex { get; }
    public int ColumnIndex { get; }
    public CellType CellType { get; }
    public double NumericCellValue { get; }
    public string StringCellValue { get; }
    public bool BooleanCellValue { get; }
    public int ErrorCellValue { get; }
    public object IdentityKey { get; }
    public bool IsPartOfArrayFormulaGroup { get; }
    public CellRangeAddress ArrayFormulaRange { get; }
    public CellType CachedFormulaResultType { get; }
    public abstract virtual IEvaluationSheet get_Sheet();
    public abstract virtual int get_RowIndex();
    public abstract virtual int get_ColumnIndex();
    public abstract virtual CellType get_CellType();
    public abstract virtual double get_NumericCellValue();
    public abstract virtual string get_StringCellValue();
    public abstract virtual bool get_BooleanCellValue();
    public abstract virtual int get_ErrorCellValue();
    public abstract virtual object get_IdentityKey();
    public abstract virtual bool get_IsPartOfArrayFormulaGroup();
    public abstract virtual CellRangeAddress get_ArrayFormulaRange();
    public abstract virtual CellType get_CachedFormulaResultType();
}
public interface NPOI.SS.Formula.IEvaluationListener {
    public abstract virtual void OnCacheHit(int sheetIndex, int rowIndex, int columnIndex, ValueEval result);
    public abstract virtual void OnReadPlainValue(int sheetIndex, int rowIndex, int columnIndex, ICacheEntry entry);
    public abstract virtual void OnStartEvaluate(IEvaluationCell cell, ICacheEntry entry);
    public abstract virtual void OnEndEvaluate(ICacheEntry entry, ValueEval result);
    public abstract virtual void OnClearWholeCache();
    public abstract virtual void OnClearCachedValue(ICacheEntry entry);
    public abstract virtual void SortDependentCachedValues(ICacheEntry[] formulaCells);
    public abstract virtual void OnClearDependentCachedValue(ICacheEntry formulaCell, int depth);
    public abstract virtual void OnChangeFromBlankValue(int sheetIndex, int rowIndex, int columnIndex, IEvaluationCell cell, ICacheEntry entry);
}
public interface NPOI.SS.Formula.IEvaluationName {
    public string NameText { get; }
    public bool IsFunctionName { get; }
    public bool HasFormula { get; }
    public Ptg[] NameDefinition { get; }
    public bool IsRange { get; }
    public abstract virtual string get_NameText();
    public abstract virtual bool get_IsFunctionName();
    public abstract virtual bool get_HasFormula();
    public abstract virtual Ptg[] get_NameDefinition();
    public abstract virtual bool get_IsRange();
    public abstract virtual NamePtg CreatePtg();
}
public interface NPOI.SS.Formula.IEvaluationSheet {
    public abstract virtual IEvaluationCell GetCell(int rowIndex, int columnIndex);
    public abstract virtual void ClearAllCachedResultValues();
}
public interface NPOI.SS.Formula.IEvaluationWorkbook {
    public abstract virtual string GetSheetName(int sheetIndex);
    public abstract virtual int GetSheetIndex(IEvaluationSheet sheet);
    public abstract virtual int GetSheetIndex(string sheetName);
    public abstract virtual IEvaluationSheet GetSheet(int sheetIndex);
    public abstract virtual ExternalSheet GetExternalSheet(int externSheetIndex);
    public abstract virtual ExternalSheet GetExternalSheet(string firstSheetName, string lastSheetName, int externalWorkbookNumber);
    public abstract virtual int ConvertFromExternSheetIndex(int externSheetIndex);
    public abstract virtual ExternalName GetExternalName(int externSheetIndex, int externNameIndex);
    public abstract virtual ExternalName GetExternalName(string nameName, string sheetName, int externalWorkbookNumber);
    public abstract virtual IEvaluationName GetName(NamePtg namePtg);
    public abstract virtual IEvaluationName GetName(string name, int sheetIndex);
    public abstract virtual string ResolveNameXText(NameXPtg ptg);
    public abstract virtual Ptg[] GetFormulaTokens(IEvaluationCell cell);
    public abstract virtual UDFFinder GetUDFFinder();
    public abstract virtual void ClearAllCachedResultValues();
    public abstract virtual SpreadsheetVersion GetSpreadsheetVersion();
}
public interface NPOI.SS.Formula.IExternSheetReferenceToken {
    public int ExternSheetIndex { get; }
    public abstract virtual int get_ExternSheetIndex();
}
public interface NPOI.SS.Formula.IFormulaParsingWorkbook {
    public abstract virtual IEvaluationName GetName(string name, int sheetIndex);
    public abstract virtual IName CreateName();
    public abstract virtual ITable GetTable(string name);
    public abstract virtual Ptg GetNameXPtg(string name, SheetIdentifier sheet);
    public abstract virtual Ptg Get3DReferencePtg(CellReference cell, SheetIdentifier sheet);
    public abstract virtual Ptg Get3DReferencePtg(AreaReference area, SheetIdentifier sheet);
    public abstract virtual int GetExternalSheetIndex(string sheetName);
    public abstract virtual int GetExternalSheetIndex(string workbookName, string sheetName);
    public abstract virtual SpreadsheetVersion GetSpreadsheetVersion();
}
public interface NPOI.SS.Formula.IFormulaRenderingWorkbook {
    public abstract virtual ExternalSheet GetExternalSheet(int externSheetIndex);
    public abstract virtual string GetSheetFirstNameByExternSheet(int externSheetIndex);
    public abstract virtual string GetSheetLastNameByExternSheet(int externSheetIndex);
    public abstract virtual string ResolveNameXText(NameXPtg nameXPtg);
    public abstract virtual string GetNameText(NamePtg namePtg);
}
public interface NPOI.SS.Formula.ISheetRange {
    public int FirstSheetIndex { get; }
    public int LastSheetIndex { get; }
    public abstract virtual int get_FirstSheetIndex();
    public abstract virtual int get_LastSheetIndex();
}
public abstract class NPOI.SS.Formula.IStabilityClassifier : object {
    private static IStabilityClassifier TOTALLY_IMMUTABLE;
    private static IStabilityClassifier();
    public abstract virtual bool IsCellFinal(int sheetIndex, int rowIndex, int columnIndex);
}
public interface NPOI.SS.Formula.IWorkbookEvaluatorProvider {
    public abstract virtual WorkbookEvaluator GetWorkbookEvaluator();
}
public class NPOI.SS.Formula.LazyAreaEval : AreaEvalBase {
    private SheetRangeEvaluator _evaluator;
    public LazyAreaEval(AreaI ptg, SheetRangeEvaluator evaluator);
    public LazyAreaEval(int firstRowIndex, int firstColumnIndex, int lastRowIndex, int lastColumnIndex, SheetRangeEvaluator evaluator);
    public virtual ValueEval GetRelativeValue(int relativeRowIndex, int relativeColumnIndex);
    public virtual ValueEval GetRelativeValue(int sheetIndex, int relativeRowIndex, int relativeColumnIndex);
    public virtual TwoDEval GetRow(int rowIndex);
    public virtual TwoDEval GetColumn(int columnIndex);
    public virtual AreaEval Offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx);
    public virtual string ToString();
    public virtual bool IsSubTotal(int rowIndex, int columnIndex);
}
public class NPOI.SS.Formula.LazyRefEval : RefEvalBase {
    private SheetRangeEvaluator _evaluator;
    public bool IsSubTotal { get; }
    public LazyRefEval(int rowIndex, int columnIndex, SheetRangeEvaluator sre);
    public virtual ValueEval GetInnerValueEval(int sheetIndex);
    public virtual AreaEval Offset(int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx);
    public bool get_IsSubTotal();
    public virtual string ToString();
}
public class NPOI.SS.Formula.Loc : object {
    private long _bookSheetColumn;
    private int _rowIndex;
    public int RowIndex { get; }
    public int ColumnIndex { get; }
    public int SheetIndex { get; }
    public int BookIndex { get; }
    public Loc(int bookIndex, int sheetIndex, int rowIndex, int columnIndex);
    public Loc(int bookSheetColumn, int rowIndex);
    public static long ToBookSheetColumn(int bookIndex, int sheetIndex, int columnIndex);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public int get_RowIndex();
    public int get_ColumnIndex();
    public int get_SheetIndex();
    public int get_BookIndex();
}
public class NPOI.SS.Formula.NameIdentifier : object {
    private string _name;
    private bool _isQuoted;
    public string Name { get; }
    public bool IsQuoted { get; }
    public NameIdentifier(string name, bool isQuoted);
    public string get_Name();
    public bool get_IsQuoted();
    public virtual string ToString();
}
internal class NPOI.SS.Formula.OperandClassTransformer : object {
    private FormulaType _formulaType;
    public OperandClassTransformer(FormulaType formulaType);
    public void TransformFormula(ParseNode rootNode);
    private void TransformNode(ParseNode node, byte desiredOperandClass, bool callerForceArrayFlag);
    private static bool IsSingleArgSum(Ptg token);
    private static bool IsSimpleValueFunction(Ptg token);
    private byte TransformClass(byte currentOperandClass, byte desiredOperandClass, bool callerForceArrayFlag);
    private void TransformFunctionNode(AbstractFunctionPtg afp, ParseNode[] children, byte desiredOperandClass, bool callerForceArrayFlag);
    private void SetSimpleValueFuncClass(AbstractFunctionPtg afp, byte desiredOperandClass, bool callerForceArrayFlag);
}
public class NPOI.SS.Formula.OperationEvaluationContext : object {
    public static FreeRefFunction UDF;
    private IEvaluationWorkbook _workbook;
    private int _sheetIndex;
    private int _rowIndex;
    private int _columnIndex;
    private EvaluationTracker _tracker;
    private bool _isSingleValue;
    private WorkbookEvaluator _bookEvaluator;
    private bool _isInArrayContext;
    public bool IsArraymode { get; public set; }
    public bool IsSingleValue { get; }
    public int RowIndex { get; }
    public int ColumnIndex { get; }
    public int SheetIndex { get; }
    public OperationEvaluationContext(WorkbookEvaluator bookEvaluator, IEvaluationWorkbook workbook, int sheetIndex, int srcRowNum, int srcColNum, EvaluationTracker tracker);
    public OperationEvaluationContext(WorkbookEvaluator bookEvaluator, IEvaluationWorkbook workbook, int sheetIndex, int srcRowNum, int srcColNum, EvaluationTracker tracker, bool isSingleValue);
    private static OperationEvaluationContext();
    public bool get_IsArraymode();
    public void set_IsArraymode(bool value);
    public IEvaluationWorkbook GetWorkbook();
    public bool get_IsSingleValue();
    public int get_RowIndex();
    public int get_ColumnIndex();
    private SheetRangeEvaluator CreateExternSheetRefEvaluator(IExternSheetReferenceToken ptg);
    private SheetRangeEvaluator CreateExternSheetRefEvaluator(string firstSheetName, string lastSheetName, int externalWorkbookNumber);
    private SheetRangeEvaluator CreateExternSheetRefEvaluator(int externSheetIndex);
    private SheetRangeEvaluator CreateExternSheetRefEvaluator(ExternalSheet externalSheet);
    private SheetRefEvaluator CreateExternSheetRefEvaluator(string workbookName, string sheetName);
    public SheetRangeEvaluator GetRefEvaluatorForCurrentSheet();
    public ValueEval GetDynamicReference(string workbookName, string sheetName, string refStrPart1, string refStrPart2, bool isA1Style);
    private static int ParseRowRef(string refStrPart);
    private static int ParseColRef(string refStrPart);
    private static NameType ClassifyCellReference(string str, SpreadsheetVersion ssVersion);
    public FreeRefFunction FindUserDefinedFunction(string functionName);
    public ValueEval GetRefEval(int rowIndex, int columnIndex);
    public ValueEval GetRef3DEval(Ref3DPtg rptg);
    public ValueEval GetRef3DEval(Ref3DPxg rptg);
    public ValueEval GetAreaEval(int firstRowIndex, int firstColumnIndex, int lastRowIndex, int lastColumnIndex);
    public ValueEval GetArea3DEval(Area3DPtg aptg);
    public ValueEval GetArea3DEval(Area3DPxg aptg);
    public ValueEval GetAreaValueEval(int firstRowIndex, int firstColumnIndex, int lastRowIndex, int lastColumnIndex, Object[0...,0...] tokens);
    private ValueEval convertObjectEval(object token);
    public ValueEval GetNameXEval(NameXPtg nameXPtg);
    public ValueEval GetNameXEval(NameXPxg nameXPxg);
    private ValueEval GetLocalNameXEval(NameXPxg nameXPxg);
    private ValueEval GetLocalNameXEval(NameXPtg nameXPtg);
    public int get_SheetIndex();
    private ValueEval GetExternalNameXEval(ExternalName externName, string workbookName);
}
internal class NPOI.SS.Formula.OperationEvaluatorFactory : object {
    private static Type[] OPERATION_CONSTRUCTOR_CLASS_ARRAY;
    private static Hashtable _instancesByPtgClass;
    private static OperationEvaluatorFactory();
    private static Hashtable InitialiseInstancesMap();
    private static void Add(Hashtable m, OperationPtg ptgKey, Function instance);
    public static ValueEval Evaluate(OperationPtg ptg, ValueEval[] args, OperationEvaluationContext ec);
    public static ValueEval EvaluateArrayFunction(ArrayFunction func, ValueEval[] args, OperationEvaluationContext ec);
}
public enum NPOI.SS.Formula.OperatorEnum : Enum {
    public byte value__;
    public static OperatorEnum NO_COMPARISON;
    public static OperatorEnum BETWEEN;
    public static OperatorEnum NOT_BETWEEN;
    public static OperatorEnum EQUAL;
    public static OperatorEnum NOT_EQUAL;
    public static OperatorEnum GREATER_THAN;
    public static OperatorEnum LESS_THAN;
    public static OperatorEnum GREATER_OR_EQUAL;
    public static OperatorEnum LESS_OR_EQUAL;
}
public class NPOI.SS.Formula.OperatorEnumHelper : object {
    public static bool IsValid(OperatorEnum operator, object cellValue, object v1, object v2);
    public static bool IsValidForIncompatibleTypes(OperatorEnum operator);
}
internal class NPOI.SS.Formula.ParseNode : object {
    public static ParseNode[] EMPTY_ARRAY;
    private Ptg _token;
    private ParseNode[] _children;
    private bool _isIf;
    private int _tokenCount;
    private int TokenCount { get; }
    public int EncodedSize { get; }
    public ParseNode(Ptg token, ParseNode[] children);
    public ParseNode(Ptg token);
    public ParseNode(Ptg token, ParseNode child0);
    public ParseNode(Ptg token, ParseNode child0, ParseNode child1);
    private static ParseNode();
    private int get_TokenCount();
    public int get_EncodedSize();
    public static Ptg[] ToTokenArray(ParseNode rootNode);
    private void CollectPtgs(TokenCollector temp);
    private void CollectIfPtgs(TokenCollector temp);
    private static bool IsIf(Ptg token);
    public Ptg GetToken();
    public ParseNode[] GetChildren();
}
public class NPOI.SS.Formula.PlainCellCache : object {
    private Hashtable _plainValueEntriesByLoc;
    public void Put(Loc key, PlainValueCellCacheEntry cce);
    public void Clear();
    public PlainValueCellCacheEntry Get(Loc key);
    public void Remove(Loc key);
}
public class NPOI.SS.Formula.PlainValueCellCacheEntry : CellCacheEntry {
    public PlainValueCellCacheEntry(ValueEval value);
}
public abstract class NPOI.SS.Formula.PTG.AbstractFunctionPtg : OperationPtg {
    public static string FUNCTION_NAME_IF;
    private static short FUNCTION_INDEX_EXTERNAL;
    protected byte returnClass;
    protected Byte[] paramClass;
    protected byte _numberOfArgs;
    protected short _functionIndex;
    public bool IsBaseToken { get; }
    public short FunctionIndex { get; }
    public int NumberOfOperands { get; }
    public string Name { get; }
    public bool IsExternalFunction { get; }
    public byte DefaultOperandClass { get; }
    protected AbstractFunctionPtg(int functionIndex, int pReturnClass, Byte[] paramTypes, int nParams);
    public virtual bool get_IsBaseToken();
    public virtual string ToString();
    public short get_FunctionIndex();
    public virtual int get_NumberOfOperands();
    public string get_Name();
    public bool get_IsExternalFunction();
    public virtual string ToFormulaString();
    public virtual string ToFormulaString(String[] operands);
    private static void AppendArgs(StringBuilder buf, int firstArgIx, String[] operands);
    public static bool IsBuiltInFunctionName(string name);
    protected string LookupName(short index);
    protected static short LookupIndex(string name);
    public virtual byte get_DefaultOperandClass();
    public byte GetParameterClass(int index);
}
public class NPOI.SS.Formula.PTG.AddPtg : ValueOperatorPtg {
    public static byte sid;
    private static string Add;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static AddPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public abstract class NPOI.SS.Formula.PTG.Area2DPtgBase : AreaPtgBase {
    private static int SIZE;
    protected byte Sid { get; }
    public int Size { get; }
    protected Area2DPtgBase(int firstRow, int lastRow, int firstColumn, int lastColumn, bool firstRowRelative, bool lastRowRelative, bool firstColRelative, bool lastColRelative);
    protected Area2DPtgBase(AreaReference ar);
    protected Area2DPtgBase(ILittleEndianInput in1);
    public Area2DPtgBase(string arearef);
    protected abstract virtual byte get_Sid();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
    public virtual string ToString();
}
public class NPOI.SS.Formula.PTG.Area3DPtg : AreaPtgBase {
    public static byte sid;
    private static int SIZE;
    private int field_1_index_extern_sheet;
    private BitField rowRelative;
    private BitField colRelative;
    public int Size { get; }
    public int ExternSheetIndex { get; public set; }
    public byte DefaultOperandClass { get; }
    public Area3DPtg(string arearef, int externIdx);
    public Area3DPtg(AreaReference arearef, int externIdx);
    public Area3DPtg(ILittleEndianInput in1);
    public Area3DPtg(int firstRow, int lastRow, int firstColumn, int lastColumn, bool firstRowRelative, bool lastRowRelative, bool firstColRelative, bool lastColRelative, int externalSheetIndex);
    public virtual string ToString();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public sealed virtual int get_ExternSheetIndex();
    public void set_ExternSheetIndex(int value);
    public void SetArea(string ref1);
    public virtual string ToFormulaString();
    public sealed virtual string ToFormulaString(IFormulaRenderingWorkbook book);
    public virtual byte get_DefaultOperandClass();
}
public class NPOI.SS.Formula.PTG.Area3DPxg : AreaPtgBase {
    private int externalWorkbookNumber;
    private string firstSheetName;
    private string lastSheetName;
    public int ExternalWorkbookNumber { get; }
    public string SheetName { get; public set; }
    public string LastSheetName { get; public set; }
    public int Size { get; }
    public Area3DPxg(int externalWorkbookNumber, SheetIdentifier sheetName, string arearef);
    public Area3DPxg(int externalWorkbookNumber, SheetIdentifier sheetName, AreaReference arearef);
    public Area3DPxg(SheetIdentifier sheetName, string arearef);
    public Area3DPxg(SheetIdentifier sheetName, AreaReference arearef);
    public virtual string ToString();
    public sealed virtual int get_ExternalWorkbookNumber();
    public sealed virtual string get_SheetName();
    public sealed virtual void set_SheetName(string value);
    public sealed virtual string get_LastSheetName();
    public sealed virtual void set_LastSheetName(string value);
    public string Format2DRefAsString();
    public virtual string ToFormulaString();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
}
public class NPOI.SS.Formula.PTG.AreaErrPtg : OperandPtg {
    public static byte sid;
    private int unused1;
    private int unused2;
    public byte DefaultOperandClass { get; }
    public int Size { get; }
    public AreaErrPtg(ILittleEndianInput in1);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public virtual int get_Size();
}
public interface NPOI.SS.Formula.PTG.AreaI {
    public int FirstRow { get; }
    public int LastRow { get; }
    public int FirstColumn { get; }
    public int LastColumn { get; }
    public abstract virtual int get_FirstRow();
    public abstract virtual int get_LastRow();
    public abstract virtual int get_FirstColumn();
    public abstract virtual int get_LastColumn();
}
public class NPOI.SS.Formula.PTG.AreaNPtg : Area2DPtgBase {
    public static short sid;
    protected byte Sid { get; }
    public AreaNPtg(ILittleEndianInput in1);
    protected virtual byte get_Sid();
}
public class NPOI.SS.Formula.PTG.AreaPtg : Area2DPtgBase {
    public static byte sid;
    protected byte Sid { get; }
    public AreaPtg(int firstRow, int lastRow, int firstColumn, int lastColumn, bool firstRowRelative, bool lastRowRelative, bool firstColRelative, bool lastColRelative);
    public AreaPtg(ILittleEndianInput in1);
    public AreaPtg(string arearef);
    public AreaPtg(AreaReference areaRef);
    protected virtual byte get_Sid();
}
public abstract class NPOI.SS.Formula.PTG.AreaPtgBase : OperandPtg {
    private int field_1_first_row;
    private int field_2_last_row;
    private int field_3_first_column;
    private int field_4_last_column;
    private static BitField rowRelative;
    private static BitField colRelative;
    private static BitField columnMask;
    public int FirstRow { get; public set; }
    public int LastRow { get; public set; }
    public int FirstColumn { get; public set; }
    public bool IsFirstRowRelative { get; public set; }
    public bool IsFirstColRelative { get; public set; }
    public int LastColumn { get; public set; }
    public short LastColumnRaw { get; }
    public bool IsLastRowRelative { get; public set; }
    public bool IsLastColRelative { get; public set; }
    public byte DefaultOperandClass { get; }
    protected AreaPtgBase(string arearef);
    protected AreaPtgBase(AreaReference ar);
    protected AreaPtgBase(int firstRow, int lastRow, int firstColumn, int lastColumn, bool firstRowRelative, bool lastRowRelative, bool firstColRelative, bool lastColRelative);
    protected AreaPtgBase(RecordInputStream in1);
    private static AreaPtgBase();
    protected Exception NotImplemented();
    public void SortTopLeftToBottomRight();
    protected void ReadCoordinates(ILittleEndianInput in1);
    protected void WriteCoordinates(ILittleEndianOutput out1);
    protected void WriteCoordinates(Byte[] array, int offset);
    public virtual int get_FirstRow();
    public virtual void set_FirstRow(int value);
    public virtual int get_LastRow();
    public virtual void set_LastRow(int value);
    public virtual int get_FirstColumn();
    public virtual void set_FirstColumn(int value);
    public virtual bool get_IsFirstRowRelative();
    public virtual void set_IsFirstRowRelative(bool value);
    public virtual bool get_IsFirstColRelative();
    public virtual void set_IsFirstColRelative(bool value);
    public virtual int get_LastColumn();
    public virtual void set_LastColumn(int value);
    public virtual short get_LastColumnRaw();
    public virtual bool get_IsLastRowRelative();
    public virtual void set_IsLastRowRelative(bool value);
    public virtual bool get_IsLastColRelative();
    public virtual void set_IsLastColRelative(bool value);
    public void SetLastColumnRaw(short column);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    protected string FormatReferenceAsString();
}
public class NPOI.SS.Formula.PTG.ArrayPtg : Ptg {
    public static byte sid;
    private static int RESERVED_FIELD_LEN;
    public static int PLAIN_TOKEN_SIZE;
    private int _reserved0Int;
    private int _reserved1Short;
    private int _reserved2Byte;
    private int _nColumns;
    private int _nRows;
    private Object[] _arrayValues;
    public bool IsBaseToken { get; }
    public int RowCount { get; }
    public int ColumnCount { get; }
    public int Size { get; }
    public byte DefaultOperandClass { get; }
    private ArrayPtg(int reserved0, int reserved1, int reserved2, int nColumns, int nRows, Object[] arrayValues);
    public ArrayPtg(Object[][] values2d);
    public Object[0...,0...] GetTokenArrayValues();
    public virtual bool get_IsBaseToken();
    public virtual string ToString();
    public int GetValueIndex(int colIx, int rowIx);
    public virtual void Write(ILittleEndianOutput out1);
    public int WriteTokenValueBytes(ILittleEndianOutput out1);
    public int get_RowCount();
    public int get_ColumnCount();
    public virtual int get_Size();
    public virtual string ToFormulaString();
    private static string GetConstantText(object o);
    public virtual byte get_DefaultOperandClass();
}
public class NPOI.SS.Formula.PTG.AttrPtg : ControlPtg {
    public static byte sid;
    private static int SIZE;
    private byte field_1_options;
    private short field_2_data;
    private Int32[] _jumpTable;
    private int _chooseFuncOffset;
    private static BitField semiVolatile;
    private static BitField optiIf;
    private static BitField optiChoose;
    private static BitField optiSkip;
    private static BitField optiSum;
    private static BitField baxcel;
    private static BitField space;
    public static AttrPtg SUM;
    public bool IsSemiVolatile { get; }
    public bool IsOptimizedIf { get; public set; }
    public bool IsOptimizedChoose { get; }
    public bool IsSum { get; public set; }
    public bool IsBaxcel { get; }
    public bool IsSpace { get; }
    public bool IsSkip { get; }
    public short Data { get; public set; }
    public Int32[] JumpTable { get; }
    public int ChooseFuncOffset { get; }
    public int Size { get; }
    public int NumberOfOperands { get; }
    public int Type { get; }
    public AttrPtg(ILittleEndianInput in1);
    private AttrPtg(int options, int data, Int32[] jt, int chooseFuncOffset);
    private static AttrPtg();
    public static AttrPtg CreateSpace(SpaceType type, int count);
    public static AttrPtg CreateIf(int dist);
    public static AttrPtg CreateSkip(int dist);
    public static AttrPtg GetSumSingle();
    public bool get_IsSemiVolatile();
    public bool get_IsOptimizedIf();
    public void set_IsOptimizedIf(bool value);
    public bool get_IsOptimizedChoose();
    public bool get_IsSum();
    public void set_IsSum(bool value);
    public bool get_IsBaxcel();
    public bool get_IsSpace();
    public bool get_IsSkip();
    public short get_Data();
    public void set_Data(short value);
    public Int32[] get_JumpTable();
    public int get_ChooseFuncOffset();
    public virtual string ToString();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public string ToFormulaString(String[] operands);
    public int get_NumberOfOperands();
    public int get_Type();
    public virtual string ToFormulaString();
    public virtual object Clone();
}
public class NPOI.SS.Formula.PTG.BoolPtg : ScalarConstantPtg {
    public static int SIZE;
    public static byte sid;
    private bool field_1_value;
    public bool Value { get; }
    public int Size { get; }
    public BoolPtg(ILittleEndianInput in1);
    public BoolPtg(string formulaToken);
    public bool get_Value();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
}
public class NPOI.SS.Formula.PTG.ConcatPtg : ValueOperatorPtg {
    public static byte sid;
    private static string CONCAT;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static ConcatPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public abstract class NPOI.SS.Formula.PTG.ControlPtg : Ptg {
    public bool IsBaseToken { get; }
    public byte DefaultOperandClass { get; }
    public virtual bool get_IsBaseToken();
    public virtual byte get_DefaultOperandClass();
}
public class NPOI.SS.Formula.PTG.Deleted3DPxg : OperandPtg {
    private int externalWorkbookNumber;
    private string sheetName;
    public int ExternalWorkbookNumber { get; }
    public string SheetName { get; public set; }
    public byte DefaultOperandClass { get; }
    public int Size { get; }
    public Deleted3DPxg(int externalWorkbookNumber, string sheetName);
    public Deleted3DPxg(string sheetName);
    public virtual string ToString();
    public sealed virtual int get_ExternalWorkbookNumber();
    public sealed virtual string get_SheetName();
    public sealed virtual void set_SheetName(string value);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
}
public class NPOI.SS.Formula.PTG.DeletedArea3DPtg : OperandPtg {
    public static byte sid;
    private int field_1_index_extern_sheet;
    private int unused1;
    private int unused2;
    public byte DefaultOperandClass { get; }
    public int Size { get; }
    public DeletedArea3DPtg(int externSheetIndex);
    public DeletedArea3DPtg(ILittleEndianInput in1);
    public sealed virtual string ToFormulaString(IFormulaRenderingWorkbook book);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
}
public class NPOI.SS.Formula.PTG.DeletedRef3DPtg : OperandPtg {
    public static byte sid;
    private int field_1_index_extern_sheet;
    private int unused1;
    public byte DefaultOperandClass { get; }
    public int Size { get; }
    public DeletedRef3DPtg(ILittleEndianInput in1);
    public DeletedRef3DPtg(int externSheetIndex);
    public sealed virtual string ToFormulaString(IFormulaRenderingWorkbook book);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
}
public class NPOI.SS.Formula.PTG.DividePtg : ValueOperatorPtg {
    public static byte sid;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static DividePtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.EqualPtg : ValueOperatorPtg {
    public static byte sid;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static EqualPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.ErrPtg : ScalarConstantPtg {
    public static ErrPtg NULL_INTERSECTION;
    public static ErrPtg DIV_ZERO;
    public static ErrPtg VALUE_INVALID;
    public static ErrPtg REF_INVALID;
    public static ErrPtg NAME_INVALID;
    public static ErrPtg NUM_ERROR;
    public static ErrPtg N_A;
    public static byte sid;
    private static int SIZE;
    private int field_1_error_code;
    public int Size { get; }
    public int ErrorCode { get; }
    public ErrPtg(int errorCode);
    public ErrPtg(ILittleEndianInput in1);
    private static ErrPtg();
    public static ErrPtg ValueOf(int code);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual string ToFormulaString();
    public virtual int get_Size();
    public int get_ErrorCode();
}
public class NPOI.SS.Formula.PTG.ExpPtg : ControlPtg {
    private static int SIZE;
    public static byte sid;
    private short field_1_first_row;
    private short field_2_first_col;
    public int Size { get; }
    public short Row { get; }
    public short Column { get; }
    public ExpPtg(ILittleEndianInput in1);
    public ExpPtg(int firstRow, int firstCol);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public short get_Row();
    public short get_Column();
    public virtual string ToFormulaString();
    public virtual string ToString();
}
public class NPOI.SS.Formula.PTG.ExternSheetNameResolver : object {
    public static string PrependSheetName(IFormulaRenderingWorkbook book, int field_1_index_extern_sheet, string cellRefText);
}
public class NPOI.SS.Formula.PTG.FuncPtg : AbstractFunctionPtg {
    public static byte sid;
    public static int SIZE;
    public int Size { get; }
    private FuncPtg(int funcIndex, FunctionMetadata fm);
    public static FuncPtg Create(ILittleEndianInput in1);
    public static FuncPtg Create(int functionIndex);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
}
public class NPOI.SS.Formula.PTG.FuncVarPtg : AbstractFunctionPtg {
    public static byte sid;
    private static int SIZE;
    public static OperationPtg SUM;
    public int Size { get; }
    private FuncVarPtg(int functionIndex, int returnClass, Byte[] paramClasses, int numArgs);
    private static FuncVarPtg();
    public static FuncVarPtg Create(ILittleEndianInput in1);
    public static FuncVarPtg Create(string pName, int numArgs);
    private static FuncVarPtg Create(int numArgs, int functionIndex);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
}
public class NPOI.SS.Formula.PTG.GreaterEqualPtg : ValueOperatorPtg {
    public static int SIZE;
    public static byte sid;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static GreaterEqualPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.GreaterThanPtg : ValueOperatorPtg {
    public static byte sid;
    private static string GREATERTHAN;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static GreaterThanPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.IntersectionPtg : OperationPtg {
    public static byte sid;
    public static OperationPtg instance;
    public bool IsBaseToken { get; }
    public int Size { get; }
    public int NumberOfOperands { get; }
    private static IntersectionPtg();
    public virtual bool get_IsBaseToken();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual string ToFormulaString();
    public virtual string ToFormulaString(String[] operands);
    public virtual int get_NumberOfOperands();
}
public class NPOI.SS.Formula.PTG.IntPtg : ScalarConstantPtg {
    private static int MIN_VALUE;
    private static int MAX_VALUE;
    public static int SIZE;
    public static byte sid;
    private int field_1_value;
    public int Value { get; }
    public int Size { get; }
    public IntPtg(ILittleEndianInput in1);
    public IntPtg(int value);
    public static bool IsInRange(int i);
    public int get_Value();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
    public virtual string ToString();
}
public class NPOI.SS.Formula.PTG.LessEqualPtg : ValueOperatorPtg {
    public static byte sid;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static LessEqualPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.LessThanPtg : ValueOperatorPtg {
    public static byte sid;
    private static string LESSTHAN;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static LessThanPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.MemAreaPtg : OperandPtg {
    public static short sid;
    private static int SIZE;
    private int field_1_reserved;
    private int field_2_subex_len;
    public int Reserved { get; public set; }
    public int LenRefSubexpression { get; public set; }
    public int Size { get; }
    public byte DefaultOperandClass { get; }
    public MemAreaPtg(int subexLen);
    public MemAreaPtg(ILittleEndianInput in1);
    public int get_Reserved();
    public void set_Reserved(int value);
    public int get_LenRefSubexpression();
    public void set_LenRefSubexpression(int value);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public virtual string ToString();
}
public class NPOI.SS.Formula.PTG.MemErrPtg : MemAreaPtg {
    public static short sid;
    private int field_1_reserved;
    private short field_2_subex_len;
    public MemErrPtg(ILittleEndianInput in1);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual string ToFormulaString();
}
public class NPOI.SS.Formula.PTG.MemFuncPtg : OperandPtg {
    public static byte sid;
    private int field_1_len_ref_subexpression;
    public int Size { get; }
    public byte DefaultOperandClass { get; }
    public int NumberOfOperands { get; }
    public int LenRefSubexpression { get; }
    public MemFuncPtg(ILittleEndianInput in1);
    public MemFuncPtg(int subExprLen);
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public int get_NumberOfOperands();
    public int get_LenRefSubexpression();
}
public class NPOI.SS.Formula.PTG.MissingArgPtg : ScalarConstantPtg {
    private static int SIZE;
    public static byte sid;
    public static Ptg instance;
    public int Size { get; }
    private static MissingArgPtg();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
}
public class NPOI.SS.Formula.PTG.MultiplyPtg : ValueOperatorPtg {
    public static byte sid;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static MultiplyPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.NamePtg : OperandPtg {
    public static short sid;
    private static int SIZE;
    private int field_1_label_index;
    private short field_2_zero;
    public int Index { get; }
    public int Size { get; }
    public byte DefaultOperandClass { get; }
    public NamePtg(int nameIndex);
    public NamePtg(ILittleEndianInput in1);
    public int get_Index();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public sealed virtual string ToFormulaString(IFormulaRenderingWorkbook book);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
}
public class NPOI.SS.Formula.PTG.NameXPtg : OperandPtg {
    public static short sid;
    private static int SIZE;
    private int _sheetRefIndex;
    private int _nameNumber;
    private int _reserved;
    public int Size { get; }
    public byte DefaultOperandClass { get; }
    public int SheetRefIndex { get; }
    public int NameIndex { get; }
    private NameXPtg(int sheetRefIndex, int nameNumber, int reserved);
    public NameXPtg(int sheetRefIndex, int nameIndex);
    public NameXPtg(ILittleEndianInput in1);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public sealed virtual string ToFormulaString(IFormulaRenderingWorkbook book);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public int get_SheetRefIndex();
    public int get_NameIndex();
}
public class NPOI.SS.Formula.PTG.NameXPxg : OperandPtg {
    private int externalWorkbookNumber;
    private string sheetName;
    private string nameName;
    public int ExternalWorkbookNumber { get; }
    public string SheetName { get; public set; }
    public string NameName { get; }
    public byte DefaultOperandClass { get; }
    public int Size { get; }
    public NameXPxg(int externalWorkbookNumber, string sheetName, string nameName);
    public NameXPxg(string sheetName, string nameName);
    public NameXPxg(string nameName);
    public virtual string ToString();
    public sealed virtual int get_ExternalWorkbookNumber();
    public sealed virtual string get_SheetName();
    public sealed virtual void set_SheetName(string value);
    public string get_NameName();
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
}
public class NPOI.SS.Formula.PTG.NotEqualPtg : ValueOperatorPtg {
    public static byte sid;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static NotEqualPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.NumberPtg : ScalarConstantPtg {
    public static int SIZE;
    public static byte sid;
    private double field_1_value;
    public double Value { get; }
    public int Size { get; }
    public NumberPtg(ILittleEndianInput in1);
    public NumberPtg(string value);
    public NumberPtg(double value);
    public double get_Value();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
}
public class NPOI.SS.Formula.PTG.OffsetArea : object {
    private int _firstColumn;
    private int _firstRow;
    private int _lastColumn;
    private int _lastRow;
    public int FirstColumn { get; }
    public int FirstRow { get; }
    public int LastColumn { get; }
    public int LastRow { get; }
    public OffsetArea(int baseRow, int baseColumn, int relFirstRowIx, int relLastRowIx, int relFirstColIx, int relLastColIx);
    public sealed virtual int get_FirstColumn();
    public sealed virtual int get_FirstRow();
    public sealed virtual int get_LastColumn();
    public sealed virtual int get_LastRow();
}
public abstract class NPOI.SS.Formula.PTG.OperandPtg : Ptg {
    public bool IsBaseToken { get; }
    public virtual bool get_IsBaseToken();
    public OperandPtg Copy();
}
public abstract class NPOI.SS.Formula.PTG.OperationPtg : Ptg {
    public static int TYPE_UNARY;
    public static int TYPE_BINARY;
    public static int TYPE_FUNCTION;
    public int NumberOfOperands { get; }
    public byte DefaultOperandClass { get; }
    public abstract virtual string ToFormulaString(String[] operands);
    public abstract virtual int get_NumberOfOperands();
    public virtual byte get_DefaultOperandClass();
}
public class NPOI.SS.Formula.PTG.ParenthesisPtg : ControlPtg {
    private static int SIZE;
    public static byte sid;
    public static ControlPtg instance;
    public int Size { get; }
    private static ParenthesisPtg();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
    public string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.PercentPtg : ValueOperatorPtg {
    public static int SIZE;
    public static byte sid;
    private static string PERCENT;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static PercentPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.PowerPtg : ValueOperatorPtg {
    public static byte sid;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static PowerPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public abstract class NPOI.SS.Formula.PTG.Ptg : object {
    public static Ptg[] EMPTY_PTG_ARRAY;
    public static byte CLASS_REF;
    public static byte CLASS_VALUE;
    public static byte CLASS_ARRAY;
    private byte ptgClass;
    public int Size { get; }
    public bool IsBaseToken { get; }
    public byte PtgClass { get; public set; }
    public byte DefaultOperandClass { get; }
    public char RVAType { get; }
    private static Ptg();
    public static Ptg[] ReadTokens(int size, ILittleEndianInput in1);
    public static Ptg CreatePtg(ILittleEndianInput in1);
    private static Ptg CreateClassifiedPtg(byte id, ILittleEndianInput in1);
    private static Ptg CreateBasePtg(byte id, ILittleEndianInput in1);
    private static Ptg[] ToPtgArray(ArrayList l);
    public virtual object Clone();
    public static int GetEncodedSize(Ptg[] ptgs);
    public static int GetEncodedSizeWithoutArrayData(Ptg[] ptgs);
    public static int SerializePtgs(Ptg[] ptgs, Byte[] array, int offset);
    public abstract virtual int get_Size();
    public abstract virtual bool get_IsBaseToken();
    public abstract virtual void Write(ILittleEndianOutput out1);
    public abstract virtual string ToFormulaString();
    public virtual string ToString();
    public byte get_PtgClass();
    public void set_PtgClass(byte value);
    public abstract virtual byte get_DefaultOperandClass();
    public char get_RVAType();
    private sealed virtual override object System.ICloneable.Clone();
    public static bool DoesFormulaReferToDeletedCell(Ptg[] ptgs);
    private static bool IsDeletedCellRef(Ptg ptg);
}
public interface NPOI.SS.Formula.PTG.Pxg {
    public int ExternalWorkbookNumber { get; }
    public string SheetName { get; public set; }
    public abstract virtual int get_ExternalWorkbookNumber();
    public abstract virtual string get_SheetName();
    public abstract virtual void set_SheetName(string value);
    public abstract virtual string ToFormulaString();
}
public interface NPOI.SS.Formula.PTG.Pxg3D {
    public string LastSheetName { get; public set; }
    public abstract virtual string get_LastSheetName();
    public abstract virtual void set_LastSheetName(string value);
}
public class NPOI.SS.Formula.PTG.RangePtg : OperationPtg {
    public static int SIZE;
    public static byte sid;
    public static OperationPtg instance;
    public bool IsBaseToken { get; }
    public int Size { get; }
    public int NumberOfOperands { get; }
    private static RangePtg();
    public virtual bool get_IsBaseToken();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual string ToFormulaString();
    public virtual string ToFormulaString(String[] operands);
    public virtual int get_NumberOfOperands();
}
public abstract class NPOI.SS.Formula.PTG.Ref2DPtgBase : RefPtgBase {
    private static int SIZE;
    protected byte Sid { get; }
    public int Size { get; }
    protected Ref2DPtgBase(string cellref);
    protected Ref2DPtgBase(CellReference cr);
    protected Ref2DPtgBase(int row, int column, bool isRowRelative, bool isColumnRelative);
    protected Ref2DPtgBase(ILittleEndianInput in1);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual string ToFormulaString();
    protected abstract virtual byte get_Sid();
    public virtual int get_Size();
    public virtual string ToString();
}
public class NPOI.SS.Formula.PTG.Ref3DPtg : RefPtgBase {
    public static byte sid;
    private static int SIZE;
    private int field_1_index_extern_sheet;
    private BitField rowRelative;
    private BitField colRelative;
    public int Size { get; }
    public int ExternSheetIndex { get; public set; }
    public byte DefaultOperandClass { get; }
    public Ref3DPtg(ILittleEndianInput in1);
    public Ref3DPtg(string cellref, int externIdx);
    public Ref3DPtg(CellReference cr, int externIdx);
    public virtual string ToString();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public sealed virtual int get_ExternSheetIndex();
    public void set_ExternSheetIndex(int value);
    public sealed virtual string ToFormulaString(IFormulaRenderingWorkbook book);
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
}
public class NPOI.SS.Formula.PTG.Ref3DPxg : RefPtgBase {
    private int externalWorkbookNumber;
    private string firstSheetName;
    private string lastSheetName;
    public int ExternalWorkbookNumber { get; }
    public string SheetName { get; public set; }
    public string LastSheetName { get; public set; }
    public int Size { get; }
    public Ref3DPxg(int externalWorkbookNumber, SheetIdentifier sheetName, string cellref);
    public Ref3DPxg(int externalWorkbookNumber, SheetIdentifier sheetName, CellReference c);
    public Ref3DPxg(SheetIdentifier sheetName, string cellref);
    public Ref3DPxg(SheetIdentifier sheetName, CellReference c);
    public virtual string ToString();
    public sealed virtual int get_ExternalWorkbookNumber();
    public sealed virtual string get_SheetName();
    public sealed virtual void set_SheetName(string value);
    public sealed virtual string get_LastSheetName();
    public sealed virtual void set_LastSheetName(string value);
    public string Format2DRefAsString();
    public virtual string ToFormulaString();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
}
public class NPOI.SS.Formula.PTG.RefErrorPtg : OperandPtg {
    private static int SIZE;
    public static byte sid;
    private int field_1_reserved;
    public int Reserved { get; public set; }
    public int Size { get; }
    public byte DefaultOperandClass { get; }
    public RefErrorPtg(ILittleEndianInput in1);
    public virtual string ToString();
    public virtual void Write(ILittleEndianOutput out1);
    public int get_Reserved();
    public void set_Reserved(int value);
    public virtual int get_Size();
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
}
public class NPOI.SS.Formula.PTG.RefNPtg : Ref2DPtgBase {
    public static byte sid;
    protected byte Sid { get; }
    public RefNPtg(ILittleEndianInput in1);
    protected virtual byte get_Sid();
}
public class NPOI.SS.Formula.PTG.RefPtg : Ref2DPtgBase {
    public static byte sid;
    protected byte Sid { get; }
    public RefPtg(string cellref);
    public RefPtg(int row, int column, bool isRowRelative, bool isColumnRelative);
    public RefPtg(ILittleEndianInput in1);
    public RefPtg(CellReference cr);
    protected virtual byte get_Sid();
}
public abstract class NPOI.SS.Formula.PTG.RefPtgBase : OperandPtg {
    private int field_1_row;
    private int field_2_col;
    private static BitField rowRelative;
    private static BitField colRelative;
    private static BitField column;
    public int Row { get; public set; }
    public int RowAsInt { get; }
    public bool IsRowRelative { get; public set; }
    public bool IsColRelative { get; public set; }
    public int ColumnRawX { get; public set; }
    public int Column { get; public set; }
    public byte DefaultOperandClass { get; }
    protected RefPtgBase(string cellref);
    protected RefPtgBase(CellReference c);
    protected RefPtgBase(int row, int column, bool isRowRelative, bool isColumnRelative);
    protected RefPtgBase(ILittleEndianInput in1);
    private static RefPtgBase();
    protected void ReadCoordinates(ILittleEndianInput in1);
    protected void WriteCoordinates(ILittleEndianOutput out1);
    protected void WriteCoordinates(Byte[] array, int offset);
    public int get_Row();
    public void set_Row(int value);
    public int get_RowAsInt();
    public bool get_IsRowRelative();
    public void set_IsRowRelative(bool value);
    public bool get_IsColRelative();
    public void set_IsColRelative(bool value);
    public int get_ColumnRawX();
    public void set_ColumnRawX(int value);
    public int get_Column();
    public void set_Column(int value);
    public string FormatReferenceAsString();
    public virtual byte get_DefaultOperandClass();
}
public abstract class NPOI.SS.Formula.PTG.ScalarConstantPtg : Ptg {
    public bool IsBaseToken { get; }
    public byte DefaultOperandClass { get; }
    public virtual bool get_IsBaseToken();
    public virtual byte get_DefaultOperandClass();
}
public class NPOI.SS.Formula.PTG.SharedFormula : object {
    private int _columnWrappingMask;
    private int _rowWrappingMask;
    public SharedFormula(SpreadsheetVersion ssVersion);
    public Ptg[] ConvertSharedFormulas(Ptg[] ptgs, int formulaRow, int formulaColumn);
    private int FixupRelativeColumn(int currentcolumn, int column, bool relative);
    private int FixupRelativeRow(int currentrow, int row, bool relative);
}
public class NPOI.SS.Formula.PTG.StringPtg : ScalarConstantPtg {
    public static byte sid;
    private static BitField fHighByte;
    private static char FORMULA_DELIMITER;
    private int field_1_Length;
    private byte field_2_options;
    private bool _is16bitUnicode;
    private string field_3_string;
    public string Value { get; }
    public int Size { get; }
    public StringPtg(ILittleEndianInput in1);
    public StringPtg(string value);
    private static StringPtg();
    public string get_Value();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
    public virtual string ToString();
}
public class NPOI.SS.Formula.PTG.SubtractPtg : ValueOperatorPtg {
    public static byte sid;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static SubtractPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.TblPtg : ControlPtg {
    private static int SIZE;
    public static byte sid;
    private int field_1_first_row;
    private int field_2_first_col;
    public int Size { get; }
    public int Row { get; }
    public int Column { get; }
    public TblPtg(ILittleEndianInput in1);
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public int get_Row();
    public int get_Column();
    public virtual string ToFormulaString();
    public virtual string ToString();
}
public class NPOI.SS.Formula.PTG.UnaryMinusPtg : ValueOperatorPtg {
    public static byte sid;
    private static string MINUS;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static UnaryMinusPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.UnaryPlusPtg : ValueOperatorPtg {
    public static byte sid;
    private static string Add;
    public static ValueOperatorPtg instance;
    protected byte Sid { get; }
    public int NumberOfOperands { get; }
    private static UnaryPlusPtg();
    protected virtual byte get_Sid();
    public virtual int get_NumberOfOperands();
    public virtual string ToFormulaString(String[] operands);
}
public class NPOI.SS.Formula.PTG.UnionPtg : OperationPtg {
    public static byte sid;
    public static OperationPtg instance;
    public bool IsBaseToken { get; }
    public int Size { get; }
    public int NumberOfOperands { get; }
    private static UnionPtg();
    public virtual bool get_IsBaseToken();
    public virtual int get_Size();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual string ToFormulaString();
    public virtual string ToFormulaString(String[] operands);
    public virtual int get_NumberOfOperands();
}
public class NPOI.SS.Formula.PTG.UnknownPtg : Ptg {
    private short size;
    public bool IsBaseToken { get; }
    public int Size { get; }
    public byte DefaultOperandClass { get; }
    public UnknownPtg(RecordInputStream in1);
    public virtual bool get_IsBaseToken();
    public virtual void Write(ILittleEndianOutput out1);
    public virtual int get_Size();
    public virtual string ToFormulaString();
    public virtual byte get_DefaultOperandClass();
    public virtual object Clone();
}
public abstract class NPOI.SS.Formula.PTG.ValueOperatorPtg : OperationPtg {
    public bool IsBaseToken { get; }
    public byte DefaultOperandClass { get; }
    protected byte Sid { get; }
    public int Size { get; }
    public virtual bool get_IsBaseToken();
    public virtual byte get_DefaultOperandClass();
    public virtual void Write(ILittleEndianOutput out1);
    protected abstract virtual byte get_Sid();
    public virtual int get_Size();
    public virtual string ToFormulaString();
}
public class NPOI.SS.Formula.SheetIdentifier : object {
    public string _bookName;
    public NameIdentifier _sheetIdentifier;
    public string BookName { get; }
    public NameIdentifier SheetId { get; }
    public SheetIdentifier(string bookName, NameIdentifier sheetIdentifier);
    public string get_BookName();
    public NameIdentifier get_SheetId();
    protected virtual void AsFormulaString(StringBuilder sb);
    public string AsFormulaString();
    public virtual string ToString();
}
public class NPOI.SS.Formula.SheetNameFormatter : object {
    private static string BIFF8_LAST_COLUMN;
    private static int BIFF8_LAST_COLUMN_TEXT_LEN;
    private static string BIFF8_LAST_ROW;
    private static int BIFF8_LAST_ROW_TEXT_LEN;
    private static char DELIMITER;
    private static string CELL_REF_PATTERN;
    private static SheetNameFormatter();
    public static string Format(string rawSheetName);
    public static void AppendFormat(StringBuilder out1, string rawSheetName);
    public static void AppendFormat(StringBuilder out1, string workbookName, string rawSheetName);
    private static void AppendAndEscape(StringBuilder sb, string rawSheetName);
    private static bool NeedsDelimiting(string rawSheetName);
    private static bool NameLooksLikeBooleanLiteral(string rawSheetName);
    private static bool IsSpecialChar(char ch);
    public static bool CellReferenceIsWithinRange(string lettersPrefix, string numbersSuffix);
    public static bool NameLooksLikePlainCellReference(string rawSheetName);
}
public class NPOI.SS.Formula.SheetRangeEvaluator : object {
    private int _firstSheetIndex;
    private int _lastSheetIndex;
    private SheetRefEvaluator[] _sheetEvaluators;
    public int FirstSheetIndex { get; }
    public int LastSheetIndex { get; }
    public string SheetNameRange { get; }
    public SheetRangeEvaluator(int firstSheetIndex, int lastSheetIndex, SheetRefEvaluator[] sheetEvaluators);
    public SheetRangeEvaluator(int onlySheetIndex, SheetRefEvaluator sheetEvaluator);
    public SheetRefEvaluator GetSheetEvaluator(int sheetIndex);
    public sealed virtual int get_FirstSheetIndex();
    public sealed virtual int get_LastSheetIndex();
    public string GetSheetName(int sheetIndex);
    public string get_SheetNameRange();
    public ValueEval GetEvalForCell(int sheetIndex, int rowIndex, int columnIndex);
}
public class NPOI.SS.Formula.SheetRangeIdentifier : SheetIdentifier {
    public NameIdentifier _lastSheetIdentifier;
    public NameIdentifier FirstSheetIdentifier { get; }
    public NameIdentifier LastSheetIdentifier { get; }
    public SheetRangeIdentifier(string bookName, NameIdentifier firstSheetIdentifier, NameIdentifier lastSheetIdentifier);
    public NameIdentifier get_FirstSheetIdentifier();
    public NameIdentifier get_LastSheetIdentifier();
    protected virtual void AsFormulaString(StringBuilder sb);
}
public class NPOI.SS.Formula.SheetRefEvaluator : object {
    private WorkbookEvaluator _bookEvaluator;
    private EvaluationTracker _tracker;
    private IEvaluationSheet _sheet;
    private int _sheetIndex;
    public string SheetName { get; }
    private IEvaluationSheet Sheet { get; }
    public SheetRefEvaluator(WorkbookEvaluator bookEvaluator, EvaluationTracker tracker, int sheetIndex);
    public string get_SheetName();
    public ValueEval GetEvalForCell(int rowIndex, int columnIndex);
    private IEvaluationSheet get_Sheet();
    public bool IsSubTotal(int rowIndex, int columnIndex);
}
internal class NPOI.SS.Formula.SingleValueAttribute : Attribute {
    private bool _isSingleValue;
    public bool IsSingleValue { get; }
    public SingleValueAttribute(bool isSingleValue);
    public bool get_IsSingleValue();
}
public interface NPOI.SS.Formula.ThreeDEval {
    public abstract virtual ValueEval GetValue(int sheetIndex, int rowIndex, int columnIndex);
}
public class NPOI.SS.Formula.TotallyImmutable : IStabilityClassifier {
    public virtual bool IsCellFinal(int sheetIndex, int rowIndex, int columnIndex);
}
public interface NPOI.SS.Formula.TwoDEval {
    public int Width { get; }
    public int Height { get; }
    public bool IsRow { get; }
    public bool IsColumn { get; }
    public abstract virtual ValueEval GetValue(int rowIndex, int columnIndex);
    public abstract virtual int get_Width();
    public abstract virtual int get_Height();
    public abstract virtual bool get_IsRow();
    public abstract virtual bool get_IsColumn();
    public abstract virtual TwoDEval GetRow(int rowIndex);
    public abstract virtual TwoDEval GetColumn(int columnIndex);
    public abstract virtual bool IsSubTotal(int rowIndex, int columnIndex);
}
public class NPOI.SS.Formula.UDF.AggregatingUDFFinder : UDFFinder {
    private List`1<UDFFinder> _usedToolPacks;
    public AggregatingUDFFinder(UDFFinder[] usedToolPacks);
    public virtual FreeRefFunction FindFunction(string name);
    public void Add(UDFFinder toolPack);
}
public class NPOI.SS.Formula.UDF.DefaultUDFFinder : UDFFinder {
    private Dictionary`2<string, FreeRefFunction> _functionsByName;
    public DefaultUDFFinder(String[] functionNames, FreeRefFunction[] functionImpls);
    public virtual FreeRefFunction FindFunction(string name);
}
public class NPOI.SS.Formula.UDF.IndexedUDFFinder : AggregatingUDFFinder {
    private Dictionary`2<int, string> _funcMap;
    public IndexedUDFFinder(UDFFinder[] usedToolPacks);
    public virtual FreeRefFunction FindFunction(string name);
    public string GetFunctionName(int idx);
    public int GetFunctionIndex(string name);
}
public abstract class NPOI.SS.Formula.UDF.UDFFinder : object {
    public static UDFFinder GetDefault();
    public abstract virtual FreeRefFunction FindFunction(string name);
}
public class NPOI.SS.Formula.UserDefinedFunction : object {
    public static FreeRefFunction instance;
    private static UserDefinedFunction();
    public sealed virtual ValueEval Evaluate(ValueEval[] args, OperationEvaluationContext ec);
}
public interface NPOI.SS.Formula.WorkbookDependentFormula {
    public abstract virtual string ToFormulaString(IFormulaRenderingWorkbook book);
}
public class NPOI.SS.Formula.WorkbookEvaluator : object {
    private IEvaluationWorkbook _workbook;
    private EvaluationCache _cache;
    private int _workbookIx;
    private IEvaluationListener _evaluationListener;
    private Dictionary`2<IEvaluationSheet, int> _sheetIndexesBySheet;
    private Dictionary`2<string, int> _sheetIndexesByName;
    private CollaboratingWorkbooksEnvironment _collaboratingWorkbookEnvironment;
    private IStabilityClassifier _stabilityClassifier;
    private UDFFinder _udfFinder;
    private bool _ignoreMissingWorkbooks;
    private bool dbgEvaluationOutputForNextEval;
    private POILogger EVAL_LOG;
    private int dbgEvaluationOutputIndent;
    internal IEvaluationWorkbook Workbook { get; }
    public bool IgnoreMissingWorkbooks { get; public set; }
    public bool DebugEvaluationOutputForNextEval { get; public set; }
    public WorkbookEvaluator(IEvaluationWorkbook workbook, IStabilityClassifier stabilityClassifier, UDFFinder udfFinder);
    public WorkbookEvaluator(IEvaluationWorkbook workbook, IEvaluationListener evaluationListener, IStabilityClassifier stabilityClassifier, UDFFinder udfFinder);
    public string GetSheetName(int sheetIndex);
    public WorkbookEvaluator GetOtherWorkbookEvaluator(string workbookName);
    internal IEvaluationWorkbook get_Workbook();
    internal IEvaluationSheet GetSheet(int sheetIndex);
    internal IEvaluationName GetName(string name, int sheetIndex);
    private static bool IsDebugLogEnabled();
    private static bool IsInfoLogEnabled();
    private static void LogDebug(string s);
    private static void LogInfo(string s);
    public void AttachToEnvironment(CollaboratingWorkbooksEnvironment collaboratingWorkbooksEnvironment, EvaluationCache cache, int workbookIx);
    public CollaboratingWorkbooksEnvironment GetEnvironment();
    public void DetachFromEnvironment();
    public IEvaluationListener GetEvaluationListener();
    public void ClearAllCachedResultValues();
    public void NotifyUpdateCell(IEvaluationCell cell);
    public void NotifyDeleteCell(IEvaluationCell cell);
    public int GetSheetIndex(IEvaluationSheet sheet);
    internal int GetSheetIndexByExternIndex(int externSheetIndex);
    public int GetSheetIndex(string sheetName);
    public ValueEval Evaluate(IEvaluationCell srcCell);
    public ValueEval Evaluate(string formula, CellReference reference);
    public ValueEval Evaluate(string formula, CellReference target, CellRangeAddressBase region);
    private ValueEval Evaluate(string formula, CellReference target, CellRangeAddressBase region, FormulaType formulaType);
    protected bool AdjustRegionRelativeReference(Ptg[] ptgs, CellReference target, CellRangeAddressBase region);
    private ValueEval EvaluateAny(IEvaluationCell srcCell, int sheetIndex, int rowIndex, int columnIndex, EvaluationTracker tracker);
    private NotImplementedException AddExceptionInfo(NotImplementedException inner, int sheetIndex, int rowIndex, int columnIndex);
    internal static ValueEval GetValueFromNonFormulaCell(IEvaluationCell cell);
    public ValueEval EvaluateFormula(OperationEvaluationContext ec, Ptg[] ptgs);
    private static int CountTokensToBeSkipped(Ptg[] ptgs, int startIndex, int distInBytes);
    public static ValueEval DereferenceResult(ValueEval evaluationResult, int srcRowNum, int srcColNum);
    public static ValueEval DereferenceResult(ValueEval evaluationResult, OperationEvaluationContext ec);
    private ValueEval GetEvalForPtg(Ptg ptg, OperationEvaluationContext ec);
    private ValueEval ProcessNameEval(ValueEval eval, OperationEvaluationContext ec);
    private ValueEval GetEvalForNameRecord(IEvaluationName nameRecord, OperationEvaluationContext ec);
    internal ValueEval EvaluateNameFormula(Ptg[] ptgs, OperationEvaluationContext ec);
    public ValueEval EvaluateReference(IEvaluationSheet sheet, int sheetIndex, int rowIndex, int columnIndex, EvaluationTracker tracker);
    public FreeRefFunction FindUserDefinedFunction(string functionName);
    public bool get_IgnoreMissingWorkbooks();
    public void set_IgnoreMissingWorkbooks(bool value);
    public static IList`1<string> GetSupportedFunctionNames();
    public static IList`1<string> GetNotSupportedFunctionNames();
    public static void RegisterFunction(string name, FreeRefFunction func);
    public static void RegisterFunction(string name, Function func);
    public bool get_DebugEvaluationOutputForNextEval();
    public void set_DebugEvaluationOutputForNextEval(bool value);
}
public class NPOI.SS.Formula.WorkbookNotFoundException : Exception {
    public WorkbookNotFoundException(string msg);
}
public class NPOI.SS.HtmlDocumentFacade : object {
    protected XmlElement body;
    protected XmlDocument document;
    protected XmlElement head;
    protected XmlElement html;
    private Dictionary`2<string, Dictionary`2<string, string>> stylesheet;
    private XmlElement stylesheetElement;
    protected XmlElement title;
    protected XmlText titleText;
    public XmlElement Body { get; }
    public XmlDocument Document { get; }
    public XmlElement Head { get; }
    public string Title { get; public set; }
    public HtmlDocumentFacade(XmlDocument document);
    public void AddCharset();
    public void AddAuthor(string value);
    public void AddDescription(string value);
    public void AddKeywords(string value);
    public void AddMeta(string name, string value);
    public void AddStyleClass(XmlElement element, string classNamePrefix, string style);
    public XmlElement CreateBlock();
    public XmlElement CreateBookmark(string name);
    public XmlElement CreateHeader1();
    public XmlElement CreateHeader2();
    public XmlElement CreateHyperlink(string internalDestination);
    public XmlElement CreateImage(string src);
    public XmlElement CreateLineBreak();
    public XmlElement CreateListItem();
    public XmlElement CreateParagraph();
    public XmlElement CreateTable();
    public XmlElement CreateTableBody();
    public XmlElement CreateTableCell();
    public XmlElement CreateTableColumn();
    public XmlElement CreateTableColumnGroup();
    public XmlElement CreateTableHeader();
    public XmlElement CreateTableHeaderCell();
    public XmlElement CreateTableRow();
    public XmlText CreateText(string data);
    public XmlElement CreateUnorderedList();
    public XmlElement get_Body();
    public XmlDocument get_Document();
    public XmlElement get_Head();
    public string GetOrCreateCssClass(string tagName, string classNamePrefix, string style);
    public string get_Title();
    public void set_Title(string value);
    public void UpdateStylesheet();
}
public class NPOI.SS.SpreadsheetVersion : object {
    public static SpreadsheetVersion EXCEL97;
    public static SpreadsheetVersion EXCEL2007;
    private string _defaultExtension;
    private int _maxRows;
    private int _maxColumns;
    private int _maxFunctionArgs;
    private int _maxCondFormats;
    private int _maxCellStyles;
    private int _maxTextLength;
    private string _name;
    public string Name { get; }
    public string DefaultExtension { get; }
    public int MaxRows { get; }
    public int LastRowIndex { get; }
    public int MaxColumns { get; }
    public int LastColumnIndex { get; }
    public int MaxFunctionArgs { get; }
    public int MaxConditionalFormats { get; }
    public string LastColumnName { get; }
    public int MaxCellStyles { get; }
    public int MaxTextLength { get; }
    private SpreadsheetVersion(string defaultExtension, int maxRows, int maxColumns, int maxFunctionArgs, int maxCondFormats, int maxCellStyles, int maxText, string name);
    private static SpreadsheetVersion();
    public string get_Name();
    public string get_DefaultExtension();
    public int get_MaxRows();
    public int get_LastRowIndex();
    public int get_MaxColumns();
    public int get_LastColumnIndex();
    public int get_MaxFunctionArgs();
    public int get_MaxConditionalFormats();
    public string get_LastColumnName();
    public int get_MaxCellStyles();
    public int get_MaxTextLength();
}
public enum NPOI.SS.UserModel.AnchorType : Enum {
    public int value__;
    public static AnchorType MoveAndResize;
    public static AnchorType MoveDontResize;
    public static AnchorType DontMoveAndResize;
}
public enum NPOI.SS.UserModel.BorderDiagonal : Enum {
    public int value__;
    public static BorderDiagonal None;
    public static BorderDiagonal Backward;
    public static BorderDiagonal Forward;
    public static BorderDiagonal Both;
}
public enum NPOI.SS.UserModel.BorderExtent : Enum {
    public int value__;
    public static BorderExtent NONE;
    public static BorderExtent ALL;
    public static BorderExtent INSIDE;
    public static BorderExtent OUTSIDE;
    public static BorderExtent TOP;
    public static BorderExtent BOTTOM;
    public static BorderExtent LEFT;
    public static BorderExtent RIGHT;
    public static BorderExtent HORIZONTAL;
    public static BorderExtent INSIDE_HORIZONTAL;
    public static BorderExtent OUTSIDE_HORIZONTAL;
    public static BorderExtent VERTICAL;
    public static BorderExtent INSIDE_VERTICAL;
    public static BorderExtent OUTSIDE_VERTICAL;
}
public enum NPOI.SS.UserModel.BorderStyle : Enum {
    public short value__;
    public static BorderStyle None;
    public static BorderStyle Thin;
    public static BorderStyle Medium;
    public static BorderStyle Dashed;
    public static BorderStyle Dotted;
    public static BorderStyle Thick;
    public static BorderStyle Double;
    public static BorderStyle Hair;
    public static BorderStyle MediumDashed;
    public static BorderStyle DashDot;
    public static BorderStyle MediumDashDot;
    public static BorderStyle DashDotDot;
    public static BorderStyle MediumDashDotDot;
    public static BorderStyle SlantedDashDot;
}
public class NPOI.SS.UserModel.BorderStyleEnum : object {
    private static BorderStyle[] _table;
    private static BorderStyleEnum();
    public static BorderStyle[] Values();
    public static BorderStyle ValueOf(short code);
}
public class NPOI.SS.UserModel.BuiltinFormats : object {
    public static int FIRST_USER_DEFINED_FORMAT_INDEX;
    private static String[] _formats;
    private static BuiltinFormats();
    public static String[] GetAll();
    public static string GetBuiltinFormat(int index);
    public static int GetBuiltinFormat(string pFmt);
}
public class NPOI.SS.UserModel.CellCopyPolicy : object {
    public static bool DEFAULT_COPY_CELL_VALUE_POLICY;
    public static bool DEFAULT_COPY_CELL_STYLE_POLICY;
    public static bool DEFAULT_COPY_CELL_FORMULA_POLICY;
    public static bool DEFAULT_COPY_HYPERLINK_POLICY;
    public static bool DEFAULT_MERGE_HYPERLINK_POLICY;
    public static bool DEFAULT_COPY_ROW_HEIGHT_POLICY;
    public static bool DEFAULT_CONDENSE_ROWS_POLICY;
    public static bool DEFAULT_COPY_MERGED_REGIONS_POLICY;
    private bool copyCellValue;
    private bool copyCellStyle;
    private bool copyCellFormula;
    private bool copyHyperlink;
    private bool mergeHyperlink;
    private bool copyRowHeight;
    private bool condenseRows;
    private bool copyMergedRegions;
    public bool IsCopyCellValue { get; public set; }
    public bool IsCopyCellStyle { get; public set; }
    public bool IsCopyCellFormula { get; public set; }
    public bool IsCopyHyperlink { get; public set; }
    public bool IsMergeHyperlink { get; public set; }
    public bool IsCopyRowHeight { get; public set; }
    public bool IsCondenseRows { get; public set; }
    public bool IsCopyMergedRegions { get; public set; }
    public CellCopyPolicy(CellCopyPolicy other);
    private CellCopyPolicy(Builder builder);
    private static CellCopyPolicy();
    public Builder CreateBuilder();
    public bool get_IsCopyCellValue();
    public void set_IsCopyCellValue(bool value);
    public bool get_IsCopyCellStyle();
    public void set_IsCopyCellStyle(bool value);
    public bool get_IsCopyCellFormula();
    public void set_IsCopyCellFormula(bool value);
    public bool get_IsCopyHyperlink();
    public void set_IsCopyHyperlink(bool value);
    public bool get_IsMergeHyperlink();
    public void set_IsMergeHyperlink(bool value);
    public bool get_IsCopyRowHeight();
    public void set_IsCopyRowHeight(bool value);
    public bool get_IsCondenseRows();
    public void set_IsCondenseRows(bool value);
    public bool get_IsCopyMergedRegions();
    public void set_IsCopyMergedRegions(bool value);
    public CellCopyPolicy Clone();
}
public enum NPOI.SS.UserModel.CellType : Enum {
    public int value__;
    public static CellType Unknown;
    public static CellType Numeric;
    public static CellType String;
    public static CellType Formula;
    public static CellType Blank;
    public static CellType Boolean;
    public static CellType Error;
}
public class NPOI.SS.UserModel.CellValue : object {
    public static CellValue TRUE;
    public static CellValue FALSE;
    private CellType _cellType;
    private double _numberValue;
    private bool _boolValue;
    private string _textValue;
    private int _errorCode;
    public bool BooleanValue { get; }
    public double NumberValue { get; }
    public string StringValue { get; }
    public CellType CellType { get; }
    public sbyte ErrorValue { get; }
    private CellValue(CellType cellType, double numberValue, bool boolValue, string textValue, int errorCode);
    public CellValue(double numberValue);
    public CellValue(string stringValue);
    private static CellValue();
    public static CellValue ValueOf(bool boolValue);
    public static CellValue GetError(int errorCode);
    public bool get_BooleanValue();
    public double get_NumberValue();
    public string get_StringValue();
    public CellType get_CellType();
    public sbyte get_ErrorValue();
    public virtual string ToString();
    public string FormatAsString();
}
public enum NPOI.SS.UserModel.Charts.AxisCrossBetween : Enum {
    public int value__;
    public static AxisCrossBetween Between;
    public static AxisCrossBetween MidpointCategory;
}
public enum NPOI.SS.UserModel.Charts.AxisCrosses : Enum {
    public int value__;
    public static AxisCrosses AutoZero;
    public static AxisCrosses Min;
    public static AxisCrosses Max;
}
public enum NPOI.SS.UserModel.Charts.AxisOrientation : Enum {
    public int value__;
    public static AxisOrientation MaxToMin;
    public static AxisOrientation MinToMax;
}
public enum NPOI.SS.UserModel.Charts.AxisPosition : Enum {
    public int value__;
    public static AxisPosition Bottom;
    public static AxisPosition Left;
    public static AxisPosition Right;
    public static AxisPosition Top;
}
public enum NPOI.SS.UserModel.Charts.AxisTickMark : Enum {
    public int value__;
    public static AxisTickMark None;
    public static AxisTickMark Cross;
    public static AxisTickMark In;
    public static AxisTickMark Out;
}
public class NPOI.SS.UserModel.Charts.DataSources : object {
    public static IChartDataSource`1<T> FromArray(T[] elements);
    public static IChartDataSource`1<double> FromNumericCellRange(ISheet sheet, CellRangeAddress cellRangeAddress);
    public static IChartDataSource`1<string> FromStringCellRange(ISheet sheet, CellRangeAddress cellRangeAddress);
}
public interface NPOI.SS.UserModel.Charts.IAreaChartData`2 {
    public abstract virtual IAreaChartSeries`2<Tx, Ty> AddSeries(IChartDataSource`1<Tx> categories, IChartDataSource`1<Ty> values);
    public abstract virtual List`1<IAreaChartSeries`2<Tx, Ty>> GetSeries();
}
public interface NPOI.SS.UserModel.Charts.IAreaChartSeries`2 {
    public abstract virtual IChartDataSource`1<Tx> GetCategoryAxisData();
    public abstract virtual IChartDataSource`1<Ty> GetValues();
}
public interface NPOI.SS.UserModel.Charts.IBarChartData`2 {
    public abstract virtual IBarChartSeries`2<Tx, Ty> AddSeries(IChartDataSource`1<Tx> categories, IChartDataSource`1<Ty> values);
    public abstract virtual List`1<IBarChartSeries`2<Tx, Ty>> GetSeries();
}
public interface NPOI.SS.UserModel.Charts.IBarChartSeries`2 {
    public abstract virtual IChartDataSource`1<Tx> GetCategoryAxisData();
    public abstract virtual IChartDataSource`1<Ty> GetValues();
}
public interface NPOI.SS.UserModel.Charts.IChartAxis {
    public long Id { get; }
    public AxisPosition Position { get; public set; }
    public string NumberFormat { get; public set; }
    public bool IsSetLogBase { get; }
    public double LogBase { get; public set; }
    public bool IsSetMinimum { get; }
    public double Minimum { get; public set; }
    public bool IsSetMaximum { get; }
    public double Maximum { get; public set; }
    public AxisOrientation Orientation { get; public set; }
    public AxisCrosses Crosses { get; public set; }
    public bool IsVisible { get; public set; }
    public AxisTickMark MajorTickMark { get; public set; }
    public AxisTickMark MinorTickMark { get; public set; }
    public abstract virtual long get_Id();
    public abstract virtual AxisPosition get_Position();
    public abstract virtual void set_Position(AxisPosition value);
    public abstract virtual string get_NumberFormat();
    public abstract virtual void set_NumberFormat(string value);
    public abstract virtual bool get_IsSetLogBase();
    public abstract virtual double get_LogBase();
    public abstract virtual void set_LogBase(double value);
    public abstract virtual bool get_IsSetMinimum();
    public abstract virtual double get_Minimum();
    public abstract virtual void set_Minimum(double value);
    public abstract virtual bool get_IsSetMaximum();
    public abstract virtual double get_Maximum();
    public abstract virtual void set_Maximum(double value);
    public abstract virtual AxisOrientation get_Orientation();
    public abstract virtual void set_Orientation(AxisOrientation value);
    public abstract virtual AxisCrosses get_Crosses();
    public abstract virtual void set_Crosses(AxisCrosses value);
    public abstract virtual void CrossAxis(IChartAxis axis);
    public abstract virtual bool get_IsVisible();
    public abstract virtual void set_IsVisible(bool value);
    public abstract virtual AxisTickMark get_MajorTickMark();
    public abstract virtual void set_MajorTickMark(AxisTickMark value);
    public abstract virtual AxisTickMark get_MinorTickMark();
    public abstract virtual void set_MinorTickMark(AxisTickMark value);
}
public interface NPOI.SS.UserModel.Charts.IChartAxisFactory {
    public abstract virtual IValueAxis CreateValueAxis(AxisPosition pos);
    public abstract virtual IChartAxis CreateCategoryAxis(AxisPosition pos);
    public abstract virtual IChartAxis CreateDateAxis(AxisPosition pos);
}
public interface NPOI.SS.UserModel.Charts.IChartData {
    public abstract virtual void FillChart(IChart chart, IChartAxis[] axis);
}
public interface NPOI.SS.UserModel.Charts.IChartDataFactory {
    public abstract virtual IScatterChartData`2<Tx, Ty> CreateScatterChartData();
    public abstract virtual ILineChartData`2<Tx, Ty> CreateLineChartData();
    public abstract virtual IBarChartData`2<Tx, Ty> CreateBarChartData();
    public abstract virtual IPieChartData`2<Tx, Ty> CreatePieChartData();
    public abstract virtual IColumnChartData`2<Tx, Ty> CreateColumnChartData();
    public abstract virtual IAreaChartData`2<Tx, Ty> CreateAreaChartData();
}
public interface NPOI.SS.UserModel.Charts.IChartDataSource`1 {
    public int PointCount { get; }
    public bool IsReference { get; }
    public bool IsNumeric { get; }
    public string FormulaString { get; }
    public abstract virtual int get_PointCount();
    public abstract virtual T GetPointAt(int index);
    public abstract virtual bool get_IsReference();
    public abstract virtual bool get_IsNumeric();
    public abstract virtual string get_FormulaString();
}
public interface NPOI.SS.UserModel.Charts.IChartLegend {
    public LegendPosition Position { get; public set; }
    public bool IsOverlay { get; public set; }
    public abstract virtual LegendPosition get_Position();
    public abstract virtual void set_Position(LegendPosition value);
    public abstract virtual bool get_IsOverlay();
    public abstract virtual void set_IsOverlay(bool value);
}
public interface NPOI.SS.UserModel.Charts.IChartSeries {
    public abstract virtual void SetTitle(string title);
    public abstract virtual void SetTitle(CellReference titleReference);
    public abstract virtual string GetTitleString();
    public abstract virtual CellReference GetTitleCellReference();
    public abstract virtual Nullable`1<TitleType> GetTitleType();
}
public interface NPOI.SS.UserModel.Charts.IColumnChartData`2 {
    public abstract virtual IColumnChartSeries`2<Tx, Ty> AddSeries(IChartDataSource`1<Tx> categories, IChartDataSource`1<Ty> values);
    public abstract virtual List`1<IColumnChartSeries`2<Tx, Ty>> GetSeries();
}
public interface NPOI.SS.UserModel.Charts.IColumnChartSeries`2 {
    public abstract virtual IChartDataSource`1<Tx> GetCategoryAxisData();
    public abstract virtual IChartDataSource`1<Ty> GetValues();
}
public interface NPOI.SS.UserModel.Charts.ILineChartData`2 {
    public abstract virtual ILineChartSeries`2<Tx, Ty> AddSeries(IChartDataSource`1<Tx> categories, IChartDataSource`1<Ty> values);
    public abstract virtual List`1<ILineChartSeries`2<Tx, Ty>> GetSeries();
}
public interface NPOI.SS.UserModel.Charts.ILineChartSeries`2 {
    public abstract virtual IChartDataSource`1<Tx> GetCategoryAxisData();
    public abstract virtual IChartDataSource`1<Ty> GetValues();
}
public interface NPOI.SS.UserModel.Charts.IManualLayout {
    public abstract virtual void SetTarget(LayoutTarget target);
    public abstract virtual LayoutTarget GetTarget();
    public abstract virtual void SetXMode(LayoutMode mode);
    public abstract virtual LayoutMode GetXMode();
    public abstract virtual void SetYMode(LayoutMode mode);
    public abstract virtual LayoutMode GetYMode();
    public abstract virtual double GetX();
    public abstract virtual void SetX(double x);
    public abstract virtual double GetY();
    public abstract virtual void SetY(double y);
    public abstract virtual void SetWidthMode(LayoutMode mode);
    public abstract virtual LayoutMode GetWidthMode();
    public abstract virtual void SetHeightMode(LayoutMode mode);
    public abstract virtual LayoutMode GetHeightMode();
    public abstract virtual void SetWidthRatio(double ratio);
    public abstract virtual double GetWidthRatio();
    public abstract virtual void SetHeightRatio(double ratio);
    public abstract virtual double GetHeightRatio();
}
public interface NPOI.SS.UserModel.Charts.IPieChartData`2 {
    public abstract virtual IPieChartSeries`2<Tx, Ty> AddSeries(IChartDataSource`1<Tx> categories, IChartDataSource`1<Ty> values);
    public abstract virtual List`1<IPieChartSeries`2<Tx, Ty>> GetSeries();
}
public interface NPOI.SS.UserModel.Charts.IPieChartSeries`2 {
    public abstract virtual IChartDataSource`1<Tx> GetCategoryAxisData();
    public abstract virtual IChartDataSource`1<Ty> GetValues();
}
public interface NPOI.SS.UserModel.Charts.IScatterChartData`2 {
    public abstract virtual IScatterChartSeries`2<Tx, Ty> AddSeries(IChartDataSource`1<Tx> xs, IChartDataSource`1<Ty> ys);
    public abstract virtual IScatterChartSeries`2<Tx, Ty> AddSeries(IChartDataSource`1<Ty> values);
    public abstract virtual List`1<IScatterChartSeries`2<Tx, Ty>> GetSeries();
}
public interface NPOI.SS.UserModel.Charts.IScatterChartSeries`2 {
    public abstract virtual IChartDataSource`1<Tx> GetXValues();
    public abstract virtual IChartDataSource`1<Ty> GetYValues();
}
public interface NPOI.SS.UserModel.Charts.IValueAxis {
    public abstract virtual AxisCrossBetween GetCrossBetween();
    public abstract virtual void SetCrossBetween(AxisCrossBetween crossBetween);
}
public enum NPOI.SS.UserModel.Charts.LayoutMode : Enum {
    public int value__;
    public static LayoutMode Edge;
    public static LayoutMode Factor;
}
public enum NPOI.SS.UserModel.Charts.LayoutTarget : Enum {
    public int value__;
    public static LayoutTarget Inner;
    public static LayoutTarget Outer;
}
public enum NPOI.SS.UserModel.Charts.LegendPosition : Enum {
    public int value__;
    public static LegendPosition Bottom;
    public static LegendPosition Left;
    public static LegendPosition Right;
    public static LegendPosition Top;
    public static LegendPosition TopRight;
}
public interface NPOI.SS.UserModel.Charts.ManuallyPositionable {
    public abstract virtual IManualLayout GetManualLayout();
}
public enum NPOI.SS.UserModel.Charts.TitleType : Enum {
    public int value__;
    public static TitleType String;
    public static TitleType CellReference;
}
public enum NPOI.SS.UserModel.ComparisonOperator : Enum {
    public byte value__;
    public static ComparisonOperator NoComparison;
    public static ComparisonOperator Between;
    public static ComparisonOperator NotBetween;
    public static ComparisonOperator Equal;
    public static ComparisonOperator NotEqual;
    public static ComparisonOperator GreaterThan;
    public static ComparisonOperator LessThan;
    public static ComparisonOperator GreaterThanOrEqual;
    public static ComparisonOperator LessThanOrEqual;
}
public enum NPOI.SS.UserModel.CompoundLineType : Enum {
    public int value__;
    public static CompoundLineType None;
    public static CompoundLineType SingleLine;
    public static CompoundLineType DoubleLines;
    public static CompoundLineType ThickThin;
    public static CompoundLineType ThinThick;
    public static CompoundLineType TripleLines;
}
public enum NPOI.SS.UserModel.ConditionFilterType : Enum {
    public int value__;
    public static ConditionFilterType FILTER;
    public static ConditionFilterType TOP_10;
    public static ConditionFilterType UNIQUE_VALUES;
    public static ConditionFilterType DUPLICATE_VALUES;
    public static ConditionFilterType CONTAINS_TEXT;
    public static ConditionFilterType NOT_CONTAINS_TEXT;
    public static ConditionFilterType BEGINS_WITH;
    public static ConditionFilterType ENDS_WITH;
    public static ConditionFilterType CONTAINS_BLANKS;
    public static ConditionFilterType NOT_CONTAINS_BLANKS;
    public static ConditionFilterType CONTAINS_ERRORS;
    public static ConditionFilterType NOT_CONTAINS_ERRORS;
    public static ConditionFilterType TIME_PERIOD;
    public static ConditionFilterType ABOVE_AVERAGE;
}
public class NPOI.SS.UserModel.ConditionType : object {
    private static Dictionary`2<int, ConditionType> lookup;
    public static ConditionType CellValueIs;
    public static ConditionType Formula;
    public static ConditionType ColorScale;
    public static ConditionType DataBar;
    public static ConditionType Filter;
    public static ConditionType IconSet;
    [CompilerGeneratedAttribute]
private byte <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public byte Id { get; public set; }
    public string Type { get; public set; }
    private ConditionType(int id, string type);
    private static ConditionType();
    [CompilerGeneratedAttribute]
public byte get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(byte value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static ConditionType ForId(byte id);
    public static ConditionType ForId(int id);
}
public class NPOI.SS.UserModel.DataConsolidateFunction : object {
    public static DataConsolidateFunction AVERAGE;
    public static DataConsolidateFunction COUNT;
    public static DataConsolidateFunction COUNT_NUMS;
    public static DataConsolidateFunction MAX;
    public static DataConsolidateFunction MIN;
    public static DataConsolidateFunction PRODUCT;
    public static DataConsolidateFunction STD_DEV;
    public static DataConsolidateFunction STD_DEVP;
    public static DataConsolidateFunction SUM;
    public static DataConsolidateFunction VAR;
    public static DataConsolidateFunction VARP;
    private int value;
    private string name;
    public string Name { get; }
    public int Value { get; }
    public DataConsolidateFunction(int value, string name);
    private static DataConsolidateFunction();
    public string get_Name();
    public int get_Value();
}
public class NPOI.SS.UserModel.DataFormatter : object {
    private static string defaultFractionWholePartFormat;
    private static string defaultFractionFractionPartFormat;
    private static string numPattern;
    private static string amPmPattern;
    private static string localePatternGroup;
    private static Regex colorPattern;
    private static Regex fractionPattern;
    private static Regex fractionStripper;
    private static Regex alternateGrouping;
    private static string invalidDateTimeString;
    private NumberFormatInfo decimalSymbols;
    private DateTimeFormatInfo dateSymbols;
    private DateFormat defaultDateformat;
    private FormatBase generalNumberFormat;
    private FormatBase defaultNumFormat;
    private CultureInfo currentCulture;
    private Hashtable formats;
    private bool emulateCSV;
    private static POILogger logger;
    private bool localeIsAdapting;
    [CompilerGeneratedAttribute]
private bool <Use4DigitYearsInAllDateFormats>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCachedValuesForFormulaCells>k__BackingField;
    public bool Use4DigitYearsInAllDateFormats { get; public set; }
    public bool UseCachedValuesForFormulaCells { get; public set; }
    private static DataFormatter();
    public DataFormatter(bool emulateCSV);
    public DataFormatter(CultureInfo locale);
    public DataFormatter(CultureInfo locale, bool emulateCSV);
    public DataFormatter(CultureInfo culture, bool localeIsAdapting, bool emulateCSV);
    [CompilerGeneratedAttribute]
public bool get_Use4DigitYearsInAllDateFormats();
    [CompilerGeneratedAttribute]
public void set_Use4DigitYearsInAllDateFormats(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseCachedValuesForFormulaCells();
    [CompilerGeneratedAttribute]
public void set_UseCachedValuesForFormulaCells(bool value);
    private FormatBase GetFormat(ICell cell);
    private FormatBase GetFormat(double cellValue, int formatIndex, string formatStrIn);
    public FormatBase CreateFormat(ICell cell);
    private FormatBase CreateFormat(double cellValue, int formatIndex, string sFormat);
    private string AdjustTo4DigitYearsIfConfigured(string format);
    private FormatBase CreateDateFormat(string pformatStr, double cellValue);
    private string cleanFormatForNumber(string formatStr);
    private FormatBase CreateNumberFormat(string formatStr, double cellValue);
    public FormatBase GetDefaultFormat(ICell cell);
    private FormatBase GetDefaultFormat(double cellValue);
    private string GetFormattedDateString(ICell cell);
    private string GetFormattedNumberString(ICell cell);
    public string FormatRawCellContents(double value, int formatIndex, string formatString);
    private string PerformDateFormatting(DateTime d, FormatBase dateFormat);
    public string FormatRawCellContents(double value, int formatIndex, string formatString, bool use1904Windowing);
    public string FormatCellValue(ICell cell);
    public string FormatCellValue(ICell cell, IFormulaEvaluator evaluator);
    public void SetDefaultNumberFormat(FormatBase format);
    public void AddFormat(string excelformatStr, FormatBase format);
    public void Update(IObservable`1<object> observable, object localeObj);
}
public class NPOI.SS.UserModel.DateUtil : object {
    public static int SECONDS_PER_MINUTE;
    public static int MINUTES_PER_HOUR;
    public static int HOURS_PER_DAY;
    public static int SECONDS_PER_DAY;
    private static int BAD_DATE;
    public static long DAY_MILLISECONDS;
    private static Char[] TIME_SEPARATOR_PATTERN;
    private static Regex date_ptrn1;
    private static Regex date_ptrn2;
    private static Regex date_ptrn3a;
    private static Regex date_ptrn3b;
    private static Regex date_ptrn4;
    private static int lastFormatIndex;
    private static string lastFormatString;
    private static bool cached;
    private static string syncIsADateFormat;
    private static DateUtil();
    public static int absoluteDay(DateTime cal, bool use1904windowing);
    public static int AbsoluteDay(DateTime cal, bool use1904windowing);
    private static int DaysInPriorYears(int yr, bool use1904windowing);
    public static double GetExcelDate(DateTime date);
    public static double GetExcelDate(int year, int month, int day, int hour, int minute, int second, bool use1904windowing);
    public static double GetExcelDate(DateTime date, bool use1904windowing);
    public static DateTime GetJavaDate(double date);
    public static DateTime GetJavaDate(double date, TimeZoneInfo tz);
    [ObsoleteAttribute("The class TimeZone was marked obsolete, Use the Overload using TimeZoneInfo instead.")]
public static DateTime GetJavaDate(double date, TimeZone tz);
    public static DateTime GetJavaDate(double date, bool use1904windowing);
    public static DateTime GetJavaDate(double date, bool use1904windowing, TimeZoneInfo tz);
    [ObsoleteAttribute("The class TimeZone was marked obsolete, Use the Overload using TimeZoneInfo instead.")]
public static DateTime GetJavaDate(double date, bool use1904windowing, TimeZone tz);
    public static DateTime GetJavaDate(double date, bool use1904windowing, TimeZoneInfo tz, bool roundSeconds);
    [ObsoleteAttribute("The class TimeZone was marked obsolete, Use the Overload using TimeZoneInfo instead.")]
public static DateTime GetJavaDate(double date, bool use1904windowing, TimeZone tz, bool roundSeconds);
    public static DateTime SetCalendar(int wholeDays, int millisecondsInDay, bool use1904windowing, bool roundSeconds);
    public static DateTime GetJavaCalendar(double date);
    public static DateTime GetJavaCalendar(double date, bool use1904windowing);
    public static DateTime GetJavaCalendarUTC(double date, bool use1904windowing);
    public static DateTime GetJavaCalendar(double date, bool use1904windowing, TimeZoneInfo timeZone);
    public static DateTime GetJavaCalendar(double date, bool use1904windowing, TimeZoneInfo timeZone, bool roundSeconds);
    [ObsoleteAttribute("The class TimeZone was marked obsolete, Use the Overload using TimeZoneInfo instead.")]
public static DateTime GetJavaCalendar(double date, bool use1904windowing, TimeZone timeZone);
    [ObsoleteAttribute("The class TimeZone was marked obsolete, Use the Overload using TimeZoneInfo instead.")]
public static DateTime GetJavaCalendar(double date, bool use1904windowing, TimeZone timeZone, bool roundSeconds);
    public static double ConvertTime(string timeStr);
    private static double ConvertTimeInternal(string timeStr);
    public static bool IsADateFormat(int formatIndex, string formatString);
    public static DateTime ParseYYYYMMDDDate(string dateStr);
    private static DateTime ParseYYYYMMDDDateInternal(string timeStr);
    private static int ParseInt(string strVal, string fieldName, int rangeMax);
    private static int ParseInt(string strVal, string fieldName, int lowerLimit, int upperLimit);
    public static bool IsInternalDateFormat(int format);
    public static bool IsCellDateFormatted(ICell cell);
    public static bool IsCellInternalDateFormatted(ICell cell);
    public static bool IsValidExcelDate(double value);
}
public interface NPOI.SS.UserModel.DifferentialStyleProvider {
    public IBorderFormatting BorderFormatting { get; }
    public IFontFormatting FontFormatting { get; }
    public IPatternFormatting PatternFormatting { get; }
    public ExcelNumberFormat NumberFormat { get; }
    public int StripeSize { get; }
    public abstract virtual IBorderFormatting get_BorderFormatting();
    public abstract virtual IFontFormatting get_FontFormatting();
    public abstract virtual IPatternFormatting get_PatternFormatting();
    public abstract virtual ExcelNumberFormat get_NumberFormat();
    public abstract virtual int get_StripeSize();
}
public enum NPOI.SS.UserModel.DisplayCellErrorType : Enum {
    public short value__;
    public static DisplayCellErrorType ErrorDisplayOnSheet;
    public static DisplayCellErrorType ErrorAsBlank;
    public static DisplayCellErrorType ErrorAsDashes;
    public static DisplayCellErrorType ErrorAsNA;
}
public enum NPOI.SS.UserModel.Drawing.MSOFillType : Enum {
    public int value__;
    public static MSOFillType Solid;
    public static MSOFillType Pattern;
    public static MSOFillType Texture;
    public static MSOFillType Picture;
    public static MSOFillType Shade;
    public static MSOFillType ShadeCenter;
    public static MSOFillType ShadeShape;
    public static MSOFillType ShadeScale;
    public static MSOFillType ShadeTitle;
    public static MSOFillType Background;
}
public static class NPOI.SS.UserModel.Drawing.OfficeArtProperties : object {
    public static int fillType;
    public static int fillColor;
    public static int fillOpacity;
    public static int fillBackColor;
    public static int fillBackOpacity;
    public static int fillCrMod;
    public static int fillBlip;
    public static int fillBlipName;
    public static int fillBlipFlags;
    public static int fillWidth;
    public static int fillHeight;
    public static int fillAngle;
    public static int fillFocus;
    public static int fillToLeft;
    public static int fillToTop;
    public static int fillToRight;
    public static int fillToBottom;
    public static int fillRectLeft;
    public static int fillRectTop;
    public static int fillRectRight;
    public static int fillRectBottom;
    public static int fillDztype;
    public static int fillShadePreset;
    public static int fillShadeColors;
    public static int fillOriginX;
    public static int fillOriginY;
    public static int fillShapeOriginX;
    public static int fillShapeOriginY;
    public static int fillShadeType;
    public static int fillColorExt;
    public static int reserved415;
    public static int fillColorExtMod;
    public static int reserved417;
    public static int fillBackColorExt;
    public static int reserved419;
    public static int fillBackColorExtMod;
    public static int reserved421;
    public static int reserved422;
    public static int reserved423;
    public static int fillStyleBoolean;
    private static Dictionary`2<int, string> fillStyle;
    private static OfficeArtProperties();
    private static void InitFillStyle();
    public static string GetFillStyleName(int optionId);
}
public static class NPOI.SS.UserModel.ERRORSTYLE : object {
    public static int STOP;
    public static int WARNING;
    public static int INFO;
}
public class NPOI.SS.UserModel.ExcelGeneralNumberFormat : FormatBase {
    private static long serialVersionUID;
    private NumberFormatInfo decimalSymbols;
    private DecimalFormat integerFormat;
    private DecimalFormat decimalFormat;
    private DecimalFormat scientificFormat;
    private CultureInfo culture;
    public ExcelGeneralNumberFormat(CultureInfo culture);
    private static ExcelGeneralNumberFormat();
    protected virtual StringBuilder Format(object obj, StringBuilder toAppendTo, int pos);
    public virtual StringBuilder Format(object number, StringBuilder toAppendTo, CultureInfo culture);
    public virtual object ParseObject(string source, int pos);
}
public class NPOI.SS.UserModel.ExcelNumberFormat : object {
    private int idx;
    private string format;
    public int Idx { get; }
    public string Format { get; }
    public ExcelNumberFormat(int idx, string format);
    public static ExcelNumberFormat From(ICellStyle style);
    public static ExcelNumberFormat From(ICell cell, ConditionalFormattingEvaluator cfEvaluator);
    public int get_Idx();
    public string get_Format();
}
public class NPOI.SS.UserModel.ExcelStyleDateFormatter : SimpleDateFormat {
    public static char MMMMM_START_SYMBOL;
    public static char MMMMM_TRUNCATE_SYMBOL;
    public static char H_BRACKET_SYMBOL;
    public static char HH_BRACKET_SYMBOL;
    public static char M_BRACKET_SYMBOL;
    public static char MM_BRACKET_SYMBOL;
    public static char S_BRACKET_SYMBOL;
    public static char SS_BRACKET_SYMBOL;
    public static char L_BRACKET_SYMBOL;
    public static char LL_BRACKET_SYMBOL;
    public static char QUOTE_SYMBOL;
    private static DecimalFormat format1digit;
    private static DecimalFormat format2digits;
    private static DecimalFormat format3digit;
    private static DecimalFormat format4digits;
    private double dateToBeFormatted;
    private static ExcelStyleDateFormatter();
    public ExcelStyleDateFormatter(string pattern);
    private static string DateTimeMatchEvaluator(Match match);
    private static string ProcessFormatPattern(string f);
    public void SetDateToBeFormatted(double date);
    public virtual string Format(object obj, CultureInfo culture);
    public StringBuilder Format(DateTime date, StringBuilder paramStringBuilder, CultureInfo culture);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class NPOI.SS.UserModel.ExtendedColor : object {
    public bool IsAuto { get; public set; }
    public bool IsIndexed { get; }
    public bool IsRGB { get; }
    public bool IsThemed { get; }
    public short Index { get; }
    public short Indexed { get; }
    public int Theme { get; public set; }
    public Byte[] RGB { get; public set; }
    public Byte[] ARGB { get; }
    protected Byte[] StoredRGB { get; }
    public Byte[] RGBWithTint { get; }
    public string ARGBHex { get; public set; }
    public double Tint { get; public set; }
    protected void SetColor(Rgb24 clr);
    public abstract virtual bool get_IsAuto();
    public abstract virtual void set_IsAuto(bool value);
    public abstract virtual bool get_IsIndexed();
    public abstract virtual bool get_IsRGB();
    public abstract virtual bool get_IsThemed();
    public abstract virtual short get_Index();
    public virtual short get_Indexed();
    public abstract virtual int get_Theme();
    public abstract virtual void set_Theme(int value);
    public abstract virtual Byte[] get_RGB();
    public abstract virtual void set_RGB(Byte[] value);
    public abstract virtual Byte[] get_ARGB();
    protected abstract virtual Byte[] get_StoredRGB();
    protected Byte[] GetRGBOrARGB();
    public Byte[] get_RGBWithTint();
    public string get_ARGBHex();
    public void set_ARGBHex(string value);
    private static byte ApplyTint(int lum, double tint);
    public abstract virtual double get_Tint();
    public abstract virtual void set_Tint(double value);
}
public enum NPOI.SS.UserModel.FillPattern : Enum {
    public short value__;
    public static FillPattern NoFill;
    public static FillPattern SolidForeground;
    public static FillPattern FineDots;
    public static FillPattern AltBars;
    public static FillPattern SparseDots;
    public static FillPattern ThickHorizontalBands;
    public static FillPattern ThickVerticalBands;
    public static FillPattern ThickBackwardDiagonals;
    public static FillPattern ThickForwardDiagonals;
    public static FillPattern BigSpots;
    public static FillPattern Bricks;
    public static FillPattern ThinHorizontalBands;
    public static FillPattern ThinVerticalBands;
    public static FillPattern ThinBackwardDiagonals;
    public static FillPattern ThinForwardDiagonals;
    public static FillPattern Squares;
    public static FillPattern Diamonds;
    public static FillPattern LessDots;
    public static FillPattern LeastDots;
}
[ObsoleteAttribute("deprecated POI 3.15 beta 2. Boldweight constants no longer needed due to IsBold property")]
public enum NPOI.SS.UserModel.FontBoldWeight : Enum {
    public short value__;
    public static FontBoldWeight None;
    public static FontBoldWeight Normal;
    public static FontBoldWeight Bold;
}
public class NPOI.SS.UserModel.FontCharset : object {
    public static FontCharset ANSI;
    public static FontCharset DEFAULT;
    public static FontCharset SYMBOL;
    public static FontCharset MAC;
    public static FontCharset SHIFTJIS;
    public static FontCharset HANGEUL;
    public static FontCharset JOHAB;
    public static FontCharset GB2312;
    public static FontCharset CHINESEBIG5;
    public static FontCharset GREEK;
    public static FontCharset TURKISH;
    public static FontCharset VIETNAMESE;
    public static FontCharset HEBREW;
    public static FontCharset ARABIC;
    public static FontCharset BALTIC;
    public static FontCharset RUSSIAN;
    public static FontCharset THAI;
    public static FontCharset EASTEUROPE;
    public static FontCharset OEM;
    private int charset;
    private static FontCharset[] _table;
    public int Value { get; }
    private FontCharset(int value);
    private static FontCharset();
    public int get_Value();
    public static FontCharset ValueOf(int value);
}
public enum NPOI.SS.UserModel.FontColor : Enum {
    public short value__;
    public static FontColor None;
    public static FontColor Normal;
    public static FontColor Red;
}
public class NPOI.SS.UserModel.FontFamily : object {
    public static FontFamily NOT_APPLICABLE;
    public static FontFamily ROMAN;
    public static FontFamily SWISS;
    public static FontFamily MODERN;
    public static FontFamily SCRIPT;
    public static FontFamily DECORATIVE;
    private int family;
    public int Value { get; }
    private FontFamily(int value);
    private static FontFamily();
    public int get_Value();
    public static FontFamily ValueOf(int family);
}
public class NPOI.SS.UserModel.FontScheme : object {
    public static FontScheme NONE;
    public static FontScheme MAJOR;
    public static FontScheme MINOR;
    private int value;
    public int Value { get; }
    private FontScheme(int val);
    private static FontScheme();
    public int get_Value();
    public static FontScheme ValueOf(int value);
}
public enum NPOI.SS.UserModel.FontSuperScript : Enum {
    public short value__;
    public static FontSuperScript None;
    public static FontSuperScript Super;
    public static FontSuperScript Sub;
}
public class NPOI.SS.UserModel.FontUnderline : object {
    public static FontUnderline SINGLE;
    public static FontUnderline DOUBLE;
    public static FontUnderline SINGLE_ACCOUNTING;
    public static FontUnderline DOUBLE_ACCOUNTING;
    public static FontUnderline NONE;
    private int value;
    private static FontUnderline[] _table;
    public int Value { get; }
    public byte ByteValue { get; }
    private FontUnderline(int val);
    private static FontUnderline();
    public int get_Value();
    public byte get_ByteValue();
    public static FontUnderline ValueOf(int value);
    public static FontUnderline ValueOf(FontUnderlineType value);
}
public enum NPOI.SS.UserModel.FontUnderlineType : Enum {
    public byte value__;
    public static FontUnderlineType None;
    public static FontUnderlineType Single;
    public static FontUnderlineType Double;
    public static FontUnderlineType SingleAccounting;
    public static FontUnderlineType DoubleAccounting;
}
public class NPOI.SS.UserModel.FormulaError : object {
    private static FormulaError[] _values;
    internal static FormulaError _NO_ERROR;
    public static FormulaError NULL;
    public static FormulaError DIV0;
    public static FormulaError VALUE;
    public static FormulaError REF;
    public static FormulaError NAME;
    public static FormulaError NUM;
    public static FormulaError NA;
    public static FormulaError CIRCULAR_REF;
    public static FormulaError FUNCTION_NOT_IMPLEMENTED;
    private byte type;
    private int longType;
    private string repr;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private static Dictionary`2<string, FormulaError> smap;
    private static Dictionary`2<byte, FormulaError> bmap;
    private static Dictionary`2<int, FormulaError> imap;
    public string Name { get; private set; }
    public byte Code { get; }
    public int LongCode { get; }
    public string String { get; }
    private static FormulaError();
    private FormulaError(int type, string repr, string name);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public byte get_Code();
    public int get_LongCode();
    public string get_String();
    public static bool IsValidCode(int errorCode);
    public static FormulaError ForInt(byte type);
    public static FormulaError ForInt(int type);
    public static FormulaError ForString(string code);
}
public enum NPOI.SS.UserModel.FormulaErrorEnum : Enum {
    public long value__;
    public static FormulaErrorEnum NO_ERROR;
    public static FormulaErrorEnum NULL;
    public static FormulaErrorEnum DIV_0;
    public static FormulaErrorEnum VALUE;
    public static FormulaErrorEnum REF;
    public static FormulaErrorEnum NAME;
    public static FormulaErrorEnum NUM;
    public static FormulaErrorEnum NA;
    public static FormulaErrorEnum CIRCULAR_REF;
    public static FormulaErrorEnum FUNCTION_NOT_IMPLEMENTED;
}
public class NPOI.SS.UserModel.FractionFormat : FormatBase {
    private static Regex DENOM_FORMAT_PATTERN;
    private static int MAX_DENOM_POW;
    private int exactDenom;
    private int maxDenom;
    private string wholePartFormatString;
    public FractionFormat(string wholePartFormatString, string denomFormatString);
    private static FractionFormat();
    public string Format(string num);
    protected virtual StringBuilder Format(object obj, StringBuilder toAppendTo, int pos);
    public virtual string Format(object obj, CultureInfo culture);
    public virtual object ParseObject(string source, int pos);
    public virtual StringBuilder Format(object obj, StringBuilder toAppendTo, CultureInfo culture);
}
public abstract class NPOI.SS.UserModel.Helpers.BaseRowColShifter : object {
    public abstract virtual void UpdateNamedRanges(FormulaShifter formulaShifter);
    public abstract virtual void updateFormulas(FormulaShifter formulaShifter);
    public abstract virtual List`1<CellRangeAddress> shiftMergedRegions(int start, int end, int n);
    public abstract virtual void updateConditionalFormatting(FormulaShifter formulaShifter);
    public abstract virtual void updateHyperlinks(FormulaShifter formulaShifter);
    public static CellRangeAddress ShiftRange(FormulaShifter Shifter, CellRangeAddress cra, int currentExternSheetIx);
}
public abstract class NPOI.SS.UserModel.Helpers.RowShifter : object {
    protected ISheet sheet;
    public RowShifter(ISheet sh);
    public List`1<CellRangeAddress> ShiftMergedRegions(int startRow, int endRow, int n);
    private bool RemovalNeeded(CellRangeAddress merged, int startRow, int endRow, int n, int lastCol);
    public static void ValidateShiftParameters(int firstShiftColumnIndex, int lastShiftColumnIndex, int step);
    public static void ValidateShiftLeftParameters(int firstShiftColumnIndex, int lastShiftColumnIndex, int step);
    public abstract virtual void UpdateNamedRanges(FormulaShifter Shifter);
    public abstract virtual void UpdateFormulas(FormulaShifter Shifter);
    public abstract virtual void UpdateRowFormulas(IRow row, FormulaShifter Shifter);
    public abstract virtual void UpdateConditionalFormatting(FormulaShifter Shifter);
    public abstract virtual void UpdateHyperlinks(FormulaShifter Shifter);
}
public enum NPOI.SS.UserModel.HorizontalAlignment : Enum {
    public int value__;
    public static HorizontalAlignment General;
    public static HorizontalAlignment Left;
    public static HorizontalAlignment Center;
    public static HorizontalAlignment Right;
    public static HorizontalAlignment Justify;
    public static HorizontalAlignment Fill;
    public static HorizontalAlignment CenterSelection;
    public static HorizontalAlignment Distributed;
}
public enum NPOI.SS.UserModel.HyperlinkType : Enum {
    public int value__;
    public static HyperlinkType Unknown;
    public static HyperlinkType Url;
    public static HyperlinkType Document;
    public static HyperlinkType Email;
    public static HyperlinkType File;
}
public interface NPOI.SS.UserModel.IAutoFilter {
}
public interface NPOI.SS.UserModel.IBorderFormatting {
    public BorderStyle BorderBottom { get; public set; }
    public BorderStyle BorderDiagonal { get; public set; }
    public BorderStyle BorderLeft { get; public set; }
    public BorderStyle BorderRight { get; public set; }
    public BorderStyle BorderTop { get; public set; }
    public short BottomBorderColor { get; public set; }
    public short DiagonalBorderColor { get; public set; }
    public short LeftBorderColor { get; public set; }
    public short RightBorderColor { get; public set; }
    public short TopBorderColor { get; public set; }
    public IColor BottomBorderColorColor { get; public set; }
    public IColor DiagonalBorderColorColor { get; public set; }
    public IColor LeftBorderColorColor { get; public set; }
    public IColor RightBorderColorColor { get; public set; }
    public IColor TopBorderColorColor { get; public set; }
    public abstract virtual BorderStyle get_BorderBottom();
    public abstract virtual void set_BorderBottom(BorderStyle value);
    public abstract virtual BorderStyle get_BorderDiagonal();
    public abstract virtual void set_BorderDiagonal(BorderStyle value);
    public abstract virtual BorderStyle get_BorderLeft();
    public abstract virtual void set_BorderLeft(BorderStyle value);
    public abstract virtual BorderStyle get_BorderRight();
    public abstract virtual void set_BorderRight(BorderStyle value);
    public abstract virtual BorderStyle get_BorderTop();
    public abstract virtual void set_BorderTop(BorderStyle value);
    public abstract virtual short get_BottomBorderColor();
    public abstract virtual void set_BottomBorderColor(short value);
    public abstract virtual short get_DiagonalBorderColor();
    public abstract virtual void set_DiagonalBorderColor(short value);
    public abstract virtual short get_LeftBorderColor();
    public abstract virtual void set_LeftBorderColor(short value);
    public abstract virtual short get_RightBorderColor();
    public abstract virtual void set_RightBorderColor(short value);
    public abstract virtual short get_TopBorderColor();
    public abstract virtual void set_TopBorderColor(short value);
    public abstract virtual IColor get_BottomBorderColorColor();
    public abstract virtual void set_BottomBorderColorColor(IColor value);
    public abstract virtual IColor get_DiagonalBorderColorColor();
    public abstract virtual void set_DiagonalBorderColorColor(IColor value);
    public abstract virtual IColor get_LeftBorderColorColor();
    public abstract virtual void set_LeftBorderColorColor(IColor value);
    public abstract virtual IColor get_RightBorderColorColor();
    public abstract virtual void set_RightBorderColorColor(IColor value);
    public abstract virtual IColor get_TopBorderColorColor();
    public abstract virtual void set_TopBorderColorColor(IColor value);
}
public interface NPOI.SS.UserModel.ICell {
    public int ColumnIndex { get; }
    public int RowIndex { get; }
    public ISheet Sheet { get; }
    public IRow Row { get; }
    public CellType CellType { get; }
    public CellType CachedFormulaResultType { get; }
    public string CellFormula { get; public set; }
    public double NumericCellValue { get; }
    public Nullable`1<DateTime> DateCellValue { get; }
    public IRichTextString RichStringCellValue { get; }
    public byte ErrorCellValue { get; }
    public string StringCellValue { get; }
    public bool BooleanCellValue { get; }
    public ICellStyle CellStyle { get; public set; }
    public CellAddress Address { get; }
    public IComment CellComment { get; public set; }
    public IHyperlink Hyperlink { get; public set; }
    public CellRangeAddress ArrayFormulaRange { get; }
    public bool IsPartOfArrayFormulaGroup { get; }
    public bool IsMergedCell { get; }
    public abstract virtual int get_ColumnIndex();
    public abstract virtual int get_RowIndex();
    public abstract virtual ISheet get_Sheet();
    public abstract virtual IRow get_Row();
    public abstract virtual CellType get_CellType();
    public abstract virtual void SetCellType(CellType cellType);
    public abstract virtual void SetBlank();
    public abstract virtual CellType get_CachedFormulaResultType();
    public abstract virtual void SetCellValue(double value);
    public abstract virtual void SetCellErrorValue(byte value);
    public abstract virtual void SetCellValue(DateTime value);
    public abstract virtual void SetCellValue(IRichTextString value);
    public abstract virtual void SetCellValue(string value);
    public abstract virtual ICell CopyCellTo(int targetIndex);
    public abstract virtual string get_CellFormula();
    public abstract virtual void set_CellFormula(string value);
    public abstract virtual void RemoveFormula();
    public abstract virtual void SetCellFormula(string formula);
    public abstract virtual double get_NumericCellValue();
    public abstract virtual Nullable`1<DateTime> get_DateCellValue();
    public abstract virtual IRichTextString get_RichStringCellValue();
    public abstract virtual byte get_ErrorCellValue();
    public abstract virtual string get_StringCellValue();
    public abstract virtual void SetCellValue(bool value);
    public abstract virtual bool get_BooleanCellValue();
    public abstract virtual ICellStyle get_CellStyle();
    public abstract virtual void set_CellStyle(ICellStyle value);
    public abstract virtual void SetAsActiveCell();
    public abstract virtual CellAddress get_Address();
    public abstract virtual IComment get_CellComment();
    public abstract virtual void set_CellComment(IComment value);
    public abstract virtual void RemoveCellComment();
    public abstract virtual IHyperlink get_Hyperlink();
    public abstract virtual void set_Hyperlink(IHyperlink value);
    public abstract virtual void RemoveHyperlink();
    public abstract virtual CellRangeAddress get_ArrayFormulaRange();
    public abstract virtual bool get_IsPartOfArrayFormulaGroup();
    public abstract virtual bool get_IsMergedCell();
    [ObsoleteAttribute("Will be removed at NPOI 2.8, Use CachedFormulaResultType instead.")]
public abstract virtual CellType GetCachedFormulaResultTypeEnum();
}
public interface NPOI.SS.UserModel.ICellRange`1 {
    public int Width { get; }
    public int Height { get; }
    public int Size { get; }
    public string ReferenceText { get; }
    public T TopLeftCell { get; }
    public T[] FlattenedCells { get; }
    public T[][] Cells { get; }
    public abstract virtual int get_Width();
    public abstract virtual int get_Height();
    public abstract virtual int get_Size();
    public abstract virtual string get_ReferenceText();
    public abstract virtual T get_TopLeftCell();
    public abstract virtual T GetCell(int relativeRowIndex, int relativeColumnIndex);
    public abstract virtual T[] get_FlattenedCells();
    public abstract virtual T[][] get_Cells();
}
public interface NPOI.SS.UserModel.ICellStyle {
    public bool ShrinkToFit { get; public set; }
    public short Index { get; }
    public short DataFormat { get; public set; }
    public short FontIndex { get; }
    public bool IsHidden { get; public set; }
    public bool IsLocked { get; public set; }
    public bool IsQuotePrefixed { get; public set; }
    public HorizontalAlignment Alignment { get; public set; }
    public bool WrapText { get; public set; }
    public VerticalAlignment VerticalAlignment { get; public set; }
    public short Rotation { get; public set; }
    public short Indention { get; public set; }
    public BorderStyle BorderLeft { get; public set; }
    public BorderStyle BorderRight { get; public set; }
    public BorderStyle BorderTop { get; public set; }
    public BorderStyle BorderBottom { get; public set; }
    public short LeftBorderColor { get; public set; }
    public short RightBorderColor { get; public set; }
    public short TopBorderColor { get; public set; }
    public short BottomBorderColor { get; public set; }
    public FillPattern FillPattern { get; public set; }
    public short FillBackgroundColor { get; public set; }
    public short FillForegroundColor { get; public set; }
    public short BorderDiagonalColor { get; public set; }
    public BorderStyle BorderDiagonalLineStyle { get; public set; }
    public BorderDiagonal BorderDiagonal { get; public set; }
    public IColor FillBackgroundColorColor { get; }
    public IColor FillForegroundColorColor { get; }
    public abstract virtual bool get_ShrinkToFit();
    public abstract virtual void set_ShrinkToFit(bool value);
    public abstract virtual short get_Index();
    public abstract virtual short get_DataFormat();
    public abstract virtual void set_DataFormat(short value);
    public abstract virtual string GetDataFormatString();
    public abstract virtual void SetFont(IFont font);
    public abstract virtual short get_FontIndex();
    public abstract virtual bool get_IsHidden();
    public abstract virtual void set_IsHidden(bool value);
    public abstract virtual bool get_IsLocked();
    public abstract virtual void set_IsLocked(bool value);
    public abstract virtual bool get_IsQuotePrefixed();
    public abstract virtual void set_IsQuotePrefixed(bool value);
    public abstract virtual HorizontalAlignment get_Alignment();
    public abstract virtual void set_Alignment(HorizontalAlignment value);
    public abstract virtual bool get_WrapText();
    public abstract virtual void set_WrapText(bool value);
    public abstract virtual VerticalAlignment get_VerticalAlignment();
    public abstract virtual void set_VerticalAlignment(VerticalAlignment value);
    public abstract virtual short get_Rotation();
    public abstract virtual void set_Rotation(short value);
    public abstract virtual short get_Indention();
    public abstract virtual void set_Indention(short value);
    public abstract virtual BorderStyle get_BorderLeft();
    public abstract virtual void set_BorderLeft(BorderStyle value);
    public abstract virtual BorderStyle get_BorderRight();
    public abstract virtual void set_BorderRight(BorderStyle value);
    public abstract virtual BorderStyle get_BorderTop();
    public abstract virtual void set_BorderTop(BorderStyle value);
    public abstract virtual BorderStyle get_BorderBottom();
    public abstract virtual void set_BorderBottom(BorderStyle value);
    public abstract virtual short get_LeftBorderColor();
    public abstract virtual void set_LeftBorderColor(short value);
    public abstract virtual short get_RightBorderColor();
    public abstract virtual void set_RightBorderColor(short value);
    public abstract virtual short get_TopBorderColor();
    public abstract virtual void set_TopBorderColor(short value);
    public abstract virtual short get_BottomBorderColor();
    public abstract virtual void set_BottomBorderColor(short value);
    public abstract virtual FillPattern get_FillPattern();
    public abstract virtual void set_FillPattern(FillPattern value);
    public abstract virtual short get_FillBackgroundColor();
    public abstract virtual void set_FillBackgroundColor(short value);
    public abstract virtual short get_FillForegroundColor();
    public abstract virtual void set_FillForegroundColor(short value);
    public abstract virtual void CloneStyleFrom(ICellStyle source);
    public abstract virtual IFont GetFont(IWorkbook parentWorkbook);
    public abstract virtual short get_BorderDiagonalColor();
    public abstract virtual void set_BorderDiagonalColor(short value);
    public abstract virtual BorderStyle get_BorderDiagonalLineStyle();
    public abstract virtual void set_BorderDiagonalLineStyle(BorderStyle value);
    public abstract virtual BorderDiagonal get_BorderDiagonal();
    public abstract virtual void set_BorderDiagonal(BorderDiagonal value);
    public abstract virtual IColor get_FillBackgroundColorColor();
    public abstract virtual IColor get_FillForegroundColorColor();
}
public interface NPOI.SS.UserModel.IChart {
    public IChartDataFactory ChartDataFactory { get; }
    public IChartAxisFactory ChartAxisFactory { get; }
    public abstract virtual IChartDataFactory get_ChartDataFactory();
    public abstract virtual IChartAxisFactory get_ChartAxisFactory();
    public abstract virtual IChartLegend GetOrCreateLegend();
    public abstract virtual void DeleteLegend();
    public abstract virtual List`1<IChartAxis> GetAxis();
    public abstract virtual void Plot(IChartData data, IChartAxis[] axis);
    public abstract virtual void SetTitle(string newTitle);
}
public interface NPOI.SS.UserModel.IClientAnchor {
    public int Col1 { get; public set; }
    public int Col2 { get; public set; }
    public int Row1 { get; public set; }
    public int Row2 { get; public set; }
    public int Dx1 { get; public set; }
    public int Dy1 { get; public set; }
    public int Dy2 { get; public set; }
    public int Dx2 { get; public set; }
    public AnchorType AnchorType { get; public set; }
    public abstract virtual int get_Col1();
    public abstract virtual void set_Col1(int value);
    public abstract virtual int get_Col2();
    public abstract virtual void set_Col2(int value);
    public abstract virtual int get_Row1();
    public abstract virtual void set_Row1(int value);
    public abstract virtual int get_Row2();
    public abstract virtual void set_Row2(int value);
    public abstract virtual int get_Dx1();
    public abstract virtual void set_Dx1(int value);
    public abstract virtual int get_Dy1();
    public abstract virtual void set_Dy1(int value);
    public abstract virtual int get_Dy2();
    public abstract virtual void set_Dy2(int value);
    public abstract virtual int get_Dx2();
    public abstract virtual void set_Dx2(int value);
    public abstract virtual AnchorType get_AnchorType();
    public abstract virtual void set_AnchorType(AnchorType value);
}
public interface NPOI.SS.UserModel.IColor {
    public short Indexed { get; }
    public Byte[] RGB { get; }
    public abstract virtual short get_Indexed();
    public abstract virtual Byte[] get_RGB();
}
public interface NPOI.SS.UserModel.IColorScaleFormatting {
    public int NumControlPoints { get; public set; }
    public IColor[] Colors { get; public set; }
    public IConditionalFormattingThreshold[] Thresholds { get; public set; }
    public abstract virtual int get_NumControlPoints();
    public abstract virtual void set_NumControlPoints(int value);
    public abstract virtual IColor[] get_Colors();
    public abstract virtual void set_Colors(IColor[] value);
    public abstract virtual IConditionalFormattingThreshold[] get_Thresholds();
    public abstract virtual void set_Thresholds(IConditionalFormattingThreshold[] value);
    public abstract virtual IConditionalFormattingThreshold CreateThreshold();
}
public interface NPOI.SS.UserModel.IComment {
    public bool Visible { get; public set; }
    public CellAddress Address { get; public set; }
    public int Row { get; public set; }
    public int Column { get; public set; }
    public string Author { get; public set; }
    public IRichTextString String { get; public set; }
    public IClientAnchor ClientAnchor { get; }
    public abstract virtual bool get_Visible();
    public abstract virtual void set_Visible(bool value);
    public abstract virtual CellAddress get_Address();
    public abstract virtual void set_Address(CellAddress value);
    public abstract virtual void SetAddress(int row, int col);
    public abstract virtual int get_Row();
    public abstract virtual void set_Row(int value);
    public abstract virtual int get_Column();
    public abstract virtual void set_Column(int value);
    public abstract virtual string get_Author();
    public abstract virtual void set_Author(string value);
    public abstract virtual IRichTextString get_String();
    public abstract virtual void set_String(IRichTextString value);
    public abstract virtual IClientAnchor get_ClientAnchor();
}
public interface NPOI.SS.UserModel.IConditionalFormatting {
    public int NumberOfRules { get; }
    public abstract virtual CellRangeAddress[] GetFormattingRanges();
    public abstract virtual void SetFormattingRanges(CellRangeAddress[] ranges);
    public abstract virtual void SetRule(int idx, IConditionalFormattingRule cfRule);
    public abstract virtual void AddRule(IConditionalFormattingRule cfRule);
    public abstract virtual IConditionalFormattingRule GetRule(int idx);
    public abstract virtual int get_NumberOfRules();
}
public interface NPOI.SS.UserModel.IConditionalFormattingRule {
    public IBorderFormatting BorderFormatting { get; }
    public IFontFormatting FontFormatting { get; }
    public IPatternFormatting PatternFormatting { get; }
    public IDataBarFormatting DataBarFormatting { get; }
    public IIconMultiStateFormatting MultiStateFormatting { get; }
    public IColorScaleFormatting ColorScaleFormatting { get; }
    public ConditionType ConditionType { get; }
    public ComparisonOperator ComparisonOperation { get; }
    public string Formula1 { get; }
    public string Formula2 { get; }
    public string Text { get; }
    public int Priority { get; }
    public bool StopIfTrue { get; }
    public ExcelNumberFormat NumberFormat { get; }
    public Nullable`1<ConditionFilterType> ConditionFilterType { get; }
    public IConditionFilterData FilterConfiguration { get; }
    public abstract virtual IBorderFormatting CreateBorderFormatting();
    public abstract virtual IBorderFormatting get_BorderFormatting();
    public abstract virtual IFontFormatting CreateFontFormatting();
    public abstract virtual IFontFormatting get_FontFormatting();
    public abstract virtual IPatternFormatting CreatePatternFormatting();
    public abstract virtual IPatternFormatting get_PatternFormatting();
    public abstract virtual IDataBarFormatting get_DataBarFormatting();
    public abstract virtual IIconMultiStateFormatting get_MultiStateFormatting();
    public abstract virtual IColorScaleFormatting get_ColorScaleFormatting();
    public abstract virtual ConditionType get_ConditionType();
    public abstract virtual ComparisonOperator get_ComparisonOperation();
    public abstract virtual string get_Formula1();
    public abstract virtual string get_Formula2();
    public abstract virtual string get_Text();
    public abstract virtual int get_Priority();
    public abstract virtual bool get_StopIfTrue();
    public abstract virtual ExcelNumberFormat get_NumberFormat();
    public abstract virtual Nullable`1<ConditionFilterType> get_ConditionFilterType();
    public abstract virtual IConditionFilterData get_FilterConfiguration();
}
public interface NPOI.SS.UserModel.IConditionalFormattingThreshold {
    public RangeType RangeType { get; public set; }
    public string Formula { get; public set; }
    public Nullable`1<double> Value { get; public set; }
    public abstract virtual RangeType get_RangeType();
    public abstract virtual void set_RangeType(RangeType value);
    public abstract virtual string get_Formula();
    public abstract virtual void set_Formula(string value);
    public abstract virtual Nullable`1<double> get_Value();
    public abstract virtual void set_Value(Nullable`1<double> value);
}
public interface NPOI.SS.UserModel.IConditionFilterData {
    public bool AboveAverage { get; }
    public bool Bottom { get; }
    public bool EqualAverage { get; }
    public bool Percent { get; }
    public long Rank { get; }
    public int StdDev { get; }
    public abstract virtual bool get_AboveAverage();
    public abstract virtual bool get_Bottom();
    public abstract virtual bool get_EqualAverage();
    public abstract virtual bool get_Percent();
    public abstract virtual long get_Rank();
    public abstract virtual int get_StdDev();
}
public class NPOI.SS.UserModel.IconSet : object {
    public static IconSet GYR_3_ARROW;
    public static IconSet GREY_3_ARROWS;
    public static IconSet GYR_3_FLAGS;
    public static IconSet GYR_3_TRAFFIC_LIGHTS;
    public static IconSet GYR_3_TRAFFIC_LIGHTS_BOX;
    public static IconSet GYR_3_SHAPES;
    public static IconSet GYR_3_SYMBOLS_CIRCLE;
    public static IconSet GYR_3_SYMBOLS;
    public static IconSet GYR_4_ARROWS;
    public static IconSet GREY_4_ARROWS;
    public static IconSet RB_4_TRAFFIC_LIGHTS;
    public static IconSet RATINGS_4;
    public static IconSet GYRB_4_TRAFFIC_LIGHTS;
    public static IconSet GYYYR_5_ARROWS;
    public static IconSet GREY_5_ARROWS;
    public static IconSet RATINGS_5;
    public static IconSet QUARTERS_5;
    protected static IconSet DEFAULT_ICONSET;
    public int id;
    public int num;
    public string name;
    private static List`1<IconSet> values;
    private IconSet(int id, int num, string name);
    private static IconSet();
    public static List`1<IconSet> Values();
    public virtual string ToString();
    public static IconSet ById(int id);
    public static IconSet ByName(string name);
    public static IconSet ByOOXMLName(string name);
}
public interface NPOI.SS.UserModel.ICreationHelper {
    public abstract virtual IRichTextString CreateRichTextString(string text);
    public abstract virtual IDataFormat CreateDataFormat();
    public abstract virtual IHyperlink CreateHyperlink(HyperlinkType type);
    public abstract virtual IFormulaEvaluator CreateFormulaEvaluator();
    public abstract virtual ExtendedColor CreateExtendedColor();
    public abstract virtual IClientAnchor CreateClientAnchor();
}
public interface NPOI.SS.UserModel.IDataBarFormatting {
    public bool IsLeftToRight { get; public set; }
    public bool IsIconOnly { get; public set; }
    public int WidthMin { get; public set; }
    public int WidthMax { get; public set; }
    public IColor Color { get; public set; }
    public IConditionalFormattingThreshold MinThreshold { get; }
    public IConditionalFormattingThreshold MaxThreshold { get; }
    public abstract virtual bool get_IsLeftToRight();
    public abstract virtual void set_IsLeftToRight(bool value);
    public abstract virtual bool get_IsIconOnly();
    public abstract virtual void set_IsIconOnly(bool value);
    public abstract virtual int get_WidthMin();
    public abstract virtual void set_WidthMin(int value);
    public abstract virtual int get_WidthMax();
    public abstract virtual void set_WidthMax(int value);
    public abstract virtual IColor get_Color();
    public abstract virtual void set_Color(IColor value);
    public abstract virtual IConditionalFormattingThreshold get_MinThreshold();
    public abstract virtual IConditionalFormattingThreshold get_MaxThreshold();
}
public interface NPOI.SS.UserModel.IDataFormat {
    public abstract virtual short GetFormat(string format);
    public abstract virtual string GetFormat(short index);
}
public interface NPOI.SS.UserModel.IDataValidation {
    public IDataValidationConstraint ValidationConstraint { get; }
    public int ErrorStyle { get; public set; }
    public bool EmptyCellAllowed { get; public set; }
    public bool SuppressDropDownArrow { get; public set; }
    public bool ShowPromptBox { get; public set; }
    public bool ShowErrorBox { get; public set; }
    public string PromptBoxTitle { get; }
    public string PromptBoxText { get; }
    public string ErrorBoxTitle { get; }
    public string ErrorBoxText { get; }
    public CellRangeAddressList Regions { get; }
    public abstract virtual IDataValidationConstraint get_ValidationConstraint();
    public abstract virtual int get_ErrorStyle();
    public abstract virtual void set_ErrorStyle(int value);
    public abstract virtual bool get_EmptyCellAllowed();
    public abstract virtual void set_EmptyCellAllowed(bool value);
    public abstract virtual bool get_SuppressDropDownArrow();
    public abstract virtual void set_SuppressDropDownArrow(bool value);
    public abstract virtual bool get_ShowPromptBox();
    public abstract virtual void set_ShowPromptBox(bool value);
    public abstract virtual bool get_ShowErrorBox();
    public abstract virtual void set_ShowErrorBox(bool value);
    public abstract virtual void CreatePromptBox(string title, string text);
    public abstract virtual string get_PromptBoxTitle();
    public abstract virtual string get_PromptBoxText();
    public abstract virtual void CreateErrorBox(string title, string text);
    public abstract virtual string get_ErrorBoxTitle();
    public abstract virtual string get_ErrorBoxText();
    public abstract virtual CellRangeAddressList get_Regions();
}
public interface NPOI.SS.UserModel.IDataValidationConstraint {
    public int Operator { get; public set; }
    public String[] ExplicitListValues { get; public set; }
    public string Formula1 { get; public set; }
    public string Formula2 { get; public set; }
    public abstract virtual int GetValidationType();
    public abstract virtual int get_Operator();
    public abstract virtual void set_Operator(int value);
    public abstract virtual String[] get_ExplicitListValues();
    public abstract virtual void set_ExplicitListValues(String[] value);
    public abstract virtual string get_Formula1();
    public abstract virtual void set_Formula1(string value);
    public abstract virtual string get_Formula2();
    public abstract virtual void set_Formula2(string value);
}
public interface NPOI.SS.UserModel.IDataValidationHelper {
    public abstract virtual IDataValidationConstraint CreateFormulaListConstraint(string listFormula);
    public abstract virtual IDataValidationConstraint CreateExplicitListConstraint(String[] listOfValues);
    public abstract virtual IDataValidationConstraint CreateNumericConstraint(int validationType, int operatorType, string formula1, string formula2);
    public abstract virtual IDataValidationConstraint CreateTextLengthConstraint(int operatorType, string formula1, string formula2);
    public abstract virtual IDataValidationConstraint CreateDecimalConstraint(int operatorType, string formula1, string formula2);
    public abstract virtual IDataValidationConstraint CreateintConstraint(int operatorType, string formula1, string formula2);
    public abstract virtual IDataValidationConstraint CreateDateConstraint(int operatorType, string formula1, string formula2, string dateFormat);
    public abstract virtual IDataValidationConstraint CreateTimeConstraint(int operatorType, string formula1, string formula2);
    public abstract virtual IDataValidationConstraint CreateCustomConstraint(string formula);
    public abstract virtual IDataValidation CreateValidation(IDataValidationConstraint constraint, CellRangeAddressList cellRangeAddressList);
}
public interface NPOI.SS.UserModel.IDrawing {
    public abstract virtual IPicture CreatePicture(IClientAnchor anchor, int pictureIndex);
    public abstract virtual IComment CreateCellComment(IClientAnchor anchor);
    public abstract virtual IChart CreateChart(IClientAnchor anchor);
    public abstract virtual IClientAnchor CreateAnchor(int dx1, int dy1, int dx2, int dy2, int col1, int row1, int col2, int row2);
}
public interface NPOI.SS.UserModel.IFont {
    public string FontName { get; public set; }
    public double FontHeight { get; public set; }
    public double FontHeightInPoints { get; public set; }
    public bool IsItalic { get; public set; }
    public bool IsStrikeout { get; public set; }
    public short Color { get; public set; }
    public FontSuperScript TypeOffset { get; public set; }
    public FontUnderlineType Underline { get; public set; }
    public short Charset { get; public set; }
    public short Index { get; }
    [ObsoleteAttribute("deprecated POI 3.15 beta 2. Use IsBold instead.")]
public short Boldweight { get; public set; }
    public bool IsBold { get; public set; }
    public abstract virtual string get_FontName();
    public abstract virtual void set_FontName(string value);
    public abstract virtual double get_FontHeight();
    public abstract virtual void set_FontHeight(double value);
    public abstract virtual double get_FontHeightInPoints();
    public abstract virtual void set_FontHeightInPoints(double value);
    public abstract virtual bool get_IsItalic();
    public abstract virtual void set_IsItalic(bool value);
    public abstract virtual bool get_IsStrikeout();
    public abstract virtual void set_IsStrikeout(bool value);
    public abstract virtual short get_Color();
    public abstract virtual void set_Color(short value);
    public abstract virtual FontSuperScript get_TypeOffset();
    public abstract virtual void set_TypeOffset(FontSuperScript value);
    public abstract virtual FontUnderlineType get_Underline();
    public abstract virtual void set_Underline(FontUnderlineType value);
    public abstract virtual short get_Charset();
    public abstract virtual void set_Charset(short value);
    public abstract virtual short get_Index();
    public abstract virtual short get_Boldweight();
    public abstract virtual void set_Boldweight(short value);
    public abstract virtual bool get_IsBold();
    public abstract virtual void set_IsBold(bool value);
    public abstract virtual void CloneStyleFrom(IFont src);
}
public interface NPOI.SS.UserModel.IFontFormatting {
    public FontSuperScript EscapementType { get; public set; }
    public short FontColorIndex { get; public set; }
    public IColor FontColor { get; public set; }
    public int FontHeight { get; public set; }
    public FontUnderlineType UnderlineType { get; public set; }
    public bool IsBold { get; }
    public bool IsItalic { get; }
    public abstract virtual FontSuperScript get_EscapementType();
    public abstract virtual void set_EscapementType(FontSuperScript value);
    public abstract virtual short get_FontColorIndex();
    public abstract virtual void set_FontColorIndex(short value);
    public abstract virtual IColor get_FontColor();
    public abstract virtual void set_FontColor(IColor value);
    public abstract virtual int get_FontHeight();
    public abstract virtual void set_FontHeight(int value);
    public abstract virtual FontUnderlineType get_UnderlineType();
    public abstract virtual void set_UnderlineType(FontUnderlineType value);
    public abstract virtual bool get_IsBold();
    public abstract virtual bool get_IsItalic();
    public abstract virtual void SetFontStyle(bool italic, bool bold);
    public abstract virtual void ResetFontStyle();
}
public interface NPOI.SS.UserModel.IFooter {
}
public interface NPOI.SS.UserModel.IFormulaEvaluator {
    public bool IgnoreMissingWorkbooks { get; public set; }
    public bool DebugEvaluationOutputForNextEval { get; public set; }
    public abstract virtual void ClearAllCachedResultValues();
    public abstract virtual void NotifySetFormula(ICell cell);
    public abstract virtual void NotifyDeleteCell(ICell cell);
    public abstract virtual void NotifyUpdateCell(ICell cell);
    public abstract virtual CellValue Evaluate(ICell cell);
    public abstract virtual void EvaluateAll();
    public abstract virtual CellType EvaluateFormulaCell(ICell cell);
    public abstract virtual ICell EvaluateInCell(ICell cell);
    public abstract virtual void SetupReferencedWorkbooks(Dictionary`2<string, IFormulaEvaluator> workbooks);
    public abstract virtual bool get_IgnoreMissingWorkbooks();
    public abstract virtual void set_IgnoreMissingWorkbooks(bool value);
    public abstract virtual bool get_DebugEvaluationOutputForNextEval();
    public abstract virtual void set_DebugEvaluationOutputForNextEval(bool value);
}
public enum NPOI.SS.UserModel.IgnoredErrorType : Enum {
    public int value__;
    public static IgnoredErrorType CalculatedColumn;
    public static IgnoredErrorType EmptyCellReference;
    public static IgnoredErrorType EvaluationError;
    public static IgnoredErrorType Formula;
    public static IgnoredErrorType FormulaRange;
    public static IgnoredErrorType ListDataValidation;
    public static IgnoredErrorType NumberStoredAsText;
    public static IgnoredErrorType TwoDigitTextYear;
    public static IgnoredErrorType UnlockedFormula;
}
public static class NPOI.SS.UserModel.IgnoredErrorTypeValues : object {
    public static IgnoredErrorType[] Values;
    private static IgnoredErrorTypeValues();
}
public interface NPOI.SS.UserModel.IHeader {
}
public interface NPOI.SS.UserModel.IHeaderFooter {
    public string Left { get; public set; }
    public string Center { get; public set; }
    public string Right { get; public set; }
    public abstract virtual string get_Left();
    public abstract virtual void set_Left(string value);
    public abstract virtual string get_Center();
    public abstract virtual void set_Center(string value);
    public abstract virtual string get_Right();
    public abstract virtual void set_Right(string value);
}
public interface NPOI.SS.UserModel.IHyperlink {
    public string Address { get; public set; }
    public string Label { get; public set; }
    public HyperlinkType Type { get; }
    public int FirstRow { get; public set; }
    public int LastRow { get; public set; }
    public int FirstColumn { get; public set; }
    public int LastColumn { get; public set; }
    public string TextMark { get; public set; }
    public abstract virtual string get_Address();
    public abstract virtual void set_Address(string value);
    public abstract virtual string get_Label();
    public abstract virtual void set_Label(string value);
    public abstract virtual HyperlinkType get_Type();
    public abstract virtual int get_FirstRow();
    public abstract virtual void set_FirstRow(int value);
    public abstract virtual int get_LastRow();
    public abstract virtual void set_LastRow(int value);
    public abstract virtual int get_FirstColumn();
    public abstract virtual void set_FirstColumn(int value);
    public abstract virtual int get_LastColumn();
    public abstract virtual void set_LastColumn(int value);
    public abstract virtual string get_TextMark();
    public abstract virtual void set_TextMark(string value);
}
public interface NPOI.SS.UserModel.IIconMultiStateFormatting {
    public IconSet IconSet { get; public set; }
    public bool IsIconOnly { get; public set; }
    public bool IsReversed { get; public set; }
    public IConditionalFormattingThreshold[] Thresholds { get; public set; }
    public abstract virtual IconSet get_IconSet();
    public abstract virtual void set_IconSet(IconSet value);
    public abstract virtual bool get_IsIconOnly();
    public abstract virtual void set_IsIconOnly(bool value);
    public abstract virtual bool get_IsReversed();
    public abstract virtual void set_IsReversed(bool value);
    public abstract virtual IConditionalFormattingThreshold[] get_Thresholds();
    public abstract virtual void set_Thresholds(IConditionalFormattingThreshold[] value);
    public abstract virtual IConditionalFormattingThreshold CreateThreshold();
}
public interface NPOI.SS.UserModel.IName {
    public string SheetName { get; }
    public string NameName { get; public set; }
    public string RefersToFormula { get; public set; }
    public bool IsFunctionName { get; }
    public bool IsDeleted { get; }
    public int SheetIndex { get; public set; }
    public string Comment { get; public set; }
    public abstract virtual string get_SheetName();
    public abstract virtual string get_NameName();
    public abstract virtual void set_NameName(string value);
    public abstract virtual string get_RefersToFormula();
    public abstract virtual void set_RefersToFormula(string value);
    public abstract virtual bool get_IsFunctionName();
    public abstract virtual bool get_IsDeleted();
    public abstract virtual int get_SheetIndex();
    public abstract virtual void set_SheetIndex(int value);
    public abstract virtual string get_Comment();
    public abstract virtual void set_Comment(string value);
    public abstract virtual void SetFunction(bool value);
}
public class NPOI.SS.UserModel.IndexedColors : object {
    public static IndexedColors Black;
    public static IndexedColors White;
    public static IndexedColors Red;
    public static IndexedColors BrightGreen;
    public static IndexedColors Blue;
    public static IndexedColors Yellow;
    public static IndexedColors Pink;
    public static IndexedColors Turquoise;
    public static IndexedColors DarkRed;
    public static IndexedColors Green;
    public static IndexedColors DarkBlue;
    public static IndexedColors DarkYellow;
    public static IndexedColors Violet;
    public static IndexedColors Teal;
    public static IndexedColors Grey25Percent;
    public static IndexedColors Grey50Percent;
    public static IndexedColors CornflowerBlue;
    public static IndexedColors Maroon;
    public static IndexedColors LemonChiffon;
    public static IndexedColors Orchid;
    public static IndexedColors Coral;
    public static IndexedColors RoyalBlue;
    public static IndexedColors LightCornflowerBlue;
    public static IndexedColors SkyBlue;
    public static IndexedColors LightTurquoise;
    public static IndexedColors LightGreen;
    public static IndexedColors LightYellow;
    public static IndexedColors PaleBlue;
    public static IndexedColors Rose;
    public static IndexedColors Lavender;
    public static IndexedColors Tan;
    public static IndexedColors LightBlue;
    public static IndexedColors Aqua;
    public static IndexedColors Lime;
    public static IndexedColors Gold;
    public static IndexedColors LightOrange;
    public static IndexedColors Orange;
    public static IndexedColors BlueGrey;
    public static IndexedColors Grey40Percent;
    public static IndexedColors DarkTeal;
    public static IndexedColors SeaGreen;
    public static IndexedColors DarkGreen;
    public static IndexedColors OliveGreen;
    public static IndexedColors Brown;
    public static IndexedColors Plum;
    public static IndexedColors Indigo;
    public static IndexedColors Grey80Percent;
    public static IndexedColors Automatic;
    private int index;
    private HSSFColor hssfColor;
    private static Dictionary`2<string, IndexedColors> mappingName;
    private static Dictionary`2<int, IndexedColors> mappingIndex;
    public Byte[] RGB { get; }
    public string HexString { get; }
    public short Index { get; }
    private IndexedColors(int idx, HSSFColor color);
    private static IndexedColors();
    public static IndexedColors ValueOf(string colorName);
    public static IndexedColors ValueOf(int index);
    public static IndexedColors FromInt(int index);
    public Byte[] get_RGB();
    public string get_HexString();
    public short get_Index();
}
public interface NPOI.SS.UserModel.IPatternFormatting {
    public short FillBackgroundColor { get; public set; }
    public short FillForegroundColor { get; public set; }
    public IColor FillBackgroundColorColor { get; public set; }
    public IColor FillForegroundColorColor { get; public set; }
    public FillPattern FillPattern { get; public set; }
    public abstract virtual short get_FillBackgroundColor();
    public abstract virtual void set_FillBackgroundColor(short value);
    public abstract virtual short get_FillForegroundColor();
    public abstract virtual void set_FillForegroundColor(short value);
    public abstract virtual IColor get_FillBackgroundColorColor();
    public abstract virtual void set_FillBackgroundColorColor(IColor value);
    public abstract virtual IColor get_FillForegroundColorColor();
    public abstract virtual void set_FillForegroundColorColor(IColor value);
    public abstract virtual FillPattern get_FillPattern();
    public abstract virtual void set_FillPattern(FillPattern value);
}
public interface NPOI.SS.UserModel.IPicture {
    public IPictureData PictureData { get; }
    public IClientAnchor ClientAnchor { get; }
    public ISheet Sheet { get; }
    public abstract virtual void Resize();
    public abstract virtual void Resize(double scale);
    public abstract virtual void Resize(double scaleX, double scaleY);
    public abstract virtual IClientAnchor GetPreferredSize();
    public abstract virtual IClientAnchor GetPreferredSize(double scaleX, double scaleY);
    public abstract virtual Size GetImageDimension();
    public abstract virtual IPictureData get_PictureData();
    public abstract virtual IClientAnchor get_ClientAnchor();
    public abstract virtual ISheet get_Sheet();
}
public interface NPOI.SS.UserModel.IPictureData {
    public Byte[] Data { get; }
    public string MimeType { get; }
    public PictureType PictureType { get; }
    public abstract virtual Byte[] get_Data();
    public abstract virtual string SuggestFileExtension();
    public abstract virtual string get_MimeType();
    public abstract virtual PictureType get_PictureType();
}
public interface NPOI.SS.UserModel.IPivotTableStyleInfo {
    public bool IsShowColumnHeaders { get; public set; }
    public bool IsShowRowHeaders { get; public set; }
    public abstract virtual bool get_IsShowColumnHeaders();
    public abstract virtual void set_IsShowColumnHeaders(bool value);
    public abstract virtual bool get_IsShowRowHeaders();
    public abstract virtual void set_IsShowRowHeaders(bool value);
}
public interface NPOI.SS.UserModel.IPrintSetup {
    public short PaperSize { get; public set; }
    public short Scale { get; public set; }
    public short PageStart { get; public set; }
    public short FitWidth { get; public set; }
    public short FitHeight { get; public set; }
    public bool LeftToRight { get; public set; }
    public bool Landscape { get; public set; }
    public bool ValidSettings { get; public set; }
    public bool NoColor { get; public set; }
    public bool Draft { get; public set; }
    public bool Notes { get; public set; }
    public bool NoOrientation { get; public set; }
    public bool UsePage { get; public set; }
    public short HResolution { get; public set; }
    public short VResolution { get; public set; }
    public double HeaderMargin { get; public set; }
    public double FooterMargin { get; public set; }
    public short Copies { get; public set; }
    public bool EndNote { get; public set; }
    public DisplayCellErrorType CellError { get; public set; }
    public abstract virtual short get_PaperSize();
    public abstract virtual void set_PaperSize(short value);
    public abstract virtual short get_Scale();
    public abstract virtual void set_Scale(short value);
    public abstract virtual short get_PageStart();
    public abstract virtual void set_PageStart(short value);
    public abstract virtual short get_FitWidth();
    public abstract virtual void set_FitWidth(short value);
    public abstract virtual short get_FitHeight();
    public abstract virtual void set_FitHeight(short value);
    public abstract virtual bool get_LeftToRight();
    public abstract virtual void set_LeftToRight(bool value);
    public abstract virtual bool get_Landscape();
    public abstract virtual void set_Landscape(bool value);
    public abstract virtual bool get_ValidSettings();
    public abstract virtual void set_ValidSettings(bool value);
    public abstract virtual bool get_NoColor();
    public abstract virtual void set_NoColor(bool value);
    public abstract virtual bool get_Draft();
    public abstract virtual void set_Draft(bool value);
    public abstract virtual bool get_Notes();
    public abstract virtual void set_Notes(bool value);
    public abstract virtual bool get_NoOrientation();
    public abstract virtual void set_NoOrientation(bool value);
    public abstract virtual bool get_UsePage();
    public abstract virtual void set_UsePage(bool value);
    public abstract virtual short get_HResolution();
    public abstract virtual void set_HResolution(short value);
    public abstract virtual short get_VResolution();
    public abstract virtual void set_VResolution(short value);
    public abstract virtual double get_HeaderMargin();
    public abstract virtual void set_HeaderMargin(double value);
    public abstract virtual double get_FooterMargin();
    public abstract virtual void set_FooterMargin(double value);
    public abstract virtual short get_Copies();
    public abstract virtual void set_Copies(short value);
    public abstract virtual bool get_EndNote();
    public abstract virtual void set_EndNote(bool value);
    public abstract virtual DisplayCellErrorType get_CellError();
    public abstract virtual void set_CellError(DisplayCellErrorType value);
}
public interface NPOI.SS.UserModel.IRichTextString {
    public string String { get; }
    public int Length { get; }
    public int NumFormattingRuns { get; }
    public abstract virtual void ApplyFont(int startIndex, int endIndex, short fontIndex);
    public abstract virtual void ApplyFont(int startIndex, int endIndex, IFont font);
    public abstract virtual void ApplyFont(IFont font);
    public abstract virtual void ClearFormatting();
    public abstract virtual string get_String();
    public abstract virtual int get_Length();
    public abstract virtual int get_NumFormattingRuns();
    public abstract virtual int GetIndexOfFormattingRun(int index);
    public abstract virtual void ApplyFont(short fontIndex);
}
public interface NPOI.SS.UserModel.IRow {
    public int RowNum { get; public set; }
    public short FirstCellNum { get; }
    public short LastCellNum { get; }
    public int PhysicalNumberOfCells { get; }
    public bool ZeroHeight { get; public set; }
    public short Height { get; public set; }
    public float HeightInPoints { get; public set; }
    public bool IsFormatted { get; }
    public ISheet Sheet { get; }
    public ICellStyle RowStyle { get; public set; }
    public List`1<ICell> Cells { get; }
    public int OutlineLevel { get; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Collapsed { get; public set; }
    public abstract virtual ICell CreateCell(int column);
    public abstract virtual ICell CreateCell(int column, CellType type);
    public abstract virtual void RemoveCell(ICell cell);
    public abstract virtual int get_RowNum();
    public abstract virtual void set_RowNum(int value);
    public abstract virtual ICell GetCell(int cellnum);
    public abstract virtual ICell GetCell(int cellnum, MissingCellPolicy policy);
    public abstract virtual short get_FirstCellNum();
    public abstract virtual short get_LastCellNum();
    public abstract virtual int get_PhysicalNumberOfCells();
    public abstract virtual bool get_ZeroHeight();
    public abstract virtual void set_ZeroHeight(bool value);
    public abstract virtual short get_Height();
    public abstract virtual void set_Height(short value);
    public abstract virtual float get_HeightInPoints();
    public abstract virtual void set_HeightInPoints(float value);
    public abstract virtual bool get_IsFormatted();
    public abstract virtual ISheet get_Sheet();
    public abstract virtual ICellStyle get_RowStyle();
    public abstract virtual void set_RowStyle(ICellStyle value);
    public abstract virtual void MoveCell(ICell cell, int newColumn);
    public abstract virtual IRow CopyRowTo(int targetIndex);
    public abstract virtual ICell CopyCell(int sourceIndex, int targetIndex);
    public abstract virtual List`1<ICell> get_Cells();
    public abstract virtual int get_OutlineLevel();
    public abstract virtual bool HasCustomHeight();
    public abstract virtual Nullable`1<bool> get_Hidden();
    public abstract virtual void set_Hidden(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_Collapsed();
    public abstract virtual void set_Collapsed(Nullable`1<bool> value);
}
public interface NPOI.SS.UserModel.IShape {
    public IShape Parent { get; }
    public UInt32 ID { get; }
    public string Name { get; public set; }
    public int LineStyleColor { get; }
    public int FillColor { get; public set; }
    public double LineWidth { get; public set; }
    public LineStyle LineStyle { get; public set; }
    public LineEndingCapType LineEndingCapType { get; public set; }
    public CompoundLineType CompoundLineType { get; public set; }
    public bool IsNoFill { get; public set; }
    public int CountOfAllChildren { get; }
    public abstract virtual IShape get_Parent();
    public abstract virtual UInt32 get_ID();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual void SetLineStyleColor(int lineStyleColor);
    public abstract virtual void SetLineStyleColor(int red, int green, int blue);
    public abstract virtual void SetFillColor(int red, int green, int blue);
    public abstract virtual int get_LineStyleColor();
    public abstract virtual int get_FillColor();
    public abstract virtual void set_FillColor(int value);
    public abstract virtual double get_LineWidth();
    public abstract virtual void set_LineWidth(double value);
    public abstract virtual LineStyle get_LineStyle();
    public abstract virtual void set_LineStyle(LineStyle value);
    public abstract virtual LineEndingCapType get_LineEndingCapType();
    public abstract virtual void set_LineEndingCapType(LineEndingCapType value);
    public abstract virtual CompoundLineType get_CompoundLineType();
    public abstract virtual void set_CompoundLineType(CompoundLineType value);
    public abstract virtual bool get_IsNoFill();
    public abstract virtual void set_IsNoFill(bool value);
    public abstract virtual int get_CountOfAllChildren();
}
public interface NPOI.SS.UserModel.ISheet {
    public int PhysicalNumberOfRows { get; }
    public int FirstRowNum { get; }
    public int LastRowNum { get; }
    public bool ForceFormulaRecalculation { get; public set; }
    public double DefaultColumnWidth { get; public set; }
    public short DefaultRowHeight { get; public set; }
    public float DefaultRowHeightInPoints { get; public set; }
    public bool HorizontallyCenter { get; public set; }
    public bool VerticallyCenter { get; public set; }
    public int NumMergedRegions { get; }
    public List`1<CellRangeAddress> MergedRegions { get; }
    public bool DisplayZeros { get; public set; }
    public bool Autobreaks { get; public set; }
    public bool DisplayGuts { get; public set; }
    public bool FitToPage { get; public set; }
    public bool RowSumsBelow { get; public set; }
    public bool RowSumsRight { get; public set; }
    public bool IsPrintGridlines { get; public set; }
    public bool IsPrintRowAndColumnHeadings { get; public set; }
    public IPrintSetup PrintSetup { get; }
    public IHeader Header { get; }
    public IFooter Footer { get; }
    public bool Protect { get; }
    public bool ScenarioProtect { get; }
    public short TabColorIndex { get; public set; }
    public IDrawing DrawingPatriarch { get; }
    public short TopRow { get; public set; }
    public short LeftCol { get; public set; }
    public PaneInformation PaneInformation { get; }
    public bool DisplayGridlines { get; public set; }
    public bool DisplayFormulas { get; public set; }
    public bool DisplayRowColHeadings { get; public set; }
    public bool IsActive { get; public set; }
    public Int32[] RowBreaks { get; }
    public Int32[] ColumnBreaks { get; }
    public IWorkbook Workbook { get; }
    public string SheetName { get; }
    public bool IsSelected { get; public set; }
    public ISheetConditionalFormatting SheetConditionalFormatting { get; }
    public bool IsRightToLeft { get; public set; }
    public CellRangeAddress RepeatingRows { get; public set; }
    public CellRangeAddress RepeatingColumns { get; public set; }
    public CellAddress ActiveCell { get; public set; }
    public abstract virtual IRow CreateRow(int rownum);
    public abstract virtual void RemoveRow(IRow row);
    public abstract virtual IRow GetRow(int rownum);
    public abstract virtual int get_PhysicalNumberOfRows();
    public abstract virtual int get_FirstRowNum();
    public abstract virtual int get_LastRowNum();
    public abstract virtual bool get_ForceFormulaRecalculation();
    public abstract virtual void set_ForceFormulaRecalculation(bool value);
    public abstract virtual void SetColumnHidden(int columnIndex, bool hidden);
    public abstract virtual bool IsColumnHidden(int columnIndex);
    public abstract virtual IRow CopyRow(int sourceIndex, int targetIndex);
    public abstract virtual IComment CopyComment(ICell sourceCell, ICell targetCell);
    public abstract virtual void SetColumnWidth(int columnIndex, double width);
    public abstract virtual double GetColumnWidth(int columnIndex);
    public abstract virtual double GetColumnWidthInPixels(int columnIndex);
    public abstract virtual double get_DefaultColumnWidth();
    public abstract virtual void set_DefaultColumnWidth(double value);
    public abstract virtual short get_DefaultRowHeight();
    public abstract virtual void set_DefaultRowHeight(short value);
    public abstract virtual float get_DefaultRowHeightInPoints();
    public abstract virtual void set_DefaultRowHeightInPoints(float value);
    public abstract virtual ICellStyle GetColumnStyle(int column);
    public abstract virtual int AddMergedRegion(CellRangeAddress region);
    public abstract virtual int AddMergedRegionUnsafe(CellRangeAddress region);
    public abstract virtual void ValidateMergedRegions();
    public abstract virtual bool get_HorizontallyCenter();
    public abstract virtual void set_HorizontallyCenter(bool value);
    public abstract virtual bool get_VerticallyCenter();
    public abstract virtual void set_VerticallyCenter(bool value);
    public abstract virtual void RemoveMergedRegion(int index);
    public abstract virtual void RemoveMergedRegions(IList`1<int> indices);
    public abstract virtual int get_NumMergedRegions();
    public abstract virtual CellRangeAddress GetMergedRegion(int index);
    public abstract virtual List`1<CellRangeAddress> get_MergedRegions();
    public abstract virtual IEnumerator GetRowEnumerator();
    public abstract virtual IEnumerator GetEnumerator();
    public abstract virtual bool get_DisplayZeros();
    public abstract virtual void set_DisplayZeros(bool value);
    public abstract virtual bool get_Autobreaks();
    public abstract virtual void set_Autobreaks(bool value);
    public abstract virtual bool get_DisplayGuts();
    public abstract virtual void set_DisplayGuts(bool value);
    public abstract virtual bool get_FitToPage();
    public abstract virtual void set_FitToPage(bool value);
    public abstract virtual bool get_RowSumsBelow();
    public abstract virtual void set_RowSumsBelow(bool value);
    public abstract virtual bool get_RowSumsRight();
    public abstract virtual void set_RowSumsRight(bool value);
    public abstract virtual bool get_IsPrintGridlines();
    public abstract virtual void set_IsPrintGridlines(bool value);
    public abstract virtual bool get_IsPrintRowAndColumnHeadings();
    public abstract virtual void set_IsPrintRowAndColumnHeadings(bool value);
    public abstract virtual IPrintSetup get_PrintSetup();
    public abstract virtual IHeader get_Header();
    public abstract virtual IFooter get_Footer();
    public abstract virtual double GetMargin(MarginType margin);
    public abstract virtual void SetMargin(MarginType margin, double size);
    public abstract virtual bool get_Protect();
    public abstract virtual void ProtectSheet(string password);
    public abstract virtual bool get_ScenarioProtect();
    public abstract virtual short get_TabColorIndex();
    public abstract virtual void set_TabColorIndex(short value);
    public abstract virtual IDrawing get_DrawingPatriarch();
    [ObsoleteAttribute("deprecated 2015-11-23 (circa POI 3.14beta1). Use {@link #setZoom(int)} instead.")]
public abstract virtual void SetZoom(int numerator, int denominator);
    public abstract virtual void SetZoom(int scale);
    public abstract virtual short get_TopRow();
    public abstract virtual void set_TopRow(short value);
    public abstract virtual short get_LeftCol();
    public abstract virtual void set_LeftCol(short value);
    public abstract virtual void ShowInPane(int toprow, int leftcol);
    public abstract virtual void ShiftRows(int startRow, int endRow, int n);
    public abstract virtual void ShiftRows(int startRow, int endRow, int n, bool copyRowHeight, bool resetOriginalRowHeight);
    public abstract virtual void CreateFreezePane(int colSplit, int rowSplit, int leftmostColumn, int topRow);
    public abstract virtual void CreateFreezePane(int colSplit, int rowSplit);
    public abstract virtual void CreateSplitPane(int xSplitPos, int ySplitPos, int leftmostColumn, int topRow, PanePosition activePane);
    public abstract virtual PaneInformation get_PaneInformation();
    public abstract virtual bool get_DisplayGridlines();
    public abstract virtual void set_DisplayGridlines(bool value);
    public abstract virtual bool get_DisplayFormulas();
    public abstract virtual void set_DisplayFormulas(bool value);
    public abstract virtual bool get_DisplayRowColHeadings();
    public abstract virtual void set_DisplayRowColHeadings(bool value);
    public abstract virtual bool get_IsActive();
    public abstract virtual void set_IsActive(bool value);
    public abstract virtual bool IsRowBroken(int row);
    public abstract virtual void RemoveRowBreak(int row);
    public abstract virtual Int32[] get_RowBreaks();
    public abstract virtual Int32[] get_ColumnBreaks();
    public abstract virtual void SetActiveCellRange(int firstRow, int lastRow, int firstColumn, int lastColumn);
    public abstract virtual void SetActiveCellRange(List`1<CellRangeAddress8Bit> cellranges, int activeRange, int activeRow, int activeColumn);
    public abstract virtual void SetColumnBreak(int column);
    public abstract virtual void SetRowBreak(int row);
    public abstract virtual bool IsColumnBroken(int column);
    public abstract virtual void RemoveColumnBreak(int column);
    public abstract virtual void SetColumnGroupCollapsed(int columnNumber, bool collapsed);
    public abstract virtual void GroupColumn(int fromColumn, int toColumn);
    public abstract virtual void UngroupColumn(int fromColumn, int toColumn);
    public abstract virtual void GroupRow(int fromRow, int toRow);
    public abstract virtual void UngroupRow(int fromRow, int toRow);
    public abstract virtual void SetRowGroupCollapsed(int row, bool collapse);
    public abstract virtual void SetDefaultColumnStyle(int column, ICellStyle style);
    public abstract virtual void AutoSizeColumn(int column);
    public abstract virtual void AutoSizeColumn(int column, bool useMergedCells);
    public abstract virtual void AutoSizeRow(int row);
    public abstract virtual void AutoSizeRow(int row, bool useMergedCells);
    [ObsoleteAttribute("deprecated as of 2015-11-23 (circa POI 3.14beta1). Use {@link #getCellComment(CellAddress)} instead.")]
public abstract virtual IComment GetCellComment(int row, int column);
    public abstract virtual IComment GetCellComment(CellAddress ref1);
    public abstract virtual Dictionary`2<CellAddress, IComment> GetCellComments();
    public abstract virtual IDrawing CreateDrawingPatriarch();
    public abstract virtual IWorkbook get_Workbook();
    public abstract virtual string get_SheetName();
    public abstract virtual bool get_IsSelected();
    public abstract virtual void set_IsSelected(bool value);
    public abstract virtual void SetActive(bool value);
    public abstract virtual ICellRange`1<ICell> SetArrayFormula(string formula, CellRangeAddress range);
    public abstract virtual ICellRange`1<ICell> RemoveArrayFormula(ICell cell);
    public abstract virtual bool IsMergedRegion(CellRangeAddress mergedRegion);
    public abstract virtual IDataValidationHelper GetDataValidationHelper();
    public abstract virtual List`1<IDataValidation> GetDataValidations();
    public abstract virtual void AddValidationData(IDataValidation dataValidation);
    public abstract virtual void RemoveDataValidation(IDataValidation dataValidation);
    public abstract virtual IAutoFilter SetAutoFilter(CellRangeAddress range);
    public abstract virtual ISheetConditionalFormatting get_SheetConditionalFormatting();
    public abstract virtual bool get_IsRightToLeft();
    public abstract virtual void set_IsRightToLeft(bool value);
    public abstract virtual CellRangeAddress get_RepeatingRows();
    public abstract virtual void set_RepeatingRows(CellRangeAddress value);
    public abstract virtual CellRangeAddress get_RepeatingColumns();
    public abstract virtual void set_RepeatingColumns(CellRangeAddress value);
    public abstract virtual ISheet CopySheet(string Name);
    public abstract virtual ISheet CopySheet(string Name, bool copyStyle);
    public abstract virtual int GetColumnOutlineLevel(int columnIndex);
    public abstract virtual bool IsDate1904();
    public abstract virtual IHyperlink GetHyperlink(int row, int column);
    public abstract virtual IHyperlink GetHyperlink(CellAddress addr);
    public abstract virtual List`1<IHyperlink> GetHyperlinkList();
    public abstract virtual CellAddress get_ActiveCell();
    public abstract virtual void set_ActiveCell(CellAddress value);
    public abstract virtual void CopyTo(IWorkbook dest, string name, bool copyStyle, bool keepFormulas);
}
public interface NPOI.SS.UserModel.ISheetConditionalFormatting {
    public int NumConditionalFormattings { get; }
    public abstract virtual int AddConditionalFormatting(CellRangeAddress[] regions, IConditionalFormattingRule rule);
    public abstract virtual int AddConditionalFormatting(CellRangeAddress[] regions, IConditionalFormattingRule rule1, IConditionalFormattingRule rule2);
    public abstract virtual int AddConditionalFormatting(CellRangeAddress[] regions, IConditionalFormattingRule[] cfRules);
    public abstract virtual int AddConditionalFormatting(IConditionalFormatting cf);
    public abstract virtual IConditionalFormattingRule CreateConditionalFormattingRule(ComparisonOperator comparisonOperation, string formula1, string formula2);
    public abstract virtual IConditionalFormattingRule CreateConditionalFormattingRule(ComparisonOperator comparisonOperation, string formula);
    public abstract virtual IConditionalFormattingRule CreateConditionalFormattingRule(string formula);
    public abstract virtual IConditionalFormattingRule CreateConditionalFormattingRule(ExtendedColor color);
    public abstract virtual IConditionalFormattingRule CreateConditionalFormattingRule(IconSet iconSet);
    public abstract virtual IConditionalFormattingRule CreateConditionalFormattingColorScaleRule();
    public abstract virtual IConditionalFormatting GetConditionalFormattingAt(int index);
    public abstract virtual int get_NumConditionalFormattings();
    public abstract virtual void RemoveConditionalFormatting(int index);
}
public interface NPOI.SS.UserModel.ITable {
    public int StartColIndex { get; }
    public int StartRowIndex { get; }
    public int EndColIndex { get; }
    public int EndRowIndex { get; }
    public string Name { get; }
    public string SheetName { get; }
    public bool IsHasTotalsRow { get; }
    public abstract virtual int get_StartColIndex();
    public abstract virtual int get_StartRowIndex();
    public abstract virtual int get_EndColIndex();
    public abstract virtual int get_EndRowIndex();
    public abstract virtual string get_Name();
    public abstract virtual int FindColumnIndex(string columnHeader);
    public abstract virtual string get_SheetName();
    public abstract virtual bool get_IsHasTotalsRow();
}
public interface NPOI.SS.UserModel.ITableStyle {
    public string Name { get; }
    public int Index { get; }
    public bool IsBuiltin { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_Index();
    public abstract virtual bool get_IsBuiltin();
    public abstract virtual DifferentialStyleProvider GetStyle(TableStyleType type);
}
public interface NPOI.SS.UserModel.ITableStyleInfo {
    public bool IsShowColumnStripes { get; public set; }
    public bool IsShowRowStripes { get; public set; }
    public bool IsShowFirstColumn { get; public set; }
    public bool IsShowLastColumn { get; public set; }
    public string Name { get; public set; }
    public ITableStyle Style { get; }
    public abstract virtual bool get_IsShowColumnStripes();
    public abstract virtual void set_IsShowColumnStripes(bool value);
    public abstract virtual bool get_IsShowRowStripes();
    public abstract virtual void set_IsShowRowStripes(bool value);
    public abstract virtual bool get_IsShowFirstColumn();
    public abstract virtual void set_IsShowFirstColumn(bool value);
    public abstract virtual bool get_IsShowLastColumn();
    public abstract virtual void set_IsShowLastColumn(bool value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual ITableStyle get_Style();
}
[ObsoleteAttribute("deprecated in POI 3.16 beta1, scheduled for removal in 3.18")]
public interface NPOI.SS.UserModel.ITextbox {
    public IRichTextString String { get; public set; }
    public int MarginLeft { get; public set; }
    public int MarginRight { get; public set; }
    public int MarginTop { get; public set; }
    public int MarginBottom { get; public set; }
    public short HorizontalAlignment { get; public set; }
    public short VerticalAlignment { get; public set; }
    public abstract virtual IRichTextString get_String();
    public abstract virtual void set_String(IRichTextString value);
    public abstract virtual int get_MarginLeft();
    public abstract virtual void set_MarginLeft(int value);
    public abstract virtual int get_MarginRight();
    public abstract virtual void set_MarginRight(int value);
    public abstract virtual int get_MarginTop();
    public abstract virtual void set_MarginTop(int value);
    public abstract virtual int get_MarginBottom();
    public abstract virtual void set_MarginBottom(int value);
    public abstract virtual short get_HorizontalAlignment();
    public abstract virtual void set_HorizontalAlignment(short value);
    public abstract virtual short get_VerticalAlignment();
    public abstract virtual void set_VerticalAlignment(short value);
}
public interface NPOI.SS.UserModel.IWorkbook {
    public int ActiveSheetIndex { get; }
    public int FirstVisibleTab { get; public set; }
    public int NumberOfSheets { get; }
    public short NumberOfFonts { get; }
    public int NumCellStyles { get; }
    public int NumberOfNames { get; }
    public MissingCellPolicy MissingCellPolicy { get; public set; }
    public bool IsHidden { get; public set; }
    public SpreadsheetVersion SpreadsheetVersion { get; }
    public abstract virtual int get_ActiveSheetIndex();
    public abstract virtual int get_FirstVisibleTab();
    public abstract virtual void set_FirstVisibleTab(int value);
    public abstract virtual void SetSheetOrder(string sheetname, int pos);
    public abstract virtual void SetSelectedTab(int index);
    public abstract virtual void SetActiveSheet(int sheetIndex);
    public abstract virtual string GetSheetName(int sheet);
    public abstract virtual void SetSheetName(int sheet, string name);
    public abstract virtual int GetSheetIndex(string name);
    public abstract virtual int GetSheetIndex(ISheet sheet);
    public abstract virtual ISheet CreateSheet();
    public abstract virtual ISheet CreateSheet(string sheetname);
    public abstract virtual ISheet CloneSheet(int sheetNum);
    public abstract virtual int get_NumberOfSheets();
    public abstract virtual ISheet GetSheetAt(int index);
    public abstract virtual ISheet GetSheet(string name);
    public abstract virtual void RemoveSheetAt(int index);
    public abstract virtual IEnumerator`1<ISheet> GetEnumerator();
    public abstract virtual IFont CreateFont();
    [ObsoleteAttribute("deprecated 3.15 beta 2. Use {@link #findFont(boolean, short, short, String, boolean, boolean, short, byte)} instead.")]
public abstract virtual IFont FindFont(short boldWeight, short color, short fontHeight, string name, bool italic, bool strikeout, FontSuperScript typeOffset, FontUnderlineType underline);
    public abstract virtual IFont FindFont(bool bold, short color, short fontHeight, string name, bool italic, bool strikeout, FontSuperScript typeOffset, FontUnderlineType underline);
    public abstract virtual short get_NumberOfFonts();
    public abstract virtual IFont GetFontAt(short idx);
    public abstract virtual ICellStyle CreateCellStyle();
    public abstract virtual int get_NumCellStyles();
    public abstract virtual ICellStyle GetCellStyleAt(int idx);
    public abstract virtual void Write(Stream stream, bool leaveOpen);
    public abstract virtual int get_NumberOfNames();
    public abstract virtual IName GetName(string name);
    public abstract virtual IList`1<IName> GetNames(string name);
    public abstract virtual IList`1<IName> GetAllNames();
    public abstract virtual IName GetNameAt(int nameIndex);
    public abstract virtual IName CreateName();
    public abstract virtual int GetNameIndex(string name);
    public abstract virtual void RemoveName(int index);
    public abstract virtual void RemoveName(string name);
    public abstract virtual void RemoveName(IName name);
    public abstract virtual int LinkExternalWorkbook(string name, IWorkbook workbook);
    public abstract virtual void SetPrintArea(int sheetIndex, string reference);
    public abstract virtual void SetPrintArea(int sheetIndex, int startColumn, int endColumn, int startRow, int endRow);
    public abstract virtual string GetPrintArea(int sheetIndex);
    public abstract virtual void RemovePrintArea(int sheetIndex);
    public abstract virtual MissingCellPolicy get_MissingCellPolicy();
    public abstract virtual void set_MissingCellPolicy(MissingCellPolicy value);
    public abstract virtual IDataFormat CreateDataFormat();
    public abstract virtual int AddPicture(Byte[] pictureData, PictureType format);
    public abstract virtual IList GetAllPictures();
    public abstract virtual ICreationHelper GetCreationHelper();
    public abstract virtual bool get_IsHidden();
    public abstract virtual void set_IsHidden(bool value);
    public abstract virtual bool IsSheetHidden(int sheetIx);
    public abstract virtual bool IsSheetVeryHidden(int sheetIx);
    public abstract virtual void SetSheetHidden(int sheetIx, SheetState hidden);
    public abstract virtual void SetSheetHidden(int sheetIx, int hidden);
    public abstract virtual void AddToolPack(UDFFinder toopack);
    public abstract virtual bool IsDate1904();
    public abstract virtual void Close();
    public abstract virtual SpreadsheetVersion get_SpreadsheetVersion();
}
public enum NPOI.SS.UserModel.LineEndingCapType : Enum {
    public int value__;
    public static LineEndingCapType None;
    public static LineEndingCapType Round;
    public static LineEndingCapType Square;
    public static LineEndingCapType Flat;
}
public enum NPOI.SS.UserModel.LineStyle : Enum {
    public int value__;
    public static LineStyle None;
    public static LineStyle Solid;
    public static LineStyle DashSys;
    public static LineStyle DotSys;
    public static LineStyle DashDotSys;
    public static LineStyle DashDotDotSys;
    public static LineStyle DotGel;
    public static LineStyle DashGel;
    public static LineStyle LongDashGel;
    public static LineStyle DashDotGel;
    public static LineStyle LongDashDotGel;
    public static LineStyle LongDashDotDotGel;
}
public enum NPOI.SS.UserModel.MarginType : Enum {
    public short value__;
    public static MarginType LeftMargin;
    public static MarginType RightMargin;
    public static MarginType TopMargin;
    public static MarginType BottomMargin;
    public static MarginType HeaderMargin;
    public static MarginType FooterMargin;
}
public enum NPOI.SS.UserModel.MissingCellPolicy : Enum {
    public int value__;
    public static MissingCellPolicy RETURN_NULL_AND_BLANK;
    public static MissingCellPolicy RETURN_BLANK_AS_NULL;
    public static MissingCellPolicy CREATE_NULL_AS_BLANK;
}
public static class NPOI.SS.UserModel.OperatorType : object {
    public static int BETWEEN;
    public static int NOT_BETWEEN;
    public static int EQUAL;
    public static int NOT_EQUAL;
    public static int GREATER_THAN;
    public static int LESS_THAN;
    public static int GREATER_OR_EQUAL;
    public static int LESS_OR_EQUAL;
    public static int IGNORED;
    public static void ValidateSecondArg(int comparisonOperator, string paramValue);
}
public class NPOI.SS.UserModel.PageOrder : object {
    public static PageOrder DOWN_THEN_OVER;
    public static PageOrder OVER_THEN_DOWN;
    private int order;
    private static PageOrder[] _table;
    public int Value { get; }
    private static PageOrder();
    private PageOrder(int order);
    public int get_Value();
    public static PageOrder ValueOf(int value);
}
public enum NPOI.SS.UserModel.PanePosition : Enum {
    public byte value__;
    public static PanePosition LowerRight;
    public static PanePosition UpperRight;
    public static PanePosition LowerLeft;
    public static PanePosition UpperLeft;
}
public enum NPOI.SS.UserModel.PaperSize : Enum {
    public short value__;
    public static PaperSize PRINTER_DEFAULT_PAPERSIZE;
    public static PaperSize US_Letter_Small;
    public static PaperSize US_Tabloid;
    public static PaperSize US_Ledger;
    public static PaperSize US_Legal;
    public static PaperSize US_Statement;
    public static PaperSize US_Executive;
    public static PaperSize A3;
    public static PaperSize A4;
    public static PaperSize A4_Small;
    public static PaperSize A5;
    public static PaperSize B4;
    public static PaperSize B5;
    public static PaperSize Folio;
    public static PaperSize Quarto;
    public static PaperSize TEN_BY_FOURTEEN;
    public static PaperSize ELEVEN_BY_SEVENTEEN;
    public static PaperSize US_Note;
    public static PaperSize US_Envelope_9;
    public static PaperSize US_Envelope_10;
    public static PaperSize US_Envelope_11;
    public static PaperSize US_Envelope_12;
    public static PaperSize US_Envelope_14;
    public static PaperSize C_Size_Sheet;
    public static PaperSize D_Size_Sheet;
    public static PaperSize E_Size_Sheet;
    public static PaperSize Envelope_DL;
    public static PaperSize Envelope_C5;
    public static PaperSize Envelope_C3;
    public static PaperSize Envelope_C4;
    public static PaperSize Envelope_C6;
    public static PaperSize Envelope_MONARCH;
    public static PaperSize A4_EXTRA;
    public static PaperSize A4_TRANSVERSE_PAPERSIZE;
    public static PaperSize A4_PLUS_PAPERSIZE;
    public static PaperSize LETTER_ROTATED_PAPERSIZE;
    public static PaperSize A4_ROTATED_PAPERSIZE;
}
public enum NPOI.SS.UserModel.PictureType : Enum {
    public int value__;
    public static PictureType Unknown;
    public static PictureType None;
    public static PictureType EMF;
    public static PictureType WMF;
    public static PictureType PICT;
    public static PictureType JPEG;
    public static PictureType PNG;
    public static PictureType DIB;
    public static PictureType GIF;
    public static PictureType TIFF;
    public static PictureType EPS;
    public static PictureType BMP;
    public static PictureType WPG;
}
public class NPOI.SS.UserModel.PrintCellComments : object {
    public static PrintCellComments NONE;
    public static PrintCellComments AS_DISPLAYED;
    public static PrintCellComments AT_END;
    private int comments;
    private static PrintCellComments[] _table;
    public int Value { get; }
    private static PrintCellComments();
    private PrintCellComments(int comments);
    public int get_Value();
    public static PrintCellComments ValueOf(int value);
}
public class NPOI.SS.UserModel.PrintOrientation : object {
    public static PrintOrientation DEFAULT;
    public static PrintOrientation PORTRAIT;
    public static PrintOrientation LANDSCAPE;
    private int orientation;
    private static PrintOrientation[] _table;
    public int Value { get; }
    private static PrintOrientation();
    private PrintOrientation(int orientation);
    public int get_Value();
    public static PrintOrientation ValueOf(int value);
}
public class NPOI.SS.UserModel.RangeType : object {
    public static RangeType NUMBER;
    public static RangeType MIN;
    public static RangeType MAX;
    public static RangeType PERCENT;
    public static RangeType PERCENTILE;
    public static RangeType UNALLOCATED;
    public static RangeType FORMULA;
    public static RangeType AUTOMIN;
    public static RangeType AUTOMAX;
    public int id;
    public string name;
    private static List`1<RangeType> values;
    private RangeType(int id, string name);
    private static RangeType();
    public static List`1<RangeType> Values();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeType ById(int id);
    public static RangeType ByName(string name);
}
public enum NPOI.SS.UserModel.ShapeTypes : Enum {
    public int value__;
    public static ShapeTypes None;
    public static ShapeTypes Line;
    public static ShapeTypes LineInv;
    public static ShapeTypes Triangle;
    public static ShapeTypes RightTriangle;
    public static ShapeTypes Rectangle;
    public static ShapeTypes Diamond;
    public static ShapeTypes Parallelogram;
    public static ShapeTypes Trapezoid;
    public static ShapeTypes NonIsoscelesTrapezoid;
    public static ShapeTypes Pentagon;
    public static ShapeTypes Hexagon;
    public static ShapeTypes Heptagon;
    public static ShapeTypes Octagon;
    public static ShapeTypes Decagon;
    public static ShapeTypes Dodecagon;
    public static ShapeTypes Star4;
    public static ShapeTypes Star5;
    public static ShapeTypes Star6;
    public static ShapeTypes Star7;
    public static ShapeTypes Star8;
    public static ShapeTypes Star10;
    public static ShapeTypes Star12;
    public static ShapeTypes Star16;
    public static ShapeTypes Star24;
    public static ShapeTypes Star32;
    public static ShapeTypes RoundedRectangle;
    public static ShapeTypes Rounded1Rectangle;
    public static ShapeTypes Rounded2SameRectangle;
    public static ShapeTypes Rounded2DiagonalRectangle;
    public static ShapeTypes SnipRoundedRectangle;
    public static ShapeTypes Snip1Rectangle;
    public static ShapeTypes Snip2SameRectangle;
    public static ShapeTypes Snip2DiagonalRectangle;
    public static ShapeTypes Plaque;
    public static ShapeTypes Ellipse;
    public static ShapeTypes Teardrop;
    public static ShapeTypes HomePlate;
    public static ShapeTypes Chevron;
    public static ShapeTypes PieWedge;
    public static ShapeTypes Pie;
    public static ShapeTypes BlockArc;
    public static ShapeTypes Donut;
    public static ShapeTypes NoSmoking;
    public static ShapeTypes RightArrow;
    public static ShapeTypes LeftArrow;
    public static ShapeTypes UpArrow;
    public static ShapeTypes DownArrow;
    public static ShapeTypes StripedRightArrow;
    public static ShapeTypes NotchedRightArrow;
    public static ShapeTypes BentUpArrow;
    public static ShapeTypes LeftRightArrow;
    public static ShapeTypes UpDownArrow;
    public static ShapeTypes LeftUpArrow;
    public static ShapeTypes LeftRightUpArrow;
    public static ShapeTypes QuadArrow;
    public static ShapeTypes LeftArrowCallout;
    public static ShapeTypes RightArrowCallout;
    public static ShapeTypes UpArrowCallout;
    public static ShapeTypes DownArrowCallout;
    public static ShapeTypes LeftRightArrowCallout;
    public static ShapeTypes UpDownArrowCallout;
    public static ShapeTypes QuadArrowCallout;
    public static ShapeTypes BentArrow;
    public static ShapeTypes UTurnArrow;
    public static ShapeTypes CircularArrow;
    public static ShapeTypes LeftCircularArrow;
    public static ShapeTypes LeftRightCircularArrow;
    public static ShapeTypes CurvedRightArrow;
    public static ShapeTypes CurvedLeftArrow;
    public static ShapeTypes CurvedUpArrow;
    public static ShapeTypes CurvedDownArrow;
    public static ShapeTypes SwooshArrow;
    public static ShapeTypes Cube;
    public static ShapeTypes Can;
    public static ShapeTypes LightningBolt;
    public static ShapeTypes Heart;
    public static ShapeTypes Sun;
    public static ShapeTypes Moon;
    public static ShapeTypes SmileyFace;
    public static ShapeTypes IrregularSeal1;
    public static ShapeTypes IrregularSeal2;
    public static ShapeTypes FoldedCorner;
    public static ShapeTypes Bevel;
    public static ShapeTypes Frame;
    public static ShapeTypes HalfFrame;
    public static ShapeTypes Corner;
    public static ShapeTypes DiagonalStripe;
    public static ShapeTypes Chord;
    public static ShapeTypes Arc;
    public static ShapeTypes LeftBracket;
    public static ShapeTypes RightBracket;
    public static ShapeTypes LeftBrace;
    public static ShapeTypes RightBrace;
    public static ShapeTypes BracketPair;
    public static ShapeTypes BracePair;
    public static ShapeTypes StraightConnector1;
    public static ShapeTypes BentConnector2;
    public static ShapeTypes BentConnector3;
    public static ShapeTypes BentConnector4;
    public static ShapeTypes BentConnector5;
    public static ShapeTypes CurvedConnector2;
    public static ShapeTypes CurvedConnector3;
    public static ShapeTypes CurvedConnector4;
    public static ShapeTypes CurvedConnector5;
    public static ShapeTypes Callout1;
    public static ShapeTypes Callout2;
    public static ShapeTypes Callout3;
    public static ShapeTypes AccentCallout1;
    public static ShapeTypes AccentCallout2;
    public static ShapeTypes AccentCallout3;
    public static ShapeTypes BorderCallout1;
    public static ShapeTypes BorderCallout2;
    public static ShapeTypes BorderCallout3;
    public static ShapeTypes AccentBorderCallout1;
    public static ShapeTypes AccentBorderCallout2;
    public static ShapeTypes AccentBorderCallout3;
    public static ShapeTypes WedgeRectangleCallout;
    public static ShapeTypes WedgeRoundRectangleCallout;
    public static ShapeTypes WedgeEllipseCallout;
    public static ShapeTypes CloudCallout;
    public static ShapeTypes Cloud;
    public static ShapeTypes Ribbon;
    public static ShapeTypes Ribbon2;
    public static ShapeTypes EllipseRibbon;
    public static ShapeTypes EllipseRibbon2;
    public static ShapeTypes LeftRightRibbon;
    public static ShapeTypes VerticalScroll;
    public static ShapeTypes HorizontalScroll;
    public static ShapeTypes Wave;
    public static ShapeTypes DoubleWave;
    public static ShapeTypes Plus;
    public static ShapeTypes FlowChartProcess;
    public static ShapeTypes FlowChartDecision;
    public static ShapeTypes FlowChartInputOutput;
    public static ShapeTypes FlowChartPredefinedProcess;
    public static ShapeTypes FlowChartInternalStorage;
    public static ShapeTypes FlowChartDocument;
    public static ShapeTypes FlowChartMultiDocument;
    public static ShapeTypes FlowChartTerminator;
    public static ShapeTypes FlowChartPreparation;
    public static ShapeTypes FlowChartManualInput;
    public static ShapeTypes FlowChartManualOperation;
    public static ShapeTypes FlowChartConnector;
    public static ShapeTypes FlowChartPunchedCard;
    public static ShapeTypes FlowChartPunchedTape;
    public static ShapeTypes FlowChartSummingJunction;
    public static ShapeTypes FlowChartOr;
    public static ShapeTypes FlowChartCollate;
    public static ShapeTypes FlowChartSort;
    public static ShapeTypes FlowChartExtract;
    public static ShapeTypes FlowChartMerge;
    public static ShapeTypes FlowChartOfflineStorage;
    public static ShapeTypes FlowChartOnlineStorage;
    public static ShapeTypes FlowChartMagneticTape;
    public static ShapeTypes FlowChartMagneticDisk;
    public static ShapeTypes FlowChartMagneticDrum;
    public static ShapeTypes FlowChartDisplay;
    public static ShapeTypes FlowChartDelay;
    public static ShapeTypes FlowChartAlternateProcess;
    public static ShapeTypes FlowChartOffpageConnector;
    public static ShapeTypes ActionButtonBlank;
    public static ShapeTypes ActionButtonHome;
    public static ShapeTypes ActionButtonHelp;
    public static ShapeTypes ActionButtonInformation;
    public static ShapeTypes ActionButtonForwardNext;
    public static ShapeTypes ActionButtonBackPrevious;
    public static ShapeTypes ActionButtonEnd;
    public static ShapeTypes ActionButtonBeginning;
    public static ShapeTypes ActionButtonReturn;
    public static ShapeTypes ActionButtonDocument;
    public static ShapeTypes ActionButtonSound;
    public static ShapeTypes ActionButtonMovie;
    public static ShapeTypes Gear6;
    public static ShapeTypes Gear9;
    public static ShapeTypes Funnel;
    public static ShapeTypes MathPlus;
    public static ShapeTypes MathMinus;
    public static ShapeTypes MathMultiply;
    public static ShapeTypes MathDivide;
    public static ShapeTypes MathEqual;
    public static ShapeTypes MathNotEqual;
    public static ShapeTypes CornerTabs;
    public static ShapeTypes SquareTabs;
    public static ShapeTypes PlaqueTabs;
    public static ShapeTypes ChartX;
    public static ShapeTypes ChartStar;
    public static ShapeTypes ChartPlus;
}
public enum NPOI.SS.UserModel.SheetState : Enum {
    public int value__;
    public static SheetState Visible;
    public static SheetState Hidden;
    public static SheetState VeryHidden;
}
public static class NPOI.SS.UserModel.Table : object {
    public static Regex IsStructuredReference;
    private static Table();
}
public enum NPOI.SS.UserModel.TableStyleType : Enum {
    public int value__;
    public static TableStyleType wholeTable;
    public static TableStyleType pageFieldLabels;
    public static TableStyleType pageFieldValues;
    public static TableStyleType firstColumnStripe;
    public static TableStyleType secondColumnStripe;
    public static TableStyleType firstRowStripe;
    public static TableStyleType secondRowStripe;
    public static TableStyleType lastColumn;
    public static TableStyleType firstColumn;
    public static TableStyleType headerRow;
    public static TableStyleType totalRow;
    public static TableStyleType firstHeaderCell;
    public static TableStyleType lastHeaderCell;
    public static TableStyleType firstTotalCell;
    public static TableStyleType lastTotalCell;
    public static TableStyleType firstSubtotalColumn;
    public static TableStyleType secondSubtotalColumn;
    public static TableStyleType thirdSubtotalColumn;
    public static TableStyleType blankRow;
    public static TableStyleType firstSubtotalRow;
    public static TableStyleType secondSubtotalRow;
    public static TableStyleType thirdSubtotalRow;
    public static TableStyleType firstColumnSubheading;
    public static TableStyleType secondColumnSubheading;
    public static TableStyleType thirdColumnSubheading;
    public static TableStyleType firstRowSubheading;
    public static TableStyleType secondRowSubheading;
    public static TableStyleType thirdRowSubheading;
}
public static class NPOI.SS.UserModel.ValidationType : object {
    public static int ANY;
    public static int INTEGER;
    public static int DECIMAL;
    public static int LIST;
    public static int DATE;
    public static int TIME;
    public static int TEXT_LENGTH;
    public static int FORMULA;
}
public enum NPOI.SS.UserModel.VerticalAlignment : Enum {
    public int value__;
    public static VerticalAlignment None;
    public static VerticalAlignment Top;
    public static VerticalAlignment Center;
    public static VerticalAlignment Bottom;
    public static VerticalAlignment Justify;
    public static VerticalAlignment Distributed;
}
public class NPOI.SS.Util.AreaReference : object {
    private static char SHEET_NAME_DELIMITER;
    private static char CELL_DELIMITER;
    private static char SPECIAL_NAME_DELIMITER;
    private static SpreadsheetVersion DEFAULT_SPREADSHEET_VERSION;
    private CellReference _firstCell;
    private CellReference _lastCell;
    private bool _isSingleCell;
    private SpreadsheetVersion _version;
    public bool IsSingleCell { get; }
    public CellReference FirstCell { get; }
    public CellReference LastCell { get; }
    [ObsoleteAttribute("deprecated since NPOI 2.5.1 Prefer supplying a spreadsheet version.")]
public AreaReference(string reference);
    public AreaReference(string reference, SpreadsheetVersion version);
    public AreaReference(CellReference topLeft, CellReference botRight, SpreadsheetVersion version);
    public AreaReference(CellReference topLeft, CellReference botRight);
    private static AreaReference();
    private static bool IsPlainColumn(string refPart);
    public static AreaReference GetWholeRow(SpreadsheetVersion version, string start, string end);
    public static AreaReference GetWholeColumn(SpreadsheetVersion version, string start, string end);
    public static bool IsContiguous(string reference);
    public static bool IsWholeColumnReference(SpreadsheetVersion version, CellReference topLeft, CellReference botRight);
    public bool IsWholeColumnReference();
    public static AreaReference[] GenerateContiguous(string reference);
    public bool get_IsSingleCell();
    public CellReference get_FirstCell();
    public CellReference get_LastCell();
    public CellReference[] GetAllReferencedCells();
    public string FormatAsString();
    public virtual string ToString();
    private static String[] SeparateAreaRefs(string reference);
}
public class NPOI.SS.Util.CellAddress : object {
    public static CellAddress A1;
    private int _row;
    private int _col;
    public int Row { get; }
    public int Column { get; }
    public CellAddress(int row, int column);
    public CellAddress(string address);
    public CellAddress(CellReference reference);
    public CellAddress(CellAddress address);
    public CellAddress(ICell cell);
    private static CellAddress();
    public int get_Row();
    public int get_Column();
    public sealed virtual int CompareTo(CellAddress other);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string FormatAsString();
}
public class NPOI.SS.Util.CellRangeAddress : CellRangeAddressBase {
    public static int ENCODED_SIZE;
    public CellRangeAddress(int firstRow, int lastRow, int firstCol, int lastCol);
    public CellRangeAddress(RecordInputStream in1);
    private static int ReadUShortAndCheck(RecordInputStream in1);
    public void Serialize(ILittleEndianOutput out1);
    public string FormatAsString();
    public string FormatAsString(string sheetName, bool useAbsoluteAddress);
    public CellRangeAddress Copy();
    public static int GetEncodedSize(int numberOfItems);
    public static CellRangeAddress ValueOf(string reference);
}
public class NPOI.SS.Util.CellRangeAddress8Bit : CellRangeAddressBase {
    public static int ENCODED_SIZE;
    public CellRangeAddress8Bit(int firstRow, int lastRow, int firstCol, int lastCol);
    public CellRangeAddress8Bit(RecordInputStream in1);
    private static int ReadUShortAndCheck(RecordInputStream in1);
    public int Serialize(int offset, Byte[] data);
    public void Serialize(ILittleEndianOutput out1);
    public CellRangeAddress8Bit Copy();
    public static int GetEncodedSize(int numberOfItems);
}
public abstract class NPOI.SS.Util.CellRangeAddressBase : object {
    private int _firstRow;
    private int _firstCol;
    private int _lastRow;
    private int _lastCol;
    public bool IsFullColumnRange { get; }
    public bool IsFullRowRange { get; }
    public int FirstColumn { get; public set; }
    public int FirstRow { get; public set; }
    public int LastColumn { get; public set; }
    public int LastRow { get; public set; }
    public int NumberOfCells { get; }
    public int MinRow { get; }
    public int MaxRow { get; }
    public int MinColumn { get; }
    public int MaxColumn { get; }
    protected CellRangeAddressBase(int firstRow, int lastRow, int firstCol, int lastCol);
    public void Validate(SpreadsheetVersion ssVersion);
    private static void ValidateRow(int row, SpreadsheetVersion ssVersion);
    private static void ValidateColumn(int column, SpreadsheetVersion ssVersion);
    public bool IsInRange(int rowInd, int colInd);
    public bool IsInRange(CellReference reference);
    public bool get_IsFullColumnRange();
    public bool get_IsFullRowRange();
    public bool ContainsRow(int rowInd);
    public bool ContainsColumn(int colInd);
    public bool Intersects(CellRangeAddressBase other);
    public int get_FirstColumn();
    public void set_FirstColumn(int value);
    public int get_FirstRow();
    public void set_FirstRow(int value);
    public int get_LastColumn();
    public void set_LastColumn(int value);
    public int get_LastRow();
    public void set_LastRow(int value);
    public int get_NumberOfCells();
    public virtual string ToString();
    public int get_MinRow();
    public int get_MaxRow();
    public int get_MinColumn();
    public int get_MaxColumn();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NPOI.SS.Util.CellRangeAddressList : object {
    private ArrayList _list;
    public int Size { get; }
    public CellRangeAddress[] CellRangeAddresses { get; }
    public CellRangeAddressList(int firstRow, int lastRow, int firstCol, int lastCol);
    public CellRangeAddressList(RecordInputStream in1);
    public int CountRanges();
    public void AddCellRangeAddress(int firstRow, int firstCol, int lastRow, int lastCol);
    public void AddCellRangeAddress(CellRangeAddress cra);
    public CellRangeAddress Remove(int rangeIndex);
    public CellRangeAddress GetCellRangeAddress(int index);
    public int Serialize(int offset, Byte[] data);
    public void Serialize(ILittleEndianOutput out1);
    public int get_Size();
    public static int GetEncodedSize(int numberOfRanges);
    public CellRangeAddressList Copy();
    public CellRangeAddress[] get_CellRangeAddresses();
}
public class NPOI.SS.Util.CellRangeUtil : object {
    public static int NO_INTERSECTION;
    public static int OVERLAP;
    public static int INSIDE;
    public static int ENCLOSES;
    public static int Intersect(CellRangeAddress crA, CellRangeAddress crB);
    public static CellRangeAddress[] MergeCellRanges(CellRangeAddress[] cellRanges);
    private static List`1<CellRangeAddress> MergeCellRanges(List`1<CellRangeAddress> cellRangeList);
    private static CellRangeAddress[] MergeRanges(CellRangeAddress range1, CellRangeAddress range2);
    [ObsoleteAttribute]
private static CellRangeAddress[] ToArray(ArrayList temp);
    public static bool Contains(CellRangeAddress crA, CellRangeAddress crB);
    public static bool HasExactSharedBorder(CellRangeAddress crA, CellRangeAddress crB);
    public static CellRangeAddress CreateEnclosingCellRange(CellRangeAddress crA, CellRangeAddress crB);
    private static bool lt(int a, int b);
    private static bool le(int a, int b);
    private static bool gt(int a, int b);
    private static bool ge(int a, int b);
}
public class NPOI.SS.Util.CellReference : object {
    private static char ABSOLUTE_REFERENCE_MARKER;
    private static char SHEET_NAME_DELIMITER;
    private static char SPECIAL_NAME_DELIMITER;
    private static Regex NAMED_RANGE_NAME_PATTERN;
    private string _sheetName;
    private int _rowIndex;
    private int _colIndex;
    private bool _isRowAbs;
    private bool _isColAbs;
    public int Row { get; }
    public short Col { get; }
    public bool IsRowAbsolute { get; }
    public bool IsColAbsolute { get; }
    public string SheetName { get; }
    public String[] CellRefParts { get; }
    public CellReference(string cellRef);
    public CellReference(ReadOnlySpan`1<char> cellRef);
    public CellReference(ICell cell);
    public CellReference(int pRow, int pCol);
    public CellReference(int pRow, short pCol);
    public CellReference(int pRow, int pCol, bool pAbsRow, bool pAbsCol);
    public CellReference(string pSheetName, int pRow, int pCol, bool pAbsRow, bool pAbsCol);
    private static CellReference();
    public int get_Row();
    public short get_Col();
    public bool get_IsRowAbsolute();
    public bool get_IsColAbsolute();
    public string get_SheetName();
    public static int ConvertColStringToIndex(string refs);
    public static int ConvertColStringToIndex(ReadOnlySpan`1<char> refs);
    public static bool IsPartAbsolute(string part);
    public static NameType ClassifyCellReference(string str, SpreadsheetVersion ssVersion);
    public static NameType ClassifyCellReference(ReadOnlySpan`1<char> str, SpreadsheetVersion ssVersion);
    private static NameType ValidateNamedRangeName(ReadOnlySpan`1<char> str, SpreadsheetVersion ssVersion);
    public static string ConvertNumToColString(int col);
    private static CellRefPartsInner SeparateRefParts(ReadOnlySpan`1<char> reference);
    private static string ParseSheetName(ReadOnlySpan`1<char> reference, int indexOfSheetNameDelimiter);
    public string FormatAsString();
    public virtual string ToString();
    public String[] get_CellRefParts();
    public void AppendCellReference(StringBuilder sb);
    public static bool CellReferenceIsWithinRange(string colStr, string rowStr, SpreadsheetVersion ssVersion);
    public static bool CellReferenceIsWithinRange(ReadOnlySpan`1<char> colStr, ReadOnlySpan`1<char> rowStr, SpreadsheetVersion ssVersion);
    [ObsoleteAttribute("deprecated 3.15 beta 2. Use {@link #isColumnWithinRange}.")]
public static bool IsColumnWithnRange(string colStr, SpreadsheetVersion ssVersion);
    public static bool IsRowWithinRange(string rowStr, SpreadsheetVersion ssVersion);
    public static bool IsRowWithinRange(ReadOnlySpan`1<char> rowStr, SpreadsheetVersion ssVersion);
    [ObsoleteAttribute("deprecated 3.15 beta 2. Use {@link #isRowWithinRange}")]
public static bool isRowWithnRange(string rowStr, SpreadsheetVersion ssVersion);
    public static bool IsColumnWithinRange(string colStr, SpreadsheetVersion ssVersion);
    public static bool IsColumnWithinRange(ReadOnlySpan`1<char> colStr, SpreadsheetVersion ssVersion);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal static class NPOI.SS.Util.CellReferenceParser : object {
    public static bool TryParseCellReference(ReadOnlySpan`1<char> input, Char& columnPrefix, ReadOnlySpan`1& column, Char& rowPrefix, ReadOnlySpan`1& row);
    public static bool TryParseStrictCellReference(ReadOnlySpan`1<char> input, ReadOnlySpan`1& column, ReadOnlySpan`1& row);
    public static bool TryParseColumnReference(ReadOnlySpan`1<char> input, ReadOnlySpan`1& column);
    public static bool TryParseRowReference(ReadOnlySpan`1<char> input, ReadOnlySpan`1& row);
    private static bool TryParse(ReadOnlySpan`1<char> input, Char& columnPrefix, ReadOnlySpan`1& column, Char& rowPrefix, ReadOnlySpan`1& row);
    public static bool TryParsePositiveInt32Fast(ReadOnlySpan`1<char> s, Int32& result);
}
public class NPOI.SS.Util.CellUtil : object {
    public static string ALIGNMENT;
    public static string BORDER_BOTTOM;
    public static string BORDER_DIAGONAL;
    public static string BORDER_LEFT;
    public static string BORDER_RIGHT;
    public static string BORDER_TOP;
    public static string BOTTOM_BORDER_COLOR;
    public static string DATA_FORMAT;
    public static string FILL_BACKGROUND_COLOR;
    public static string FILL_FOREGROUND_COLOR;
    public static string FILL_PATTERN;
    public static string FONT;
    public static string HIDDEN;
    public static string INDENTION;
    public static string LEFT_BORDER_COLOR;
    public static string LOCKED;
    public static string RIGHT_BORDER_COLOR;
    public static string ROTATION;
    public static string SHRINK_TO_FIT;
    public static string TOP_BORDER_COLOR;
    public static string VERTICAL_ALIGNMENT;
    public static string WRAP_TEXT;
    private static ISet`1<string> shortValues;
    private static ISet`1<string> intValues;
    private static ISet`1<string> booleanValues;
    private static ISet`1<string> borderTypeValues;
    private static UnicodeMapping[] unicodeMappings;
    private static CellUtil();
    public static ICell CopyCell(IRow row, int sourceIndex, int targetIndex);
    private static ICell CopyCell(ICell oldCell, ICell newCell, int sourceIndex, int targetIndex);
    public static IRow GetRow(int rowIndex, ISheet sheet);
    public static ICell GetCell(IRow row, int columnIndex);
    public static ICell CreateCell(IRow row, int column, string value, ICellStyle style);
    public static ICell CreateCell(IRow row, int column, string value);
    [ObsoleteAttribute("deprecated 3.15-beta2. Use {@link #SetAlignment(ICell, HorizontalAlignment)} instead.")]
public static void SetAlignment(ICell cell, IWorkbook workbook, short align);
    public static void SetAlignment(ICell cell, HorizontalAlignment align);
    public static void SetVerticalAlignment(ICell cell, VerticalAlignment align);
    [ObsoleteAttribute("deprecated 3.15-beta2. Use {@link #SetFont(ICell, IFont)} instead.")]
public static void SetFont(ICell cell, IWorkbook workbook, IFont font);
    public static void SetFont(ICell cell, IFont font);
    public static void SetCellStyleProperties(ICell cell, Dictionary`2<string, object> properties, bool cloneExistingStyles);
    public static bool DictionaryEqual(IDictionary`2<TKey, TValue> first, IDictionary`2<TKey, TValue> second, IEqualityComparer`1<TValue> valueComparer);
    public static void SetCellStyleProperty(ICell cell, string propertyName, object propertyValue);
    [ObsoleteAttribute("deprecated 3.15-beta2. Use {@link #setCellStyleProperty(Cell, String, Object)} instead.")]
public static void SetCellStyleProperty(ICell cell, IWorkbook workbook, string propertyName, object propertyValue);
    private static void PutAll(Dictionary`2<string, object> src, Dictionary`2<string, object> dest);
    private static Dictionary`2<string, object> GetFormatProperties(ICellStyle style);
    private static void SetFormatProperties(ICellStyle style, IWorkbook workbook, Dictionary`2<string, object> properties);
    private static short GetShort(Dictionary`2<string, object> properties, string name);
    private static int GetInt(Dictionary`2<string, object> properties, string name);
    private static BorderStyle GetBorderStyle(Dictionary`2<string, object> properties, string name);
    private static FillPattern GetFillPattern(Dictionary`2<string, object> properties, string name);
    private static HorizontalAlignment GetHorizontalAlignment(Dictionary`2<string, object> properties, string name);
    private static VerticalAlignment GetVerticalAlignment(Dictionary`2<string, object> properties, string name);
    private static bool GetBoolean(Dictionary`2<string, object> properties, string name);
    private static void Put(Dictionary`2<string, object> properties, string name, object value);
    private static void PutShort(Dictionary`2<string, object> properties, string name, short value);
    private static void PutEnum(Dictionary`2<string, object> properties, string name, Enum value);
    private static void PutBoolean(Dictionary`2<string, object> properties, string name, bool value);
    public static ICell TranslateUnicodeValues(ICell cell);
    private static UnicodeMapping um(string entityName, string resolvedValue);
}
public class NPOI.SS.Util.CellWalk.CellWalk : object {
    private ISheet sheet;
    private CellRangeAddress range;
    private bool traverseEmptyCells;
    public CellWalk(ISheet sheet, CellRangeAddress range);
    public bool IsTraverseEmptyCells();
    public void SetTraverseEmptyCells(bool traverseEmptyCells);
    public void Traverse(ICellHandler handler);
    private bool IsEmpty(ICell cell);
}
public interface NPOI.SS.Util.CellWalk.ICellHandler {
    public abstract virtual void OnCell(ICell cell, ICellWalkContext ctx);
}
public interface NPOI.SS.Util.CellWalk.ICellWalkContext {
    public long OrdinalNumber { get; }
    public int RowNumber { get; }
    public int ColumnNumber { get; }
    public abstract virtual long get_OrdinalNumber();
    public abstract virtual int get_RowNumber();
    public abstract virtual int get_ColumnNumber();
}
public class NPOI.SS.Util.ConstantStringFormat : FormatBase {
    private static DecimalFormat df;
    private string str;
    public ConstantStringFormat(string s);
    private static ConstantStringFormat();
    public virtual string Format(object obj);
    public virtual string Format(object obj, CultureInfo culture);
    public virtual StringBuilder Format(object obj, StringBuilder toAppendTo, CultureInfo culture);
    public virtual object ParseObject(string source, int pos);
}
public class NPOI.SS.Util.DataMarker : object {
    private ISheet sheet;
    private CellRangeAddress range;
    public ISheet Sheet { get; public set; }
    public CellRangeAddress Range { get; public set; }
    public DataMarker(ISheet sheet, CellRangeAddress range);
    public ISheet get_Sheet();
    public void set_Sheet(ISheet value);
    public CellRangeAddress get_Range();
    public void set_Range(CellRangeAddress value);
    public string FormatAsString();
}
public abstract class NPOI.SS.Util.DateFormat : FormatBase {
    public static int FULL;
    public static int LONG;
    public static int MEDIUM;
    public static int SHORT;
    public static int DEFAULT;
    public static string GetDateTimePattern(int dateStyle, int timeStyle, CultureInfo locale);
    public static string GetDatePattern(int dateStyle, CultureInfo locale);
    public static string GetTimePattern(int timeStyle, CultureInfo locale);
}
public class NPOI.SS.Util.DateFormatConverter : object {
    private static POILogger logger;
    private static Dictionary`2<string, string> tokenConversions;
    private static Dictionary`2<string, string> localePrefixes;
    private static DateFormatConverter();
    private static Dictionary`2<string, string> PrepareTokenConversions();
    private static Dictionary`2<string, string> PrepareLocalePrefixes();
    public static string GetPrefixForLocale(CultureInfo locale);
    public static string Convert(CultureInfo locale, DateFormat df);
    public static string Convert(CultureInfo locale, string format);
    public static string GetDatePattern(int style, CultureInfo locale);
    public static string GetTimePattern(int style, CultureInfo locale);
    public static string GetDateTimePattern(int style, CultureInfo locale);
}
public class NPOI.SS.Util.DecimalFormat : FormatBase {
    private string _pattern;
    private NumberFormatInfo _formatInfo;
    private static Regex RegexFraction;
    public string Pattern { get; }
    public bool ParseIntegerOnly { get; }
    public DecimalFormat(string pattern);
    public DecimalFormat(string pattern, NumberFormatInfo formatInfo);
    private static DecimalFormat();
    public string get_Pattern();
    public virtual string Format(object obj);
    public virtual string Format(object obj, CultureInfo culture);
    public virtual StringBuilder Format(object obj, StringBuilder toAppendTo, CultureInfo culture);
    public virtual object ParseObject(string source, int pos);
    public bool get_ParseIntegerOnly();
}
[ExtensionAttribute]
internal static class NPOI.SS.Util.DoublePrecisionHelper : object {
    public static double GetFractionPart(double number);
    public static double DropDigitsAfterSignificantOnes(double number, int digits);
    [ExtensionAttribute]
public static bool IsIntegerWithDigitsDropped(double number, int significantDigits);
    [ExtensionAttribute]
public static bool IsIntegerWithDigitsDropped(BigDecimal number, int significantDigits);
}
public class NPOI.SS.Util.ExpandedDouble : object {
    private static BigInteger BI_FRAC_MASK;
    private static BigInteger BI_IMPLIED_FRAC_MSB;
    private BigInteger _significand;
    private int _binaryExponent;
    public ExpandedDouble(long rawBits);
    public ExpandedDouble(BigInteger frac, int binaryExp);
    private static ExpandedDouble();
    private static BigInteger GetFrac(long rawBits);
    public static ExpandedDouble FromRawBitsAndExponent(long rawBits, int exp);
    public NormalisedDecimal NormaliseBaseTen();
    public int GetBinaryExponent();
    public BigInteger GetSignificand();
}
public abstract class NPOI.SS.Util.FormatBase : object {
    [CompilerGeneratedAttribute]
private TimeZoneInfo <TimeZone>k__BackingField;
    public TimeZoneInfo TimeZone { get; public set; }
    public virtual string Format(object obj, CultureInfo culture);
    public virtual string Format(object obj);
    protected virtual StringBuilder Format(object obj, StringBuilder sb, int pos);
    public abstract virtual StringBuilder Format(object obj, StringBuilder toAppendTo, CultureInfo culture);
    public abstract virtual object ParseObject(string source, int pos);
    [CompilerGeneratedAttribute]
public TimeZoneInfo get_TimeZone();
    [CompilerGeneratedAttribute]
public void set_TimeZone(TimeZoneInfo value);
}
public class NPOI.SS.Util.IEEEDouble : object {
    private static long EXPONENT_MASK;
    private static int EXPONENT_SHIFT;
    public static long FRAC_MASK;
    public static int EXPONENT_BIAS;
    public static long FRAC_ASSUMED_HIGH_BIT;
    public static int BIASED_EXPONENT_SPECIAL_VALUE;
    public static int GetBiasedExponent(long rawBits);
}
public class NPOI.SS.Util.ImageUtils : object {
    private static POILogger logger;
    public static int PIXEL_DPI;
    private static ImageUtils();
    public static Size GetImageDimension(Stream is1);
    public static Size GetImageDimension(Stream is1, PictureType type);
    public static Int32[] GetResolution(Image r);
    public static Size SetPreferredSize(IPicture picture, double scaleX, double scaleY);
    public static Size GetDimensionFromAnchor(IPicture picture);
    private static double GetRowHeightInPixels(ISheet sheet, int rowNum);
}
public class NPOI.SS.Util.MutableFPNumber : object {
    private static BigInteger BI_MIN_BASE;
    private static BigInteger BI_MAX_BASE;
    private static int C_64;
    private static int MIN_PRECISION;
    private BigInteger _significand;
    private int _binaryExponent;
    public MutableFPNumber(BigInteger frac, int binaryExponent);
    private static MutableFPNumber();
    public MutableFPNumber Copy();
    public void Normalise64bit();
    public int Get64BitNormalisedExponent();
    public bool IsBelowMaxRep();
    public bool IsAboveMinRep();
    public NormalisedDecimal CreateNormalisedDecimal(int pow10);
    public void multiplyByPowerOfTen(int pow10);
    private void mulShift(BigInteger multiplicand, int multiplierShift);
    public ExpandedDouble CreateExpandedDouble();
}
public enum NPOI.SS.Util.NameType : Enum {
    public int value__;
    public static NameType None;
    public static NameType Cell;
    public static NameType NamedRange;
    public static NameType Column;
    public static NameType Row;
    public static NameType BadCellOrNamedRange;
}
public class NPOI.SS.Util.NormalisedDecimal : object {
    private static int EXPONENT_OFFSET;
    private static decimal BD_2_POW_24;
    private static int LOG_BASE_10_OF_2_TIMES_2_POW_20;
    private static int C_2_POW_19;
    private static int FRAC_HALF;
    private static long MAX_REP_WHOLE_PART;
    private int _relativeDecimalExponent;
    private long _wholePart;
    private int _fractionalPart;
    public NormalisedDecimal(long wholePart, int fracPart, int decimalExponent);
    private static NormalisedDecimal();
    public static NormalisedDecimal Create(BigInteger frac, int binaryExponent);
    public NormalisedDecimal RoundUnits();
    public ExpandedDouble NormaliseBaseTwo();
    public BigInteger ComposeFrac();
    public string GetSignificantDecimalDigits();
    public string GetSignificantDecimalDigitsLastDigitRounded();
    public int GetDecimalExponent();
    public int CompareNormalised(NormalisedDecimal other);
    public decimal GetFractionalPart();
    private string GetFractionalDigits();
    public virtual string ToString();
}
public class NPOI.SS.Util.NumberComparer : object {
    public static int Compare(double a, double b);
    private static int CompareSubnormalNumbers(long fracA, long fracB, bool isNegative);
    private static int CompareAcrossSubnormalThreshold(long normalRawBitsA, long subnormalRawBitsB, bool isNegative);
    private static string ToHex(double a);
}
public class NPOI.SS.Util.NumberToTextConverter : object {
    private static long EXCEL_NAN_BITS;
    private static int MAX_TEXT_LEN;
    public static string ToText(double value);
    public static string RawDoubleBitsToText(long pRawBits);
    private static void ConvertToText(StringBuilder sb, NormalisedDecimal pnd);
    private static void FormatLessThanOne(StringBuilder sb, string decimalDigits, int decExponent, int countSigDigits);
    private static void FormatGreaterThanOne(StringBuilder sb, string decimalDigits, int decExponent, int countSigDigits);
    private static bool NeedsScientificNotation(int nDigits);
    private static int CountSignifantDigits(string sb);
    private static void AppendExp(StringBuilder sb, int val);
}
public class NPOI.SS.Util.PaneInformation : object {
    public static byte PANE_LOWER_RIGHT;
    public static byte PANE_UPPER_RIGHT;
    public static byte PANE_LOWER_LEFT;
    public static byte PANE_UPPER_LEFT;
    private short x;
    private short y;
    private short topRow;
    private short leftColumn;
    private byte activePane;
    private bool frozen;
    public short VerticalSplitPosition { get; }
    public short HorizontalSplitPosition { get; }
    public short HorizontalSplitTopRow { get; }
    public short VerticalSplitLeftColumn { get; }
    public byte ActivePane { get; }
    public PaneInformation(short x, short y, short top, short left, byte active, bool frozen);
    public short get_VerticalSplitPosition();
    public short get_HorizontalSplitPosition();
    public short get_HorizontalSplitTopRow();
    public short get_VerticalSplitLeftColumn();
    public byte get_ActivePane();
    public bool IsFreezePane();
}
public class NPOI.SS.Util.PhoneFormat : FormatBase {
    public static FormatBase Instance;
    private static string df;
    private static PhoneFormat();
    public virtual string Format(object obj, CultureInfo culture);
    protected virtual StringBuilder Format(object obj, StringBuilder toAppendTo, int pos);
    public virtual StringBuilder Format(object obj, StringBuilder toAppendTo, CultureInfo culture);
    public virtual object ParseObject(string source, int pos);
}
public class NPOI.SS.Util.PropertyTemplate : object {
    private Dictionary`2<CellAddress, Dictionary`2<string, object>> _propertyTemplate;
    private Dictionary`2<CellAddress, Dictionary`2<string, object>> Template { get; }
    public PropertyTemplate(PropertyTemplate template);
    private Dictionary`2<CellAddress, Dictionary`2<string, object>> get_Template();
    private static Dictionary`2<string, object> cloneCellProperties(Dictionary`2<string, object> properties);
    public void DrawBorders(CellRangeAddress range, BorderStyle borderType, BorderExtent extent);
    public void DrawBorders(CellRangeAddress range, BorderStyle borderType, short color, BorderExtent extent);
    private void DrawTopBorder(CellRangeAddress range, BorderStyle borderType);
    private void DrawBottomBorder(CellRangeAddress range, BorderStyle borderType);
    private void DrawLeftBorder(CellRangeAddress range, BorderStyle borderType);
    private void DrawRightBorder(CellRangeAddress range, BorderStyle borderType);
    private void DrawOutsideBorders(CellRangeAddress range, BorderStyle borderType, BorderExtent extent);
    private void DrawHorizontalBorders(CellRangeAddress range, BorderStyle borderType, BorderExtent extent);
    private void DrawVerticalBorders(CellRangeAddress range, BorderStyle borderType, BorderExtent extent);
    private void removeBorders(CellRangeAddress range);
    public void applyBorders(ISheet sheet);
    public void DrawBorderColors(CellRangeAddress range, short color, BorderExtent extent);
    private void DrawTopBorderColor(CellRangeAddress range, short color);
    private void DrawBottomBorderColor(CellRangeAddress range, short color);
    private void DrawLeftBorderColor(CellRangeAddress range, short color);
    private void DrawRightBorderColor(CellRangeAddress range, short color);
    private void DrawOutsideBorderColors(CellRangeAddress range, short color, BorderExtent extent);
    private void DrawHorizontalBorderColors(CellRangeAddress range, short color, BorderExtent extent);
    private void DrawVerticalBorderColors(CellRangeAddress range, short color, BorderExtent extent);
    private void removeBorderColors(CellRangeAddress range);
    private void addProperty(int row, int col, string property, short value);
    private void AddProperty(int row, int col, string property, object value);
    private void removeProperties(int row, int col, HashSet`1<string> properties);
    public int GetNumBorders(CellAddress cell);
    public int GetNumBorders(int row, int col);
    public int GetNumBorderColors(CellAddress cell);
    public int GetNumBorderColors(int row, int col);
    public BorderStyle GetBorderStyle(CellAddress cell, string property);
    public BorderStyle GetBorderStyle(int row, int col, string property);
    public short GetTemplateProperty(CellAddress cell, string property);
    public short GetTemplateProperty(int row, int col, string property);
    private static short Getshort(object value);
}
public class NPOI.SS.Util.RegionUtil : object {
    [ObsoleteAttribute("use SetBorderLeft(BorderStyle, CellRangeAddress, ISheet) instead")]
public static void SetBorderLeft(int border, CellRangeAddress region, ISheet sheet);
    public static void SetBorderLeft(BorderStyle border, CellRangeAddress region, ISheet sheet);
    public static void SetLeftBorderColor(int color, CellRangeAddress region, ISheet sheet);
    [ObsoleteAttribute("use SetBorderRight(BorderStyle, CellRangeAddress, ISheet) instead")]
public static void SetBorderRight(int border, CellRangeAddress region, ISheet sheet);
    public static void SetBorderRight(BorderStyle border, CellRangeAddress region, ISheet sheet);
    public static void SetRightBorderColor(int color, CellRangeAddress region, ISheet sheet);
    [ObsoleteAttribute("use SetBorderBottom(BorderStyle, CellRangeAddress, ISheet) instead")]
public static void SetBorderBottom(int border, CellRangeAddress region, ISheet sheet);
    public static void SetBorderBottom(BorderStyle border, CellRangeAddress region, ISheet sheet);
    public static void SetBottomBorderColor(int color, CellRangeAddress region, ISheet sheet);
    [ObsoleteAttribute("use SetBorderTop(BorderStyle, CellRangeAddress, ISheet) instead")]
public static void SetBorderTop(int border, CellRangeAddress region, ISheet sheet);
    public static void SetBorderTop(BorderStyle border, CellRangeAddress region, ISheet sheet);
    public static void SetTopBorderColor(int color, CellRangeAddress region, ISheet sheet);
}
public class NPOI.SS.Util.SheetBuilder : object {
    private IWorkbook workbook;
    private Object[][] cells;
    private bool shouldCreateEmptyCells;
    private string sheetName;
    public SheetBuilder(IWorkbook workbook, Object[][] cells);
    public bool GetCreateEmptyCells();
    public SheetBuilder SetCreateEmptyCells(bool shouldCreateEmptyCells);
    public SheetBuilder SetSheetName(string sheetName);
    public ISheet Build();
    private void SetCellValue(ICell cell, object value);
    private bool IsFormulaDefinition(object obj);
    private string GetFormula(object obj);
}
public class NPOI.SS.Util.SheetUtil : object {
    private static char defaultChar;
    private static int dpi;
    private static IFormulaEvaluator dummyEvaluator;
    private static CultureInfo StartupCulture;
    private static ConcurrentDictionary`2<FontCacheKey, Font> FontCache;
    private static SheetUtil();
    public static IRow CopyRow(ISheet sourceSheet, int sourceRowIndex, ISheet targetSheet, int targetRowIndex);
    public static IRow CopyRow(ISheet sheet, int sourceRowIndex, int targetRowIndex);
    public static double GetRowHeight(IRow row, bool useMergedCells, int firstColumnIdx, int lastColumnIdx);
    public static double GetRowHeight(ISheet sheet, int rowIdx, bool useMergedCells, int firstColumnIdx, int lastColumnIdx);
    public static double GetRowHeight(IRow row, bool useMergedCells);
    public static double GetRowHeight(ISheet sheet, int rowIdx, bool useMergedCells);
    public static double GetCellHeight(ICell cell, bool useMergedCells);
    private static ICell GetFirstCellFromMergedRegion(ICell cell);
    private static double GetActualHeight(ICell cell);
    private static int GetNumberOfRowsInMergedRegion(ICell cell);
    private static double GetCellConetntHeight(double actualHeight, int numberOfRowsInMergedRegion);
    private static string GetCellStringValue(ICell cell);
    private static Font GetWindowsFont(ICell cell);
    private static double GetRotatedContentHeight(ICell cell, string stringValue, Font windowsFont);
    private static double GetContentHeight(string stringValue, Font windowsFont);
    public static double GetCellWidth(ICell cell, int defaultCharWidth, DataFormatter formatter, bool useMergedCells);
    private static double GetCellWidth(int defaultCharWidth, int colspan, ICellStyle style, double width, string str, Font windowsFont, ICell cell);
    public static double GetColumnWidth(ISheet sheet, int column, bool useMergedCells);
    public static double GetColumnWidth(ISheet sheet, int column, bool useMergedCells, int firstRow, int lastRow, int maxRows);
    public static int GetDefaultCharWidth(IWorkbook wb);
    private static double GetColumnWidthForRow(IRow row, int column, int defaultCharWidth, DataFormatter formatter, bool useMergedCells);
    public static bool CanComputeColumnWidth(IFont font);
    public static Font IFont2Font(IFont font1);
    private static Font IFont2FontImpl(FontCacheKey cacheKey);
    [ObsoleteAttribute("deprecated 3.15 beta 2. Use {@link CellRangeAddressBase#isInRange(int, int)}.")]
public static bool ContainsCell(CellRangeAddress cr, int rowIx, int colIx);
    public static string GetUniqueSheetName(IWorkbook wb, string srcName);
    public static ICell GetCellWithMerges(ISheet sheet, int rowIx, int colIx);
}
public class NPOI.SS.Util.SimpleDateFormat : DateFormat {
    private string _pattern;
    private DateTimeFormatInfo _formatData;
    private CultureInfo _culture;
    public string Pattern { get; }
    public SimpleDateFormat(string pattern, CultureInfo culture);
    public SimpleDateFormat(string pattern, DateTimeFormatInfo formatSymbols);
    public SimpleDateFormat(string pattern);
    public string get_Pattern();
    public virtual string Format(object obj);
    public virtual string Format(object obj, CultureInfo culture);
    public virtual StringBuilder Format(object obj, StringBuilder toAppendTo, CultureInfo culture);
    public virtual object ParseObject(string source, int pos);
    public DateTime Parse(string source);
}
public class NPOI.SS.Util.SSCellRange`1 : object {
    private int _height;
    private int _width;
    private K[] _flattenedArray;
    private int _firstRow;
    private int _firstColumn;
    public K TopLeftCell { get; }
    public K[] FlattenedCells { get; }
    public K[][] Cells { get; }
    public int Height { get; }
    public int Width { get; }
    public int Size { get; }
    public string ReferenceText { get; }
    private SSCellRange`1(int firstRow, int firstColumn, int height, int width, K[] flattenedArray);
    public static SSCellRange`1<K> Create(int firstRow, int firstColumn, int height, int width, List`1<K> flattenedList, Type cellClass);
    public sealed virtual K GetCell(int relativeRowIndex, int relativeColumnIndex);
    public sealed virtual K get_TopLeftCell();
    public sealed virtual K[] get_FlattenedCells();
    public sealed virtual K[][] get_Cells();
    public sealed virtual int get_Height();
    public sealed virtual int get_Width();
    public sealed virtual int get_Size();
    public sealed virtual string get_ReferenceText();
    public sealed virtual IEnumerator`1<K> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NPOI.SS.Util.SSNFormat : FormatBase {
    public static FormatBase Instance;
    private static string df;
    private static SSNFormat();
    public virtual string Format(object obj, CultureInfo culture);
    protected virtual StringBuilder Format(object obj, StringBuilder toAppendTo, int pos);
    public virtual StringBuilder Format(object obj, StringBuilder toAppendTo, CultureInfo culture);
    public virtual object ParseObject(string source, int pos);
}
public class NPOI.SS.Util.WorkbookUtil : object {
    public static string CreateSafeSheetName(string nameProposal);
    public static string CreateSafeSheetName(string nameProposal, char replaceChar);
    public static void ValidateSheetName(string sheetName);
    public static void ValidateSheetState(SheetState state);
}
public class NPOI.SS.Util.ZipPlusFourFormat : FormatBase {
    public static FormatBase Instance;
    private static string df;
    private static ZipPlusFourFormat();
    public virtual string Format(object obj, CultureInfo culture);
    protected virtual StringBuilder Format(object obj, StringBuilder toAppendTo, int pos);
    public virtual StringBuilder Format(object obj, StringBuilder toAppendTo, CultureInfo culture);
    public virtual object ParseObject(string source, int pos);
}
public abstract class NPOI.UnsupportedFileFormatException : ArgumentException {
    public UnsupportedFileFormatException(string s);
}
[ExtensionAttribute]
public static class NPOI.Util.ArrayExtensions.ArrayExtensions : object {
    [ExtensionAttribute]
public static void ForEach(Array array, Action`2<Array, Int32[]> action);
}
internal class NPOI.Util.ArrayExtensions.ArrayTraverse : object {
    public Int32[] Position;
    private Int32[] maxLengths;
    public ArrayTraverse(Array array);
    public bool Step();
}
public class NPOI.Util.Arrays : object {
    public static void Fill(Byte[] array, byte defaultValue);
    public static void Fill(Char[] array, char defaultValue);
    public static void Fill(T[] array, T defaultValue);
    public static void Fill(Byte[] a, int fromIndex, int toIndex, byte val);
    public static void Fill(Char[] a, int fromIndex, int toIndex, char val);
    private static void RangeCheck(int length, int fromIndex, int toIndex);
    public static ArrayList AsList(Array arr);
    public static ArrayList AsArrayList(T[] arr);
    public static List`1<T> AsList(T[] arr);
    public static void Fill(Int32[] array, byte defaultValue);
    public static bool Equals(object a1, object b1);
    public static bool Equals(Object[] a, Object[] a2);
    public static void ArrayMoveWithin(Object[] array, int moveFrom, int moveTo, int numToMove);
    public static Byte[] CopyOf(Byte[] source, int newLength);
    internal static Int32[] CopyOfRange(Int32[] original, int from, int to);
    internal static Byte[] CopyOfRange(Byte[] original, int from, int to);
    public static int HashCode(Int64[] a);
    public static int HashCode(Int32[] a);
    public static int HashCode(Int16[] a);
    public static int HashCode(Char[] a);
    public static int HashCode(Byte[] a);
    public static int HashCode(Boolean[] a);
    public static int HashCode(Single[] a);
    public static int HashCode(Double[] a);
    public static int HashCode(Object[] a);
    public static int DeepHashCode(Object[] a);
    public static bool DeepEquals(Object[] a1, Object[] a2);
    private static bool DeepEquals0(object e1, object e2);
    public static string ToString(Int64[] a);
    public static string ToString(Int32[] a);
    public static string ToString(Int16[] a);
    public static string ToString(Char[] a);
    public static string ToString(Byte[] a);
    public static string ToString(Boolean[] a);
    public static string ToString(Single[] a);
    public static string ToString(Double[] a);
    public static string DeepToString(Object[] a);
    private static void DeepToString(Object[] a, StringBuilder buf, HashSet`1<Object[]> dejaVu);
    public static string ToString(Object[] a);
}
internal class NPOI.Util.AssertFailedException : ApplicationException {
    public AssertFailedException(string message);
}
public class NPOI.Util.BigInteger : object {
    private int _signum;
    internal Int32[] mag;
    [ObsoleteAttribute]
private int bitCount;
    [ObsoleteAttribute]
private int bitLength;
    [ObsoleteAttribute]
private int firstNonzeroIntNum;
    public static long LONG_MASK;
    public static long INFLATED;
    public static int Min_RADIX;
    public static int Max_RADIX;
    private static BigInteger[] posConst;
    private static BigInteger[] negConst;
    private static String[] zeros;
    public static BigInteger ZERO;
    public static BigInteger One;
    private static BigInteger Two;
    public static BigInteger TEN;
    private static int Max_CONSTANT;
    private static Int32[] digitsPerLong;
    private static BigInteger[] longRadix;
    private static Int64[] bitsPerDigit;
    private static Int32[] digitsPerInt;
    private static Int32[] intRadix;
    private static BigInteger();
    public BigInteger(Int32[] magnitude, int signum);
    public BigInteger(Byte[] val);
    public BigInteger(Int32[] val);
    public BigInteger(long val);
    public BigInteger(string val);
    public BigInteger(string val, int radix);
    private static void Init();
    private static Int32[] TrustedStripLeadingZeroInts(Int32[] val);
    private static void DestructiveMulAdd(Int32[] x, int y, int z);
    public string ToString(int radix);
    public static BigInteger ValueOf(long val);
    private static BigInteger ValueOf(Int32[] val);
    public static int BitLengthForInt(int n);
    public int BitLength();
    public int BitCount();
    public BigInteger Abs();
    public BigInteger Negate();
    public BigInteger Pow(int exponent);
    private Int32[] MultiplyToLen(Int32[] x, int xlen, Int32[] y, int ylen, Int32[] z);
    private static int mulAdd(Int32[] output, Int32[] input, int offset, int len, int k);
    private static Int32[] squareToLen(Int32[] x, int len, Int32[] z);
    public static void PrimitiveLeftShift(Int32[] a, int len, int n);
    private static int addOne(Int32[] a, int offset, int mlen, int carry);
    public int Signum();
    public Byte[] ToByteArray();
    private int intLength();
    private int signBit();
    private int signInt();
    private int GetInt(int n);
    private int FirstNonzeroIntNum();
    private static Int32[] stripLeadingZeroBytes(Byte[] a);
    private static Int32[] makePositive(Byte[] a);
    private static Int32[] makePositive(Int32[] a);
    public static int NumberOfLeadingZeros(int i);
    public static int NumberOfTrailingZeros(int i);
    public static int BitCountForInt(int i);
    public sealed virtual int CompareTo(BigInteger val);
    private int compareMagnitude(BigInteger val);
    public virtual bool Equals(object x);
    public BigInteger Min(BigInteger val);
    public BigInteger Max(BigInteger val);
    public virtual int GetHashCode();
    public int IntValue();
    public BigInteger ShiftLeft(int n);
    public long LongValue();
    public BigInteger ShiftRight(int n);
    private Int32[] Increment(Int32[] val);
    public BigInteger and(BigInteger val);
    public BigInteger Not();
    public BigInteger Or(BigInteger val);
    private BigInteger Multiply(long v);
    public BigInteger Multiply(BigInteger val);
    public BigInteger Add(BigInteger val);
    private static Int32[] add(Int32[] x, Int32[] y);
    public BigInteger Subtract(BigInteger val);
    private static Int32[] Subtract(Int32[] big, Int32[] little);
    public BigInteger Divide(BigInteger val);
    public static BigInteger op_RightShift(BigInteger bi1, int shiftVal);
    public static BigInteger op_LeftShift(BigInteger bi1, int shiftVal);
    public static BigInteger op_BitwiseAnd(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_BitwiseOr(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Multiply(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Addition(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Subtraction(BigInteger bi1, BigInteger bi2);
    public static bool op_LessThan(BigInteger bi1, BigInteger bi2);
    public static bool op_GreaterThan(BigInteger bi1, BigInteger bi2);
    public static BigInteger op_Division(BigInteger bi1, BigInteger bi2);
    public static bool op_Equality(BigInteger bi1, BigInteger bi2);
    public static bool op_Inequality(BigInteger bi1, BigInteger bi2);
}
public class NPOI.Util.BitField : object {
    private int _mask;
    private int _shift_count;
    public BitField(int mask);
    public BitField(UInt32 mask);
    public int Clear(int holder);
    public short ClearShort(short holder);
    public int GetRawValue(int holder);
    public short GetShortRawValue(short holder);
    public short GetShortValue(short holder);
    public int GetValue(int holder);
    public bool IsAllSet(int holder);
    public bool IsSet(int holder);
    public int Set(int holder);
    public int SetBoolean(int holder, bool flag);
    public short SetShort(short holder);
    public short SetShortBoolean(short holder, bool flag);
    public short SetShortValue(short holder, short value);
    public int SetValue(int holder, int value);
    public byte SetByteBoolean(byte holder, bool flag);
    public byte ClearByte(byte holder);
    public byte SetByte(byte holder);
}
public class NPOI.Util.BitFieldFactory : object {
    private static Hashtable instances;
    private static BitFieldFactory();
    public static BitField GetInstance(int mask);
}
public class NPOI.Util.BoundedInputStream : ByteArrayInputStream {
    private ByteArrayInputStream in1;
    private long max;
    [CompilerGeneratedAttribute]
private bool <IsPropagateClose>k__BackingField;
    public bool IsPropagateClose { get; public set; }
    public BoundedInputStream(ByteArrayInputStream in1, long size);
    public BoundedInputStream(ByteArrayInputStream in1);
    public virtual int Read();
    public virtual int Read(Byte[] b);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Close();
    public virtual void Reset();
    public virtual void Mark(int readlimit);
    public virtual bool MarkSupported();
    [CompilerGeneratedAttribute]
public bool get_IsPropagateClose();
    [CompilerGeneratedAttribute]
public void set_IsPropagateClose(bool value);
}
public class NPOI.Util.BufferUnderflowException : RuntimeException {
}
public class NPOI.Util.BufferUnderrunException : IOException {
}
public class NPOI.Util.ByteArrayInputStream : InputStream {
    protected Byte[] buf;
    protected int pos;
    protected int mark;
    protected int count;
    private object _lockObject;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ByteArrayInputStream(Byte[] buf);
    public ByteArrayInputStream(Byte[] buf, int offset, int length);
    public virtual int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public virtual int Available();
    public virtual bool MarkSupported();
    public virtual void Mark(int readlimit);
    public virtual void Reset();
    public virtual void Close();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
public class NPOI.Util.ByteArrayOutputStream : MemoryStream {
    public ByteArrayOutputStream(int size);
    public virtual void Write(int b);
    public virtual void Write(Byte[] b);
    public void Reset();
    public Byte[] ToByteArray();
    public string ToString(string encoding);
}
[DefaultMemberAttribute("Item")]
public class NPOI.Util.ByteBuffer : object {
    private Byte[] buffer;
    private int mark;
    private int position;
    private int limit;
    private int capacity;
    private int offset;
    public int Position { get; public set; }
    public int Limit { get; public set; }
    public byte Item { get; public set; }
    public int Remain { get; }
    public Byte[] Buffer { get; }
    public int Offset { get; }
    public bool HasBuffer { get; }
    public int Length { get; }
    private ByteBuffer(int mark, int pos, int lim, int cap, Byte[] buffer, int offset);
    public ByteBuffer(Byte[] buffer, int off, int len);
    public ByteBuffer(int capacity, int limit);
    protected ByteBuffer(Byte[] buffer, int mark, int pos, int lim, int cap, int off);
    public int get_Position();
    public void set_Position(int value);
    public int get_Limit();
    public void set_Limit(int value);
    public int Remaining();
    public bool HasRemaining();
    public static ByteBuffer CreateBuffer(int capacity);
    public static ByteBuffer CreateBuffer(Byte[] buffer, int offset, int length);
    public static ByteBuffer CreateBuffer(Byte[] buffer);
    public ByteBuffer Slice();
    public ByteBuffer Duplicate();
    protected int NextGetIndex();
    protected int NextGetIndex(int nb);
    protected int NextPutIndex();
    protected int NextPutIndex(int nb);
    protected int Index(int i);
    protected int CheckIndex(int i);
    protected int CheckIndex(int i, int nb);
    public byte Read();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    protected void CheckBounds(int off, int len, int size);
    public ByteBuffer Read(Byte[] buf);
    public ByteBuffer Read(Byte[] dst, int offset, int length);
    public ByteBuffer Write(byte x);
    public ByteBuffer Write(Byte[] src, int offset, int length);
    public ByteBuffer Write(ByteBuffer src);
    public ByteBuffer Write(Byte[] data);
    public int get_Remain();
    public Byte[] get_Buffer();
    public int get_Offset();
    public bool get_HasBuffer();
    public int get_Length();
}
public class NPOI.Util.ByteField : object {
    private static byte _default_value;
    private int _offset;
    private byte _value;
    public byte Value { get; public set; }
    public ByteField(int offset);
    public ByteField(int offset, byte value);
    public ByteField(int offset, Byte[] data);
    public ByteField(int offset, byte _value, Byte[] data);
    public virtual byte get_Value();
    public virtual void set_Value(byte value);
    public virtual void ReadFromBytes(Byte[] data);
    public virtual void ReadFromStream(Stream stream);
    public virtual void Set(byte value, Byte[] data);
    public virtual string ToString();
    public virtual void WriteToBytes(Byte[] data);
}
public class NPOI.Util.Character : object {
    public static int GetNumericValue(char src);
    public static bool isWhitespace(char src);
}
public class NPOI.Util.ClassID : object {
    public static ClassID OLE10_PACKAGE;
    public static ClassID PPT_SHOW;
    public static ClassID XLS_WORKBOOK;
    public static ClassID TXT_ONLY;
    public static ClassID EXCEL97;
    public static ClassID EXCEL95;
    public static ClassID WORD97;
    public static ClassID WORD95;
    public static ClassID POWERPOINT97;
    public static ClassID POWERPOINT95;
    public static ClassID EQUATION30;
    protected Byte[] bytes;
    public static int LENGTH;
    public int Length { get; }
    public Byte[] Bytes { get; public set; }
    public ClassID(Byte[] src, int offset);
    public ClassID(string externalForm);
    private static ClassID();
    public int get_Length();
    public Byte[] get_Bytes();
    public void set_Bytes(Byte[] value);
    public Byte[] Read(Byte[] src, int offset);
    public void Write(Byte[] dst, int offset);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class NPOI.Util.CloseIgnoringInputStream : Stream {
    private Stream _is;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CloseIgnoringInputStream(Stream stream);
    public int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class NPOI.Util.CodePageUtil : object {
    public static int CP_037;
    public static int CP_SJIS;
    public static int CP_GBK;
    public static int CP_MS949;
    public static int CP_UTF16;
    public static int CP_UTF16_BE;
    public static int CP_WINDOWS_1250;
    public static int CP_WINDOWS_1251;
    public static int CP_WINDOWS_1252;
    public static int CP_WINDOWS_1252_BIFF23;
    public static int CP_WINDOWS_1253;
    public static int CP_WINDOWS_1254;
    public static int CP_WINDOWS_1255;
    public static int CP_WINDOWS_1256;
    public static int CP_WINDOWS_1257;
    public static int CP_WINDOWS_1258;
    public static int CP_JOHAB;
    public static int CP_MAC_ROMAN;
    public static int CP_MAC_ROMAN_BIFF23;
    public static int CP_MAC_JAPAN;
    public static int CP_MAC_CHINESE_TRADITIONAL;
    public static int CP_MAC_KOREAN;
    public static int CP_MAC_ARABIC;
    public static int CP_MAC_HEBREW;
    public static int CP_MAC_GREEK;
    public static int CP_MAC_CYRILLIC;
    public static int CP_MAC_CHINESE_SIMPLE;
    public static int CP_MAC_ROMANIA;
    public static int CP_MAC_UKRAINE;
    public static int CP_MAC_THAI;
    public static int CP_MAC_CENTRAL_EUROPE;
    public static int CP_MAC_ICELAND;
    public static int CP_MAC_TURKISH;
    public static int CP_MAC_CROATIAN;
    public static int CP_US_ACSII;
    public static int CP_KOI8_R;
    public static int CP_ISO_8859_1;
    public static int CP_ISO_8859_2;
    public static int CP_ISO_8859_3;
    public static int CP_ISO_8859_4;
    public static int CP_ISO_8859_5;
    public static int CP_ISO_8859_6;
    public static int CP_ISO_8859_7;
    public static int CP_ISO_8859_8;
    public static int CP_ISO_8859_9;
    public static int CP_ISO_2022_JP1;
    public static int CP_ISO_2022_JP2;
    public static int CP_ISO_2022_JP3;
    public static int CP_ISO_2022_KR;
    public static int CP_EUC_JP;
    public static int CP_EUC_KR;
    public static int CP_GB2312;
    public static int CP_GB18030;
    public static int CP_US_ASCII2;
    public static int CP_UTF8;
    public static int CP_UNICODE;
    private static CodePageUtil();
    public static Byte[] GetBytesInCodePage(string string1, int codepage);
    public static string GetStringFromCodePage(Byte[] string1, int codepage);
    public static string GetStringFromCodePage(Byte[] string1, int offset, int length, int codepage);
    public static string CodepageToEncoding(int codepage);
}
public class NPOI.Util.Collections.HashSet`1 : object {
    private Dictionary`2<T, object> impl;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public int Count { get; }
    public bool IsReadOnly { get; public set; }
    public sealed virtual void Add(T o);
    public sealed virtual bool Contains(T o);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    public sealed virtual bool Remove(T o);
    public sealed virtual void Clear();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class NPOI.Util.Collections.Properties : object {
    private Hashtable _col;
    private static string whiteSpaceChars;
    private static string keyValueSeparators;
    private static string strictKeyValueSeparators;
    public int Count { get; }
    public string Item { get; public set; }
    public ICollection Keys { get; }
    public string Remove(string key);
    public IEnumerator GetEnumerator();
    public bool ContainsKey(string key);
    public virtual void Add(string key, string value);
    public void AddAll(Properties col);
    public int get_Count();
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public ICollection get_Keys();
    public void Clear();
    public void Load(Stream inStream);
    private string LoadConvert(string theString);
    private bool ContinueLine(string line);
}
public class NPOI.Util.Collections.StringTokenizer : object {
    private int pos;
    private string str;
    private int len;
    private string delim;
    private bool retDelims;
    public StringTokenizer(string str);
    public StringTokenizer(string str, string delim);
    public StringTokenizer(string str, string delim, bool retDelims);
    public bool HasMoreTokens();
    public string NextToken(string delim);
    public string NextToken();
    public int CountTokens();
}
public class NPOI.Util.Coords : object {
    [CompilerGeneratedAttribute]
private long <x>k__BackingField;
    [CompilerGeneratedAttribute]
private long <y>k__BackingField;
    public long x { get; internal set; }
    public long y { get; internal set; }
    public Coords(long X, long Y);
    public Coords(Coords val);
    [CompilerGeneratedAttribute]
public long get_x();
    [CompilerGeneratedAttribute]
internal void set_x(long value);
    [CompilerGeneratedAttribute]
public long get_y();
    [CompilerGeneratedAttribute]
internal void set_y(long value);
    public void Min(Coords val);
    public void Max(Coords val);
    public void Add(Coords val);
    public void Sub(Coords val);
    public static Coords op_Addition(Coords left, Coords right);
    public static Coords op_Subtraction(Coords left, Coords right);
    public static Coords op_Multiply(Coords left, Coords right);
    public static Coords op_Multiply(Coords V, double Constant);
    public double InnerProduct(Coords Coords);
    public long Norm();
}
public class NPOI.Util.CRC32 : object {
    protected UInt64[] crc32Table;
    [CompilerGeneratedAttribute]
private ulong <Value>k__BackingField;
    public ulong Value { get; public set; }
    public ulong ByteCRC(Byte[]& buffer);
    public ulong StringCRC(string sInputString);
    public long FileCRC(string sInputFilename);
    public long StreamCRC(Stream inFile);
    [CompilerGeneratedAttribute]
public ulong get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ulong value);
    public void Update(Byte[] data);
}
public class NPOI.Util.DblVect2D : object {
    [CompilerGeneratedAttribute]
private double <x>k__BackingField;
    [CompilerGeneratedAttribute]
private double <y>k__BackingField;
    public double x { get; internal set; }
    public double y { get; internal set; }
    public DblVect2D(double X, double Y);
    public DblVect2D(DblVect2D val);
    [CompilerGeneratedAttribute]
public double get_x();
    [CompilerGeneratedAttribute]
internal void set_x(double value);
    [CompilerGeneratedAttribute]
public double get_y();
    [CompilerGeneratedAttribute]
internal void set_y(double value);
    public void Min(DblVect2D val);
    public void Max(DblVect2D val);
    public void Add(DblVect2D val);
    public void Sub(DblVect2D val);
    public static DblVect2D op_Addition(DblVect2D left, DblVect2D right);
    public static DblVect2D op_Subtraction(DblVect2D left, DblVect2D right);
    public static DblVect2D op_Multiply(DblVect2D left, DblVect2D right);
    public static DblVect2D op_Multiply(DblVect2D V, double Constant);
    public static DblVect2D op_Division(DblVect2D V, double Constant);
    public double InnerProduct(DblVect2D vect);
    public double Norm();
    public static DblVect2D Conv(Coords val);
}
public class NPOI.Util.FileInputStream : InputStream {
    private Stream inner;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FileInputStream(Stream fs);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
}
public class NPOI.Util.FilterInputStream : InputStream {
    protected InputStream modreq(System.Runtime.CompilerServices.IsVolatile) input;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected FilterInputStream(InputStream input);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read();
    public virtual int Read(Byte[] b);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual long Skip(long n);
    public virtual int Available();
    public virtual void Close();
    public virtual void Mark(int readlimit);
    public virtual void Reset();
    public virtual bool MarkSupported();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class NPOI.Util.FilterOutputStream : OutputStream {
    protected OutputStream output;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterOutputStream(OutputStream output);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual long get_Position();
    [CompilerGeneratedAttribute]
public virtual void set_Position(long value);
    public virtual void Write(int b);
    public virtual void Write(Byte[] b);
    public virtual void Write(Byte[] b, int off, int len);
    public virtual void Flush();
    public virtual void Close();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
}
public interface NPOI.Util.FixedField {
    public abstract virtual void ReadFromBytes(Byte[] data);
    public abstract virtual void ReadFromStream(Stream stream);
    public abstract virtual string ToString();
    public abstract virtual void WriteToBytes(Byte[] data);
}
public class NPOI.Util.HexDump : object {
    private static Char[] _hexcodes;
    private static Int32[] _shifts;
    public static string EOL;
    private static Char[] DIGITS_LOWER;
    private static Char[] DIGITS_UPPER;
    private static HexDump();
    private static string Dump(byte value);
    private static string Dump(long value);
    public static string Dump(Byte[] data, long offset, int index);
    public static string Dump(Byte[] data, long offset, int index, int length);
    public static char ToAscii(int dataB);
    public static void Dump(Byte[] data, long offset, Stream stream, int index);
    public static void Dump(Stream inStream, int start, int bytesToDump);
    public static void Dump(Byte[] data, long offset, Stream stream, int index, int length);
    public static void Dump(Stream in1, Stream out1, int start, int bytesToDump);
    public static Char[] ShortToHex(int value);
    public static Char[] ByteToHex(int value);
    public static Char[] IntToHex(int value);
    public static Char[] LongToHex(long value);
    private static Char[] ToHexChars(long pValue, int nBytes);
    public static string ToHex(byte value);
    public static string ToHex(short value);
    public static string ToHex(int value);
    public static string ToHex(long value);
    public static string ToHex(Byte[] value);
    public static string ToHex(Int16[] value);
    private static string ToHex(long value, int digits);
    public static string ToHex(Byte[] value, int bytesPerLine);
    public static string EncodeHexString(Byte[] data);
    public static Char[] EncodeHex(Byte[] data);
    public static Char[] EncodeHex(Byte[] data, bool toLowerCase);
    protected static Char[] EncodeHex(Byte[] data, Char[] toDigits);
}
public class NPOI.Util.HexRead : object {
    public static Byte[] ReadData(string filename);
    public static Byte[] ReadData(Stream stream, string section);
    public static Byte[] ReadData(string filename, string section);
    public static Byte[] ReadData(Stream stream, int eofChar);
    public static Byte[] ReadFromString(string data);
    private static void ReadToEOL(Stream stream);
}
public interface NPOI.Util.ICloseable {
    public abstract virtual void Close();
}
public interface NPOI.Util.IDelayableLittleEndianOutput {
    public abstract virtual ILittleEndianOutput CreateDelayedOutput(int size);
}
public interface NPOI.Util.ILittleEndianInput {
    public abstract virtual int Available();
    public abstract virtual int ReadByte();
    public abstract virtual int ReadUByte();
    public abstract virtual short ReadShort();
    public abstract virtual int ReadUShort();
    public abstract virtual int ReadInt();
    public abstract virtual long ReadLong();
    public abstract virtual double ReadDouble();
    public abstract virtual void ReadFully(Byte[] buf);
    public abstract virtual void ReadFully(Byte[] buf, int off, int len);
}
public interface NPOI.Util.ILittleEndianOutput {
    public abstract virtual void WriteByte(int v);
    public abstract virtual void WriteShort(int v);
    public abstract virtual void WriteInt(int v);
    public abstract virtual void WriteLong(long v);
    public abstract virtual void WriteDouble(double v);
    public abstract virtual void Write(Byte[] b);
    public abstract virtual void Write(Byte[] b, int offset, int len);
}
public abstract class NPOI.Util.InputStream : Stream {
    private static int MAX_SKIP_BUFFER_SIZE;
    public bool CanWrite { get; }
    private static InputStream();
    public virtual int Read();
    public virtual int Read(Byte[] b);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual long Skip(long n);
    public virtual int Available();
    public virtual void Close();
    public virtual void Mark(int readlimit);
    public virtual void Reset();
    public virtual bool MarkSupported();
    public virtual bool get_CanWrite();
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class NPOI.Util.IntegerField : object {
    private int _value;
    private int _offset;
    public int Value { get; public set; }
    public IntegerField(int offset);
    public IntegerField(int offset, int value);
    public IntegerField(int offset, Byte[] data);
    public IntegerField(int offset, int value, Byte[] data);
    public int get_Value();
    public void set_Value(int value);
    public void Set(int value, Byte[] data);
    public sealed virtual void ReadFromBytes(Byte[] data);
    public sealed virtual void ReadFromStream(Stream stream);
    public sealed virtual void WriteToBytes(Byte[] data);
    public static void Write(int offset, int value, Byte[] data);
    public virtual string ToString();
}
public class NPOI.Util.IntList : object {
    private Int32[] _array;
    private int _limit;
    private int fillval;
    private static int _default_size;
    public int Count { get; }
    public IntList(int InitialCapacity);
    public IntList(IntList list);
    public IntList(int initialCapacity, int fillvalue);
    private static IntList();
    private void FillArray(int val, Int32[] array, int index);
    public void Add(int index, int value);
    public bool Add(int value);
    public bool AddAll(IntList c);
    public bool AddAll(int index, IntList c);
    public void Clear();
    public bool Contains(int o);
    public bool ContainsAll(IntList c);
    public virtual bool Equals(object o);
    public int Get(int index);
    public virtual int GetHashCode();
    public int IndexOf(int o);
    public bool IsEmpty();
    public int LastIndexOf(int o);
    public int Remove(int index);
    public bool RemoveValue(int o);
    public bool RemoveAll(IntList c);
    public bool RetainAll(IntList c);
    public int Set(int index, int element);
    public int Size();
    public int get_Count();
    public Int32[] ToArray();
    public Int32[] ToArray(Int32[] a);
    private void growArray(int new_size);
}
[DefaultMemberAttribute("Item")]
public class NPOI.Util.IntMapper`1 : object {
    private List`1<T> elements;
    private Dictionary`2<T, int> valueKeyMap;
    private static int _default_size;
    public int Size { get; }
    public T Item { get; }
    public IntMapper`1(int InitialCapacity);
    private static IntMapper`1();
    public bool Add(T value);
    public int get_Size();
    public T get_Item(int index);
    public int GetIndex(T o);
    public IEnumerator`1<T> GetEnumerator();
    public void Clear();
}
public class NPOI.Util.IOUtils : object {
    private static POILogger logger;
    private static int BYTE_ARRAY_MAX_OVERRIDE;
    private static int MAX_BYTE_ARRAY_INIT_SIZE;
    private static int DEFAULT_BUFFER_SIZE;
    private static IOUtils();
    public static Byte[] PeekFirst8Bytes(InputStream stream);
    public static Byte[] PeekFirst8Bytes(Stream stream);
    public static Byte[] ToByteArray(Stream stream);
    public static Byte[] ToByteArray(Stream stream, int length);
    public static Byte[] ToByteArray(ByteBuffer buffer, int length);
    public static int ReadFully(Stream stream, Byte[] b);
    public static int ReadFully(Stream stream, Byte[] b, int off, int len);
    public static void Copy(Stream inp, Stream out1);
    public static long CalculateChecksum(Byte[] data);
    public static void CloseQuietly(Stream closeable);
    public static void CloseQuietly(ICloseable closeable);
    public static Byte[] SafelyAllocate(long length, int maxLength);
    public static void SafelyAllocateCheck(long length, int maxLength);
    private static void CheckByteSizeLimit(int length);
    private static void CheckLength(long length, int maxLength);
    private static void ThrowRFE(long length, int maxLength);
    private static void ThrowRecordTruncationException(int maxLength);
}
public class NPOI.Util.LittleEndian : LittleEndianConsts {
    public static short GetShort(Byte[] data, int offset);
    public static int GetUShort(Byte[] data, int offset);
    public static short GetShort(Byte[] data);
    public static int GetUShort(Byte[] data);
    public static int GetInt(Byte[] data, int offset);
    public static int GetInt(Byte[] data);
    public static long GetUInt(Byte[] data, int offset);
    public static long GetUInt(Byte[] data);
    public static long GetLong(Byte[] data, int offset);
    public static double GetDouble(Byte[] data, int offset);
    public static void PutShort(Byte[] data, int offset, short value);
    public static void PutByte(Byte[] data, int offset, int value);
    public static void PutUByte(Byte[] data, int offset, short value);
    public static void PutUShort(Byte[] data, int offset, int value);
    public static void PutShort(Stream outputStream, short value);
    public static void PutInt(Byte[] data, int offset, int value);
    public static void PutInt(int value, Stream outputStream);
    public static void PutLong(Byte[] data, int offset, long value);
    public static void PutDouble(Byte[] data, int offset, double value);
    public static short ReadShort(Stream stream);
    public static int ReadUShort(Stream stream);
    public static int ReadInt(Stream stream);
    public static long ReadLong(Stream stream);
    public static int UByteToInt(byte b);
    public static Byte[] GetByteArray(Byte[] data, int offset, int size);
    [ObsoleteAttribute]
public static double GetDouble(Byte[] data);
    [ObsoleteAttribute]
public static long GetLong(Byte[] data);
    [ObsoleteAttribute]
public static ulong GetULong(Byte[] data);
    [ObsoleteAttribute]
public static ulong GetULong(Byte[] data, int offset);
    private static long GetNumber(Byte[] data, int offset, int size);
    public static short GetUByte(Byte[] data);
    public static short GetUByte(Byte[] data, int offset);
    [ObsoleteAttribute]
public static void PutDouble(Byte[] data, double value);
    public static void PutDouble(double value, Stream outputStream);
    public static void PutUInt(long value, Stream outputStream);
    [ObsoleteAttribute]
public static void PutUInt(Byte[] data, int offset, UInt32 value);
    public static void PutUInt(Byte[] data, int offset, long value);
    [ObsoleteAttribute]
public static void PutLong(Byte[] data, long value);
    public static void PutLong(long value, Stream outputStream);
    [ObsoleteAttribute]
public static void PutULong(Byte[] data, ulong value);
    [ObsoleteAttribute]
public static void PutULong(Byte[] data, int offset, ulong value);
    private static void PutNumber(Byte[] data, int offset, long value, int size);
    private static void PutNumber(Byte[] data, int offset, ulong value, int size);
    [ObsoleteAttribute]
public static void PutShortArray(Byte[] data, int offset, Int16[] value);
    [ObsoleteAttribute]
public static void PutUShort(Byte[] data, int value);
    public static void PutUShort(int value, Stream outputStream);
    [ObsoleteAttribute]
public static Byte[] ReadFromStream(Stream stream, int size);
    [ObsoleteAttribute]
public static ulong ReadULong(Stream stream);
}
public class NPOI.Util.LittleEndianByteArrayInputStream : object {
    private Byte[] _buf;
    private int _endIndex;
    private int _ReadIndex;
    public LittleEndianByteArrayInputStream(Byte[] buf, int startOffset, int maxReadLen);
    public LittleEndianByteArrayInputStream(Byte[] buf, int startOffset);
    public LittleEndianByteArrayInputStream(Byte[] buf);
    public sealed virtual int Available();
    private void CheckPosition(int i);
    public int GetReadIndex();
    public sealed virtual int ReadByte();
    public sealed virtual int ReadInt();
    public sealed virtual long ReadLong();
    public sealed virtual short ReadShort();
    public sealed virtual int ReadUByte();
    public sealed virtual int ReadUShort();
    public sealed virtual void ReadFully(Byte[] buf, int off, int len);
    public sealed virtual void ReadFully(Byte[] buf);
    public sealed virtual double ReadDouble();
}
public class NPOI.Util.LittleEndianByteArrayOutputStream : object {
    private Byte[] _buf;
    private int _endIndex;
    private int _writeIndex;
    public int WriteIndex { get; }
    public LittleEndianByteArrayOutputStream(Byte[] buf, int startOffset, int maxWriteLen);
    public LittleEndianByteArrayOutputStream(Byte[] buf, int startOffset);
    private void CheckPosition(int i);
    public sealed virtual void WriteByte(int v);
    public sealed virtual void WriteDouble(double v);
    public sealed virtual void WriteInt(int v);
    public sealed virtual void WriteLong(long v);
    public sealed virtual void WriteShort(int v);
    public sealed virtual void Write(Byte[] b);
    public sealed virtual void Write(Byte[] b, int offset, int len);
    public int get_WriteIndex();
    public sealed virtual ILittleEndianOutput CreateDelayedOutput(int size);
    public virtual string ToString();
}
public class NPOI.Util.LittleEndianConsts : object {
    public static int BYTE_SIZE;
    public static int SHORT_SIZE;
    public static int INT_SIZE;
    public static int DOUBLE_SIZE;
    public static int LONG_SIZE;
    [ObsoleteAttribute]
public static int UINT_SIZE;
    [ObsoleteAttribute]
public static int ULONG_SIZE;
}
public class NPOI.Util.LittleEndianInputStream : FilterInputStream {
    private int readLimit;
    private long markPos;
    public LittleEndianInputStream(Stream is1);
    public LittleEndianInputStream(InputStream is1);
    public virtual int Read(Byte[] b);
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Mark(int readlimit);
    public virtual void Reset();
    public virtual long Skip(long n);
    public virtual int Available();
    public virtual int ReadByte();
    public sealed virtual int ReadUByte();
    public sealed virtual double ReadDouble();
    public sealed virtual int ReadInt();
    public long ReadUInt();
    public sealed virtual long ReadLong();
    public sealed virtual short ReadShort();
    public sealed virtual int ReadUShort();
    private static void CheckEOF(int value);
    public sealed virtual void ReadFully(Byte[] buf);
    public sealed virtual void ReadFully(Byte[] buf, int off, int len);
}
public class NPOI.Util.LittleEndianOutputStream : object {
    protected internal Stream out1;
    public LittleEndianOutputStream(Stream out1);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Close();
    public sealed virtual void WriteByte(int v);
    public sealed virtual void WriteDouble(double v);
    public sealed virtual void WriteInt(int v);
    public sealed virtual void WriteLong(long v);
    public sealed virtual void WriteShort(int v);
    public sealed virtual void Write(Byte[] b);
    public sealed virtual void Write(Byte[] b, int off, int len);
    public void Flush();
}
public class NPOI.Util.LocaleUtil : object {
    public static TimeZoneInfo TIMEZONE_UTC;
    public static string CHARSET_1252;
    [ThreadStaticAttribute]
private static TimeZoneInfo userTimeZone;
    [ThreadStaticAttribute]
private static CultureInfo userLocale;
    private static LocaleUtil();
    public static void SetUserTimeZone(TimeZoneInfo timezone);
    public static TimeZoneInfo GetUserTimeZoneInfo();
    public static void SetUserLocale(CultureInfo locale);
    public static CultureInfo GetUserLocale();
    public static DateTime GetLocaleCalendar();
    public static DateTime GetLocaleCalendar(int year, int month, int day);
    public static DateTime GetLocaleCalendar(int year, int month, int day, int hour, int minute, int second);
    public static DateTime GetLocaleCalendar(TimeZoneInfo timeZone);
    [ObsoleteAttribute("The class TimeZone was marked obsolete, Use the Overload using TimeZoneInfo instead.")]
public static DateTime GetLocaleCalendar(TimeZone timeZone);
}
public class NPOI.Util.LongField : object {
    private long _value;
    private int _offset;
    public long Value { get; public set; }
    public LongField(int offset);
    public LongField(int offset, long value);
    public LongField(int offset, Byte[] data);
    public LongField(int offset, long value, Byte[] data);
    public long get_Value();
    public void set_Value(long value);
    public void Set(long value, Byte[] data);
    public void ReadFromBytes(Byte[] data);
    public void ReadFromStream(Stream stream);
    public void WriteToBytes(Byte[] data);
    public static void Write(int offset, long value, Byte[] data);
    public virtual string ToString();
}
public abstract class NPOI.Util.LZWDecompresser : object {
    private bool maskMeansCompressed;
    private int codeLengthIncrease;
    private bool positionIsBigEndian;
    protected LZWDecompresser(bool maskMeansCompressed, int codeLengthIncrease, bool positionIsBigEndian);
    protected abstract virtual int populateDictionary(Byte[] dict);
    protected abstract virtual int adjustDictionaryOffset(int offset);
    public Byte[] decompress(Stream src);
    public void decompress(Stream src, Stream res);
    public static byte fromInt(int b);
    public static int fromByte(byte b);
}
internal class NPOI.Util.MutableBigInteger : object {
    private Int32[] _value;
    private int intLen;
    private int offset;
    private static MutableBigInteger One;
    private static long LONG_MASK;
    private static long INFLATED;
    public MutableBigInteger(int val);
    public MutableBigInteger(Int32[] val);
    private MutableBigInteger(BigInteger b);
    private MutableBigInteger(MutableBigInteger val);
    private static MutableBigInteger();
    public static Int32[] ArraysCopyOf(Int32[] original, int newLength);
    public static Int64[] ArraysCopyOf(Int64[] original, int newLength);
    public static Int32[] ArraysCopyOfRange(Int32[] original, int from, int to);
    public static Int64[] ArraysCopyOfRange(Int64[] original, int from, int to);
    private Int32[] getMagnitudeArray();
    private long toLong();
    public BigInteger toBigInteger(int sign);
    private void clear();
    private void reset();
    private int compare(MutableBigInteger b);
    private int compareHalf(MutableBigInteger b);
    private int getLowestSetBit();
    private int getInt(int index);
    private long getLong(int index);
    private void normalize();
    private void ensureCapacity(int len);
    private Int32[] toIntArray();
    private void setInt(int index, int val);
    private void setValue(Int32[] val, int length);
    private void copyValue(MutableBigInteger src);
    private void copyValue(Int32[] val);
    private bool isOne();
    private bool isZero();
    private bool isEven();
    private bool isOdd();
    private bool isNormal();
    public string toString();
    private void rightShift(int n);
    private void leftShift(int n);
    private int divadd(Int32[] a, Int32[] result, int offset);
    private int mulsub(Int32[] q, Int32[] a, int x, int len, int offset);
    private void primitiveRightShift(int n);
    private void primitiveLeftShift(int n);
    private void add(MutableBigInteger addend);
    private int subtract(MutableBigInteger b);
    private int difference(MutableBigInteger b);
    private void multiply(MutableBigInteger y, MutableBigInteger z);
    public void mul(int y, MutableBigInteger z);
    public int divideOneWord(int divisor, MutableBigInteger quotient);
    public MutableBigInteger divide(MutableBigInteger b, MutableBigInteger quotient);
    public long divide(long v, MutableBigInteger quotient);
    private MutableBigInteger divideMagnitude(Int32[] divisor, MutableBigInteger quotient);
    private bool unsignedLongCompare(long one, long two);
    private void divWord(Int32[] result, long n, int d);
    private MutableBigInteger hybridGCD(MutableBigInteger b);
    private MutableBigInteger binaryGCD(MutableBigInteger v);
    private static int binaryGcd(int a, int b);
    private MutableBigInteger mutableModInverse(MutableBigInteger p);
    private MutableBigInteger modInverseMP2(int k);
    private static int inverseMod32(int val);
    private static MutableBigInteger modInverseBP2(MutableBigInteger mod, int k);
    private MutableBigInteger modInverse(MutableBigInteger mod);
    private static MutableBigInteger fixup(MutableBigInteger c, MutableBigInteger p, int k);
    private MutableBigInteger euclidModInverse(int k);
}
public class NPOI.Util.NullLogger : POILogger {
    public virtual void Initialize(string cat);
    public virtual void Log(int level, object obj1);
    public virtual bool Check(int level);
    public virtual void Log(int level, object obj1, object obj2);
    public virtual void Log(int level, object obj1, object obj2, object obj3);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8);
    public virtual void Log(int level, object obj1, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8, Exception exception);
}
public class NPOI.Util.Number : object {
    private static Type BoolType;
    private static Type CharType;
    private static Type IntPtrType;
    private static Type UIntPtrType;
    private static Type DecimalType;
    private static Number();
    public static int BitCount(int i);
    public static bool IsNumber(object value);
    public static bool IsInteger(object value);
}
[ExtensionAttribute]
public static class NPOI.Util.ObjectExtensions : object {
    private static MethodInfo CloneMethod;
    private static ObjectExtensions();
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static object Copy(object originalObject);
    private static object InternalCopy(object originalObject, IDictionary`2<object, object> visited);
    private static void RecursiveCopyBaseTypePrivateFields(object originalObject, IDictionary`2<object, object> visited, object cloneObject, Type typeToReflect);
    private static void CopyFields(object originalObject, IDictionary`2<object, object> visited, object cloneObject, Type typeToReflect, BindingFlags bindingFlags, Func`2<FieldInfo, bool> filter);
    [ExtensionAttribute]
public static T Copy(T original);
}
public static class NPOI.Util.Operator : object {
    public static int UnsignedRightShift(int operand, int val);
    public static long UnsignedRightShift(long operand, int val);
    public static short UnsignedRightShift(short operand, int val);
    public static sbyte UnsignedRightShift(sbyte operand, int val);
}
public abstract class NPOI.Util.OutputStream : Stream {
    public abstract virtual void Write(int b);
    public virtual void Write(Byte[] b);
    public virtual void Write(Byte[] b, int off, int len);
}
public class NPOI.Util.PngUtils : object {
    private static Byte[] PNG_FILE_HEADER;
    private static PngUtils();
    public static bool MatchesPngHeader(Byte[] data, int offset);
}
public class NPOI.Util.POILogFactory : object {
    private static Hashtable _loggers;
    private static POILogger _nullLogger;
    private static string _loggerClassName;
    private static POILogFactory();
    public static POILogger GetLogger(Type type);
    public static POILogger GetLogger(string cat);
}
public abstract class NPOI.Util.POILogger : object {
    public static int DEBUG;
    public static int INFO;
    public static int WARN;
    public static int ERROR;
    public static int FATAL;
    public abstract virtual void Initialize(string cat);
    public abstract virtual void Log(int level, object obj1);
    public abstract virtual void Log(int level, object obj1, Exception exception);
    public abstract virtual bool Check(int level);
    public virtual void Log(int level, object obj1, object obj2);
    public virtual void Log(int level, object obj1, object obj2, object obj3);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8);
    public virtual void Log(int level, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, Exception exception);
    public virtual void Log(int level, object obj1, object obj2, object obj3, object obj4, object obj5, object obj6, object obj7, object obj8, Exception exception);
}
public class NPOI.Util.POIUtils : object {
    public static Rgb24 Color_Empty;
    private static POIUtils();
    public static void CopyNodeRecursively(Entry entry, DirectoryEntry target);
    public static void CopyNodes(DirectoryEntry sourceRoot, DirectoryEntry targetRoot, List`1<string> excepts);
    public static void CopyNodes(POIFSFileSystem source, POIFSFileSystem target, List`1<string> excepts);
}
public class NPOI.Util.PushbackInputStream : FilterInputStream {
    protected Byte[] buf;
    private int bufint;
    protected int pos;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PushbackInputStream(InputStream input);
    public PushbackInputStream(InputStream input, int size);
    protected virtual void Dispose(bool disposing);
    public virtual int ReadByte();
    public virtual int Read();
    public virtual int Read(Byte[] b, int off, int len);
    public virtual void Unread(int b);
    public void Unread(Byte[] b);
    public virtual int Available();
    public virtual bool get_CanRead();
    private void ensureOpen();
    public void Unread(Byte[] b, int off, int len);
    public virtual long Skip(long n);
    public virtual bool MarkSupported();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class NPOI.Util.PushbackStream : Stream {
    private int buf;
    private Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public PushbackStream(Stream s);
    protected virtual void Dispose(bool disposing);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Unread(int b);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
public class NPOI.Util.RecordFormatException : RuntimeException {
    public RecordFormatException(string exception);
    public RecordFormatException(string exception, Exception ex);
    public RecordFormatException(Exception ex);
}
public static class NPOI.Util.RecyclableMemory : object {
    private static RecyclableMemoryStreamManager _memoryManager;
    private static bool _dataInitialized;
    private static object _dataLock;
    private static RecyclableMemoryStreamManager MemoryManager { get; }
    private static RecyclableMemory();
    private static RecyclableMemoryStreamManager get_MemoryManager();
    public static void SetRecyclableMemoryStreamManager(RecyclableMemoryStreamManager recyclableMemoryStreamManager);
    public static MemoryStream GetStream();
    public static MemoryStream GetStream(Byte[] array);
    public static MemoryStream GetStream(int capacity);
}
public class NPOI.Util.ReferenceEqualityComparer : EqualityComparer`1<object> {
    public virtual bool Equals(object x, object y);
    public virtual int GetHashCode(object obj);
}
public class NPOI.Util.RLEDecompressingInputStream : InputStream {
    private static Int32[] POWER2;
    private Stream input;
    private Byte[] buf;
    private int pos;
    private int len;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public RLEDecompressingInputStream(Stream input);
    private static RLEDecompressingInputStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read();
    public virtual int Read(Byte[] b);
    public virtual int Read(Byte[] b, int off, int l);
    public virtual long Skip(long n);
    public virtual int Available();
    public virtual void Close();
    private int ReadChunk();
    private static int GetCopyLenBits(int offset);
    public int ReadShort();
    public int ReadInt();
    private int ReadShort(Stream stream);
    private int ReadInt(InputStream stream);
    public static Byte[] Decompress(Byte[] compressed);
    public static Byte[] Decompress(Byte[] compressed, int offset, int length);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class NPOI.Util.RuntimeException : Exception {
    public RuntimeException(string message);
    public RuntimeException(Exception e);
    public RuntimeException(string exception, Exception ex);
}
public class NPOI.Util.ShortField : object {
    private short _value;
    private int _offset;
    public short Value { get; public set; }
    public ShortField(int offset);
    public ShortField(int offset, short value);
    public ShortField(int offset, Byte[] data);
    public ShortField(int offset, short value, Byte[]& data);
    public short get_Value();
    public void set_Value(short value);
    public void Set(short value, Byte[]& data);
    public void ReadFromBytes(Byte[] data);
    public void ReadFromStream(Stream stream);
    public void WriteToBytes(Byte[] data);
    public static void Write(int offset, short value, Byte[]& data);
    public virtual string ToString();
}
public class NPOI.Util.ShortList : object {
    private Int16[] _array;
    private int _limit;
    private static int _default_size;
    public int Count { get; }
    public ShortList(ShortList list);
    public ShortList(int InitialCapacity);
    private static ShortList();
    public void Add(int index, short value);
    public bool Add(short value);
    public bool AddAll(ShortList c);
    public bool AddAll(int index, ShortList c);
    public void Clear();
    public bool Contains(short o);
    public bool ContainsAll(ShortList c);
    public virtual bool Equals(object o);
    public short Get(int index);
    public virtual int GetHashCode();
    public int IndexOf(short o);
    public bool IsEmpty();
    public int LastIndexOf(short o);
    public short Remove(int index);
    public bool RemoveValue(short o);
    public bool RemoveAll(ShortList c);
    public bool RetainAll(ShortList c);
    public short Set(int index, short element);
    public int Size();
    public int get_Count();
    public Int16[] ToArray();
    public Int16[] ToArray(Int16[] a);
    private void GrowArray(int new_size);
}
public class NPOI.Util.StringUtil : object {
    private static Encoding ISO_8859_1;
    private static Encoding UTF16LE;
    private static Dictionary`2<int, int> msCodepointToUnicode;
    public static char MIN_HIGH_SURROGATE;
    public static char MAX_HIGH_SURROGATE;
    public static char MIN_LOW_SURROGATE;
    public static char MAX_LOW_SURROGATE;
    public static int MIN_SUPPLEMENTARY_CODE_POINT;
    private static Int32[] symbolMap_f020;
    private static Int32[] symbolMap_f0a0;
    private static StringUtil();
    public static string GetFromUnicodeLE(Byte[] str, int offset, int len);
    public static string GetFromUnicodeLE(Byte[] str);
    public static Byte[] GetToUnicodeLE(string string1);
    public static string GetFromUnicodeBE(Byte[] str, int offset, int len);
    public static string GetFromUnicodeBE(Byte[] str);
    public static string GetFromCompressedUnicode(Byte[] str, int offset, int len);
    public static void PutCompressedUnicode(string input, Byte[] output, int offset);
    public static void PutCompressedUnicode(string input, ILittleEndianOutput out1);
    public static void PutUnicodeLE(string input, Byte[] output, int offset);
    public static void PutUnicodeLE(string input, ILittleEndianOutput out1);
    public static void PutUnicodeBE(string input, Byte[] output, int offset);
    public static string GetPreferredEncoding();
    public static bool HasMultibyte(string value);
    public static string ReadCompressedUnicode(ILittleEndianInput in1, int nChars);
    public static string ReadUnicodeLE(ILittleEndianInput in1, int nChars);
    public static string ReadUnicodeString(ILittleEndianInput in1);
    public static string ReadUnicodeString(ILittleEndianInput in1, int nChars);
    public static void WriteUnicodeString(ILittleEndianOutput out1, string value);
    public static void WriteUnicodeStringFlagAndData(ILittleEndianOutput out1, string value);
    public static int GetEncodedSize(string value);
    public static bool IsUnicodeString(string value);
    public static string ToHexString(string s);
    public static string ToHexString(char chr);
    public static string ToHexString(short chr);
    public static string ToHexString(int chr);
    public static string ToHexString(long chr);
    private static bool NeedToEncode(char chr);
    public static string MapMsCodepointString(string string1);
    public static int toCodePoint(char high, char low);
    private static int codePointAt(Char[] a, int index, int limit);
    public static int CharCount(int codePoint);
    public static void mapMsCodepoint(int msCodepoint, int unicodeCodepoint);
    private static void InitMsCodepointMap();
    public static string Join(Object[] array, string separator);
    public static string Join(string separator, Object[] array);
    public static int CountMatches(string haystack, char needle);
}
public class NPOI.Util.SystemOutLogger : POILogger {
    private string _cat;
    public virtual void Initialize(string cat);
    public virtual void Log(int level, object obj1);
    public virtual void Log(int level, object obj1, Exception exception);
    public virtual bool Check(int level);
}
public class NPOI.Util.TempFile : object {
    private static string dir;
    public static FileInfo CreateTempFile(string prefix, string suffix);
    public static string GetTempFilePath(string prefix, string suffix);
}
public static class NPOI.Util.TimeUtil : object {
    public static long CurrentMillis();
}
[ObsoleteAttribute]
public class NPOI.Util.ULongField : object {
    private ulong _value;
    private int _offset;
    public ulong Value { get; public set; }
    public ULongField(int offset);
    public ULongField(int offset, ulong value);
    public ULongField(int offset, Byte[] data);
    public ULongField(int offset, ulong value, Byte[] data);
    public ulong get_Value();
    public void set_Value(ulong value);
    public void Set(ulong value, Byte[] data);
    public void ReadFromBytes(Byte[] data);
    public void ReadFromStream(Stream stream);
    public void WriteToBytes(Byte[] data);
    public virtual string ToString();
}
public class NPOI.Util.Units : object {
    public static int EMU_PER_PIXEL;
    public static int EMU_PER_POINT;
    public static int EMU_PER_CENTIMETER;
    public static int MASTER_DPI;
    public static int PIXEL_DPI;
    public static int POINT_DPI;
    private static Units();
    public static int ToEMU(double value);
    public static int PixelToEMU(int pixels);
    public static double ToPoints(long emu);
    public static double FixedPointToDecimal(int fixedPoint);
    public static int DoubleToFixedPoint(double floatPoint);
    public static double MasterToPoints(int masterDPI);
    public static int PointsToMaster(double points);
    public static int PointsToPixel(double points);
    public static double PixelToPoints(int pixel);
}
public enum NPOI.WP.UserModel.HeaderFooterType : Enum {
    public int value__;
    public static HeaderFooterType DEFAULT;
    public static HeaderFooterType EVEN;
    public static HeaderFooterType FIRST;
}
public interface NPOI.WP.UserModel.ICharacterRun {
    public bool IsBold { get; public set; }
    public bool IsItalic { get; public set; }
    public bool IsSmallCaps { get; public set; }
    public bool IsCapitalized { get; public set; }
    public bool IsStrikeThrough { get; public set; }
    public bool IsDoubleStrikeThrough { get; public set; }
    public bool IsShadowed { get; public set; }
    public bool IsEmbossed { get; public set; }
    public bool IsImprinted { get; public set; }
    public double FontSize { get; public set; }
    public int CharacterSpacing { get; public set; }
    public int Kerning { get; public set; }
    public bool IsHighlighted { get; }
    public string FontName { get; }
    public string Text { get; }
    public abstract virtual bool get_IsBold();
    public abstract virtual void set_IsBold(bool value);
    public abstract virtual bool get_IsItalic();
    public abstract virtual void set_IsItalic(bool value);
    public abstract virtual bool get_IsSmallCaps();
    public abstract virtual void set_IsSmallCaps(bool value);
    public abstract virtual bool get_IsCapitalized();
    public abstract virtual void set_IsCapitalized(bool value);
    public abstract virtual bool get_IsStrikeThrough();
    public abstract virtual void set_IsStrikeThrough(bool value);
    public abstract virtual bool get_IsDoubleStrikeThrough();
    public abstract virtual void set_IsDoubleStrikeThrough(bool value);
    public abstract virtual bool get_IsShadowed();
    public abstract virtual void set_IsShadowed(bool value);
    public abstract virtual bool get_IsEmbossed();
    public abstract virtual void set_IsEmbossed(bool value);
    public abstract virtual bool get_IsImprinted();
    public abstract virtual void set_IsImprinted(bool value);
    public abstract virtual double get_FontSize();
    public abstract virtual void set_FontSize(double value);
    public abstract virtual int get_CharacterSpacing();
    public abstract virtual void set_CharacterSpacing(int value);
    public abstract virtual int get_Kerning();
    public abstract virtual void set_Kerning(int value);
    public abstract virtual bool get_IsHighlighted();
    public abstract virtual string get_FontName();
    public abstract virtual string get_Text();
}
public interface NPOI.WP.UserModel.IParagraph {
    public int IndentFromRight { get; public set; }
    public int IndentFromLeft { get; public set; }
    public int FirstLineIndent { get; public set; }
    public int FontAlignment { get; public set; }
    public bool IsWordWrapped { get; public set; }
    public abstract virtual int get_IndentFromRight();
    public abstract virtual void set_IndentFromRight(int value);
    public abstract virtual int get_IndentFromLeft();
    public abstract virtual void set_IndentFromLeft(int value);
    public abstract virtual int get_FirstLineIndent();
    public abstract virtual void set_FirstLineIndent(int value);
    public abstract virtual int get_FontAlignment();
    public abstract virtual void set_FontAlignment(int value);
    public abstract virtual bool get_IsWordWrapped();
    public abstract virtual void set_IsWordWrapped(bool value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
