internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NSec.Cryptography.AeadAlgorithm : Algorithm {
    [NullableAttribute("2")]
private static Aegis128L s_Aegis128L;
    [NullableAttribute("2")]
private static Aegis256 s_Aegis256;
    [NullableAttribute("2")]
private static Aes256Gcm s_Aes256Gcm;
    [NullableAttribute("2")]
private static ChaCha20Poly1305 s_ChaCha20Poly1305;
    [NullableAttribute("2")]
private static XChaCha20Poly1305 s_XChaCha20Poly1305;
    private int _keySize;
    private int _nonceSize;
    private int _tagSize;
    public static Aegis128L Aegis128L { get; }
    public static Aegis256 Aegis256 { get; }
    public static Aes256Gcm Aes256Gcm { get; }
    public static ChaCha20Poly1305 ChaCha20Poly1305 { get; }
    public static XChaCha20Poly1305 XChaCha20Poly1305 { get; }
    public int KeySize { get; }
    public int NonceSize { get; }
    public int TagSize { get; }
    private protected AeadAlgorithm(int keySize, int nonceSize, int tagSize);
    public static Aegis128L get_Aegis128L();
    public static Aegis256 get_Aegis256();
    public static Aes256Gcm get_Aes256Gcm();
    public static ChaCha20Poly1305 get_ChaCha20Poly1305();
    public static XChaCha20Poly1305 get_XChaCha20Poly1305();
    public int get_KeySize();
    public int get_NonceSize();
    public int get_TagSize();
    [NullableContextAttribute("0")]
public Byte[] Encrypt(Key key, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext);
    [NullableContextAttribute("0")]
public void Encrypt(Key key, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext);
    [NullableContextAttribute("0")]
public Byte[] Decrypt(Key key, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext);
    [NullableContextAttribute("0")]
public bool Decrypt(Key key, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, Span`1<byte> plaintext);
    internal sealed virtual int GetKeySize();
    internal sealed virtual int GetPublicKeySize();
    internal abstract virtual int GetSeedSize();
    [NullableContextAttribute("0")]
private protected abstract virtual void EncryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext);
    [NullableContextAttribute("0")]
private protected abstract virtual bool DecryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, Span`1<byte> plaintext);
}
public class NSec.Cryptography.Aegis128L : AeadAlgorithm {
    private static UInt32 NSecBlobHeader;
    private static int s_selfTest;
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private protected virtual void EncryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext);
    internal virtual int GetSeedSize();
    private protected virtual bool DecryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, Span`1<byte> plaintext);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private static void SelfTest();
}
public class NSec.Cryptography.Aegis256 : AeadAlgorithm {
    private static UInt32 NSecBlobHeader;
    private static int s_selfTest;
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private protected virtual void EncryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext);
    internal virtual int GetSeedSize();
    private protected virtual bool DecryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, Span`1<byte> plaintext);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private static void SelfTest();
}
public class NSec.Cryptography.Aes256Gcm : AeadAlgorithm {
    private static UInt32 NSecBlobHeader;
    private static int s_isSupported;
    private static int s_selfTest;
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private protected virtual void EncryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext);
    internal virtual int GetSeedSize();
    private protected virtual bool DecryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, Span`1<byte> plaintext);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private static void SelfTest();
}
public abstract class NSec.Cryptography.Algorithm : object {
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public static bool Equals(object objA, object objB);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public static bool ReferenceEquals(object objA, object objB);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public sealed virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public sealed virtual int GetHashCode();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public sealed virtual string ToString();
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual int GetKeySize();
    internal virtual int GetPublicKeySize();
    internal virtual int GetSeedSize();
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    internal virtual bool TryExportPublicKey(PublicKey publicKey, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual bool TryImportPublicKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, PublicKey& publicKey);
}
public class NSec.Cryptography.Argon2id : PasswordBasedKeyDerivationAlgorithm {
    private static int s_selfTest;
    [NativeIntegerAttribute]
private UIntPtr _memLimit;
    private ulong _opsLimit;
    public Argon2id(Argon2Parameters& parameters);
    internal void GetParameters(Argon2Parameters& parameters);
    internal virtual bool TryDeriveBytesCore(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> bytes);
    private static void SelfTest();
}
public class NSec.Cryptography.Argon2Parameters : ValueType {
    public int DegreeOfParallelism;
    public long MemorySize;
    public long NumberOfPasses;
}
public class NSec.Cryptography.Blake2b : HashAlgorithm {
    public static int MinHashSize;
    public static int MaxHashSize;
    private static int s_selfTest;
    public Blake2b(int hashSize);
    private static Blake2b();
    internal virtual void FinalizeCore(IncrementalHashState& state, Span`1<byte> hash);
    internal virtual void InitializeCore(IncrementalHashState& state);
    internal virtual void UpdateCore(IncrementalHashState& state, ReadOnlySpan`1<byte> data);
    private protected virtual void HashCore(ReadOnlySpan`1<byte> data, Span`1<byte> hash);
    private static void SelfTest();
}
public class NSec.Cryptography.Blake2bMac : MacAlgorithm {
    public static int MinKeySize;
    public static int MaxKeySize;
    public static int MinMacSize;
    public static int MaxMacSize;
    private static UInt32 NSecBlobHeader;
    private static int s_selfTest;
    public Blake2bMac(int keySize, int macSize);
    private static Blake2bMac();
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual void FinalizeCore(IncrementalMacState& state, Span`1<byte> mac);
    internal virtual int GetSeedSize();
    [NullableContextAttribute("1")]
internal virtual void InitializeCore(SecureMemoryHandle keyHandle, IncrementalMacState& state);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual void UpdateCore(IncrementalMacState& state, ReadOnlySpan`1<byte> data);
    private protected virtual void MacCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> data, Span`1<byte> mac);
    private static void SelfTest();
}
public class NSec.Cryptography.ChaCha20Poly1305 : AeadAlgorithm {
    private static UInt32 NSecBlobHeader;
    private static int s_selfTest;
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private protected virtual void EncryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext);
    internal virtual int GetSeedSize();
    private protected virtual bool DecryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, Span`1<byte> plaintext);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private static void SelfTest();
}
public class NSec.Cryptography.Ed25519 : SignatureAlgorithm {
    [NullableAttribute("1")]
private static PrivateKeyFormatter s_nsecPrivateKeyFormatter;
    [NullableAttribute("1")]
private static PublicKeyFormatter s_nsecPublicKeyFormatter;
    [NullableAttribute("1")]
private static PrivateKeyFormatter s_pkixPrivateKeyFormatter;
    [NullableAttribute("1")]
private static PublicKeyFormatter s_pkixPublicKeyFormatter;
    [NullableAttribute("1")]
private static PrivateKeyFormatter s_rawPrivateKeyFormatter;
    [NullableAttribute("1")]
private static PublicKeyFormatter s_rawPublicKeyFormatter;
    private static int s_selfTest;
    private static Ed25519();
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual int GetSeedSize();
    private protected virtual void SignCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> data, Span`1<byte> signature);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    internal virtual bool TryExportPublicKey(PublicKey publicKey, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual bool TryImportPublicKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, PublicKey& publicKey);
    private protected virtual bool VerifyCore(PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) publicKeyBytes, ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature);
    private static void SelfTest();
}
public class NSec.Cryptography.Ed25519ph : SignatureAlgorithm2 {
    [NullableAttribute("1")]
private static PrivateKeyFormatter s_nsecPrivateKeyFormatter;
    [NullableAttribute("1")]
private static PublicKeyFormatter s_nsecPublicKeyFormatter;
    [NullableAttribute("1")]
private static PrivateKeyFormatter s_rawPrivateKeyFormatter;
    [NullableAttribute("1")]
private static PublicKeyFormatter s_rawPublicKeyFormatter;
    private static int s_selfTest;
    private static Ed25519ph();
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual int GetSeedSize();
    private protected virtual void SignCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> data, Span`1<byte> signature);
    private protected virtual bool VerifyCore(PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) publicKeyBytes, ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature);
    internal virtual void InitializeCore(IncrementalSignatureState& state);
    internal virtual void UpdateCore(IncrementalSignatureState& state, ReadOnlySpan`1<byte> data);
    internal virtual void FinalSignCore(IncrementalSignatureState& state, SecureMemoryHandle keyHandle, Span`1<byte> signature);
    internal virtual bool FinalVerifyCore(IncrementalSignatureState& state, PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) publicKeyBytes, ReadOnlySpan`1<byte> signature);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    internal virtual bool TryExportPublicKey(PublicKey publicKey, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual bool TryImportPublicKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, PublicKey& publicKey);
    private static void SelfTest();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NSec.Cryptography.Error : object {
    [NullableAttribute("2")]
private static ResourceManager s_resourceManager;
    private static ResourceManager ResourceManager { get; }
    private static ResourceManager get_ResourceManager();
    internal static ArgumentException Argument_BadBase16Length(string paramName);
    internal static ArgumentException Argument_BadBase32Length(string paramName);
    internal static ArgumentException Argument_BadBase64Length(string paramName);
    internal static ArgumentException Argument_CiphertextLength(string paramName);
    internal static ArgumentException Argument_DeriveInvalidCount(string paramName, object arg0);
    internal static ArgumentException Argument_DestinationTooShort(string paramName);
    internal static ArgumentException Argument_FormatNotSupported(string paramName, object arg0);
    internal static ArgumentException Argument_HashLength(string paramName, object arg0);
    internal static ArgumentException Argument_InvalidArgon2Parameters(string paramName);
    internal static ArgumentException Argument_InvalidPbkdf2Parameters(string paramName);
    internal static ArgumentException Argument_InvalidPrkLength(string paramName, object arg0);
    internal static ArgumentException Argument_InvalidPrkLengthExact(string paramName, object arg0);
    internal static ArgumentException Argument_InvalidScryptParameters(string paramName);
    internal static ArgumentException Argument_KeyAlgorithmMismatch(string paramName, object arg0);
    internal static ArgumentException Argument_MacKeyRequired(string paramName);
    internal static ArgumentException Argument_MacLength(string paramName, object arg0);
    internal static ArgumentException Argument_MinMaxValue(string paramName, object arg0, object arg1);
    internal static ArgumentException Argument_NonceFixedCounterSize(string paramName, object arg0);
    internal static ArgumentException Argument_NonceFixedSize(string paramName, object arg0);
    internal static ArgumentException Argument_NonceLength(string paramName, object arg0);
    internal static ArgumentException Argument_NonceXorSize(string paramName);
    internal static ArgumentException Argument_OverlapCiphertext(string paramName);
    internal static ArgumentException Argument_OverlapInfo(string paramName);
    internal static ArgumentException Argument_OverlapPlaintext(string paramName);
    internal static ArgumentException Argument_OverlapPrk(string paramName);
    internal static ArgumentException Argument_OverlapSalt(string paramName);
    internal static ArgumentException Argument_PlaintextLength(string paramName);
    internal static ArgumentException Argument_PlaintextTooLong(string paramName, object arg0);
    internal static ArgumentException Argument_PublicKeyAlgorithmMismatch(string paramName, object arg0);
    internal static ArgumentException Argument_SaltLength(string paramName, object arg0);
    internal static ArgumentException Argument_SaltLengthRange(string paramName, object arg0, object arg1);
    internal static ArgumentException Argument_SharedSecretLength(string paramName, object arg0);
    internal static ArgumentException Argument_SignatureKeyRequired(string paramName);
    internal static ArgumentException Argument_SignatureLength(string paramName, object arg0);
    internal static ArgumentNullException ArgumentNull_Algorithm(string paramName);
    internal static ArgumentNullException ArgumentNull_Key(string paramName);
    internal static ArgumentNullException ArgumentNull_Password(string paramName);
    internal static ArgumentNullException ArgumentNull_SharedSecret(string paramName);
    internal static ArgumentNullException ArgumentNull_String(string paramName);
    internal static ArgumentOutOfRangeException ArgumentOutOfRange_DeriveInvalidCount(string paramName, object arg0);
    internal static ArgumentOutOfRangeException ArgumentOutOfRange_DeriveNegativeCount(string paramName);
    internal static ArgumentOutOfRangeException ArgumentOutOfRange_GenerateNegativeCount(string paramName);
    [NullableContextAttribute("2")]
internal static ArgumentOutOfRangeException ArgumentOutOfRange_HashSize(string paramName, object arg0, object arg1, object arg2);
    [NullableContextAttribute("2")]
internal static ArgumentOutOfRangeException ArgumentOutOfRange_KeySize(string paramName, object arg0, object arg1, object arg2);
    [NullableContextAttribute("2")]
internal static ArgumentOutOfRangeException ArgumentOutOfRange_MacSize(string paramName, object arg0, object arg1, object arg2);
    internal static ArgumentOutOfRangeException ArgumentOutOfRange_MustBePositive(string paramName, object arg0);
    internal static ArgumentOutOfRangeException ArgumentOutOfRange_NonceAddend(string paramName);
    internal static ArgumentOutOfRangeException ArgumentOutOfRange_NonceCounterSize(string paramName, object arg0);
    internal static ArgumentOutOfRangeException ArgumentOutOfRange_NonceFixedCounterSize(string paramName, object arg0);
    internal static CryptographicException Cryptographic_PasswordBasedKeyDerivationFailed();
    internal static FormatException Format_BadBase16();
    internal static FormatException Format_BadBase32();
    internal static FormatException Format_BadBase64();
    internal static FormatException Format_InvalidBlob();
    internal static InvalidOperationException InvalidOperation_AlreadyArchived();
    internal static InvalidOperationException InvalidOperation_ExportNotAllowed();
    internal static InvalidOperationException InvalidOperation_InitializationFailed();
    [NullableContextAttribute("2")]
internal static InvalidOperationException InvalidOperation_InitializationFailed_VersionMismatch(object arg0, object arg1);
    internal static InvalidOperationException InvalidOperation_InternalError();
    internal static InvalidOperationException InvalidOperation_NoPublicKey();
    internal static InvalidOperationException InvalidOperation_UninitializedState();
    internal static NotSupportedException NotSupported_CreateKey();
    internal static NotSupportedException NotSupported_ExportKey();
    internal static NotSupportedException NotSupported_ImportKey();
    [NullableContextAttribute("2")]
internal static NotSupportedException NotSupported_KeyConversion(object arg0, object arg1);
    internal static NotSupportedException NotSupported_Operation();
    internal static OverflowException Overflow_NonceCounter();
    internal static PlatformNotSupportedException PlatformNotSupported_Aes256Gcm();
    internal static PlatformNotSupportedException PlatformNotSupported_Initialization(Exception innerException);
}
internal static class NSec.Cryptography.Formatting.Armor : object {
    [NullableAttribute("1")]
private static SByte[] s_decodingMap;
    private static Armor();
    public static void EncodeToUtf8(ReadOnlySpan`1<byte> bytes, ReadOnlySpan`1<byte> utf8BeginLabel, ReadOnlySpan`1<byte> utf8EndLabel, Span`1<byte> utf8);
    public static int GetEncodedToUtf8Length(int inputLength, ReadOnlySpan`1<byte> utf8BeginLabel, ReadOnlySpan`1<byte> utf8EndLabel);
    public static bool TryDecodeFromUtf8(ReadOnlySpan`1<byte> utf8, ReadOnlySpan`1<byte> utf8BeginLabel, ReadOnlySpan`1<byte> utf8EndLabel, Span`1<byte> bytes, Int32& written);
}
internal class NSec.Cryptography.Formatting.Ed25519PrivateKeyFormatter : PrivateKeyFormatter {
    [NullableContextAttribute("1")]
public Ed25519PrivateKeyFormatter(Byte[] blobHeader);
    protected virtual void Deserialize(ReadOnlySpan`1<byte> span, SecureMemoryHandle& keyHandle, PublicKeyBytes& publicKeyBytes);
    protected virtual void Serialize(SecureMemoryHandle keyHandle, Span`1<byte> span);
}
internal class NSec.Cryptography.Formatting.Ed25519PublicKeyFormatter : PublicKeyFormatter {
    [NullableContextAttribute("1")]
public Ed25519PublicKeyFormatter(Byte[] blobHeader);
    protected virtual void Deserialize(ReadOnlySpan`1<byte> span, PublicKeyBytes& publicKeyBytes);
    protected virtual void Serialize(PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) publicKeyBytes, Span`1<byte> span);
}
internal static class NSec.Cryptography.Formatting.NSecKeyFormatter : object {
    public static bool TryExport(UInt32 blobHeader, int keySize, int outputSize, SecureMemoryHandle keyHandle, Span`1<byte> blob, Int32& blobSize);
    public static bool TryImport(UInt32 blobHeader, int keySize, int outputSize, ReadOnlySpan`1<byte> blob, SecureMemoryHandle& keyHandle);
}
internal abstract class NSec.Cryptography.Formatting.PrivateKeyFormatter : object {
    [NullableAttribute("1")]
private static Byte[] s_beginLabel;
    [NullableAttribute("1")]
private static Byte[] s_endLabel;
    [NullableAttribute("1")]
private Byte[] _blobHeader;
    private int _blobSize;
    private int _blobTextSize;
    private int _keySize;
    [NullableContextAttribute("1")]
public PrivateKeyFormatter(int keySize, Byte[] blobHeader);
    private static PrivateKeyFormatter();
    public bool TryExport(SecureMemoryHandle keyHandle, Span`1<byte> blob, Int32& blobSize);
    public bool TryExportText(SecureMemoryHandle keyHandle, Span`1<byte> blob, Int32& blobSize);
    public bool TryImport(ReadOnlySpan`1<byte> blob, SecureMemoryHandle& keyHandle, PublicKeyBytes& publicKeyBytes);
    public bool TryImportText(ReadOnlySpan`1<byte> blob, SecureMemoryHandle& keyHandle, PublicKeyBytes& publicKeyBytes);
    protected abstract virtual void Deserialize(ReadOnlySpan`1<byte> span, SecureMemoryHandle& keyHandle, PublicKeyBytes& publicKeyBytes);
    protected abstract virtual void Serialize(SecureMemoryHandle keyHandle, Span`1<byte> span);
}
internal abstract class NSec.Cryptography.Formatting.PublicKeyFormatter : object {
    [NullableAttribute("1")]
private static Byte[] s_beginLabel;
    [NullableAttribute("1")]
private static Byte[] s_endLabel;
    [NullableAttribute("1")]
private Byte[] _blobHeader;
    private int _blobSize;
    private int _blobTextSize;
    private int _keySize;
    [NullableContextAttribute("1")]
public PublicKeyFormatter(int keySize, Byte[] blobHeader);
    private static PublicKeyFormatter();
    public bool TryExport(PublicKeyBytes& publicKeyBytes, Span`1<byte> blob, Int32& blobSize);
    public bool TryExportText(PublicKeyBytes& publicKeyBytes, Span`1<byte> blob, Int32& blobSize);
    public bool TryImport(ReadOnlySpan`1<byte> blob, PublicKeyBytes& result);
    public bool TryImportText(ReadOnlySpan`1<byte> blob, PublicKeyBytes& result);
    protected abstract virtual void Deserialize(ReadOnlySpan`1<byte> span, PublicKeyBytes& publicKeyBytes);
    protected abstract virtual void Serialize(PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) publicKeyBytes, Span`1<byte> span);
}
internal static class NSec.Cryptography.Formatting.RawKeyFormatter : object {
    public static bool TryExport(SecureMemoryHandle keyHandle, Span`1<byte> blob, Int32& blobSize);
    public static bool TryImport(int keySize, ReadOnlySpan`1<byte> blob, SecureMemoryHandle& keyHandle);
}
internal class NSec.Cryptography.Formatting.X25519PrivateKeyFormatter : PrivateKeyFormatter {
    [NullableContextAttribute("1")]
public X25519PrivateKeyFormatter(Byte[] blobHeader);
    protected virtual void Deserialize(ReadOnlySpan`1<byte> span, SecureMemoryHandle& keyHandle, PublicKeyBytes& publicKeyBytes);
    protected virtual void Serialize(SecureMemoryHandle keyHandle, Span`1<byte> span);
}
internal class NSec.Cryptography.Formatting.X25519PublicKeyFormatter : PublicKeyFormatter {
    [NullableContextAttribute("1")]
public X25519PublicKeyFormatter(Byte[] blobHeader);
    protected virtual void Deserialize(ReadOnlySpan`1<byte> span, PublicKeyBytes& publicKeyBytes);
    protected virtual void Serialize(PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) publicKeyBytes, Span`1<byte> span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NSec.Cryptography.HashAlgorithm : Algorithm {
    [NullableAttribute("2")]
private static Blake2b s_Blake2b_256;
    [NullableAttribute("2")]
private static Blake2b s_Blake2b_512;
    [NullableAttribute("2")]
private static Sha256 s_Sha256;
    [NullableAttribute("2")]
private static Sha512 s_Sha512;
    [NullableAttribute("2")]
private static Sha512 s_Sha512_256;
    private int _hashSize;
    public static Blake2b Blake2b_256 { get; }
    public static Blake2b Blake2b_512 { get; }
    public static Sha256 Sha256 { get; }
    public static Sha512 Sha512 { get; }
    public static Sha512 Sha512_256 { get; }
    public int HashSize { get; }
    private protected HashAlgorithm(int hashSize);
    public static Blake2b get_Blake2b_256();
    public static Blake2b get_Blake2b_512();
    public static Sha256 get_Sha256();
    public static Sha512 get_Sha512();
    public static Sha512 get_Sha512_256();
    public int get_HashSize();
    [NullableContextAttribute("0")]
public Byte[] Hash(ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("0")]
public void Hash(ReadOnlySpan`1<byte> data, Span`1<byte> hash);
    [NullableContextAttribute("0")]
public bool Verify(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> hash);
    [NullableContextAttribute("0")]
internal abstract virtual void FinalizeCore(IncrementalHashState& state, Span`1<byte> hash);
    internal sealed virtual int GetKeySize();
    internal sealed virtual int GetPublicKeySize();
    internal sealed virtual int GetSeedSize();
    internal abstract virtual void InitializeCore(IncrementalHashState& state);
    [NullableContextAttribute("0")]
internal abstract virtual void UpdateCore(IncrementalHashState& state, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("0")]
private protected abstract virtual void HashCore(ReadOnlySpan`1<byte> data, Span`1<byte> hash);
}
public class NSec.Cryptography.HkdfSha256 : KeyDerivationAlgorithm2 {
    private protected virtual void DeriveBytesCore(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    private protected virtual void ExpandCore(ReadOnlySpan`1<byte> pseudorandomKey, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    private protected virtual void ExtractCore(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, Span`1<byte> pseudorandomKey);
}
public class NSec.Cryptography.HkdfSha512 : KeyDerivationAlgorithm2 {
    private protected virtual void DeriveBytesCore(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    private protected virtual void ExpandCore(ReadOnlySpan`1<byte> pseudorandomKey, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    private protected virtual void ExtractCore(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, Span`1<byte> pseudorandomKey);
}
public class NSec.Cryptography.HmacSha256 : MacAlgorithm {
    public static int MinKeySize;
    public static int MaxKeySize;
    public static int MinMacSize;
    public static int MaxMacSize;
    private static UInt32 NSecBlobHeader;
    private static int s_selfTest;
    public HmacSha256(int keySize, int macSize);
    private static HmacSha256();
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual void FinalizeCore(IncrementalMacState& state, Span`1<byte> mac);
    internal virtual int GetSeedSize();
    [NullableContextAttribute("1")]
internal virtual void InitializeCore(SecureMemoryHandle keyHandle, IncrementalMacState& state);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual void UpdateCore(IncrementalMacState& state, ReadOnlySpan`1<byte> data);
    private protected virtual void MacCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> data, Span`1<byte> mac);
    private static void SelfTest();
}
public class NSec.Cryptography.HmacSha512 : MacAlgorithm {
    public static int MinKeySize;
    public static int MaxKeySize;
    public static int MinMacSize;
    public static int MaxMacSize;
    private static UInt32 NSecBlobHeader;
    private static int s_selfTest;
    public HmacSha512(int keySize, int macSize);
    private static HmacSha512();
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual void FinalizeCore(IncrementalMacState& state, Span`1<byte> mac);
    internal virtual int GetSeedSize();
    [NullableContextAttribute("1")]
internal virtual void InitializeCore(SecureMemoryHandle keyHandle, IncrementalMacState& state);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual void UpdateCore(IncrementalMacState& state, ReadOnlySpan`1<byte> data);
    private protected virtual void MacCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> data, Span`1<byte> mac);
    private static void SelfTest();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class NSec.Cryptography.IncrementalHash : ValueType {
    private IncrementalHashState _state;
    private HashAlgorithm _algorithm;
    public HashAlgorithm Algorithm { get; }
    public HashAlgorithm get_Algorithm();
    [EditorBrowsableAttribute("1")]
public static bool Equals(object objA, object objB);
    [NullableContextAttribute("1")]
public static Byte[] Finalize(IncrementalHash& state);
    [NullableContextAttribute("0")]
public static void Finalize(IncrementalHash& state, Span`1<byte> hash);
    [NullableContextAttribute("0")]
public static bool FinalizeAndVerify(IncrementalHash& state, ReadOnlySpan`1<byte> hash);
    [NullableContextAttribute("1")]
public static void Initialize(HashAlgorithm algorithm, IncrementalHash& state);
    [EditorBrowsableAttribute("1")]
public static bool ReferenceEquals(object objA, object objB);
    [NullableContextAttribute("0")]
public static void Update(IncrementalHash& state, ReadOnlySpan`1<byte> data);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
internal class NSec.Cryptography.IncrementalHashState : ValueType {
    internal crypto_generichash_blake2b_state blake2b;
    internal crypto_hash_sha256_state sha256;
    internal crypto_hash_sha512_state sha512;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class NSec.Cryptography.IncrementalMac : ValueType {
    private IncrementalMacState _state;
    private MacAlgorithm _algorithm;
    public MacAlgorithm Algorithm { get; }
    public MacAlgorithm get_Algorithm();
    [EditorBrowsableAttribute("1")]
public static bool Equals(object objA, object objB);
    [NullableContextAttribute("1")]
public static Byte[] Finalize(IncrementalMac& state);
    [NullableContextAttribute("0")]
public static void Finalize(IncrementalMac& state, Span`1<byte> mac);
    [NullableContextAttribute("0")]
public static bool FinalizeAndVerify(IncrementalMac& state, ReadOnlySpan`1<byte> mac);
    [NullableContextAttribute("1")]
public static void Initialize(Key key, IncrementalMac& state);
    [EditorBrowsableAttribute("1")]
public static bool ReferenceEquals(object objA, object objB);
    [NullableContextAttribute("0")]
public static void Update(IncrementalMac& state, ReadOnlySpan`1<byte> data);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
internal class NSec.Cryptography.IncrementalMacState : ValueType {
    internal crypto_generichash_blake2b_state blake2b;
    internal crypto_auth_hmacsha256_state hmacsha256;
    internal crypto_auth_hmacsha512_state hmacsha512;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class NSec.Cryptography.IncrementalSignature : ValueType {
    private IncrementalSignatureState _state;
    private SignatureAlgorithm2 _algorithm;
    private Key _privateKey;
    public SignatureAlgorithm2 Algorithm { get; }
    public SignatureAlgorithm2 get_Algorithm();
    [EditorBrowsableAttribute("1")]
public static bool Equals(object objA, object objB);
    [NullableContextAttribute("1")]
public static void Initialize(Key privateKey, IncrementalSignature& state);
    [NullableContextAttribute("0")]
public static void Update(IncrementalSignature& state, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("1")]
public static Byte[] Finalize(IncrementalSignature& state);
    [NullableContextAttribute("0")]
public static void Finalize(IncrementalSignature& state, Span`1<byte> signature);
    [EditorBrowsableAttribute("1")]
public static bool ReferenceEquals(object objA, object objB);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
internal class NSec.Cryptography.IncrementalSignatureState : ValueType {
    internal crypto_sign_ed25519ph_state ed25519ph;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class NSec.Cryptography.IncrementalSignatureVerification : ValueType {
    private IncrementalSignatureState _state;
    private SignatureAlgorithm2 _algorithm;
    private PublicKey _publicKey;
    public SignatureAlgorithm2 Algorithm { get; }
    public SignatureAlgorithm2 get_Algorithm();
    [EditorBrowsableAttribute("1")]
public static bool Equals(object objA, object objB);
    [NullableContextAttribute("1")]
public static void Initialize(PublicKey publicKey, IncrementalSignatureVerification& state);
    [NullableContextAttribute("0")]
public static void Update(IncrementalSignatureVerification& state, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("0")]
public static bool FinalizeAndVerify(IncrementalSignatureVerification& state, ReadOnlySpan`1<byte> signature);
    [EditorBrowsableAttribute("1")]
public static bool ReferenceEquals(object objA, object objB);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Algorithm = {Algorithm}")]
public class NSec.Cryptography.Key : object {
    private Algorithm _algorithm;
    private KeyExportPolicies _exportPolicy;
    private SecureMemoryHandle _handle;
    [NullableAttribute("2")]
private PublicKey _publicKey;
    private bool _exported;
    public Algorithm Algorithm { get; }
    public KeyExportPolicies ExportPolicy { get; }
    public bool HasPublicKey { get; }
    public PublicKey PublicKey { get; }
    public int Size { get; }
    internal SecureMemoryHandle Handle { get; }
    public Key(Algorithm algorithm, KeyCreationParameters& creationParameters);
    internal Key(Algorithm algorithm, KeyCreationParameters& creationParameters, SecureMemoryHandle keyHandle, PublicKey publicKey);
    public Algorithm get_Algorithm();
    public KeyExportPolicies get_ExportPolicy();
    public bool get_HasPublicKey();
    public PublicKey get_PublicKey();
    public int get_Size();
    internal SecureMemoryHandle get_Handle();
    public static Key Create(Algorithm algorithm, KeyCreationParameters& creationParameters);
    public static Key Import(Algorithm algorithm, ReadOnlySpan`1<byte> blob, KeyBlobFormat format, KeyCreationParameters& creationParameters);
    [NullableContextAttribute("0")]
public static bool TryImport(Algorithm algorithm, ReadOnlySpan`1<byte> blob, KeyBlobFormat format, Key& result, KeyCreationParameters& creationParameters);
    public sealed virtual void Dispose();
    public Byte[] Export(KeyBlobFormat format);
    public int GetExportBlobSize(KeyBlobFormat format);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("0")]
public bool TryExport(KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NSec.Cryptography.KeyAgreementAlgorithm : Algorithm {
    [NullableAttribute("2")]
private static X25519 s_X25519;
    private int _privateKeySize;
    private int _publicKeySize;
    private int _sharedSecretSize;
    public static X25519 X25519 { get; }
    public int PrivateKeySize { get; }
    public int PublicKeySize { get; }
    public int SharedSecretSize { get; }
    private protected KeyAgreementAlgorithm(int privateKeySize, int publicKeySize, int sharedSecretSize);
    public static X25519 get_X25519();
    public int get_PrivateKeySize();
    public int get_PublicKeySize();
    public int get_SharedSecretSize();
    public SharedSecret Agree(Key key, PublicKey otherPartyPublicKey, SharedSecretCreationParameters& creationParameters);
    internal sealed virtual int GetKeySize();
    internal sealed virtual int GetPublicKeySize();
    internal abstract virtual int GetSeedSize();
    private protected abstract virtual bool AgreeCore(SecureMemoryHandle keyHandle, PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) otherPartyPublicKey, SecureMemoryHandle& sharedSecretHandle);
}
public enum NSec.Cryptography.KeyBlobFormat : Enum {
    public int value__;
    public static KeyBlobFormat RawSymmetricKey;
    public static KeyBlobFormat RawPrivateKey;
    public static KeyBlobFormat NSecSymmetricKey;
    public static KeyBlobFormat NSecPrivateKey;
    public static KeyBlobFormat PkixPrivateKey;
    public static KeyBlobFormat PkixPrivateKeyText;
    public static KeyBlobFormat RawPublicKey;
    public static KeyBlobFormat NSecPublicKey;
    public static KeyBlobFormat PkixPublicKey;
    public static KeyBlobFormat PkixPublicKeyText;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class NSec.Cryptography.KeyCreationParameters : ValueType {
    public KeyExportPolicies ExportPolicy;
}
public abstract class NSec.Cryptography.KeyDerivationAlgorithm : Algorithm {
    [NullableAttribute("2")]
private static HkdfSha256 s_HkdfSha256;
    [NullableAttribute("2")]
private static HkdfSha512 s_HkdfSha512;
    private int _maxCount;
    private int _maxSaltSize;
    private int _minSaltSize;
    [NullableAttribute("1")]
public static HkdfSha256 HkdfSha256 { get; }
    [NullableAttribute("1")]
public static HkdfSha512 HkdfSha512 { get; }
    public int MaxCount { get; }
    public int MaxSaltSize { get; }
    public int MinSaltSize { get; }
    private protected KeyDerivationAlgorithm(bool supportsSalt, int maxCount);
    [NullableContextAttribute("1")]
public static HkdfSha256 get_HkdfSha256();
    [NullableContextAttribute("1")]
public static HkdfSha512 get_HkdfSha512();
    public int get_MaxCount();
    public int get_MaxSaltSize();
    public int get_MinSaltSize();
    public Byte[] DeriveBytes(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, int count);
    public void DeriveBytes(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    public Key DeriveKey(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Algorithm algorithm, KeyCreationParameters& creationParameters);
    public Byte[] DeriveBytes(SharedSecret sharedSecret, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, int count);
    public void DeriveBytes(SharedSecret sharedSecret, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    [NullableContextAttribute("1")]
public Key DeriveKey(SharedSecret sharedSecret, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Algorithm algorithm, KeyCreationParameters& creationParameters);
    internal sealed virtual int GetKeySize();
    internal sealed virtual int GetPublicKeySize();
    internal sealed virtual int GetSeedSize();
    private protected virtual void DeriveBytesCore(SecureMemoryHandle sharedSecretHandle, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    private protected abstract virtual void DeriveBytesCore(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
}
public abstract class NSec.Cryptography.KeyDerivationAlgorithm2 : KeyDerivationAlgorithm {
    private int _pseudorandomKeySize;
    public int PseudorandomKeySize { get; }
    private protected KeyDerivationAlgorithm2(bool supportsSalt, int maxCount, int pseudorandomKeySize);
    public int get_PseudorandomKeySize();
    public Byte[] Extract(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt);
    public void Extract(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, Span`1<byte> pseudorandomKey);
    [NullableContextAttribute("1")]
public Byte[] Extract(SharedSecret sharedSecret, ReadOnlySpan`1<byte> salt);
    public void Extract(SharedSecret sharedSecret, ReadOnlySpan`1<byte> salt, Span`1<byte> pseudorandomKey);
    public Byte[] Expand(ReadOnlySpan`1<byte> pseudorandomKey, ReadOnlySpan`1<byte> info, int count);
    public void Expand(ReadOnlySpan`1<byte> pseudorandomKey, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    public Key ExpandKey(ReadOnlySpan`1<byte> pseudorandomKey, ReadOnlySpan`1<byte> info, Algorithm algorithm, KeyCreationParameters& creationParameters);
    private protected virtual void DeriveBytesCore(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    private protected abstract virtual void ExpandCore(ReadOnlySpan`1<byte> pseudorandomKey, ReadOnlySpan`1<byte> info, Span`1<byte> bytes);
    private protected virtual void ExtractCore(SecureMemoryHandle sharedSecretHandle, ReadOnlySpan`1<byte> salt, Span`1<byte> pseudorandomKey);
    private protected abstract virtual void ExtractCore(ReadOnlySpan`1<byte> inputKeyingMaterial, ReadOnlySpan`1<byte> salt, Span`1<byte> pseudorandomKey);
}
[FlagsAttribute]
public enum NSec.Cryptography.KeyExportPolicies : Enum {
    public int value__;
    public static KeyExportPolicies None;
    public static KeyExportPolicies AllowPlaintextExport;
    public static KeyExportPolicies AllowPlaintextArchiving;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NSec.Cryptography.MacAlgorithm : Algorithm {
    [NullableAttribute("2")]
private static Blake2bMac s_Blake2b_128;
    [NullableAttribute("2")]
private static Blake2bMac s_Blake2b_256;
    [NullableAttribute("2")]
private static Blake2bMac s_Blake2b_512;
    [NullableAttribute("2")]
private static HmacSha256 s_HmacSha256;
    [NullableAttribute("2")]
private static HmacSha256 s_HmacSha256_128;
    [NullableAttribute("2")]
private static HmacSha512 s_HmacSha512;
    [NullableAttribute("2")]
private static HmacSha512 s_HmacSha512_256;
    private int _keySize;
    private int _macSize;
    public static Blake2bMac Blake2b_128 { get; }
    public static Blake2bMac Blake2b_256 { get; }
    public static Blake2bMac Blake2b_512 { get; }
    public static HmacSha256 HmacSha256 { get; }
    public static HmacSha256 HmacSha256_128 { get; }
    public static HmacSha512 HmacSha512 { get; }
    public static HmacSha512 HmacSha512_256 { get; }
    public int KeySize { get; }
    public int MacSize { get; }
    private protected MacAlgorithm(int keySize, int macSize);
    public static Blake2bMac get_Blake2b_128();
    public static Blake2bMac get_Blake2b_256();
    public static Blake2bMac get_Blake2b_512();
    public static HmacSha256 get_HmacSha256();
    public static HmacSha256 get_HmacSha256_128();
    public static HmacSha512 get_HmacSha512();
    public static HmacSha512 get_HmacSha512_256();
    public int get_KeySize();
    public int get_MacSize();
    public Byte[] Mac(Key key, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("0")]
public void Mac(Key key, ReadOnlySpan`1<byte> data, Span`1<byte> mac);
    [NullableContextAttribute("0")]
public bool Verify(Key key, ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> mac);
    [NullableContextAttribute("0")]
internal abstract virtual void FinalizeCore(IncrementalMacState& state, Span`1<byte> mac);
    internal sealed virtual int GetKeySize();
    internal sealed virtual int GetPublicKeySize();
    internal abstract virtual int GetSeedSize();
    internal abstract virtual void InitializeCore(SecureMemoryHandle keyHandle, IncrementalMacState& state);
    [NullableContextAttribute("0")]
internal abstract virtual void UpdateCore(IncrementalMacState& state, ReadOnlySpan`1<byte> data);
    [NullableContextAttribute("0")]
private protected abstract virtual void MacCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> data, Span`1<byte> mac);
}
public abstract class NSec.Cryptography.PasswordBasedKeyDerivationAlgorithm : Algorithm {
    private int _maxCount;
    private int _maxSaltSize;
    private int _minSaltSize;
    public int MaxCount { get; }
    public int MaxSaltSize { get; }
    public int MinSaltSize { get; }
    private protected PasswordBasedKeyDerivationAlgorithm(int saltSize, int maxCount);
    public int get_MaxCount();
    public int get_MaxSaltSize();
    public int get_MinSaltSize();
    [NullableContextAttribute("1")]
public static Argon2id Argon2id(Argon2Parameters& parameters);
    [NullableContextAttribute("1")]
public static Scrypt Scrypt(ScryptParameters& parameters);
    [NullableContextAttribute("1")]
public Byte[] DeriveBytes(string password, ReadOnlySpan`1<byte> salt, int count);
    public void DeriveBytes(string password, ReadOnlySpan`1<byte> salt, Span`1<byte> bytes);
    [NullableContextAttribute("1")]
public Key DeriveKey(string password, ReadOnlySpan`1<byte> salt, Algorithm algorithm, KeyCreationParameters& creationParameters);
    public Byte[] DeriveBytes(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int count);
    public void DeriveBytes(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> bytes);
    public Key DeriveKey(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Algorithm algorithm, KeyCreationParameters& creationParameters);
    internal sealed virtual int GetKeySize();
    internal sealed virtual int GetPublicKeySize();
    internal sealed virtual int GetSeedSize();
    internal abstract virtual bool TryDeriveBytesCore(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Algorithm = {Algorithm}")]
public class NSec.Cryptography.PublicKey : object {
    private Algorithm _algorithm;
    private PublicKeyBytes _bytes;
    public Algorithm Algorithm { get; }
    public int Size { get; }
    internal PublicKey(Algorithm algorithm);
    public Algorithm get_Algorithm();
    public int get_Size();
    public static PublicKey Import(Algorithm algorithm, ReadOnlySpan`1<byte> blob, KeyBlobFormat format);
    [NullableContextAttribute("0")]
public static bool TryImport(Algorithm algorithm, ReadOnlySpan`1<byte> blob, KeyBlobFormat format, PublicKey& result);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PublicKey other);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public Byte[] Export(KeyBlobFormat format);
    public int GetExportBlobSize(KeyBlobFormat format);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("0")]
public bool TryExport(KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    internal PublicKeyBytes& GetPinnableReference();
}
public class NSec.Cryptography.Scrypt : PasswordBasedKeyDerivationAlgorithm {
    private static int s_selfTest;
    private ulong _n;
    private UInt32 _r;
    private UInt32 _p;
    public Scrypt(ScryptParameters& parameters);
    internal void GetParameters(ScryptParameters& parameters);
    internal virtual bool TryDeriveBytesCore(ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, Span`1<byte> bytes);
    private static void SelfTest();
}
public class NSec.Cryptography.ScryptParameters : ValueType {
    public long Cost;
    public int BlockSize;
    public int Parallelization;
}
public class NSec.Cryptography.Sha256 : HashAlgorithm {
    public static int MinHashSize;
    public static int MaxHashSize;
    private static int s_selfTest;
    public Sha256(int hashSize);
    private static Sha256();
    internal virtual void FinalizeCore(IncrementalHashState& state, Span`1<byte> hash);
    internal virtual void InitializeCore(IncrementalHashState& state);
    internal virtual void UpdateCore(IncrementalHashState& state, ReadOnlySpan`1<byte> data);
    private protected virtual void HashCore(ReadOnlySpan`1<byte> data, Span`1<byte> hash);
    private static void SelfTest();
}
public class NSec.Cryptography.Sha512 : HashAlgorithm {
    public static int MinHashSize;
    public static int MaxHashSize;
    private static int s_selfTest;
    public Sha512(int hashSize);
    private static Sha512();
    internal virtual void FinalizeCore(IncrementalHashState& state, Span`1<byte> hash);
    internal virtual void InitializeCore(IncrementalHashState& state);
    internal virtual void UpdateCore(IncrementalHashState& state, ReadOnlySpan`1<byte> data);
    private protected virtual void HashCore(ReadOnlySpan`1<byte> data, Span`1<byte> hash);
    private static void SelfTest();
}
[DebuggerDisplayAttribute("Size = {Size}")]
public class NSec.Cryptography.SharedSecret : object {
    private static UInt32 NSecBlobHeader;
    private static int MaxSize;
    private KeyExportPolicies _exportPolicy;
    [NullableAttribute("1")]
private SecureMemoryHandle _handle;
    private bool _exported;
    public KeyExportPolicies ExportPolicy { get; }
    public int Size { get; }
    [NullableAttribute("1")]
internal SecureMemoryHandle Handle { get; }
    [NullableContextAttribute("1")]
internal SharedSecret(SharedSecretCreationParameters& creationParameters, SecureMemoryHandle sharedSecretHandle);
    public KeyExportPolicies get_ExportPolicy();
    public int get_Size();
    [NullableContextAttribute("1")]
internal SecureMemoryHandle get_Handle();
    public static SharedSecret Import(ReadOnlySpan`1<byte> blob, SharedSecretBlobFormat format, SharedSecretCreationParameters& creationParameters);
    public static bool TryImport(ReadOnlySpan`1<byte> blob, SharedSecretBlobFormat format, SharedSecret& result, SharedSecretCreationParameters& creationParameters);
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public Byte[] Export(SharedSecretBlobFormat format);
    public int GetExportBlobSize(SharedSecretBlobFormat format);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual string ToString();
    public bool TryExport(SharedSecretBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    private static bool TryExportCore(SecureMemoryHandle sharedSecretHandle, SharedSecretBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    private static bool TryExportNSec(SecureMemoryHandle sharedSecretHandle, Span`1<byte> blob, Int32& blobSize);
    private static bool TryExportRaw(SecureMemoryHandle sharedSecretHandle, Span`1<byte> blob, Int32& blobSize);
    private static bool TryImportCore(ReadOnlySpan`1<byte> blob, SharedSecretBlobFormat format, SecureMemoryHandle& sharedSecretHandle);
    private static bool TryImportNSec(ReadOnlySpan`1<byte> blob, SecureMemoryHandle& sharedSecretHandle);
    private static bool TryImportRaw(ReadOnlySpan`1<byte> blob, SecureMemoryHandle& sharedSecretHandle);
}
public enum NSec.Cryptography.SharedSecretBlobFormat : Enum {
    public int value__;
    public static SharedSecretBlobFormat RawSharedSecret;
    public static SharedSecretBlobFormat NSecSharedSecret;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class NSec.Cryptography.SharedSecretCreationParameters : ValueType {
    public KeyExportPolicies ExportPolicy;
}
public abstract class NSec.Cryptography.SignatureAlgorithm : Algorithm {
    [NullableAttribute("2")]
private static Ed25519 s_Ed25519;
    [NullableAttribute("2")]
private static Ed25519ph s_Ed25519ph;
    private int _privateKeySize;
    private int _publicKeySize;
    private int _signatureSize;
    [NullableAttribute("1")]
public static Ed25519 Ed25519 { get; }
    [NullableAttribute("1")]
public static Ed25519ph Ed25519ph { get; }
    public int PrivateKeySize { get; }
    public int PublicKeySize { get; }
    public int SignatureSize { get; }
    private protected SignatureAlgorithm(int privateKeySize, int publicKeySize, int signatureSize);
    [NullableContextAttribute("1")]
public static Ed25519 get_Ed25519();
    [NullableContextAttribute("1")]
public static Ed25519ph get_Ed25519ph();
    public int get_PrivateKeySize();
    public int get_PublicKeySize();
    public int get_SignatureSize();
    [NullableContextAttribute("1")]
public Byte[] Sign(Key key, ReadOnlySpan`1<byte> data);
    public void Sign(Key key, ReadOnlySpan`1<byte> data, Span`1<byte> signature);
    public bool Verify(PublicKey publicKey, ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature);
    internal sealed virtual int GetKeySize();
    internal sealed virtual int GetPublicKeySize();
    internal abstract virtual int GetSeedSize();
    private protected abstract virtual void SignCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> data, Span`1<byte> signature);
    private protected abstract virtual bool VerifyCore(PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) publicKeyBytes, ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature);
}
public abstract class NSec.Cryptography.SignatureAlgorithm2 : SignatureAlgorithm {
    private protected SignatureAlgorithm2(int privateKeySize, int publicKeySize, int signatureSize);
    internal abstract virtual void InitializeCore(IncrementalSignatureState& state);
    internal abstract virtual void UpdateCore(IncrementalSignatureState& state, ReadOnlySpan`1<byte> data);
    internal abstract virtual void FinalSignCore(IncrementalSignatureState& state, SecureMemoryHandle keyHandle, Span`1<byte> signature);
    internal abstract virtual bool FinalVerifyCore(IncrementalSignatureState& state, PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) publicKeyBytes, ReadOnlySpan`1<byte> signature);
}
internal static class NSec.Cryptography.Sodium : object {
    private static int s_initialized;
    public static void Initialize();
    private static void InitializeCore();
    [UnmanagedCallersOnlyAttribute]
private static void InternalError();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NSec.Cryptography.X25519 : KeyAgreementAlgorithm {
    private static PrivateKeyFormatter s_nsecPrivateKeyFormatter;
    private static PublicKeyFormatter s_nsecPublicKeyFormatter;
    private static PrivateKeyFormatter s_pkixPrivateKeyFormatter;
    private static PublicKeyFormatter s_pkixPublicKeyFormatter;
    private static PrivateKeyFormatter s_rawPrivateKeyFormatter;
    private static PublicKeyFormatter s_rawPublicKeyFormatter;
    private static int s_selfTest;
    private static X25519();
    [NullableContextAttribute("0")]
internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    internal virtual int GetSeedSize();
    private protected virtual bool AgreeCore(SecureMemoryHandle keyHandle, PublicKeyBytes& modreq(System.Runtime.InteropServices.InAttribute) otherPartyPublicKey, SecureMemoryHandle& sharedSecretHandle);
    [NullableContextAttribute("0")]
internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("0")]
internal virtual bool TryExportPublicKey(PublicKey publicKey, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    [NullableContextAttribute("0")]
internal virtual bool TryImportPublicKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, PublicKey& publicKey);
    private static void SelfTest();
}
public class NSec.Cryptography.XChaCha20Poly1305 : AeadAlgorithm {
    private static UInt32 NSecBlobHeader;
    private static int s_selfTest;
    internal virtual void CreateKey(ReadOnlySpan`1<byte> seed, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private protected virtual void EncryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext);
    internal virtual int GetSeedSize();
    private protected virtual bool DecryptCore(SecureMemoryHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, Span`1<byte> plaintext);
    internal virtual bool TryExportKey(SecureMemoryHandle keyHandle, KeyBlobFormat format, Span`1<byte> blob, Int32& blobSize);
    [NullableContextAttribute("2")]
internal virtual bool TryImportKey(ReadOnlySpan`1<byte> blob, KeyBlobFormat format, SecureMemoryHandle& keyHandle, PublicKey& publicKey);
    private static void SelfTest();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
