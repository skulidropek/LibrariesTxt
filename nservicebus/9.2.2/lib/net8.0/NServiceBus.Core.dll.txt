[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.CodePrinter : object {
    public static Func`3<Type, string, string> PrintTypeStripOuterClasses;
    private static string _nonPubStatMethods;
    private static string _nonPubInstMethods;
    private static Char[] _enumValueSeparators;
    public static ObjectToCode DefaultNotRecognizedToCode;
    private static Type[] TypesImplementedByArray;
    private static CodePrinter();
    [ExtensionAttribute]
public static StringBuilder AppendTypeOf(StringBuilder sb, Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static StringBuilder AppendTypeOfList(StringBuilder sb, Type[] types, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
internal static StringBuilder AppendMember(StringBuilder sb, MemberInfo member, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendField(StringBuilder sb, FieldInfo field, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendProperty(StringBuilder sb, PropertyInfo property, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendEnum(StringBuilder sb, TEnum value, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static StringBuilder AppendMethod(StringBuilder sb, MethodInfo method, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendName(StringBuilder sb, string name, string typeCode, T identity, string suffix);
    [ExtensionAttribute]
internal static StringBuilder AppendName(StringBuilder sb, string name, Type type, T identity, string suffix);
    [ExtensionAttribute]
public static string ToCode(Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static string ToCode(bool x);
    [ExtensionAttribute]
public static string ToCode(string x);
    [ExtensionAttribute]
public static string ToEnumValueCode(Type enumType, object x, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static Type[] GetGenericTypeParametersOrArguments(TypeInfo typeInfo);
    [ExtensionAttribute]
public static string ToCommaSeparatedCode(IEnumerable items, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToArrayInitializerCode(IEnumerable items, Type itemType, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToCode(object x, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdent(StringBuilder sb, int lineIdent);
    [ExtensionAttribute]
internal static StringBuilder NewLine(StringBuilder sb, int lineIdent, int identSpaces);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentExpr(StringBuilder sb, Expression expr, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentArgumentExprs(StringBuilder sb, IReadOnlyList`1<T> exprs, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentArgumentExprs(StringBuilder sb, SmallList2`1<T> exprs, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentCs(StringBuilder sb, Expression expr, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentCs(StringBuilder sb, Expression expr, EnclosedIn enclosedIn, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    public static int CountLambdas(string code);
}
[FlagsAttribute]
internal enum FastExpressionCompiler.CompilerFlags : Enum {
    public byte value__;
    public static CompilerFlags Default;
    public static CompilerFlags NoInvocationLambdaInlining;
    public static CompilerFlags EnableDelegateDebugInfo;
    public static CompilerFlags ThrowOnNotSupportedExpression;
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ExpressionCompiler : object {
    private static Type[] _closureAsASingleParamType;
    private static Type[][] _closureTypePlusParamTypesPool;
    public static ArrayClosure EmptyArrayClosure;
    public static FieldInfo ArrayClosureArrayField;
    public static FieldInfo ArrayClosureWithNonPassedParamsField;
    private static ConstructorInfo[] _nonPassedParamsArrayClosureCtors;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructor;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructorWithoutConstants;
    [CompilerGeneratedAttribute]
private static Result <NotSupported_RuntimeVariables>k__BackingField;
    public static Result NotSupported_RuntimeVariables { get; private set; }
    private static ExpressionCompiler();
    [ExtensionAttribute]
public static TDelegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static bool CompileFastToIL(LambdaExpression lambdaExpr, ILGenerator il, CompilerFlags flags);
    [ExtensionAttribute]
public static Delegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate CompileSys(Expression`1<TDelegate> lambdaExpr);
    [ExtensionAttribute]
public static Delegate CompileSys(LambdaExpression lambdaExpr);
    [ExtensionAttribute]
public static TDelegate CompileFast(Expression`1<TDelegate> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`1<R> CompileFast(Expression`1<Func`1<R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`2<T1, R> CompileFast(Expression`1<Func`2<T1, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`3<T1, T2, R> CompileFast(Expression`1<Func`3<T1, T2, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`4<T1, T2, T3, R> CompileFast(Expression`1<Func`4<T1, T2, T3, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`5<T1, T2, T3, T4, R> CompileFast(Expression`1<Func`5<T1, T2, T3, T4, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`6<T1, T2, T3, T4, T5, R> CompileFast(Expression`1<Func`6<T1, T2, T3, T4, T5, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, R> CompileFast(Expression`1<Func`7<T1, T2, T3, T4, T5, T6, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action CompileFast(Expression`1<Action> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`1<T1> CompileFast(Expression`1<Action`1<T1>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`2<T1, T2> CompileFast(Expression`1<Action`2<T1, T2>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`3<T1, T2, T3> CompileFast(Expression`1<Action`3<T1, T2, T3>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`4<T1, T2, T3, T4> CompileFast(Expression`1<Action`4<T1, T2, T3, T4>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`5<T1, T2, T3, T4, T5> CompileFast(Expression`1<Action`5<T1, T2, T3, T4, T5>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`6<T1, T2, T3, T4, T5, T6> CompileFast(Expression`1<Action`6<T1, T2, T3, T4, T5, T6>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompile(LambdaExpression lambdaExpr, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs, CompilerFlags flags);
    [ExtensionAttribute]
internal static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ClosureInfo& closureInfo, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithoutClosure(LambdaExpression lambdaExpr, CompilerFlags flags);
    private static Delegate CompileNoArgsNew(ConstructorInfo ctor, Type delegateType, Type[] closurePlusParamTypes, Type returnType);
    internal static object TryCompileBoundToFirstClosureParam(Type delegateType, Expression bodyExpr, IReadOnlyList`1<ParameterExpression> paramExprs, Type[] closurePlusParamTypes, Type returnType, CompilerFlags flags);
    private static Type[] RentOrNewClosureTypeToParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    private static void ReturnClosureTypeToParamTypesToPool(Type[] closurePlusParamTypes);
    [ExtensionAttribute]
internal static LabelInfo& GetLabelOrInvokeIndexByTarget(SmallList4`1& labels, object labelTarget, Boolean& found);
    [ExtensionAttribute]
private static Label GetOrDefineLabel(LabelInfo& label, ILGenerator il);
    [CompilerGeneratedAttribute]
public static Result get_NotSupported_RuntimeVariables();
    [CompilerGeneratedAttribute]
private static void set_NotSupported_RuntimeVariables(Result value);
    [ExtensionAttribute]
public static bool TryGetDebugClosureNestedLambdaOrConstant(Delegate parentLambda, Object& item, int itemIndex);
    [ExtensionAttribute]
public static bool TryGetDebugClosureNestedLambda(Delegate parentLambda, int itemIndex, Delegate& d);
    public static bool IsClosureBoundConstant(object value, Type type);
    public static bool TryCollectBoundConstants(ClosureInfo& closure, Expression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    public static Result TryCollectInfo(ClosureInfo& closure, Expression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static Expression CreateInlinedLambdaInvocationExpression(IReadOnlyList`1<Expression> invokeArgs, int invokeArgCount, LambdaExpression lambdaExpr);
    private static bool PropagateNonPassedParamsToOuterLambda(ClosureInfo& closure, NestedLambdaInfo nestedLambda, IReadOnlyList`1<ParameterExpression> paramExprs, IReadOnlyList`1<ParameterExpression> nestedLambdaParamExprs, SmallList`1& nestedNonPassedParams);
    private static bool FindAlreadyCompiledNestedLambdaInfoInLambdas(SmallList`1& nestedLambdas, LambdaExpression lambdaExpr, NestedLambdaInfo& found);
    private static bool TryCompileNestedLambda(ClosureInfo& nestedClosureInfo, NestedLambdaInfo nestedLambdaInfo, CompilerFlags setup);
    [ExtensionAttribute]
public static IDelegateDebugInfo TryGetDebugInfo(D d);
    private static Result TryCollectMemberInitExprConstants(ClosureInfo& closure, MemberInitExpression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static Result TryCollectListInitExprConstants(ClosureInfo& closure, ListInitExpression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static Result TryCollectTryExprConstants(ClosureInfo& closure, TryExpression tryExpr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    [ExtensionAttribute]
public static bool IgnoresResult(ParentFlags parent);
    [ExtensionAttribute]
internal static bool EmitPopIfIgnoreResult(ILGenerator il, ParentFlags parent);
    [ExtensionAttribute]
internal static bool TryEmitBoxOf(ILGenerator il, Type sourceType);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.FecHelpers : object {
    [ExtensionAttribute]
public static int GetFirstIndex(IReadOnlyList`1<T> source, T item, TEq eq);
    [ExtensionAttribute]
public static T GetArgument(IReadOnlyList`1<T> source, int index);
    [ExtensionAttribute]
public static ParameterExpression GetParameter(IReadOnlyList`1<ParameterExpression> source, int index);
    [ExtensionAttribute]
public static IReadOnlyList`1<ParameterExpression> ToReadOnlyList(IReadOnlyList`1<ParameterExpression> source);
    [ExtensionAttribute]
public static int GetCount(IReadOnlyList`1<ParameterExpression> p);
    [ExtensionAttribute]
public static int GetCount(IReadOnlyList`1<Expression> p);
}
internal interface FastExpressionCompiler.IDelegateDebugInfo {
    public LambdaExpression Expression { get; }
    public string ExpressionString { get; }
    public string CSharpString { get; }
    public abstract virtual LambdaExpression get_Expression();
    public abstract virtual string get_ExpressionString();
    public abstract virtual string get_CSharpString();
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ILGeneratorHacks : object {
    private static Func`3<ILGenerator, Type, int> _getNextLocalVarIndex;
    private static ILGeneratorHacks();
    internal static int PostInc(Int32& i);
    [ExtensionAttribute]
public static int GetNextLocalVarIndex(ILGenerator il, Type t);
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ILGeneratorTools : object {
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, Type value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, FieldInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, MethodInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, ConstructorInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, Label value);
    [ExtensionAttribute]
public static void DmarkLabel(ILGenerator il, Label value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, byte value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, sbyte value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, short value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, int value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, long value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, float value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, double value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, string value, OpCode opcode);
}
internal class FastExpressionCompiler.ImTools.DefaultEq`1 : ValueType {
    public sealed virtual K GetTombstone();
    public sealed virtual bool Equals(K x, K y);
    public sealed virtual int GetHashCode(K key);
}
internal static class FastExpressionCompiler.ImTools.Hasher : object {
    public static int Combine(int h1, int h2);
}
internal interface FastExpressionCompiler.ImTools.IEq`1 {
    public abstract virtual K GetTombstone();
    public abstract virtual bool Equals(K x, K y);
    public abstract virtual int GetHashCode(K key);
}
internal class FastExpressionCompiler.ImTools.RefEq`1 : ValueType {
    public sealed virtual K GetTombstone();
    public sealed virtual bool Equals(K x, K y);
    public sealed virtual int GetHashCode(K key);
}
internal class FastExpressionCompiler.ImTools.RefEq`2 : ValueType {
    public sealed virtual ValueTuple`2<A, B> GetTombstone();
    public sealed virtual bool Equals(ValueTuple`2<A, B> x, ValueTuple`2<A, B> y);
    public sealed virtual int GetHashCode(ValueTuple`2<A, B> key);
}
internal class FastExpressionCompiler.ImTools.RefEq`3 : ValueType {
    public sealed virtual ValueTuple`3<A, B, C> GetTombstone();
    public sealed virtual bool Equals(ValueTuple`3<A, B, C> x, ValueTuple`3<A, B, C> y);
    public sealed virtual int GetHashCode(ValueTuple`3<A, B, C> key);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.ImTools.SmallList : object {
    internal static int ForLoopCopyCount;
    internal static int DefaultInitialCapacity;
    internal static void Expand(TItem[]& items);
    public static TItem& AddDefaultToNotNullItemsAndGetRef(TItem[]& items, int index);
    public static TItem& AddDefaultAndGetRef(TItem[]& items, int index, int initialCapacity);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList`1& source, int index);
    [ExtensionAttribute]
public static TItem& Add(SmallList`1& source, int initialCapacity);
    [ExtensionAttribute]
public static void Add(SmallList`1& source, TItem& item, int initialCapacity);
    [ExtensionAttribute]
public static int TryGetIndex(TItem[] items, TItem& it, int startIndex, int count, TEq eq, int notFoundResult);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAdd(SmallList`1& source, TItem& item, TEq eq);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList4`1& source, int index);
    [ExtensionAttribute]
public static TItem& GetLastSurePresentItem(SmallList4`1& source);
    [ExtensionAttribute]
public static TItem& NotFound(SmallList4`1& _);
    [ExtensionAttribute]
public static TItem& AddDefaultAndGetRef(SmallList4`1& source);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList4`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAdd(SmallList4`1& source, TItem& item, TEq eq);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList2`1& source, int index);
    [ExtensionAttribute]
public static TItem& GetLastSurePresentItem(SmallList2`1& source);
    [ExtensionAttribute]
public static TItem& NotFound(SmallList2`1& _);
    [ExtensionAttribute]
public static TItem& AddDefaultAndGetRef(SmallList2`1& source);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList2`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAdd(SmallList2`1& source, TItem item, TEq eq);
}
internal class FastExpressionCompiler.ImTools.SmallList`1 : ValueType {
    public T[] Items;
    public int Count;
    public SmallList`1(T[] items, int count);
    public SmallList`1(T[] items);
    public void Pop();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{Count} of {_it0?.ToString()}, {_it1?.ToString()}, ...")]
internal class FastExpressionCompiler.ImTools.SmallList2`1 : ValueType {
    public static int StackCapacity;
    internal static TItem Missing;
    internal int _count;
    internal TItem _it0;
    internal TItem _it1;
    internal TItem[] _rest;
    public int Count { get; }
    public TItem Item { get; }
    public void InitCount(int count);
    public void Populate1(TItem it0);
    public void Populate2(TItem it0, TItem it1);
    public void Populate(TItem it0, TItem it1, TItem[] rest);
    public void Populate(TList items);
    public int get_Count();
    public TItem get_Item(int index);
    public void Add(TItem& item);
    public void AddDefault();
    public void RemoveLastSurePresentItem();
    public TItem[] ToArray();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{Count} of {_it0?.ToString()}, {_it1?.ToString()}, {_it2?.ToString()}, {_it3?.ToString()}, ...")]
internal class FastExpressionCompiler.ImTools.SmallList4`1 : ValueType {
    public static int StackCapacity;
    internal static TItem Missing;
    internal int _count;
    internal TItem _it0;
    internal TItem _it1;
    internal TItem _it2;
    internal TItem _it3;
    internal TItem[] _rest;
    public int Count { get; }
    public TItem Item { get; }
    public int get_Count();
    public void Populate1(TItem it0);
    public void Populate2(TItem it0, TItem it1);
    public void Populate3(TItem it0, TItem it1, TItem it2);
    public void Populate4(TItem it0, TItem it1, TItem it2, TItem it3);
    public void Populate(TItem it0, TItem it1, TItem it2, TItem it3, TItem[] rest);
    public void Populate(TList items);
    public TItem get_Item(int index);
    public void Add(TItem& item);
    public void AddDefault();
    public void RemoveLastSurePresentItem();
    public TItem[] ToArray();
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.ImTools.SmallMap4 : object {
    internal static byte MinFreeCapacityShift;
    internal static byte MinHashesCapacityBitShift;
    public static byte MaxProbeBits;
    internal static byte MaxProbeCount;
    internal static byte ProbeCountShift;
    internal static int HashAndIndexMask;
    public static int StackEntriesCount;
    internal static int MinEntriesCapacity;
    public static SmallMap4`4<K, V, TEq, SingleArrayEntries`3<K, V, TEq>> New(byte capacityBitShift);
    public static string ToB(int x);
    internal static Int32& GetHashRef(Int32& start, int distance);
    internal static int GetHash(Int32& start, int distance);
    [ExtensionAttribute]
public static V& TryGetValueRef(SmallMap4`4& map, K key, Boolean& found);
    [ExtensionAttribute]
public static bool ContainsKey(SmallMap4`4& map, K key);
    [ExtensionAttribute]
public static V& AddOrGetValueRef(SmallMap4`4& map, K key, Boolean& found);
    [ExtensionAttribute]
private static void AddInitialHashWithoutResizing(SmallMap4`4& map, K key, int index, int indexMask);
    [ExtensionAttribute]
public static V& AddSureAbsentDefaultAndGetRef(SmallMap4`4& map, K key);
    [ExtensionAttribute]
private static V& AddSureAbsentDefaultAndGetRefByHash(SmallMap4`4& map, K key);
    [ExtensionAttribute]
public static Entry`2& GetSurePresentEntryRef(SmallMap4`4& map, int index);
    [ExtensionAttribute]
internal static V& TryGetValueRefByHash(SmallMap4`4& map, K key, Boolean& found);
    [ExtensionAttribute]
private static V& AddOrGetValueRefByHash(SmallMap4`4& map, K key, Boolean& found);
}
[DebuggerDisplayAttribute("{Count} of {_e0}, {_e1}, {_e2}, {_e3}, ...")]
internal class FastExpressionCompiler.ImTools.SmallMap4`4 : ValueType {
    internal static Entry`2<K, V> _missing;
    internal byte _capacityBitShift;
    internal int _count;
    internal Int32[] _packedHashesAndIndexes;
    internal TEntries _entries;
    internal Entry`2<K, V> _e0;
    internal Entry`2<K, V> _e1;
    internal Entry`2<K, V> _e2;
    internal Entry`2<K, V> _e3;
    public int CapacityBitShift { get; }
    public Int32[] PackedHashesAndIndexes { get; }
    public int Count { get; }
    public TEntries Entries { get; }
    public SmallMap4`4(byte capacityBitShift);
    public int get_CapacityBitShift();
    public Int32[] get_PackedHashesAndIndexes();
    public int get_Count();
    public TEntries get_Entries();
    internal int ResizeHashes(int indexMask);
}
internal class FastExpressionCompiler.NotSupportedExpressionException : InvalidOperationException {
    public Result Reason;
    public NotSupportedExpressionException(Result reason);
    public NotSupportedExpressionException(Result reason, string message);
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ToCSharpPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr);
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
public static StringBuilder ToCSharpString(Expression e, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    private static StringBuilder NullConstantOrDefaultToCSharpString(Type exprType, StringBuilder sb, EnclosedIn encloseIn, bool stripNamespace, Func`3<Type, string, string> printType);
    private static StringBuilder InsertTopFFuncDefinitionOnce(StringBuilder sb);
    [ExtensionAttribute]
internal static StringBuilder ToCSharpString(Expression e, StringBuilder sb, EnclosedIn enclosedIn, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode, bool isReturnByRef);
    [ExtensionAttribute]
private static StringBuilder ToCSharpBlock(Expression expr, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToCSharpExpression(Expression expr, StringBuilder sb, EnclosedIn enclosedIn, bool newLineExpr, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder AppendSemicolonOnce(StringBuilder sb);
    [ExtensionAttribute]
internal static StringBuilder AppendLineOnce(StringBuilder sb);
    [ExtensionAttribute]
internal static StringBuilder ToCSharpString(LabelTarget target, StringBuilder sb);
    [ExtensionAttribute]
private static StringBuilder ToCSharpString(IReadOnlyList`1<MemberBinding> bindings, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder BlockToCSharpString(BlockExpression b, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode, bool inTheLastBlock, BinaryExpression blockResultAssignment, bool containerIgnoresResult);
    private static string OperatorToCSharpString(ExpressionType nodeType);
    [CompilerGeneratedAttribute]
internal static void <ToCSharpString>g__PrintPart|6_0(Expression part, <>c__DisplayClass6_0& , <>c__DisplayClass6_1& );
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ToExpressionPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, List`1& paramsExprs, List`1& uniqueExprs, List`1& lts, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(Expression expr, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(ParameterExpression pe, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(LabelTarget lt, StringBuilder sb, List`1<LabelTarget> labelTargets, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<CatchBlock> bs, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(CatchBlock b, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<SwitchCase> items, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(SwitchCase s, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(MemberBinding mb, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(ElementInit ei, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder CreateExpressionString(Expression e, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.Tools : object {
    internal static MethodInfo DelegateTargetGetterMethod;
    private static Tools();
    [ExtensionAttribute]
public static Expression AsExpr(object obj);
    [ExtensionAttribute]
public static Expression[] AsExprs(Object[] obj);
    [ExtensionAttribute]
internal static bool IsUnsigned(Type type);
    [ExtensionAttribute]
internal static bool IsPrimitiveWithZeroDefault(Type type);
    [ExtensionAttribute]
internal static bool IsNullable(Type type);
    [ExtensionAttribute]
internal static Type GetUnderlyingNullableTypeOrNull(Type type);
    [ExtensionAttribute]
internal static Type GetUnderlyingNullableTypeUnsafe(Type type);
    [ExtensionAttribute]
public static string GetArithmeticBinaryOperatorMethodName(ExpressionType nodeType);
    [ExtensionAttribute]
internal static bool IsAssignNodeType(ExpressionType nodeType);
    [ExtensionAttribute]
internal static bool IsBlockLike(ExpressionType nodeType);
    [ExtensionAttribute]
internal static bool IsReturnable(ExpressionType nodeType);
    [ExtensionAttribute]
internal static bool IsBlockLikeOrConditional(ExpressionType nodeType);
    [ExtensionAttribute]
internal static Expression StripConvertRecursively(Expression expr);
    [ExtensionAttribute]
internal static bool IsComplexExpression(Expression expr);
    [ExtensionAttribute]
internal static bool IsConstantOrDefault(Expression expr);
    [ExtensionAttribute]
internal static bool IsParamOrConstantOrDefault(Expression expr);
    [ExtensionAttribute]
internal static string GetCSharpName(MemberInfo m);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindMethod(Type type, string methodName);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindDelegateInvokeMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindNullableValueGetterMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo GetNullableHasValueGetterMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static FieldInfo GetNullableValueUnsafeAkaGetValueOrDefaultMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static ConstructorInfo GetNullableConstructor(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindConvertOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static ConstructorInfo FindSingleParamConstructor(Type type, Type paramType);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> xs);
    [ExtensionAttribute]
internal static IList`1<T> AsList(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static bool TryGetIndex(IList`1<T> items, Int32& index, T item, int count, TEq eq);
    public static T[] Empty();
    public static Type[] GetParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    public static Type GetFuncOrActionType(Type returnType);
    public static Type GetFuncOrActionType(Type p, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type p5, Type returnType);
    public static Type GetFuncOrActionType(Type[] paramTypes, Type returnType);
    [ExtensionAttribute]
public static T GetFirst(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T GetFirst(T[] source);
    [CompilerGeneratedAttribute]
internal static Type <GetFuncOrActionType>g__GetAction|40_0(int length);
    [CompilerGeneratedAttribute]
internal static Type <GetFuncOrActionType>g__GetFunc|40_1(int length);
}
internal static class FastExpressionCompiler.Trimming : object {
    public static string Message;
}
internal static class NServiceBus.ActivityDecorator : object {
    internal static Dictionary`2<string, string> HeaderMapping;
    private static ActivityDecorator();
    public static void PromoteHeadersToTags(Activity activity, Dictionary`2<string, string> headers);
}
internal static class NServiceBus.ActivityDisplayNames : object {
    public static string ProcessMessage;
    public static string PublishEvent;
    public static string SubscribeEvent;
    public static string UnsubscribeEvent;
    public static string SendMessage;
    public static string ReplyMessage;
}
[ExtensionAttribute]
internal static class NServiceBus.ActivityExtensions : object {
    public static string OutgoingActivityKey;
    public static string IncomingActivityKey;
    [ExtensionAttribute]
public static bool TryGetRecordingOutgoingPipelineActivity(ContextBag pipelineContext, Activity& activity);
    [ExtensionAttribute]
public static bool TryGetRecordingIncomingPipelineActivity(ContextBag pipelineContext, Activity& activity);
    [ExtensionAttribute]
private static bool TryGetRecordingPipelineActivity(ContextBag pipelineContext, string activityKey, Activity& activity);
    [ExtensionAttribute]
public static void SetOutgoingPipelineActitvity(ContextBag pipelineContext, Activity activity);
    [ExtensionAttribute]
public static void SetIncomingPipelineActitvity(ContextBag pipelineContext, Activity activity);
    [ExtensionAttribute]
public static void SetErrorStatus(Activity activity, Exception ex);
}
internal class NServiceBus.ActivityFactory : object {
    public sealed virtual Activity StartIncomingPipelineActivity(MessageContext context);
    private static ActivityContext CreateNewRootActivityContext();
    public sealed virtual Activity StartOutgoingPipelineActivity(string activityName, string displayName, IBehaviorContext outgoingContext);
    public sealed virtual Activity StartHandlerActivity(MessageHandler messageHandler, ActiveSagaInstance saga);
}
internal static class NServiceBus.ActivityNames : object {
    public static string IncomingMessageActivityName;
    public static string OutgoingMessageActivityName;
    public static string OutgoingEventActivityName;
    public static string SubscribeActivityName;
    public static string UnsubscribeActivityName;
    public static string InvokeHandlerActivityName;
}
internal static class NServiceBus.ActivitySources : object {
    public static ActivitySource Main;
    private static ActivitySources();
}
internal static class NServiceBus.ActivityTags : object {
    public static string SagaId;
    public static string MessageId;
    public static string CorrelationId;
    public static string ReplyToAddress;
    public static string NServiceBusVersion;
    public static string ControlMessageHeader;
    public static string SagaType;
    public static string OriginatingSagaId;
    public static string OriginatingSagaType;
    public static string DelayedRetries;
    public static string DelayedRetriesTimestamp;
    public static string DeliverAt;
    public static string RelatedTo;
    public static string EnclosedMessageTypes;
    public static string ContentType;
    public static string IsSagaTimeoutMessage;
    public static string IsDeferredMessage;
    public static string OriginatingEndpoint;
    public static string OriginatingMachine;
    public static string OriginatingHostId;
    public static string ProcessingEndpoint;
    public static string ProcessingMachine;
    public static string HostDisplayName;
    public static string HostId;
    public static string HasLicenseExpired;
    public static string OriginatingAddress;
    public static string ConversationId;
    public static string PreviousConversationId;
    public static string MessageIntent;
    public static string TimeToBeReceived;
    public static string DataBusContentType;
    public static string NonDurableMessage;
    public static string NativeMessageId;
    public static string HandlerType;
    public static string HandlerSagaId;
    public static string EventTypes;
    public static string CancelledTask;
}
internal class NServiceBus.AddHostInfoHeadersBehavior : object {
    private string endpoint;
    private HostInformation hostInformation;
    public AddHostInfoHeadersBehavior(HostInformation hostInformation, string endpoint);
    public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
}
public enum NServiceBus.AddressMode : Enum {
    public int value__;
    public static AddressMode Local;
    public static AddressMode Remote;
}
internal class NServiceBus.ApplyReplyToAddressBehavior : object {
    private string instanceSpecificQueue;
    private string sharedQueue;
    private string configuredReturnAddress;
    public ApplyReplyToAddressBehavior(ReceiveAddresses receiveAddresses, string publicReturnAddress);
    public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
    private string ApplyUserOverride(string replyTo, State state);
}
internal class NServiceBus.ApplyStaticHeadersBehavior : object {
    private CurrentStaticHeaders currentStaticHeaders;
    public ApplyStaticHeadersBehavior(CurrentStaticHeaders currentStaticHeaders);
    public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
}
internal class NServiceBus.ApplyTimeToBeReceivedBehavior : object {
    private TimeToBeReceivedMappings timeToBeReceivedMappings;
    public ApplyTimeToBeReceivedBehavior(TimeToBeReceivedMappings timeToBeReceivedMappings);
    public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
}
internal class NServiceBus.AssemblyPublisherSource : object {
    private Assembly messageAssembly;
    private PublisherAddress address;
    public RouteSourcePriority Priority { get; }
    public AssemblyPublisherSource(Assembly messageAssembly, PublisherAddress address);
    public sealed virtual IEnumerable`1<PublisherTableEntry> GenerateWithBestPracticeEnforcement(Conventions conventions);
    public sealed virtual IEnumerable`1<PublisherTableEntry> GenerateWithoutBestPracticeEnforcement(Conventions conventions);
    public sealed virtual RouteSourcePriority get_Priority();
    [CompilerGeneratedAttribute]
private PublisherTableEntry <GenerateWithBestPracticeEnforcement>b__3_0(Type t);
}
internal static class NServiceBus.AssemblyQualifiedNameParser : object {
    public static string GetMessageTypeNameWithoutAssembly(string messageTypeIdentifier);
}
internal class NServiceBus.AssemblyRouteSource : object {
    private Assembly messageAssembly;
    private UnicastRoute route;
    public RouteSourcePriority Priority { get; }
    public AssemblyRouteSource(Assembly messageAssembly, UnicastRoute route);
    public sealed virtual IEnumerable`1<RouteTableEntry> GenerateRoutes(Conventions conventions);
    public sealed virtual RouteSourcePriority get_Priority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NServiceBus.AssemblyScannerConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <ScanAppDomainAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ScanFileSystemAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ScanAssembliesInNestedDirectories>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <AdditionalAssemblyScanningPath>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ExcludedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <ExcludedTypes>k__BackingField;
    public bool ScanAppDomainAssemblies { get; public set; }
    public bool ScanFileSystemAssemblies { get; public set; }
    public bool ThrowExceptions { get; public set; }
    public bool ScanAssembliesInNestedDirectories { get; public set; }
    [NullableAttribute("2")]
public string AdditionalAssemblyScanningPath { get; public set; }
    internal List`1<string> ExcludedAssemblies { get; }
    internal List`1<Type> ExcludedTypes { get; }
    [CompilerGeneratedAttribute]
public bool get_ScanAppDomainAssemblies();
    [CompilerGeneratedAttribute]
public void set_ScanAppDomainAssemblies(bool value);
    [CompilerGeneratedAttribute]
public bool get_ScanFileSystemAssemblies();
    [CompilerGeneratedAttribute]
public void set_ScanFileSystemAssemblies(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptions();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptions(bool value);
    [CompilerGeneratedAttribute]
public bool get_ScanAssembliesInNestedDirectories();
    [CompilerGeneratedAttribute]
public void set_ScanAssembliesInNestedDirectories(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_AdditionalAssemblyScanningPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_AdditionalAssemblyScanningPath(string value);
    public void ExcludeAssemblies(String[] assemblies);
    public void ExcludeTypes(Type[] types);
    [CompilerGeneratedAttribute]
internal List`1<string> get_ExcludedAssemblies();
    [CompilerGeneratedAttribute]
internal List`1<Type> get_ExcludedTypes();
}
[ExtensionAttribute]
public static class NServiceBus.AssemblyScannerConfigurationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static AssemblyScannerConfiguration AssemblyScanner(EndpointConfiguration configuration);
}
internal class NServiceBus.AssemblyScanningComponent : object {
    [CompilerGeneratedAttribute]
private List`1<Type> <AvailableTypes>k__BackingField;
    public List`1<Type> AvailableTypes { get; }
    private AssemblyScanningComponent(List`1<Type> availableTypes);
    public static AssemblyScanningComponent Initialize(Configuration configuration, SettingsHolder settings);
    [CompilerGeneratedAttribute]
public List`1<Type> get_AvailableTypes();
}
internal static class NServiceBus.AssemblyValidator : object {
    public static void ValidateAssemblyFile(string assemblyPath, Boolean& shouldLoad, String& reason);
    public static bool IsRuntimeAssembly(AssemblyName assemblyName);
    private static string GetPublicKeyToken(Byte[] publicKey);
    private static bool IsRuntimeAssembly(string tokenString);
}
internal static class NServiceBus.AsyncDirectory : object {
    [AsyncStateMachineAttribute("NServiceBus.AsyncDirectory/<Move>d__0")]
public static Task Move(string sourcePath, string targetPath, CancellationToken cancellationToken);
}
internal static class NServiceBus.AsyncFile : object {
    private static ILog log;
    private static AsyncFile();
    [AsyncStateMachineAttribute("NServiceBus.AsyncFile/<WriteBytes>d__1")]
public static Task WriteBytes(string filePath, ReadOnlyMemory`1<byte> bytes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.AsyncFile/<WriteTextAtomic>d__2")]
public static Task WriteTextAtomic(string targetPath, string text, CancellationToken cancellationToken);
    private static FileStream CreateWriteStream(string filePath, FileMode fileMode);
    public static Task WriteText(string filePath, string text, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.AsyncFile/<ReadText>d__5")]
public static Task`1<string> ReadText(string filePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.AsyncFile/<ReadBytes>d__6")]
public static Task`1<Byte[]> ReadBytes(string filePath, CancellationToken cancellationToken);
    private static FileStream CreateReadStream(string filePath);
    [AsyncStateMachineAttribute("NServiceBus.AsyncFile/<Move>d__8")]
public static Task`1<bool> Move(string sourcePath, string targetPath, CancellationToken cancellationToken);
    private static bool IsFileLocked(string filePath);
}
internal class NServiceBus.AttachCausationHeadersBehavior : object {
    private Func`2<IOutgoingLogicalMessageContext, string> conversationIdStrategy;
    public static string NewConversationId;
    public AttachCausationHeadersBehavior(Func`2<IOutgoingLogicalMessageContext, string> conversationIdStrategy);
    public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
    private static void SetRelatedToHeader(IOutgoingLogicalMessageContext context, IncomingMessage incomingMessage);
    private void SetConversationIdHeader(IOutgoingLogicalMessageContext context, IncomingMessage incomingMessage);
}
internal class NServiceBus.AttachCorrelationIdBehavior : object {
    public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
}
internal class NServiceBus.AttachSagaDetailsToOutGoingMessageBehavior : object {
    public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
    private static bool HasBeenFound(ActiveSagaInstance saga);
}
internal class NServiceBus.AttachSenderRelatedInfoOnMessageBehavior : object {
    public sealed virtual Task Invoke(IRoutingContext context, Func`2<IRoutingContext, Task> next);
}
public abstract class NServiceBus.Audit.AuditAction : object {
    public abstract virtual IReadOnlyCollection`1<IRoutingContext> GetRoutingContexts(IAuditActionContext context);
}
public class NServiceBus.Audit.RouteToAudit : AuditAction {
    [CompilerGeneratedAttribute]
private static RouteToAudit <Instance>k__BackingField;
    internal static RouteToAudit Instance { get; }
    private static RouteToAudit();
    public virtual IReadOnlyCollection`1<IRoutingContext> GetRoutingContexts(IAuditActionContext context);
    [CompilerGeneratedAttribute]
internal static RouteToAudit get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NServiceBus.AuditConfigReader : object {
    [ExtensionAttribute]
public static bool TryGetAuditQueueAddress(IReadOnlySettings settings, String& address);
    [ExtensionAttribute]
public static bool TryGetAuditMessageExpiration(IReadOnlySettings settings, TimeSpan& auditMessageExpiration);
    internal static Result GetConfiguredAuditQueue(IReadOnlySettings settings);
}
internal class NServiceBus.AuditContext : BehaviorContext {
    [CompilerGeneratedAttribute]
private OutgoingMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuditAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TimeToBeReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AuditMetadata>k__BackingField;
    private AuditAction auditAction;
    private bool locked;
    public OutgoingMessage Message { get; }
    public string AuditAddress { get; }
    public Nullable`1<TimeSpan> TimeToBeReceived { get; }
    public Dictionary`2<string, string> AuditMetadata { get; }
    private IReadOnlyDictionary`2<string, string> NServiceBus.Pipeline.IAuditActionContext.AuditMetadata { get; }
    public AuditAction AuditAction { get; public set; }
    public AuditContext(OutgoingMessage message, string auditAddress, Nullable`1<TimeSpan> timeToBeReceived, IBehaviorContext parent);
    [CompilerGeneratedAttribute]
public sealed virtual OutgoingMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual string get_AuditAddress();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_TimeToBeReceived();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_AuditMetadata();
    private sealed virtual override IReadOnlyDictionary`2<string, string> NServiceBus.Pipeline.IAuditActionContext.get_AuditMetadata();
    public sealed virtual AuditAction get_AuditAction();
    public sealed virtual void set_AuditAction(AuditAction value);
    public sealed virtual IAuditActionContext PreventChanges();
}
[ExtensionAttribute]
public static class NServiceBus.AuditContextExtensions : object {
    [ExtensionAttribute]
public static IRoutingContext CreateRoutingContext(IAuditActionContext context, OutgoingMessage auditMessage, RoutingStrategy routingStrategy);
}
internal class NServiceBus.AuditHostInformationBehavior : object {
    private string endpoint;
    private HostInformation hostInfo;
    public AuditHostInformationBehavior(HostInformation hostInfo, string endpoint);
    public sealed virtual Task Invoke(IAuditContext context, Func`2<IAuditContext, Task> next);
}
internal class NServiceBus.AuditInvalidLicenseBehavior : object {
    private static ILog Log;
    private static AuditInvalidLicenseBehavior();
    [AsyncStateMachineAttribute("NServiceBus.AuditInvalidLicenseBehavior/<Invoke>d__0")]
public sealed virtual Task Invoke(IAuditContext context, Func`2<IAuditContext, Task> next);
}
internal class NServiceBus.AuditProcessingStatisticsBehavior : object {
    public sealed virtual Task Invoke(IAuditContext context, Func`2<IAuditContext, Task> next);
}
internal class NServiceBus.AuditToRoutingConnector : StageConnector`2<IAuditContext, IRoutingContext> {
    [AsyncStateMachineAttribute("NServiceBus.AuditToRoutingConnector/<Invoke>d__0")]
public virtual Task Invoke(IAuditContext context, Func`2<IRoutingContext, Task> stage);
}
public class NServiceBus.AutomaticSubscriptions.Config.AutoSubscribeSettings : object {
    private EndpointConfiguration config;
    internal AutoSubscribeSettings(EndpointConfiguration config);
    public void DoNotAutoSubscribeSagas();
    public AutoSubscribeSettings DisableFor();
    public AutoSubscribeSettings DisableFor(Type eventType);
    private SubscribeSettings GetSettings();
}
[ExtensionAttribute]
public static class NServiceBus.AutoSubscribeSettingsExtensions : object {
    [ExtensionAttribute]
public static AutoSubscribeSettings AutoSubscribe(EndpointConfiguration config);
}
internal class NServiceBus.BatchDispatchContext : BehaviorContext {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<TransportOperation> <Operations>k__BackingField;
    public IReadOnlyCollection`1<TransportOperation> Operations { get; }
    public BatchDispatchContext(IReadOnlyCollection`1<TransportOperation> operations, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<TransportOperation> get_Operations();
}
internal class NServiceBus.BatchToDispatchConnector : StageConnector`2<IBatchDispatchContext, IDispatchContext> {
    public virtual Task Invoke(IBatchDispatchContext context, Func`2<IDispatchContext, Task> stage);
}
internal abstract class NServiceBus.BehaviorContext : ContextBag {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public IServiceProvider Builder { get; }
    public ContextBag Extensions { get; }
    public CancellationToken CancellationToken { get; }
    protected BehaviorContext(IBehaviorContext parentContext);
    public BehaviorContext(ContextBag parentContext, CancellationToken cancellationToken);
    public sealed virtual IServiceProvider get_Builder();
    public sealed virtual ContextBag get_Extensions();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
}
internal static class NServiceBus.BehaviorTypeChecker : object {
    private static HashSet`1<Type> NotAllowedInterfaces;
    private static BehaviorTypeChecker();
    public static void ThrowIfInvalid(Type behavior, string paramName);
}
[ExtensionAttribute]
public static class NServiceBus.BestPracticesOptionExtensions : object {
    [ExtensionAttribute]
public static void DoNotEnforceBestPractices(ExtendableOptions options);
    [ExtensionAttribute]
public static bool IgnoredBestPractices(ExtendableOptions options);
    [ExtensionAttribute]
public static void DoNotEnforceBestPractices(IOutgoingReplyContext context);
    [ExtensionAttribute]
public static void DoNotEnforceBestPractices(IOutgoingSendContext context);
    [ExtensionAttribute]
public static void DoNotEnforceBestPractices(ISubscribeContext context);
    [ExtensionAttribute]
public static void DoNotEnforceBestPractices(IOutgoingPublishContext context);
    [ExtensionAttribute]
public static void DoNotEnforceBestPractices(IUnsubscribeContext context);
    [ExtensionAttribute]
private static void SetDoNotEnforceBestPractices(ContextBag context);
}
internal static class NServiceBus.Browser : object {
    public static bool TryOpen(string url);
}
internal static class NServiceBus.ColoredConsoleLogger : object {
    private static bool logToConsole;
    private static ColoredConsoleLogger();
    public static void WriteLine(string message, LogLevel logLevel);
    private static ConsoleColor GetColor(LogLevel logLevel);
}
internal static class NServiceBus.CombGuid : object {
    private static long BaseDateTicks;
    public static Guid Generate();
    internal static Guid Generate(Guid inputGuid, DateTime inputNow);
}
internal class NServiceBus.CompleteAction : StorageAction {
    public CompleteAction(IContainSagaData sagaData, Dictionary`2<string, SagaStorageFile> sagaFiles, SagaManifestCollection sagaManifests);
    public virtual Task Execute(CancellationToken cancellationToken);
}
internal class NServiceBus.CompositeNotification : object {
    private List`1<INotifier> notifications;
    public void Register(INotificationSubscriptions`1<TEvent> notification);
    public Task Raise(object event, CancellationToken cancellationToken);
}
internal class NServiceBus.ConcreteProxyCreator : object {
    private ModuleBuilder moduleBuilder;
    internal static string SUFFIX;
    public Type CreateTypeFrom(Type type);
    private static void AddCustomAttributeToProperty(CustomAttributeData attributeData, PropertyBuilder propBuilder);
    private static object ExtractValue(CustomAttributeTypedArgument arg);
    private static List`1<PropertyInfo> GetAllProperties(Type type);
}
[ExtensionAttribute]
public static class NServiceBus.Configuration.AdvancedExtensibility.AdvancedExtensibilityExtensions : object {
    [ExtensionAttribute]
public static SettingsHolder GetSettings(ExposeSettings config);
}
public abstract class NServiceBus.Configuration.AdvancedExtensibility.ExposeSettings : object {
    [CompilerGeneratedAttribute]
private SettingsHolder <Settings>k__BackingField;
    internal SettingsHolder Settings { get; }
    protected ExposeSettings(SettingsHolder settings);
    [CompilerGeneratedAttribute]
internal SettingsHolder get_Settings();
}
[ExtensionAttribute]
public static class NServiceBus.ConfigureAudit : object {
    [ExtensionAttribute]
public static void AuditProcessedMessagesTo(EndpointConfiguration config, string auditQueue, Nullable`1<TimeSpan> timeToBeReceived);
}
[ExtensionAttribute]
public static class NServiceBus.ConfigureCriticalErrorAction : object {
    [ExtensionAttribute]
public static void DefineCriticalErrorAction(EndpointConfiguration endpointConfiguration, Func`3<ICriticalErrorContext, CancellationToken, Task> onCriticalError);
}
internal class NServiceBus.ConfiguredPublishers : object {
    private List`1<IPublisherSource> publisherSources;
    public void Add(IPublisherSource publisherSource);
    public void Apply(Publishers publishers, Conventions conventions, bool enforceBestPractices);
    private static IEnumerable`1<PublisherTableEntry> Generate(Conventions conventions, IPublisherSource source, bool enforceBestPractices);
}
[ExtensionAttribute]
public static class NServiceBus.ConfigureError : object {
    [ExtensionAttribute]
public static void SendFailedMessagesTo(EndpointConfiguration config, string errorQueue);
}
[ExtensionAttribute]
public static class NServiceBus.ConfigureFileShareDataBus : object {
    [ExtensionAttribute]
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public static DataBusExtensions`1<FileShareDataBus> BasePath(DataBusExtensions`1<FileShareDataBus> config, string basePath);
}
[ExtensionAttribute]
public static class NServiceBus.ConfigureLicenseExtensions : object {
    [ExtensionAttribute]
public static void License(EndpointConfiguration config, string licenseText);
    [ExtensionAttribute]
public static void LicensePath(EndpointConfiguration config, string licenseFile);
}
[ExtensionAttribute]
public static class NServiceBus.ConfigurePurging : object {
    [ExtensionAttribute]
public static void PurgeOnStartup(EndpointConfiguration config, bool value);
}
[ExtensionAttribute]
public static class NServiceBus.ConnectorContextExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use `CreateAuditContext(this ForkConnector<IIncomingPhysicalMessageContext, IAuditContext> forkConnector, OutgoingMessage message, string auditAddress, TimeSpan? timeToBeReceived, IIncomingPhysicalMessageContext sourceContext)` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static IAuditContext CreateAuditContext(ForkConnector`2<IIncomingPhysicalMessageContext, IAuditContext> forkConnector, OutgoingMessage message, string auditAddress, IIncomingPhysicalMessageContext sourceContext);
    [ExtensionAttribute]
public static IRoutingContext CreateRoutingContext(ForkConnector`2<ITransportReceiveContext, IRoutingContext> forkConnector, OutgoingMessage outgoingMessage, string localAddress, ITransportReceiveContext sourceContext);
    [ExtensionAttribute]
public static IRoutingContext CreateRoutingContext(StageConnector`2<IAuditContext, IRoutingContext> stageConnector, OutgoingMessage outgoingMessage, RoutingStrategy routingStrategy, IAuditContext sourceContext);
    [ExtensionAttribute]
public static IRoutingContext CreateRoutingContext(StageConnector`2<IOutgoingPhysicalMessageContext, IRoutingContext> stageConnector, OutgoingMessage outgoingMessage, IReadOnlyCollection`1<RoutingStrategy> routingStrategies, IOutgoingPhysicalMessageContext sourceContext);
    [ExtensionAttribute]
public static IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(StageForkConnector`3<ITransportReceiveContext, IIncomingPhysicalMessageContext, IBatchDispatchContext> stageForkConnector, IncomingMessage incomingMessage, ITransportReceiveContext sourceContext);
    [ExtensionAttribute]
internal static IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(IStageForkConnector`3<ITransportReceiveContext, IIncomingPhysicalMessageContext, IBatchDispatchContext> stageForkConnector, IncomingMessage incomingMessage, ITransportReceiveContext sourceContext);
    [ExtensionAttribute]
public static IIncomingPhysicalMessageContext CreateIncomingPhysicalMessageContext(StageConnector`2<ITransportReceiveContext, IIncomingPhysicalMessageContext> stageConnector, IncomingMessage incomingMessage, ITransportReceiveContext sourceContext);
    [ExtensionAttribute]
public static IIncomingLogicalMessageContext CreateIncomingLogicalMessageContext(StageConnector`2<IIncomingPhysicalMessageContext, IIncomingLogicalMessageContext> stageConnector, LogicalMessage logicalMessage, IIncomingPhysicalMessageContext sourceContext);
    [ExtensionAttribute]
public static IInvokeHandlerContext CreateInvokeHandlerContext(StageConnector`2<IIncomingLogicalMessageContext, IInvokeHandlerContext> stageConnector, MessageHandler messageHandler, ICompletableSynchronizedStorageSession storageSession, IIncomingLogicalMessageContext sourceContext);
    [ExtensionAttribute]
public static IBatchDispatchContext CreateBatchDispatchContext(StageForkConnector`3<ITransportReceiveContext, IIncomingPhysicalMessageContext, IBatchDispatchContext> stageForkConnector, IReadOnlyCollection`1<TransportOperation> transportOperations, IIncomingPhysicalMessageContext sourceContext);
    [ExtensionAttribute]
internal static IBatchDispatchContext CreateBatchDispatchContext(IStageForkConnector`3<ITransportReceiveContext, IIncomingPhysicalMessageContext, IBatchDispatchContext> stageForkConnector, IReadOnlyCollection`1<TransportOperation> transportOperations, IIncomingPhysicalMessageContext sourceContext);
    [ExtensionAttribute]
public static IDispatchContext CreateDispatchContext(StageConnector`2<IBatchDispatchContext, IDispatchContext> stageConnector, IReadOnlyCollection`1<TransportOperation> transportOperations, IBatchDispatchContext sourceContext);
    [ExtensionAttribute]
public static IDispatchContext CreateDispatchContext(StageConnector`2<IRoutingContext, IDispatchContext> stageConnector, IReadOnlyCollection`1<TransportOperation> transportOperations, IRoutingContext sourceContext);
    [ExtensionAttribute]
public static IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(StageConnector`2<IOutgoingPublishContext, IOutgoingLogicalMessageContext> stageConnector, OutgoingLogicalMessage outgoingMessage, IReadOnlyCollection`1<RoutingStrategy> routingStrategies, IOutgoingPublishContext sourceContext);
    [ExtensionAttribute]
public static IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(StageConnector`2<IOutgoingReplyContext, IOutgoingLogicalMessageContext> stageConnector, OutgoingLogicalMessage outgoingMessage, IReadOnlyCollection`1<RoutingStrategy> routingStrategies, IOutgoingReplyContext sourceContext);
    [ExtensionAttribute]
public static IOutgoingLogicalMessageContext CreateOutgoingLogicalMessageContext(StageConnector`2<IOutgoingSendContext, IOutgoingLogicalMessageContext> stageConnector, OutgoingLogicalMessage outgoingMessage, IReadOnlyCollection`1<RoutingStrategy> routingStrategies, IOutgoingSendContext sourceContext);
    [ExtensionAttribute]
public static IOutgoingPhysicalMessageContext CreateOutgoingPhysicalMessageContext(StageConnector`2<IOutgoingLogicalMessageContext, IOutgoingPhysicalMessageContext> stageConnector, ReadOnlyMemory`1<byte> messageBody, IReadOnlyCollection`1<RoutingStrategy> routingStrategies, IOutgoingLogicalMessageContext sourceContext);
    [ExtensionAttribute]
public static IAuditContext CreateAuditContext(ForkConnector`2<IIncomingPhysicalMessageContext, IAuditContext> forkConnector, OutgoingMessage message, string auditAddress, Nullable`1<TimeSpan> timeToBeReceived, IIncomingPhysicalMessageContext sourceContext);
    [ExtensionAttribute]
internal static IAuditContext CreateAuditContext(IForkConnector`3<IIncomingPhysicalMessageContext, IIncomingPhysicalMessageContext, IAuditContext> forkConnector, OutgoingMessage message, string auditAddress, Nullable`1<TimeSpan> timeToBeReceived, IIncomingPhysicalMessageContext sourceContext);
}
internal class NServiceBus.ConsecutiveFailuresCircuitBreaker : object {
    private int failureCount;
    private string name;
    private int consecutiveFailuresBeforeTriggering;
    private Func`3<long, CancellationToken, Task> triggerAction;
    private Func`3<long, CancellationToken, Task> disarmAction;
    private TimeSpan armedFailureDelayDuration;
    private static ILog Logger;
    private int disposeSignaled;
    private bool disposed;
    public ConsecutiveFailuresCircuitBreaker(string name, int consecutiveFailuresBeforeTriggering, Func`3<long, CancellationToken, Task> triggerAction, Func`3<long, CancellationToken, Task> disarmAction, TimeSpan armedFailureDelayDuration);
    private static ConsecutiveFailuresCircuitBreaker();
    public Task Success(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.ConsecutiveFailuresCircuitBreaker/<Failure>d__2")]
public Task Failure(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal class NServiceBus.ConsecutiveFailuresConfiguration : object {
    [CompilerGeneratedAttribute]
private int <NumberOfConsecutiveFailuresBeforeArming>k__BackingField;
    [CompilerGeneratedAttribute]
private RateLimitSettings <RateLimitSettings>k__BackingField;
    public int NumberOfConsecutiveFailuresBeforeArming { get; public set; }
    public RateLimitSettings RateLimitSettings { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumberOfConsecutiveFailuresBeforeArming();
    [CompilerGeneratedAttribute]
public void set_NumberOfConsecutiveFailuresBeforeArming(int value);
    [CompilerGeneratedAttribute]
public RateLimitSettings get_RateLimitSettings();
    [CompilerGeneratedAttribute]
public void set_RateLimitSettings(RateLimitSettings value);
    public ConsecutiveFailuresCircuitBreaker CreateCircuitBreaker(Func`3<long, CancellationToken, Task> onConsecutiveArmed, Func`3<long, CancellationToken, Task> onConsecutiveDisarmed);
}
[ExtensionAttribute]
public static class NServiceBus.ConsistencyGuarantees.TransactionModeSettingsExtensions : object {
    [ExtensionAttribute]
public static TransportTransactionMode GetRequiredTransactionModeForReceives(IReadOnlySettings settings);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class NServiceBus.ContainSagaData : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Originator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalMessageId>k__BackingField;
    [EditorBrowsableAttribute("1")]
public Guid Id { get; public set; }
    [EditorBrowsableAttribute("1")]
public string Originator { get; public set; }
    [EditorBrowsableAttribute("1")]
public string OriginalMessageId { get; public set; }
    [CompilerGeneratedAttribute]
public virtual Guid get_Id();
    [CompilerGeneratedAttribute]
public virtual void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public virtual string get_Originator();
    [CompilerGeneratedAttribute]
public virtual void set_Originator(string value);
    [CompilerGeneratedAttribute]
public virtual string get_OriginalMessageId();
    [CompilerGeneratedAttribute]
public virtual void set_OriginalMessageId(string value);
}
public static class NServiceBus.ContentTypes : object {
    public static string Json;
    public static string Xml;
}
internal static class NServiceBus.ContextPropagation : object {
    public static void PropagateContextToHeaders(Activity activity, Dictionary`2<string, string> headers, ContextBag contextBag);
    public static void PropagateContextFromHeaders(Activity activity, IDictionary`2<string, string> headers);
}
public class NServiceBus.Conventions : object {
    internal Func`2<PropertyInfo, bool> IsDataBusPropertyAction;
    private ConcurrentDictionary`2<Type, List`1<DataBusPropertyInfo>> cache;
    private ConventionCache CommandsConventionCache;
    private ConventionCache EventsConventionCache;
    private List`1<Func`2<Type, bool>> IsSystemMessageActions;
    private ConventionCache MessagesConventionCache;
    private List`1<IMessageConvention> conventions;
    private OverridableMessageConvention defaultMessageConvention;
    private static ILog logger;
    internal bool CustomMessageTypeConventionUsed { get; }
    internal String[] RegisteredConventions { get; }
    private static Conventions();
    public bool IsMessageType(Type t);
    public bool IsInSystemConventionList(Type t);
    public void AddSystemMessagesConventions(Func`2<Type, bool> definesMessageType);
    public bool IsCommandType(Type t);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public bool IsDataBusProperty(PropertyInfo property);
    public bool IsEventType(Type t);
    internal bool get_CustomMessageTypeConventionUsed();
    internal String[] get_RegisteredConventions();
    internal List`1<DataBusPropertyInfo> GetDataBusProperties(object message);
    internal void DefineMessageTypeConvention(Func`2<Type, bool> definesMessageType);
    internal void DefineCommandTypeConventions(Func`2<Type, bool> definesCommandType);
    internal void DefineEventTypeConventions(Func`2<Type, bool> definesEventType);
    internal void Add(IMessageConvention messageConvention);
    [CompilerGeneratedAttribute]
private bool <IsMessageType>b__1_0(RuntimeTypeHandle typeHandle);
    [CompilerGeneratedAttribute]
private bool <IsCommandType>b__4_0(RuntimeTypeHandle typeHandle);
    [CompilerGeneratedAttribute]
private bool <IsEventType>b__6_0(RuntimeTypeHandle typeHandle);
    [CompilerGeneratedAttribute]
private List`1<DataBusPropertyInfo> <GetDataBusProperties>b__11_0(Type messageType);
}
public class NServiceBus.ConventionsBuilder : ExposeSettings {
    [CompilerGeneratedAttribute]
private Conventions <Conventions>k__BackingField;
    public Conventions Conventions { get; }
    public ConventionsBuilder(SettingsHolder settings);
    public ConventionsBuilder DefiningMessagesAs(Func`2<Type, bool> definesMessageType);
    public ConventionsBuilder DefiningCommandsAs(Func`2<Type, bool> definesCommandType);
    public ConventionsBuilder DefiningEventsAs(Func`2<Type, bool> definesEventType);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public ConventionsBuilder DefiningDataBusPropertiesAs(Func`2<PropertyInfo, bool> definesDataBusProperty);
    public ConventionsBuilder Add(IMessageConvention messageConvention);
    [CompilerGeneratedAttribute]
public Conventions get_Conventions();
}
public class NServiceBus.ConversationId : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    internal string Value { get; }
    public static ConversationId Default { get; }
    private ConversationId(string value);
    [CompilerGeneratedAttribute]
internal string get_Value();
    public static ConversationId Custom(string customValue);
    public static ConversationId get_Default();
}
public class NServiceBus.ConversationIdStrategyContext : object {
    [CompilerGeneratedAttribute]
private OutgoingLogicalMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Headers>k__BackingField;
    public OutgoingLogicalMessage Message { get; }
    public IReadOnlyDictionary`2<string, string> Headers { get; }
    public ConversationIdStrategyContext(OutgoingLogicalMessage message, IReadOnlyDictionary`2<string, string> headers);
    [CompilerGeneratedAttribute]
public OutgoingLogicalMessage get_Message();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Headers();
}
[ExtensionAttribute]
public static class NServiceBus.ConversationRoutingExtensions : object {
    [ExtensionAttribute]
public static void StartNewConversation(SendOptions sendOptions, string conversationId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NServiceBus.CorrelatedSagaPropertyMapper`1 : object {
    private SagaPropertyMapper`1<TSagaData> sagaPropertyMapper;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Expression`1<Func`2<TSagaData, object>> sagaProperty;
    internal CorrelatedSagaPropertyMapper`1(SagaPropertyMapper`1<TSagaData> sagaPropertyMapper, Expression`1<Func`2<TSagaData, object>> sagaProperty);
    public CorrelatedSagaPropertyMapper`1<TSagaData> ToMessage(Expression`1<Func`2<TMessage, object>> messageProperty);
    public CorrelatedSagaPropertyMapper`1<TSagaData> ToMessageHeader(string headerName);
}
internal abstract class NServiceBus.CorrelationSagaToMessageMap : SagaToMessageMap {
    public string SagaPropName;
    public Type SagaPropType;
}
public class NServiceBus.CriticalError : object {
    private Func`3<CriticalErrorContext, CancellationToken, Task> criticalErrorAction;
    private List`1<LatentCritical> criticalErrors;
    private IEndpointInstance endpoint;
    private object endpointCriticalLock;
    public CriticalError(Func`3<ICriticalErrorContext, CancellationToken, Task> onCriticalErrorAction);
    public virtual void Raise(string errorMessage, Exception exception, CancellationToken cancellationToken);
    private void RaiseForEndpoint(string errorMessage, Exception exception, CancellationToken cancellationToken);
    internal void SetEndpoint(IEndpointInstance endpointInstance, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.CriticalError/<<RaiseForEndpoint>g__RaiseCriticalError|2_0>d")]
[CompilerGeneratedAttribute]
internal static Task <RaiseForEndpoint>g__RaiseCriticalError|2_0(CriticalErrorContext errorContext, Func`3<CriticalErrorContext, CancellationToken, Task> criticalErrorAction, CancellationToken cancellationToken);
}
public class NServiceBus.CriticalErrorContext : object {
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task> <Stop>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Func`2<CancellationToken, Task> Stop { get; }
    public string Error { get; }
    public Exception Exception { get; }
    public CriticalErrorContext(Func`2<CancellationToken, Task> stop, string error, Exception exception);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<CancellationToken, Task> get_Stop();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Error();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
}
internal class NServiceBus.CurrentStaticHeaders : Dictionary`2<string, string> {
}
internal class NServiceBus.CustomDataBus : DataBusDefinition {
    [CompilerGeneratedAttribute]
private Func`2<IServiceProvider, IDataBus> <DataBusFactory>k__BackingField;
    public Func`2<IServiceProvider, IDataBus> DataBusFactory { get; }
    public CustomDataBus(Func`2<IServiceProvider, IDataBus> dataBusFactory);
    protected internal virtual Type ProvidedByFeature();
    [CompilerGeneratedAttribute]
public Func`2<IServiceProvider, IDataBus> get_DataBusFactory();
}
internal class NServiceBus.CustomFinderAdapter`2 : SagaFinder {
    [AsyncStateMachineAttribute("NServiceBus.CustomFinderAdapter`2/<Find>d__0")]
public virtual Task`1<IContainSagaData> Find(IServiceProvider builder, SagaFinderDefinition finderDefinition, ISynchronizedStorageSession storageSession, ContextBag context, object message, IReadOnlyDictionary`2<string, string> messageHeaders, CancellationToken cancellationToken);
}
internal class NServiceBus.CustomFinderSagaToMessageMap : SagaToMessageMap {
    public Type CustomFinderType;
    public virtual SagaFinderDefinition CreateSagaFinderDefinition(Type sagaEntityType);
    protected virtual string SagaDoesNotHandleMappedMessage(Type sagaType);
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public abstract class NServiceBus.DataBus.DataBusDefinition : object {
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
protected internal abstract virtual Type ProvidedByFeature();
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public class NServiceBus.DataBus.DataBusExtensions : ExposeSettings {
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public DataBusExtensions(SettingsHolder settings);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public DataBusExtensions AddDeserializer();
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public DataBusExtensions AddDeserializer(TSerializer serializer);
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public class NServiceBus.DataBus.DataBusExtensions`1 : DataBusExtensions {
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public DataBusExtensions`1(SettingsHolder settings);
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public interface NServiceBus.DataBus.IDataBus {
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<Stream> Get(string key, CancellationToken cancellationToken);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<string> Put(Stream stream, TimeSpan timeToBeReceived, CancellationToken cancellationToken);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task Start(CancellationToken cancellationToken);
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public interface NServiceBus.DataBus.IDataBusSerializer {
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public string ContentType { get; }
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual void Serialize(object databusProperty, Stream stream);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual object Deserialize(Type propertyType, Stream stream);
    public abstract virtual string get_ContentType();
}
internal class NServiceBus.DataBusDeserializer : object {
    private Dictionary`2<string, IDataBusSerializer> deserializers;
    private static ILog logger;
    public DataBusDeserializer(IDataBusSerializer mainDeserializer, IReadOnlyCollection`1<IDataBusSerializer> additionalDeserializers);
    private static DataBusDeserializer();
    public object Deserialize(string serializerUsed, Type propertyType, Stream stream);
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public class NServiceBus.DataBusProperty`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [JsonIgnoreAttribute]
[XmlIgnoreAttribute]
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public T Value { get; private set; }
    [JsonIgnoreAttribute]
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public Type Type { get; }
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public string Key { get; public set; }
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public bool HasValue { get; public set; }
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public DataBusProperty`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Key(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HasValue(bool value);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public sealed virtual void SetValue(object valueToSet);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public sealed virtual object GetValue();
}
internal class NServiceBus.DataBusPropertyInfo : object {
    public Func`2<object, object> Getter;
    public string Name;
    public Type Type;
    public Action`2<object, object> Setter;
}
internal class NServiceBus.DataBusReceiveBehavior : object {
    private Conventions conventions;
    private IDataBus dataBus;
    private DataBusDeserializer deserializer;
    public DataBusReceiveBehavior(IDataBus dataBus, DataBusDeserializer deserializer, Conventions conventions);
    [AsyncStateMachineAttribute("NServiceBus.DataBusReceiveBehavior/<Invoke>d__1")]
public sealed virtual Task Invoke(IIncomingLogicalMessageContext context, Func`2<IIncomingLogicalMessageContext, Task> next);
}
internal class NServiceBus.DataBusSendBehavior : object {
    private Conventions conventions;
    private IDataBus dataBus;
    private IDataBusSerializer dataBusSerializer;
    public DataBusSendBehavior(IDataBus databus, IDataBusSerializer serializer, Conventions conventions);
    [AsyncStateMachineAttribute("NServiceBus.DataBusSendBehavior/<Invoke>d__1")]
public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
}
[ExtensionAttribute]
internal static class NServiceBus.DateTimeOffsetExtensions : object {
    private static int ticksPerMicrosecond;
    [ExtensionAttribute]
public static int Microseconds(DateTimeOffset self);
    [ExtensionAttribute]
public static DateTimeOffset AddMicroseconds(DateTimeOffset self, int microseconds);
}
public static class NServiceBus.DateTimeOffsetHelper : object {
    private static string format;
    private static string errorMessage;
    public static string ToWireFormattedString(DateTimeOffset dateTime);
    public static DateTimeOffset ToDateTimeOffset(string wireFormattedString);
}
internal class NServiceBus.DefaultLoggerFactory : object {
    private LogLevel filterLevel;
    private bool isDebugEnabled;
    private bool isErrorEnabled;
    private bool isFatalEnabled;
    private bool isInfoEnabled;
    private bool isWarnEnabled;
    private object locker;
    private RollingLogger rollingLogger;
    public DefaultLoggerFactory(LogLevel filterLevel, string loggingDirectory);
    public sealed virtual ILog GetLogger(Type type);
    public sealed virtual ILog GetLogger(string name);
    public void Write(string name, LogLevel messageLevel, string message, Exception exception);
}
public static class NServiceBus.DefaultRecoverabilityPolicy : object {
    public static RecoverabilityAction Invoke(RecoverabilityConfig config, ErrorContext errorContext);
    private static bool TryGetDelay(IncomingMessage message, int delayedDeliveriesPerformed, DelayedConfig config, TimeSpan& delay);
    private static bool HasReachedMaxTime(IncomingMessage message);
}
internal class NServiceBus.DefaultSagaIdGenerator : object {
    public sealed virtual Guid Generate(SagaIdGeneratorContext context);
}
public class NServiceBus.DelayedConfig : object {
    [CompilerGeneratedAttribute]
private int <MaxNumberOfRetries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeIncrease>k__BackingField;
    public int MaxNumberOfRetries { get; }
    public TimeSpan TimeIncrease { get; }
    public DelayedConfig(int maxNumberOfRetries, TimeSpan timeIncrease);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfRetries();
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeIncrease();
}
public class NServiceBus.DelayedDelivery.DelayDeliveryWith : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Delay>k__BackingField;
    public TimeSpan Delay { get; }
    public DelayDeliveryWith(TimeSpan delay);
    [CompilerGeneratedAttribute]
public TimeSpan get_Delay();
}
public class NServiceBus.DelayedDelivery.DoNotDeliverBefore : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <At>k__BackingField;
    public DateTimeOffset At { get; }
    public DoNotDeliverBefore(DateTimeOffset at);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_At();
}
[ExtensionAttribute]
public static class NServiceBus.DelayedDeliveryOptionExtensions : object {
    [ExtensionAttribute]
public static void DelayDeliveryWith(SendOptions options, TimeSpan delay);
    [ExtensionAttribute]
public static Nullable`1<TimeSpan> GetDeliveryDelay(SendOptions options);
    [ExtensionAttribute]
public static void DoNotDeliverBefore(SendOptions options, DateTimeOffset at);
    [ExtensionAttribute]
public static Nullable`1<DateTimeOffset> GetDeliveryDate(SendOptions options);
}
internal class NServiceBus.DelayedMessagePoller : object {
    private string delayedRootDirectory;
    private CancellationTokenSource polling;
    private string basePath;
    private static ILog Logger;
    public DelayedMessagePoller(string basePath, string delayedDir);
    private static DelayedMessagePoller();
    private void MoveDelayedMessagesToMainDirectory();
    public void Start();
    [AsyncStateMachineAttribute("NServiceBus.DelayedMessagePoller/<PollForDelayedMessages>d__3")]
private Task PollForDelayedMessages(CancellationToken cancellationToken);
    public void Stop();
}
[ExtensionAttribute]
internal static class NServiceBus.DelayedRetriesHeaderExtensions : object {
    [ExtensionAttribute]
public static int GetDelayedDeliveriesPerformed(IncomingMessage message);
    [ExtensionAttribute]
public static void SetCurrentDelayedDeliveries(OutgoingMessage message, int currentDelayedRetry);
    [ExtensionAttribute]
public static void SetDelayedDeliveryTimestamp(OutgoingMessage message, DateTimeOffset timestamp);
}
public class NServiceBus.DelayedRetriesSettings : ExposeSettings {
    internal DelayedRetriesSettings(SettingsHolder settings);
    public DelayedRetriesSettings NumberOfRetries(int numberOfRetries);
    public DelayedRetriesSettings TimeIncrease(TimeSpan timeIncrease);
    public DelayedRetriesSettings OnMessageBeingRetried(Func`3<DelayedRetryMessage, CancellationToken, Task> notificationCallback);
}
public class NServiceBus.DelayedRetry : RecoverabilityAction {
    [CompilerGeneratedAttribute]
private TimeSpan <Delay>k__BackingField;
    private static ILog Logger;
    public TimeSpan Delay { get; }
    public ErrorHandleResult ErrorHandleResult { get; }
    protected internal DelayedRetry(TimeSpan delay);
    private static DelayedRetry();
    [CompilerGeneratedAttribute]
public TimeSpan get_Delay();
    public virtual ErrorHandleResult get_ErrorHandleResult();
    public virtual IReadOnlyCollection`1<IRoutingContext> GetRoutingContexts(IRecoverabilityActionContext context);
}
internal static class NServiceBus.DelegateFactory : object {
    private static ConcurrentDictionary`2<PropertyInfo, Func`2<object, object>> PropertyInfoToLateBoundProperty;
    private static ConcurrentDictionary`2<FieldInfo, Func`2<object, object>> FieldInfoToLateBoundField;
    private static ConcurrentDictionary`2<PropertyInfo, Action`2<object, object>> PropertyInfoToLateBoundPropertySet;
    private static ConcurrentDictionary`2<FieldInfo, Action`2<object, object>> FieldInfoToLateBoundFieldSet;
    private static DelegateFactory();
    public static Func`2<object, object> CreateGet(PropertyInfo property);
    public static Func`2<object, object> CreateGet(FieldInfo field);
    public static Action`2<object, object> CreateSet(FieldInfo field);
    public static Action`2<object, object> CreateSet(PropertyInfo property);
}
internal class NServiceBus.Dependency : object {
    [CompilerGeneratedAttribute]
private string <DependentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependsOnId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enforce>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyDirection <Direction>k__BackingField;
    public string DependentId { get; }
    public string DependsOnId { get; }
    public bool Enforce { get; }
    public DependencyDirection Direction { get; }
    public Dependency(string dependentId, string dependsOnId, DependencyDirection direction, bool enforce);
    [CompilerGeneratedAttribute]
public string get_DependentId();
    [CompilerGeneratedAttribute]
public string get_DependsOnId();
    [CompilerGeneratedAttribute]
public bool get_Enforce();
    [CompilerGeneratedAttribute]
public DependencyDirection get_Direction();
}
public enum NServiceBus.DependencyLifecycle : Enum {
    public int value__;
    public static DependencyLifecycle SingleInstance;
    public static DependencyLifecycle InstancePerUnitOfWork;
    public static DependencyLifecycle InstancePerCall;
}
internal class NServiceBus.DeserializeMessageConnector : StageConnector`2<IIncomingPhysicalMessageContext, IIncomingLogicalMessageContext> {
    private MessageDeserializerResolver deserializerResolver;
    private LogicalMessageFactory logicalMessageFactory;
    private MessageMetadataRegistry messageMetadataRegistry;
    private IMessageMapper mapper;
    private bool allowContentTypeInference;
    private ConcurrentDictionary`2<string, Type[]> enclosedMessageTypesStringToMessageTypes;
    private static Char[] EnclosedMessageTypeSeparator;
    private static ILog log;
    public DeserializeMessageConnector(MessageDeserializerResolver deserializerResolver, LogicalMessageFactory logicalMessageFactory, MessageMetadataRegistry messageMetadataRegistry, IMessageMapper mapper, bool allowContentTypeInference);
    private static DeserializeMessageConnector();
    [AsyncStateMachineAttribute("NServiceBus.DeserializeMessageConnector/<Invoke>d__1")]
public virtual Task Invoke(IIncomingPhysicalMessageContext context, Func`2<IIncomingLogicalMessageContext, Task> stage);
    private static bool IsControlMessage(IncomingMessage incomingMessage);
    private LogicalMessage[] ExtractWithExceptionHandling(IncomingMessage message);
    private LogicalMessage[] Extract(IncomingMessage physicalMessage);
    private static bool DoesTypeHaveImplAddedByVersion3(string existingTypeString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NServiceBus.DeterministicGuid : object {
    public static Guid Create(string data1, string data2);
    [SkipLocalsInitAttribute]
public static Guid Create(string data);
}
[ExtensionAttribute]
public static class NServiceBus.DiagnosticSettingsExtensions : object {
    [ExtensionAttribute]
public static void AddStartupDiagnosticsSection(IReadOnlySettings settings, string sectionName, object section);
    [ExtensionAttribute]
public static void SetDiagnosticsPath(EndpointConfiguration config, string path);
    [ExtensionAttribute]
public static void CustomDiagnosticsWriter(EndpointConfiguration config, Func`3<string, CancellationToken, Task> customDiagnosticsWriter);
}
internal class NServiceBus.DirectoryBasedTransaction : object {
    [CompilerGeneratedAttribute]
private string <FileToProcess>k__BackingField;
    private string basePath;
    private string commitDir;
    private bool committed;
    private ConcurrentQueue`1<OutgoingFile> outgoingFiles;
    private string transactionDir;
    private static string TxtFileExtension;
    private static ILog log;
    public string FileToProcess { get; private set; }
    public DirectoryBasedTransaction(string basePath, string pendingDirName, string committedDirName, string transactionId);
    private static DirectoryBasedTransaction();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileToProcess();
    [CompilerGeneratedAttribute]
private void set_FileToProcess(string value);
    public sealed virtual Task`1<bool> BeginTransaction(string incomingFilePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.DirectoryBasedTransaction/<Commit>d__6")]
public sealed virtual Task Commit(CancellationToken cancellationToken);
    public sealed virtual void Rollback();
    public sealed virtual void ClearPendingOutgoingOperations();
    public sealed virtual Task Enlist(string messagePath, string messageContents, CancellationToken cancellationToken);
    public sealed virtual bool Complete();
    public static void RecoverPartiallyCompletedTransactions(string basePath, string pendingDirName, string committedDirName);
    private void RecoverPending();
    private void RecoverCommitted();
}
internal class NServiceBus.DisabledPublishingTerminator : PipelineTerminator`1<IOutgoingPublishContext> {
    protected virtual Task Terminate(IOutgoingPublishContext context);
}
public class NServiceBus.Discard : RecoverabilityAction {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    private static ILog Logger;
    public string Reason { get; }
    public ErrorHandleResult ErrorHandleResult { get; }
    public Discard(string reason);
    private static Discard();
    [CompilerGeneratedAttribute]
public string get_Reason();
    public virtual ErrorHandleResult get_ErrorHandleResult();
    public virtual IReadOnlyCollection`1<IRoutingContext> GetRoutingContexts(IRecoverabilityActionContext context);
}
internal class NServiceBus.DispatchContext : BehaviorContext {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TransportOperation> <Operations>k__BackingField;
    public IEnumerable`1<TransportOperation> Operations { get; }
    public DispatchContext(IReadOnlyCollection`1<TransportOperation> operations, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<TransportOperation> get_Operations();
}
public class NServiceBus.DistributionPolicy : object {
    private ConcurrentDictionary`2<Tuple`2<string, DistributionStrategyScope>, DistributionStrategy> configuredStrategies;
    public void SetDistributionStrategy(DistributionStrategy distributionStrategy);
    private sealed virtual override DistributionStrategy NServiceBus.IDistributionPolicy.GetDistributionStrategy(string endpointName, DistributionStrategyScope scope);
}
public enum NServiceBus.DistributionStrategyScope : Enum {
    public int value__;
    public static DistributionStrategyScope Send;
    public static DistributionStrategyScope Publish;
}
internal class NServiceBus.EnabledPersistence : object {
    [CompilerGeneratedAttribute]
private List`1<Type> <SelectedStorages>k__BackingField;
    public Type DefinitionType;
    public List`1<Type> SelectedStorages { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Type> get_SelectedStorages();
    [CompilerGeneratedAttribute]
public void set_SelectedStorages(List`1<Type> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NServiceBus.Endpoint : object {
    [AsyncStateMachineAttribute("NServiceBus.Endpoint/<Create>d__0")]
public static Task`1<IStartableEndpoint> Create(EndpointConfiguration configuration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.Endpoint/<Start>d__1")]
public static Task`1<IEndpointInstance> Start(EndpointConfiguration configuration, CancellationToken cancellationToken);
}
public class NServiceBus.EndpointConfiguration : ExposeSettings {
    [CompilerGeneratedAttribute]
private PipelineSettings <Pipeline>k__BackingField;
    internal ConventionsBuilder ConventionsBuilder;
    [CompilerGeneratedAttribute]
private Notifications <Notifications>k__BackingField;
    public PipelineSettings Pipeline { get; }
    [ObsoleteAttribute("Error notification events have been replaced with a Task-based API available on the recoverability settings. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public Notifications Notifications { get; }
    public EndpointConfiguration(string endpointName);
    [CompilerGeneratedAttribute]
public PipelineSettings get_Pipeline();
    public void RegisterComponents(Action`1<IServiceCollection> registration);
    public void SendOnly();
    public ConventionsBuilder Conventions();
    public RoutingSettings`1<TTransport> UseTransport(TTransport transportDefinition);
    internal void TypesToScanInternal(IEnumerable`1<Type> typesToScan);
    internal void FinalizeConfiguration(List`1<Type> availableTypes);
    private static void ValidateEndpointName(string endpointName);
    private static void ActivateAndInvoke(IList`1<Type> types, Action`1<T> action);
    private static bool HasDefaultConstructor(Type type);
    private static void ForAllTypes(IEnumerable`1<Type> types, Action`1<Type> action);
    [CompilerGeneratedAttribute]
public Notifications get_Notifications();
    [CompilerGeneratedAttribute]
private void <FinalizeConfiguration>b__9_0(INeedInitialization t);
    [CompilerGeneratedAttribute]
private void <FinalizeConfiguration>b__9_1(IWantToRunBeforeConfigurationIsFinalized t);
}
[ExtensionAttribute]
public static class NServiceBus.EndpointConfigurationExtensions : object {
    [ExtensionAttribute]
public static void EnableFeature(EndpointConfiguration config);
    [ExtensionAttribute]
public static void EnableFeature(EndpointConfiguration config, Type featureType);
    [ExtensionAttribute]
public static void DisableFeature(EndpointConfiguration config);
    [ExtensionAttribute]
public static void DisableFeature(EndpointConfiguration config, Type featureType);
}
internal class NServiceBus.EndpointCreator : object {
    private PipelineComponent pipelineComponent;
    private FeatureComponent featureComponent;
    private ReceiveComponent receiveComponent;
    private RecoverabilityComponent recoverabilityComponent;
    private SendComponent sendComponent;
    private TransportSeam transportSeam;
    private HostingComponent hostingComponent;
    private SettingsHolder settings;
    private Configuration hostingConfiguration;
    private Conventions conventions;
    private EndpointCreator(SettingsHolder settings, Configuration hostingConfiguration, Conventions conventions);
    public static EndpointCreator Create(EndpointConfiguration endpointConfiguration, IServiceCollection serviceCollection);
    private void Configure();
    private void ConfigureMessageTypes();
    public StartableEndpoint CreateStartableEndpoint(IServiceProvider builder, bool serviceProviderIsExternallyManaged);
    [CompilerGeneratedAttribute]
internal static void <Create>g__CheckIfSettingsWhereUsedToCreateAnotherEndpoint|1_0(SettingsHolder settings);
}
[ExtensionAttribute]
public static class NServiceBus.EndpointInstanceExtensions : object {
    [AsyncStateMachineAttribute("NServiceBus.EndpointInstanceExtensions/<Stop>d__0")]
[ExtensionAttribute]
public static Task Stop(IEndpointInstance endpoint, TimeSpan gracefulStopTimeout);
}
public static class NServiceBus.EndpointWithExternallyManagedContainer : object {
    public static IStartableEndpointWithExternallyManagedContainer Create(EndpointConfiguration configuration, IServiceCollection serviceCollection);
}
internal class NServiceBus.EnforceBestPracticesOptions : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public bool Enabled { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
}
internal class NServiceBus.EnforcePublishBestPracticesBehavior : object {
    private Validations validations;
    public EnforcePublishBestPracticesBehavior(Validations validations);
    public sealed virtual Task Invoke(IOutgoingPublishContext context, Func`2<IOutgoingPublishContext, Task> next);
}
internal class NServiceBus.EnforceReplyBestPracticesBehavior : object {
    private Validations validations;
    public EnforceReplyBestPracticesBehavior(Validations validations);
    public sealed virtual Task Invoke(IOutgoingReplyContext context, Func`2<IOutgoingReplyContext, Task> next);
}
internal class NServiceBus.EnforceSendBestPracticesBehavior : object {
    private Validations validations;
    public EnforceSendBestPracticesBehavior(Validations validations);
    public sealed virtual Task Invoke(IOutgoingSendContext context, Func`2<IOutgoingSendContext, Task> next);
}
internal class NServiceBus.EnforceSubscribeBestPracticesBehavior : object {
    private Validations validations;
    public EnforceSubscribeBestPracticesBehavior(Validations validations);
    public sealed virtual Task Invoke(ISubscribeContext context, Func`2<ISubscribeContext, Task> next);
}
internal class NServiceBus.EnforceUnsubscribeBestPracticesBehavior : object {
    private Validations validations;
    public EnforceUnsubscribeBestPracticesBehavior(Validations validations);
    public sealed virtual Task Invoke(IUnsubscribeContext context, Func`2<IUnsubscribeContext, Task> next);
}
[ExtensionAttribute]
public static class NServiceBus.ErrorQueueSettings : object {
    public static string SettingsKey;
    private static string DefaultErrorQueueName;
    private static ILog Logger;
    private static ErrorQueueSettings();
    [ExtensionAttribute]
public static string ErrorQueueAddress(IReadOnlySettings settings);
    [ExtensionAttribute]
public static bool TryGetExplicitlyConfiguredErrorQueueAddress(IReadOnlySettings settings, String& errorQueue);
}
[ExtensionAttribute]
internal static class NServiceBus.ExceptionExtensions : object {
    [ExtensionAttribute]
public static string GetMessage(Exception exception);
    [ExtensionAttribute]
public static bool IsCausedBy(Exception ex, CancellationToken cancellationToken);
}
public class NServiceBus.Extensibility.ContextBag : object {
    [CompilerGeneratedAttribute]
private IBehavior[] <Behaviors>k__BackingField;
    internal ContextBag parentBag;
    private protected ContextBag root;
    private Dictionary`2<string, object> stash;
    internal IBehavior[] Behaviors { get; internal set; }
    public ContextBag(ContextBag parentBag);
    public sealed virtual T Get();
    public sealed virtual bool TryGet(T& result);
    public sealed virtual bool TryGet(string key, T& result);
    public sealed virtual T Get(string key);
    public T GetOrCreate();
    public void Set(T t);
    public void Remove();
    public void Remove(string key);
    public void Set(string key, T t);
    internal void SetOnRoot(string key, T t);
    internal void Merge(ContextBag context);
    private Dictionary`2<string, object> GetOrCreateStash();
    [CompilerGeneratedAttribute]
internal IBehavior[] get_Behaviors();
    [CompilerGeneratedAttribute]
internal void set_Behaviors(IBehavior[] value);
}
public abstract class NServiceBus.Extensibility.ExtendableOptions : object {
    internal static string OperationPropertiesKey;
    [CompilerGeneratedAttribute]
private DispatchProperties <DispatchProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ContextBag <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserDefinedMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <OutgoingHeaders>k__BackingField;
    internal DispatchProperties DispatchProperties { get; }
    internal ContextBag Context { get; }
    internal string UserDefinedMessageId { get; internal set; }
    internal Dictionary`2<string, string> OutgoingHeaders { get; }
    [CompilerGeneratedAttribute]
internal DispatchProperties get_DispatchProperties();
    [CompilerGeneratedAttribute]
internal ContextBag get_Context();
    [CompilerGeneratedAttribute]
internal string get_UserDefinedMessageId();
    [CompilerGeneratedAttribute]
internal void set_UserDefinedMessageId(string value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_OutgoingHeaders();
}
[ExtensionAttribute]
public static class NServiceBus.Extensibility.ExtendableOptionsExtensions : object {
    [ExtensionAttribute]
public static ContextBag GetExtensions(ExtendableOptions options);
    [ExtensionAttribute]
public static DispatchProperties GetDispatchProperties(ExtendableOptions options);
    [ExtensionAttribute]
public static IReadOnlyContextBag GetOperationProperties(IOutgoingContext behaviorContext);
    [ExtensionAttribute]
public static IReadOnlyContextBag GetOperationProperties(IUnsubscribeContext behaviorContext);
    [ExtensionAttribute]
public static IReadOnlyContextBag GetOperationProperties(ISubscribeContext behaviorContext);
    [ExtensionAttribute]
public static IReadOnlyContextBag GetOperationProperties(IRoutingContext behaviorContext);
    [ExtensionAttribute]
private static ContextBag GetOperationPropertiesInternal(IBehaviorContext behaviorContext);
}
public interface NServiceBus.Extensibility.IExtendable {
    [EditorBrowsableAttribute("1")]
public ContextBag Extensions { get; }
    public abstract virtual ContextBag get_Extensions();
}
public interface NServiceBus.Extensibility.IReadOnlyContextBag {
    public abstract virtual T Get();
    public abstract virtual T Get(string key);
    public abstract virtual bool TryGet(T& result);
    public abstract virtual bool TryGet(string key, T& result);
}
internal class NServiceBus.ExternallyManagedContainerHost : object {
    [CompilerGeneratedAttribute]
private Lazy`1<IMessageSession> <MessageSession>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<IServiceProvider> <Builder>k__BackingField;
    private EndpointCreator endpointCreator;
    private IMessageSession messageSession;
    private IServiceProvider objectBuilder;
    public Lazy`1<IMessageSession> MessageSession { get; private set; }
    internal Lazy`1<IServiceProvider> Builder { get; private set; }
    public ExternallyManagedContainerHost(EndpointCreator endpointCreator);
    [CompilerGeneratedAttribute]
public sealed virtual Lazy`1<IMessageSession> get_MessageSession();
    [CompilerGeneratedAttribute]
private void set_MessageSession(Lazy`1<IMessageSession> value);
    [CompilerGeneratedAttribute]
internal Lazy`1<IServiceProvider> get_Builder();
    [CompilerGeneratedAttribute]
private void set_Builder(Lazy`1<IServiceProvider> value);
    [AsyncStateMachineAttribute("NServiceBus.ExternallyManagedContainerHost/<Start>d__9")]
public sealed virtual Task`1<IEndpointInstance> Start(IServiceProvider externalBuilder, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private IMessageSession <.ctor>b__0_0();
    [CompilerGeneratedAttribute]
private IServiceProvider <.ctor>b__0_1();
}
public class NServiceBus.FailedConfig : object {
    [CompilerGeneratedAttribute]
private string <ErrorQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<Type> <UnrecoverableExceptionTypes>k__BackingField;
    public string ErrorQueue { get; }
    public HashSet`1<Type> UnrecoverableExceptionTypes { get; }
    public FailedConfig(string errorQueue, HashSet`1<Type> unrecoverableExceptionTypes);
    [CompilerGeneratedAttribute]
public string get_ErrorQueue();
    [CompilerGeneratedAttribute]
public HashSet`1<Type> get_UnrecoverableExceptionTypes();
}
internal class NServiceBus.FaultMetadataExtractor : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <staticFaultMetadata>P;
    [CompilerGeneratedAttribute]
private Action`1<Dictionary`2<string, string>> <headerCustomizations>P;
    public FaultMetadataExtractor(Dictionary`2<string, string> staticFaultMetadata, Action`1<Dictionary`2<string, string>> headerCustomizations);
    public Dictionary`2<string, string> Extract(ErrorContext errorContext);
    private static void SetExceptionMetadata(Dictionary`2<string, string> headers, Exception e);
    private static string Truncate(string value, int maxLength);
}
public class NServiceBus.Faults.DelayedRetryMessage : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    public string MessageId { get; }
    public Dictionary`2<string, string> Headers { get; }
    public ReadOnlyMemory`1<byte> Body { get; }
    public Exception Exception { get; }
    public int RetryAttempt { get; }
    public DelayedRetryMessage(string messageId, Dictionary`2<string, string> headers, ReadOnlyMemory`1<byte> body, Exception exception, int retryAttempt);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public int get_RetryAttempt();
}
public class NServiceBus.Faults.FailedMessage : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    public Dictionary`2<string, string> Headers { get; }
    public ReadOnlyMemory`1<byte> Body { get; }
    public Exception Exception { get; }
    public string ErrorQueue { get; }
    public string MessageId { get; }
    public FailedMessage(string messageId, Dictionary`2<string, string> headers, ReadOnlyMemory`1<byte> body, Exception exception, string errorQueue);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_ErrorQueue();
    [CompilerGeneratedAttribute]
public string get_MessageId();
}
public static class NServiceBus.Faults.FaultsHeaderKeys : object {
    public static string FailedQ;
    public static string ExceptionType;
    public static string InnerExceptionType;
    public static string HelpLink;
    public static string Message;
    public static string Source;
    public static string StackTrace;
    public static string TimeOfFailure;
    private static string ExceptionInfoPrefix;
    internal static string ExceptionInfoDataPrefix;
}
public class NServiceBus.Faults.ImmediateRetryMessage : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryAttempt>k__BackingField;
    public string MessageId { get; }
    public Dictionary`2<string, string> Headers { get; }
    public ReadOnlyMemory`1<byte> Body { get; }
    public Exception Exception { get; }
    public int RetryAttempt { get; }
    public ImmediateRetryMessage(string messageId, Dictionary`2<string, string> headers, ReadOnlyMemory`1<byte> body, Exception exception, int retryAttempt);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public int get_RetryAttempt();
}
internal class NServiceBus.FeatureComponent : object {
    private SettingsHolder settings;
    private FeatureActivator featureActivator;
    public FeatureComponent(SettingsHolder settings);
    public void RegisterFeatureEnabledStatusInSettings(Configuration hostingConfiguration);
    public void Initalize(FeatureConfigurationContext featureConfigurationContext);
    public Task Start(IServiceProvider builder, IMessageSession messageSession, CancellationToken cancellationToken);
    public Task Stop(CancellationToken cancellationToken);
    private static bool IsFeature(Type type);
}
public class NServiceBus.Features.Audit : Feature {
    private static ILog Logger;
    private static Audit();
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.AutoCorrelationFeature : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
public class NServiceBus.Features.AutoSubscribe : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.ConfiguredUnicastRoutes : object {
    private List`1<IRouteSource> routeSources;
    public void Add(IRouteSource routeSource);
    public void Apply(UnicastRoutingTable unicastRoutingTable, Conventions conventions);
}
internal class NServiceBus.Features.CustomIDataBus : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public class NServiceBus.Features.DataBus : Feature {
    internal static string SelectedDataBusKey;
    internal static string DataBusSerializerKey;
    internal static string AdditionalDataBusDeserializersKey;
    private static DataBus();
    private static Type GetSelectedFeatureForDataBus(SettingsHolder settings);
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.DataBusFileBased : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.DelayedDeliveryFeature : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
public abstract class NServiceBus.Features.Feature : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<List`1<string>> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabledByDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsActive>k__BackingField;
    private List`1<Action`1<SettingsHolder>> registeredDefaults;
    private List`1<SetupPrerequisite> setupPrerequisites;
    private static Type baseFeatureType;
    public string Name { get; }
    public string Version { get; }
    internal List`1<List`1<string>> Dependencies { get; }
    public bool IsEnabledByDefault { get; private set; }
    public bool IsActive { get; private set; }
    private static Feature();
    [CompilerGeneratedAttribute]
public string get_Name();
    public string get_Version();
    [CompilerGeneratedAttribute]
internal List`1<List`1<string>> get_Dependencies();
    [CompilerGeneratedAttribute]
public bool get_IsEnabledByDefault();
    [CompilerGeneratedAttribute]
private void set_IsEnabledByDefault(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsActive();
    [CompilerGeneratedAttribute]
private void set_IsActive(bool value);
    protected void Defaults(Action`1<SettingsHolder> settings);
    protected internal abstract virtual void Setup(FeatureConfigurationContext context);
    protected void Prerequisite(Func`2<FeatureConfigurationContext, bool> condition, string description);
    protected void EnableByDefault();
    protected void DependsOn();
    protected void DependsOn(string featureTypeName);
    protected void DependsOnAtLeastOne(Type[] features);
    protected void DependsOnOptionally(string featureName);
    protected void DependsOnOptionally(Type featureType);
    protected void DependsOnOptionally();
    protected void DependsOnAtLeastOne(String[] featureNames);
    public virtual string ToString();
    internal PrerequisiteStatus CheckPrerequisites(FeatureConfigurationContext context);
    internal void SetupFeature(FeatureConfigurationContext config);
    internal void ConfigureDefaults(SettingsHolder settings);
    private static string GetFeatureName(Type featureType);
}
internal class NServiceBus.Features.FeatureActivator : object {
    private List`1<FeatureInfo> features;
    private List`1<FeatureInfo> enabledFeatures;
    private SettingsHolder settings;
    internal List`1<FeatureDiagnosticData> Status { get; }
    public FeatureActivator(SettingsHolder settings);
    internal List`1<FeatureDiagnosticData> get_Status();
    public void Add(Feature feature);
    public FeatureDiagnosticData[] SetupFeatures(FeatureConfigurationContext featureConfigurationContext);
    [AsyncStateMachineAttribute("NServiceBus.Features.FeatureActivator/<StartFeatures>d__5")]
public Task StartFeatures(IServiceProvider builder, IMessageSession session, CancellationToken cancellationToken);
    public Task StopFeatures(CancellationToken cancellationToken);
    private static List`1<FeatureInfo> Sort(IEnumerable`1<FeatureInfo> features);
    private static bool DirectedCycleExistsFrom(Node node, Node[] visitedNodes);
    private bool ActivateFeature(FeatureInfo featureInfo, List`1<FeatureInfo> featuresToActivate, FeatureConfigurationContext featureConfigurationContext);
    private static bool HasAllPrerequisitesSatisfied(Feature feature, FeatureDiagnosticData diagnosticData, FeatureConfigurationContext context);
    [CompilerGeneratedAttribute]
private bool <SetupFeatures>b__4_1(FeatureInfo x);
}
public class NServiceBus.Features.FeatureConfigurationContext : object {
    [CompilerGeneratedAttribute]
private IReadOnlySettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceCollection <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineSettings <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private Configuration <Routing>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FeatureStartupTaskController> <TaskControllers>k__BackingField;
    private Configuration receiveConfiguration;
    public IReadOnlySettings Settings { get; }
    public IServiceCollection Services { get; }
    public PipelineSettings Pipeline { get; }
    internal Configuration Routing { get; }
    internal Configuration Receiving { get; }
    internal List`1<FeatureStartupTaskController> TaskControllers { get; }
    [ObsoleteAttribute("Use `Services` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public IServiceCollection Container { get; }
    internal FeatureConfigurationContext(IReadOnlySettings settings, IServiceCollection container, PipelineSettings pipelineSettings, Configuration routing, Configuration receiveConfiguration);
    [CompilerGeneratedAttribute]
public IReadOnlySettings get_Settings();
    [CompilerGeneratedAttribute]
public IServiceCollection get_Services();
    [CompilerGeneratedAttribute]
public PipelineSettings get_Pipeline();
    [CompilerGeneratedAttribute]
internal Configuration get_Routing();
    internal Configuration get_Receiving();
    [CompilerGeneratedAttribute]
internal List`1<FeatureStartupTaskController> get_TaskControllers();
    public void AddSatelliteReceiver(string name, QueueAddress transportAddress, PushRuntimeSettings runtimeSettings, Func`3<RecoverabilityConfig, ErrorContext, RecoverabilityAction> recoverabilityPolicy, OnSatelliteMessage onMessage);
    public void RegisterStartupTask(TTask startupTask);
    public void RegisterStartupTask(Func`1<TTask> startupTaskFactory);
    public void RegisterStartupTask(Func`2<IServiceProvider, TTask> startupTaskFactory);
    public IServiceCollection get_Container();
}
internal class NServiceBus.Features.FeatureDiagnosticData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnabledByDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    [CompilerGeneratedAttribute]
private PrerequisiteStatus <PrerequisiteStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyList`1<string>> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <StartupTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DependenciesAreMet>k__BackingField;
    public string Name { get; internal set; }
    public bool EnabledByDefault { get; internal set; }
    public bool Active { get; internal set; }
    public PrerequisiteStatus PrerequisiteStatus { get; internal set; }
    public IReadOnlyList`1<IReadOnlyList`1<string>> Dependencies { get; internal set; }
    public string Version { get; internal set; }
    public IReadOnlyList`1<string> StartupTasks { get; internal set; }
    public bool DependenciesAreMet { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_EnabledByDefault();
    [CompilerGeneratedAttribute]
internal void set_EnabledByDefault(bool value);
    [CompilerGeneratedAttribute]
public bool get_Active();
    [CompilerGeneratedAttribute]
internal void set_Active(bool value);
    [CompilerGeneratedAttribute]
public PrerequisiteStatus get_PrerequisiteStatus();
    [CompilerGeneratedAttribute]
internal void set_PrerequisiteStatus(PrerequisiteStatus value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyList`1<string>> get_Dependencies();
    [CompilerGeneratedAttribute]
internal void set_Dependencies(IReadOnlyList`1<IReadOnlyList`1<string>> value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_StartupTasks();
    [CompilerGeneratedAttribute]
internal void set_StartupTasks(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_DependenciesAreMet();
    [CompilerGeneratedAttribute]
public void set_DependenciesAreMet(bool value);
}
public abstract class NServiceBus.Features.FeatureStartupTask : object {
    private IMessageSession messageSession;
    protected abstract virtual Task OnStart(IMessageSession session, CancellationToken cancellationToken);
    protected abstract virtual Task OnStop(IMessageSession session, CancellationToken cancellationToken);
    internal Task PerformStartup(IMessageSession session, CancellationToken cancellationToken);
    internal Task PerformStop(CancellationToken cancellationToken);
}
internal class NServiceBus.Features.FeatureStartupTaskController : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private Func`2<IServiceProvider, FeatureStartupTask> factory;
    private FeatureStartupTask instance;
    private static ILog Log;
    public string Name { get; }
    public FeatureStartupTaskController(string name, Func`2<IServiceProvider, FeatureStartupTask> factory);
    private static FeatureStartupTaskController();
    [CompilerGeneratedAttribute]
public string get_Name();
    public Task Start(IServiceProvider builder, IMessageSession messageSession, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.Features.FeatureStartupTaskController/<Stop>d__5")]
public Task Stop(CancellationToken cancellationToken);
    private static void DisposeIfNecessary(FeatureStartupTask task);
}
public enum NServiceBus.Features.FeatureState : Enum {
    public int value__;
    public static FeatureState Disabled;
    public static FeatureState Enabled;
    public static FeatureState Active;
    public static FeatureState Deactivated;
}
internal class NServiceBus.Features.InferredMessageTypeEnricherFeature : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.LearningSagaPersistence : Feature {
    internal static string StorageLocationKey;
    private static LearningSagaPersistence();
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.LicenseReminder : Feature {
    public static string LicenseTextSettingsKey;
    public static string LicenseFilePathSettingsKey;
    private static ILog Logger;
    private static LicenseReminder();
    protected internal virtual void Setup(FeatureConfigurationContext context);
    private static object GenerateLicenseDiagnostics(LicenseManager licenseManager);
}
internal class NServiceBus.Features.MessageCausation : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
    private static Func`2<IOutgoingLogicalMessageContext, string> GetIdStrategy(IReadOnlySettings settings);
    internal static Func`2<IOutgoingLogicalMessageContext, string> WrapUserDefinedInvocation(Func`2<ConversationIdStrategyContext, ConversationId> userDefinedIdGenerator);
}
internal class NServiceBus.Features.MessageCorrelation : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
[ObsoleteAttribute("It's not recommended to disable the MessageDrivenSubscriptions feature and this option will be removed in future versions. Use 'TransportExtensions<T>.DisablePublishing()' to avoid the need for a subscription storage if this endpoint does not publish events. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public class NServiceBus.Features.MessageDrivenSubscriptions : Feature {
    internal static string EnablePublishingSettingsKey;
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.Mutators : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.NativePublishSubscribeFeature : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
public class NServiceBus.Features.Outbox : Feature {
    internal static string TimeToKeepDeduplicationEntries;
    private static bool ReceivingEnabled(IReadOnlySettings settings);
    private static bool TransactionsEnabled(IReadOnlySettings settings);
    private static bool AllowUseWithoutReceiving(IReadOnlySettings settings);
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
public class NServiceBus.Features.PlatformRetryNotifications : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.PrerequisiteStatus : object {
    [CompilerGeneratedAttribute]
private bool <IsSatisfied>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Reasons>k__BackingField;
    public bool IsSatisfied { get; private set; }
    public List`1<string> Reasons { get; }
    [CompilerGeneratedAttribute]
public bool get_IsSatisfied();
    [CompilerGeneratedAttribute]
private void set_IsSatisfied(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Reasons();
    internal void ReportFailure(string description);
}
internal class NServiceBus.Features.RootFeature : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
public class NServiceBus.Features.Sagas : Feature {
    private Conventions conventions;
    protected internal virtual void Setup(FeatureConfigurationContext context);
    private static void RegisterCustomFindersInContainer(IServiceCollection container, IEnumerable`1<SagaMetadata> sagaMetaModel);
    private static bool IsSagaType(Type t);
    private static bool IsSagaNotFoundHandler(Type t);
    private static bool IsCompatible(Type t, Type source);
    private static bool IsTypeATimeoutHandledByAnySaga(Type type, IEnumerable`1<Type> sagas);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_0(SettingsHolder s);
}
[ExtensionAttribute]
public static class NServiceBus.Features.SettingsExtensions : object {
    [ExtensionAttribute]
public static SettingsHolder EnableFeatureByDefault(SettingsHolder settings);
    [ExtensionAttribute]
public static SettingsHolder EnableFeatureByDefault(SettingsHolder settings, Type featureType);
    [ExtensionAttribute]
public static bool IsFeatureActive(IReadOnlySettings settings, Type featureType);
    [ExtensionAttribute]
public static bool IsFeatureEnabled(IReadOnlySettings settings, Type featureType);
    [ExtensionAttribute]
internal static void EnableFeature(SettingsHolder settings, Type featureType);
    [ExtensionAttribute]
internal static void DisableFeature(SettingsHolder settings, Type featureType);
    [ExtensionAttribute]
internal static void MarkFeatureAsActive(SettingsHolder settings, Type featureType);
    [ExtensionAttribute]
internal static void MarkFeatureAsDeactivated(SettingsHolder settings, Type featureType);
}
internal class NServiceBus.Features.SubscriptionMigrationMode : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
    public static bool IsMigrationModeEnabled(IReadOnlySettings settings);
}
public class NServiceBus.Features.SynchronizedStorage : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.TimeToBeReceived : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
    private static TimeToBeReceivedMappings GetMappings(FeatureConfigurationContext context);
}
internal class NServiceBus.Features.TransactionScopeUnitOfWork : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public class NServiceBus.FileShareDataBus : DataBusDefinition {
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
protected internal virtual Type ProvidedByFeature();
}
internal class NServiceBus.FileShareDataBusImplementation : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxMessageTimeToLive>k__BackingField;
    private string basePath;
    private static ILog logger;
    public TimeSpan MaxMessageTimeToLive { get; public set; }
    public FileShareDataBusImplementation(string basePath);
    private static FileShareDataBusImplementation();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxMessageTimeToLive();
    [CompilerGeneratedAttribute]
public void set_MaxMessageTimeToLive(TimeSpan value);
    public sealed virtual Task`1<Stream> Get(string key, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.FileShareDataBusImplementation/<Put>d__7")]
public sealed virtual Task`1<string> Put(Stream stream, TimeSpan timeToBeReceived, CancellationToken cancellationToken);
    public sealed virtual Task Start(CancellationToken cancellationToken);
    private string GenerateKey(TimeSpan timeToBeReceived);
}
internal class NServiceBus.FileVersionRetriever : object {
    public static string GetFileVersion(Type type);
    public static string GetFileVersion(Assembly assembly);
}
internal class NServiceBus.ForceBatchDispatchToBeIsolatedBehavior : object {
    public sealed virtual Task Invoke(IBatchDispatchContext context, Func`2<IBatchDispatchContext, Task> next);
}
[ExtensionAttribute]
internal static class NServiceBus.ForkExtensions : object {
    [ExtensionAttribute]
public static Task Fork(IForkConnector`3<TFromContext, TToContext, TForkContext> forkConnector, TForkContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class NServiceBus.Guard : object {
    public static void ThrowIfNegativeOrZero(TimeSpan argument, string paramName);
    public static void ThrowIfNegative(TimeSpan argument, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowArgumentOutOfRangeException(string paramName);
}
internal class NServiceBus.HeaderFinderSagaToMessageMap : CorrelationSagaToMessageMap {
    public string HeaderName;
    public virtual SagaFinderDefinition CreateSagaFinderDefinition(Type sagaEntityType);
}
[ExtensionAttribute]
public static class NServiceBus.HeaderOptionExtensions : object {
    [ExtensionAttribute]
public static void SetHeader(ExtendableOptions options, string key, string value);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, string> GetHeaders(ExtendableOptions options);
}
internal class NServiceBus.HeaderPropertySagaFinder`1 : SagaFinder {
    private ISagaPersister persister;
    public HeaderPropertySagaFinder`1(ISagaPersister persister);
    [AsyncStateMachineAttribute("NServiceBus.HeaderPropertySagaFinder`1/<Find>d__2")]
public virtual Task`1<IContainSagaData> Find(IServiceProvider builder, SagaFinderDefinition finderDefinition, ISynchronizedStorageSession storageSession, ContextBag context, object message, IReadOnlyDictionary`2<string, string> messageHeaders, CancellationToken cancellationToken);
}
public static class NServiceBus.Headers : object {
    public static string HttpFrom;
    public static string HttpTo;
    public static string RouteTo;
    public static string DestinationSites;
    public static string OriginatingSite;
    public static string SagaId;
    public static string MessageId;
    public static string CorrelationId;
    public static string ReplyToAddress;
    public static string NServiceBusVersion;
    public static string ReturnMessageErrorCodeHeader;
    public static string ControlMessageHeader;
    public static string SagaType;
    public static string OriginatingSagaId;
    public static string OriginatingSagaType;
    public static string DelayedRetries;
    public static string DelayedRetriesTimestamp;
    public static string ImmediateRetries;
    public static string ProcessingStarted;
    public static string ProcessingEnded;
    public static string TimeSent;
    public static string DeliverAt;
    public static string RelatedTo;
    public static string EnclosedMessageTypes;
    public static string ContentType;
    public static string SubscriptionMessageType;
    public static string SubscriberTransportAddress;
    public static string SubscriberEndpoint;
    public static string IsSagaTimeoutMessage;
    public static string IsDeferredMessage;
    public static string OriginatingEndpoint;
    public static string OriginatingMachine;
    public static string OriginatingHostId;
    public static string ProcessingEndpoint;
    public static string ProcessingMachine;
    public static string HostDisplayName;
    public static string HostId;
    public static string HasLicenseExpired;
    public static string OriginatingAddress;
    public static string ConversationId;
    public static string PreviousConversationId;
    public static string MessageIntent;
    public static string NonDurableMessage;
    public static string TimeToBeReceived;
    public static string DiagnosticsTraceParent;
    public static string DiagnosticsTraceState;
    public static string DiagnosticsBaggage;
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public static string DataBusConfigContentType;
    public static string StartNewTrace;
}
internal static class NServiceBus.HeaderSerializer : object {
    private static DataContractJsonSerializer serializer;
    private static HeaderSerializer();
    public static string Serialize(Dictionary`2<string, string> dictionary);
    public static Dictionary`2<string, string> Deserialize(string value);
}
internal static class NServiceBus.Host : object {
    internal static String[] parameters;
    private static Host();
    public static string GetOutputDirectory();
    private static string DeriveAppDataPath(Assembly systemWebAssembly);
    private static string TryMapPath(Assembly systemWebAssembly);
    private static string GetMapPathError(string reason);
}
[ExtensionAttribute]
public static class NServiceBus.HostInfoConfigurationExtensions : object {
    [ExtensionAttribute]
public static HostInfoSettings UniquelyIdentifyRunningInstance(EndpointConfiguration config);
}
public class NServiceBus.HostInfoSettings : object {
    private EndpointConfiguration config;
    internal HostInfoSettings(EndpointConfiguration config);
    public HostInfoSettings UsingInstalledFilePath();
    public HostInfoSettings UsingCustomIdentifier(Guid id);
    public HostInfoSettings UsingNames(string instanceName, string hostName);
    public HostInfoSettings UsingCustomDisplayName(string displayName);
    public HostInfoSettings UsingHostName(string hostName);
}
public class NServiceBus.Hosting.Helpers.AssemblyScanner : object {
    [CompilerGeneratedAttribute]
private bool <ThrowExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ScanAppDomainAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ScanFileSystemAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CoreAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageInterfacesAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalAssemblyScanningPath>k__BackingField;
    internal bool ScanNestedDirectories;
    private Assembly assemblyToScan;
    private string baseDirectoryToScan;
    private HashSet`1<Type> typesToSkip;
    private HashSet`1<string> assembliesToSkip;
    private static string NServiceBusCoreAssemblyName;
    private static string NServiceBusMessageInterfacesAssemblyName;
    private static String[] FileSearchPatternsToUse;
    private static HashSet`1<string> DefaultAssemblyExclusions;
    public bool ThrowExceptions { get; public set; }
    public bool ScanAppDomainAssemblies { get; public set; }
    public bool ScanFileSystemAssemblies { get; public set; }
    internal string CoreAssemblyName { get; internal set; }
    internal string MessageInterfacesAssemblyName { get; internal set; }
    unknown IReadOnlyCollection`1<string> AssembliesToSkip {internal set; }
    unknown IReadOnlyCollection`1<Type> TypesToSkip {internal set; }
    internal string AdditionalAssemblyScanningPath { get; internal set; }
    public AssemblyScanner(string baseDirectoryToScan);
    internal AssemblyScanner(Assembly assemblyToScan);
    private static AssemblyScanner();
    [CompilerGeneratedAttribute]
public bool get_ThrowExceptions();
    [CompilerGeneratedAttribute]
public void set_ThrowExceptions(bool value);
    [CompilerGeneratedAttribute]
public bool get_ScanAppDomainAssemblies();
    [CompilerGeneratedAttribute]
public void set_ScanAppDomainAssemblies(bool value);
    [CompilerGeneratedAttribute]
public bool get_ScanFileSystemAssemblies();
    [CompilerGeneratedAttribute]
public void set_ScanFileSystemAssemblies(bool value);
    [CompilerGeneratedAttribute]
internal string get_CoreAssemblyName();
    [CompilerGeneratedAttribute]
internal void set_CoreAssemblyName(string value);
    [CompilerGeneratedAttribute]
internal string get_MessageInterfacesAssemblyName();
    [CompilerGeneratedAttribute]
internal void set_MessageInterfacesAssemblyName(string value);
    internal void set_AssembliesToSkip(IReadOnlyCollection`1<string> value);
    private static string RemoveExtension(string assemblyName);
    internal void set_TypesToSkip(IReadOnlyCollection`1<Type> value);
    [CompilerGeneratedAttribute]
internal string get_AdditionalAssemblyScanningPath();
    [CompilerGeneratedAttribute]
internal void set_AdditionalAssemblyScanningPath(string value);
    public AssemblyScannerResults GetScannableAssemblies();
    private void ScanAssembliesInDirectory(string directoryToScan, List`1<Assembly> assemblies, AssemblyScannerResults results);
    private bool TryLoadScannableAssembly(string assemblyPath, AssemblyScannerResults results, Assembly& assembly);
    private bool ScanAssembly(Assembly assembly, Dictionary`2<string, bool> processed);
    private static Assembly GetReferencedAssembly(AssemblyName assemblyName);
    internal static string FormatReflectionTypeLoadException(string fileName, ReflectionTypeLoadException e);
    private static List`1<FileInfo> ScanDirectoryForAssemblyFiles(string directoryToScan, bool scanNestedDirectories);
    private bool IsExcluded(string assemblyName);
    private List`1<Type> FilterAllowedTypes(Type[] types);
    private bool IsAllowedType(Type type);
    private void AddTypesToResult(Assembly assembly, AssemblyScannerResults results);
    private bool ShouldScanDependencies(Assembly assembly);
    private bool IsCoreOrMessageInterfaceAssembly(AssemblyName assemblyName);
}
public class NServiceBus.Hosting.Helpers.AssemblyScannerResults : object {
    [CompilerGeneratedAttribute]
private List`1<Assembly> <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SkippedFile> <SkippedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ErrorsThrownDuringScanning>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <Types>k__BackingField;
    public List`1<Assembly> Assemblies { get; private set; }
    public List`1<SkippedFile> SkippedFiles { get; }
    public bool ErrorsThrownDuringScanning { get; internal set; }
    public List`1<Type> Types { get; private set; }
    [CompilerGeneratedAttribute]
public List`1<Assembly> get_Assemblies();
    [CompilerGeneratedAttribute]
private void set_Assemblies(List`1<Assembly> value);
    [CompilerGeneratedAttribute]
public List`1<SkippedFile> get_SkippedFiles();
    [CompilerGeneratedAttribute]
public bool get_ErrorsThrownDuringScanning();
    [CompilerGeneratedAttribute]
internal void set_ErrorsThrownDuringScanning(bool value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_Types();
    [CompilerGeneratedAttribute]
private void set_Types(List`1<Type> value);
    internal void RemoveDuplicates();
}
public class NServiceBus.Hosting.Helpers.SkippedFile : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SkipReason>k__BackingField;
    public string FilePath { get; }
    public string SkipReason { get; }
    internal SkippedFile(string filePath, string message);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_SkipReason();
}
public class NServiceBus.Hosting.HostInformation : object {
    [CompilerGeneratedAttribute]
private Guid <HostId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    public Guid HostId { get; }
    public string DisplayName { get; }
    public Dictionary`2<string, string> Properties { get; }
    public HostInformation(Guid hostId, string displayName);
    public HostInformation(Guid hostId, string displayName, Dictionary`2<string, string> properties);
    [CompilerGeneratedAttribute]
public Guid get_HostId();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
}
internal class NServiceBus.HostingComponent : object {
    private Configuration configuration;
    public HostingComponent(Configuration configuration);
    private static bool IsINeedToInstallSomething(Type t);
    public static Configuration PrepareConfiguration(Settings settings, AssemblyScanningComponent assemblyScanningComponent, IServiceCollection serviceCollection);
    public static HostingComponent Initialize(Configuration configuration);
    [AsyncStateMachineAttribute("NServiceBus.HostingComponent/<RunInstallers>d__5")]
public Task RunInstallers(IServiceProvider builder, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.HostingComponent/<WriteDiagnosticsFile>d__6")]
public Task WriteDiagnosticsFile(CancellationToken cancellationToken);
    public void SetupCriticalErrors(IEndpointInstance endpointInstance, CancellationToken cancellationToken);
    private string GetInstallationUserName();
}
internal class NServiceBus.HostStartupDiagnosticsWriter : object {
    private Func`3<string, CancellationToken, Task> diagnosticsWriter;
    private bool isCustomWriter;
    private static JsonSerializerOptions diagnosticsOptions;
    private static ILog logger;
    public HostStartupDiagnosticsWriter(Func`3<string, CancellationToken, Task> diagnosticsWriter, bool isCustomWriter);
    private static HostStartupDiagnosticsWriter();
    [AsyncStateMachineAttribute("NServiceBus.HostStartupDiagnosticsWriter/<Write>d__1")]
public Task Write(List`1<StartupDiagnosticEntry> entries, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NServiceBus.HostStartupDiagnosticsWriter/<DeduplicateEntries>d__2")]
private static IEnumerable`1<StartupDiagnosticEntry> DeduplicateEntries(List`1<StartupDiagnosticEntry> entries);
}
internal class NServiceBus.HostStartupDiagnosticsWriterFactory : object {
    private static ILog Logger;
    private static HostStartupDiagnosticsWriterFactory();
    public static HostStartupDiagnosticsWriter GetDiagnosticsWriter(Configuration configuration);
    private static Func`3<string, CancellationToken, Task> BuildDefaultDiagnosticsWriter(Configuration configuration);
}
internal interface NServiceBus.IActivityFactory {
    public abstract virtual Activity StartIncomingPipelineActivity(MessageContext context);
    public abstract virtual Activity StartOutgoingPipelineActivity(string activityName, string displayName, IBehaviorContext outgoingContext);
    public abstract virtual Activity StartHandlerActivity(MessageHandler messageHandler, ActiveSagaInstance saga);
}
[NullableContextAttribute("2")]
public interface NServiceBus.IAmStartedByMessages`1 {
}
public interface NServiceBus.ICancellableContext {
    public CancellationToken CancellationToken { get; }
    public abstract virtual CancellationToken get_CancellationToken();
}
public interface NServiceBus.IConfigureHowToFindSagaWithMessage {
    public abstract virtual void ConfigureMapping(Expression`1<Func`2<TSagaEntity, object>> sagaEntityProperty, Expression`1<Func`2<TMessage, object>> messageProperty);
}
[NullableContextAttribute("1")]
public interface NServiceBus.IConfigureHowToFindSagaWithMessageHeaders {
    public abstract virtual void ConfigureMapping(Expression`1<Func`2<TSagaEntity, object>> sagaEntityProperty, string headerName);
}
[NullableContextAttribute("2")]
public interface NServiceBus.IContainSagaData {
    [EditorBrowsableAttribute("1")]
public Guid Id { get; public set; }
    [EditorBrowsableAttribute("1")]
public string Originator { get; public set; }
    [EditorBrowsableAttribute("1")]
public string OriginalMessageId { get; public set; }
    public abstract virtual Guid get_Id();
    public abstract virtual void set_Id(Guid value);
    public abstract virtual string get_Originator();
    public abstract virtual void set_Originator(string value);
    public abstract virtual string get_OriginalMessageId();
    public abstract virtual void set_OriginalMessageId(string value);
}
public interface NServiceBus.ICriticalErrorContext {
    public Func`2<CancellationToken, Task> Stop { get; }
    public string Error { get; }
    public Exception Exception { get; }
    public abstract virtual Func`2<CancellationToken, Task> get_Stop();
    public abstract virtual string get_Error();
    public abstract virtual Exception get_Exception();
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public interface NServiceBus.IDataBusProperty {
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public string Key { get; public set; }
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public bool HasValue { get; public set; }
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public Type Type { get; }
    public abstract virtual string get_Key();
    public abstract virtual void set_Key(string value);
    public abstract virtual bool get_HasValue();
    public abstract virtual void set_HasValue(bool value);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual object GetValue();
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual void SetValue(object value);
    public abstract virtual Type get_Type();
}
public interface NServiceBus.IDistributionPolicy {
    public abstract virtual DistributionStrategy GetDistributionStrategy(string endpointName, DistributionStrategyScope scope);
}
public interface NServiceBus.IEndpointInstance {
    [NullableContextAttribute("1")]
public abstract virtual Task Stop(CancellationToken cancellationToken);
}
internal interface NServiceBus.IForkConnector {
}
internal interface NServiceBus.IForkConnector`3 {
}
[NullableContextAttribute("1")]
public interface NServiceBus.IHandleMessages`1 {
    public abstract virtual Task Handle(T message, IMessageHandlerContext context);
}
[NullableContextAttribute("1")]
public interface NServiceBus.IHandleTimeouts`1 {
    public abstract virtual Task Timeout(T state, IMessageHandlerContext context);
}
internal interface NServiceBus.ILearningTransportTransaction {
    public string FileToProcess { get; }
    public abstract virtual string get_FileToProcess();
    public abstract virtual Task`1<bool> BeginTransaction(string incomingFilePath, CancellationToken cancellationToken);
    public abstract virtual Task Commit(CancellationToken cancellationToken);
    public abstract virtual void Rollback();
    public abstract virtual void ClearPendingOutgoingOperations();
    public abstract virtual Task Enlist(string messagePath, string messageContents, CancellationToken cancellationToken);
    public abstract virtual bool Complete();
}
public interface NServiceBus.IMessageConvention {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool IsMessageType(Type type);
    public abstract virtual bool IsCommandType(Type type);
    public abstract virtual bool IsEventType(Type type);
}
public interface NServiceBus.IMessageCreator {
    public abstract virtual T CreateInstance();
    public abstract virtual T CreateInstance(Action`1<T> action);
    public abstract virtual object CreateInstance(Type messageType);
}
public interface NServiceBus.IMessageHandlerContext {
    public ISynchronizedStorageSession SynchronizedStorageSession { get; }
    public abstract virtual ISynchronizedStorageSession get_SynchronizedStorageSession();
    public abstract virtual void DoNotContinueDispatchingCurrentMessageToHandlers();
}
public interface NServiceBus.IMessageProcessingContext {
    public string MessageId { get; }
    public string ReplyToAddress { get; }
    public IReadOnlyDictionary`2<string, string> MessageHeaders { get; }
    public abstract virtual string get_MessageId();
    public abstract virtual string get_ReplyToAddress();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_MessageHeaders();
    public abstract virtual Task Reply(object message, ReplyOptions options);
    public abstract virtual Task Reply(Action`1<T> messageConstructor, ReplyOptions options);
    public abstract virtual Task ForwardCurrentMessageTo(string destination);
}
[NullableContextAttribute("1")]
public interface NServiceBus.IMessageSession {
    public abstract virtual Task Send(object message, SendOptions sendOptions, CancellationToken cancellationToken);
    public abstract virtual Task Send(Action`1<T> messageConstructor, SendOptions sendOptions, CancellationToken cancellationToken);
    public abstract virtual Task Publish(object message, PublishOptions publishOptions, CancellationToken cancellationToken);
    public abstract virtual Task Publish(Action`1<T> messageConstructor, PublishOptions publishOptions, CancellationToken cancellationToken);
    public abstract virtual Task Subscribe(Type eventType, SubscribeOptions subscribeOptions, CancellationToken cancellationToken);
    public abstract virtual Task Unsubscribe(Type eventType, UnsubscribeOptions unsubscribeOptions, CancellationToken cancellationToken);
}
public class NServiceBus.ImmediateConfig : object {
    [CompilerGeneratedAttribute]
private int <MaxNumberOfRetries>k__BackingField;
    public int MaxNumberOfRetries { get; }
    public ImmediateConfig(int maxNumberOfRetries);
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfRetries();
}
[ExtensionAttribute]
public static class NServiceBus.ImmediateDispatchOptionExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IsImmediateDispatchSet` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static bool RequiredImmediateDispatch(ExtendableOptions options);
    [ExtensionAttribute]
public static void RequireImmediateDispatch(ExtendableOptions options);
    [ExtensionAttribute]
public static bool IsImmediateDispatchSet(ExtendableOptions options);
}
internal class NServiceBus.ImmediateDispatchTerminator : PipelineTerminator`1<IDispatchContext> {
    private IMessageDispatcher dispatcher;
    public ImmediateDispatchTerminator(IMessageDispatcher dispatcher);
    protected virtual Task Terminate(IDispatchContext context);
}
public class NServiceBus.ImmediateRetriesSettings : ExposeSettings {
    internal ImmediateRetriesSettings(SettingsHolder settings);
    public void NumberOfRetries(int numberOfRetries);
    public ImmediateRetriesSettings OnMessageBeingRetried(Func`3<ImmediateRetryMessage, CancellationToken, Task> notificationCallback);
}
public class NServiceBus.ImmediateRetry : RecoverabilityAction {
    private static ILog Logger;
    public ErrorHandleResult ErrorHandleResult { get; }
    private static ImmediateRetry();
    public virtual ErrorHandleResult get_ErrorHandleResult();
    public virtual IReadOnlyCollection`1<IRoutingContext> GetRoutingContexts(IRecoverabilityActionContext context);
}
internal abstract class NServiceBus.IncomingContext : BehaviorContext {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplyToAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <MessageHeaders>k__BackingField;
    private MessageOperations MessageOperations { get; }
    public string MessageId { get; }
    public string ReplyToAddress { get; }
    public IReadOnlyDictionary`2<string, string> MessageHeaders { get; }
    protected IncomingContext(string messageId, string replyToAddress, IReadOnlyDictionary`2<string, string> headers, IBehaviorContext parentContext);
    private MessageOperations get_MessageOperations();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReplyToAddress();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, string> get_MessageHeaders();
    public sealed virtual Task Send(object message, SendOptions options);
    public sealed virtual Task Send(Action`1<T> messageConstructor, SendOptions options);
    public sealed virtual Task Publish(object message, PublishOptions options);
    public sealed virtual Task Publish(Action`1<T> messageConstructor, PublishOptions publishOptions);
    public sealed virtual Task Reply(object message, ReplyOptions options);
    public sealed virtual Task Reply(Action`1<T> messageConstructor, ReplyOptions options);
    public sealed virtual Task ForwardCurrentMessageTo(string destination);
    public Task Subscribe(Type eventType, SubscribeOptions options);
    public Task Unsubscribe(Type eventType, UnsubscribeOptions options);
}
internal class NServiceBus.IncomingLogicalMessageContext : IncomingContext {
    [CompilerGeneratedAttribute]
private LogicalMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MessageHandled>k__BackingField;
    public LogicalMessage Message { get; }
    public Dictionary`2<string, string> Headers { get; }
    public bool MessageHandled { get; public set; }
    internal IncomingLogicalMessageContext(LogicalMessage logicalMessage, IIncomingPhysicalMessageContext parentContext);
    public IncomingLogicalMessageContext(LogicalMessage logicalMessage, string messageId, string replyToAddress, Dictionary`2<string, string> headers, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual LogicalMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_MessageHandled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MessageHandled(bool value);
    public sealed virtual void UpdateMessageInstance(object newInstance);
}
internal static class NServiceBus.IncomingMessageOperations : object {
    public static Task ForwardCurrentMessageTo(IIncomingContext context, string destination);
}
internal class NServiceBus.IncomingPhysicalMessageContext : IncomingContext {
    [CompilerGeneratedAttribute]
private IncomingMessage <Message>k__BackingField;
    public IncomingMessage Message { get; }
    public IncomingPhysicalMessageContext(IncomingMessage message, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual IncomingMessage get_Message();
    public sealed virtual void UpdateMessage(ReadOnlyMemory`1<byte> body);
}
internal class NServiceBus.IncomingPipelineMetrics : object {
    private static string TotalProcessedSuccessfully;
    private static string TotalFetched;
    private static string TotalFailures;
    private static string MessageHandlerTime;
    private static string CriticalTime;
    private static string ProcessingTime;
    private static string RecoverabilityImmediate;
    private static string RecoverabilityDelayed;
    private static string RecoverabilityError;
    private Counter`1<long> totalProcessedSuccessfully;
    private Counter`1<long> totalFetched;
    private Counter`1<long> totalFailures;
    private Histogram`1<double> messageHandlerTime;
    private Histogram`1<double> criticalTime;
    private Histogram`1<double> processingTime;
    private Counter`1<long> totalImmediateRetries;
    private Counter`1<long> totalDelayedRetries;
    private Counter`1<long> totalSentToErrorQueue;
    private string queueNameBase;
    private string endpointDiscriminator;
    public IncomingPipelineMetrics(IMeterFactory meterFactory, string queueName, string discriminator);
    public void AddDefaultIncomingPipelineMetricTags(IncomingPipelineMetricTags incomingPipelineMetricsTags);
    public void RecordProcessingTime(ITransportReceiveContext context, TimeSpan elapsed);
    public void RecordCriticalTimeAndTotalProcessed(ITransportReceiveContext context);
    public void RecordMessageProcessingFailure(IncomingPipelineMetricTags incomingPipelineMetricTags, Exception error);
    public void RecordFetchedMessage(IncomingPipelineMetricTags incomingPipelineMetricTags);
    public void RecordSuccessfulMessageHandlerTime(IInvokeHandlerContext invokeHandlerContext, TimeSpan elapsed);
    public void RecordFailedMessageHandlerTime(IInvokeHandlerContext invokeHandlerContext, TimeSpan elapsed, Exception error);
    public void RecordImmediateRetry(IRecoverabilityContext recoverabilityContext);
    public void RecordDelayedRetry(IRecoverabilityContext recoverabilityContext);
    public void RecordSendToErrorQueue(IRecoverabilityContext recoverabilityContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NServiceBus.IncomingPipelineMetricTags : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, KeyValuePair`2<string, object>> tags;
    public void Add(string tagKey, object value);
    public void ApplyTag(TagList& tagList, string tagKey);
    public void ApplyTags(TagList& tagList, ReadOnlySpan`1<string> tagKeys);
}
[NullableContextAttribute("1")]
public interface NServiceBus.INeedInitialization {
    public abstract virtual void Customize(EndpointConfiguration configuration);
}
internal class NServiceBus.InferredMessageTypeEnricherBehavior : object {
    public sealed virtual Task Invoke(IIncomingLogicalMessageContext context, Func`2<IIncomingLogicalMessageContext, Task> next);
}
internal interface NServiceBus.INotificationSubscriptions`1 {
    public abstract virtual Task Raise(TEvent event, CancellationToken cancellationToken);
}
public interface NServiceBus.Installation.INeedToInstallSomething {
    public abstract virtual Task Install(string identity, CancellationToken cancellationToken);
}
public static class NServiceBus.Installation.Installer : object {
    [AsyncStateMachineAttribute("NServiceBus.Installation.Installer/<Setup>d__0")]
public static Task Setup(EndpointConfiguration configuration, CancellationToken cancellationToken);
    public static InstallerWithExternallyManagedContainer CreateInstallerWithExternallyManagedContainer(EndpointConfiguration configuration, IServiceCollection serviceCollection);
}
public class NServiceBus.Installation.InstallerWithExternallyManagedContainer : object {
    private EndpointCreator endpointCreator;
    internal InstallerWithExternallyManagedContainer(EndpointCreator endpointCreator);
    [AsyncStateMachineAttribute("NServiceBus.Installation.InstallerWithExternallyManagedContainer/<Setup>d__2")]
public Task Setup(IServiceProvider builder, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class NServiceBus.InstallConfigExtensions : object {
    [ExtensionAttribute]
public static void EnableInstallers(EndpointConfiguration config, string username);
}
internal class NServiceBus.InternallyManagedContainerHost : object {
    private StartableEndpoint endpoint;
    public InternallyManagedContainerHost(StartableEndpoint endpoint);
    [AsyncStateMachineAttribute("NServiceBus.InternallyManagedContainerHost/<Start>d__1")]
public sealed virtual Task`1<IEndpointInstance> Start(CancellationToken cancellationToken);
}
internal class NServiceBus.InvokeAuditPipelineBehavior : object {
    private string auditAddress;
    private Nullable`1<TimeSpan> timeToBeReceived;
    public InvokeAuditPipelineBehavior(string auditAddress, Nullable`1<TimeSpan> timeToBeReceived);
    [AsyncStateMachineAttribute("NServiceBus.InvokeAuditPipelineBehavior/<Invoke>d__1")]
public sealed virtual Task Invoke(IIncomingPhysicalMessageContext context, Func`2<IIncomingPhysicalMessageContext, Task> next);
}
internal class NServiceBus.InvokeHandlerContext : IncomingContext {
    [CompilerGeneratedAttribute]
private MessageHandler <MessageHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private object <MessageBeingHandled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandlerInvocationAborted>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageMetadata <MessageMetadata>k__BackingField;
    public MessageHandler MessageHandler { get; }
    public ISynchronizedStorageSession SynchronizedStorageSession { get; }
    public Dictionary`2<string, string> Headers { get; }
    public object MessageBeingHandled { get; }
    public bool HandlerInvocationAborted { get; private set; }
    public MessageMetadata MessageMetadata { get; }
    internal InvokeHandlerContext(MessageHandler handler, ISynchronizedStorageSession storageSession, IIncomingLogicalMessageContext parentContext);
    public InvokeHandlerContext(MessageHandler handler, string messageId, string replyToAddress, Dictionary`2<string, string> headers, MessageMetadata messageMetadata, object messageBeingHandled, ISynchronizedStorageSession storageSession, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual MessageHandler get_MessageHandler();
    public sealed virtual ISynchronizedStorageSession get_SynchronizedStorageSession();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual object get_MessageBeingHandled();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HandlerInvocationAborted();
    [CompilerGeneratedAttribute]
private void set_HandlerInvocationAborted(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual MessageMetadata get_MessageMetadata();
    public sealed virtual void DoNotContinueDispatchingCurrentMessageToHandlers();
}
internal class NServiceBus.InvokeHandlerTerminator : PipelineTerminator`1<IInvokeHandlerContext> {
    [CompilerGeneratedAttribute]
private IActivityFactory <activityFactory>P;
    [CompilerGeneratedAttribute]
private IncomingPipelineMetrics <messagingMetricsMeters>P;
    public InvokeHandlerTerminator(IActivityFactory activityFactory, IncomingPipelineMetrics messagingMetricsMeters);
    [AsyncStateMachineAttribute("NServiceBus.InvokeHandlerTerminator/<Terminate>d__3")]
protected virtual Task Terminate(IInvokeHandlerContext context);
}
internal class NServiceBus.InvokeSagaNotFoundBehavior : object {
    private static ILog logger;
    private static InvokeSagaNotFoundBehavior();
    [AsyncStateMachineAttribute("NServiceBus.InvokeSagaNotFoundBehavior/<Invoke>d__0")]
public sealed virtual Task Invoke(IIncomingLogicalMessageContext context, Func`2<IIncomingLogicalMessageContext, Task> next);
}
internal interface NServiceBus.IPipeline {
}
internal interface NServiceBus.IPipeline`1 {
    public abstract virtual Task Invoke(TContext context);
}
internal interface NServiceBus.IPipelineCache {
    public abstract virtual IPipeline`1<TContext> Pipeline();
}
public interface NServiceBus.IPipelineContext {
    public abstract virtual Task Send(object message, SendOptions options);
    public abstract virtual Task Send(Action`1<T> messageConstructor, SendOptions options);
    public abstract virtual Task Publish(object message, PublishOptions options);
    public abstract virtual Task Publish(Action`1<T> messageConstructor, PublishOptions publishOptions);
}
internal interface NServiceBus.IPipelineExecutor {
    public abstract virtual Task Invoke(MessageContext messageContext, CancellationToken cancellationToken);
}
internal interface NServiceBus.IPipelineTerminator {
}
internal interface NServiceBus.IPublisherSource {
    public RouteSourcePriority Priority { get; }
    public abstract virtual IEnumerable`1<PublisherTableEntry> GenerateWithBestPracticeEnforcement(Conventions conventions);
    public abstract virtual IEnumerable`1<PublisherTableEntry> GenerateWithoutBestPracticeEnforcement(Conventions conventions);
    public abstract virtual RouteSourcePriority get_Priority();
}
internal interface NServiceBus.IRecoverabilityActionContextNotifications {
    public abstract virtual void Add(object notification);
}
internal interface NServiceBus.IRecoverabilityPipelineExecutor {
    public abstract virtual Task`1<ErrorHandleResult> Invoke(ErrorContext errorContext, CancellationToken cancellationToken);
}
internal interface NServiceBus.IRouteSource {
    public RouteSourcePriority Priority { get; }
    public abstract virtual IEnumerable`1<RouteTableEntry> GenerateRoutes(Conventions conventions);
    public abstract virtual RouteSourcePriority get_Priority();
}
internal interface NServiceBus.ISagaLoader {
    public abstract virtual Task`1<IContainSagaData> Load(ISagaPersister persister, string sagaId, ISynchronizedStorageSession storageSession, ContextBag context, CancellationToken cancellationToken);
}
internal interface NServiceBus.IStageConnector {
}
internal interface NServiceBus.IStageConnector`2 {
}
internal interface NServiceBus.IStageForkConnector`3 {
}
[NullableContextAttribute("1")]
public interface NServiceBus.IStartableEndpoint {
    public abstract virtual Task`1<IEndpointInstance> Start(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface NServiceBus.IStartableEndpointWithExternallyManagedContainer {
    public Lazy`1<IMessageSession> MessageSession { get; }
    public abstract virtual Task`1<IEndpointInstance> Start(IServiceProvider builder, CancellationToken cancellationToken);
    public abstract virtual Lazy`1<IMessageSession> get_MessageSession();
}
public interface NServiceBus.IToSagaExpression`1 {
    public abstract virtual void ToSaga(Expression`1<Func`2<TSagaData, object>> sagaEntityProperty);
}
internal interface NServiceBus.IUnicastPublishRouter {
    public abstract virtual Task`1<IEnumerable`1<UnicastRoutingStrategy>> Route(Type messageType, IDistributionPolicy distributionPolicy, IOutgoingPublishContext publishContext);
}
[NullableContextAttribute("1")]
public interface NServiceBus.IWantToRunBeforeConfigurationIsFinalized {
    public abstract virtual void Run(SettingsHolder settings);
}
internal static class NServiceBus.JsonPrettyPrinter : object {
    private static string LINE_INDENT;
    internal static string Print(string input);
    private static bool IsEscaped(string input, int i);
    private static void PrintIndent(StringBuilder sb, int indent);
}
[ExtensionAttribute]
internal static class NServiceBus.LambdaExpressionPrettyPrint : object {
    [ExtensionAttribute]
public static string PrettyPrint(List`1<Expression> expression);
}
public class NServiceBus.LearningPersistence : PersistenceDefinition {
}
internal class NServiceBus.LearningSagaIdGenerator : object {
    public sealed virtual Guid Generate(SagaIdGeneratorContext context);
    public static Guid Generate(Type sagaEntityType, string correlationPropertyName, object correlationPropertyValue);
}
internal class NServiceBus.LearningSagaPersister : object {
    private SagaManifestCollection sagaManifests;
    public LearningSagaPersister(SagaManifestCollection sagaManifests);
    public sealed virtual Task Save(IContainSagaData sagaData, SagaCorrelationProperty correlationProperty, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    public sealed virtual Task Update(IContainSagaData sagaData, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    public sealed virtual Task`1<TSagaData> Get(Guid sagaId, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    public sealed virtual Task`1<TSagaData> Get(string propertyName, object propertyValue, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    public sealed virtual Task Complete(IContainSagaData sagaData, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    private static Task`1<TSagaData> Get(Guid sagaId, ISynchronizedStorageSession session, SagaManifestCollection sagaManifests, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class NServiceBus.LearningSagaPersisterConfigurationExtensions : object {
    [ExtensionAttribute]
public static void SagaStorageDirectory(PersistenceExtensions`1<LearningPersistence> persistenceExtensions, string path);
}
internal class NServiceBus.LearningSynchronizedStorage : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.LearningSynchronizedStorageSession : object {
    private Dictionary`2<string, SagaStorageFile> sagaFiles;
    private List`1<StorageAction> deferredActions;
    public sealed virtual void Dispose();
    public sealed virtual ValueTask`1<bool> TryOpen(IOutboxTransaction transaction, ContextBag context, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<bool> TryOpen(TransportTransaction transportTransaction, ContextBag context, CancellationToken cancellationToken);
    public sealed virtual Task Open(ContextBag context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningSynchronizedStorageSession/<CompleteAsync>d__4")]
public sealed virtual Task CompleteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningSynchronizedStorageSession/<Read>d__5`1")]
public Task`1<TSagaData> Read(Guid sagaId, SagaManifestCollection sagaManifests, CancellationToken cancellationToken);
    public void Update(IContainSagaData sagaData, SagaManifestCollection sagaManifests);
    public void Save(IContainSagaData sagaData, SagaManifestCollection sagaManifests);
    public void Complete(IContainSagaData sagaData, SagaManifestCollection sagaManifests);
    [AsyncStateMachineAttribute("NServiceBus.LearningSynchronizedStorageSession/<Open>d__9")]
private Task`1<SagaStorageFile> Open(Guid sagaId, Type entityType, SagaManifestCollection sagaManifests, CancellationToken cancellationToken);
}
public class NServiceBus.LearningTransport : TransportDefinition {
    [CompilerGeneratedAttribute]
private string <StorageDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestrictPayloadSize>k__BackingField;
    public string StorageDirectory { get; public set; }
    public bool RestrictPayloadSize { get; public set; }
    public virtual Task`1<TransportInfrastructure> Initialize(HostSettings hostSettings, ReceiveSettings[] receivers, String[] sendingAddresses, CancellationToken cancellationToken);
    public virtual IReadOnlyCollection`1<TransportTransactionMode> GetSupportedTransactionModes();
    [CompilerGeneratedAttribute]
public string get_StorageDirectory();
    [CompilerGeneratedAttribute]
public void set_StorageDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_RestrictPayloadSize();
    [CompilerGeneratedAttribute]
public void set_RestrictPayloadSize(bool value);
}
[ExtensionAttribute]
[PreObsoleteAttribute("https://github.com/Particular/NServiceBus/issues/6811")]
public static class NServiceBus.LearningTransportConfigurationExtensions : object {
    [ExtensionAttribute]
[PreObsoleteAttribute("https://github.com/Particular/NServiceBus/issues/6811")]
public static TransportExtensions`1<LearningTransport> UseTransport(EndpointConfiguration config);
    [ExtensionAttribute]
[PreObsoleteAttribute("https://github.com/Particular/NServiceBus/issues/6811")]
public static void StorageDirectory(TransportExtensions`1<LearningTransport> transportExtensions, string path);
    [ExtensionAttribute]
[PreObsoleteAttribute("https://github.com/Particular/NServiceBus/issues/6811")]
public static void NoPayloadSizeRestriction(TransportExtensions`1<LearningTransport> transportExtensions);
}
internal class NServiceBus.LearningTransportDispatcher : object {
    private int maxMessageSizeKB;
    private string basePath;
    public LearningTransportDispatcher(string basePath, int maxMessageSizeKB);
    public sealed virtual Task Dispatch(TransportOperations outgoingMessages, TransportTransaction transaction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportDispatcher/<DispatchMulticast>d__2")]
private Task DispatchMulticast(IEnumerable`1<MulticastTransportOperation> transportOperations, TransportTransaction transaction, CancellationToken cancellationToken);
    private Task DispatchUnicast(IEnumerable`1<UnicastTransportOperation> operations, TransportTransaction transaction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportDispatcher/<WriteMessage>d__4")]
private Task WriteMessage(string destination, IOutgoingTransportOperation transportOperation, TransportTransaction transaction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportDispatcher/<GetSubscribersFor>d__5")]
private Task`1<IEnumerable`1<string>> GetSubscribersFor(Type messageType, CancellationToken cancellationToken);
    private static HashSet`1<Type> GetPotentialEventTypes(Type messageType);
    private static bool IsCoreMarkerInterface(Type type);
}
internal static class NServiceBus.LearningTransportHeaders : object {
    public static string TimeToBeReceived;
}
internal class NServiceBus.LearningTransportInfrastructure : TransportInfrastructure {
    private string storagePath;
    private HostSettings settings;
    private ReceiveSettings[] receiverSettings;
    private LearningTransport transport;
    private static string DefaultLearningTransportDirectory;
    public static string StorageLocationKey;
    public static string NoPayloadSizeRestrictionKey;
    public LearningTransportInfrastructure(HostSettings settings, LearningTransport transport, ReceiveSettings[] receiverSettings);
    private static string FindStoragePath();
    public void ConfigureReceiveInfrastructure();
    public IMessageReceiver CreateReceiver(ReceiveSettings receiveSettings);
    public void ConfigureSendInfrastructure();
    public virtual Task Shutdown(CancellationToken cancellationToken);
    public virtual string ToTransportAddress(QueueAddress queueAddress);
}
internal class NServiceBus.LearningTransportMessagePump : object {
    [CompilerGeneratedAttribute]
private ISubscriptionManager <Subscriptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiveAddress>k__BackingField;
    private CancellationTokenSource messagePumpCancellationTokenSource;
    private CancellationTokenSource messageProcessingCancellationTokenSource;
    private SemaphoreSlim concurrencyLimiter;
    private Task messagePumpTask;
    private string messagePumpBasePath;
    private DelayedMessagePoller delayedMessagePoller;
    private int maxConcurrency;
    private string bodyDir;
    private string pendingTransactionDir;
    private string committedTransactionDir;
    private string delayedDir;
    private OnMessage onMessage;
    private OnError onError;
    private ConcurrentDictionary`2<string, int> retryCounts;
    private string basePath;
    private Action`3<string, Exception, CancellationToken> criticalErrorAction;
    private ReceiveSettings receiveSettings;
    private TransportTransactionMode transactionMode;
    private static ILog log;
    public static string BodyFileSuffix;
    public static string BodyDirName;
    public static string DelayedDirName;
    private static string CommittedDirName;
    private static string PendingDirName;
    public ISubscriptionManager Subscriptions { get; }
    public string Id { get; }
    public string ReceiveAddress { get; }
    public LearningTransportMessagePump(string id, string receiveAddress, string basePath, Action`3<string, Exception, CancellationToken> criticalErrorAction, ISubscriptionManager subscriptionManager, ReceiveSettings receiveSettings, TransportTransactionMode transactionMode);
    private static LearningTransportMessagePump();
    public void Init();
    public sealed virtual Task Initialize(PushRuntimeSettings limitations, OnMessage onMessage, OnError onError, CancellationToken cancellationToken);
    public sealed virtual Task StartReceive(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportMessagePump/<StopReceive>d__4")]
public sealed virtual Task StopReceive(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportMessagePump/<ChangeConcurrency>d__5")]
public sealed virtual Task ChangeConcurrency(PushRuntimeSettings limitations, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ISubscriptionManager get_Subscriptions();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReceiveAddress();
    private void RecoverPendingTransactions();
    private void EnsureDirectoriesExists();
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportMessagePump/<PumpMessagesAndSwallowExceptions>d__17")]
[DebuggerNonUserCodeAttribute]
private Task PumpMessagesAndSwallowExceptions(CancellationToken messagePumpCancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportMessagePump/<PumpMessages>d__18")]
private Task PumpMessages(CancellationToken messagePumpCancellationToken);
    private ILearningTransportTransaction GetTransaction();
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportMessagePump/<ProcessMessageSwallowExceptionsAndReleaseConcurrencyLimiter>d__20")]
private Task ProcessMessageSwallowExceptionsAndReleaseConcurrencyLimiter(ILearningTransportTransaction transaction, string filePath, string messageId, CancellationToken messageProcessingCancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportMessagePump/<ProcessFileAndComplete>d__21")]
private Task ProcessFileAndComplete(ILearningTransportTransaction transaction, string filePath, string messageId, CancellationToken messageProcessingCancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportMessagePump/<ProcessFile>d__22")]
private Task ProcessFile(ILearningTransportTransaction transaction, string messageId, CancellationToken messageProcessingCancellationToken);
}
internal class NServiceBus.LearningTransportSubscriptionManager : object {
    private string basePath;
    private string endpointName;
    private string localAddress;
    public LearningTransportSubscriptionManager(string basePath, string endpointName, string localAddress);
    public sealed virtual Task SubscribeAll(MessageMetadata[] eventTypes, ContextBag context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportSubscriptionManager/<Unsubscribe>d__2")]
public sealed virtual Task Unsubscribe(MessageMetadata eventType, ContextBag context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.LearningTransportSubscriptionManager/<Subscribe>d__3")]
private Task Subscribe(MessageMetadata eventType, CancellationToken cancellationToken);
    private string GetSubscriptionEntryPath(string eventDir);
    private string GetEventDirectory(Type eventType);
}
internal class NServiceBus.LicenseManager : object {
    internal ActiveLicenseFindResult result;
    private static ILog Logger;
    public bool HasLicenseExpired { get; }
    private static LicenseManager();
    public bool get_HasLicenseExpired();
    public void InitializeLicense(string licenseText, string licenseFilePath);
    public static void LogLicenseStatus(LicenseStatus licenseStatus, ILog logger, License license, string developerLicenseUrl);
    private static void LogFindResults(ActiveLicenseFindResult result);
    private static void OpenDeveloperLicensePage(string developerLicenseUrl);
    private string CreateDeveloperLicenseUrl();
    private static string GetPlatformCode();
    private static string GetFrameworkVersion();
    [CompilerGeneratedAttribute]
internal static string <LogLicenseStatus>g__GetRemainingDaysString|3_0(Nullable`1<int> remainingDays);
}
internal static class NServiceBus.LicenseSources : object {
    public static LicenseSource[] GetLicenseSources(string licenseText, string licenseFilePath);
}
internal class NServiceBus.LoadHandlersConnector : StageConnector`2<IIncomingLogicalMessageContext, IInvokeHandlerContext> {
    private MessageHandlerRegistry messageHandlerRegistry;
    private static ILog logger;
    private static bool isDebugIsEnabled;
    private static string scopeInconsistencyMessage;
    public LoadHandlersConnector(MessageHandlerRegistry messageHandlerRegistry);
    private static LoadHandlersConnector();
    [AsyncStateMachineAttribute("NServiceBus.LoadHandlersConnector/<Invoke>d__1")]
public virtual Task Invoke(IIncomingLogicalMessageContext context, Func`2<IInvokeHandlerContext, Task> stage);
    private static void ValidateTransactionMode(IIncomingLogicalMessageContext context);
    private static void LogHandlersInvocation(IIncomingLogicalMessageContext context, List`1<MessageHandler> handlersToInvoke);
}
[ExtensionAttribute]
public static class NServiceBus.LoadMessageHandlersExtensions : object {
    [ExtensionAttribute]
public static void ExecuteTheseHandlersFirst(EndpointConfiguration config, IEnumerable`1<Type> handlerTypes);
    [ExtensionAttribute]
public static void ExecuteTheseHandlersFirst(EndpointConfiguration config, Type[] handlerTypes);
}
internal class NServiceBus.LoadSagaByIdWrapper`1 : object {
    [AsyncStateMachineAttribute("NServiceBus.LoadSagaByIdWrapper`1/<Load>d__0")]
public sealed virtual Task`1<IContainSagaData> Load(ISagaPersister persister, string sagaId, ISynchronizedStorageSession storageSession, ContextBag context, CancellationToken cancellationToken);
}
internal class NServiceBus.LogErrorOnInvalidLicenseBehavior : object {
    private static ILog Log;
    private static LogErrorOnInvalidLicenseBehavior();
    public sealed virtual Task Invoke(IIncomingPhysicalMessageContext context, Func`2<IIncomingPhysicalMessageContext, Task> next);
}
public class NServiceBus.Logging.DefaultFactory : LoggingFactoryDefinition {
    private Lazy`1<string> directory;
    private Lazy`1<LogLevel> level;
    protected internal virtual ILoggerFactory GetLoggingFactory();
    public void Level(LogLevel level);
    public void Directory(string directory);
}
public interface NServiceBus.Logging.ILog {
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
    public abstract virtual void Debug(string message);
    public abstract virtual void Debug(string message, Exception exception);
    public abstract virtual void DebugFormat(string format, Object[] args);
    public abstract virtual void Info(string message);
    public abstract virtual void Info(string message, Exception exception);
    public abstract virtual void InfoFormat(string format, Object[] args);
    public abstract virtual void Warn(string message);
    public abstract virtual void Warn(string message, Exception exception);
    public abstract virtual void WarnFormat(string format, Object[] args);
    public abstract virtual void Error(string message);
    public abstract virtual void Error(string message, Exception exception);
    public abstract virtual void ErrorFormat(string format, Object[] args);
    public abstract virtual void Fatal(string message);
    public abstract virtual void Fatal(string message, Exception exception);
    public abstract virtual void FatalFormat(string format, Object[] args);
}
public interface NServiceBus.Logging.ILoggerFactory {
    public abstract virtual ILog GetLogger(Type type);
    public abstract virtual ILog GetLogger(string name);
}
public abstract class NServiceBus.Logging.LoggingFactoryDefinition : object {
    protected internal abstract virtual ILoggerFactory GetLoggingFactory();
}
public enum NServiceBus.Logging.LogLevel : Enum {
    public int value__;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
    public static LogLevel Fatal;
}
public static class NServiceBus.Logging.LogManager : object {
    private static Lazy`1<ILoggerFactory> loggerFactory;
    private static LogManager();
    public static T Use();
    public static void UseFactory(ILoggerFactory loggerFactory);
    public static ILog GetLogger();
    public static ILog GetLogger(Type type);
    public static ILog GetLogger(string name);
}
internal class NServiceBus.MainPipelineExecutor : object {
    [CompilerGeneratedAttribute]
private IServiceProvider <rootBuilder>P;
    [CompilerGeneratedAttribute]
private IPipelineCache <pipelineCache>P;
    [CompilerGeneratedAttribute]
private MessageOperations <messageOperations>P;
    [CompilerGeneratedAttribute]
private INotificationSubscriptions`1<ReceivePipelineCompleted> <receivePipelineNotification>P;
    [CompilerGeneratedAttribute]
private IPipeline`1<ITransportReceiveContext> <receivePipeline>P;
    [CompilerGeneratedAttribute]
private IActivityFactory <activityFactory>P;
    [CompilerGeneratedAttribute]
private IncomingPipelineMetrics <incomingPipelineMetrics>P;
    public MainPipelineExecutor(IServiceProvider rootBuilder, IPipelineCache pipelineCache, MessageOperations messageOperations, INotificationSubscriptions`1<ReceivePipelineCompleted> receivePipelineNotification, IPipeline`1<ITransportReceiveContext> receivePipeline, IActivityFactory activityFactory, IncomingPipelineMetrics incomingPipelineMetrics);
    [AsyncStateMachineAttribute("NServiceBus.MainPipelineExecutor/<Invoke>d__8")]
public sealed virtual Task Invoke(MessageContext messageContext, CancellationToken cancellationToken);
}
internal class NServiceBus.MarkAsAcknowledgedBehavior : object {
    public sealed virtual Task Invoke(IAuditContext context, Func`2<IAuditContext, Task> next);
}
[ExtensionAttribute]
public static class NServiceBus.MessageCausationConfigurationExtensions : object {
    [ExtensionAttribute]
public static void CustomConversationIdStrategy(EndpointConfiguration endpointConfiguration, Func`2<ConversationIdStrategyContext, ConversationId> customStrategy);
}
public class NServiceBus.MessageDeserializationException : SerializationException {
    public MessageDeserializationException(string message);
    public MessageDeserializationException(string messageId, Exception innerException);
}
internal class NServiceBus.MessageDeserializerResolver : object {
    private IMessageSerializer mainSerializer;
    private Dictionary`2<string, IMessageSerializer> serializersMap;
    public MessageDeserializerResolver(IMessageSerializer mainSerializer, IEnumerable`1<IMessageSerializer> additionalDeserializers);
    public IMessageSerializer Resolve(Dictionary`2<string, string> headers);
}
internal class NServiceBus.MessageDrivenSubscribeTerminator : PipelineTerminator`1<ISubscribeContext> {
    private IMessageDispatcher dispatcher;
    private string subscriberAddress;
    private string subscriberEndpoint;
    private SubscriptionRouter subscriptionRouter;
    private static ILog Logger;
    public MessageDrivenSubscribeTerminator(SubscriptionRouter subscriptionRouter, ReceiveAddresses receiveAddresses, string subscriberEndpoint, IMessageDispatcher dispatcher);
    private static MessageDrivenSubscribeTerminator();
    [AsyncStateMachineAttribute("NServiceBus.MessageDrivenSubscribeTerminator/<Terminate>d__1")]
protected virtual Task Terminate(ISubscribeContext context);
    [AsyncStateMachineAttribute("NServiceBus.MessageDrivenSubscribeTerminator/<SendSubscribeMessageWithRetries>d__2")]
private Task SendSubscribeMessageWithRetries(string destination, OutgoingMessage subscriptionMessage, string messageType, ContextBag context, int retriesCount, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class NServiceBus.MessageDrivenSubscriptionsConfigExtensions : object {
    [ExtensionAttribute]
public static void SubscriptionAuthorizer(RoutingSettings`1<T> routingSettings, Func`2<IIncomingPhysicalMessageContext, bool> authorizer);
    [ExtensionAttribute]
internal static Func`2<IIncomingPhysicalMessageContext, bool> GetSubscriptionAuthorizer(IReadOnlySettings settings);
    [ExtensionAttribute]
public static void DisablePublishing(RoutingSettings`1<T> routingSettings);
    [ExtensionAttribute]
public static void RegisterPublisher(RoutingSettings`1<T> routingSettings, Type eventType, string publisherEndpoint);
    [ExtensionAttribute]
public static void RegisterPublisher(RoutingSettings`1<T> routingSettings, Assembly assembly, string publisherEndpoint);
    [ExtensionAttribute]
public static void RegisterPublisher(RoutingSettings`1<T> routingSettings, Assembly assembly, string namespace, string publisherEndpoint);
    private static void ThrowOnAddress(string publisherEndpoint);
}
internal class NServiceBus.MessageDrivenUnsubscribeTerminator : PipelineTerminator`1<IUnsubscribeContext> {
    private string endpoint;
    private IMessageDispatcher dispatcher;
    private string replyToAddress;
    private SubscriptionRouter subscriptionRouter;
    private static ILog Logger;
    public MessageDrivenUnsubscribeTerminator(SubscriptionRouter subscriptionRouter, ReceiveAddresses receiveAddresses, string endpoint, IMessageDispatcher dispatcher);
    private static MessageDrivenUnsubscribeTerminator();
    protected virtual Task Terminate(IUnsubscribeContext context);
    [AsyncStateMachineAttribute("NServiceBus.MessageDrivenUnsubscribeTerminator/<SendUnsubscribeMessageWithRetries>d__2")]
private Task SendUnsubscribeMessageWithRetries(string destination, OutgoingMessage unsubscribeMessage, string messageType, ContextBag context, int retriesCount, CancellationToken cancellationToken);
}
internal class NServiceBus.MessageFaulted : MessageProcessingFailed {
    [CompilerGeneratedAttribute]
private string <ErrorQueue>k__BackingField;
    public string ErrorQueue { get; }
    public MessageFaulted(string errorQueue, IncomingMessage failedMessage, Exception exception);
    [CompilerGeneratedAttribute]
public string get_ErrorQueue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NServiceBus.MessageHeaderToSagaExpression`2 : object {
    private IConfigureHowToFindSagaWithMessageHeaders sagaHeaderFindingConfiguration;
    private string headerName;
    public MessageHeaderToSagaExpression`2(IConfigureHowToFindSagaWithMessageHeaders sagaHeaderFindingConfiguration, string headerName);
    public sealed virtual void ToSaga(Expression`1<Func`2<TSagaData, object>> sagaEntityProperty);
}
[ExtensionAttribute]
public static class NServiceBus.MessageIdExtensions : object {
    [ExtensionAttribute]
public static void SetMessageId(ExtendableOptions options, string messageId);
    [ExtensionAttribute]
public static string GetMessageId(ExtendableOptions options);
}
public enum NServiceBus.MessageIntent : Enum {
    public int value__;
    public static MessageIntent Send;
    public static MessageIntent Publish;
    public static MessageIntent Subscribe;
    public static MessageIntent Unsubscribe;
    public static MessageIntent Reply;
}
public interface NServiceBus.MessageInterfaces.IMessageMapper {
    public abstract virtual void Initialize(IEnumerable`1<Type> types);
    public abstract virtual Type GetMappedTypeFor(Type t);
    public abstract virtual Type GetMappedTypeFor(string typeName);
}
public class NServiceBus.MessageInterfaces.MessageMapper.Reflection.MessageMapper : object {
    private object messageInitializationLock;
    private ConcurrentDictionary`2<Type, bool> initializedTypes;
    private ConcreteProxyCreator concreteProxyCreator;
    private ConcurrentDictionary`2<RuntimeTypeHandle, RuntimeTypeHandle> concreteToInterfaceTypeMapping;
    private ConcurrentDictionary`2<RuntimeTypeHandle, RuntimeTypeHandle> interfaceToConcreteTypeMapping;
    private ConcurrentDictionary`2<string, RuntimeTypeHandle> nameToType;
    private ConcurrentDictionary`2<RuntimeTypeHandle, RuntimeMethodHandle> typeToConstructor;
    public sealed virtual void Initialize(IEnumerable`1<Type> types);
    public sealed virtual Type GetMappedTypeFor(Type t);
    public sealed virtual Type GetMappedTypeFor(string typeName);
    public sealed virtual T CreateInstance(Action`1<T> action);
    public sealed virtual T CreateInstance();
    public sealed virtual object CreateInstance(Type t);
    private void InitType(Type t);
    private void InnerInitialize(Type t);
    private void GenerateImplementationFor(Type interfaceType);
    private static string GetTypeName(Type t);
}
[NullableContextAttribute("1")]
public interface NServiceBus.MessageMutator.IMutateIncomingMessages {
    public abstract virtual Task MutateIncoming(MutateIncomingMessageContext context);
}
[NullableContextAttribute("1")]
public interface NServiceBus.MessageMutator.IMutateIncomingTransportMessages {
    public abstract virtual Task MutateIncoming(MutateIncomingTransportMessageContext context);
}
[NullableContextAttribute("1")]
public interface NServiceBus.MessageMutator.IMutateOutgoingMessages {
    public abstract virtual Task MutateOutgoing(MutateOutgoingMessageContext context);
}
[NullableContextAttribute("1")]
public interface NServiceBus.MessageMutator.IMutateOutgoingTransportMessages {
    public abstract virtual Task MutateOutgoing(MutateOutgoingTransportMessageContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NServiceBus.MessageMutator.MutateIncomingMessageContext : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    private object message;
    internal bool MessageInstanceChanged;
    public object Message { get; public set; }
    public Dictionary`2<string, string> Headers { get; }
    public CancellationToken CancellationToken { get; }
    public MutateIncomingMessageContext(object message, Dictionary`2<string, string> headers, CancellationToken cancellationToken);
    public object get_Message();
    public void set_Message(object value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
}
public class NServiceBus.MessageMutator.MutateIncomingTransportMessageContext : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    private ReadOnlyMemory`1<byte> body;
    internal bool MessageBodyChanged;
    public ReadOnlyMemory`1<byte> Body { get; public set; }
    [NullableAttribute("1")]
public Dictionary`2<string, string> Headers { get; }
    public CancellationToken CancellationToken { get; }
    public MutateIncomingTransportMessageContext(ReadOnlyMemory`1<byte> body, Dictionary`2<string, string> headers, CancellationToken cancellationToken);
    public ReadOnlyMemory`1<byte> get_Body();
    public void set_Body(ReadOnlyMemory`1<byte> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NServiceBus.MessageMutator.MutateOutgoingMessageContext : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <OutgoingHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> incomingHeaders;
    [NullableAttribute("2")]
private object incomingMessage;
    internal bool MessageInstanceChanged;
    private object outgoingMessage;
    public object OutgoingMessage { get; public set; }
    public Dictionary`2<string, string> OutgoingHeaders { get; }
    public CancellationToken CancellationToken { get; }
    public MutateOutgoingMessageContext(object outgoingMessage, Dictionary`2<string, string> outgoingHeaders, object incomingMessage, IReadOnlyDictionary`2<string, string> incomingHeaders, CancellationToken cancellationToken);
    public object get_OutgoingMessage();
    public void set_OutgoingMessage(object value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_OutgoingHeaders();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [NullableContextAttribute("2")]
public bool TryGetIncomingMessage(Object& incomingMessage);
    public bool TryGetIncomingHeaders(IReadOnlyDictionary`2& incomingHeaders);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NServiceBus.MessageMutator.MutateOutgoingTransportMessageContext : object {
    [CompilerGeneratedAttribute]
private object <OutgoingMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <OutgoingHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, string> incomingHeaders;
    [NullableAttribute("2")]
private object incomingMessage;
    internal bool MessageBodyChanged;
    [NullableAttribute("0")]
private ReadOnlyMemory`1<byte> outgoingBody;
    public object OutgoingMessage { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> OutgoingBody { get; public set; }
    public Dictionary`2<string, string> OutgoingHeaders { get; }
    public CancellationToken CancellationToken { get; }
    public MutateOutgoingTransportMessageContext(ReadOnlyMemory`1<byte> outgoingBody, object outgoingMessage, Dictionary`2<string, string> outgoingHeaders, object incomingMessage, IReadOnlyDictionary`2<string, string> incomingHeaders, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public object get_OutgoingMessage();
    [NullableContextAttribute("0")]
public ReadOnlyMemory`1<byte> get_OutgoingBody();
    [NullableContextAttribute("0")]
public void set_OutgoingBody(ReadOnlyMemory`1<byte> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_OutgoingHeaders();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [NullableContextAttribute("2")]
public bool TryGetIncomingMessage(Object& incomingMessage);
    public bool TryGetIncomingHeaders(IReadOnlyDictionary`2& incomingHeaders);
}
[ExtensionAttribute]
public static class NServiceBus.MessageMutator.MutatorRegistrationExtensions : object {
    [ExtensionAttribute]
public static void RegisterMessageMutator(EndpointConfiguration endpointConfiguration, object messageMutator);
}
internal class NServiceBus.MessageOperations : object {
    private IMessageMapper messageMapper;
    protected IPipeline`1<IOutgoingPublishContext> publishPipeline;
    protected IPipeline`1<IOutgoingSendContext> sendPipeline;
    protected IPipeline`1<IOutgoingReplyContext> replyPipeline;
    protected IPipeline`1<ISubscribeContext> subscribePipeline;
    protected IPipeline`1<IUnsubscribeContext> unsubscribePipeline;
    protected IActivityFactory activityFactory;
    public MessageOperations(IMessageMapper messageMapper, IPipeline`1<IOutgoingPublishContext> publishPipeline, IPipeline`1<IOutgoingSendContext> sendPipeline, IPipeline`1<IOutgoingReplyContext> replyPipeline, IPipeline`1<ISubscribeContext> subscribePipeline, IPipeline`1<IUnsubscribeContext> unsubscribePipeline, IActivityFactory activityFactory);
    public Task Publish(IBehaviorContext context, Action`1<T> messageConstructor, PublishOptions options);
    public Task Publish(IBehaviorContext context, object message, PublishOptions options);
    [AsyncStateMachineAttribute("NServiceBus.MessageOperations/<Publish>d__10")]
private Task Publish(IBehaviorContext context, Type messageType, object message, PublishOptions options);
    public Task Subscribe(IBehaviorContext context, Type eventType, SubscribeOptions options);
    [AsyncStateMachineAttribute("NServiceBus.MessageOperations/<Subscribe>d__12")]
public Task Subscribe(IBehaviorContext context, Type[] eventTypes, SubscribeOptions options);
    [AsyncStateMachineAttribute("NServiceBus.MessageOperations/<Unsubscribe>d__13")]
public Task Unsubscribe(IBehaviorContext context, Type eventType, UnsubscribeOptions options);
    public Task Send(IBehaviorContext context, Action`1<T> messageConstructor, SendOptions options);
    public Task Send(IBehaviorContext context, object message, SendOptions options);
    [AsyncStateMachineAttribute("NServiceBus.MessageOperations/<SendMessage>d__16")]
private Task SendMessage(IBehaviorContext context, Type messageType, object message, SendOptions options);
    public Task Reply(IBehaviorContext context, object message, ReplyOptions options);
    public Task Reply(IBehaviorContext context, Action`1<T> messageConstructor, ReplyOptions options);
    [AsyncStateMachineAttribute("NServiceBus.MessageOperations/<ReplyMessage>d__19")]
private Task ReplyMessage(IBehaviorContext context, Type messageType, object message, ReplyOptions options);
    private static void MergeDispatchProperties(ContextBag context, DispatchProperties dispatchProperties);
}
[ExtensionAttribute]
public static class NServiceBus.MessageProcessingContextExtensions : object {
    [ExtensionAttribute]
public static Task Reply(IMessageProcessingContext context, object message);
    [ExtensionAttribute]
public static Task Reply(IMessageProcessingContext context, Action`1<T> messageConstructor);
}
internal abstract class NServiceBus.MessageProcessingFailed : object {
    [CompilerGeneratedAttribute]
private IncomingMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public IncomingMessage Message { get; }
    public Exception Exception { get; }
    protected MessageProcessingFailed(IncomingMessage failedMessage, Exception exception);
    [CompilerGeneratedAttribute]
public IncomingMessage get_Message();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
[ExtensionAttribute]
public static class NServiceBus.MessageProcessingOptimizationExtensions : object {
    [ExtensionAttribute]
public static void LimitMessageProcessingConcurrencyTo(EndpointConfiguration config, int maxConcurrency);
}
internal class NServiceBus.MessageSession : object {
    private IServiceProvider builder;
    private MessageOperations messageOperations;
    private PipelineCache pipelineCache;
    private CancellationToken endpointStoppingToken;
    internal static string SubscribeAllFlagKey;
    public MessageSession(IServiceProvider builder, MessageOperations messageOperations, PipelineCache pipelineCache, CancellationToken cancellationToken);
    private PipelineRootContext CreateContext(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.MessageSession/<Send>d__2")]
public sealed virtual Task Send(object message, SendOptions sendOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.MessageSession/<Send>d__3`1")]
public sealed virtual Task Send(Action`1<T> messageConstructor, SendOptions sendOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.MessageSession/<Publish>d__4")]
public sealed virtual Task Publish(object message, PublishOptions publishOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.MessageSession/<Publish>d__5`1")]
public sealed virtual Task Publish(Action`1<T> messageConstructor, PublishOptions publishOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.MessageSession/<Subscribe>d__6")]
public sealed virtual Task Subscribe(Type eventType, SubscribeOptions subscribeOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.MessageSession/<SubscribeAll>d__7")]
public Task SubscribeAll(Type[] eventTypes, SubscribeOptions subscribeOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.MessageSession/<Unsubscribe>d__8")]
public sealed virtual Task Unsubscribe(Type eventType, UnsubscribeOptions unsubscribeOptions, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class NServiceBus.MessageSessionExtensions : object {
    [ExtensionAttribute]
public static Task Send(IMessageSession session, object message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Send(IMessageSession session, Action`1<T> messageConstructor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Send(IMessageSession session, string destination, object message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Send(IMessageSession session, string destination, Action`1<T> messageConstructor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendLocal(IMessageSession session, object message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendLocal(IMessageSession session, Action`1<T> messageConstructor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Publish(IMessageSession session, object message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Publish(IMessageSession session, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Publish(IMessageSession session, Action`1<T> messageConstructor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Subscribe(IMessageSession session, Type messageType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Subscribe(IMessageSession session, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Unsubscribe(IMessageSession session, Type messageType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task Unsubscribe(IMessageSession session, CancellationToken cancellationToken);
}
internal class NServiceBus.MessageToBeRetried : MessageProcessingFailed {
    [CompilerGeneratedAttribute]
private int <Attempt>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Delay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImmediateRetry>k__BackingField;
    public int Attempt { get; }
    public TimeSpan Delay { get; }
    public bool IsImmediateRetry { get; }
    public MessageToBeRetried(int attempt, TimeSpan delay, bool immediateRetry, IncomingMessage failedMessage, Exception exception);
    [CompilerGeneratedAttribute]
public int get_Attempt();
    [CompilerGeneratedAttribute]
public TimeSpan get_Delay();
    [CompilerGeneratedAttribute]
public bool get_IsImmediateRetry();
}
internal static class NServiceBus.MeterTags : object {
    public static string EndpointDiscriminator;
    public static string QueueName;
    public static string MessageType;
    public static string MessageHandlerTypes;
    public static string MessageHandlerType;
    public static string ExecutionResult;
    public static string ErrorType;
}
[ExtensionAttribute]
internal static class NServiceBus.MetricsExtensions : object {
    [ExtensionAttribute]
public static bool TryGetTimeSent(Dictionary`2<string, string> headers, DateTimeOffset& timeSent);
    [ExtensionAttribute]
public static bool TryGetDeliverAt(Dictionary`2<string, string> headers, DateTimeOffset& deliverAt);
}
internal class NServiceBus.MigrationModePublishConnector : StageConnector`2<IOutgoingPublishContext, IOutgoingLogicalMessageContext> {
    private DistributionPolicy distributionPolicy;
    private IUnicastPublishRouter unicastPublishRouter;
    public MigrationModePublishConnector(DistributionPolicy distributionPolicy, IUnicastPublishRouter unicastPublishRouter);
    [AsyncStateMachineAttribute("NServiceBus.MigrationModePublishConnector/<Invoke>d__1")]
public virtual Task Invoke(IOutgoingPublishContext context, Func`2<IOutgoingLogicalMessageContext, Task> stage);
    [AsyncStateMachineAttribute("NServiceBus.MigrationModePublishConnector/<GetRoutingStrategies>d__2")]
private Task`1<List`1<UnicastRoutingStrategy>> GetRoutingStrategies(IOutgoingPublishContext context, Type eventType);
}
internal class NServiceBus.MigrationSubscribeTerminator : PipelineTerminator`1<ISubscribeContext> {
    private SubscriptionRouter subscriptionRouter;
    private string subscriberAddress;
    private string subscriberEndpoint;
    private IMessageDispatcher dispatcher;
    private ISubscriptionManager subscriptionManager;
    private MessageMetadataRegistry messageMetadataRegistry;
    private static ILog Logger;
    public MigrationSubscribeTerminator(ISubscriptionManager subscriptionManager, MessageMetadataRegistry messageMetadataRegistry, SubscriptionRouter subscriptionRouter, IMessageDispatcher dispatcher, ReceiveAddresses receiveAddresses, string subscriberEndpoint);
    private static MigrationSubscribeTerminator();
    [AsyncStateMachineAttribute("NServiceBus.MigrationSubscribeTerminator/<Terminate>d__1")]
protected virtual Task Terminate(ISubscribeContext context);
    [AsyncStateMachineAttribute("NServiceBus.MigrationSubscribeTerminator/<SendSubscribeMessageWithRetries>d__2")]
private Task SendSubscribeMessageWithRetries(string destination, OutgoingMessage subscriptionMessage, string messageType, ContextBag context, int retriesCount, CancellationToken cancellationToken);
}
internal class NServiceBus.MigrationUnsubscribeTerminator : PipelineTerminator`1<IUnsubscribeContext> {
    private ISubscriptionManager subscriptionManager;
    private MessageMetadataRegistry messageMetadataRegistry;
    private string endpoint;
    private IMessageDispatcher dispatcher;
    private string replyToAddress;
    private SubscriptionRouter subscriptionRouter;
    private static ILog Logger;
    public MigrationUnsubscribeTerminator(ISubscriptionManager subscriptionManager, MessageMetadataRegistry messageMetadataRegistry, SubscriptionRouter subscriptionRouter, IMessageDispatcher dispatcher, ReceiveAddresses receiveAddresses, string endpoint);
    private static MigrationUnsubscribeTerminator();
    [AsyncStateMachineAttribute("NServiceBus.MigrationUnsubscribeTerminator/<Terminate>d__1")]
protected virtual Task Terminate(IUnsubscribeContext context);
    [AsyncStateMachineAttribute("NServiceBus.MigrationUnsubscribeTerminator/<SendUnsubscribeMessageWithRetries>d__2")]
private Task SendUnsubscribeMessageWithRetries(string destination, OutgoingMessage unsubscribeMessage, string messageType, ContextBag context, int retriesCount, CancellationToken cancellationToken);
}
public class NServiceBus.MoveToError : RecoverabilityAction {
    [CompilerGeneratedAttribute]
private string <ErrorQueue>k__BackingField;
    private static ILog Logger;
    public string ErrorQueue { get; }
    public ErrorHandleResult ErrorHandleResult { get; }
    protected internal MoveToError(string errorQueue);
    private static MoveToError();
    [CompilerGeneratedAttribute]
public string get_ErrorQueue();
    public virtual ErrorHandleResult get_ErrorHandleResult();
    public virtual IReadOnlyCollection`1<IRoutingContext> GetRoutingContexts(IRecoverabilityActionContext context);
}
internal class NServiceBus.MulticastPublishConnector : StageConnector`2<IOutgoingPublishContext, IOutgoingLogicalMessageContext> {
    public virtual Task Invoke(IOutgoingPublishContext context, Func`2<IOutgoingLogicalMessageContext, Task> stage);
}
internal class NServiceBus.MutateIncomingMessageBehavior : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasIncomingMessageMutators;
    private HashSet`1<IMutateIncomingMessages> mutators;
    public MutateIncomingMessageBehavior(HashSet`1<IMutateIncomingMessages> mutators);
    public sealed virtual Task Invoke(IIncomingLogicalMessageContext context, Func`2<IIncomingLogicalMessageContext, Task> next);
    [AsyncStateMachineAttribute("NServiceBus.MutateIncomingMessageBehavior/<InvokeIncomingMessageMutators>d__2")]
private Task InvokeIncomingMessageMutators(IIncomingLogicalMessageContext context, Func`2<IIncomingLogicalMessageContext, Task> next);
}
internal class NServiceBus.MutateIncomingTransportMessageBehavior : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasIncomingTransportMessageMutators;
    private HashSet`1<IMutateIncomingTransportMessages> mutators;
    public MutateIncomingTransportMessageBehavior(HashSet`1<IMutateIncomingTransportMessages> mutators);
    public sealed virtual Task Invoke(IIncomingPhysicalMessageContext context, Func`2<IIncomingPhysicalMessageContext, Task> next);
    [AsyncStateMachineAttribute("NServiceBus.MutateIncomingTransportMessageBehavior/<InvokeIncomingTransportMessagesMutators>d__2")]
private Task InvokeIncomingTransportMessagesMutators(IIncomingPhysicalMessageContext context, Func`2<IIncomingPhysicalMessageContext, Task> next);
}
internal class NServiceBus.MutateOutgoingMessageBehavior : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasOutgoingMessageMutators;
    private HashSet`1<IMutateOutgoingMessages> mutators;
    public MutateOutgoingMessageBehavior(HashSet`1<IMutateOutgoingMessages> mutators);
    public sealed virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
    [AsyncStateMachineAttribute("NServiceBus.MutateOutgoingMessageBehavior/<InvokeOutgoingMessageMutators>d__2")]
private Task InvokeOutgoingMessageMutators(IOutgoingLogicalMessageContext context, Func`2<IOutgoingLogicalMessageContext, Task> next);
}
internal class NServiceBus.MutateOutgoingTransportMessageBehavior : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasOutgoingTransportMessageMutators;
    private HashSet`1<IMutateOutgoingTransportMessages> mutators;
    public MutateOutgoingTransportMessageBehavior(HashSet`1<IMutateOutgoingTransportMessages> mutators);
    public sealed virtual Task Invoke(IOutgoingPhysicalMessageContext context, Func`2<IOutgoingPhysicalMessageContext, Task> next);
    [AsyncStateMachineAttribute("NServiceBus.MutateOutgoingTransportMessageBehavior/<InvokeOutgoingTransportMessageMutators>d__2")]
private Task InvokeOutgoingTransportMessageMutators(IOutgoingPhysicalMessageContext context, Func`2<IOutgoingPhysicalMessageContext, Task> next);
}
internal class NServiceBus.NamedLogger : object {
    [CompilerGeneratedAttribute]
private bool <IsDebugEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInfoEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWarnEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsErrorEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFatalEnabled>k__BackingField;
    private DefaultLoggerFactory defaultLoggerFactory;
    private string name;
    public bool IsDebugEnabled { get; internal set; }
    public bool IsInfoEnabled { get; internal set; }
    public bool IsWarnEnabled { get; internal set; }
    public bool IsErrorEnabled { get; internal set; }
    public bool IsFatalEnabled { get; internal set; }
    public NamedLogger(string name, DefaultLoggerFactory defaultLoggerFactory);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDebugEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsDebugEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInfoEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsInfoEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsWarnEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsWarnEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsErrorEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsErrorEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFatalEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsFatalEnabled(bool value);
    public sealed virtual void Debug(string message);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void DebugFormat(string format, Object[] args);
    public sealed virtual void Info(string message);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void InfoFormat(string format, Object[] args);
    public sealed virtual void Warn(string message);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void WarnFormat(string format, Object[] args);
    public sealed virtual void Error(string message);
    public sealed virtual void Error(string message, Exception exception);
    public sealed virtual void ErrorFormat(string format, Object[] args);
    public sealed virtual void Fatal(string message);
    public sealed virtual void Fatal(string message, Exception exception);
    public sealed virtual void FatalFormat(string format, Object[] args);
}
internal class NServiceBus.NamespacePublisherSource : object {
    private Assembly messageAssembly;
    private string messageNamespace;
    private PublisherAddress address;
    public RouteSourcePriority Priority { get; }
    public NamespacePublisherSource(Assembly messageAssembly, string messageNamespace, PublisherAddress address);
    public sealed virtual IEnumerable`1<PublisherTableEntry> GenerateWithBestPracticeEnforcement(Conventions conventions);
    public sealed virtual IEnumerable`1<PublisherTableEntry> GenerateWithoutBestPracticeEnforcement(Conventions conventions);
    public sealed virtual RouteSourcePriority get_Priority();
}
internal class NServiceBus.NamespaceRouteSource : object {
    private Assembly messageAssembly;
    private string messageNamespace;
    private UnicastRoute route;
    public RouteSourcePriority Priority { get; }
    public NamespaceRouteSource(Assembly messageAssembly, string messageNamespace, UnicastRoute route);
    public sealed virtual IEnumerable`1<RouteTableEntry> GenerateRoutes(Conventions conventions);
    public sealed virtual RouteSourcePriority get_Priority();
}
internal class NServiceBus.NativeSubscribeTerminator : PipelineTerminator`1<ISubscribeContext> {
    private ISubscriptionManager subscriptionManager;
    private MessageMetadataRegistry messageMetadataRegistry;
    public NativeSubscribeTerminator(ISubscriptionManager subscriptionManager, MessageMetadataRegistry messageMetadataRegistry);
    [AsyncStateMachineAttribute("NServiceBus.NativeSubscribeTerminator/<Terminate>d__1")]
protected virtual Task Terminate(ISubscribeContext context);
}
internal class NServiceBus.NativeUnsubscribeTerminator : PipelineTerminator`1<IUnsubscribeContext> {
    private ISubscriptionManager subscriptionManager;
    private MessageMetadataRegistry messageMetadataRegistry;
    public NativeUnsubscribeTerminator(ISubscriptionManager subscriptionManager, MessageMetadataRegistry messageMetadataRegistry);
    protected virtual Task Terminate(IUnsubscribeContext context);
}
internal class NServiceBus.NoOpActivityFactory : object {
    public sealed virtual Activity StartIncomingPipelineActivity(MessageContext context);
    public sealed virtual Activity StartOutgoingPipelineActivity(string activityName, string displayName, IBehaviorContext outgoingContext);
    public sealed virtual Activity StartHandlerActivity(MessageHandler messageHandler, ActiveSagaInstance saga);
}
internal class NServiceBus.NoOpCompletableSynchronizedStorageSession : object {
    public static ICompletableSynchronizedStorageSession Instance;
    private static NoOpCompletableSynchronizedStorageSession();
    public sealed virtual ValueTask`1<bool> TryOpen(IOutboxTransaction transaction, ContextBag context, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<bool> TryOpen(TransportTransaction transportTransaction, ContextBag context, CancellationToken cancellationToken);
    public sealed virtual Task Open(ContextBag context, CancellationToken cancellationToken);
    public sealed virtual Task CompleteAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
internal class NServiceBus.NoOpOutboxStorage : object {
    private static Task`1<OutboxMessage> NoOutboxMessageTask;
    private static Task`1<IOutboxTransaction> NoOutboxTransactionTask;
    private static NoOpOutboxStorage();
    public sealed virtual Task`1<OutboxMessage> Get(string messageId, ContextBag options, CancellationToken cancellationToken);
    public sealed virtual Task Store(OutboxMessage message, IOutboxTransaction transaction, ContextBag options, CancellationToken cancellationToken);
    public sealed virtual Task SetAsDispatched(string messageId, ContextBag options, CancellationToken cancellationToken);
    public sealed virtual Task`1<IOutboxTransaction> BeginTransaction(ContextBag context, CancellationToken cancellationToken);
}
internal class NServiceBus.NoOpOutboxTransaction : object {
    public sealed virtual void Dispose();
    public sealed virtual Task Commit(CancellationToken cancellationToken);
}
internal class NServiceBus.Notification`1 : object {
    private List`1<Func`3<TEvent, CancellationToken, Task>> subscriptions;
    public void Subscribe(Func`3<TEvent, CancellationToken, Task> subscription);
    private sealed virtual override Task NServiceBus.INotificationSubscriptions<TEvent>.Raise(TEvent event, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Error notification events have been replaced with a Task-based API available on the recoverability settings. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public class NServiceBus.Notifications : object {
}
internal class NServiceBus.NoTransaction : object {
    [CompilerGeneratedAttribute]
private string <FileToProcess>k__BackingField;
    private string processingDirectory;
    public string FileToProcess { get; private set; }
    public NoTransaction(string basePath, string pendingDirName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileToProcess();
    [CompilerGeneratedAttribute]
private void set_FileToProcess(string value);
    public sealed virtual Task`1<bool> BeginTransaction(string incomingFilePath, CancellationToken cancellationToken);
    public sealed virtual Task Enlist(string messagePath, string messageContents, CancellationToken cancellationToken);
    public sealed virtual Task Commit(CancellationToken cancellationToken);
    public sealed virtual void Rollback();
    public sealed virtual void ClearPendingOutgoingOperations();
    public sealed virtual bool Complete();
}
public class NServiceBus.NServiceBusMarkerInterfaceConvention : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    public sealed virtual bool IsCommandType(Type type);
    public sealed virtual bool IsEventType(Type type);
    public sealed virtual bool IsMessageType(Type type);
}
[ExtensionAttribute]
[ObsoleteAttribute("Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static class NServiceBus.ObjectBuilder.ServiceProviderExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceProvider.GetService` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static object Build(IServiceProvider serviceProvider, Type typeToBuild);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceProvider.CreateScope` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static IServiceScope CreateChildBuilder(IServiceProvider serviceProvider);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceProvider.GetService` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static T Build(IServiceProvider serviceProvider);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceProvider.GetServices` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static IEnumerable`1<T> BuildAll(IServiceProvider serviceProvider);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceProvider.GetServices` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static IEnumerable`1<object> BuildAll(IServiceProvider serviceProvider, Type typeToBuild);
}
public class NServiceBus.OnSatelliteMessage : MulticastDelegate {
    public OnSatelliteMessage(object object, IntPtr method);
    public virtual Task Invoke(IServiceProvider serviceProvider, MessageContext messageContext, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(IServiceProvider serviceProvider, MessageContext messageContext, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class NServiceBus.OpenTelemetryConfigurationExtensions : object {
    [ExtensionAttribute]
public static void EnableOpenTelemetry(EndpointConfiguration endpointConfiguration);
}
[ExtensionAttribute]
public static class NServiceBus.OpenTelemetryExtensions : object {
    [ExtensionAttribute]
public static void StartNewTraceOnReceive(SendOptions sendOptions);
    [ExtensionAttribute]
public static void ContinueExistingTraceOnReceive(PublishOptions publishOptions);
}
internal class NServiceBus.OpenTelemetryFeature : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
internal class NServiceBus.OpenTelemetryPublishBehavior : object {
    public static string ContinueTraceOnReceive;
    public sealed virtual Task Invoke(IOutgoingPublishContext context, Func`2<IOutgoingPublishContext, Task> next);
}
internal class NServiceBus.OpenTelemetrySendBehavior : object {
    public static string StartNewTraceOnReceive;
    public sealed virtual Task Invoke(IOutgoingSendContext context, Func`2<IOutgoingSendContext, Task> next);
}
public interface NServiceBus.Outbox.IOutboxStorage {
    public abstract virtual Task`1<OutboxMessage> Get(string messageId, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task Store(OutboxMessage message, IOutboxTransaction transaction, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task SetAsDispatched(string messageId, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task`1<IOutboxTransaction> BeginTransaction(ContextBag context, CancellationToken cancellationToken);
}
public interface NServiceBus.Outbox.IOutboxTransaction {
    public abstract virtual Task Commit(CancellationToken cancellationToken);
}
public class NServiceBus.Outbox.OutboxMessage : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportOperation[] <TransportOperations>k__BackingField;
    public string MessageId { get; }
    public TransportOperation[] TransportOperations { get; }
    public OutboxMessage(string messageId, TransportOperation[] operations);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public TransportOperation[] get_TransportOperations();
}
public class NServiceBus.Outbox.OutboxSettings : ExposeSettings {
    internal OutboxSettings(SettingsHolder settings);
}
public class NServiceBus.Outbox.TransportOperation : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchProperties <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    public string MessageId { get; }
    public DispatchProperties Options { get; }
    public ReadOnlyMemory`1<byte> Body { get; }
    public Dictionary`2<string, string> Headers { get; }
    public TransportOperation(string messageId, DispatchProperties properties, ReadOnlyMemory`1<byte> body, Dictionary`2<string, string> headers);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public DispatchProperties get_Options();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
}
[ExtensionAttribute]
public static class NServiceBus.OutboxConfigExtensions : object {
    [ExtensionAttribute]
public static OutboxSettings EnableOutbox(EndpointConfiguration config);
}
internal abstract class NServiceBus.OutgoingContext : BehaviorContext {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    private MessageOperations MessageOperations { get; }
    public string MessageId { get; }
    public Dictionary`2<string, string> Headers { get; }
    protected OutgoingContext(string messageId, Dictionary`2<string, string> headers, IBehaviorContext parentContext);
    private MessageOperations get_MessageOperations();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageId();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Headers();
    public sealed virtual Task Send(object message, SendOptions options);
    public sealed virtual Task Send(Action`1<T> messageConstructor, SendOptions options);
    public sealed virtual Task Publish(object message, PublishOptions options);
    public sealed virtual Task Publish(Action`1<T> messageConstructor, PublishOptions publishOptions);
    public Task Subscribe(Type eventType, SubscribeOptions options);
    public Task Unsubscribe(Type eventType, UnsubscribeOptions options);
}
internal class NServiceBus.OutgoingLogicalMessageContext : OutgoingContext {
    [CompilerGeneratedAttribute]
private OutgoingLogicalMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<RoutingStrategy> <RoutingStrategies>k__BackingField;
    public OutgoingLogicalMessage Message { get; private set; }
    public IReadOnlyCollection`1<RoutingStrategy> RoutingStrategies { get; }
    public OutgoingLogicalMessageContext(string messageId, Dictionary`2<string, string> headers, OutgoingLogicalMessage message, IReadOnlyCollection`1<RoutingStrategy> routingStrategies, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual OutgoingLogicalMessage get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(OutgoingLogicalMessage value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<RoutingStrategy> get_RoutingStrategies();
    public sealed virtual void UpdateMessage(object newInstance);
}
internal class NServiceBus.OutgoingPhysicalMessageContext : OutgoingContext {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<RoutingStrategy> <RoutingStrategies>k__BackingField;
    public ReadOnlyMemory`1<byte> Body { get; private set; }
    public IReadOnlyCollection`1<RoutingStrategy> RoutingStrategies { get; }
    public OutgoingPhysicalMessageContext(ReadOnlyMemory`1<byte> body, IReadOnlyCollection`1<RoutingStrategy> routingStrategies, IOutgoingLogicalMessageContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(ReadOnlyMemory`1<byte> value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<RoutingStrategy> get_RoutingStrategies();
    public sealed virtual void UpdateMessage(ReadOnlyMemory`1<byte> body);
}
internal class NServiceBus.OutgoingPhysicalToRoutingConnector : StageConnector`2<IOutgoingPhysicalMessageContext, IRoutingContext> {
    public virtual Task Invoke(IOutgoingPhysicalMessageContext context, Func`2<IRoutingContext, Task> stage);
}
internal class NServiceBus.OutgoingPublishContext : OutgoingContext {
    [CompilerGeneratedAttribute]
private OutgoingLogicalMessage <Message>k__BackingField;
    public OutgoingLogicalMessage Message { get; }
    public OutgoingPublishContext(OutgoingLogicalMessage message, string messageId, Dictionary`2<string, string> headers, ContextBag extensions, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual OutgoingLogicalMessage get_Message();
}
internal class NServiceBus.OutgoingReplyContext : OutgoingContext {
    [CompilerGeneratedAttribute]
private OutgoingLogicalMessage <Message>k__BackingField;
    public OutgoingLogicalMessage Message { get; }
    public OutgoingReplyContext(OutgoingLogicalMessage message, string messageId, Dictionary`2<string, string> headers, ContextBag extensions, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual OutgoingLogicalMessage get_Message();
}
internal class NServiceBus.OutgoingSendContext : OutgoingContext {
    [CompilerGeneratedAttribute]
private OutgoingLogicalMessage <Message>k__BackingField;
    public OutgoingLogicalMessage Message { get; }
    public OutgoingSendContext(OutgoingLogicalMessage message, string messageId, Dictionary`2<string, string> headers, ContextBag extensions, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual OutgoingLogicalMessage get_Message();
}
internal class NServiceBus.OverridableMessageConvention : object {
    private IMessageConvention inner;
    private Func`2<Type, bool> isCommandType;
    private Func`2<Type, bool> isEventType;
    private Func`2<Type, bool> isMessageType;
    public string Name { get; }
    public bool ConventionModified { get; }
    public OverridableMessageConvention(IMessageConvention inner);
    public sealed virtual string get_Name();
    public sealed virtual bool IsCommandType(Type type);
    public sealed virtual bool IsEventType(Type type);
    public sealed virtual bool IsMessageType(Type type);
    public void DefiningCommandsAs(Func`2<Type, bool> isCommandType);
    public void DefiningEventsAs(Func`2<Type, bool> isEventType);
    public void DefiningMessagesAs(Func`2<Type, bool> isMessageType);
    public bool get_ConventionModified();
}
internal static class NServiceBus.PathChecker : object {
    public static void ThrowForBadPath(string value, string valueName);
}
internal static class NServiceBus.PathUtilities : object {
    public static string SanitizedPath(string commandLine);
}
public class NServiceBus.PendingTransportOperations : object {
    private ConcurrentStack`1<TransportOperation> operations;
    public TransportOperation[] Operations { get; }
    public bool HasOperations { get; }
    public TransportOperation[] get_Operations();
    public bool get_HasOperations();
    public void Add(TransportOperation transportOperation);
    public void AddRange(TransportOperation[] transportOperations);
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
internal static void <AddRange>g__ThrowArgumentNullException|5_0(string paramName);
    [CompilerGeneratedAttribute]
[DoesNotReturnAttribute]
internal static void <AddRange>g__ThrowArgumentOutOfRangeException|5_1(string paramName);
}
public class NServiceBus.Performance.TimeToBeReceived.DiscardIfNotReceivedBefore : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxTime>k__BackingField;
    public TimeSpan MaxTime { get; }
    public DiscardIfNotReceivedBefore(TimeSpan maxTime);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxTime();
}
[ExtensionAttribute]
public static class NServiceBus.Persistence.CompletableSynchronizedStorageSessionExtensions : object {
    [ExtensionAttribute]
public static ValueTask Open(ICompletableSynchronizedStorageSession session, IIncomingLogicalMessageContext context);
    [AsyncStateMachineAttribute("NServiceBus.Persistence.CompletableSynchronizedStorageSessionExtensions/<Open>d__1")]
[ExtensionAttribute]
public static ValueTask Open(ICompletableSynchronizedStorageSession session, IOutboxTransaction outboxTransaction, TransportTransaction transportTransaction, ContextBag contextBag, CancellationToken cancellationToken);
}
public interface NServiceBus.Persistence.ICompletableSynchronizedStorageSession {
    public abstract virtual ValueTask`1<bool> TryOpen(IOutboxTransaction transaction, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<bool> TryOpen(TransportTransaction transportTransaction, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task Open(ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task CompleteAsync(CancellationToken cancellationToken);
}
public interface NServiceBus.Persistence.ISynchronizedStorageSession {
}
public abstract class NServiceBus.Persistence.PersistenceDefinition : object {
    private List`1<Action`1<SettingsHolder>> defaults;
    private Dictionary`2<Type, Action`1<SettingsHolder>> storageToActionMap;
    protected void Supports(Action`1<SettingsHolder> action);
    protected void Defaults(Action`1<SettingsHolder> action);
    public bool HasSupportFor();
    public bool HasSupportFor(Type storageType);
    internal void ApplyActionForStorage(Type storageType, SettingsHolder settings);
    internal void ApplyDefaults(SettingsHolder settings);
    internal List`1<Type> GetSupportedStorages(List`1<Type> selectedStorages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NServiceBus.PersistenceConfig : object {
    [ExtensionAttribute]
public static PersistenceExtensions`1<T> UsePersistence(EndpointConfiguration config);
    [ExtensionAttribute]
public static PersistenceExtensions`2<T, S> UsePersistence(EndpointConfiguration config);
    [ExtensionAttribute]
public static PersistenceExtensions UsePersistence(EndpointConfiguration config, Type definitionType);
}
public class NServiceBus.PersistenceExtensions : ExposeSettings {
    public PersistenceExtensions(Type definitionType, SettingsHolder settings, Type storageType);
}
public class NServiceBus.PersistenceExtensions`1 : PersistenceExtensions {
    public PersistenceExtensions`1(SettingsHolder settings);
    protected PersistenceExtensions`1(SettingsHolder settings, Type storageType);
}
public class NServiceBus.PersistenceExtensions`2 : PersistenceExtensions`1<T> {
    public PersistenceExtensions`2(SettingsHolder settings);
}
internal class NServiceBus.PersistenceStartup : object {
    private static ILog Logger;
    private static PersistenceStartup();
    public sealed virtual void Run(SettingsHolder settings);
    private static void ValidateSagaAndOutboxUseSamePersistence(List`1<EnabledPersistence> enabledPersistences, SettingsHolder settings);
    internal static bool HasSupportFor(IReadOnlySettings settings);
}
internal class NServiceBus.PersistenceStorageMerger : object {
    public static List`1<EnabledPersistence> Merge(List`1<EnabledPersistence> definitions, SettingsHolder settings);
}
public abstract class NServiceBus.Pipeline.Behavior`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual Task Invoke(TContext context, Func`2<TContext, Task> next);
    [NullableContextAttribute("1")]
public abstract virtual Task Invoke(TContext context, Func`1<Task> next);
}
public abstract class NServiceBus.Pipeline.ForkConnector`2 : Behavior`1<TFromContext> {
    public abstract virtual Task Invoke(TFromContext context, Func`1<Task> next, Func`2<TForkContext, Task> fork);
    public sealed virtual Task Invoke(TFromContext context, Func`1<Task> next);
}
public interface NServiceBus.Pipeline.IAuditActionContext {
    public OutgoingMessage Message { get; }
    public IReadOnlyDictionary`2<string, string> AuditMetadata { get; }
    public string AuditAddress { get; }
    public Nullable`1<TimeSpan> TimeToBeReceived { get; }
    public abstract virtual OutgoingMessage get_Message();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_AuditMetadata();
    public abstract virtual string get_AuditAddress();
    public abstract virtual Nullable`1<TimeSpan> get_TimeToBeReceived();
}
public interface NServiceBus.Pipeline.IAuditContext {
    public OutgoingMessage Message { get; }
    public string AuditAddress { get; }
    public Nullable`1<TimeSpan> TimeToBeReceived { get; }
    public Dictionary`2<string, string> AuditMetadata { get; }
    public AuditAction AuditAction { get; public set; }
    public abstract virtual OutgoingMessage get_Message();
    public abstract virtual string get_AuditAddress();
    public abstract virtual Nullable`1<TimeSpan> get_TimeToBeReceived();
    public abstract virtual Dictionary`2<string, string> get_AuditMetadata();
    public abstract virtual AuditAction get_AuditAction();
    public abstract virtual void set_AuditAction(AuditAction value);
    public abstract virtual IAuditActionContext PreventChanges();
    [ObsoleteAttribute("Use `AuditMetadata` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public virtual void AddAuditData(string key, string value);
}
public interface NServiceBus.Pipeline.IBatchDispatchContext {
    public IReadOnlyCollection`1<TransportOperation> Operations { get; }
    public abstract virtual IReadOnlyCollection`1<TransportOperation> get_Operations();
}
public interface NServiceBus.Pipeline.IBehavior {
}
public interface NServiceBus.Pipeline.IBehavior`2 {
    [NullableContextAttribute("1")]
public abstract virtual Task Invoke(TInContext context, Func`2<TOutContext, Task> next);
}
public interface NServiceBus.Pipeline.IBehaviorContext {
    [NullableAttribute("1")]
public IServiceProvider Builder { get; }
    [NullableContextAttribute("1")]
public abstract virtual IServiceProvider get_Builder();
}
public interface NServiceBus.Pipeline.IDispatchContext {
    public IEnumerable`1<TransportOperation> Operations { get; }
    public abstract virtual IEnumerable`1<TransportOperation> get_Operations();
}
public interface NServiceBus.Pipeline.IIncomingContext {
}
public interface NServiceBus.Pipeline.IIncomingLogicalMessageContext {
    public LogicalMessage Message { get; }
    public Dictionary`2<string, string> Headers { get; }
    public bool MessageHandled { get; public set; }
    public abstract virtual LogicalMessage get_Message();
    public abstract virtual Dictionary`2<string, string> get_Headers();
    public abstract virtual bool get_MessageHandled();
    public abstract virtual void set_MessageHandled(bool value);
    public abstract virtual void UpdateMessageInstance(object newInstance);
}
public interface NServiceBus.Pipeline.IIncomingPhysicalMessageContext {
    public IncomingMessage Message { get; }
    public abstract virtual IncomingMessage get_Message();
    public abstract virtual void UpdateMessage(ReadOnlyMemory`1<byte> body);
}
public interface NServiceBus.Pipeline.IInvokeHandlerContext {
    public MessageHandler MessageHandler { get; }
    public Dictionary`2<string, string> Headers { get; }
    public object MessageBeingHandled { get; }
    public bool HandlerInvocationAborted { get; }
    public MessageMetadata MessageMetadata { get; }
    public abstract virtual MessageHandler get_MessageHandler();
    public abstract virtual Dictionary`2<string, string> get_Headers();
    public abstract virtual object get_MessageBeingHandled();
    public abstract virtual bool get_HandlerInvocationAborted();
    public abstract virtual MessageMetadata get_MessageMetadata();
}
public interface NServiceBus.Pipeline.IOutgoingContext {
    public string MessageId { get; }
    public Dictionary`2<string, string> Headers { get; }
    public abstract virtual string get_MessageId();
    public abstract virtual Dictionary`2<string, string> get_Headers();
}
public interface NServiceBus.Pipeline.IOutgoingLogicalMessageContext {
    public OutgoingLogicalMessage Message { get; }
    public IReadOnlyCollection`1<RoutingStrategy> RoutingStrategies { get; }
    public abstract virtual OutgoingLogicalMessage get_Message();
    public abstract virtual IReadOnlyCollection`1<RoutingStrategy> get_RoutingStrategies();
    public abstract virtual void UpdateMessage(object newInstance);
}
public interface NServiceBus.Pipeline.IOutgoingPhysicalMessageContext {
    public ReadOnlyMemory`1<byte> Body { get; }
    public IReadOnlyCollection`1<RoutingStrategy> RoutingStrategies { get; }
    public abstract virtual ReadOnlyMemory`1<byte> get_Body();
    public abstract virtual IReadOnlyCollection`1<RoutingStrategy> get_RoutingStrategies();
    public abstract virtual void UpdateMessage(ReadOnlyMemory`1<byte> body);
}
public interface NServiceBus.Pipeline.IOutgoingPublishContext {
    public OutgoingLogicalMessage Message { get; }
    public abstract virtual OutgoingLogicalMessage get_Message();
}
public interface NServiceBus.Pipeline.IOutgoingReplyContext {
    public OutgoingLogicalMessage Message { get; }
    public abstract virtual OutgoingLogicalMessage get_Message();
}
public interface NServiceBus.Pipeline.IOutgoingSendContext {
    public OutgoingLogicalMessage Message { get; }
    public abstract virtual OutgoingLogicalMessage get_Message();
}
public interface NServiceBus.Pipeline.IRecoverabilityActionContext {
    public IncomingMessage FailedMessage { get; }
    public Exception Exception { get; }
    public string ReceiveAddress { get; }
    public int ImmediateProcessingFailures { get; }
    public int DelayedDeliveriesPerformed { get; }
    public IReadOnlyDictionary`2<string, string> Metadata { get; }
    public abstract virtual IncomingMessage get_FailedMessage();
    public abstract virtual Exception get_Exception();
    public abstract virtual string get_ReceiveAddress();
    public abstract virtual int get_ImmediateProcessingFailures();
    public abstract virtual int get_DelayedDeliveriesPerformed();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_Metadata();
}
public interface NServiceBus.Pipeline.IRecoverabilityContext {
    public IncomingMessage FailedMessage { get; }
    public Exception Exception { get; }
    public string ReceiveAddress { get; }
    public int ImmediateProcessingFailures { get; }
    public int DelayedDeliveriesPerformed { get; }
    public RecoverabilityConfig RecoverabilityConfiguration { get; }
    public RecoverabilityAction RecoverabilityAction { get; public set; }
    public Dictionary`2<string, string> Metadata { get; }
    public abstract virtual IncomingMessage get_FailedMessage();
    public abstract virtual Exception get_Exception();
    public abstract virtual string get_ReceiveAddress();
    public abstract virtual int get_ImmediateProcessingFailures();
    public abstract virtual int get_DelayedDeliveriesPerformed();
    public abstract virtual RecoverabilityConfig get_RecoverabilityConfiguration();
    public abstract virtual RecoverabilityAction get_RecoverabilityAction();
    public abstract virtual void set_RecoverabilityAction(RecoverabilityAction value);
    public abstract virtual Dictionary`2<string, string> get_Metadata();
    public abstract virtual IRecoverabilityActionContext PreventChanges();
}
public interface NServiceBus.Pipeline.IRoutingContext {
    public OutgoingMessage Message { get; }
    public IReadOnlyCollection`1<RoutingStrategy> RoutingStrategies { get; public set; }
    public abstract virtual OutgoingMessage get_Message();
    public abstract virtual IReadOnlyCollection`1<RoutingStrategy> get_RoutingStrategies();
    public abstract virtual void set_RoutingStrategies(IReadOnlyCollection`1<RoutingStrategy> value);
}
public interface NServiceBus.Pipeline.ISubscribeContext {
    public Type[] EventTypes { get; }
    public abstract virtual Type[] get_EventTypes();
}
public interface NServiceBus.Pipeline.ITransportReceiveContext {
    public IncomingMessage Message { get; }
    public abstract virtual IncomingMessage get_Message();
}
public interface NServiceBus.Pipeline.IUnsubscribeContext {
    public Type EventType { get; }
    public abstract virtual Type get_EventType();
}
public class NServiceBus.Pipeline.LogicalMessage : object {
    [CompilerGeneratedAttribute]
private MessageMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    public Type MessageType { get; }
    public MessageMetadata Metadata { get; internal set; }
    public object Instance { get; internal set; }
    public LogicalMessage(MessageMetadata metadata, object message);
    public Type get_MessageType();
    [CompilerGeneratedAttribute]
public MessageMetadata get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(MessageMetadata value);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
internal void set_Instance(object value);
}
public class NServiceBus.Pipeline.LogicalMessageFactory : object {
    private IMessageMapper messageMapper;
    private MessageMetadataRegistry messageMetadataRegistry;
    public LogicalMessageFactory(MessageMetadataRegistry messageMetadataRegistry, IMessageMapper messageMapper);
    public LogicalMessage Create(object message);
    public LogicalMessage Create(Type messageType, object message);
}
public class NServiceBus.Pipeline.MessageHandler : object {
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HandlerType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTimeoutHandler>k__BackingField;
    private Func`4<object, object, IMessageHandlerContext, Task> invocation;
    public object Instance { get; public set; }
    public Type HandlerType { get; }
    internal bool IsTimeoutHandler { get; internal set; }
    public MessageHandler(Func`4<object, object, IMessageHandlerContext, Task> invocation, Type handlerType);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [CompilerGeneratedAttribute]
public Type get_HandlerType();
    [CompilerGeneratedAttribute]
internal bool get_IsTimeoutHandler();
    [CompilerGeneratedAttribute]
internal void set_IsTimeoutHandler(bool value);
    public Task Invoke(object message, IMessageHandlerContext handlerContext);
}
public class NServiceBus.Pipeline.OutgoingLogicalMessage : object {
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    public Type MessageType { get; }
    public object Instance { get; }
    public OutgoingLogicalMessage(Type messageType, object message);
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public object get_Instance();
}
public class NServiceBus.Pipeline.PipelineSettings : ExposeSettings {
    private bool locked;
    internal PipelineModifications modifications;
    internal PipelineSettings(SettingsHolder settings);
    public void Replace(string stepId, Type newBehavior, string description);
    public void Replace(string stepId, T newBehavior, string description);
    public void Replace(string stepId, Func`2<IServiceProvider, T> factoryMethod, string description);
    public void RegisterOrReplace(string stepId, Type behavior, string description);
    public void RegisterOrReplace(string stepId, T behavior, string description);
    public void RegisterOrReplace(string stepId, Func`2<IServiceProvider, T> factoryMethod, string description);
    public void Register(Type behavior, string description);
    public void Register(string stepId, Type behavior, string description);
    public void Register(Func`2<IServiceProvider, T> factoryMethod, string description);
    public void Register(string stepId, Func`2<IServiceProvider, T> factoryMethod, string description);
    public void Register(T behavior, string description);
    public void Register(string stepId, T behavior, string description);
    public void Register();
    public void Register(RegisterStep registration);
    internal void PreventChanges();
    private void EnsureWriteEnabled(string key, string operation);
}
public abstract class NServiceBus.Pipeline.PipelineTerminator`1 : StageConnector`2<T, ITerminatingContext<T>> {
    protected abstract virtual Task Terminate(T context);
    public sealed virtual Task Invoke(T context, Func`2<ITerminatingContext<T>, Task> next);
}
[DebuggerDisplayAttribute("{StepId}({BehaviorType.FullName}) - {Description}")]
public abstract class NServiceBus.Pipeline.RegisterStep : object {
    [CompilerGeneratedAttribute]
private string <StepId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Dependency> <Befores>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Dependency> <Afters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BehaviorType>k__BackingField;
    private Func`2<IServiceProvider, IBehavior> factoryMethod;
    public string StepId { get; }
    public string Description { get; private set; }
    internal List`1<Dependency> Befores { get; private set; }
    internal List`1<Dependency> Afters { get; private set; }
    public Type BehaviorType { get; private set; }
    protected RegisterStep(string stepId, Type behavior, string description, Func`2<IServiceProvider, IBehavior> factoryMethod);
    [CompilerGeneratedAttribute]
public string get_StepId();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
internal List`1<Dependency> get_Befores();
    [CompilerGeneratedAttribute]
private void set_Befores(List`1<Dependency> value);
    [CompilerGeneratedAttribute]
internal List`1<Dependency> get_Afters();
    [CompilerGeneratedAttribute]
private void set_Afters(List`1<Dependency> value);
    [CompilerGeneratedAttribute]
public Type get_BehaviorType();
    [CompilerGeneratedAttribute]
private void set_BehaviorType(Type value);
    internal void ApplyContainerRegistration(IServiceCollection serviceCollection);
    public void InsertBeforeIfExists(string id);
    public void InsertBefore(string id);
    public void InsertAfterIfExists(string id);
    public void InsertAfter(string id);
    internal void Replace(ReplaceStep replacement);
    internal IBehavior CreateBehavior(IServiceProvider defaultBuilder);
    internal static RegisterStep Create(string pipelineStep, Type behavior, string description, Func`2<IServiceProvider, IBehavior> factoryMethod);
}
public abstract class NServiceBus.Pipeline.StageConnector`2 : object {
    public abstract virtual Task Invoke(TFromContext context, Func`2<TToContext, Task> stage);
}
public abstract class NServiceBus.Pipeline.StageForkConnector`3 : object {
    public sealed virtual Task Invoke(TFromContext context, Func`2<TToContext, Task> next);
    public abstract virtual Task Invoke(TFromContext context, Func`2<TToContext, Task> stage, Func`2<TForkContext, Task> fork);
}
[ExtensionAttribute]
public static class NServiceBus.Pipeline.TransportMessageContextExtensions : object {
    [ExtensionAttribute]
public static bool TryGetIncomingPhysicalMessage(IOutgoingReplyContext context, IncomingMessage& message);
    [ExtensionAttribute]
public static bool TryGetIncomingPhysicalMessage(IOutgoingLogicalMessageContext context, IncomingMessage& message);
    [ExtensionAttribute]
public static bool TryGetIncomingPhysicalMessage(IOutgoingPhysicalMessageContext context, IncomingMessage& message);
}
internal class NServiceBus.Pipeline`1 : object {
    private IBehavior[] behaviors;
    private Func`2<TContext, Task> pipeline;
    private static ILog Logger;
    public Pipeline`1(IServiceProvider builder, PipelineModifications pipelineModifications);
    private static Pipeline`1();
    public sealed virtual Task Invoke(TContext context);
}
internal class NServiceBus.PipelineCache : object {
    private PipelineModifications pipelineModifications;
    private Dictionary`2<Type, Lazy`1<IPipeline>> pipelines;
    public PipelineCache(IServiceProvider rootBuilder, PipelineModifications pipelineModifications);
    public sealed virtual IPipeline`1<TContext> Pipeline();
    private void FromMainPipeline(IServiceProvider builder);
}
internal class NServiceBus.PipelineComponent : object {
    private PipelineModifications modifications;
    private PipelineComponent(PipelineModifications modifications);
    public static PipelineComponent Initialize(PipelineSettings settings, Configuration hostingConfiguration, Configuration receiveConfiguration);
    public Pipeline`1<T> CreatePipeline(IServiceProvider builder);
    public PipelineCache BuildPipelineCache(IServiceProvider rootBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NServiceBus.PipelineContextExtensions : object {
    [ExtensionAttribute]
public static Task Send(IPipelineContext context, object message);
    [ExtensionAttribute]
public static Task Send(IPipelineContext context, Action`1<T> messageConstructor);
    [ExtensionAttribute]
public static Task Send(IPipelineContext context, string destination, object message);
    [ExtensionAttribute]
public static Task Send(IPipelineContext context, string destination, Action`1<T> messageConstructor);
    [ExtensionAttribute]
public static Task SendLocal(IPipelineContext context, object message);
    [ExtensionAttribute]
public static Task SendLocal(IPipelineContext context, Action`1<T> messageConstructor);
    [ExtensionAttribute]
public static Task Publish(IPipelineContext context, object message);
    [ExtensionAttribute]
public static Task Publish(IPipelineContext context);
    [ExtensionAttribute]
public static Task Publish(IPipelineContext context, Action`1<T> messageConstructor);
}
[ExtensionAttribute]
internal static class NServiceBus.PipelineExecutionExtensions : object {
    private static MethodInfo GetBehaviorMethodInfo;
    private static PipelineExecutionExtensions();
    [ExtensionAttribute]
public static Func`2<TRootContext, Task> CreatePipelineExecutionFuncFor(IBehavior[] behaviors, List`1<Expression> expressions);
    [ExtensionAttribute]
public static Delegate CreatePipelineExecutionExpression(IBehavior[] behaviors, List`1<Expression> expressions);
    private static Delegate CreateBehaviorCallDelegate(MethodInfo methodInfo, ParameterExpression outerContextParam, Type behaviorType, Delegate previous, int i, List`1<Expression> expressions);
    public static TBehavior GetBehavior(TContext context, int index);
    private static Delegate CreateDoneDelegate(Type inContextType, int i);
}
[ExtensionAttribute]
internal static class NServiceBus.PipelineInvocationExtensions : object {
    [ExtensionAttribute]
public static Task InvokePipeline(TContext context);
}
internal class NServiceBus.PipelineModelBuilder : object {
    private List`1<RegisterStep> additions;
    private List`1<ReplaceStep> replacements;
    private List`1<RegisterOrReplaceStep> addOrReplaceSteps;
    private Type rootContextType;
    private static ILog Logger;
    public PipelineModelBuilder(Type rootContextType, List`1<RegisterStep> additions, List`1<ReplaceStep> replacements, List`1<RegisterOrReplaceStep> addOrReplaceSteps);
    private static PipelineModelBuilder();
    public List`1<RegisterStep> Build();
    private static bool IsStageConnector(RegisterStep stageStep);
    private static List`1<RegisterStep> Sort(List`1<RegisterStep> registrations);
    private static void ProcessBefores(Node node, Dictionary`2<string, Node> nameToNode);
    private static void ProcessAfters(Node node, Dictionary`2<string, Node> nameToNode);
    private static string GetCurrentIds(Dictionary`2<string, Node> nameToNodeDict);
    [CompilerGeneratedAttribute]
private bool <Build>b__1_0(RegisterOrReplaceStep addOrReplaceStep);
    [CompilerGeneratedAttribute]
private bool <Build>b__1_2(RegisterOrReplaceStep addOrReplaceStep);
    [CompilerGeneratedAttribute]
private bool <Build>b__1_7(IGrouping`2<Type, RegisterStep> stage);
}
internal class NServiceBus.PipelineModifications : object {
    public List`1<RegisterStep> Additions;
    public List`1<ReplaceStep> Replacements;
    public List`1<RegisterOrReplaceStep> AdditionsOrReplacements;
}
internal class NServiceBus.PipelineRootContext : BehaviorContext {
    public PipelineRootContext(IServiceProvider builder, MessageOperations messageOperations, IPipelineCache pipelineCache, CancellationToken cancellationToken, ContextBag parentContext);
}
internal class NServiceBus.PopulateAutoCorrelationHeadersForRepliesBehavior : object {
    public sealed virtual Task Invoke(IOutgoingReplyContext context, Func`2<IOutgoingReplyContext, Task> next);
    private static void FlowDetailsForRequestingSagaToOutgoingMessage(IOutgoingReplyContext context);
}
[AttributeUsageAttribute("32767")]
internal class NServiceBus.PreObsoleteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ContextUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplacementTypeOrMember>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Note>k__BackingField;
    public string ContextUrl { get; }
    public string ReplacementTypeOrMember { get; public set; }
    public string Message { get; public set; }
    public string Note { get; public set; }
    public PreObsoleteAttribute(string contextUrl);
    [CompilerGeneratedAttribute]
public string get_ContextUrl();
    [CompilerGeneratedAttribute]
public string get_ReplacementTypeOrMember();
    [CompilerGeneratedAttribute]
public void set_ReplacementTypeOrMember(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_Note();
    [CompilerGeneratedAttribute]
public void set_Note(string value);
}
internal class NServiceBus.ProcessingStatisticsBehavior : object {
    [AsyncStateMachineAttribute("NServiceBus.ProcessingStatisticsBehavior/<Invoke>d__0")]
public sealed virtual Task Invoke(IIncomingPhysicalMessageContext context, Func`2<IIncomingPhysicalMessageContext, Task> next);
}
internal class NServiceBus.PropertyFinderSagaToMessageMap : CorrelationSagaToMessageMap {
    public Func`2<object, object> MessageProp;
    public virtual SagaFinderDefinition CreateSagaFinderDefinition(Type sagaEntityType);
}
internal class NServiceBus.PropertySagaFinder`1 : SagaFinder {
    private ISagaPersister sagaPersister;
    public PropertySagaFinder`1(ISagaPersister sagaPersister);
    [AsyncStateMachineAttribute("NServiceBus.PropertySagaFinder`1/<Find>d__1")]
public virtual Task`1<IContainSagaData> Find(IServiceProvider builder, SagaFinderDefinition finderDefinition, ISynchronizedStorageSession storageSession, ContextBag context, object message, IReadOnlyDictionary`2<string, string> messageHeaders, CancellationToken cancellationToken);
}
public class NServiceBus.PublishOptions : ExtendableOptions {
}
public class NServiceBus.RateLimitSettings : object {
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToWaitBetweenThrottledAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task> <OnRateLimitStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task> <OnRateLimitEnded>k__BackingField;
    public TimeSpan TimeToWaitBetweenThrottledAttempts { get; }
    public Func`2<CancellationToken, Task> OnRateLimitStarted { get; }
    public Func`2<CancellationToken, Task> OnRateLimitEnded { get; }
    public RateLimitSettings(Nullable`1<TimeSpan> timeToWaitBetweenThrottledAttempts, Func`2<CancellationToken, Task> onRateLimitStarted, Func`2<CancellationToken, Task> onRateLimitEnded);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToWaitBetweenThrottledAttempts();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task> get_OnRateLimitStarted();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task> get_OnRateLimitEnded();
}
internal class NServiceBus.ReadOnlyStream : Stream {
    private ReadOnlyMemory`1<byte> memory;
    private int position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyStream(ReadOnlyMemory`1<byte> memory);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class NServiceBus.ReceiveAddresses : object {
    [CompilerGeneratedAttribute]
private string <MainReceiveAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstanceReceiveAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SatelliteReceiveAddresses>k__BackingField;
    public string MainReceiveAddress { get; }
    public string InstanceReceiveAddress { get; }
    public String[] SatelliteReceiveAddresses { get; }
    public ReceiveAddresses(string mainReceiveAddress, string instanceReceiveAddress, String[] satelliteReceiveAddresses);
    [CompilerGeneratedAttribute]
public string get_MainReceiveAddress();
    [CompilerGeneratedAttribute]
public string get_InstanceReceiveAddress();
    [CompilerGeneratedAttribute]
public String[] get_SatelliteReceiveAddresses();
}
internal class NServiceBus.ReceiveComponent : object {
    private Configuration configuration;
    private IActivityFactory activityFactory;
    private List`1<IMessageReceiver> receivers;
    public static string MainReceiverId;
    public static string InstanceSpecificReceiverId;
    private static Type IHandleMessagesType;
    private static ILog Logger;
    private ReceiveComponent(Configuration configuration, IActivityFactory activityFactory);
    private static ReceiveComponent();
    public static Configuration PrepareConfiguration(Settings settings, TransportSeam transportSeam);
    public static ReceiveComponent Configure(Configuration configuration, string errorQueue, Configuration hostingConfiguration, PipelineSettings pipelineSettings);
    [AsyncStateMachineAttribute("NServiceBus.ReceiveComponent/<Initialize>d__4")]
public Task Initialize(IServiceProvider builder, RecoverabilityComponent recoverabilityComponent, MessageOperations messageOperations, PipelineComponent pipelineComponent, IPipelineCache pipelineCache, TransportInfrastructure transportInfrastructure, ConsecutiveFailuresConfiguration consecutiveFailuresConfiguration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.ReceiveComponent/<Start>d__5")]
public Task Start(CancellationToken cancellationToken);
    public Task Stop(CancellationToken cancellationToken);
    private static void RegisterMessageHandlers(MessageHandlerRegistry handlerRegistry, List`1<Type> orderedTypes, IServiceCollection serviceCollection, ICollection`1<Type> availableTypes);
    public static bool IsMessageHandler(Type type);
    private static IMessageReceiver CreateReceiver(ConsecutiveFailuresConfiguration consecutiveFailuresConfiguration, IMessageReceiver receiver);
}
[ExtensionAttribute]
public static class NServiceBus.ReceiveFeatureConfigurationContextExtensions : object {
    [ExtensionAttribute]
public static QueueAddress LocalQueueAddress(FeatureConfigurationContext config);
    [ExtensionAttribute]
public static QueueAddress InstanceSpecificQueueAddress(FeatureConfigurationContext config);
}
public class NServiceBus.ReceivePipelineCompleted : object {
    [CompilerGeneratedAttribute]
private IncomingMessage <ProcessedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CompletedAt>k__BackingField;
    public IncomingMessage ProcessedMessage { get; }
    public DateTimeOffset StartedAt { get; }
    public DateTimeOffset CompletedAt { get; }
    public ReceivePipelineCompleted(IncomingMessage processedMessage, DateTimeOffset startedAt, DateTimeOffset completedAt);
    [CompilerGeneratedAttribute]
public IncomingMessage get_ProcessedMessage();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartedAt();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CompletedAt();
}
[ExtensionAttribute]
public static class NServiceBus.ReceivePipelineConfigExtensions : object {
    [ExtensionAttribute]
public static void OnReceivePipelineCompleted(PipelineSettings pipelineSettings, Func`3<ReceivePipelineCompleted, CancellationToken, Task> subscription);
}
[ExtensionAttribute]
public static class NServiceBus.ReceiveSettingsExtensions : object {
    internal static string CustomQueueNameBaseKey;
    [ExtensionAttribute]
public static void MakeInstanceUniquelyAddressable(EndpointConfiguration config, string discriminator);
    [ExtensionAttribute]
public static void OverrideLocalAddress(EndpointConfiguration config, string baseInputQueueName);
}
internal class NServiceBus.ReceiveStatisticsFeature : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
[ExtensionAttribute]
public static class NServiceBus.Recoverability.RecoverabilityContextExtensions : object {
    [ExtensionAttribute]
public static IRoutingContext CreateRoutingContext(IRecoverabilityActionContext context, OutgoingMessage outgoingMessage, RoutingStrategy routingStrategy);
}
public abstract class NServiceBus.RecoverabilityAction : object {
    private static ImmediateRetry CachedImmediateRetry;
    public ErrorHandleResult ErrorHandleResult { get; }
    private static RecoverabilityAction();
    public static ImmediateRetry ImmediateRetry();
    public abstract virtual IReadOnlyCollection`1<IRoutingContext> GetRoutingContexts(IRecoverabilityActionContext context);
    public static DelayedRetry DelayedRetry(TimeSpan timeSpan);
    public static MoveToError MoveToError(string errorQueue);
    public static Discard Discard(string reason);
    public abstract virtual ErrorHandleResult get_ErrorHandleResult();
}
internal class NServiceBus.RecoverabilityComponent : object {
    private Notification`1<MessageToBeRetried> messageRetryNotification;
    private Notification`1<MessageFaulted> messageFaultedNotification;
    private RecoverabilityConfig recoverabilityConfig;
    private FaultMetadataExtractor faultMetadataExtractor;
    private HostInformation hostInformation;
    private SettingsHolder settings;
    private bool transactionsOn;
    private bool delayedRetriesAvailable;
    private bool immediateRetriesAvailable;
    public static string NumberOfDelayedRetries;
    public static string DelayedRetriesTimeIncrease;
    public static string NumberOfImmediateRetries;
    public static string FaultHeaderCustomization;
    public static string PolicyOverride;
    public static string UnrecoverableExceptions;
    private static int DefaultNumberOfRetries;
    private static TimeSpan DefaultTimeIncrease;
    private static ILog Logger;
    private TransportSeam transportSeam;
    public RecoverabilityComponent(SettingsHolder settings);
    private static RecoverabilityComponent();
    public void Initialize(Configuration receiveConfiguration, Configuration hostingConfiguration, TransportSeam transportSeam, PipelineSettings pipelineSettings);
    public IRecoverabilityPipelineExecutor CreateRecoverabilityPipelineExecutor(IServiceProvider serviceProvider, IPipelineCache pipelineCache, PipelineComponent pipeline, MessageOperations messageOperations);
    public IRecoverabilityPipelineExecutor CreateSatelliteRecoverabilityExecutor(IServiceProvider serviceProvider, Func`3<RecoverabilityConfig, ErrorContext, RecoverabilityAction> recoverabilityPolicy);
    public static RecoverabilityAction AdjustForTransportCapabilities(string errorQueue, bool immediateRetriesAvailable, bool delayedRetriesAvailable, RecoverabilityAction selectedAction);
    private FaultMetadataExtractor CreateFaultMetadataExtractor();
    private ImmediateConfig GetImmediateRetryConfig();
    private DelayedConfig GetDelayedRetryConfig();
    [CompilerGeneratedAttribute]
private RecoverabilityRoutingConnector <Initialize>b__1_0(IServiceProvider sp);
}
public class NServiceBus.RecoverabilityConfig : object {
    [CompilerGeneratedAttribute]
private ImmediateConfig <Immediate>k__BackingField;
    [CompilerGeneratedAttribute]
private DelayedConfig <Delayed>k__BackingField;
    [CompilerGeneratedAttribute]
private FailedConfig <Failed>k__BackingField;
    public ImmediateConfig Immediate { get; }
    public DelayedConfig Delayed { get; }
    public FailedConfig Failed { get; }
    public RecoverabilityConfig(ImmediateConfig immediateConfig, DelayedConfig delayedConfig, FailedConfig failedConfig);
    [CompilerGeneratedAttribute]
public ImmediateConfig get_Immediate();
    [CompilerGeneratedAttribute]
public DelayedConfig get_Delayed();
    [CompilerGeneratedAttribute]
public FailedConfig get_Failed();
}
internal class NServiceBus.RecoverabilityContext : PipelineRootContext {
    [CompilerGeneratedAttribute]
private IncomingMessage <FailedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiveAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ImmediateProcessingFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DelayedDeliveriesPerformed>k__BackingField;
    [CompilerGeneratedAttribute]
private RecoverabilityConfig <RecoverabilityConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Metadata>k__BackingField;
    private RecoverabilityAction recoverabilityAction;
    private bool locked;
    private List`1<object> notifications;
    public IncomingMessage FailedMessage { get; }
    public Exception Exception { get; }
    public string ReceiveAddress { get; }
    public int ImmediateProcessingFailures { get; }
    public int DelayedDeliveriesPerformed { get; }
    private IReadOnlyDictionary`2<string, string> NServiceBus.Pipeline.IRecoverabilityActionContext.Metadata { get; }
    public RecoverabilityConfig RecoverabilityConfiguration { get; }
    public Dictionary`2<string, string> Metadata { get; }
    public RecoverabilityAction RecoverabilityAction { get; public set; }
    public RecoverabilityContext(IServiceProvider serviceProvider, MessageOperations messageOperations, IPipelineCache pipelineCache, ErrorContext errorContext, RecoverabilityConfig recoverabilityConfig, Dictionary`2<string, string> metadata, RecoverabilityAction recoverabilityAction, ContextBag parent, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual IncomingMessage get_FailedMessage();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReceiveAddress();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ImmediateProcessingFailures();
    [CompilerGeneratedAttribute]
public sealed virtual int get_DelayedDeliveriesPerformed();
    private sealed virtual override IReadOnlyDictionary`2<string, string> NServiceBus.Pipeline.IRecoverabilityActionContext.get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual RecoverabilityConfig get_RecoverabilityConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Metadata();
    public sealed virtual RecoverabilityAction get_RecoverabilityAction();
    public sealed virtual void set_RecoverabilityAction(RecoverabilityAction value);
    public sealed virtual IRecoverabilityActionContext PreventChanges();
    public sealed virtual void Add(object notification);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class NServiceBus.RecoverabilityEndpointConfigurationExtensions : object {
    [ExtensionAttribute]
public static RecoverabilitySettings Recoverability(EndpointConfiguration configuration);
}
internal class NServiceBus.RecoverabilityPipelineExecutor`1 : object {
    private IServiceProvider serviceProvider;
    private IPipelineCache pipelineCache;
    private MessageOperations messageOperations;
    private RecoverabilityConfig recoverabilityConfig;
    private Func`3<ErrorContext, TState, RecoverabilityAction> recoverabilityPolicy;
    private IPipeline`1<IRecoverabilityContext> recoverabilityPipeline;
    private FaultMetadataExtractor faultMetadataExtractor;
    private TState state;
    public RecoverabilityPipelineExecutor`1(IServiceProvider serviceProvider, IPipelineCache pipelineCache, MessageOperations messageOperations, RecoverabilityConfig recoverabilityConfig, Func`3<ErrorContext, TState, RecoverabilityAction> recoverabilityPolicy, IPipeline`1<IRecoverabilityContext> recoverabilityPipeline, FaultMetadataExtractor faultMetadataExtractor, TState state);
    [AsyncStateMachineAttribute("NServiceBus.RecoverabilityPipelineExecutor`1/<Invoke>d__1")]
public sealed virtual Task`1<ErrorHandleResult> Invoke(ErrorContext errorContext, CancellationToken cancellationToken);
}
internal class NServiceBus.RecoverabilityRoutingConnector : StageConnector`2<IRecoverabilityContext, IRoutingContext> {
    private IncomingPipelineMetrics incomingPipelineMetrics;
    private CompositeNotification notifications;
    public RecoverabilityRoutingConnector(IncomingPipelineMetrics incomingPipelineMetrics, INotificationSubscriptions`1<MessageToBeRetried> messageRetryNotification, INotificationSubscriptions`1<MessageFaulted> messageFaultedNotification);
    [AsyncStateMachineAttribute("NServiceBus.RecoverabilityRoutingConnector/<Invoke>d__2")]
public virtual Task Invoke(IRecoverabilityContext context, Func`2<IRoutingContext, Task> stage);
}
public class NServiceBus.RecoverabilitySettings : ExposeSettings {
    internal RecoverabilitySettings(SettingsHolder settings);
    public RecoverabilitySettings Failed(Action`1<RetryFailedSettings> customizations);
    public RecoverabilitySettings Immediate(Action`1<ImmediateRetriesSettings> customizations);
    public RecoverabilitySettings Delayed(Action`1<DelayedRetriesSettings> customizations);
    public RecoverabilitySettings CustomPolicy(Func`3<RecoverabilityConfig, ErrorContext, RecoverabilityAction> custom);
    public RecoverabilitySettings AddUnrecoverableException();
    public RecoverabilitySettings AddUnrecoverableException(Type exceptionType);
    public RecoverabilitySettings OnConsecutiveFailures(int numberOfConsecutiveFailures, RateLimitSettings settings);
}
[ExtensionAttribute]
public static class NServiceBus.RecoverabilitySettingsExtensions : object {
    [ExtensionAttribute]
public static void AddUnrecoverableException(SettingsHolder settings, Type exceptionType);
    [ExtensionAttribute]
internal static HashSet`1<Type> UnrecoverableExceptions(IReadOnlySettings settings);
}
internal static class NServiceBus.Reflect`1 : object {
    public static PropertyInfo GetProperty(Expression`1<Func`2<TTarget, object>> property);
    internal static List`1<TTarget> GetEnumValues();
    public static PropertyInfo GetProperty(Expression`1<Func`2<TTarget, object>> property, bool checkForSingleDot);
    public static MemberInfo GetMemberInfo(Expression member, bool checkForSingleDot);
}
internal class NServiceBus.RegisterOrReplaceStep : object {
    [CompilerGeneratedAttribute]
private RegisterStep <RegisterStep>k__BackingField;
    [CompilerGeneratedAttribute]
private ReplaceStep <ReplaceStep>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StepId>k__BackingField;
    public RegisterStep RegisterStep { get; }
    public ReplaceStep ReplaceStep { get; }
    public string StepId { get; }
    private RegisterOrReplaceStep(string stepId, RegisterStep registerStep, ReplaceStep replaceStep);
    [CompilerGeneratedAttribute]
public RegisterStep get_RegisterStep();
    [CompilerGeneratedAttribute]
public ReplaceStep get_ReplaceStep();
    [CompilerGeneratedAttribute]
public string get_StepId();
    public static RegisterOrReplaceStep Create(string stepId, Type behaviorType, string description, Func`2<IServiceProvider, IBehavior> factoryMethod);
}
[ExtensionAttribute]
internal static class NServiceBus.RegisterStepExtensions : object {
    private static Type BehaviorInterfaceType;
    private static RegisterStepExtensions();
    [ExtensionAttribute]
public static bool IsStageConnector(RegisterStep step);
    [ExtensionAttribute]
public static Type GetContextType(Type behaviorType);
    [ExtensionAttribute]
public static bool IsBehavior(Type behaviorType);
    [ExtensionAttribute]
public static Type GetBehaviorInterface(Type behaviorType);
    [ExtensionAttribute]
public static Type GetOutputContext(RegisterStep step);
    [ExtensionAttribute]
public static Type GetOutputContext(Type behaviorType);
    [ExtensionAttribute]
public static Type GetInputContext(RegisterStep step);
    [ExtensionAttribute]
public static Type GetInputContext(Type behaviorType);
}
internal class NServiceBus.RemoveStep : object {
    [CompilerGeneratedAttribute]
private string <RemoveId>k__BackingField;
    public string RemoveId { get; }
    public RemoveStep(string removeId);
    [CompilerGeneratedAttribute]
public string get_RemoveId();
}
internal class NServiceBus.ReplaceStep : object {
    [CompilerGeneratedAttribute]
private string <ReplaceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BehaviorType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IServiceProvider, IBehavior> <FactoryMethod>k__BackingField;
    public string ReplaceId { get; }
    public string Description { get; }
    public Type BehaviorType { get; }
    public Func`2<IServiceProvider, IBehavior> FactoryMethod { get; }
    public ReplaceStep(string idToReplace, Type behavior, string description, Func`2<IServiceProvider, IBehavior> factoryMethod);
    [CompilerGeneratedAttribute]
public string get_ReplaceId();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public Type get_BehaviorType();
    [CompilerGeneratedAttribute]
public Func`2<IServiceProvider, IBehavior> get_FactoryMethod();
}
internal class NServiceBus.ReplyConnector : StageConnector`2<IOutgoingReplyContext, IOutgoingLogicalMessageContext> {
    [AsyncStateMachineAttribute("NServiceBus.ReplyConnector/<Invoke>d__0")]
public virtual Task Invoke(IOutgoingReplyContext context, Func`2<IOutgoingLogicalMessageContext, Task> stage);
    private static string GetReplyToAddressFromIncomingMessage(IOutgoingReplyContext context);
}
public class NServiceBus.ReplyOptions : ExtendableOptions {
}
internal class NServiceBus.RetryAcknowledgementBehavior : object {
    internal static string RetryUniqueMessageIdHeaderKey;
    internal static string RetryConfirmationQueueHeaderKey;
    [AsyncStateMachineAttribute("NServiceBus.RetryAcknowledgementBehavior/<Invoke>d__2")]
public sealed virtual Task Invoke(ITransportReceiveContext context, Func`2<ITransportReceiveContext, Task> next);
    private static bool IsRetriedMessage(ITransportReceiveContext context, String& retryUniqueMessageId, String& retryAcknowledgementQueue);
}
public class NServiceBus.RetryFailedSettings : ExposeSettings {
    internal RetryFailedSettings(SettingsHolder settings);
    public RetryFailedSettings HeaderCustomization(Action`1<Dictionary`2<string, string>> customization);
    public RetryFailedSettings OnMessageSentToErrorQueue(Func`3<FailedMessage, CancellationToken, Task> notificationCallback);
}
internal class NServiceBus.RollingLogger : object {
    protected string currentfilePath;
    private long currentFileSize;
    internal Func`1<DateTimeOffset> GetDate;
    private DateTimeOffset lastWriteDate;
    private long maxFileSize;
    private int numberOfArchiveFilesToKeep;
    private string targetDirectory;
    private static long fileLimitInBytes;
    public RollingLogger(string targetDirectory, int numberOfArchiveFilesToKeep, long maxFileSize);
    public void WriteLine(string message);
    private void InnerWrite(string message);
    protected virtual void AppendLine(string message);
    private void SyncFileSystem();
    private bool HasCurrentDateChanged();
    private bool IsCurrentFileTooLarge();
    private void PurgeOldFiles(List`1<LogFile> logFiles);
    private IEnumerable`1<string> GetFilesToDelete(IEnumerable`1<LogFile> logFiles);
    internal static LogFile GetTodaysNewest(IEnumerable`1<LogFile> logFiles, DateTimeOffset today);
    [IteratorStateMachineAttribute("NServiceBus.RollingLogger/<GetNsbLogFiles>d__10")]
private static IEnumerable`1<LogFile> GetNsbLogFiles(string targetDirectory);
    private static bool TryDeriveLogInformationFromPath(string file, LogFile& logFile);
    private static bool TryParseDate(string datePart, DateTimeOffset& dateTime);
    private void CalculateNewFileName(List`1<LogFile> logFiles, DateTimeOffset today);
}
internal enum NServiceBus.RouteSourcePriority : Enum {
    public int value__;
    public static RouteSourcePriority Assembly;
    public static RouteSourcePriority Namespace;
    public static RouteSourcePriority Type;
}
public abstract class NServiceBus.Routing.AddressTag : object {
}
public class NServiceBus.Routing.DistributionContext : object {
    [CompilerGeneratedAttribute]
private String[] <ReceiverAddresses>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private OutgoingLogicalMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private ContextBag <Extensions>k__BackingField;
    private ITransportAddressResolver addressResolver;
    public String[] ReceiverAddresses { get; }
    public string MessageId { get; }
    public Dictionary`2<string, string> Headers { get; }
    public OutgoingLogicalMessage Message { get; }
    public ContextBag Extensions { get; }
    public DistributionContext(String[] receiverAddresses, OutgoingLogicalMessage message, string messageId, Dictionary`2<string, string> headers, ITransportAddressResolver addressTranslation, ContextBag extensions);
    [CompilerGeneratedAttribute]
public String[] get_ReceiverAddresses();
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public OutgoingLogicalMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual ContextBag get_Extensions();
    public string ToTransportAddress(EndpointInstance endpointInstance);
}
public abstract class NServiceBus.Routing.DistributionStrategy : object {
    [CompilerGeneratedAttribute]
private string <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private DistributionStrategyScope <Scope>k__BackingField;
    public string Endpoint { get; }
    public DistributionStrategyScope Scope { get; }
    protected DistributionStrategy(string endpoint, DistributionStrategyScope scope);
    public abstract virtual string SelectDestination(DistributionContext context);
    [CompilerGeneratedAttribute]
public string get_Endpoint();
    [CompilerGeneratedAttribute]
public DistributionStrategyScope get_Scope();
}
public class NServiceBus.Routing.EndpointInstance : object {
    [CompilerGeneratedAttribute]
private string <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Discriminator>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Properties>k__BackingField;
    private static PropertyComparer propertyComparer;
    public string Endpoint { get; }
    public string Discriminator { get; }
    public IReadOnlyDictionary`2<string, string> Properties { get; }
    public EndpointInstance(string endpoint, string discriminator, IReadOnlyDictionary`2<string, string> properties);
    private static EndpointInstance();
    [CompilerGeneratedAttribute]
public string get_Endpoint();
    [CompilerGeneratedAttribute]
public string get_Discriminator();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Properties();
    public EndpointInstance SetProperty(string key, string value);
    public virtual string ToString();
    private bool Equals(EndpointInstance other);
    private static bool PropertiesEqual(IReadOnlyDictionary`2<string, string> left, IReadOnlyDictionary`2<string, string> right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EndpointInstance left, EndpointInstance right);
    public static bool op_Inequality(EndpointInstance left, EndpointInstance right);
}
public class NServiceBus.Routing.EndpointInstances : object {
    private Dictionary`2<string, HashSet`1<EndpointInstance>> allInstances;
    private Dictionary`2<string, IList`1<EndpointInstance>> registrations;
    private object updateLock;
    public IEnumerable`1<EndpointInstance> FindInstances(string endpoint);
    [IteratorStateMachineAttribute("NServiceBus.Routing.EndpointInstances/<DefaultInstance>d__1")]
private static IEnumerable`1<EndpointInstance> DefaultInstance(string endpoint);
    public void AddOrReplaceInstances(string sourceKey, IList`1<EndpointInstance> endpointInstances);
}
public interface NServiceBus.Routing.IMessageDrivenSubscriptionTransport {
}
public class NServiceBus.Routing.MessageDrivenSubscriptions.PublisherAddress : object {
    private String[] addresses;
    private string endpoint;
    private EndpointInstance[] instances;
    public static PublisherAddress CreateFromEndpointName(string endpoint);
    public static PublisherAddress CreateFromEndpointInstances(EndpointInstance[] instances);
    public static PublisherAddress CreateFromPhysicalAddresses(String[] addresses);
    internal IEnumerable`1<string> Resolve(Func`2<string, IEnumerable`1<EndpointInstance>> instanceResolver, Func`2<EndpointInstance, string> addressResolver);
    public virtual string ToString();
    private bool Equals(PublisherAddress other);
    private static bool CollectionEquals(IEnumerable`1<T> left, IEnumerable`1<T> right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static int CollectionHashCode(IEnumerable`1<T> collection);
}
public class NServiceBus.Routing.MessageDrivenSubscriptions.Publishers : object {
    private Dictionary`2<Type, HashSet`1<PublisherAddress>> publishers;
    private Dictionary`2<string, IList`1<PublisherTableEntry>> publisherRegistrations;
    private object updateLock;
    internal IEnumerable`1<PublisherAddress> GetPublisherFor(Type eventType);
    public void AddOrReplacePublishers(string sourceKey, IList`1<PublisherTableEntry> entries);
}
public class NServiceBus.Routing.MessageDrivenSubscriptions.PublisherTableEntry : object {
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private PublisherAddress <Address>k__BackingField;
    public Type EventType { get; }
    public PublisherAddress Address { get; }
    public PublisherTableEntry(Type eventType, PublisherAddress address);
    [CompilerGeneratedAttribute]
public Type get_EventType();
    [CompilerGeneratedAttribute]
public PublisherAddress get_Address();
}
public class NServiceBus.Routing.MulticastAddressTag : AddressTag {
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    public Type MessageType { get; }
    public MulticastAddressTag(Type messageType);
    [CompilerGeneratedAttribute]
public Type get_MessageType();
}
public class NServiceBus.Routing.MulticastRoutingStrategy : RoutingStrategy {
    private Type messageType;
    public MulticastRoutingStrategy(Type messageType);
    public virtual AddressTag Apply(Dictionary`2<string, string> headers);
}
public class NServiceBus.Routing.RouteTableEntry : object {
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private UnicastRoute <Route>k__BackingField;
    public Type MessageType { get; }
    public UnicastRoute Route { get; }
    public RouteTableEntry(Type messageType, UnicastRoute route);
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public UnicastRoute get_Route();
}
public abstract class NServiceBus.Routing.RoutingStrategy : object {
    public abstract virtual AddressTag Apply(Dictionary`2<string, string> headers);
}
public class NServiceBus.Routing.SingleInstanceRoundRobinDistributionStrategy : DistributionStrategy {
    private long index;
    public SingleInstanceRoundRobinDistributionStrategy(string endpoint, DistributionStrategyScope scope);
    public virtual string SelectDestination(DistributionContext context);
}
public class NServiceBus.Routing.UnicastAddressTag : AddressTag {
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    public string Destination { get; }
    public UnicastAddressTag(string destination);
    [CompilerGeneratedAttribute]
public string get_Destination();
}
public class NServiceBus.Routing.UnicastRoute : object {
    [CompilerGeneratedAttribute]
private string <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointInstance <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PhysicalAddress>k__BackingField;
    public string Endpoint { get; private set; }
    public EndpointInstance Instance { get; private set; }
    public string PhysicalAddress { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Endpoint();
    [CompilerGeneratedAttribute]
private void set_Endpoint(string value);
    [CompilerGeneratedAttribute]
public EndpointInstance get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(EndpointInstance value);
    [CompilerGeneratedAttribute]
public string get_PhysicalAddress();
    [CompilerGeneratedAttribute]
private void set_PhysicalAddress(string value);
    public static UnicastRoute CreateFromEndpointName(string endpoint);
    public static UnicastRoute CreateFromEndpointInstance(EndpointInstance instance);
    public static UnicastRoute CreateFromPhysicalAddress(string physicalAddress);
    public virtual string ToString();
}
public class NServiceBus.Routing.UnicastRoutingStrategy : RoutingStrategy {
    private string destination;
    public UnicastRoutingStrategy(string destination);
    public virtual AddressTag Apply(Dictionary`2<string, string> headers);
}
public class NServiceBus.Routing.UnicastRoutingTable : object {
    private Dictionary`2<Type, UnicastRoute> routeTable;
    private Dictionary`2<string, IList`1<RouteTableEntry>> routeGroups;
    private object updateLock;
    internal UnicastRoute GetRouteFor(Type messageType);
    public void AddOrReplaceRoutes(string sourceKey, IList`1<RouteTableEntry> entries);
}
internal class NServiceBus.RoutingComponent : object {
    [CompilerGeneratedAttribute]
private bool <EnforceBestPractices>k__BackingField;
    public bool EnforceBestPractices { get; }
    private RoutingComponent(bool enforceBestPractices);
    public static Configuration Configure(Settings settings);
    [CompilerGeneratedAttribute]
public bool get_EnforceBestPractices();
    public UnicastSendRouter UnicastSendRouterBuilder(IServiceProvider serviceProvider);
    public static RoutingComponent Initialize(Configuration configuration, Configuration receiveConfiguration, Conventions conventions, PipelineSettings pipelineSettings, Configuration hostingConfiguration, TransportSeam transportSeam);
    private static void EnableBestPracticeEnforcement(PipelineSettings pipeline, Validations validations);
}
internal class NServiceBus.RoutingContext : OutgoingContext {
    [CompilerGeneratedAttribute]
private OutgoingMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<RoutingStrategy> <RoutingStrategies>k__BackingField;
    public OutgoingMessage Message { get; }
    public IReadOnlyCollection`1<RoutingStrategy> RoutingStrategies { get; public set; }
    public RoutingContext(OutgoingMessage messageToDispatch, RoutingStrategy routingStrategy, IBehaviorContext parentContext);
    public RoutingContext(OutgoingMessage messageToDispatch, IReadOnlyCollection`1<RoutingStrategy> routingStrategies, IBehaviorContext parentContext);
    [CompilerGeneratedAttribute]
public sealed virtual OutgoingMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<RoutingStrategy> get_RoutingStrategies();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RoutingStrategies(IReadOnlyCollection`1<RoutingStrategy> value);
}
[ExtensionAttribute]
internal static class NServiceBus.RoutingContextExtensions : object {
    [ExtensionAttribute]
public static TransportOperation ToTransportOperation(IRoutingContext context, RoutingStrategy strategy, DispatchConsistency dispatchConsistency, bool copySharedMutableMessageState);
}
[ExtensionAttribute]
public static class NServiceBus.RoutingFeatureSettingsExtensions : object {
    [ExtensionAttribute]
public static void OverridePublicReturnAddress(EndpointConfiguration configuration, string address);
}
[ExtensionAttribute]
public static class NServiceBus.RoutingOptionExtensions : object {
    [ExtensionAttribute]
public static void SetDestination(SendOptions options, string destination);
    [ExtensionAttribute]
public static void SetDestination(ReplyOptions options, string destination);
    [ExtensionAttribute]
public static string GetDestination(ReplyOptions options);
    [ExtensionAttribute]
public static string GetDestination(SendOptions options);
    [ExtensionAttribute]
public static void RouteToThisEndpoint(SendOptions options);
    [ExtensionAttribute]
public static bool IsRoutingToThisEndpoint(SendOptions options);
    [ExtensionAttribute]
public static void RouteToThisInstance(SendOptions options);
    [ExtensionAttribute]
public static bool IsRoutingToThisInstance(SendOptions options);
    [ExtensionAttribute]
public static void RouteToSpecificInstance(SendOptions options, string instanceId);
    [ExtensionAttribute]
public static string GetRouteToSpecificInstance(SendOptions options);
    [ExtensionAttribute]
public static void RouteReplyToThisInstance(SendOptions options);
    [ExtensionAttribute]
public static bool IsRoutingReplyToThisInstance(SendOptions options);
    [ExtensionAttribute]
public static void RouteReplyToAnyInstance(SendOptions options);
    [ExtensionAttribute]
public static bool IsRoutingReplyToAnyInstance(SendOptions options);
    [ExtensionAttribute]
public static void RouteReplyToThisInstance(ReplyOptions options);
    [ExtensionAttribute]
public static bool IsRoutingReplyToThisInstance(ReplyOptions options);
    [ExtensionAttribute]
public static void RouteReplyToAnyInstance(ReplyOptions options);
    [ExtensionAttribute]
public static bool IsRoutingReplyToAnyInstance(ReplyOptions options);
    [ExtensionAttribute]
public static void RouteReplyTo(ReplyOptions options, string address);
    [ExtensionAttribute]
public static string GetReplyToRoute(ReplyOptions options);
    [ExtensionAttribute]
public static void RouteReplyTo(SendOptions options, string address);
    [ExtensionAttribute]
public static string GetReplyToRoute(SendOptions options);
}
public class NServiceBus.RoutingSettings : ExposeSettings {
    public RoutingSettings(SettingsHolder settings);
    public void RouteToEndpoint(Type messageType, string destination);
    public void RouteToEndpoint(Assembly assembly, string destination);
    public void RouteToEndpoint(Assembly assembly, string namespace, string destination);
    public void DoNotEnforceBestPractices();
    private static void ThrowOnAddress(string destination);
}
public class NServiceBus.RoutingSettings`1 : RoutingSettings {
    public RoutingSettings`1(SettingsHolder settings);
}
internal class NServiceBus.RoutingToDispatchConnector : StageConnector`2<IRoutingContext, IDispatchContext> {
    private static ILog log;
    private static bool isDebugEnabled;
    private static RoutingToDispatchConnector();
    public virtual Task Invoke(IRoutingContext context, Func`2<IDispatchContext, Task> stage);
    private static void LogOutgoingOperations(TransportOperation[] operations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NServiceBus.RunningEndpointInstance : object {
    private ReceiveComponent receiveComponent;
    private FeatureComponent featureComponent;
    private IMessageSession messageSession;
    private TransportInfrastructure transportInfrastructure;
    private CancellationTokenSource stoppingTokenSource;
    [NullableAttribute("2")]
private IServiceProvider serviceProvider;
    private SettingsHolder settings;
    private Status modreq(System.Runtime.CompilerServices.IsVolatile) status;
    private SemaphoreSlim stopSemaphore;
    private static ILog Log;
    public RunningEndpointInstance(SettingsHolder settings, ReceiveComponent receiveComponent, FeatureComponent featureComponent, IMessageSession messageSession, TransportInfrastructure transportInfrastructure, CancellationTokenSource stoppingTokenSource, IServiceProvider serviceProvider);
    private static RunningEndpointInstance();
    [AsyncStateMachineAttribute("NServiceBus.RunningEndpointInstance/<Stop>d__1")]
public sealed virtual Task Stop(CancellationToken cancellationToken);
    public sealed virtual Task Send(object message, SendOptions sendOptions, CancellationToken cancellationToken);
    public sealed virtual Task Send(Action`1<T> messageConstructor, SendOptions sendOptions, CancellationToken cancellationToken);
    public sealed virtual Task Publish(object message, PublishOptions publishOptions, CancellationToken cancellationToken);
    public sealed virtual Task Publish(Action`1<T> messageConstructor, PublishOptions publishOptions, CancellationToken cancellationToken);
    public sealed virtual Task Subscribe(Type eventType, SubscribeOptions subscribeOptions, CancellationToken cancellationToken);
    public sealed virtual Task Unsubscribe(Type eventType, UnsubscribeOptions unsubscribeOptions, CancellationToken cancellationToken);
    private void GuardAgainstUseWhenNotStarted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NServiceBus.Saga : object {
    [CompilerGeneratedAttribute]
private IContainSagaData <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Completed>k__BackingField;
    public IContainSagaData Entity { get; public set; }
    public bool Completed { get; private set; }
    [CompilerGeneratedAttribute]
public IContainSagaData get_Entity();
    [CompilerGeneratedAttribute]
public void set_Entity(IContainSagaData value);
    [CompilerGeneratedAttribute]
public bool get_Completed();
    [CompilerGeneratedAttribute]
private void set_Completed(bool value);
    protected internal abstract virtual void ConfigureHowToFindSaga(IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
    protected Task RequestTimeout(IMessageHandlerContext context, DateTimeOffset at);
    protected Task RequestTimeout(IMessageHandlerContext context, DateTimeOffset at, TTimeoutMessageType timeoutMessage);
    protected Task RequestTimeout(IMessageHandlerContext context, TimeSpan within);
    protected Task RequestTimeout(IMessageHandlerContext context, TimeSpan within, TTimeoutMessageType timeoutMessage);
    protected Task ReplyToOriginator(IMessageHandlerContext context, object message, IReadOnlyDictionary`2<string, string> outgoingHeaders);
    protected void MarkAsComplete();
    private void VerifySagaCanHandleTimeout(TTimeoutMessageType timeoutMessage);
    private void SetTimeoutHeaders(ExtendableOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NServiceBus.Saga`1 : Saga {
    public TSagaData Data { get; public set; }
    public TSagaData get_Data();
    public void set_Data(TSagaData value);
    protected internal virtual void ConfigureHowToFindSaga(IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
    protected abstract virtual void ConfigureHowToFindSaga(SagaPropertyMapper`1<TSagaData> mapper);
}
internal abstract class NServiceBus.SagaFinder : object {
    public abstract virtual Task`1<IContainSagaData> Find(IServiceProvider builder, SagaFinderDefinition finderDefinition, ISynchronizedStorageSession storageSession, ContextBag context, object message, IReadOnlyDictionary`2<string, string> messageHeaders, CancellationToken cancellationToken);
}
internal class NServiceBus.SagaInvocationResult : object {
    private State state;
    public bool WasFound { get; }
    public bool get_WasFound();
    public void SagaFound();
    public void SagaNotFound();
}
internal class NServiceBus.SagaLookupValues : object {
    private Dictionary`2<Type, LookupValue> entries;
    public void Add(string propertyName, object propertyValue);
    public bool TryGet(Type sagaType, LookupValue& value);
}
internal class NServiceBus.SagaManifest : object {
    [CompilerGeneratedAttribute]
private string <StorageDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SagaEntityType>k__BackingField;
    public string StorageDirectory { get; public set; }
    public Type SagaEntityType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StorageDirectory();
    [CompilerGeneratedAttribute]
public void set_StorageDirectory(string value);
    [CompilerGeneratedAttribute]
public Type get_SagaEntityType();
    [CompilerGeneratedAttribute]
public void set_SagaEntityType(Type value);
    public string GetFilePath(Guid sagaId);
}
internal class NServiceBus.SagaManifestCollection : object {
    private Dictionary`2<Type, SagaManifest> sagaManifests;
    public SagaManifestCollection(SagaMetadataCollection sagas, string storageLocation, Func`2<string, string> sagaNameConverter);
    public SagaManifest GetForEntityType(Type type);
}
internal class NServiceBus.SagaPersistenceBehavior : object {
    private SagaMetadataCollection sagaMetadataCollection;
    private ISagaPersister sagaPersister;
    private ISagaIdGenerator sagaIdGenerator;
    private static Task`1<IContainSagaData> DefaultSagaDataCompletedTask;
    private static ILog logger;
    public SagaPersistenceBehavior(ISagaPersister persister, ISagaIdGenerator sagaIdGenerator, SagaMetadataCollection sagaMetadataCollection);
    private static SagaPersistenceBehavior();
    [AsyncStateMachineAttribute("NServiceBus.SagaPersistenceBehavior/<Invoke>d__1")]
public sealed virtual Task Invoke(IInvokeHandlerContext context, Func`2<IInvokeHandlerContext, Task> next);
    private static void RemoveSagaHeadersIfProcessingAEvent(IInvokeHandlerContext context);
    private static bool IsMessageAllowedToStartTheSaga(IInvokeHandlerContext context, SagaMetadata sagaMetadata);
    private static bool IsTimeoutMessage(Dictionary`2<string, string> headers);
    private Task`1<IContainSagaData> TryLoadSagaEntity(SagaMetadata metadata, IInvokeHandlerContext context);
    private static SagaFinderDefinition GetSagaFinder(SagaMetadata metadata, IInvokeHandlerContext context);
    private IContainSagaData CreateNewSagaEntity(SagaMetadata metadata, IInvokeHandlerContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NServiceBus.SagaPropertyMapper`1 : object {
    private IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration;
    internal SagaPropertyMapper`1(IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration);
    public ToSagaExpression`2<TSagaData, TMessage> ConfigureMapping(Expression`1<Func`2<TMessage, object>> messageProperty);
    public IToSagaExpression`1<TSagaData> ConfigureHeaderMapping(string headerName);
    public CorrelatedSagaPropertyMapper`1<TSagaData> MapSaga(Expression`1<Func`2<TSagaData, object>> sagaProperty);
}
public class NServiceBus.Sagas.ActiveSagaInstance : object {
    private Func`1<DateTimeOffset> currentDateTimeOffsetProvider;
    [CompilerGeneratedAttribute]
private string <SagaId>k__BackingField;
    [CompilerGeneratedAttribute]
private SagaMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Saga <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNew>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Modified>k__BackingField;
    private CorrelationPropertyInfo correlationProperty;
    private Guid sagaId;
    public string SagaId { get; internal set; }
    internal SagaMetadata Metadata { get; }
    public Saga Instance { get; }
    public bool IsNew { get; private set; }
    public bool NotFound { get; private set; }
    public DateTimeOffset Created { get; }
    public DateTimeOffset Modified { get; private set; }
    public ActiveSagaInstance(Saga saga, SagaMetadata metadata, Func`1<DateTimeOffset> currentDateTimeOffsetProvider);
    [CompilerGeneratedAttribute]
public string get_SagaId();
    [CompilerGeneratedAttribute]
internal void set_SagaId(string value);
    [CompilerGeneratedAttribute]
internal SagaMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public Saga get_Instance();
    [CompilerGeneratedAttribute]
public bool get_IsNew();
    [CompilerGeneratedAttribute]
private void set_IsNew(bool value);
    [CompilerGeneratedAttribute]
public bool get_NotFound();
    [CompilerGeneratedAttribute]
private void set_NotFound(bool value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Created();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Modified();
    [CompilerGeneratedAttribute]
private void set_Modified(DateTimeOffset value);
    internal bool TryGetCorrelationProperty(CorrelationPropertyInfo& sagaCorrelationProperty);
    public void AttachNewEntity(IContainSagaData sagaEntity);
    internal void AttachExistingEntity(IContainSagaData loadedEntity);
    private void AttachEntity(IContainSagaData sagaEntity);
    private void UpdateModified();
    internal void MarkAsNotFound();
    internal void Completed();
    internal void Updated();
    internal void ValidateChanges();
    private void ValidateCorrelationPropertyHaveValue(object currentCorrelationPropertyValue);
    private void ValidateCorrelationPropertyNotModified(object currentCorrelationPropertyValue);
    private void ValidateSagaIdIsNotModified();
    private static object GetDefault(Type type);
}
public interface NServiceBus.Sagas.IFinder {
}
[NullableContextAttribute("1")]
public interface NServiceBus.Sagas.IHandleSagaNotFound {
    public abstract virtual Task Handle(object message, IMessageProcessingContext context);
}
public interface NServiceBus.Sagas.ISagaFinder`2 {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<TSagaData> FindBy(TMessage message, ISynchronizedStorageSession storageSession, IReadOnlyContextBag context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface NServiceBus.Sagas.ISagaIdGenerator {
    public abstract virtual Guid Generate(SagaIdGeneratorContext context);
}
public interface NServiceBus.Sagas.ISagaPersister {
    public abstract virtual Task Save(IContainSagaData sagaData, SagaCorrelationProperty correlationProperty, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task Update(IContainSagaData sagaData, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task`1<TSagaData> Get(Guid sagaId, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task`1<TSagaData> Get(string propertyName, object propertyValue, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task Complete(IContainSagaData sagaData, ISynchronizedStorageSession session, ContextBag context, CancellationToken cancellationToken);
}
public class NServiceBus.Sagas.SagaCorrelationProperty : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private static SagaCorrelationProperty <None>k__BackingField;
    public string Name { get; }
    public object Value { get; }
    public static SagaCorrelationProperty None { get; }
    public SagaCorrelationProperty(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public static SagaCorrelationProperty get_None();
}
public class NServiceBus.Sagas.SagaFinderDefinition : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Properties>k__BackingField;
    public Type Type { get; }
    public Type MessageType { get; }
    public string MessageTypeName { get; }
    public Dictionary`2<string, object> Properties { get; }
    internal SagaFinderDefinition(Type type, Type messageType, Dictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public string get_MessageTypeName();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Properties();
}
public class NServiceBus.Sagas.SagaIdGeneratorContext : object {
    [CompilerGeneratedAttribute]
private SagaCorrelationProperty <CorrelationProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private SagaMetadata <SagaMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ContextBag <Extensions>k__BackingField;
    public SagaCorrelationProperty CorrelationProperty { get; }
    public SagaMetadata SagaMetadata { get; }
    public ContextBag Extensions { get; }
    public SagaIdGeneratorContext(SagaCorrelationProperty correlationProperty, SagaMetadata sagaMetadata, ContextBag extensions);
    [CompilerGeneratedAttribute]
public SagaCorrelationProperty get_CorrelationProperty();
    [CompilerGeneratedAttribute]
public SagaMetadata get_SagaMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual ContextBag get_Extensions();
}
public class NServiceBus.Sagas.SagaMessage : object {
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAllowedToStartSaga>k__BackingField;
    public Type MessageType { get; }
    public string MessageTypeName { get; }
    public bool IsAllowedToStartSaga { get; }
    internal SagaMessage(Type messageType, bool isAllowedToStart);
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public string get_MessageTypeName();
    [CompilerGeneratedAttribute]
public bool get_IsAllowedToStartSaga();
}
public class NServiceBus.Sagas.SagaMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SagaEntityType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SagaType>k__BackingField;
    private Dictionary`2<string, SagaMessage> associatedMessages;
    private CorrelationPropertyMetadata correlationProperty;
    private Dictionary`2<string, SagaFinderDefinition> sagaFinders;
    private static Type[] AllowedCorrelationPropertyTypes;
    public IReadOnlyCollection`1<SagaMessage> AssociatedMessages { get; }
    public IReadOnlyCollection`1<SagaFinderDefinition> Finders { get; }
    public string Name { get; }
    public string EntityName { get; }
    public Type SagaEntityType { get; }
    public Type SagaType { get; }
    public SagaMetadata(string name, Type sagaType, string entityName, Type sagaEntityType, CorrelationPropertyMetadata correlationProperty, IReadOnlyCollection`1<SagaMessage> messages, IReadOnlyCollection`1<SagaFinderDefinition> finders);
    private static SagaMetadata();
    public IReadOnlyCollection`1<SagaMessage> get_AssociatedMessages();
    public IReadOnlyCollection`1<SagaFinderDefinition> get_Finders();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_EntityName();
    [CompilerGeneratedAttribute]
public Type get_SagaEntityType();
    [CompilerGeneratedAttribute]
public Type get_SagaType();
    public bool TryGetCorrelationProperty(CorrelationPropertyMetadata& property);
    internal static bool IsSagaType(Type t);
    public bool IsMessageAllowedToStartTheSaga(string messageType);
    public bool TryGetFinder(string messageType, SagaFinderDefinition& finderDefinition);
    public static SagaMetadata Create(Type sagaType);
    public static SagaMetadata Create(Type sagaType, IEnumerable`1<Type> availableTypes, Conventions conventions);
    private static void ApplyScannedFinders(SagaMapper mapper, Type sagaEntityType, IEnumerable`1<Type> availableTypes, Conventions conventions);
    private static List`1<SagaMessage> GetAssociatedMessages(Type sagaType);
    [IteratorStateMachineAttribute("NServiceBus.Sagas.SagaMetadata/<GetMessagesCorrespondingToFilterOnSaga>d__25")]
private static IEnumerable`1<Type> GetMessagesCorrespondingToFilterOnSaga(Type sagaType, Type filter);
    private static Type GetBaseSagaType(Type t);
}
public class NServiceBus.Sagas.SagaMetadataCollection : object {
    private Dictionary`2<Type, SagaMetadata> byEntity;
    private Dictionary`2<Type, SagaMetadata> byType;
    public sealed virtual IEnumerator`1<SagaMetadata> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Initialize(IEnumerable`1<Type> availableTypes);
    public void Initialize(IEnumerable`1<Type> availableTypes, Conventions conventions);
    public SagaMetadata FindByEntity(Type entityType);
    public SagaMetadata Find(Type sagaType);
    internal bool TryFind(Type sagaType, SagaMetadata& targetSagaMetaData);
    internal void VerifyIfEntitiesAreShared();
}
public class NServiceBus.Sagas.SagaSettings : ExposeSettings {
    internal static string DisableVerifyingIfEntitiesAreShared;
    internal SagaSettings(SettingsHolder settings);
    public void DisableBestPracticeValidation();
}
[ExtensionAttribute]
public static class NServiceBus.SagasConfigExtensions : object {
    [ExtensionAttribute]
public static SagaSettings Sagas(EndpointConfiguration config);
}
internal class NServiceBus.SagaStorageFile : object {
    private FileStream fileStream;
    private bool isCompleted;
    private static int DefaultBufferSize;
    private static Task`1<SagaStorageFile> noSagaFoundResult;
    private static JsonSerializerOptions Options;
    private SagaStorageFile(FileStream fileStream);
    private static SagaStorageFile();
    public sealed virtual void Dispose();
    public static Task`1<SagaStorageFile> Open(Guid sagaId, SagaManifest manifest, CancellationToken cancellationToken);
    public static Task`1<SagaStorageFile> Create(Guid sagaId, SagaManifest manifest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.SagaStorageFile/<OpenWithRetryOnConcurrency>d__4")]
private static Task`1<SagaStorageFile> OpenWithRetryOnConcurrency(string filePath, FileMode fileAccess, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.SagaStorageFile/<Write>d__5")]
public Task Write(IContainSagaData sagaData, CancellationToken cancellationToken);
    public void MarkAsCompleted();
    public ValueTask`1<TSagaData> Read(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class NServiceBus.SagaStorageFileExtensions : object {
    [ExtensionAttribute]
public static void RegisterSagaFile(Dictionary`2<string, SagaStorageFile> sagaFiles, SagaStorageFile sagaStorageFile, Guid sagaId, Type sagaDataType);
}
internal abstract class NServiceBus.SagaToMessageMap : object {
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    public Type MessageType { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public void set_MessageType(Type value);
    public abstract virtual SagaFinderDefinition CreateSagaFinderDefinition(Type sagaEntityType);
    public void AssertSagaHandlesMappedMessage(Type sagaType, IEnumerable`1<SagaMessage> associatedMessages);
    protected virtual string SagaDoesNotHandleMappedMessage(Type sagaType);
    [CompilerGeneratedAttribute]
private bool <AssertSagaHandlesMappedMessage>b__5_0(SagaMessage m);
}
internal class NServiceBus.SatelliteDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueAddress <ReceiveAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private PushRuntimeSettings <RuntimeSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<RecoverabilityConfig, ErrorContext, RecoverabilityAction> <RecoverabilityPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private OnSatelliteMessage <OnMessage>k__BackingField;
    public string Name { get; }
    public QueueAddress ReceiveAddress { get; }
    public PushRuntimeSettings RuntimeSettings { get; }
    public Func`3<RecoverabilityConfig, ErrorContext, RecoverabilityAction> RecoverabilityPolicy { get; }
    public OnSatelliteMessage OnMessage { get; }
    public SatelliteDefinition(string name, QueueAddress receiveAddress, PushRuntimeSettings runtimeSettings, Func`3<RecoverabilityConfig, ErrorContext, RecoverabilityAction> recoverabilityPolicy, OnSatelliteMessage onMessage);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public QueueAddress get_ReceiveAddress();
    [CompilerGeneratedAttribute]
public PushRuntimeSettings get_RuntimeSettings();
    [CompilerGeneratedAttribute]
public Func`3<RecoverabilityConfig, ErrorContext, RecoverabilityAction> get_RecoverabilityPolicy();
    [CompilerGeneratedAttribute]
public OnSatelliteMessage get_OnMessage();
}
internal class NServiceBus.SatellitePipelineExecutor : object {
    private SatelliteDefinition satelliteDefinition;
    private IServiceProvider builder;
    public SatellitePipelineExecutor(IServiceProvider builder, SatelliteDefinition definition);
    public sealed virtual Task Invoke(MessageContext messageContext, CancellationToken cancellationToken);
}
internal class NServiceBus.SatelliteRecoverabilityExecutor`1 : object {
    private IServiceProvider serviceProvider;
    private FaultMetadataExtractor faultMetadataExtractor;
    private Func`3<ErrorContext, TState, RecoverabilityAction> recoverabilityPolicy;
    private TState state;
    public SatelliteRecoverabilityExecutor`1(IServiceProvider serviceProvider, FaultMetadataExtractor faultMetadataExtractor, Func`3<ErrorContext, TState, RecoverabilityAction> recoverabilityPolicy, TState state);
    [AsyncStateMachineAttribute("NServiceBus.SatelliteRecoverabilityExecutor`1/<Invoke>d__1")]
public sealed virtual Task`1<ErrorHandleResult> Invoke(ErrorContext errorContext, CancellationToken cancellationToken);
}
internal class NServiceBus.SaveAction : StorageAction {
    public SaveAction(IContainSagaData sagaData, Dictionary`2<string, SagaStorageFile> sagaFiles, SagaManifestCollection sagaManifests);
    [AsyncStateMachineAttribute("NServiceBus.SaveAction/<Execute>d__1")]
public virtual Task Execute(CancellationToken cancellationToken);
}
internal class NServiceBus.SendComponent : object {
    private IActivityFactory activityFactory;
    private IMessageMapper messageMapper;
    private SendComponent(IMessageMapper messageMapper, IActivityFactory activityFactory);
    public static SendComponent Initialize(PipelineSettings pipelineSettings, Configuration hostingConfiguration, RoutingComponent routingComponent, IMessageMapper messageMapper);
    public MessageOperations CreateMessageOperations(IServiceProvider builder, PipelineComponent pipelineComponent);
}
internal class NServiceBus.SendConnector : StageConnector`2<IOutgoingSendContext, IOutgoingLogicalMessageContext> {
    private UnicastSendRouter unicastSendRouter;
    public SendConnector(UnicastSendRouter unicastSendRouter);
    [AsyncStateMachineAttribute("NServiceBus.SendConnector/<Invoke>d__1")]
public virtual Task Invoke(IOutgoingSendContext context, Func`2<IOutgoingLogicalMessageContext, Task> stage);
}
internal class NServiceBus.SendOnlySubscribeTerminator : PipelineTerminator`1<ISubscribeContext> {
    protected virtual Task Terminate(ISubscribeContext context);
}
internal class NServiceBus.SendOnlyUnsubscribeTerminator : PipelineTerminator`1<IUnsubscribeContext> {
    protected virtual Task Terminate(IUnsubscribeContext context);
}
public class NServiceBus.SendOptions : ExtendableOptions {
}
public interface NServiceBus.Serialization.IMessageSerializer {
    public string ContentType { get; }
    public abstract virtual string get_ContentType();
    public abstract virtual void Serialize(object message, Stream stream);
    public abstract virtual Object[] Deserialize(ReadOnlyMemory`1<byte> body, IList`1<Type> messageTypes);
}
public abstract class NServiceBus.Serialization.SerializationDefinition : object {
    public abstract virtual Func`2<IMessageMapper, IMessageSerializer> Configure(IReadOnlySettings settings);
}
public class NServiceBus.Serialization.SerializationExtensions`1 : ExposeSettings {
    internal SettingsHolder EndpointConfigurationSettings;
    public SerializationExtensions`1(SettingsHolder serializerSettings, SettingsHolder endpointConfigurationSettings);
}
[ExtensionAttribute]
public static class NServiceBus.SerializationConfigExtensions : object {
    [ExtensionAttribute]
public static SerializationExtensions`1<T> UseSerialization(EndpointConfiguration config);
    [ExtensionAttribute]
public static SerializationExtensions`1<T> UseSerialization(EndpointConfiguration config, T serializationDefinition);
    [ExtensionAttribute]
public static SerializationExtensions`1<T> AddDeserializer(EndpointConfiguration config);
    [ExtensionAttribute]
public static SerializationExtensions`1<T> AddDeserializer(EndpointConfiguration config, T serializationDefinition);
    private static SerializationExtensions`1<T> CreateSerializationExtension(SettingsHolder serializerSettings, SettingsHolder endpointConfigurationSettings);
}
[ExtensionAttribute]
public static class NServiceBus.SerializationContextExtensions : object {
    [ExtensionAttribute]
public static void SkipSerialization(IOutgoingLogicalMessageContext context);
    [ExtensionAttribute]
public static bool ShouldSkipSerialization(IOutgoingLogicalMessageContext context);
}
[ExtensionAttribute]
public static class NServiceBus.SerializationExtensionsExtensions : object {
    private static string DisableMessageTypeInferenceKey;
    private static string DisableDynamicTypeLoadingKey;
    [ExtensionAttribute]
public static void DisableMessageTypeInference(SerializationExtensions`1<T> config);
    [ExtensionAttribute]
public static void DisableDynamicTypeLoading(SerializationExtensions`1<T> config);
    [ExtensionAttribute]
internal static bool IsDynamicTypeLoadingEnabled(IReadOnlySettings endpointConfigurationSettings);
    [ExtensionAttribute]
internal static bool IsMessageTypeInferenceEnabled(IReadOnlySettings endpointConfigurationSettings);
}
internal class NServiceBus.SerializationFeature : Feature {
    private static ILog Logger;
    private static SerializationFeature();
    protected internal sealed virtual void Setup(FeatureConfigurationContext context);
    private static IMessageSerializer CreateMessageSerializer(Tuple`2<SerializationDefinition, SettingsHolder> definitionAndSettings, IMessageMapper mapper, IReadOnlySettings mainSettings);
    private static void LogFoundMessages(IReadOnlyCollection`1<MessageMetadata> messageDefinitions);
}
[ExtensionAttribute]
internal static class NServiceBus.SerializationSettingsExtensions : object {
    private static string AdditionalSerializersSettingsKey;
    private static string MainSerializerSettingsKey;
    private static ILog log;
    private static SerializationSettingsExtensions();
    [ExtensionAttribute]
public static List`1<Tuple`2<SerializationDefinition, SettingsHolder>> GetAdditionalSerializers(SettingsHolder settings);
    [ExtensionAttribute]
public static List`1<Tuple`2<SerializationDefinition, SettingsHolder>> GetAdditionalSerializers(IReadOnlySettings settings);
    [ExtensionAttribute]
public static void SetMainSerializer(SettingsHolder settings, SerializationDefinition definition, SettingsHolder serializerSpecificSettings);
    [ExtensionAttribute]
public static Tuple`2<SerializationDefinition, SettingsHolder> GetMainSerializer(IReadOnlySettings settings);
}
internal class NServiceBus.SerializeMessageConnector : StageConnector`2<IOutgoingLogicalMessageContext, IOutgoingPhysicalMessageContext> {
    private MessageMetadataRegistry messageMetadataRegistry;
    private IMessageSerializer messageSerializer;
    private static ILog log;
    public SerializeMessageConnector(IMessageSerializer messageSerializer, MessageMetadataRegistry messageMetadataRegistry);
    private static SerializeMessageConnector();
    [AsyncStateMachineAttribute("NServiceBus.SerializeMessageConnector/<Invoke>d__1")]
public virtual Task Invoke(IOutgoingLogicalMessageContext context, Func`2<IOutgoingPhysicalMessageContext, Task> stage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NServiceBus.Serializers.SystemJson.JsonMessageSerializer : object {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [NullableAttribute("2")]
private JsonSerializerOptions serializerOptions;
    private IMessageMapper messageMapper;
    public string ContentType { get; }
    internal JsonMessageSerializer(SystemJsonSerializerSettings settings, IMessageMapper messageMapper);
    public JsonMessageSerializer(JsonSerializerOptions serializerOptions, string contentType, IMessageMapper messageMapper);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentType();
    public sealed virtual void Serialize(object message, Stream stream);
    [NullableContextAttribute("0")]
public sealed virtual Object[] Deserialize(ReadOnlyMemory`1<byte> body, IList`1<Type> messageTypes);
    private object Deserialize(ReadOnlyMemory`1<byte> body, Type type);
    [IteratorStateMachineAttribute("NServiceBus.Serializers.SystemJson.JsonMessageSerializer/<FindRootTypes>d__8")]
private static IEnumerable`1<Type> FindRootTypes(IEnumerable`1<Type> messageTypesToDeserialize);
    private Type GetMappedType(Type messageType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NServiceBus.Serializers.SystemJson.SystemJsonSerializerSettings : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <SerializerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [NullableAttribute("2")]
public JsonSerializerOptions SerializerOptions { get; public set; }
    public string ContentType { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonSerializerOptions get_SerializerOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_SerializerOptions(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
}
[ExtensionAttribute]
[ObsoleteAttribute("Use methods on IServiceCollection instead. Note that interfaces are not registered implicitly. See the NServiceBus 7 to 8 upgrade guide for more information. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static class NServiceBus.ServiceCollectionExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceCollection.Add` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static void ConfigureComponent(IServiceCollection serviceCollection, Type concreteComponent, DependencyLifecycle dependencyLifecycle);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceCollection.Add`, `IServiceCollection.AddSingleton`, `IServiceCollection.AddTransient` or `IServiceCollection.AddScoped` instead. Note that interfaces are not registered implicitly. See the NServiceBus 7 to 8 upgrade guide for more information. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static void ConfigureComponent(IServiceCollection serviceCollection, DependencyLifecycle dependencyLifecycle);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceCollection.Add`, `IServiceCollection.AddSingleton`, `IServiceCollection.AddTransient` or `IServiceCollection.AddScoped` instead. Note that interfaces are not registered implicitly. See the NServiceBus 7 to 8 upgrade guide for more information. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static void ConfigureComponent(IServiceCollection serviceCollection, Func`1<T> componentFactory, DependencyLifecycle dependencyLifecycle);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceCollection.Add`, `IServiceCollection.AddSingleton`, `IServiceCollection.AddTransient` or `IServiceCollection.AddScoped` instead. Note that interfaces are not registered implicitly. See the NServiceBus 7 to 8 upgrade guide for more information. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static void ConfigureComponent(IServiceCollection serviceCollection, Func`2<IServiceProvider, T> componentFactory, DependencyLifecycle dependencyLifecycle);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceCollection.Add`, `IServiceCollection.AddSingleton`, `IServiceCollection.AddTransient` or `IServiceCollection.AddScoped` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static void RegisterSingleton(IServiceCollection serviceCollection, Type lookupType, object instance);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceCollection.AddSingleton` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static void RegisterSingleton(IServiceCollection serviceCollection, T instance);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceCollection.GetEnumerator` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static bool HasComponent(IServiceCollection serviceCollection);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `IServiceCollection.GetEnumerator` instead. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static bool HasComponent(IServiceCollection serviceCollection, Type componentType);
}
public interface NServiceBus.Settings.IReadOnlySettings {
    public abstract virtual T Get();
    public abstract virtual T Get(string key);
    public abstract virtual bool TryGet(T& val);
    public abstract virtual bool TryGet(string key, T& val);
    public abstract virtual object Get(string key);
    public abstract virtual T GetOrDefault();
    public abstract virtual T GetOrDefault(string key);
    public abstract virtual bool HasSetting(string key);
    public abstract virtual bool HasSetting();
    public abstract virtual bool HasExplicitValue(string key);
    public abstract virtual bool HasExplicitValue();
}
public class NServiceBus.Settings.SettingsHolder : object {
    private ConcurrentDictionary`2<string, object> Defaults;
    private bool locked;
    private ConcurrentDictionary`2<string, object> Overrides;
    public sealed virtual T Get(string key);
    public sealed virtual bool TryGet(T& val);
    public sealed virtual bool TryGet(string key, T& val);
    public sealed virtual T Get();
    public sealed virtual object Get(string key);
    public sealed virtual T GetOrDefault();
    public sealed virtual T GetOrDefault(string key);
    public sealed virtual bool HasSetting(string key);
    public sealed virtual bool HasSetting();
    public sealed virtual bool HasExplicitValue(string key);
    public sealed virtual bool HasExplicitValue();
    public T GetOrCreate();
    public void Set(string key, object value);
    public void Set(T value);
    public void Set(Action value);
    public void SetDefault(T value);
    public void SetDefault(Action value);
    public void SetDefault(string key, object value);
    internal void PreventChanges();
    internal void Merge(IReadOnlySettings settings);
    private void EnsureMergingIsPossible();
    private void EnsureWriteEnabled(string key);
    public void Clear();
}
[ExtensionAttribute]
public static class NServiceBus.SettingsExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use FeatureConfigurationContext.LocalQueueAddress() to access the endpoint queue address. Inject the ReceiveAddresses class to access the endpoint's receiving transport addresses at runtime. See the NServiceBus version 8 upgrade guide for further details. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static string LocalAddress(IReadOnlySettings settings);
    [ExtensionAttribute]
[ObsoleteAttribute("Use FeatureConfigurationContext.InstanceSpecificQueueAddress() to access the endpoint instance specific queue address. Inject the ReceiveAddresses class to access the endpoint's receiving transport addresses at runtime. See the NServiceBus version 8 upgrade guide for further details. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static string InstanceSpecificQueue(IReadOnlySettings settings);
    [ExtensionAttribute]
public static IList`1<Type> GetAvailableTypes(IReadOnlySettings settings);
    [ExtensionAttribute]
public static string EndpointName(IReadOnlySettings settings);
    [ExtensionAttribute]
public static string EndpointQueueName(IReadOnlySettings settings);
}
internal class NServiceBus.StartableEndpoint : object {
    private PipelineComponent pipelineComponent;
    private RecoverabilityComponent recoverabilityComponent;
    private HostingComponent hostingComponent;
    private SendComponent sendComponent;
    private IServiceProvider serviceProvider;
    private bool serviceProviderIsExternallyManaged;
    private FeatureComponent featureComponent;
    private SettingsHolder settings;
    private ReceiveComponent receiveComponent;
    private TransportSeam transportSeam;
    private MessageSession messageSession;
    private TransportInfrastructure transportInfrastructure;
    private CancellationTokenSource stoppingTokenSource;
    public StartableEndpoint(SettingsHolder settings, FeatureComponent featureComponent, ReceiveComponent receiveComponent, TransportSeam transportSeam, PipelineComponent pipelineComponent, RecoverabilityComponent recoverabilityComponent, HostingComponent hostingComponent, SendComponent sendComponent, IServiceProvider serviceProvider, bool serviceProviderIsExternallyManaged);
    public Task RunInstallers(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.StartableEndpoint/<Setup>d__2")]
public Task Setup(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.StartableEndpoint/<Start>d__3")]
public Task`1<IEndpointInstance> Start(CancellationToken cancellationToken);
}
public class NServiceBus.StartupDiagnosticEntries : object {
    internal List`1<StartupDiagnosticEntry> entries;
    public void Add(string sectionName, object section);
}
internal class NServiceBus.StaticHeaders : Feature {
    protected internal virtual void Setup(FeatureConfigurationContext context);
}
[ExtensionAttribute]
public static class NServiceBus.StaticHeadersConfigExtensions : object {
    [ExtensionAttribute]
public static void AddHeaderToAllOutgoingMessages(EndpointConfiguration config, string key, string value);
}
internal class NServiceBus.StepRegistrationsCoordinator : object {
    private List`1<RegisterStep> additions;
    private List`1<ReplaceStep> replacements;
    private List`1<RegisterOrReplaceStep> addOrReplaceSteps;
    public StepRegistrationsCoordinator(List`1<ReplaceStep> replacements, List`1<RegisterOrReplaceStep> addOrReplaceSteps);
    public void Register(string pipelineStep, Type behavior, string description);
    public void Register(RegisterStep rego);
    public List`1<RegisterStep> BuildPipelineModelFor();
}
internal abstract class NServiceBus.StorageAction : object {
    protected IContainSagaData sagaData;
    protected Dictionary`2<string, SagaStorageFile> sagaFiles;
    protected SagaManifestCollection sagaManifests;
    private string sagaFileKey;
    protected StorageAction(IContainSagaData sagaData, Dictionary`2<string, SagaStorageFile> sagaFiles, SagaManifestCollection sagaManifests);
    public abstract virtual Task Execute(CancellationToken cancellationToken);
    protected SagaStorageFile GetSagaFile();
}
public abstract class NServiceBus.StorageType : object {
    private string storage;
    private StorageType(string storage);
    public virtual string ToString();
    internal static List`1<Type> GetAvailableStorageTypes();
}
[ExtensionAttribute]
internal static class NServiceBus.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder NewLine(StringBuilder stringBuilder, string newLine);
}
internal class NServiceBus.SubscribeContext : BehaviorContext {
    [CompilerGeneratedAttribute]
private Type[] <EventTypes>k__BackingField;
    public Type[] EventTypes { get; }
    [EditorBrowsableAttribute("1")]
public Type EventType { get; }
    public SubscribeContext(IBehaviorContext parentContext, Type[] eventTypes, ContextBag extensions);
    [CompilerGeneratedAttribute]
public sealed virtual Type[] get_EventTypes();
    public Type get_EventType();
}
internal class NServiceBus.SubscribeDiagnosticsBehavior : object {
    public sealed virtual Task Invoke(ISubscribeContext context, Func`2<ISubscribeContext, Task> next);
}
public class NServiceBus.SubscribeOptions : ExtendableOptions {
}
public class NServiceBus.SubscriptionMigrationModeSettings : ExposeSettings {
    public SubscriptionMigrationModeSettings(SettingsHolder settings);
    public void SubscriptionAuthorizer(Func`2<IIncomingPhysicalMessageContext, bool> authorizer);
    public void RegisterPublisher(Type eventType, string publisherEndpoint);
    public void RegisterPublisher(Assembly assembly, string publisherEndpoint);
    public void RegisterPublisher(Assembly assembly, string namespace, string publisherEndpoint);
    private static void ThrowOnAddress(string publisherEndpoint);
}
internal class NServiceBus.SubscriptionReceiverBehavior : object {
    private Func`2<IIncomingPhysicalMessageContext, bool> authorizer;
    private ISubscriptionStorage subscriptionStorage;
    private static ILog Logger;
    public SubscriptionReceiverBehavior(ISubscriptionStorage subscriptionStorage, Func`2<IIncomingPhysicalMessageContext, bool> authorizer);
    private static SubscriptionReceiverBehavior();
    [AsyncStateMachineAttribute("NServiceBus.SubscriptionReceiverBehavior/<Invoke>d__1")]
public sealed virtual Task Invoke(IIncomingPhysicalMessageContext context, Func`2<IIncomingPhysicalMessageContext, Task> next);
    private static string GetSubscriptionMessageTypeFrom(IncomingMessage msg);
}
internal class NServiceBus.SubscriptionRouter : object {
    private EndpointInstances endpointInstances;
    private Func`2<EndpointInstance, string> transportAddressTranslation;
    private static List`1<string> noAddresses;
    private Publishers publishers;
    public SubscriptionRouter(Publishers publishers, EndpointInstances endpointInstances, Func`2<EndpointInstance, string> transportAddressTranslation);
    private static SubscriptionRouter();
    public List`1<string> GetAddressesForEventType(Type messageType);
    [CompilerGeneratedAttribute]
private IEnumerable`1<EndpointInstance> <GetAddressesForEventType>b__1_0(string e);
    [CompilerGeneratedAttribute]
private string <GetAddressesForEventType>b__1_1(EndpointInstance i);
}
public static class NServiceBus.Support.RuntimeEnvironment : object {
    [CompilerGeneratedAttribute]
private static Func`1<string> <MachineNameAction>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MachineName>k__BackingField;
    [ObsoleteAttribute("Use `HostInfoSettings.UsingHostName` instead. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public static Func`1<string> MachineNameAction { get; public set; }
    public static string MachineName { get; private set; }
    private static RuntimeEnvironment();
    [CompilerGeneratedAttribute]
public static Func`1<string> get_MachineNameAction();
    [CompilerGeneratedAttribute]
public static void set_MachineNameAction(Func`1<string> value);
    [CompilerGeneratedAttribute]
public static string get_MachineName();
    [CompilerGeneratedAttribute]
private static void set_MachineName(string value);
    internal static void SetMachineName(string machineName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NServiceBus.SystemJsonConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Options(SerializationExtensions`1<SystemJsonSerializer> config, JsonSerializerOptions options);
    [ExtensionAttribute]
public static void ContentType(SerializationExtensions`1<SystemJsonSerializer> config, string contentType);
}
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public class NServiceBus.SystemJsonDataBusSerializer : object {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public string ContentType { get; }
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public sealed virtual void Serialize(object dataBusProperty, Stream stream);
    [ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public sealed virtual object Deserialize(Type propertyType, Stream stream);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentType();
}
public class NServiceBus.SystemJsonSerializer : SerializationDefinition {
    [NullableContextAttribute("1")]
public virtual Func`2<IMessageMapper, IMessageSerializer> Configure(IReadOnlySettings settings);
}
[ExtensionAttribute]
internal static class NServiceBus.TaskEx : object {
    private static string TaskIsNullExceptionMessage;
    [ExtensionAttribute]
public static Task`1<T> ThrowIfNull(Task`1<T> task);
    [ExtensionAttribute]
public static Task ThrowIfNull(Task task);
}
internal class NServiceBus.ThrowIfCannotDeferMessageBehavior : object {
    public sealed virtual Task Invoke(IRoutingContext context, Func`2<IRoutingContext, Task> next);
}
[AttributeUsageAttribute("1028")]
public class NServiceBus.TimeToBeReceivedAttribute : Attribute {
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToBeReceived>k__BackingField;
    public TimeSpan TimeToBeReceived { get; }
    public TimeToBeReceivedAttribute(string timeSpan);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToBeReceived();
}
[ExtensionAttribute]
public static class NServiceBus.TimeToBeReceivedConventionExtensions : object {
    [ExtensionAttribute]
public static ConventionsBuilder DefiningTimeToBeReceivedAs(ConventionsBuilder builder, Func`2<Type, TimeSpan> retrieveTimeToBeReceived);
}
internal class NServiceBus.TimeToBeReceivedMappings : object {
    private ConcurrentDictionary`2<Type, TimeSpan> mappings;
    private Func`2<Type, TimeSpan> convention;
    private bool doesTransportSupportDiscardIfNotReceivedBefore;
    public static Func`2<Type, TimeSpan> DefaultConvention;
    public TimeToBeReceivedMappings(IEnumerable`1<Type> knownMessages, Func`2<Type, TimeSpan> convention, bool doesTransportSupportDiscardIfNotReceivedBefore);
    private static TimeToBeReceivedMappings();
    public bool TryGetTimeToBeReceived(Type messageType, TimeSpan& timeToBeReceived);
    private static TimeSpan GetTimeToBeReceived(Func`2<Type, TimeSpan> convention, Type messageType, bool doesTransportSupportDiscardIfNotReceivedBefore);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private TimeSpan <TryGetTimeToBeReceived>b__1_0(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NServiceBus.ToSagaExpression`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Expression`1<Func`2<TMessage, object>> messageProperty;
    private IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration;
    public ToSagaExpression`2(IConfigureHowToFindSagaWithMessage sagaMessageFindingConfiguration, Expression`1<Func`2<TMessage, object>> messageProperty);
    public void ToSaga(Expression`1<Func`2<TSagaData, object>> sagaEntityProperty);
}
[ExtensionAttribute]
internal static class NServiceBus.TracingExtensions : object {
    [ExtensionAttribute]
public static Task Invoke(IPipeline`1<TContext> pipeline, TContext context, Activity activity);
}
internal class NServiceBus.TransactionScopeUnitOfWorkBehavior : object {
    private TransactionOptions transactionOptions;
    public TransactionScopeUnitOfWorkBehavior(TransactionOptions transactionOptions);
    [AsyncStateMachineAttribute("NServiceBus.TransactionScopeUnitOfWorkBehavior/<Invoke>d__1")]
public sealed virtual Task Invoke(IIncomingPhysicalMessageContext context, Func`2<IIncomingPhysicalMessageContext, Task> next);
}
public enum NServiceBus.Transport.DispatchConsistency : Enum {
    public int value__;
    public static DispatchConsistency Default;
    public static DispatchConsistency Isolated;
}
public class NServiceBus.Transport.DispatchProperties : Dictionary`2<string, string> {
    private static string DoNotDeliverBeforeKeyName;
    private static string DelayDeliveryWithKeyName;
    private static string DiscardIfNotReceivedBeforeKeyName;
    public DoNotDeliverBefore DoNotDeliverBefore { get; public set; }
    public DelayDeliveryWith DelayDeliveryWith { get; public set; }
    public DiscardIfNotReceivedBefore DiscardIfNotReceivedBefore { get; public set; }
    public DispatchProperties(Dictionary`2<string, string> properties);
    private static DispatchProperties();
    public DoNotDeliverBefore get_DoNotDeliverBefore();
    public void set_DoNotDeliverBefore(DoNotDeliverBefore value);
    public DelayDeliveryWith get_DelayDeliveryWith();
    public void set_DelayDeliveryWith(DelayDeliveryWith value);
    public DiscardIfNotReceivedBefore get_DiscardIfNotReceivedBefore();
    public void set_DiscardIfNotReceivedBefore(DiscardIfNotReceivedBefore value);
}
public class NServiceBus.Transport.ErrorContext : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportTransaction <TransportTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ImmediateProcessingFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DelayedDeliveriesPerformed>k__BackingField;
    [CompilerGeneratedAttribute]
private IncomingMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiveAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ContextBag <Extensions>k__BackingField;
    public Exception Exception { get; }
    public TransportTransaction TransportTransaction { get; }
    public int ImmediateProcessingFailures { get; }
    public int DelayedDeliveriesPerformed { get; }
    public IncomingMessage Message { get; }
    public string ReceiveAddress { get; }
    public ContextBag Extensions { get; }
    public ErrorContext(Exception exception, Dictionary`2<string, string> headers, string nativeMessageId, ReadOnlyMemory`1<byte> body, TransportTransaction transportTransaction, int immediateProcessingFailures, string receiveAddress, ContextBag context);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public TransportTransaction get_TransportTransaction();
    [CompilerGeneratedAttribute]
public int get_ImmediateProcessingFailures();
    [CompilerGeneratedAttribute]
public int get_DelayedDeliveriesPerformed();
    [CompilerGeneratedAttribute]
public IncomingMessage get_Message();
    [CompilerGeneratedAttribute]
public string get_ReceiveAddress();
    [CompilerGeneratedAttribute]
public ContextBag get_Extensions();
}
public enum NServiceBus.Transport.ErrorHandleResult : Enum {
    public int value__;
    public static ErrorHandleResult Handled;
    public static ErrorHandleResult RetryRequired;
}
public class NServiceBus.Transport.HostSettings : object {
    [CompilerGeneratedAttribute]
private IReadOnlySettings <CoreSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private StartupDiagnosticEntries <StartupDiagnostic>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<string, Exception, CancellationToken> <CriticalErrorAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetupInfrastructure>k__BackingField;
    public IReadOnlySettings CoreSettings { get; }
    public string Name { get; }
    public string HostDisplayName { get; }
    public StartupDiagnosticEntries StartupDiagnostic { get; }
    public Action`3<string, Exception, CancellationToken> CriticalErrorAction { get; }
    public bool SetupInfrastructure { get; }
    public HostSettings(string name, string hostDisplayName, StartupDiagnosticEntries startupDiagnostic, Action`3<string, Exception, CancellationToken> criticalErrorAction, bool setupInfrastructure, IReadOnlySettings coreSettings);
    [CompilerGeneratedAttribute]
public IReadOnlySettings get_CoreSettings();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_HostDisplayName();
    [CompilerGeneratedAttribute]
public StartupDiagnosticEntries get_StartupDiagnostic();
    [CompilerGeneratedAttribute]
public Action`3<string, Exception, CancellationToken> get_CriticalErrorAction();
    [CompilerGeneratedAttribute]
public bool get_SetupInfrastructure();
}
public interface NServiceBus.Transport.IMessageDispatcher {
    public abstract virtual Task Dispatch(TransportOperations outgoingMessages, TransportTransaction transaction, CancellationToken cancellationToken);
}
public interface NServiceBus.Transport.IMessageReceiver {
    public ISubscriptionManager Subscriptions { get; }
    public string Id { get; }
    public string ReceiveAddress { get; }
    public abstract virtual Task Initialize(PushRuntimeSettings limitations, OnMessage onMessage, OnError onError, CancellationToken cancellationToken);
    public abstract virtual Task StartReceive(CancellationToken cancellationToken);
    public abstract virtual Task ChangeConcurrency(PushRuntimeSettings limitations, CancellationToken cancellationToken);
    public abstract virtual Task StopReceive(CancellationToken cancellationToken);
    public abstract virtual ISubscriptionManager get_Subscriptions();
    public abstract virtual string get_Id();
    public abstract virtual string get_ReceiveAddress();
}
public class NServiceBus.Transport.IncomingMessage : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NativeMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    private Nullable`1<ReadOnlyMemory`1<byte>> originalBody;
    public string MessageId { get; }
    public string NativeMessageId { get; }
    public Dictionary`2<string, string> Headers { get; }
    public ReadOnlyMemory`1<byte> Body { get; private set; }
    public IncomingMessage(string nativeMessageId, Dictionary`2<string, string> headers, ReadOnlyMemory`1<byte> body);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public string get_NativeMessageId();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(ReadOnlyMemory`1<byte> value);
    internal void UpdateBody(ReadOnlyMemory`1<byte> updatedBody);
    internal void RevertToOriginalBodyIfNeeded();
}
[ExtensionAttribute]
public static class NServiceBus.Transport.IncomingMessageExtensions : object {
    [ExtensionAttribute]
public static MessageIntent GetMessageIntent(IncomingMessage message);
    [ExtensionAttribute]
public static string GetReplyToAddress(IncomingMessage message);
}
public interface NServiceBus.Transport.IOutgoingTransportOperation {
    public OutgoingMessage Message { get; }
    public DispatchProperties Properties { get; }
    public DispatchConsistency RequiredDispatchConsistency { get; }
    public abstract virtual OutgoingMessage get_Message();
    public abstract virtual DispatchProperties get_Properties();
    public abstract virtual DispatchConsistency get_RequiredDispatchConsistency();
}
public interface NServiceBus.Transport.ISubscriptionManager {
    public abstract virtual Task SubscribeAll(MessageMetadata[] eventTypes, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task Unsubscribe(MessageMetadata eventType, ContextBag context, CancellationToken cancellationToken);
}
public interface NServiceBus.Transport.ITransportAddressResolver {
    public abstract virtual string ToTransportAddress(QueueAddress queueAddress);
}
public class NServiceBus.Transport.MessageContext : object {
    [CompilerGeneratedAttribute]
private string <NativeMessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportTransaction <TransportTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceiveAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ContextBag <Extensions>k__BackingField;
    public string NativeMessageId { get; }
    public Dictionary`2<string, string> Headers { get; }
    public ReadOnlyMemory`1<byte> Body { get; }
    public TransportTransaction TransportTransaction { get; }
    public string ReceiveAddress { get; }
    public ContextBag Extensions { get; }
    public MessageContext(string nativeMessageId, Dictionary`2<string, string> headers, ReadOnlyMemory`1<byte> body, TransportTransaction transportTransaction, string receiveAddress, ContextBag context);
    [CompilerGeneratedAttribute]
public string get_NativeMessageId();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
public TransportTransaction get_TransportTransaction();
    [CompilerGeneratedAttribute]
public string get_ReceiveAddress();
    [CompilerGeneratedAttribute]
public sealed virtual ContextBag get_Extensions();
}
public class NServiceBus.Transport.MulticastTransportOperation : object {
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private OutgoingMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchConsistency <RequiredDispatchConsistency>k__BackingField;
    public Type MessageType { get; }
    public DispatchProperties Properties { get; }
    public OutgoingMessage Message { get; }
    public DispatchConsistency RequiredDispatchConsistency { get; }
    public MulticastTransportOperation(OutgoingMessage message, Type messageType, DispatchProperties properties, DispatchConsistency requiredDispatchConsistency);
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public sealed virtual DispatchProperties get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual OutgoingMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual DispatchConsistency get_RequiredDispatchConsistency();
}
public class NServiceBus.Transport.OnError : MulticastDelegate {
    public OnError(object object, IntPtr method);
    public virtual Task`1<ErrorHandleResult> Invoke(ErrorContext errorContext, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(ErrorContext errorContext, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task`1<ErrorHandleResult> EndInvoke(IAsyncResult result);
}
public class NServiceBus.Transport.OnMessage : MulticastDelegate {
    public OnMessage(object object, IntPtr method);
    public virtual Task Invoke(MessageContext messageContext, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(MessageContext messageContext, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public class NServiceBus.Transport.OutgoingMessage : object {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Headers>k__BackingField;
    public ReadOnlyMemory`1<byte> Body { get; private set; }
    public string MessageId { get; }
    public Dictionary`2<string, string> Headers { get; }
    public OutgoingMessage(string messageId, Dictionary`2<string, string> headers, ReadOnlyMemory`1<byte> body);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(ReadOnlyMemory`1<byte> value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Headers();
    public void UpdateBody(ReadOnlyMemory`1<byte> updatedBody);
}
public class NServiceBus.Transport.PushRuntimeSettings : object {
    [CompilerGeneratedAttribute]
private int <MaxConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private static PushRuntimeSettings <Default>k__BackingField;
    public int MaxConcurrency { get; }
    public static PushRuntimeSettings Default { get; }
    public PushRuntimeSettings(int maxConcurrency);
    private static PushRuntimeSettings();
    [CompilerGeneratedAttribute]
public int get_MaxConcurrency();
    [CompilerGeneratedAttribute]
public static PushRuntimeSettings get_Default();
}
public class NServiceBus.Transport.QueueAddress : object {
    private static IReadOnlyDictionary`2<string, string> EmptyProperties;
    [CompilerGeneratedAttribute]
private string <BaseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Discriminator>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Qualifier>k__BackingField;
    public string BaseAddress { get; }
    public string Discriminator { get; }
    public IReadOnlyDictionary`2<string, string> Properties { get; }
    public string Qualifier { get; }
    public QueueAddress(string baseAddress, string discriminator, IReadOnlyDictionary`2<string, string> properties, string qualifier);
    private static QueueAddress();
    [CompilerGeneratedAttribute]
public string get_BaseAddress();
    [CompilerGeneratedAttribute]
public string get_Discriminator();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public string get_Qualifier();
    public virtual string ToString();
}
public class NServiceBus.Transport.QueueBindings : object {
    private List`1<string> sendingAddresses;
    public IReadOnlyCollection`1<string> SendingAddresses { get; }
    public IReadOnlyCollection`1<string> get_SendingAddresses();
    public void BindSending(string transportAddress);
}
public class NServiceBus.Transport.ReceiveSettings : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueAddress <ReceiveAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePublishSubscribe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PurgeOnStartup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorQueue>k__BackingField;
    public string Id { get; public set; }
    public QueueAddress ReceiveAddress { get; }
    public bool UsePublishSubscribe { get; public set; }
    public bool PurgeOnStartup { get; public set; }
    public string ErrorQueue { get; }
    public ReceiveSettings(string id, QueueAddress receiveAddress, bool usePublishSubscribe, bool purgeOnStartup, string errorQueue);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public QueueAddress get_ReceiveAddress();
    [CompilerGeneratedAttribute]
public bool get_UsePublishSubscribe();
    [CompilerGeneratedAttribute]
public void set_UsePublishSubscribe(bool value);
    [CompilerGeneratedAttribute]
public bool get_PurgeOnStartup();
    [CompilerGeneratedAttribute]
public void set_PurgeOnStartup(bool value);
    [CompilerGeneratedAttribute]
public string get_ErrorQueue();
}
public abstract class NServiceBus.Transport.TransportDefinition : object {
    private TransportTransactionMode transportTransactionMode;
    [CompilerGeneratedAttribute]
private bool <SupportsDelayedDelivery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsPublishSubscribe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsTTBR>k__BackingField;
    public TransportTransactionMode TransportTransactionMode { get; public set; }
    public bool SupportsDelayedDelivery { get; }
    public bool SupportsPublishSubscribe { get; }
    public bool SupportsTTBR { get; }
    protected TransportDefinition(TransportTransactionMode defaultTransactionMode, bool supportsDelayedDelivery, bool supportsPublishSubscribe, bool supportsTTBR);
    [ObsoleteAttribute("Inject the ITransportAddressResolver type to access the address translation mechanism at runtime. See the NServiceBus version 8 upgrade guide for further details. The member currently throws a NotImplementedException. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public virtual string ToTransportAddress(QueueAddress address);
    public abstract virtual Task`1<TransportInfrastructure> Initialize(HostSettings hostSettings, ReceiveSettings[] receivers, String[] sendingAddresses, CancellationToken cancellationToken);
    public abstract virtual IReadOnlyCollection`1<TransportTransactionMode> GetSupportedTransactionModes();
    public virtual TransportTransactionMode get_TransportTransactionMode();
    public virtual void set_TransportTransactionMode(TransportTransactionMode value);
    [CompilerGeneratedAttribute]
public bool get_SupportsDelayedDelivery();
    [CompilerGeneratedAttribute]
public bool get_SupportsPublishSubscribe();
    [CompilerGeneratedAttribute]
public bool get_SupportsTTBR();
}
public abstract class NServiceBus.Transport.TransportInfrastructure : object {
    [CompilerGeneratedAttribute]
private IMessageDispatcher <Dispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IMessageReceiver> <Receivers>k__BackingField;
    public IMessageDispatcher Dispatcher { get; protected set; }
    public IReadOnlyDictionary`2<string, IMessageReceiver> Receivers { get; protected set; }
    [CompilerGeneratedAttribute]
public IMessageDispatcher get_Dispatcher();
    [CompilerGeneratedAttribute]
protected void set_Dispatcher(IMessageDispatcher value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IMessageReceiver> get_Receivers();
    [CompilerGeneratedAttribute]
protected void set_Receivers(IReadOnlyDictionary`2<string, IMessageReceiver> value);
    public abstract virtual Task Shutdown(CancellationToken cancellationToken);
    public abstract virtual string ToTransportAddress(QueueAddress address);
}
public class NServiceBus.Transport.TransportOperation : object {
    [CompilerGeneratedAttribute]
private OutgoingMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private AddressTag <AddressTag>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchConsistency <RequiredDispatchConsistency>k__BackingField;
    public OutgoingMessage Message { get; }
    public AddressTag AddressTag { get; }
    public DispatchProperties Properties { get; }
    public DispatchConsistency RequiredDispatchConsistency { get; public set; }
    public TransportOperation(OutgoingMessage message, AddressTag addressTag, DispatchProperties properties, DispatchConsistency requiredDispatchConsistency);
    [CompilerGeneratedAttribute]
public OutgoingMessage get_Message();
    [CompilerGeneratedAttribute]
public AddressTag get_AddressTag();
    [CompilerGeneratedAttribute]
public DispatchProperties get_Properties();
    [CompilerGeneratedAttribute]
public DispatchConsistency get_RequiredDispatchConsistency();
    [CompilerGeneratedAttribute]
public void set_RequiredDispatchConsistency(DispatchConsistency value);
}
public class NServiceBus.Transport.TransportOperations : object {
    [CompilerGeneratedAttribute]
private List`1<MulticastTransportOperation> <MulticastTransportOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<UnicastTransportOperation> <UnicastTransportOperations>k__BackingField;
    public List`1<MulticastTransportOperation> MulticastTransportOperations { get; }
    public List`1<UnicastTransportOperation> UnicastTransportOperations { get; }
    public TransportOperations(TransportOperation[] transportOperations);
    [CompilerGeneratedAttribute]
public List`1<MulticastTransportOperation> get_MulticastTransportOperations();
    [CompilerGeneratedAttribute]
public List`1<UnicastTransportOperation> get_UnicastTransportOperations();
}
public class NServiceBus.Transport.TransportTransaction : ContextBag {
}
public class NServiceBus.Transport.UnicastTransportOperation : object {
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private OutgoingMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private DispatchConsistency <RequiredDispatchConsistency>k__BackingField;
    public string Destination { get; }
    public OutgoingMessage Message { get; }
    public DispatchProperties Properties { get; }
    public DispatchConsistency RequiredDispatchConsistency { get; }
    public UnicastTransportOperation(OutgoingMessage message, string destination, DispatchProperties properties, DispatchConsistency requiredDispatchConsistency);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public sealed virtual OutgoingMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual DispatchProperties get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual DispatchConsistency get_RequiredDispatchConsistency();
}
internal class NServiceBus.TransportAddressResolver : object {
    private TransportSeam transportSeam;
    private IServiceProvider serviceProvider;
    public TransportAddressResolver(TransportSeam transportSeam, IServiceProvider serviceProvider);
    public sealed virtual string ToTransportAddress(QueueAddress queueAddress);
}
[PreObsoleteAttribute("https://github.com/Particular/NServiceBus/issues/6811")]
public class NServiceBus.TransportExtensions`1 : object {
    [CompilerGeneratedAttribute]
private T <Transport>k__BackingField;
    private RoutingSettings`1<T> routing;
    public T Transport { get; }
    public TransportExtensions`1(T transport, RoutingSettings`1<T> routing);
    [CompilerGeneratedAttribute]
public T get_Transport();
    [PreObsoleteAttribute("https://github.com/Particular/NServiceBus/issues/6811")]
public RoutingSettings`1<T> Routing();
    [PreObsoleteAttribute("https://github.com/Particular/NServiceBus/issues/6811")]
public TransportExtensions`1<T> Transactions(TransportTransactionMode transportTransactionMode);
}
internal class NServiceBus.TransportReceiveContext : PipelineRootContext {
    [CompilerGeneratedAttribute]
private IncomingMessage <Message>k__BackingField;
    public IncomingMessage Message { get; }
    public TransportReceiveContext(IServiceProvider serviceProvider, MessageOperations messageOperations, IPipelineCache pipelineCache, IncomingMessage receivedMessage, TransportTransaction transportTransaction, ContextBag parentContext, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual IncomingMessage get_Message();
}
internal class NServiceBus.TransportReceiveToPhysicalMessageConnector : object {
    private IOutboxStorage outboxStorage;
    private IncomingPipelineMetrics incomingPipelineMetrics;
    public TransportReceiveToPhysicalMessageConnector(IOutboxStorage outboxStorage, IncomingPipelineMetrics incomingPipelineMetrics);
    [AsyncStateMachineAttribute("NServiceBus.TransportReceiveToPhysicalMessageConnector/<Invoke>d__1")]
public sealed virtual Task Invoke(ITransportReceiveContext context, Func`2<IIncomingPhysicalMessageContext, Task> next);
    private static void ConvertToPendingOperations(OutboxMessage deduplicationEntry, PendingTransportOperations pendingTransportOperations);
    private static TransportOperation[] ConvertToOutboxOperations(TransportOperation[] operations);
    private static void SerializeRoutingStrategy(AddressTag addressTag, Dictionary`2<string, string> options);
    private static AddressTag DeserializeRoutingStrategy(Dictionary`2<string, string> options);
}
internal class NServiceBus.TransportSeam : object {
    private HostSettings hostSettings;
    private ReceiveSettings[] receivers;
    [CompilerGeneratedAttribute]
private TransportInfrastructure <TransportInfrastructure>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportDefinition <TransportDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private QueueBindings <QueueBindings>k__BackingField;
    private TransportInfrastructure TransportInfrastructure { get; private set; }
    public TransportDefinition TransportDefinition { get; }
    public QueueBindings QueueBindings { get; }
    protected TransportSeam(TransportDefinition transportDefinition, HostSettings hostSettings, QueueBindings queueBindings);
    public void Configure(ReceiveSettings[] receivers);
    public TransportInfrastructure GetTransportInfrastructure(IServiceProvider _);
    public ITransportAddressResolver TransportAddressResolverBuilder(IServiceProvider sp);
    [AsyncStateMachineAttribute("NServiceBus.TransportSeam/<CreateTransportInfrastructure>d__6")]
public Task`1<TransportInfrastructure> CreateTransportInfrastructure(CancellationToken cancellationToken);
    public static TransportSeam Create(Settings transportSeamSettings, Configuration hostingConfiguration);
    [CompilerGeneratedAttribute]
private TransportInfrastructure get_TransportInfrastructure();
    [CompilerGeneratedAttribute]
private void set_TransportInfrastructure(TransportInfrastructure value);
    [CompilerGeneratedAttribute]
public TransportDefinition get_TransportDefinition();
    [CompilerGeneratedAttribute]
public QueueBindings get_QueueBindings();
}
public enum NServiceBus.TransportTransactionMode : Enum {
    public int value__;
    public static TransportTransactionMode None;
    public static TransportTransactionMode ReceiveOnly;
    public static TransportTransactionMode SendsAtomicWithReceive;
    public static TransportTransactionMode TransactionScope;
}
[ExtensionAttribute]
internal static class NServiceBus.TypeExtensionMethods : object {
    private static Byte[] MsPublicKeyToken;
    private static ConcurrentDictionary`2<RuntimeTypeHandle, bool> IsSystemTypeCache;
    private static ConcurrentDictionary`2<RuntimeTypeHandle, string> TypeToNameLookup;
    private static Byte[] nsbPublicKeyToken;
    private static TypeExtensionMethods();
    [ExtensionAttribute]
public static T Construct(Type type);
    [ExtensionAttribute]
public static bool IsSimpleType(Type type);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static string SerializationFriendlyName(Type t);
    private static bool IsClrType(Byte[] a1);
    [ExtensionAttribute]
public static bool IsSystemType(Type type);
    [ExtensionAttribute]
public static bool IsFromParticularAssembly(Type type);
}
internal class NServiceBus.TypePublisherSource : object {
    private Type messageType;
    private PublisherAddress address;
    public RouteSourcePriority Priority { get; }
    public TypePublisherSource(Type messageType, PublisherAddress address);
    [IteratorStateMachineAttribute("NServiceBus.TypePublisherSource/<GenerateWithBestPracticeEnforcement>d__3")]
public sealed virtual IEnumerable`1<PublisherTableEntry> GenerateWithBestPracticeEnforcement(Conventions conventions);
    [IteratorStateMachineAttribute("NServiceBus.TypePublisherSource/<GenerateWithoutBestPracticeEnforcement>d__4")]
public sealed virtual IEnumerable`1<PublisherTableEntry> GenerateWithoutBestPracticeEnforcement(Conventions conventions);
    public sealed virtual RouteSourcePriority get_Priority();
}
internal class NServiceBus.TypeRouteSource : object {
    private Type messageType;
    private UnicastRoute route;
    public RouteSourcePriority Priority { get; }
    public TypeRouteSource(Type messageType, UnicastRoute route);
    [IteratorStateMachineAttribute("NServiceBus.TypeRouteSource/<GenerateRoutes>d__3")]
public sealed virtual IEnumerable`1<RouteTableEntry> GenerateRoutes(Conventions conventions);
    public sealed virtual RouteSourcePriority get_Priority();
}
public class NServiceBus.Unicast.MessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    public object Message { get; }
    public MessageEventArgs(object msg);
    [CompilerGeneratedAttribute]
public object get_Message();
}
public class NServiceBus.Unicast.MessageHandlerRegistry : object {
    private Dictionary`2<Type, List`1<DelegateHolder>> handlerAndMessagesHandledByHandlerCache;
    private static ILog Log;
    private static MessageHandlerRegistry();
    public List`1<MessageHandler> GetHandlersFor(Type messageType);
    public IEnumerable`1<Type> GetMessageTypes();
    public void RegisterHandler(Type handlerType);
    public void Clear();
    private static void CacheHandlerMethods(Type handler, Type messageType, ICollection`1<DelegateHolder> typeList);
    private static void CacheMethod(Type handler, Type messageType, Type interfaceGenericType, ICollection`1<DelegateHolder> methodList, bool isTimeoutHandler);
    private static Func`4<object, object, IMessageHandlerContext, Task> GetMethod(Type targetType, Type messageType, Type interfaceGenericType);
    private static Type[] GetMessageTypesBeingHandledBy(Type type);
    private static void ValidateHandlerType(Type handlerType);
}
public class NServiceBus.Unicast.Messages.MessageMetadata : object {
    [CompilerGeneratedAttribute]
private Type <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <MessageHierarchy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageHierarchySerialized>k__BackingField;
    public Type MessageType { get; }
    public Type[] MessageHierarchy { get; }
    public string MessageHierarchySerialized { get; }
    public MessageMetadata(Type messageType);
    public MessageMetadata(Type messageType, Type[] messageHierarchy);
    [CompilerGeneratedAttribute]
public Type get_MessageType();
    [CompilerGeneratedAttribute]
public Type[] get_MessageHierarchy();
    [CompilerGeneratedAttribute]
public string get_MessageHierarchySerialized();
    private static string SerializeMessageHierarchy(Type[] messageHierarchy);
}
public class NServiceBus.Unicast.Messages.MessageMetadataRegistry : object {
    private Func`2<Type, bool> isMessageType;
    private bool allowDynamicTypeLoading;
    private ConcurrentDictionary`2<RuntimeTypeHandle, MessageMetadata> messages;
    private ConcurrentDictionary`2<string, Type> cachedTypes;
    private static Type IHandleMessagesType;
    private static ILog Logger;
    public MessageMetadataRegistry(Func`2<Type, bool> isMessageType, bool allowDynamicTypeLoading);
    private static MessageMetadataRegistry();
    public MessageMetadata GetMessageMetadata(Type messageType);
    public MessageMetadata GetMessageMetadata(string messageTypeIdentifier);
    public MessageMetadata[] GetAllMessages();
    private Type GetType(string messageTypeIdentifier);
    internal void RegisterMessageTypesFoundIn(IList`1<Type> availableTypes);
    [IteratorStateMachineAttribute("NServiceBus.Unicast.Messages.MessageMetadataRegistry/<GetHandledMessageTypes>d__6")]
private static IEnumerable`1<Type> GetHandledMessageTypes(Type messageHandlerType);
    private MessageMetadata RegisterMessageType(Type messageType);
    private static int PlaceInMessageHierarchy(Type type);
    [IteratorStateMachineAttribute("NServiceBus.Unicast.Messages.MessageMetadataRegistry/<GetParentTypes>d__9")]
private static IEnumerable`1<Type> GetParentTypes(Type type);
    [CompilerGeneratedAttribute]
private bool <RegisterMessageType>b__7_0(Type t);
}
public class NServiceBus.Unicast.MessagesEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Object[] <Messages>k__BackingField;
    public Object[] Messages { get; }
    public MessagesEventArgs(Object[] messages);
    [CompilerGeneratedAttribute]
public Object[] get_Messages();
}
public class NServiceBus.Unicast.Queuing.QueueNotFoundException : Exception {
    [CompilerGeneratedAttribute]
private string <Queue>k__BackingField;
    public string Queue { get; public set; }
    public QueueNotFoundException(string queue, string message, Exception inner);
    [CompilerGeneratedAttribute]
public string get_Queue();
    [CompilerGeneratedAttribute]
public void set_Queue(string value);
}
public interface NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.ISubscriptionStorage {
    public abstract virtual Task Subscribe(Subscriber subscriber, MessageType messageType, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task Unsubscribe(Subscriber subscriber, MessageType messageType, ContextBag context, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<Subscriber>> GetSubscriberAddressesForMessage(IEnumerable`1<MessageType> messageTypes, ContextBag context, CancellationToken cancellationToken);
}
public class NServiceBus.Unicast.Subscriptions.MessageDrivenSubscriptions.Subscriber : object {
    [CompilerGeneratedAttribute]
private string <TransportAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Endpoint>k__BackingField;
    public string TransportAddress { get; }
    public string Endpoint { get; }
    public Subscriber(string transportAddress, string endpoint);
    [CompilerGeneratedAttribute]
public string get_TransportAddress();
    [CompilerGeneratedAttribute]
public string get_Endpoint();
}
public class NServiceBus.Unicast.Subscriptions.MessageType : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string TypeName { get; }
    public Version Version { get; }
    public MessageType(Type type);
    public MessageType(string messageTypeString);
    public MessageType(string typeName, string versionString);
    public MessageType(string typeName, Version version);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public Version get_Version();
    private static Version ParseVersion(string versionString);
    public virtual string ToString();
    public bool Equals(MessageType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MessageType left, MessageType right);
    public static bool op_Inequality(MessageType left, MessageType right);
}
public static class NServiceBus.Unicast.Transport.ControlMessageFactory : object {
    public static OutgoingMessage Create(MessageIntent intent);
}
internal class NServiceBus.UnicastPublishConnector : StageConnector`2<IOutgoingPublishContext, IOutgoingLogicalMessageContext> {
    private DistributionPolicy distributionPolicy;
    private IUnicastPublishRouter unicastPublishRouter;
    public UnicastPublishConnector(IUnicastPublishRouter unicastPublishRouter, DistributionPolicy distributionPolicy);
    [AsyncStateMachineAttribute("NServiceBus.UnicastPublishConnector/<Invoke>d__1")]
public virtual Task Invoke(IOutgoingPublishContext context, Func`2<IOutgoingLogicalMessageContext, Task> stage);
    [AsyncStateMachineAttribute("NServiceBus.UnicastPublishConnector/<GetRoutingStrategies>d__2")]
private Task`1<List`1<UnicastRoutingStrategy>> GetRoutingStrategies(IOutgoingPublishContext context, Type eventType);
}
internal class NServiceBus.UnicastPublishRouter : object {
    private MessageMetadataRegistry messageMetadataRegistry;
    private ITransportAddressResolver transportAddressTranslation;
    private ISubscriptionStorage subscriptionStorage;
    private static ILog logger;
    public UnicastPublishRouter(MessageMetadataRegistry messageMetadataRegistry, ITransportAddressResolver transportAddressTranslation, ISubscriptionStorage subscriptionStorage);
    private static UnicastPublishRouter();
    [AsyncStateMachineAttribute("NServiceBus.UnicastPublishRouter/<Route>d__1")]
public sealed virtual Task`1<IEnumerable`1<UnicastRoutingStrategy>> Route(Type messageType, IDistributionPolicy distributionPolicy, IOutgoingPublishContext publishContext);
    private static void WarnIfNoSubscribersFound(Type messageType, int subscribersFound);
    private ValueCollection<string, UnicastRoutingStrategy> SelectDestinationsForEachEndpoint(IOutgoingPublishContext publishContext, IDistributionPolicy distributionPolicy, IEnumerable`1<Subscriber> subscribers);
    private Task`1<IEnumerable`1<Subscriber>> GetSubscribers(IExtendable publishContext, Type[] typesToRoute, CancellationToken cancellationToken);
}
internal class NServiceBus.UnicastSendRouter : object {
    private EndpointInstance instanceSpecificQueue;
    private EndpointInstances endpointInstances;
    private ITransportAddressResolver transportAddressResolver;
    private UnicastRoutingTable unicastRoutingTable;
    private IDistributionPolicy defaultDistributionPolicy;
    private bool isSendOnly;
    private string receiveQueueName;
    public UnicastSendRouter(bool isSendOnly, string receiveQueueName, QueueAddress instanceSpecificQueue, IDistributionPolicy defaultDistributionPolicy, UnicastRoutingTable unicastRoutingTable, EndpointInstances endpointInstances, ITransportAddressResolver transportAddressResolver);
    public virtual UnicastRoutingStrategy Route(IOutgoingSendContext context);
    private UnicastRoute SelectRoute(State state, IOutgoingSendContext context);
    private UnicastRoute RouteToThisInstance();
    private UnicastRoute RouteToAnyInstance();
    private UnicastRoute RouteToSpecificInstance(IOutgoingSendContext context, string specificInstance);
    private UnicastRoute RouteUsingTable(IOutgoingSendContext context);
    private UnicastRoutingStrategy ResolveRoute(UnicastRoute route, IOutgoingSendContext context);
    private string TranslateTransportAddress(EndpointInstance instance);
    [CompilerGeneratedAttribute]
private string <ResolveRoute>b__8_0(EndpointInstance e);
}
[ObsoleteAttribute("The unit of work pattern is more straightforward to implement in a pipeline behavior, where the using keyword and try/catch blocks can be used. Use `NServiceBus.Pipeline.Behavior<TContext>` instead. Will be removed in version 10.0.0.", "True")]
[EditorBrowsableAttribute("1")]
public interface NServiceBus.UnitOfWork.IManageUnitsOfWork {
    public abstract virtual Task Begin();
    public abstract virtual Task End(Exception ex);
}
public class NServiceBus.UnitOfWorkSettings : object {
    private EndpointConfiguration config;
    internal UnitOfWorkSettings(EndpointConfiguration config);
    public UnitOfWorkSettings WrapHandlersInATransactionScope(Nullable`1<TimeSpan> timeout, Nullable`1<IsolationLevel> isolationLevel);
}
[ExtensionAttribute]
public static class NServiceBus.UnitOfWorkSettingsExtensions : object {
    [ExtensionAttribute]
public static UnitOfWorkSettings UnitOfWork(EndpointConfiguration config);
}
internal class NServiceBus.UnsubscribeContext : BehaviorContext {
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    public Type EventType { get; }
    public UnsubscribeContext(IBehaviorContext parentContext, Type eventType, ContextBag extensions);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventType();
}
internal class NServiceBus.UnsubscribeDiagnosticsBehavior : object {
    public sealed virtual Task Invoke(IUnsubscribeContext context, Func`2<IUnsubscribeContext, Task> next);
}
public class NServiceBus.UnsubscribeOptions : ExtendableOptions {
}
internal class NServiceBus.UpdateAction : StorageAction {
    public UpdateAction(IContainSagaData sagaData, Dictionary`2<string, SagaStorageFile> sagaFiles, SagaManifestCollection sagaManifests);
    public virtual Task Execute(CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class NServiceBus.UseDataBusExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public static DataBusExtensions`1<TDataBusDefinition> UseDataBus(EndpointConfiguration config);
    [ExtensionAttribute]
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public static DataBusExtensions`1<TDataBusDefinition> UseDataBus(EndpointConfiguration config, IDataBusSerializer dataBusSerializer);
    [ExtensionAttribute]
[ObsoleteAttribute("The DataBus feature has been released as a dedicated package, 'NServiceBus.ClaimCheck'. Will be treated as an error from version 10.0.0. Will be removed in version 11.0.0.", "False")]
[EditorBrowsableAttribute("1")]
public static DataBusExtensions UseDataBus(EndpointConfiguration config, Func`2<IServiceProvider, IDataBus> dataBusFactory, IDataBusSerializer dataBusSerializer);
    private static void EnableDataBus(EndpointConfiguration config, DataBusDefinition selectedDataBus, IDataBusSerializer dataBusSerializer);
}
internal class NServiceBus.UserDefinedTimeToBeReceivedConvention : object {
    [CompilerGeneratedAttribute]
private Func`2<Type, TimeSpan> <GetTimeToBeReceivedForMessage>k__BackingField;
    public Func`2<Type, TimeSpan> GetTimeToBeReceivedForMessage { get; }
    public UserDefinedTimeToBeReceivedConvention(Func`2<Type, TimeSpan> retrieveTimeToBeReceived);
    [CompilerGeneratedAttribute]
public Func`2<Type, TimeSpan> get_GetTimeToBeReceivedForMessage();
}
internal class NServiceBus.Validations : object {
    private Conventions conventions;
    private static ILog Log;
    public Validations(Conventions conventions);
    private static Validations();
    public void AssertIsValidForSend(Type messageType);
    public void AssertIsValidForReply(Type messageType);
    public void AssertIsValidForPubSub(Type messageType);
}
internal static class NServiceBus.VersionInformation : object {
    [CompilerGeneratedAttribute]
private static string <MajorMinorPatch>k__BackingField;
    public static string MajorMinorPatch { get; }
    private static VersionInformation();
    [CompilerGeneratedAttribute]
public static string get_MajorMinorPatch();
}
internal class NServiceBus.WrappedMessageReceiver : object {
    private static ILog Logger;
    private static PushRuntimeSettings RateLimitedRuntimeSettings;
    private IMessageReceiver baseReceiver;
    private ConsecutiveFailuresConfiguration consecutiveFailuresConfiguration;
    private ConsecutiveFailuresCircuitBreaker consecutiveFailuresCircuitBreaker;
    private TaskCompletionSource`1<bool> resetEventReplacement;
    private Task rateLimitTask;
    private CancellationTokenSource rateLimitLoopCancellationToken;
    private OnMessage wrappedOnMessage;
    private OnError wrappedOnError;
    private PushRuntimeSettings originalLimitations;
    private bool endpointShouldBeRateLimited;
    private long lastStateChangeTime;
    public ISubscriptionManager Subscriptions { get; }
    public string Id { get; }
    public string ReceiveAddress { get; }
    public WrappedMessageReceiver(ConsecutiveFailuresConfiguration consecutiveFailuresConfiguration, IMessageReceiver baseReceiver);
    private static WrappedMessageReceiver();
    [AsyncStateMachineAttribute("NServiceBus.WrappedMessageReceiver/<WrappedInvoke>d__1")]
public Task WrappedInvoke(MessageContext messageContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.WrappedMessageReceiver/<WrappedOnError>d__2")]
public Task`1<ErrorHandleResult> WrappedOnError(ErrorContext errorContext, CancellationToken cancellationToken);
    public sealed virtual ISubscriptionManager get_Subscriptions();
    public sealed virtual string get_Id();
    public sealed virtual string get_ReceiveAddress();
    public sealed virtual Task ChangeConcurrency(PushRuntimeSettings limitations, CancellationToken cancellationToken);
    public sealed virtual Task StartReceive(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.WrappedMessageReceiver/<StopReceive>d__11")]
public sealed virtual Task StopReceive(CancellationToken cancellationToken);
    public sealed virtual Task Initialize(PushRuntimeSettings limitations, OnMessage onMessage, OnError onError, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.WrappedMessageReceiver/<RateLimitLoop>d__13")]
private Task RateLimitLoop(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.WrappedMessageReceiver/<StartRateLimiting>d__14")]
private Task StartRateLimiting(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NServiceBus.WrappedMessageReceiver/<StopRateLimiting>d__15")]
private Task StopRateLimiting(CancellationToken cancellationToken);
    private void SwitchBackToNormalMode(long stateChangeTime);
    private void SwitchToRateLimitMode(long stateChangeTime);
    [CompilerGeneratedAttribute]
private Task <Initialize>b__12_0(long ticks, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private Task <Initialize>b__12_1(long ticks, CancellationToken cancellationToken);
}
internal class NServiceBus.XmlDeserialization : object {
    private XmlSerializerCache cache;
    private string defaultNamespace;
    private IMessageMapper mapper;
    private List`1<Type> messageBaseTypes;
    private IDictionary`2<string, string> prefixesToNamespaces;
    private bool sanitizeInput;
    private bool skipWrappingRawXml;
    private static string BASETYPE;
    private static ILog logger;
    public XmlDeserialization(IMessageMapper mapper, XmlSerializerCache cache, bool skipWrappingRawXml, bool sanitizeInput);
    private static XmlDeserialization();
    public Object[] Deserialize(Stream stream, IList`1<Type> messageTypesToDeserialize);
    private static bool NothingToBeProcessed(XmlDocument doc);
    private static XmlDocument ReadStreamIntoDocument(Stream stream, bool sanitizeInput);
    private void ProcessRootTypes(IEnumerable`1<Type> rootTypes, XmlDocument doc, List`1<object> result);
    private static bool ContainsAnyMessageTypesToDeserialize(IList`1<Type> messageTypesToDeserialize);
    private void ProcessChildNodes(IList`1<Type> messageTypesToDeserialize, XmlDocument doc, List`1<object> result);
    private static Type ExtractNodeTypeAtPosition(IList`1<Type> messageTypesToDeserialize, int position);
    private void CacheDefaultNamespaceMessageBaseTypesAndPrefixes(XmlDocument doc);
    private static bool ContainsMultipleMessages(XmlDocument doc);
    [IteratorStateMachineAttribute("NServiceBus.XmlDeserialization/<FindRootTypes>d__10")]
private static IEnumerable`1<Type> FindRootTypes(IEnumerable`1<Type> messageTypesToDeserialize);
    private object Process(XmlNode node, object parent, Type nodeType);
    private Type InferNodeType(XmlNode node, object parent);
    private object GetObjectOfTypeFromNode(Type t, XmlNode node);
    private static FieldInfo GetField(FieldInfo[] fields, string name);
    private object GetPropertyValue(Type type, XmlNode n);
    private static PropertyInfo GetProperty(PropertyInfo[] properties, string name);
    private static string GetNameAfterColon(string name);
}
internal class NServiceBus.XmlMessageSerializer : object {
    [CompilerGeneratedAttribute]
private bool <SanitizeInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWrappingRawXml>k__BackingField;
    private XmlSerializerCache cache;
    private Conventions conventions;
    private IMessageMapper mapper;
    private string nameSpace;
    public string Namespace { get; public set; }
    public bool SanitizeInput { get; public set; }
    public bool SkipWrappingRawXml { get; public set; }
    public string ContentType { get; }
    public XmlMessageSerializer(IMessageMapper mapper, Conventions conventions);
    public string get_Namespace();
    public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public bool get_SanitizeInput();
    [CompilerGeneratedAttribute]
public void set_SanitizeInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipWrappingRawXml();
    [CompilerGeneratedAttribute]
public void set_SkipWrappingRawXml(bool value);
    public sealed virtual Object[] Deserialize(ReadOnlyMemory`1<byte> body, IList`1<Type> messageTypesToDeserialize);
    public sealed virtual string get_ContentType();
    public sealed virtual void Serialize(object message, Stream stream);
    public void InitType(Type t);
    public void Initialize(IEnumerable`1<Type> types);
    private static string TrimPotentialTrailingForwardSlashes(string value);
}
internal class NServiceBus.XmlSanitizingStream : StreamReader {
    private static int EOF;
    public XmlSanitizingStream(Stream streamToSanitize);
    public static bool IsLegalXmlChar(string xmlVersion, int character);
    public static bool IsLegalXmlChar(int character);
    public virtual int Read();
    public virtual int Peek();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    public virtual string ReadToEnd();
}
internal class NServiceBus.XmlSerialization : object {
    private XmlSerializerCache cache;
    private Conventions conventions;
    private object message;
    private Type messageType;
    private string namespace;
    private bool skipWrappingRawXml;
    private RawXmlTextWriter writer;
    private static string BaseType;
    private static string DefaultNamespace;
    private static XNamespace xsiNamespace;
    private static XNamespace xsdNamespace;
    private int disposeSignaled;
    private bool disposed;
    public XmlSerialization(Type messageType, Stream stream, object message, Conventions conventions, XmlSerializerCache cache, bool skipWrappingRawXml, string namespace);
    private static XmlSerialization();
    public sealed virtual void Dispose();
    public void Serialize();
    private static void ForceEmptyTagsWithNewlines(XDocument document);
    private static void SetDefaultNamespace(XElement element, XNamespace newXmlns);
    private List`1<string> GetBaseTypes();
    private void WriteObject(XElement elem, string name, Type type, object value, bool useNS);
    private void Write(XElement elem, Type t, object obj);
    private void WriteEntry(XElement elem, string name, Type type, object value);
    private static bool IsIndexedProperty(PropertyInfo propertyInfo);
    private static void WriteElementNamespaces(XElement elem, IReadOnlyList`1<string> baseTypes);
    private void ThrowIfDisposed();
}
[ExtensionAttribute]
public static class NServiceBus.XmlSerializationExtensions : object {
    [ExtensionAttribute]
public static SerializationExtensions`1<XmlSerializer> DontWrapRawXml(SerializationExtensions`1<XmlSerializer> config);
    [ExtensionAttribute]
public static SerializationExtensions`1<XmlSerializer> Namespace(SerializationExtensions`1<XmlSerializer> config, string namespaceToUse);
    [ExtensionAttribute]
public static SerializationExtensions`1<XmlSerializer> SanitizeInput(SerializationExtensions`1<XmlSerializer> config);
}
public class NServiceBus.XmlSerializer : SerializationDefinition {
    internal static string CustomNamespaceConfigurationKey;
    internal static string SkipWrappingRawXml;
    internal static string SanitizeInput;
    public virtual Func`2<IMessageMapper, IMessageSerializer> Configure(IReadOnlySettings settings);
}
internal class NServiceBus.XmlSerializerCache : object {
    private object lockObject;
    private ConcurrentBag`1<Type> typesBeingInitialized;
    public ConcurrentDictionary`2<Type, Type> typesToCreateForArrays;
    public ConcurrentDictionary`2<Type, Type> typesToCreateForEnumerables;
    public ConcurrentDictionary`2<Type, Tuple`2<FieldInfo[], PropertyInfo[]>> typeMembers;
    private static ILog logger;
    private static XmlSerializerCache();
    public void InitType(Type t);
    private void InitTypeInternal(Type t);
    private static PropertyInfo[] GetAllPropertiesForType(Type t, bool isKeyValuePair);
    private static FieldInfo[] GetAllFieldsForType(Type t);
}
internal class NServiceBusCore_ProcessedByFody : object {
    internal static string FodyVersion;
    internal static string Janitor;
    internal static string Obsolete;
}
internal class Particular.Licensing.ActiveLicense : object {
    public static ActiveLicenseFindResult Find(string applicationName, LicenseSource[] licenseSources);
}
internal class Particular.Licensing.ActiveLicenseFindResult : object {
    [CompilerGeneratedAttribute]
private License <License>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    internal List`1<string> Report;
    internal List`1<string> SelectedLicenseReport;
    internal License License { get; internal set; }
    internal string Location { get; internal set; }
    [CompilerGeneratedAttribute]
internal License get_License();
    [CompilerGeneratedAttribute]
internal void set_License(License value);
    [CompilerGeneratedAttribute]
internal string get_Location();
    [CompilerGeneratedAttribute]
internal void set_Location(string value);
}
internal static class Particular.Licensing.FilePathLicenseStore : object {
    public static void StoreLicense(string filePath, string license);
}
internal class Particular.Licensing.License : object {
    [CompilerGeneratedAttribute]
private string <LicenseId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpirationDate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedTrial>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Edition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegisteredTo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <UpgradeProtectionExpiration>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ValidApplications>k__BackingField;
    internal Func`1<DateTime> releaseDateProvider;
    internal Func`1<DateTime> utcDateTimeProvider;
    private static int ExpirationWarningThresholdDays;
    private static int TrialExpirationWarningThresholdDays;
    public string LicenseId { get; public set; }
    public Nullable`1<DateTime> ExpirationDate { get; public set; }
    public bool IsTrialLicense { get; }
    public bool IsExtendedTrial { get; public set; }
    public bool IsCommercialLicense { get; }
    public string LicenseType { get; public set; }
    public string Edition { get; public set; }
    public string RegisteredTo { get; public set; }
    public Nullable`1<DateTime> UpgradeProtectionExpiration { get; internal set; }
    public List`1<string> ValidApplications { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_LicenseId();
    [CompilerGeneratedAttribute]
public void set_LicenseId(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpirationDate();
    [CompilerGeneratedAttribute]
public void set_ExpirationDate(Nullable`1<DateTime> value);
    public bool get_IsTrialLicense();
    [CompilerGeneratedAttribute]
public bool get_IsExtendedTrial();
    [CompilerGeneratedAttribute]
public void set_IsExtendedTrial(bool value);
    public bool get_IsCommercialLicense();
    [CompilerGeneratedAttribute]
public string get_LicenseType();
    [CompilerGeneratedAttribute]
public void set_LicenseType(string value);
    [CompilerGeneratedAttribute]
public string get_Edition();
    [CompilerGeneratedAttribute]
public void set_Edition(string value);
    [CompilerGeneratedAttribute]
public string get_RegisteredTo();
    [CompilerGeneratedAttribute]
public void set_RegisteredTo(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_UpgradeProtectionExpiration();
    [CompilerGeneratedAttribute]
internal void set_UpgradeProtectionExpiration(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ValidApplications();
    [CompilerGeneratedAttribute]
internal void set_ValidApplications(List`1<string> value);
    public static License TrialLicense(DateTime trialStartDate);
    public bool ValidForApplication(string applicationName);
    public bool HasExpired();
    public Nullable`1<int> GetDaysUntilLicenseExpires();
    public Nullable`1<int> GetDaysUntilUpgradeProtectionExpires();
    public LicenseStatus GetLicenseStatus();
}
internal static class Particular.Licensing.LicenseDeserializer : object {
    public static License Deserialize(string licenseText);
    private static DateTime Parse(string dateStringFromLicense, string paramName);
}
internal static class Particular.Licensing.LicenseFileLocationResolver : object {
    [CompilerGeneratedAttribute]
private static string <ApplicationFolderLicenseFile>k__BackingField;
    private static string CompanyFolder;
    public static string ApplicationFolderLicenseFile { get; }
    private static LicenseFileLocationResolver();
    [CompilerGeneratedAttribute]
public static string get_ApplicationFolderLicenseFile();
    public static string GetPathFor(SpecialFolder specialFolder, string licenseFileName);
    private static string GetSpecialFolderPath(SpecialFolder specialFolder);
}
internal abstract class Particular.Licensing.LicenseSource : object {
    protected string location;
    protected LicenseSource(string location);
    public abstract virtual LicenseSourceResult Find(string applicationName);
    protected LicenseSourceResult ValidateLicense(string licenseText, string applicationName);
    public static List`1<LicenseSource> GetStandardLicenseSources();
}
internal class Particular.Licensing.LicenseSourceEnvironmentVariable : LicenseSource {
    private string variableName;
    public LicenseSourceEnvironmentVariable(string variableName);
    public virtual LicenseSourceResult Find(string applicationName);
    private bool TryReadLicense(String& license);
}
internal class Particular.Licensing.LicenseSourceFilePath : LicenseSource {
    public LicenseSourceFilePath(string path);
    public virtual LicenseSourceResult Find(string applicationName);
}
internal class Particular.Licensing.LicenseSourceResult : object {
    [CompilerGeneratedAttribute]
private License <License>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Result>k__BackingField;
    internal License License { get; internal set; }
    internal string Location { get; internal set; }
    internal string Result { get; internal set; }
    [CompilerGeneratedAttribute]
internal License get_License();
    [CompilerGeneratedAttribute]
internal void set_License(License value);
    [CompilerGeneratedAttribute]
internal string get_Location();
    [CompilerGeneratedAttribute]
internal void set_Location(string value);
    [CompilerGeneratedAttribute]
internal string get_Result();
    [CompilerGeneratedAttribute]
internal void set_Result(string value);
    public static LicenseSourceResult DetermineBestLicenseSourceResult(LicenseSourceResult[] sourceResults);
}
internal class Particular.Licensing.LicenseSourceUserProvided : LicenseSource {
    private string licenseText;
    public LicenseSourceUserProvided(string licenseText);
    public virtual LicenseSourceResult Find(string applicationName);
}
internal enum Particular.Licensing.LicenseStatus : Enum {
    public int value__;
    public static LicenseStatus Valid;
    public static LicenseStatus ValidWithExpiredUpgradeProtection;
    public static LicenseStatus ValidWithExpiringTrial;
    public static LicenseStatus ValidWithExpiringSubscription;
    public static LicenseStatus ValidWithExpiringUpgradeProtection;
    public static LicenseStatus InvalidDueToExpiredTrial;
    public static LicenseStatus InvalidDueToExpiredSubscription;
    public static LicenseStatus InvalidDueToExpiredUpgradeProtection;
}
internal class Particular.Licensing.LicenseVerifier : object {
    private static string Modulus;
    private static string Exponent;
    public static string PublicKey;
    public static bool TryVerify(string licenseText, String& failureMessage);
}
internal class Particular.Licensing.NonBlockingReader : object {
    public static string ReadAllTextWithoutLocking(string path);
}
internal static class Particular.Licensing.ReleaseDateReader : object {
    public static DateTime GetReleaseDate();
}
internal static class Particular.Licensing.TrialStartDateStore : object {
    [CompilerGeneratedAttribute]
private static string <StorageFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <StorageLocation>k__BackingField;
    public static string StorageFolder { get; }
    public static string StorageLocation { get; }
    private static TrialStartDateStore();
    [CompilerGeneratedAttribute]
public static string get_StorageFolder();
    [CompilerGeneratedAttribute]
public static string get_StorageLocation();
    public static DateTime GetTrialStartDate();
}
[ExtensionAttribute]
internal static class System.ArrayExtensions.ArrayExtensions : object {
    [ExtensionAttribute]
public static void ForEach(Array array, Action`2<Array, Int32[]> action);
}
internal class System.ArrayExtensions.ArrayTraverse : object {
    public Int32[] Position;
    private Int32[] maxLengths;
    public ArrayTraverse(Array array);
    public bool Step();
}
[ExtensionAttribute]
internal static class System.ObjectExtensions : object {
    private static MethodInfo CloneMethod;
    private static ObjectExtensions();
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static object DeepCopy(object originalObject);
    private static object InternalCopy(object originalObject, IDictionary`2<object, object> visited);
    private static void RecursiveCopyBaseTypePrivateFields(object originalObject, IDictionary`2<object, object> visited, object cloneObject, Type typeToReflect);
    private static void CopyFields(object originalObject, IDictionary`2<object, object> visited, object cloneObject, Type typeToReflect, BindingFlags bindingFlags, Func`2<FieldInfo, bool> filter);
    [ExtensionAttribute]
public static T DeepCopy(T original);
}
internal class System.ReferenceEqualityComparer : EqualityComparer`1<object> {
    public virtual bool Equals(object x, object y);
    public virtual int GetHashCode(object obj);
}
