[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class NSubstitute.Arg : object {
    public static T& Any();
    public static T& Is(T value);
    public static T& Is(Expression`1<Predicate`1<T>> predicate);
    public static T& Is(Expression`1<Predicate`1<object>> predicate);
    public static Action& Invoke();
    public static Action`1& Invoke(T arg);
    public static Action`2& Invoke(T1 arg1, T2 arg2);
    public static Action`3& Invoke(T1 arg1, T2 arg2, T3 arg3);
    public static Action`4& Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public static TDelegate& InvokeDelegate(Object[] arguments);
    public static T& Do(Action`1<T> useArgument);
    public static T& Do(Action`1<object> useArgument);
    private static Action`1<object> InvokeDelegateAction(Object[] arguments);
}
public class NSubstitute.Callback : object {
    private ConcurrentQueue`1<Action`1<CallInfo>> callbackQueue;
    private Action`1<CallInfo> alwaysDo;
    private Action`1<CallInfo> keepDoing;
    public static ConfiguredCallback First(Action`1<CallInfo> doThis);
    public static Callback Always(Action`1<CallInfo> doThis);
    public static ConfiguredCallback FirstThrow(Func`2<CallInfo, TException> throwThis);
    public static ConfiguredCallback FirstThrow(TException exception);
    public static Callback AlwaysThrow(Func`2<CallInfo, TException> throwThis);
    public static Callback AlwaysThrow(TException exception);
    protected static Action`1<CallInfo> ToCallback(Func`2<CallInfo, TException> throwThis);
    protected void AddCallback(Action`1<CallInfo> doThis);
    protected void SetAlwaysDo(Action`1<CallInfo> always);
    protected void SetKeepDoing(Action`1<CallInfo> keep);
    public void Call(CallInfo callInfo);
    private void CallFromStack(CallInfo callInfo);
}
public class NSubstitute.Callbacks.ConfiguredCallback : EndCallbackChain {
    public ConfiguredCallback Then(Action`1<CallInfo> doThis);
    public EndCallbackChain ThenKeepDoing(Action`1<CallInfo> doThis);
    public EndCallbackChain ThenKeepThrowing(Func`2<CallInfo, TException> throwThis);
    public EndCallbackChain ThenKeepThrowing(TException throwThis);
    public ConfiguredCallback ThenThrow(Func`2<CallInfo, TException> throwThis);
    public ConfiguredCallback ThenThrow(TException exception);
}
public class NSubstitute.Callbacks.EndCallbackChain : Callback {
    public Callback AndAlways(Action`1<CallInfo> doThis);
}
[ExtensionAttribute]
public static class NSubstitute.ClearExtensions.ClearExtensions : object {
    [ExtensionAttribute]
public static void ClearSubstitute(T substitute, ClearOptions options);
}
[FlagsAttribute]
public enum NSubstitute.ClearOptions : Enum {
    public int value__;
    public static ClearOptions ReceivedCalls;
    public static ClearOptions ReturnValues;
    public static ClearOptions CallActions;
    public static ClearOptions All;
}
public class NSubstitute.Compatibility.CompatArg : object {
    public static CompatArg Instance;
    private static CompatArg();
    public T Any();
    public T Is(T value);
    public T Is(Expression`1<Predicate`1<T>> predicate);
    public AnyType Is(Expression`1<Predicate`1<object>> predicate);
    public Action Invoke();
    public Action`1<T> Invoke(T arg);
    public Action`2<T1, T2> Invoke(T1 arg1, T2 arg2);
    public Action`3<T1, T2, T3> Invoke(T1 arg1, T2 arg2, T3 arg3);
    public Action`4<T1, T2, T3, T4> Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public TDelegate InvokeDelegate(Object[] arguments);
    public T Do(Action`1<T> useArgument);
    public static AnyType Do(Action`1<object> useArgument);
}
public class NSubstitute.Core.Argument : object {
    [NullableAttribute("2")]
private ICall _call;
    private int _argIndex;
    [NullableAttribute("2")]
private Type _declaredType;
    [NullableAttribute("2")]
private Func`1<object> _getValue;
    [NullableAttribute("2")]
private Action`1<object> _setValue;
    [NullableAttribute("2")]
public object Value { get; public set; }
    public bool IsByRef { get; }
    public Type DeclaredType { get; }
    public Type ActualType { get; }
    [ObsoleteAttribute("This constructor overload is deprecated and will be removed in the next version.")]
public Argument(Type declaredType, Func`1<object> getValue, Action`1<object> setValue);
    public Argument(ICall call, int argIndex);
    [NullableContextAttribute("2")]
public object get_Value();
    [NullableContextAttribute("2")]
public void set_Value(object value);
    public bool get_IsByRef();
    public Type get_DeclaredType();
    public Type get_ActualType();
    public bool IsDeclaredTypeEqualToOrByRefVersionOf(Type type);
    public bool IsValueAssignableTo(Type type);
    public bool CanSetValueWithInstanceOf(Type type);
    private static Type AsNonByRefType(Type type);
}
public class NSubstitute.Core.Arguments.AnyArgumentMatcher : object {
    private Type _typeArgMustBeCompatibleWith;
    public AnyArgumentMatcher(Type typeArgMustBeCompatibleWith);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual bool IsSatisfiedBy(object argument);
}
public class NSubstitute.Core.Arguments.ArgumentFormatter : object {
    [CompilerGeneratedAttribute]
private static IArgumentFormatter <Default>k__BackingField;
    internal static IArgumentFormatter Default { get; }
    private static ArgumentFormatter();
    [CompilerGeneratedAttribute]
internal static IArgumentFormatter get_Default();
    public sealed virtual string Format(object argument, bool highlight);
    private string Format(object arg);
    [CompilerGeneratedAttribute]
internal static bool <Format>g__HasDefaultToString|4_0(object obj);
}
public static class NSubstitute.Core.Arguments.ArgumentMatcher : object {
    public static T& Enqueue(IArgumentMatcher`1<T> argumentMatcher);
    internal static T& Enqueue(IArgumentMatcher argumentMatcher);
    internal static T& Enqueue(IArgumentMatcher argumentMatcher, Action`1<object> action);
    private static T& EnqueueArgSpecification(IArgumentSpecification specification);
}
public class NSubstitute.Core.Arguments.ArgumentMatchInfo : object {
    [NullableAttribute("2")]
private object _argument;
    private IArgumentSpecification _specification;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; }
    public bool IsMatch { get; }
    public ArgumentMatchInfo(int index, object argument, IArgumentSpecification specification);
    [CompilerGeneratedAttribute]
public int get_Index();
    public bool get_IsMatch();
    public string DescribeNonMatch();
    [NullableContextAttribute("2")]
public bool Equals(ArgumentMatchInfo other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NSubstitute.Core.Arguments.ArgumentSpecification : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`1<object> NoOpAction;
    private IArgumentMatcher _matcher;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<object> _action;
    [CompilerGeneratedAttribute]
private Type <ForType>k__BackingField;
    public Type ForType { get; }
    public bool HasAction { get; }
    public ArgumentSpecification(Type forType, IArgumentMatcher matcher);
    public ArgumentSpecification(Type forType, IArgumentMatcher matcher, Action`1<object> action);
    private static ArgumentSpecification();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ForType();
    public sealed virtual bool get_HasAction();
    [NullableContextAttribute("2")]
public sealed virtual bool IsSatisfiedBy(object argument);
    public sealed virtual string DescribeNonMatch(object argument);
    public sealed virtual string FormatArgument(object argument);
    public virtual string ToString();
    public sealed virtual IArgumentSpecification CreateCopyMatchingAnyArgOfType(Type requiredType);
    [NullableContextAttribute("2")]
public sealed virtual void RunAction(object argument);
    [NullableContextAttribute("2")]
private void RunActionIfTypeIsCompatible(object argument);
    [NullableContextAttribute("2")]
private bool IsCompatibleWith(object argument);
    private string GetIncompatibleTypeMessage(object argument);
}
public class NSubstitute.Core.Arguments.ArgumentSpecificationCompatibilityTester : object {
    private IDefaultChecker _defaultChecker;
    public ArgumentSpecificationCompatibilityTester(IDefaultChecker defaultChecker);
    public sealed virtual bool IsSpecificationCompatible(IArgumentSpecification specification, object argumentValue, Type argumentType);
    private bool IsProvidedArgumentTheOneWeWouldGetUsingAnArgSpecForThisType(object argument, Type typeArgSpecIsFor);
    private bool AreTypesCompatible(Type argumentType, Type typeArgSpecIsFor);
}
public class NSubstitute.Core.Arguments.ArgumentSpecificationFactory : object {
    public sealed virtual IArgumentSpecification Create(object argument, IParameterInfo parameterInfo, ISuppliedArgumentSpecifications suppliedArgumentSpecifications);
    private IArgumentSpecification CreateSpecFromNonParamsArg(object argument, IParameterInfo parameterInfo, ISuppliedArgumentSpecifications suppliedArgumentSpecifications);
    private IArgumentSpecification CreateSpecFromParamsArg(object argument, IParameterInfo parameterInfo, ISuppliedArgumentSpecifications suppliedArgumentSpecifications);
    private IEnumerable`1<IArgumentSpecification> UnwrapParamsArguments(IEnumerable`1<object> args, Type paramsElementType, ISuppliedArgumentSpecifications suppliedArgumentSpecifications);
}
public class NSubstitute.Core.Arguments.ArgumentSpecificationsFactory : object {
    private IArgumentSpecificationFactory _argumentSpecificationFactory;
    private ISuppliedArgumentSpecificationsFactory _suppliedArgumentSpecificationsFactory;
    public ArgumentSpecificationsFactory(IArgumentSpecificationFactory argumentSpecificationFactory, ISuppliedArgumentSpecificationsFactory suppliedArgumentSpecificationsFactory);
    public sealed virtual IEnumerable`1<IArgumentSpecification> Create(IList`1<IArgumentSpecification> argumentSpecs, Object[] arguments, IParameterInfo[] parameterInfos, MethodInfo methodInfo, MatchArgs matchArgs);
    private static IEnumerable`1<IArgumentSpecification> ConvertToMatchAnyValue(IEnumerable`1<IArgumentSpecification> specs);
}
public class NSubstitute.Core.Arguments.ArrayContentsArgumentMatcher : object {
    private IArgumentSpecification[] _argumentSpecifications;
    public ArrayContentsArgumentMatcher(IEnumerable`1<IArgumentSpecification> argumentSpecifications);
    [NullableContextAttribute("2")]
public sealed virtual bool IsSatisfiedBy(object argument);
    public virtual string ToString();
    public sealed virtual string Format(object argument, bool highlight);
    private IEnumerable`1<string> Format(Object[] args, IArgumentSpecification[] specs);
}
public class NSubstitute.Core.Arguments.DefaultChecker : object {
    private IDefaultForType _defaultForType;
    public DefaultChecker(IDefaultForType defaultForType);
    public sealed virtual bool IsDefault(object value, Type forType);
}
public class NSubstitute.Core.Arguments.EqualsArgumentMatcher : object {
    [NullableAttribute("2")]
private object _value;
    [NullableContextAttribute("2")]
public EqualsArgumentMatcher(object value);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual bool IsSatisfiedBy(object argument);
}
public class NSubstitute.Core.Arguments.ExpressionArgumentMatcher`1 : object {
    private string _predicateDescription;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Predicate`1<T> _predicate;
    public ExpressionArgumentMatcher`1(Expression`1<Predicate`1<T>> predicate);
    [NullableContextAttribute("2")]
public sealed virtual bool IsSatisfiedBy(object argument);
    public virtual string ToString();
}
public interface NSubstitute.Core.Arguments.IArgumentFormatter {
    public abstract virtual string Format(object arg, bool highlight);
}
[NullableContextAttribute("2")]
public interface NSubstitute.Core.Arguments.IArgumentMatcher {
    public abstract virtual bool IsSatisfiedBy(object argument);
}
public interface NSubstitute.Core.Arguments.IArgumentMatcher`1 {
    [NullableContextAttribute("2")]
public abstract virtual bool IsSatisfiedBy(T argument);
}
public interface NSubstitute.Core.Arguments.IArgumentSpecification {
    public Type ForType { get; }
    public bool HasAction { get; }
    [NullableContextAttribute("2")]
public abstract virtual bool IsSatisfiedBy(object argument);
    public abstract virtual Type get_ForType();
    public abstract virtual IArgumentSpecification CreateCopyMatchingAnyArgOfType(Type requiredType);
    public abstract virtual bool get_HasAction();
    [NullableContextAttribute("2")]
public abstract virtual void RunAction(object argument);
    public abstract virtual string DescribeNonMatch(object argument);
    public abstract virtual string FormatArgument(object argument);
}
public interface NSubstitute.Core.Arguments.IArgumentSpecificationCompatibilityTester {
    public abstract virtual bool IsSpecificationCompatible(IArgumentSpecification specification, object argumentValue, Type argumentType);
}
public interface NSubstitute.Core.Arguments.IArgumentSpecificationFactory {
    public abstract virtual IArgumentSpecification Create(object argument, IParameterInfo parameterInfo, ISuppliedArgumentSpecifications suppliedArgumentSpecifications);
}
public interface NSubstitute.Core.Arguments.IArgumentSpecificationsFactory {
    public abstract virtual IEnumerable`1<IArgumentSpecification> Create(IList`1<IArgumentSpecification> argumentSpecs, Object[] arguments, IParameterInfo[] parameterInfos, MethodInfo methodInfo, MatchArgs matchArgs);
}
public interface NSubstitute.Core.Arguments.IDefaultChecker {
    public abstract virtual bool IsDefault(object value, Type forType);
}
public interface NSubstitute.Core.Arguments.ISuppliedArgumentSpecifications {
    public abstract virtual bool AnyFor(object argument, Type argumentType);
    public abstract virtual bool IsNextFor(object argument, Type argumentType);
    public abstract virtual IArgumentSpecification Dequeue();
    public abstract virtual IEnumerable`1<IArgumentSpecification> DequeueRemaining();
}
public interface NSubstitute.Core.Arguments.ISuppliedArgumentSpecificationsFactory {
    public abstract virtual ISuppliedArgumentSpecifications Create(IEnumerable`1<IArgumentSpecification> argumentSpecifications);
}
public class NSubstitute.Core.Arguments.SuppliedArgumentSpecifications : object {
    private IArgumentSpecificationCompatibilityTester _argSpecCompatibilityTester;
    private Queue`1<IArgumentSpecification> _queue;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IArgumentSpecification> <AllSpecifications>k__BackingField;
    private IReadOnlyCollection`1<IArgumentSpecification> AllSpecifications { get; }
    public SuppliedArgumentSpecifications(IArgumentSpecificationCompatibilityTester argSpecCompatibilityTester, IEnumerable`1<IArgumentSpecification> argumentSpecifications);
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IArgumentSpecification> get_AllSpecifications();
    public sealed virtual bool AnyFor(object argument, Type argumentType);
    public sealed virtual bool IsNextFor(object argument, Type argumentType);
    public sealed virtual IArgumentSpecification Dequeue();
    public sealed virtual IEnumerable`1<IArgumentSpecification> DequeueRemaining();
}
public class NSubstitute.Core.Arguments.SuppliedArgumentSpecificationsFactory : object {
    private IArgumentSpecificationCompatibilityTester _argumentSpecificationCompatTester;
    public SuppliedArgumentSpecificationsFactory(IArgumentSpecificationCompatibilityTester argumentSpecificationCompatTester);
    public sealed virtual ISuppliedArgumentSpecifications Create(IEnumerable`1<IArgumentSpecification> argumentSpecifications);
}
public class NSubstitute.Core.ArgumentSpecificationDequeue : object {
    private static IArgumentSpecification[] EmptySpecifications;
    private Func`1<IList`1<IArgumentSpecification>> _dequeueAllQueuedArgSpecs;
    public ArgumentSpecificationDequeue(Func`1<IList`1<IArgumentSpecification>> dequeueAllQueuedArgSpecs);
    private static ArgumentSpecificationDequeue();
    public sealed virtual IList`1<IArgumentSpecification> DequeueAllArgumentSpecificationsForMethod(int parametersCount);
    public sealed virtual IList`1<IArgumentSpecification> DequeueAllArgumentSpecificationsForMethod(MethodInfo methodInfo);
}
public class NSubstitute.Core.Call : object {
    private MethodInfo _methodInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _arguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _originalArguments;
    private object _target;
    private IList`1<IArgumentSpecification> _argumentSpecifications;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IParameterInfo[] _parameterInfosCached;
    private Nullable`1<long> _sequenceNumber;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _baseMethod;
    private int _callEntryState;
    public bool CanCallBase { get; }
    private ICall NSubstitute.Core.CallCollection.IReceivedCallEntry.Call { get; }
    private bool NSubstitute.Core.CallCollection.IReceivedCallEntry.IsSkipped { get; }
    [ObsoleteAttribute("This constructor is deprecated and will be removed in future version of product.")]
public Call(MethodInfo methodInfo, Object[] arguments, object target, IList`1<IArgumentSpecification> argumentSpecifications, IParameterInfo[] parameterInfos, Func`1<object> baseMethod);
    public Call(MethodInfo methodInfo, Object[] arguments, object target, IList`1<IArgumentSpecification> argumentSpecifications, Func`1<object> baseMethod);
    public sealed virtual IParameterInfo[] GetParameterInfos();
    public sealed virtual IList`1<IArgumentSpecification> GetArgumentSpecifications();
    public sealed virtual void AssignSequenceNumber(long number);
    public sealed virtual long GetSequenceNumber();
    public sealed virtual bool get_CanCallBase();
    public sealed virtual Maybe`1<object> TryCallBase();
    public sealed virtual Type GetReturnType();
    public sealed virtual MethodInfo GetMethodInfo();
    public sealed virtual Object[] GetArguments();
    public sealed virtual Object[] GetOriginalArguments();
    public sealed virtual object Target();
    private static IParameterInfo[] GetParameterInfoFromMethod(MethodInfo methodInfo);
    private sealed virtual override ICall NSubstitute.Core.CallCollection.IReceivedCallEntry.get_Call();
    private sealed virtual override bool NSubstitute.Core.CallCollection.IReceivedCallEntry.get_IsSkipped();
    private sealed virtual override void NSubstitute.Core.CallCollection.IReceivedCallEntry.Skip();
    private sealed virtual override bool NSubstitute.Core.CallCollection.IReceivedCallEntry.TryTakeEntryOwnership();
}
public class NSubstitute.Core.CallActions : object {
    private static Action`1<CallInfo> EmptyAction;
    private ICallInfoFactory _callInfoFactory;
    private ConcurrentQueue`1<CallAction> _actions;
    public CallActions(ICallInfoFactory callInfoFactory);
    private static CallActions();
    public sealed virtual void Add(ICallSpecification callSpecification, Action`1<CallInfo> action);
    public sealed virtual void Add(ICallSpecification callSpecification);
    public sealed virtual void MoveActionsForSpecToNewSpec(ICallSpecification oldCallSpecification, ICallSpecification newCallSpecification);
    public sealed virtual void Clear();
    public sealed virtual void InvokeMatchingActions(ICall call);
}
public class NSubstitute.Core.CallBaseConfiguration : object {
    [CompilerGeneratedAttribute]
private ConcurrentStack`1<CallBaseRule> <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CallBaseByDefault>k__BackingField;
    private ConcurrentStack`1<CallBaseRule> Rules { get; }
    public bool CallBaseByDefault { get; public set; }
    [CompilerGeneratedAttribute]
private ConcurrentStack`1<CallBaseRule> get_Rules();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CallBaseByDefault();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CallBaseByDefault(bool value);
    public sealed virtual void Exclude(ICallSpecification callSpecification);
    public sealed virtual void Include(ICallSpecification callSpecification);
    public sealed virtual bool ShouldCallBase(ICall call);
    private bool TryGetExplicitConfiguration(ICall call, Boolean& callBase);
}
public class NSubstitute.Core.CallCollection : object {
    private ConcurrentQueue`1<IReceivedCallEntry> _callEntries;
    public sealed virtual void Add(ICall call);
    public sealed virtual void Delete(ICall call);
    public sealed virtual IEnumerable`1<ICall> AllCalls();
    public sealed virtual void Clear();
}
public class NSubstitute.Core.CallFactory : object {
    public sealed virtual ICall Create(MethodInfo methodInfo, Object[] arguments, object target, IList`1<IArgumentSpecification> argumentSpecifications, Func`1<object> baseMethod);
    public sealed virtual ICall Create(MethodInfo methodInfo, Object[] arguments, object target, IList`1<IArgumentSpecification> argumentSpecifications);
}
public class NSubstitute.Core.CallFormatter : object {
    [CompilerGeneratedAttribute]
private static IMethodInfoFormatter <Default>k__BackingField;
    private IEnumerable`1<IMethodInfoFormatter> _methodInfoFormatters;
    internal static IMethodInfoFormatter Default { get; }
    private static CallFormatter();
    [CompilerGeneratedAttribute]
internal static IMethodInfoFormatter get_Default();
    public sealed virtual bool CanFormat(MethodInfo methodInfo);
    public sealed virtual string Format(MethodInfo methodInfoOfCall, IEnumerable`1<string> formattedArguments);
}
public class NSubstitute.Core.CallHandlerFactory : MulticastDelegate {
    public CallHandlerFactory(object object, IntPtr method);
    public virtual ICallHandler Invoke(ISubstituteState substituteState);
    public virtual IAsyncResult BeginInvoke(ISubstituteState substituteState, AsyncCallback callback, object object);
    public virtual ICallHandler EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class NSubstitute.Core.CallInfo : object {
    private Argument[] _callArguments;
    public object Item { get; public set; }
    public CallInfo(Argument[] callArguments);
    public object get_Item(int index);
    public void set_Item(int index, object value);
    private void EnsureArgIsSettable(Argument argument, int index, object value);
    public Object[] Args();
    public Type[] ArgTypes();
    public T Arg();
    private bool TryGetArg(Func`2<Argument, bool> condition, T& value);
    private void ThrowIfMoreThanOne(IEnumerable`1<Argument> arguments);
    public T ArgAt(int position);
    private static string DisplayTypes(IEnumerable`1<Type> types);
}
public class NSubstitute.Core.CallInfoFactory : object {
    public sealed virtual CallInfo Create(ICall call);
    private static Argument[] GetArgumentsFromCall(ICall call);
}
public class NSubstitute.Core.CallResults : object {
    private ICallInfoFactory _callInfoFactory;
    private ConcurrentStack`1<ResultForCallSpec> _results;
    public CallResults(ICallInfoFactory callInfoFactory);
    public sealed virtual void SetResult(ICallSpecification callSpecification, IReturn result);
    public sealed virtual bool TryGetResult(ICall call, Object& result);
    private bool TryFindResultForCall(ICall call, ResultForCallSpec& configuredResult);
    public sealed virtual void Clear();
    private static bool ReturnsVoidFrom(ICall call);
}
public class NSubstitute.Core.CallRouter : object {
    private ISubstituteState _substituteState;
    private IThreadLocalContext _threadContext;
    private IRouteFactory _routeFactory;
    private bool _canConfigureBaseCalls;
    public bool CallBaseByDefault { get; public set; }
    public CallRouter(ISubstituteState substituteState, IThreadLocalContext threadContext, IRouteFactory routeFactory, bool canConfigureBaseCalls);
    public sealed virtual bool get_CallBaseByDefault();
    public sealed virtual void set_CallBaseByDefault(bool value);
    public sealed virtual void Clear(ClearOptions options);
    public sealed virtual IEnumerable`1<ICall> ReceivedCalls();
    public sealed virtual void SetRoute(Func`2<ISubstituteState, IRoute> getRoute);
    public sealed virtual object Route(ICall call);
    private IRoute ResolveCurrentRoute(ICall call, bool isQuerying, Func`2<ICall, Object[]> pendingRaisingEventArgs, Func`2<ISubstituteState, IRoute> queuedNextRouteFactory);
    private static bool IsSpecifyingACall(ICall call);
    public sealed virtual ConfiguredCall LastCallShouldReturn(IReturn returnValue, MatchArgs matchArgs, PendingSpecificationInfo pendingSpecInfo);
    public sealed virtual void SetReturnForType(Type type, IReturn returnValue);
    public sealed virtual void RegisterCustomCallHandlerFactory(CallHandlerFactory factory);
}
public class NSubstitute.Core.CallRouterFactory : object {
    private IThreadLocalContext _threadLocalContext;
    private IRouteFactory _routeFactory;
    public CallRouterFactory(IThreadLocalContext threadLocalContext, IRouteFactory routeFactory);
    public sealed virtual ICallRouter Create(ISubstituteState substituteState, bool canConfigureBaseCalls);
}
public class NSubstitute.Core.CallRouterResolver : object {
    public sealed virtual ICallRouter ResolveFor(object substitute);
}
public class NSubstitute.Core.CallSpecAndTarget : object {
    [CompilerGeneratedAttribute]
private ICallSpecification <CallSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    public ICallSpecification CallSpecification { get; }
    public object Target { get; }
    public CallSpecAndTarget(ICallSpecification callSpecification, object target);
    [CompilerGeneratedAttribute]
public ICallSpecification get_CallSpecification();
    [CompilerGeneratedAttribute]
public object get_Target();
}
public class NSubstitute.Core.CallSpecification : object {
    private MethodInfo _methodInfo;
    private IArgumentSpecification[] _argumentSpecifications;
    public CallSpecification(MethodInfo methodInfo, IEnumerable`1<IArgumentSpecification> argumentSpecifications);
    public sealed virtual MethodInfo GetMethodInfo();
    public sealed virtual Type ReturnType();
    public sealed virtual bool IsSatisfiedBy(ICall call);
    private static bool AreComparable(MethodInfo a, MethodInfo b);
    private static bool CanCompareGenericMethods(MethodInfo a, MethodInfo b);
    private static Type[] ParameterTypes(MethodInfo info);
    internal static bool TypesAreAllEquivalent(Type[] aArgs, Type[] bArgs);
    private static bool AreEquivalentDefinitions(MethodInfo a, MethodInfo b);
    private bool IsMatchingArgumentSpecifications(ICall call);
    public sealed virtual IEnumerable`1<ArgumentMatchInfo> NonMatchingArguments(ICall call);
    public virtual string ToString();
    public sealed virtual string Format(ICall call);
    private IEnumerable`1<string> FormatArguments(IEnumerable`1<object> arguments);
    public sealed virtual ICallSpecification CreateCopyThatMatchesAnyArguments();
    public sealed virtual void InvokePerArgumentActions(CallInfo callInfo);
    private bool HasDifferentNumberOfArguments(ICall call);
    [CompilerGeneratedAttribute]
private ArgumentMatchInfo <NonMatchingArguments>b__12_0(object arg, int index);
}
public class NSubstitute.Core.CallSpecificationFactory : object {
    private IArgumentSpecificationsFactory _argumentSpecificationsFactory;
    public CallSpecificationFactory(IArgumentSpecificationsFactory argumentSpecificationsFactory);
    public sealed virtual ICallSpecification CreateFrom(ICall call, MatchArgs matchArgs);
}
public static class NSubstitute.Core.CallSpecificationFactoryFactoryYesThatsRight : object {
    [ObsoleteAttribute("This factory is deprecated and will be removed in future versions of the product. Please use 'SubstitutionContext.Current.CallSpecificationFactory' instead. Use NSubstituteDefaultFactory services if you need to activate a new instance.")]
public static ICallSpecificationFactory CreateCallSpecFactory();
}
public class NSubstitute.Core.ConfigureCall : object {
    private ICallResults _configuredResults;
    private ICallActions _callActions;
    private IGetCallSpec _getCallSpec;
    public ConfigureCall(ICallResults configuredResults, ICallActions callActions, IGetCallSpec getCallSpec);
    public sealed virtual ConfiguredCall SetResultForLastCall(IReturn valueToReturn, MatchArgs matchArgs, PendingSpecificationInfo pendingSpecInfo);
    public sealed virtual void SetResultForCall(ICall call, IReturn valueToReturn, MatchArgs matchArgs);
    private static void CheckResultIsCompatibleWithCall(IReturn valueToReturn, ICallSpecification spec);
}
public class NSubstitute.Core.ConfiguredCall : object {
    private Action`1<Action`1<CallInfo>> _addAction;
    public ConfiguredCall(Action`1<Action`1<CallInfo>> addAction);
    public ConfiguredCall AndDoes(Action`1<CallInfo> action);
}
public class NSubstitute.Core.CustomHandlers : object {
    private List`1<ICallHandler> _handlers;
    private ISubstituteState _substituteState;
    public IReadOnlyCollection`1<ICallHandler> Handlers { get; }
    public CustomHandlers(ISubstituteState substituteState);
    public sealed virtual IReadOnlyCollection`1<ICallHandler> get_Handlers();
    public sealed virtual void AddCustomHandlerFactory(CallHandlerFactory factory);
}
public class NSubstitute.Core.DefaultForType : object {
    private static object BoxedBoolean;
    private static object BoxedInt;
    private static object BoxedLong;
    private static object BoxedDouble;
    private static DefaultForType();
    public sealed virtual object GetDefaultFor(Type type);
    private bool IsVoid(Type returnType);
    private object DefaultInstanceOfValueType(Type returnType);
}
[ExtensionAttribute]
public static class NSubstitute.Core.DependencyInjection.ConfigurableNSubContainerExtensions : object {
    [ExtensionAttribute]
public static IConfigurableNSubContainer RegisterPerScope(IConfigurableNSubContainer container);
    [ExtensionAttribute]
public static IConfigurableNSubContainer RegisterPerScope(IConfigurableNSubContainer container, Func`2<INSubResolver, TKey> factory);
    [ExtensionAttribute]
public static IConfigurableNSubContainer RegisterSingleton(IConfigurableNSubContainer container);
}
public interface NSubstitute.Core.DependencyInjection.IConfigurableNSubContainer {
    public abstract virtual IConfigurableNSubContainer Register(NSubLifetime lifetime);
    public abstract virtual IConfigurableNSubContainer Register(Func`2<INSubResolver, TKey> factory, NSubLifetime lifetime);
    public abstract virtual IConfigurableNSubContainer Decorate(Func`3<TKey, INSubResolver, TKey> factory);
}
public interface NSubstitute.Core.DependencyInjection.INSubContainer {
    public abstract virtual IConfigurableNSubContainer Customize();
    public abstract virtual INSubResolver CreateScope();
}
public interface NSubstitute.Core.DependencyInjection.INSubResolver {
    public abstract virtual T Resolve();
}
public class NSubstitute.Core.DependencyInjection.NSubContainer : object {
    [NullableAttribute("2")]
private NSubContainer _parentContainer;
    private object _syncRoot;
    private Dictionary`2<Type, Registration> _registrations;
    private NSubContainer(NSubContainer parentContainer);
    public sealed virtual T Resolve();
    public sealed virtual IConfigurableNSubContainer Register(NSubLifetime lifetime);
    public sealed virtual IConfigurableNSubContainer Register(Func`2<INSubResolver, TKey> factory, NSubLifetime lifetime);
    public sealed virtual IConfigurableNSubContainer Decorate(Func`3<TKey, INSubResolver, TKey> factory);
    public sealed virtual IConfigurableNSubContainer Customize();
    public sealed virtual INSubResolver CreateScope();
    private void SetRegistration(Type type, Registration registration);
    private Registration TryFindRegistration(Type type);
}
public enum NSubstitute.Core.DependencyInjection.NSubLifetime : Enum {
    public int value__;
    public static NSubLifetime Singleton;
    public static NSubLifetime PerScope;
    public static NSubLifetime Transient;
}
public static class NSubstitute.Core.DependencyInjection.NSubstituteDefaultFactory : object {
    [CompilerGeneratedAttribute]
private static INSubContainer <DefaultContainer>k__BackingField;
    public static INSubContainer DefaultContainer { get; }
    private static NSubstituteDefaultFactory();
    [CompilerGeneratedAttribute]
public static INSubContainer get_DefaultContainer();
    public static ISubstitutionContext CreateSubstitutionContext();
    private static INSubContainer CreateDefaultContainer();
}
internal class NSubstitute.Core.EmptyDisposable : object {
    [CompilerGeneratedAttribute]
private static IDisposable <Instance>k__BackingField;
    public static IDisposable Instance { get; }
    private static EmptyDisposable();
    [CompilerGeneratedAttribute]
public static IDisposable get_Instance();
    public sealed virtual void Dispose();
}
public class NSubstitute.Core.EventCallFormatter : object {
    public static Func`2<MethodInfo, Predicate`1<EventInfo>> IsSubscription;
    public static Func`2<MethodInfo, Predicate`1<EventInfo>> IsUnsubscription;
    private Func`2<MethodInfo, Predicate`1<EventInfo>> _eventsToFormat;
    private string _eventOperator;
    public EventCallFormatter(Func`2<MethodInfo, Predicate`1<EventInfo>> eventsToFormat);
    private static EventCallFormatter();
    public sealed virtual bool CanFormat(MethodInfo methodInfo);
    public sealed virtual string Format(MethodInfo methodInfo, IEnumerable`1<string> arguments);
    private string Format(EventInfo eventInfo, string eventOperator, IEnumerable`1<string> arguments);
}
public class NSubstitute.Core.EventHandlerRegistry : object {
    private List`1<Tuple`2<string, List`1<object>>> _handlersForEvent;
    public sealed virtual void Add(string eventName, object handler);
    public sealed virtual void Remove(string eventName, object handler);
    public sealed virtual IEnumerable`1<object> GetHandlers(string eventName);
    private List`1<object> Handlers(string eventName);
}
public class NSubstitute.Core.Events.DelegateEventWrapper`1 : RaiseEventWrapper {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _providedArguments;
    protected string RaiseMethodName { get; }
    public DelegateEventWrapper`1(Object[] arguments);
    protected virtual string get_RaiseMethodName();
    public static T op_Implicit(DelegateEventWrapper`1<T> wrapper);
    protected virtual Object[] WorkOutRequiredArguments(ICall call);
    private bool LooksLikeAnEventStyleCall(ParameterInfo[] parameters);
    private Object[] WorkOutSenderAndEventArgs(Type eventArgsType, ICall call);
    private static bool RequiredArgsHaveBeenProvided(Object[] providedArgs, ParameterInfo[] requiredArgs);
    private static void ThrowBecauseRequiredArgsNotProvided(ParameterInfo[] requiredArgs);
}
public class NSubstitute.Core.Events.EventHandlerWrapper`1 : RaiseEventWrapper {
    [NullableAttribute("2")]
private object _sender;
    [NullableAttribute("2")]
private EventArgs _eventArgs;
    protected string RaiseMethodName { get; }
    [NullableContextAttribute("2")]
public EventHandlerWrapper`1(EventArgs eventArgs);
    [NullableContextAttribute("2")]
public EventHandlerWrapper`1(object sender, EventArgs eventArgs);
    protected virtual string get_RaiseMethodName();
    public static EventHandler op_Implicit(EventHandlerWrapper`1<TEventArgs> wrapper);
    public static EventHandler`1<TEventArgs> op_Implicit(EventHandlerWrapper`1<TEventArgs> wrapper);
    protected virtual Object[] WorkOutRequiredArguments(ICall call);
}
public abstract class NSubstitute.Core.Events.RaiseEventWrapper : object {
    protected string RaiseMethodName { get; }
    protected abstract virtual Object[] WorkOutRequiredArguments(ICall call);
    protected abstract virtual string get_RaiseMethodName();
    protected EventArgs GetDefaultForEventArgType(Type type);
    private static ConstructorInfo GetDefaultConstructor(Type type);
    protected static void RaiseEvent(RaiseEventWrapper wrapper);
}
[ExtensionAttribute]
internal static class NSubstitute.Core.Extensions : object {
    [ExtensionAttribute]
public static bool IsCompatibleWith(object instance, Type type);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> strings, string separator);
    [ExtensionAttribute]
public static bool IsDelegate(Type type);
    [ExtensionAttribute]
public static MethodInfo GetInvokeMethod(Type type);
    private static bool TypeCanBeNull(Type type);
    [ExtensionAttribute]
public static string GetNonMangledTypeName(Type type);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> sequence);
    [CompilerGeneratedAttribute]
internal static void <GetNonMangledTypeName>g__AppendTypeNameRecursively|5_0(Type currentType, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static string <GetNonMangledTypeName>g__GetTypeNameWithoutGenericArity|5_1(Type type);
}
public class NSubstitute.Core.GetCallSpec : object {
    private ICallCollection _receivedCalls;
    private ICallSpecificationFactory _callSpecificationFactory;
    private ICallActions _callActions;
    public GetCallSpec(ICallCollection receivedCalls, ICallSpecificationFactory callSpecificationFactory, ICallActions callActions);
    public sealed virtual ICallSpecification FromPendingSpecification(MatchArgs matchArgs, PendingSpecificationInfo pendingSpecInfo);
    public sealed virtual ICallSpecification FromCall(ICall call, MatchArgs matchArgs);
    public sealed virtual ICallSpecification FromExistingSpec(ICallSpecification spec, MatchArgs matchArgs);
    private ICallSpecification UpdateCallSpecToMatchAnyArgs(ICallSpecification callSpecification);
}
public interface NSubstitute.Core.IArgumentSpecificationDequeue {
    [ObsoleteAttribute("This method is deprecated and will be removed in future versions of product.")]
public abstract virtual IList`1<IArgumentSpecification> DequeueAllArgumentSpecificationsForMethod(MethodInfo methodInfo);
    public abstract virtual IList`1<IArgumentSpecification> DequeueAllArgumentSpecificationsForMethod(int parametersCount);
}
public interface NSubstitute.Core.ICall {
    public bool CanCallBase { get; }
    public abstract virtual Type GetReturnType();
    public abstract virtual MethodInfo GetMethodInfo();
    public abstract virtual Object[] GetArguments();
    public abstract virtual Object[] GetOriginalArguments();
    public abstract virtual object Target();
    public abstract virtual IParameterInfo[] GetParameterInfos();
    public abstract virtual IList`1<IArgumentSpecification> GetArgumentSpecifications();
    public abstract virtual void AssignSequenceNumber(long number);
    public abstract virtual long GetSequenceNumber();
    public abstract virtual bool get_CanCallBase();
    public abstract virtual Maybe`1<object> TryCallBase();
}
public interface NSubstitute.Core.ICallActions {
    public abstract virtual void Add(ICallSpecification callSpecification, Action`1<CallInfo> action);
    public abstract virtual void Add(ICallSpecification callSpec);
    public abstract virtual void InvokeMatchingActions(ICall callInfo);
    public abstract virtual void MoveActionsForSpecToNewSpec(ICallSpecification oldCallSpecification, ICallSpecification newCallSpecification);
    public abstract virtual void Clear();
}
public interface NSubstitute.Core.ICallBaseConfiguration {
    public bool CallBaseByDefault { get; public set; }
    public abstract virtual bool get_CallBaseByDefault();
    public abstract virtual void set_CallBaseByDefault(bool value);
    public abstract virtual void Exclude(ICallSpecification callSpecification);
    public abstract virtual void Include(ICallSpecification callSpecification);
    public abstract virtual bool ShouldCallBase(ICall call);
}
public interface NSubstitute.Core.ICallCollection {
    public abstract virtual void Add(ICall call);
    public abstract virtual void Delete(ICall call);
    public abstract virtual IEnumerable`1<ICall> AllCalls();
    public abstract virtual void Clear();
}
public interface NSubstitute.Core.ICallFactory {
    public abstract virtual ICall Create(MethodInfo methodInfo, Object[] arguments, object target, IList`1<IArgumentSpecification> argumentSpecifications, Func`1<object> baseMethod);
    public abstract virtual ICall Create(MethodInfo methodInfo, Object[] getterArgs, object target, IList`1<IArgumentSpecification> getArgumentSpecifications);
}
public interface NSubstitute.Core.ICallHandler {
    public abstract virtual RouteAction Handle(ICall call);
}
[NullableContextAttribute("2")]
internal interface NSubstitute.Core.ICallIndependentReturn {
    public abstract virtual object GetReturnValue();
}
public interface NSubstitute.Core.ICallInfoFactory {
    public abstract virtual CallInfo Create(ICall call);
}
public interface NSubstitute.Core.ICallResults {
    public abstract virtual void SetResult(ICallSpecification callSpecification, IReturn result);
    public abstract virtual bool TryGetResult(ICall call, Object& result);
    public abstract virtual void Clear();
}
public interface NSubstitute.Core.ICallRouter {
    public bool CallBaseByDefault { get; public set; }
    public abstract virtual bool get_CallBaseByDefault();
    public abstract virtual void set_CallBaseByDefault(bool value);
    public abstract virtual ConfiguredCall LastCallShouldReturn(IReturn returnValue, MatchArgs matchArgs, PendingSpecificationInfo pendingSpecInfo);
    public abstract virtual object Route(ICall call);
    public abstract virtual IEnumerable`1<ICall> ReceivedCalls();
    [ObsoleteAttribute("This method is deprecated and will be removed in future versions of the product. Please use IThreadLocalContext.SetNextRoute method instead.")]
public abstract virtual void SetRoute(Func`2<ISubstituteState, IRoute> getRoute);
    public abstract virtual void SetReturnForType(Type type, IReturn returnValue);
    public abstract virtual void RegisterCustomCallHandlerFactory(CallHandlerFactory factory);
    public abstract virtual void Clear(ClearOptions clear);
}
public interface NSubstitute.Core.ICallRouterFactory {
    public abstract virtual ICallRouter Create(ISubstituteState substituteState, bool canConfigureBaseCalls);
}
public interface NSubstitute.Core.ICallRouterProvider {
    public abstract virtual ICallRouter GetCallRouter();
}
public interface NSubstitute.Core.ICallRouterResolver {
    public abstract virtual ICallRouter ResolveFor(object substitute);
}
public interface NSubstitute.Core.ICallSpecification {
    public abstract virtual bool IsSatisfiedBy(ICall call);
    public abstract virtual string Format(ICall call);
    public abstract virtual ICallSpecification CreateCopyThatMatchesAnyArguments();
    public abstract virtual void InvokePerArgumentActions(CallInfo callInfo);
    public abstract virtual IEnumerable`1<ArgumentMatchInfo> NonMatchingArguments(ICall call);
    public abstract virtual MethodInfo GetMethodInfo();
    public abstract virtual Type ReturnType();
}
public interface NSubstitute.Core.ICallSpecificationFactory {
    public abstract virtual ICallSpecification CreateFrom(ICall call, MatchArgs matchArgs);
}
public interface NSubstitute.Core.IConfigureCall {
    public abstract virtual ConfiguredCall SetResultForLastCall(IReturn valueToReturn, MatchArgs matchArgs, PendingSpecificationInfo pendingSpecInfo);
    public abstract virtual void SetResultForCall(ICall call, IReturn valueToReturn, MatchArgs matchArgs);
}
public interface NSubstitute.Core.ICustomHandlers {
    public IReadOnlyCollection`1<ICallHandler> Handlers { get; }
    public abstract virtual IReadOnlyCollection`1<ICallHandler> get_Handlers();
    public abstract virtual void AddCustomHandlerFactory(CallHandlerFactory factory);
}
public interface NSubstitute.Core.IDefaultForType {
    public abstract virtual object GetDefaultFor(Type type);
}
public interface NSubstitute.Core.IDescribeNonMatches {
    public abstract virtual string DescribeFor(object argument);
}
public interface NSubstitute.Core.IEventHandlerRegistry {
    public abstract virtual void Add(string eventName, object handler);
    public abstract virtual void Remove(string eventName, object handler);
    public abstract virtual IEnumerable`1<object> GetHandlers(string eventName);
}
public interface NSubstitute.Core.IGetCallSpec {
    public abstract virtual ICallSpecification FromPendingSpecification(MatchArgs matchArgs, PendingSpecificationInfo pendingSpecInfo);
    public abstract virtual ICallSpecification FromExistingSpec(ICallSpecification spec, MatchArgs matchArgs);
    public abstract virtual ICallSpecification FromCall(ICall call, MatchArgs matchArgs);
}
public interface NSubstitute.Core.IMethodInfoFormatter {
    public abstract virtual bool CanFormat(MethodInfo methodInfo);
    public abstract virtual string Format(MethodInfo methodInfo, IEnumerable`1<string> formattedArguments);
}
public interface NSubstitute.Core.IParameterInfo {
    public Type ParameterType { get; }
    public bool IsParams { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public abstract virtual Type get_ParameterType();
    public abstract virtual bool get_IsParams();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsOut();
}
public interface NSubstitute.Core.IPendingSpecification {
    public abstract virtual bool HasPendingCallSpecInfo();
    [NullableContextAttribute("2")]
public abstract virtual PendingSpecificationInfo UseCallSpecInfo();
    public abstract virtual void SetCallSpecification(ICallSpecification callSpecification);
    public abstract virtual void SetLastCall(ICall lastCall);
    public abstract virtual void Clear();
}
public interface NSubstitute.Core.IPropertyHelper {
    public abstract virtual bool IsCallToSetAReadWriteProperty(ICall call);
    public abstract virtual ICall CreateCallToPropertyGetterFromSetterCall(ICall callToSetter);
}
public interface NSubstitute.Core.IProxyFactory {
    public abstract virtual object GenerateProxy(ICallRouter callRouter, Type typeToProxy, Type[] additionalInterfaces, Object[] constructorArguments);
}
public interface NSubstitute.Core.IQuery {
    public abstract virtual void RegisterCall(ICall call);
}
public interface NSubstitute.Core.IQueryResults {
    public abstract virtual IEnumerable`1<ICall> MatchingCallsInOrder();
    public abstract virtual IEnumerable`1<CallSpecAndTarget> QuerySpecification();
}
public interface NSubstitute.Core.IReceivedCallsExceptionThrower {
    public abstract virtual void Throw(ICallSpecification callSpecification, IEnumerable`1<ICall> matchingCalls, IEnumerable`1<ICall> nonMatchingCalls, Quantity requiredQuantity);
}
public interface NSubstitute.Core.IResultsForType {
    public abstract virtual void SetResult(Type type, IReturn resultToReturn);
    public abstract virtual bool TryGetResult(ICall call, Object& result);
    public abstract virtual void Clear();
}
public interface NSubstitute.Core.IReturn {
    public abstract virtual object ReturnFor(CallInfo info);
    [NullableContextAttribute("2")]
public abstract virtual Type TypeOrNull();
    public abstract virtual bool CanBeAssignedTo(Type t);
}
public interface NSubstitute.Core.ISubstituteFactory {
    public abstract virtual object Create(Type[] typesToProxy, Object[] constructorArguments);
    public abstract virtual object CreatePartial(Type[] typesToProxy, Object[] constructorArguments);
}
public interface NSubstitute.Core.ISubstituteState {
    public ICallBaseConfiguration CallBaseConfiguration { get; }
    public ICallCollection ReceivedCalls { get; }
    public ICallResults CallResults { get; }
    public ICallActions CallActions { get; }
    public IConfigureCall ConfigureCall { get; }
    public IEventHandlerRegistry EventHandlerRegistry { get; }
    public IReadOnlyCollection`1<IAutoValueProvider> AutoValueProviders { get; }
    public ICallResults AutoValuesCallResults { get; }
    public IResultsForType ResultsForType { get; }
    public ICustomHandlers CustomHandlers { get; }
    public abstract virtual ICallBaseConfiguration get_CallBaseConfiguration();
    public abstract virtual ICallCollection get_ReceivedCalls();
    public abstract virtual ICallResults get_CallResults();
    public abstract virtual ICallActions get_CallActions();
    public abstract virtual IConfigureCall get_ConfigureCall();
    public abstract virtual IEventHandlerRegistry get_EventHandlerRegistry();
    public abstract virtual IReadOnlyCollection`1<IAutoValueProvider> get_AutoValueProviders();
    public abstract virtual ICallResults get_AutoValuesCallResults();
    public abstract virtual IResultsForType get_ResultsForType();
    public abstract virtual ICustomHandlers get_CustomHandlers();
}
public interface NSubstitute.Core.ISubstituteStateFactory {
    public abstract virtual ISubstituteState Create(ISubstituteFactory substituteFactory);
}
public interface NSubstitute.Core.ISubstitutionContext {
    public ISubstituteFactory SubstituteFactory { get; }
    public IRouteFactory RouteFactory { get; }
    public ICallSpecificationFactory CallSpecificationFactory { get; }
    public IThreadLocalContext ThreadContext { get; }
    [ObsoleteAttribute("This property is obsolete and will be removed in a future version of the product.")]
public SequenceNumberGenerator SequenceNumberGenerator { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("This property is obsolete and will be removed in a future version of the product. Use the ThreadContext.PendingSpecification property instead. For example: SubstitutionContext.Current.ThreadContext.PendingSpecification.")]
public PendingSpecificationInfo PendingSpecificationInfo { get; public set; }
    [ObsoleteAttribute("This property is obsolete and will be removed in a future version of the product. Use the ThreadContext.IsQuerying property instead. For example: SubstitutionContext.Current.ThreadContext.IsQuerying.")]
public bool IsQuerying { get; }
    public abstract virtual ISubstituteFactory get_SubstituteFactory();
    public abstract virtual IRouteFactory get_RouteFactory();
    public abstract virtual ICallSpecificationFactory get_CallSpecificationFactory();
    public abstract virtual IThreadLocalContext get_ThreadContext();
    public abstract virtual ICallRouter GetCallRouterFor(object substitute);
    public abstract virtual SequenceNumberGenerator get_SequenceNumberGenerator();
    [NullableContextAttribute("2")]
public abstract virtual PendingSpecificationInfo get_PendingSpecificationInfo();
    [NullableContextAttribute("2")]
public abstract virtual void set_PendingSpecificationInfo(PendingSpecificationInfo value);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.LastCallShouldReturn() method instead. For example: SubstitutionContext.Current.ThreadContext.LastCallShouldReturn(...).")]
public abstract virtual ConfiguredCall LastCallShouldReturn(IReturn value, MatchArgs matchArgs);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.SetLastCallRouter() method instead. For example: SubstitutionContext.Current.ThreadContext.SetLastCallRouter(...).")]
public abstract virtual void LastCallRouter(ICallRouter callRouter);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.EnqueueArgumentSpecification() method instead. For example: SubstitutionContext.Current.ThreadContext.EnqueueArgumentSpecification(...).")]
public abstract virtual void EnqueueArgumentSpecification(IArgumentSpecification spec);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.DequeueAllArgumentSpecifications() method instead. For example: SubstitutionContext.Current.ThreadContext.DequeueAllArgumentSpecifications().")]
public abstract virtual IList`1<IArgumentSpecification> DequeueAllArgumentSpecifications();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.SetPendingRaisingEventArgumentsFactory() method instead. For example: SubstitutionContext.Current.ThreadContext.SetPendingRaisingEventArgumentsFactory(...).")]
public abstract virtual void RaiseEventForNextCall(Func`2<ICall, Object[]> getArguments);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.UsePendingRaisingEventArgumentsFactory() method instead. For example: SubstitutionContext.Current.ThreadContext.UsePendingRaisingEventArgumentsFactory().")]
public abstract virtual Func`2<ICall, Object[]> DequeuePendingRaisingEventArguments();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.RunInQueryContext() method instead. For example: SubstitutionContext.Current.ThreadContext.RunInQueryContext(...).")]
public abstract virtual IQueryResults RunQuery(Action calls);
    public abstract virtual bool get_IsQuerying();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.RegisterInContextQuery() method instead. For example: SubstitutionContext.Current.ThreadContext.RegisterInContextQuery().", "True")]
public abstract virtual void AddToQuery(object target, ICallSpecification callSpecification);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.ClearLastCallRouter() method instead. For example: SubstitutionContext.Current.ThreadContext.ClearLastCallRouter().")]
public abstract virtual void ClearLastCallRouter();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the RouteFactory property instead.")]
public abstract virtual IRouteFactory GetRouteFactory();
}
public interface NSubstitute.Core.IThreadLocalContext {
    public IPendingSpecification PendingSpecification { get; }
    public bool IsQuerying { get; }
    public abstract virtual IPendingSpecification get_PendingSpecification();
    public abstract virtual void SetLastCallRouter(ICallRouter callRouter);
    public abstract virtual void ClearLastCallRouter();
    public abstract virtual ConfiguredCall LastCallShouldReturn(IReturn value, MatchArgs matchArgs);
    public abstract virtual void SetNextRoute(ICallRouter callRouter, Func`2<ISubstituteState, IRoute> nextRouteFactory);
    public abstract virtual Func`2<ISubstituteState, IRoute> UseNextRoute(ICallRouter callRouter);
    public abstract virtual void EnqueueArgumentSpecification(IArgumentSpecification spec);
    public abstract virtual IList`1<IArgumentSpecification> DequeueAllArgumentSpecifications();
    public abstract virtual void SetPendingRaisingEventArgumentsFactory(Func`2<ICall, Object[]> getArguments);
    public abstract virtual Func`2<ICall, Object[]> UsePendingRaisingEventArgumentsFactory();
    public abstract virtual bool get_IsQuerying();
    public abstract virtual void RunInQueryContext(Action calls, IQuery query);
    public abstract virtual void RegisterInContextQuery(ICall call);
}
[DebuggerDisplayAttribute("{_name}")]
public class NSubstitute.Core.MatchArgs : object {
    private string _name;
    public static MatchArgs AsSpecifiedInCall;
    public static MatchArgs Any;
    private MatchArgs(string name);
    private static MatchArgs();
}
public static class NSubstitute.Core.Maybe : object {
    public static Maybe`1<T> Just(T value);
    public static Maybe`1<T> Nothing();
}
public class NSubstitute.Core.Maybe`1 : ValueType {
    private bool hasValue;
    private T value;
    public Maybe`1(T value);
    public bool HasValue();
    public Maybe`1<T> OrElse(Func`1<Maybe`1<T>> other);
    public Maybe`1<T> OrElse(Maybe`1<T> other);
    public T ValueOr(Func`1<T> other);
    public T ValueOr(T other);
    [NullableContextAttribute("2")]
public T ValueOrDefault();
    public TResult Fold(Func`1<TResult> handleNoValue, Func`2<T, TResult> handleValue);
    [IteratorStateMachineAttribute("NSubstitute.Core.Maybe`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__10")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NSubstitute.Core.MethodFormatter : object {
    public sealed virtual bool CanFormat(MethodInfo methodInfo);
    public sealed virtual string Format(MethodInfo methodInfo, IEnumerable`1<string> arguments);
    private static string FormatGenericType(MethodInfo methodInfoOfCall);
}
internal class NSubstitute.Core.ParameterInfoWrapper : object {
    private ParameterInfo _parameterInfo;
    public Type ParameterType { get; }
    public bool IsParams { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public ParameterInfoWrapper(ParameterInfo parameterInfo);
    public sealed virtual Type get_ParameterType();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsOut();
}
public class NSubstitute.Core.PendingSpecificationInfo : object {
    [NullableAttribute("2")]
private ICallSpecification _callSpecification;
    [NullableAttribute("2")]
private ICall _lastCall;
    [NullableContextAttribute("2")]
private PendingSpecificationInfo(ICallSpecification callSpecification, ICall lastCall);
    public T Handle(Func`2<ICallSpecification, T> onCallSpec, Func`2<ICall, T> onLastCall);
    public static PendingSpecificationInfo FromLastCall(ICall lastCall);
    public static PendingSpecificationInfo FromCallSpecification(ICallSpecification callSpecification);
}
public class NSubstitute.Core.PropertyCallFormatter : object {
    public sealed virtual bool CanFormat(MethodInfo methodInfo);
    public sealed virtual string Format(MethodInfo methodInfo, IEnumerable`1<string> arguments);
    private PropertyInfo GetPropertyFromGetterOrSetterCall(MethodInfo methodInfoOfCall);
    private string FormatPropertyIndexer(int numberOfIndexParameters, IEnumerable`1<string> arguments);
    private bool OnlyHasIndexParameterArgs(int numberOfIndexParameters, IEnumerable`1<string> arguments);
    private string FormatArgsAfterIndexParamsAsSetterArgs(int numberOfIndexParameters, IEnumerable`1<string> arguments);
}
public class NSubstitute.Core.PropertyHelper : object {
    private ICallFactory _callFactory;
    private IArgumentSpecificationCompatibilityTester _argSpecCompatTester;
    public PropertyHelper(ICallFactory callFactory, IArgumentSpecificationCompatibilityTester argSpecCompatTester);
    public sealed virtual bool IsCallToSetAReadWriteProperty(ICall call);
    [NullableContextAttribute("2")]
private bool PropertySetterExistsAndHasAGetMethod(PropertyInfo propertySetter);
    private PropertyInfo GetPropertyFromSetterCall(ICall call);
    public sealed virtual ICall CreateCallToPropertyGetterFromSetterCall(ICall callToSetter);
    private IList`1<IArgumentSpecification> GetGetterCallSpecificationsFromSetterCall(ICall callToSetter);
    private static T[] SkipLast(ICollection`1<T> collection);
}
public class NSubstitute.Core.Query : object {
    private List`1<CallSpecAndTarget> _querySpec;
    private HashSet`1<ICall> _matchingCalls;
    private ICallSpecificationFactory _callSpecificationFactory;
    public Query(ICallSpecificationFactory callSpecificationFactory);
    public sealed virtual void RegisterCall(ICall call);
    public IQueryResults Result();
    private sealed virtual override IEnumerable`1<ICall> NSubstitute.Core.IQueryResults.MatchingCallsInOrder();
    private sealed virtual override IEnumerable`1<CallSpecAndTarget> NSubstitute.Core.IQueryResults.QuerySpecification();
}
public class NSubstitute.Core.ReceivedCallsExceptionThrower : object {
    public sealed virtual void Throw(ICallSpecification callSpecification, IEnumerable`1<ICall> matchingCalls, IEnumerable`1<ICall> nonMatchingCalls, Quantity requiredQuantity);
    private void AppendNonMatchingCalls(ICallSpecification callSpecification, IEnumerable`1<ICall> nonMatchingCalls, StringBuilder builder);
    private void AppendMatchingCalls(ICallSpecification callSpecification, IEnumerable`1<ICall> matchingCalls, StringBuilder builder);
    private void WriteCallsWithRespectToCallSpec(ICallSpecification callSpecification, IEnumerable`1<ICall> relatedCalls, StringBuilder builder);
    private string DescribeNonMatches(ICall call, ICallSpecification callSpecification);
}
[ExtensionAttribute]
public static class NSubstitute.Core.ReflectionExtensions : object {
    [ExtensionAttribute]
public static PropertyInfo GetPropertyFromSetterCallOrNull(MethodInfo call);
    [ExtensionAttribute]
public static PropertyInfo GetPropertyFromGetterCallOrNull(MethodInfo call);
    [ExtensionAttribute]
public static bool IsParams(ParameterInfo parameterInfo);
    private static bool CanBePropertySetterCall(MethodInfo call);
    private static PropertyInfo[] GetAllProperties(Type type);
}
public class NSubstitute.Core.ResultsForType : object {
    private CallResults _results;
    public ResultsForType(ICallInfoFactory callInfoFactory);
    public sealed virtual void SetResult(Type type, IReturn resultToReturn);
    public sealed virtual bool TryGetResult(ICall call, Object& result);
    public sealed virtual void Clear();
}
public class NSubstitute.Core.ReturnMultipleFuncsValues`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentQueue`1<Func`2<CallInfo, T>> _funcsToReturn;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<CallInfo, T> _lastFunc;
    public ReturnMultipleFuncsValues`1(Func`2[] funcs);
    public sealed virtual object ReturnFor(CallInfo info);
    public sealed virtual Type TypeOrNull();
    public sealed virtual bool CanBeAssignedTo(Type t);
    private T GetNext(CallInfo info);
}
public class NSubstitute.Core.ReturnMultipleValues`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentQueue`1<T> _valuesToReturn;
    [NullableAttribute("2")]
private T _lastValue;
    public ReturnMultipleValues`1(T[] values);
    [NullableContextAttribute("2")]
public sealed virtual object GetReturnValue();
    public sealed virtual object ReturnFor(CallInfo info);
    public sealed virtual Type TypeOrNull();
    public sealed virtual bool CanBeAssignedTo(Type t);
    [NullableContextAttribute("2")]
private T GetNext();
}
internal class NSubstitute.Core.ReturnObservable`1 : object {
    [NullableAttribute("2")]
private T _value;
    [NullableContextAttribute("2")]
public ReturnObservable`1(T value);
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public class NSubstitute.Core.ReturnValue : object {
    [NullableAttribute("2")]
private object _value;
    [NullableContextAttribute("2")]
public ReturnValue(object value);
    [NullableContextAttribute("2")]
public sealed virtual object GetReturnValue();
    public sealed virtual object ReturnFor(CallInfo info);
    [NullableContextAttribute("2")]
public sealed virtual Type TypeOrNull();
    public sealed virtual bool CanBeAssignedTo(Type t);
}
public class NSubstitute.Core.ReturnValueFromFunc`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<CallInfo, T> _funcToReturnValue;
    public ReturnValueFromFunc`1(Func`2<CallInfo, T> funcToReturnValue);
    public sealed virtual object ReturnFor(CallInfo info);
    public sealed virtual Type TypeOrNull();
    public sealed virtual bool CanBeAssignedTo(Type t);
    private static Func`2<CallInfo, T> ReturnNull();
}
internal class NSubstitute.Core.RobustThreadLocal`1 : object {
    private ThreadLocal`1<T> _threadLocal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<T> _initialValueFactory;
    public T Value { get; public set; }
    public RobustThreadLocal`1(Func`1<T> initialValueFactory);
    public T get_Value();
    public void set_Value(T value);
}
public class NSubstitute.Core.RouteAction : object {
    private static RouteAction _continue;
    [CompilerGeneratedAttribute]
private bool <HasReturnValue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <ReturnValue>k__BackingField;
    public bool HasReturnValue { get; }
    [NullableAttribute("2")]
public object ReturnValue { get; }
    [NullableContextAttribute("2")]
private RouteAction(bool hasReturnValue, object returnValue);
    private static RouteAction();
    [CompilerGeneratedAttribute]
public bool get_HasReturnValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_ReturnValue();
    public static RouteAction Continue();
    public static RouteAction Return(object value);
}
public class NSubstitute.Core.RouteFactoryCacheWrapper : object {
    private IRouteFactory _factory;
    private CachedRoute _recordReplayCache;
    private CachedRoute _recordCallSpecificationCache;
    public RouteFactoryCacheWrapper(IRouteFactory factory);
    public sealed virtual IRoute RecordReplay(ISubstituteState state);
    public sealed virtual IRoute RecordCallSpecification(ISubstituteState state);
    public sealed virtual IRoute CallQuery(ISubstituteState state);
    public sealed virtual IRoute CheckReceivedCalls(ISubstituteState state, MatchArgs matchArgs, Quantity requiredQuantity);
    public sealed virtual IRoute DoWhenCalled(ISubstituteState state, Action`1<CallInfo> doAction, MatchArgs matchArgs);
    public sealed virtual IRoute DoNotCallBase(ISubstituteState state, MatchArgs matchArgs);
    public sealed virtual IRoute CallBase(ISubstituteState state, MatchArgs matchArgs);
    public sealed virtual IRoute RaiseEvent(ISubstituteState state, Func`2<ICall, Object[]> getEventArguments);
}
public class NSubstitute.Core.SequenceChecking.InstanceTracker : object {
    private Dictionary`2<object, int> _instances;
    private int _counter;
    public int InstanceNumber(object o);
    public int NumberOfInstances();
}
public class NSubstitute.Core.SequenceChecking.SequenceFormatter : object {
    private string _delimiter;
    private CallData[] _query;
    private CallData[] _actualCalls;
    private bool _requiresInstanceNumbers;
    private bool _hasMultipleInstances;
    public SequenceFormatter(string delimiter, CallSpecAndTarget[] querySpec, ICall[] matchingCallsInOrder);
    public string FormatQuery();
    public string FormatActualCalls();
    private string Format(CallData[] calls);
    private bool HasMultipleCallsOnSameType();
    [CompilerGeneratedAttribute]
private string <Format>b__8_0(CallData x);
}
public class NSubstitute.Core.SequenceChecking.SequenceInOrderAssertion : object {
    public void Assert(IQueryResults queryResult);
    private bool Matches(ICall call, CallSpecAndTarget specAndTarget);
    private bool IsNotPropertyGetterCall(MethodInfo methodInfo);
    private string GetExceptionMessage(CallSpecAndTarget[] querySpec, ICall[] matchingCallsInOrder);
    [CompilerGeneratedAttribute]
private bool <Assert>b__0_0(ICall x);
    [CompilerGeneratedAttribute]
private bool <Assert>b__0_1(CallSpecAndTarget x);
    [CompilerGeneratedAttribute]
private <>f__AnonymousType0`3<ICall, ICallSpecification, bool> <Assert>b__0_2(ICall call, CallSpecAndTarget specAndTarget);
}
public class NSubstitute.Core.SequenceNumberGenerator : object {
    private long _current;
    public virtual long Next();
}
public class NSubstitute.Core.SubstituteFactory : object {
    private ISubstituteStateFactory _substituteStateFactory;
    private ICallRouterFactory _callRouterFactory;
    private IProxyFactory _proxyFactory;
    public SubstituteFactory(ISubstituteStateFactory substituteStateFactory, ICallRouterFactory callRouterFactory, IProxyFactory proxyFactory);
    public sealed virtual object Create(Type[] typesToProxy, Object[] constructorArguments);
    public sealed virtual object CreatePartial(Type[] typesToProxy, Object[] constructorArguments);
    private object Create(Type[] typesToProxy, Object[] constructorArguments, bool callBaseByDefault);
    private static Type GetPrimaryProxyType(Type[] typesToProxy);
    private static bool CanCallBaseImplementation(Type primaryProxyType);
}
public class NSubstitute.Core.SubstituteState : object {
    [CompilerGeneratedAttribute]
private ICallBaseConfiguration <CallBaseConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private ICallCollection <ReceivedCalls>k__BackingField;
    [CompilerGeneratedAttribute]
private ICallResults <CallResults>k__BackingField;
    [CompilerGeneratedAttribute]
private ICallActions <CallActions>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigureCall <ConfigureCall>k__BackingField;
    [CompilerGeneratedAttribute]
private IEventHandlerRegistry <EventHandlerRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IAutoValueProvider> <AutoValueProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private ICallResults <AutoValuesCallResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IResultsForType <ResultsForType>k__BackingField;
    [CompilerGeneratedAttribute]
private ICustomHandlers <CustomHandlers>k__BackingField;
    public ICallBaseConfiguration CallBaseConfiguration { get; }
    public ICallCollection ReceivedCalls { get; }
    public ICallResults CallResults { get; }
    public ICallActions CallActions { get; }
    public IConfigureCall ConfigureCall { get; }
    public IEventHandlerRegistry EventHandlerRegistry { get; }
    public IReadOnlyCollection`1<IAutoValueProvider> AutoValueProviders { get; }
    public ICallResults AutoValuesCallResults { get; }
    public IResultsForType ResultsForType { get; }
    public ICustomHandlers CustomHandlers { get; }
    public SubstituteState(ICallSpecificationFactory callSpecificationFactory, ICallInfoFactory callInfoFactory, IReadOnlyCollection`1<IAutoValueProvider> autoValueProviders);
    [CompilerGeneratedAttribute]
public sealed virtual ICallBaseConfiguration get_CallBaseConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual ICallCollection get_ReceivedCalls();
    [CompilerGeneratedAttribute]
public sealed virtual ICallResults get_CallResults();
    [CompilerGeneratedAttribute]
public sealed virtual ICallActions get_CallActions();
    [CompilerGeneratedAttribute]
public sealed virtual IConfigureCall get_ConfigureCall();
    [CompilerGeneratedAttribute]
public sealed virtual IEventHandlerRegistry get_EventHandlerRegistry();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<IAutoValueProvider> get_AutoValueProviders();
    [CompilerGeneratedAttribute]
public sealed virtual ICallResults get_AutoValuesCallResults();
    [CompilerGeneratedAttribute]
public sealed virtual IResultsForType get_ResultsForType();
    [CompilerGeneratedAttribute]
public sealed virtual ICustomHandlers get_CustomHandlers();
}
public class NSubstitute.Core.SubstituteStateFactory : object {
    private ICallSpecificationFactory _callSpecificationFactory;
    private ICallInfoFactory _callInfoFactory;
    private IAutoValueProvidersFactory _autoValueProvidersFactory;
    public SubstituteStateFactory(ICallSpecificationFactory callSpecificationFactory, ICallInfoFactory callInfoFactory, IAutoValueProvidersFactory autoValueProvidersFactory);
    public sealed virtual ISubstituteState Create(ISubstituteFactory substituteFactory);
}
public class NSubstitute.Core.SubstitutionContext : object {
    [CompilerGeneratedAttribute]
private static ISubstitutionContext <Current>k__BackingField;
    private ICallRouterResolver _callRouterResolver;
    [CompilerGeneratedAttribute]
private ISubstituteFactory <SubstituteFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IRouteFactory <RouteFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IThreadLocalContext <ThreadContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ICallSpecificationFactory <CallSpecificationFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private SequenceNumberGenerator <SequenceNumberGenerator>k__BackingField;
    public static ISubstitutionContext Current { get; public set; }
    public ISubstituteFactory SubstituteFactory { get; }
    public IRouteFactory RouteFactory { get; }
    public IThreadLocalContext ThreadContext { get; }
    public ICallSpecificationFactory CallSpecificationFactory { get; }
    [ObsoleteAttribute("This property is obsolete and will be removed in a future version of the product.")]
public SequenceNumberGenerator SequenceNumberGenerator { get; }
    [ObsoleteAttribute("This property is obsolete and will be removed in a future version of the product. Use the ThreadContext.IsQuerying property instead. For example: SubstitutionContext.Current.ThreadContext.IsQuerying.")]
public bool IsQuerying { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("This property is obsolete and will be removed in a future version of the product. Use the ThreadContext.PendingSpecification property instead. For example: SubstitutionContext.Current.ThreadContext.PendingSpecification.")]
public PendingSpecificationInfo PendingSpecificationInfo { get; public set; }
    private static SubstitutionContext();
    public SubstitutionContext(ISubstituteFactory substituteFactory, IRouteFactory routeFactory, ICallSpecificationFactory callSpecificationFactory, IThreadLocalContext threadLocalContext, ICallRouterResolver callRouterResolver, SequenceNumberGenerator sequenceNumberGenerator);
    [CompilerGeneratedAttribute]
public static ISubstitutionContext get_Current();
    [CompilerGeneratedAttribute]
public static void set_Current(ISubstitutionContext value);
    [CompilerGeneratedAttribute]
public sealed virtual ISubstituteFactory get_SubstituteFactory();
    [CompilerGeneratedAttribute]
public sealed virtual IRouteFactory get_RouteFactory();
    [CompilerGeneratedAttribute]
public sealed virtual IThreadLocalContext get_ThreadContext();
    [CompilerGeneratedAttribute]
public sealed virtual ICallSpecificationFactory get_CallSpecificationFactory();
    public sealed virtual ICallRouter GetCallRouterFor(object substitute);
    [CompilerGeneratedAttribute]
public sealed virtual SequenceNumberGenerator get_SequenceNumberGenerator();
    public sealed virtual bool get_IsQuerying();
    [NullableContextAttribute("2")]
public sealed virtual PendingSpecificationInfo get_PendingSpecificationInfo();
    [NullableContextAttribute("2")]
public sealed virtual void set_PendingSpecificationInfo(PendingSpecificationInfo value);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.LastCallShouldReturn() method instead. For example: SubstitutionContext.Current.ThreadContext.LastCallShouldReturn(...).")]
public sealed virtual ConfiguredCall LastCallShouldReturn(IReturn value, MatchArgs matchArgs);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.ClearLastCallRouter() method instead. For example: SubstitutionContext.Current.ThreadContext.ClearLastCallRouter().")]
public sealed virtual void ClearLastCallRouter();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the RouteFactory property instead.")]
public sealed virtual IRouteFactory GetRouteFactory();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.SetLastCallRouter() method instead. For example: SubstitutionContext.Current.ThreadContext.SetLastCallRouter(...).")]
public sealed virtual void LastCallRouter(ICallRouter callRouter);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.EnqueueArgumentSpecification() method instead. For example: SubstitutionContext.Current.ThreadContext.EnqueueArgumentSpecification(...).")]
public sealed virtual void EnqueueArgumentSpecification(IArgumentSpecification spec);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.DequeueAllArgumentSpecifications() method instead. For example: SubstitutionContext.Current.ThreadContext.DequeueAllArgumentSpecifications().")]
public sealed virtual IList`1<IArgumentSpecification> DequeueAllArgumentSpecifications();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.SetPendingRaisingEventArgumentsFactory() method instead. For example: SubstitutionContext.Current.ThreadContext.SetPendingRaisingEventArgumentsFactory(...).")]
public sealed virtual void RaiseEventForNextCall(Func`2<ICall, Object[]> getArguments);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.UsePendingRaisingEventArgumentsFactory() method instead. For example: SubstitutionContext.Current.ThreadContext.UsePendingRaisingEventArgumentsFactory().")]
public sealed virtual Func`2<ICall, Object[]> DequeuePendingRaisingEventArguments();
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.RegisterInContextQuery() method instead. For example: SubstitutionContext.Current.ThreadContext.RegisterInContextQuery().", "True")]
public sealed virtual void AddToQuery(object target, ICallSpecification callSpecification);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future version of the product. Use the ThreadContext.RunInQueryContext() method instead. For example: SubstitutionContext.Current.ThreadContext.RunInQueryContext(...).")]
public sealed virtual IQueryResults RunQuery(Action calls);
}
public class NSubstitute.Core.ThreadLocalContext : object {
    private static IArgumentSpecification[] EmptySpecifications;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RobustThreadLocal`1<ICallRouter> _lastCallRouter;
    private RobustThreadLocal`1<IList`1<IArgumentSpecification>> _argumentSpecifications;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RobustThreadLocal`1<Func`2<ICall, Object[]>> _getArgumentsForRaisingEvent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RobustThreadLocal`1<IQuery> _currentQuery;
    private RobustThreadLocal`1<PendingSpecInfoData> _pendingSpecificationInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private RobustThreadLocal`1<Tuple`2<ICallRouter, Func`2<ISubstituteState, IRoute>>> _nextRouteFactory;
    [CompilerGeneratedAttribute]
private IPendingSpecification <PendingSpecification>k__BackingField;
    public IPendingSpecification PendingSpecification { get; }
    public bool IsQuerying { get; }
    private static ThreadLocalContext();
    [CompilerGeneratedAttribute]
public sealed virtual IPendingSpecification get_PendingSpecification();
    public sealed virtual void SetLastCallRouter(ICallRouter callRouter);
    public sealed virtual ConfiguredCall LastCallShouldReturn(IReturn value, MatchArgs matchArgs);
    public sealed virtual void SetNextRoute(ICallRouter callRouter, Func`2<ISubstituteState, IRoute> nextRouteFactory);
    public sealed virtual Func`2<ISubstituteState, IRoute> UseNextRoute(ICallRouter callRouter);
    public sealed virtual void ClearLastCallRouter();
    public sealed virtual void EnqueueArgumentSpecification(IArgumentSpecification spec);
    public sealed virtual IList`1<IArgumentSpecification> DequeueAllArgumentSpecifications();
    public sealed virtual void SetPendingRaisingEventArgumentsFactory(Func`2<ICall, Object[]> getArguments);
    public sealed virtual Func`2<ICall, Object[]> UsePendingRaisingEventArgumentsFactory();
    public sealed virtual void RunInQueryContext(Action calls, IQuery query);
    public sealed virtual bool get_IsQuerying();
    public sealed virtual void RegisterInContextQuery(ICall call);
}
public class NSubstitute.Core.WhenCalled`1 : object {
    private T _substitute;
    private Action`1<T> _call;
    private MatchArgs _matchArgs;
    private ICallRouter _callRouter;
    private IThreadLocalContext _threadContext;
    private IRouteFactory _routeFactory;
    public WhenCalled`1(ISubstitutionContext context, T substitute, Action`1<T> call, MatchArgs matchArgs);
    public void Do(Action`1<CallInfo> callbackWithArguments);
    public void Do(Callback callback);
    public void DoNotCallBase();
    public void CallBase();
    public void Throw(Exception exception);
    public TException Throw();
    public void Throw(Func`2<CallInfo, Exception> createException);
    [CompilerGeneratedAttribute]
private IRoute <DoNotCallBase>b__9_0(ISubstituteState x);
    [CompilerGeneratedAttribute]
private IRoute <CallBase>b__10_0(ISubstituteState x);
}
[ExtensionAttribute]
public static class NSubstitute.ExceptionExtensions.ExceptionExtensions : object {
    [ExtensionAttribute]
public static ConfiguredCall Throws(object value, Exception ex);
    [ExtensionAttribute]
public static ConfiguredCall Throws(object value);
    [ExtensionAttribute]
public static ConfiguredCall Throws(object value, Func`2<CallInfo, Exception> createException);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsForAnyArgs(object value, Exception ex);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsForAnyArgs(object value);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsForAnyArgs(object value, Func`2<CallInfo, Exception> createException);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsync(Task value, Exception ex);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsync(Task`1<T> value, Exception ex);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsync(Task value);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsync(Task value, Func`2<CallInfo, Exception> createException);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsync(Task`1<T> value, Func`2<CallInfo, Exception> createException);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsyncForAnyArgs(Task value, Exception ex);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsyncForAnyArgs(Task`1<T> value, Exception ex);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsyncForAnyArgs(Task value);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsyncForAnyArgs(Task value, Func`2<CallInfo, Exception> createException);
    [ExtensionAttribute]
public static ConfiguredCall ThrowsAsyncForAnyArgs(Task`1<T> value, Func`2<CallInfo, Exception> createException);
    private static object FromException(object value, Exception exception);
    private static Task TaskFromException(Exception ex);
    private static Task`1<T> TaskFromException(Exception ex);
}
public class NSubstitute.Exceptions.AmbiguousArgumentsException : SubstituteException {
    internal static string NonReportedResolvedSpecificationsKey;
    private static string DefaultErrorMessage;
    private static string TabPadding;
    [CompilerGeneratedAttribute]
private bool <ContainsDefaultMessage>k__BackingField;
    internal bool ContainsDefaultMessage { get; }
    public AmbiguousArgumentsException(string message);
    public AmbiguousArgumentsException(MethodInfo method, IEnumerable`1<object> invocationArguments, IEnumerable`1<IArgumentSpecification> matchedSpecifications, IEnumerable`1<IArgumentSpecification> allSpecifications);
    [CompilerGeneratedAttribute]
internal bool get_ContainsDefaultMessage();
    private static string BuildExceptionMessage(MethodInfo method, IEnumerable`1<object> invocationArguments, IEnumerable`1<IArgumentSpecification> matchedSpecifications, IEnumerable`1<IArgumentSpecification> allSpecifications);
    private static IEnumerable`1<string> FormatMethodParameterTypes(IEnumerable`1<ParameterInfo> parameters);
    private static IEnumerable`1<string> FormatMethodArguments(IEnumerable`1<object> arguments);
    private static IEnumerable`1<string> PadNonMatchedSpecifications(IEnumerable`1<IArgumentSpecification> matchedSpecifications, IEnumerable`1<object> allArguments);
    private static string FormatSpecifications(IEnumerable`1<IArgumentSpecification> specifications);
}
public class NSubstitute.Exceptions.ArgumentIsNotOutOrRefException : SubstituteException {
    private static string WhatProbablyWentWrong;
    public ArgumentIsNotOutOrRefException(int argumentIndex, Type argumentType);
}
public class NSubstitute.Exceptions.ArgumentNotFoundException : SubstituteException {
    public ArgumentNotFoundException(string message);
}
public class NSubstitute.Exceptions.ArgumentSetWithIncompatibleValueException : SubstituteException {
    private static string WhatProbablyWentWrong;
    public ArgumentSetWithIncompatibleValueException(int argumentIndex, Type argumentType, Type typeOfValueWeTriedToAssign);
}
public class NSubstitute.Exceptions.CallSequenceNotFoundException : SubstituteException {
    public CallSequenceNotFoundException(string message);
}
public class NSubstitute.Exceptions.CannotCreateEventArgsException : SubstituteException {
    public CannotCreateEventArgsException(string message);
    public CannotCreateEventArgsException(string message, Exception innerException);
}
public class NSubstitute.Exceptions.CanNotPartiallySubForInterfaceOrDelegateException : SubstituteException {
    public CanNotPartiallySubForInterfaceOrDelegateException(Type type);
    private static string DescribeProblem(Type type);
}
public class NSubstitute.Exceptions.CannotReturnNullForValueType : SubstituteException {
    private static string Description;
    public CannotReturnNullForValueType(Type valueType);
}
public class NSubstitute.Exceptions.CouldNotConfigureCallBaseException : SubstituteException {
    private static string CannotConfigureSingleCallMessage;
    private static string CannotConfigureAllCallsMessage;
    public CouldNotConfigureCallBaseException(string message);
    internal static CouldNotConfigureCallBaseException ForSingleCall();
    internal static CouldNotConfigureCallBaseException ForAllCalls();
}
public class NSubstitute.Exceptions.CouldNotRaiseEventException : SubstituteException {
    protected static string WhatProbablyWentWrong;
}
public class NSubstitute.Exceptions.CouldNotSetReturnDueToMissingInfoAboutLastCallException : CouldNotSetReturnException {
}
public class NSubstitute.Exceptions.CouldNotSetReturnDueToNoLastCallException : CouldNotSetReturnException {
}
public class NSubstitute.Exceptions.CouldNotSetReturnDueToTypeMismatchException : CouldNotSetReturnException {
    public CouldNotSetReturnDueToTypeMismatchException(Type returnType, MethodInfo member);
    private static string DescribeProblem(Type typeOfReturnValue, MethodInfo member);
}
public abstract class NSubstitute.Exceptions.CouldNotSetReturnException : SubstituteException {
    protected static string WhatProbablyWentWrong;
    protected CouldNotSetReturnException(string s);
}
public class NSubstitute.Exceptions.MissingSequenceNumberException : SubstituteException {
}
public class NSubstitute.Exceptions.NotASubstituteException : SubstituteException {
    private static string Explanation;
}
public class NSubstitute.Exceptions.NotRunningAQueryException : SubstituteException {
}
public class NSubstitute.Exceptions.NullSubstituteReferenceException : SubstituteException {
    private static string Explanation;
}
public class NSubstitute.Exceptions.ReceivedCallsException : SubstituteException {
    public ReceivedCallsException(string message);
    public ReceivedCallsException(string message, Exception innerException);
}
public class NSubstitute.Exceptions.RedundantArgumentMatcherException : SubstituteException {
    public RedundantArgumentMatcherException(IEnumerable`1<IArgumentSpecification> remainingSpecifications, IEnumerable`1<IArgumentSpecification> allSpecifications);
    public RedundantArgumentMatcherException(string message);
    private static string FormatErrorMessage(IEnumerable`1<IArgumentSpecification> remainingSpecifications, IEnumerable`1<IArgumentSpecification> allSpecifications);
    private static string FormatSpecifications(IEnumerable`1<IArgumentSpecification> specifications);
}
public class NSubstitute.Exceptions.SubstituteException : Exception {
    public SubstituteException(string message);
    public SubstituteException(string message, Exception innerException);
}
public class NSubstitute.Exceptions.SubstituteInternalException : SubstituteException {
    public SubstituteInternalException(string message);
    public SubstituteInternalException(string message, Exception innerException);
}
public class NSubstitute.Exceptions.UnexpectedArgumentMatcherException : SubstituteException {
    public static string WhatProbablyWentWrong;
    public UnexpectedArgumentMatcherException(string message);
    private static UnexpectedArgumentMatcherException();
}
[ExtensionAttribute]
public static class NSubstitute.Extensions.ConfigurationExtensions : object {
    [ExtensionAttribute]
public static T Configure(T substitute);
}
[ExtensionAttribute]
public static class NSubstitute.Extensions.ReturnsForAllExtensions : object {
    [ExtensionAttribute]
public static void ReturnsForAll(object substitute, T returnThis);
    [ExtensionAttribute]
public static void ReturnsForAll(object substitute, Func`2<CallInfo, T> returnThis);
}
public class NSubstitute.Proxies.CastleDynamicProxy.CastleDynamicProxyFactory : object {
    private ICallFactory _callFactory;
    private IArgumentSpecificationDequeue _argSpecificationDequeue;
    private ProxyGenerator _proxyGenerator;
    private AllMethodsExceptCallRouterCallsHook _allMethodsExceptCallRouterCallsHook;
    public CastleDynamicProxyFactory(ICallFactory callFactory, IArgumentSpecificationDequeue argSpecificationDequeue);
    public sealed virtual object GenerateProxy(ICallRouter callRouter, Type typeToProxy, Type[] additionalInterfaces, Object[] constructorArguments);
    private object GenerateTypeProxy(ICallRouter callRouter, Type typeToProxy, Type[] additionalInterfaces, Object[] constructorArguments);
    private object GenerateDelegateProxy(ICallRouter callRouter, Type delegateType, Type[] additionalInterfaces, Object[] constructorArguments);
    private CastleForwardingInterceptor CreateForwardingInterceptor(ICallRouter callRouter);
    private object CreateProxyUsingCastleProxyGenerator(Type typeToProxy, Type[] additionalInterfaces, Object[] constructorArguments, IInterceptor[] interceptors, ProxyGenerationOptions proxyGenerationOptions);
    private ProxyGenerationOptions GetOptionsToMixinCallRouterProvider(ICallRouter callRouter);
    [NullableContextAttribute("2")]
private static void VerifyNoConstructorArgumentsGivenForInterface(Object[] constructorArguments);
    [NullableContextAttribute("2")]
private static void VerifyNoConstructorArgumentsGivenForDelegate(Object[] constructorArguments);
    private static void VerifyNoAdditionalInterfacesGivenForDelegate(Type[] constructorArguments);
    private static void VerifyClassHasNotBeenPassedAsAnAdditionalInterface(Type[] additionalInterfaces);
    private static bool HasItems(T[] array);
}
public class NSubstitute.Proxies.CastleDynamicProxy.CastleForwardingInterceptor : object {
    private CastleInvocationMapper _invocationMapper;
    private ICallRouter _callRouter;
    private bool _fullDispatchMode;
    public CastleForwardingInterceptor(CastleInvocationMapper invocationMapper, ICallRouter callRouter);
    public sealed virtual void Intercept(IInvocation invocation);
    public void SwitchToFullDispatchMode();
}
public class NSubstitute.Proxies.CastleDynamicProxy.CastleInvocationMapper : object {
    private ICallFactory _callFactory;
    private IArgumentSpecificationDequeue _argSpecificationDequeue;
    public CastleInvocationMapper(ICallFactory callFactory, IArgumentSpecificationDequeue argSpecificationDequeue);
    public virtual ICall Map(IInvocation castleInvocation);
    private static Func`1<object> CreateBaseResultInvocation(IInvocation invocation);
}
public class NSubstitute.Proxies.CastleDynamicProxy.ProxyIdInterceptor : object {
    private Type _primaryProxyType;
    [NullableAttribute("2")]
private string _cachedProxyId;
    public ProxyIdInterceptor(Type primaryProxyType);
    public sealed virtual void Intercept(IInvocation invocation);
    private string GenerateId(IInvocation invocation);
    public static bool IsDefaultToStringMethod(MethodInfo methodInfo);
}
[ObsoleteAttribute("This class is deprecated and will be removed in future versions of the product.")]
public class NSubstitute.Proxies.DelegateProxy.DelegateProxyFactory : object {
    private CastleDynamicProxyFactory _castleObjectProxyFactory;
    public DelegateProxyFactory(CastleDynamicProxyFactory objectProxyFactory);
    public sealed virtual object GenerateProxy(ICallRouter callRouter, Type typeToProxy, Type[] additionalInterfaces, Object[] constructorArguments);
}
[ObsoleteAttribute("This class is deprecated and will be removed in future versions of the product.")]
[AttributeUsageAttribute("64")]
public class NSubstitute.Proxies.DelegateProxy.ProxiedDelegateTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <DelegateType>k__BackingField;
    public Type DelegateType { get; }
    public ProxiedDelegateTypeAttribute(Type delegateType);
    [CompilerGeneratedAttribute]
public Type get_DelegateType();
}
[ObsoleteAttribute("This class is deprecated and will be removed in future versions of the product.")]
public class NSubstitute.Proxies.ProxyFactory : object {
    private IProxyFactory _delegateFactory;
    private IProxyFactory _dynamicProxyFactory;
    public ProxyFactory(IProxyFactory delegateFactory, IProxyFactory dynamicProxyFactory);
    public sealed virtual object GenerateProxy(ICallRouter callRouter, Type typeToProxy, Type[] additionalInterfaces, Object[] constructorArguments);
}
public static class NSubstitute.Raise : object {
    public static EventHandlerWrapper`1<TEventArgs> EventWith(object sender, TEventArgs eventArgs);
    public static EventHandlerWrapper`1<TEventArgs> EventWith(TEventArgs eventArgs);
    public static EventHandlerWrapper`1<TEventArgs> EventWith();
    public static EventHandlerWrapper`1<EventArgs> Event();
    public static DelegateEventWrapper`1<THandler> Event(Object[] arguments);
    private static Object[] FixParamsArrayAmbiguity(Object[] arguments, Type delegateType);
}
public class NSubstitute.Received : object {
    public static void InOrder(Action calls);
}
public abstract class NSubstitute.ReceivedExtensions.Quantity : object {
    public static Quantity Exactly(int number);
    public static Quantity AtLeastOne();
    public static Quantity None();
    public static Quantity Within(int minInclusive, int maxInclusive);
    public abstract virtual bool Matches(IEnumerable`1<T> items);
    public abstract virtual bool RequiresMoreThan(IEnumerable`1<T> items);
    public abstract virtual string Describe(string singularNoun, string pluralNoun);
}
[ExtensionAttribute]
public static class NSubstitute.ReceivedExtensions.ReceivedExtensions : object {
    [ExtensionAttribute]
public static T Received(T substitute, Quantity requiredQuantity);
    [ExtensionAttribute]
public static T ReceivedWithAnyArgs(T substitute, Quantity requiredQuantity);
}
[ExtensionAttribute]
public static class NSubstitute.ReturnsExtensions.ReturnsExtensions : object {
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNull(T value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNullForAnyArgs(T value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNull(Nullable`1<T> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNullForAnyArgs(Nullable`1<T> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNull(Task`1<T> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNull(ValueTask`1<T> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNullForAnyArgs(Task`1<T> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNullForAnyArgs(ValueTask`1<T> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNull(Task`1<Nullable`1<T>> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNullForAnyArgs(Task`1<Nullable`1<T>> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNull(ValueTask`1<Nullable`1<T>> value);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsNullForAnyArgs(ValueTask`1<Nullable`1<T>> value);
}
public class NSubstitute.Routing.AutoValues.AutoArrayProvider : object {
    public sealed virtual bool CanProvideValueFor(Type type);
    public sealed virtual object GetValue(Type type);
}
public class NSubstitute.Routing.AutoValues.AutoObservableProvider : object {
    private Lazy`1<IReadOnlyCollection`1<IAutoValueProvider>> _autoValueProviders;
    public AutoObservableProvider(Lazy`1<IReadOnlyCollection`1<IAutoValueProvider>> autoValueProviders);
    public sealed virtual bool CanProvideValueFor(Type type);
    public sealed virtual object GetValue(Type type);
    private static object GetDefault(Type type);
}
public class NSubstitute.Routing.AutoValues.AutoQueryableProvider : object {
    public sealed virtual bool CanProvideValueFor(Type type);
    public sealed virtual object GetValue(Type type);
}
public class NSubstitute.Routing.AutoValues.AutoStringProvider : object {
    public sealed virtual bool CanProvideValueFor(Type type);
    public sealed virtual object GetValue(Type type);
}
public class NSubstitute.Routing.AutoValues.AutoSubstituteProvider : object {
    private ISubstituteFactory _substituteFactory;
    public AutoSubstituteProvider(ISubstituteFactory substituteFactory);
    public sealed virtual bool CanProvideValueFor(Type type);
    public sealed virtual object GetValue(Type type);
    private bool IsPureVirtualClassWithParameterlessConstructor(Type type);
    private bool HasParameterlessConstructor(Type type);
    private bool IsPureVirtualType(Type type);
    private bool IsCallableFromProxy(MethodBase constructor);
    private bool IsOverridable(MethodInfo methodInfo);
    private bool NotMethodFromObject(MethodInfo methodInfo);
    private bool NotStaticMethod(MethodInfo methodInfo);
    [CompilerGeneratedAttribute]
private bool <HasParameterlessConstructor>b__5_0(ConstructorInfo x);
}
public class NSubstitute.Routing.AutoValues.AutoTaskProvider : object {
    private Lazy`1<IReadOnlyCollection`1<IAutoValueProvider>> _autoValueProviders;
    public AutoTaskProvider(Lazy`1<IReadOnlyCollection`1<IAutoValueProvider>> autoValueProviders);
    public sealed virtual bool CanProvideValueFor(Type type);
    public sealed virtual object GetValue(Type type);
    private static object GetDefault(Type type);
}
public class NSubstitute.Routing.AutoValues.AutoValueProvidersFactory : object {
    public sealed virtual IReadOnlyCollection`1<IAutoValueProvider> CreateProviders(ISubstituteFactory substituteFactory);
}
public interface NSubstitute.Routing.AutoValues.IAutoValueProvider {
    public abstract virtual bool CanProvideValueFor(Type type);
    public abstract virtual object GetValue(Type type);
}
public interface NSubstitute.Routing.AutoValues.IAutoValueProvidersFactory {
    public abstract virtual IReadOnlyCollection`1<IAutoValueProvider> CreateProviders(ISubstituteFactory substituteFactory);
}
public class NSubstitute.Routing.Handlers.AddCallToQueryResultHandler : object {
    private IThreadLocalContext _threadContext;
    public AddCallToQueryResultHandler(IThreadLocalContext threadContext);
    public sealed virtual RouteAction Handle(ICall call);
}
public enum NSubstitute.Routing.Handlers.AutoValueBehaviour : Enum {
    public int value__;
    public static AutoValueBehaviour UseValueForSubsequentCalls;
    public static AutoValueBehaviour ReturnAndForgetValue;
}
public class NSubstitute.Routing.Handlers.CallBaseForCallHandler : object {
    private ICallSpecificationFactory _callSpecificationFactory;
    private ICallBaseConfiguration _callBaseConfig;
    private MatchArgs _matchArgs;
    public CallBaseForCallHandler(ICallSpecificationFactory callSpecificationFactory, ICallBaseConfiguration callBaseConfig, MatchArgs matchArgs);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.CheckReceivedCallsHandler : object {
    private ICallCollection _receivedCalls;
    private ICallSpecificationFactory _callSpecificationFactory;
    private IReceivedCallsExceptionThrower _exceptionThrower;
    private MatchArgs _matchArgs;
    private Quantity _requiredQuantity;
    public CheckReceivedCallsHandler(ICallCollection receivedCalls, ICallSpecificationFactory callSpecificationFactory, IReceivedCallsExceptionThrower exceptionThrower, MatchArgs matchArgs, Quantity requiredQuantity);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.ClearLastCallRouterHandler : object {
    private IThreadLocalContext _threadContext;
    public ClearLastCallRouterHandler(IThreadLocalContext threadContext);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.ClearUnusedCallSpecHandler : object {
    private IPendingSpecification _pendingSpecification;
    public ClearUnusedCallSpecHandler(IPendingSpecification pendingSpecification);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.DoActionsCallHandler : object {
    private ICallActions _callActions;
    public DoActionsCallHandler(ICallActions callActions);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.DoNotCallBaseForCallHandler : object {
    private ICallSpecificationFactory _callSpecificationFactory;
    private ICallBaseConfiguration _callBaseConfig;
    private MatchArgs _matchArgs;
    public DoNotCallBaseForCallHandler(ICallSpecificationFactory callSpecificationFactory, ICallBaseConfiguration callBaseConfig, MatchArgs matchArgs);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.EventSubscriptionHandler : object {
    private IEventHandlerRegistry _eventHandlerRegistry;
    public EventSubscriptionHandler(IEventHandlerRegistry eventHandlerRegistry);
    public sealed virtual RouteAction Handle(ICall call);
    private static bool CanBeSubscribeUnsubscribeCall(ICall call);
    private static void If(ICall call, Func`2<ICall, Predicate`1<EventInfo>> meetsThisSpecification, Action`2<string, object> takeThisAction);
    private static Predicate`1<EventInfo> IsEventSubscription(ICall call);
    private static Predicate`1<EventInfo> IsEventUnsubscription(ICall call);
    private static IEnumerable`1<EventInfo> GetEvents(ICall call, Func`2<ICall, Predicate`1<EventInfo>> createPredicate);
}
public class NSubstitute.Routing.Handlers.PropertySetterHandler : object {
    private IPropertyHelper _propertyHelper;
    private IConfigureCall _configureCall;
    public PropertySetterHandler(IPropertyHelper propertyHelper, IConfigureCall configureCall);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.RaiseEventHandler : object {
    private IEventHandlerRegistry _eventHandlerRegistry;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ICall, Object[]> _getEventArguments;
    public RaiseEventHandler(IEventHandlerRegistry eventHandlerRegistry, Func`2<ICall, Object[]> getEventArguments);
    public sealed virtual RouteAction Handle(ICall call);
    [CompilerGeneratedAttribute]
internal static EventInfo <Handle>g__FindEventInfo|3_0(MethodInfo mi);
}
public class NSubstitute.Routing.Handlers.RecordCallHandler : object {
    private ICallCollection _callCollection;
    private SequenceNumberGenerator _generator;
    public RecordCallHandler(ICallCollection callCollection, SequenceNumberGenerator generator);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.RecordCallSpecificationHandler : object {
    private IPendingSpecification _pendingCallSpecification;
    private ICallSpecificationFactory _callSpecificationFactory;
    private ICallActions _callActions;
    public RecordCallSpecificationHandler(IPendingSpecification pendingCallSpecification, ICallSpecificationFactory callSpecificationFactory, ICallActions callActions);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.ReturnAutoValue : object {
    private IAutoValueProvider[] _autoValueProviders;
    private ICallResults _callResults;
    private ICallSpecificationFactory _callSpecificationFactory;
    private AutoValueBehaviour _autoValueBehaviour;
    public ReturnAutoValue(AutoValueBehaviour autoValueBehaviour, IEnumerable`1<IAutoValueProvider> autoValueProviders, ICallResults callResults, ICallSpecificationFactory callSpecificationFactory);
    public sealed virtual RouteAction Handle(ICall call);
    private object GetResultValueUsingProvider(ICall call, Type type, IAutoValueProvider provider);
}
public class NSubstitute.Routing.Handlers.ReturnConfiguredResultHandler : object {
    private ICallResults _callResults;
    public ReturnConfiguredResultHandler(ICallResults callResults);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.ReturnDefaultForReturnTypeHandler : object {
    private IDefaultForType _defaultForType;
    public ReturnDefaultForReturnTypeHandler(IDefaultForType defaultForType);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.ReturnFromAndConfigureDynamicCall : object {
    private static Type DynamicAttributeType;
    private IConfigureCall _configureCall;
    public ReturnFromAndConfigureDynamicCall(IConfigureCall configureCall);
    private static ReturnFromAndConfigureDynamicCall();
    public sealed virtual RouteAction Handle(ICall call);
    private bool ReturnsDynamic(ICall call);
}
public class NSubstitute.Routing.Handlers.ReturnFromBaseIfRequired : object {
    private ICallBaseConfiguration _config;
    public ReturnFromBaseIfRequired(ICallBaseConfiguration config);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.ReturnFromCustomHandlers : object {
    private ICustomHandlers _customHandlers;
    public ReturnFromCustomHandlers(ICustomHandlers customHandlers);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.ReturnResultForTypeHandler : object {
    private IResultsForType _resultsForType;
    public ReturnResultForTypeHandler(IResultsForType resultsForType);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.SetActionForCallHandler : object {
    private ICallSpecificationFactory _callSpecificationFactory;
    private ICallActions _callActions;
    private Action`1<CallInfo> _action;
    private MatchArgs _matchArgs;
    public SetActionForCallHandler(ICallSpecificationFactory callSpecificationFactory, ICallActions callActions, Action`1<CallInfo> action, MatchArgs matchArgs);
    public sealed virtual RouteAction Handle(ICall call);
}
public class NSubstitute.Routing.Handlers.TrackLastCallHandler : object {
    private IPendingSpecification _pendingSpecification;
    public TrackLastCallHandler(IPendingSpecification pendingSpecification);
    public sealed virtual RouteAction Handle(ICall call);
}
public interface NSubstitute.Routing.IRoute {
    public abstract virtual object Handle(ICall call);
}
public interface NSubstitute.Routing.IRouteFactory {
    public abstract virtual IRoute CallQuery(ISubstituteState state);
    public abstract virtual IRoute CheckReceivedCalls(ISubstituteState state, MatchArgs matchArgs, Quantity requiredQuantity);
    public abstract virtual IRoute DoWhenCalled(ISubstituteState state, Action`1<CallInfo> doAction, MatchArgs matchArgs);
    public abstract virtual IRoute DoNotCallBase(ISubstituteState state, MatchArgs matchArgs);
    public abstract virtual IRoute CallBase(ISubstituteState state, MatchArgs matchArgs);
    public abstract virtual IRoute RaiseEvent(ISubstituteState state, Func`2<ICall, Object[]> getEventArguments);
    public abstract virtual IRoute RecordCallSpecification(ISubstituteState state);
    public abstract virtual IRoute RecordReplay(ISubstituteState state);
}
public class NSubstitute.Routing.Route : object {
    private ICallHandler[] _handlers;
    public IEnumerable`1<ICallHandler> Handlers { get; }
    public Route(ICallHandler[] handlers);
    public IEnumerable`1<ICallHandler> get_Handlers();
    public sealed virtual object Handle(ICall call);
}
public class NSubstitute.Routing.RouteFactory : object {
    private SequenceNumberGenerator _sequenceNumberGenerator;
    private IThreadLocalContext _threadLocalContext;
    private ICallSpecificationFactory _callSpecificationFactory;
    private IReceivedCallsExceptionThrower _receivedCallsExceptionThrower;
    private IPropertyHelper _propertyHelper;
    private IDefaultForType _defaultForType;
    public RouteFactory(SequenceNumberGenerator sequenceNumberGenerator, IThreadLocalContext threadLocalContext, ICallSpecificationFactory callSpecificationFactory, IReceivedCallsExceptionThrower receivedCallsExceptionThrower, IPropertyHelper propertyHelper, IDefaultForType defaultForType);
    public sealed virtual IRoute CallQuery(ISubstituteState state);
    public sealed virtual IRoute CheckReceivedCalls(ISubstituteState state, MatchArgs matchArgs, Quantity requiredQuantity);
    public sealed virtual IRoute DoWhenCalled(ISubstituteState state, Action`1<CallInfo> doAction, MatchArgs matchArgs);
    public sealed virtual IRoute DoNotCallBase(ISubstituteState state, MatchArgs matchArgs);
    public sealed virtual IRoute CallBase(ISubstituteState state, MatchArgs matchArgs);
    public sealed virtual IRoute RaiseEvent(ISubstituteState state, Func`2<ICall, Object[]> getEventArguments);
    public sealed virtual IRoute RecordCallSpecification(ISubstituteState state);
    public sealed virtual IRoute RecordReplay(ISubstituteState state);
    private ReturnDefaultForReturnTypeHandler ReturnDefaultForReturnTypeHandler();
}
public static class NSubstitute.Substitute : object {
    public static T For(Object[] constructorArguments);
    public static T1 For(Object[] constructorArguments);
    public static T1 For(Object[] constructorArguments);
    public static object For(Type[] typesToProxy, Object[] constructorArguments);
    public static T ForPartsOf(Object[] constructorArguments);
}
[ExtensionAttribute]
public static class NSubstitute.SubstituteExtensions : object {
    [ExtensionAttribute]
public static T Received(T substitute);
    [ExtensionAttribute]
public static T Received(T substitute, int requiredNumberOfCalls);
    [ExtensionAttribute]
public static T DidNotReceive(T substitute);
    [ExtensionAttribute]
public static T ReceivedWithAnyArgs(T substitute);
    [ExtensionAttribute]
public static T ReceivedWithAnyArgs(T substitute, int requiredNumberOfCalls);
    [ExtensionAttribute]
public static T DidNotReceiveWithAnyArgs(T substitute);
    [ExtensionAttribute]
public static IEnumerable`1<ICall> ReceivedCalls(T substitute);
    [ExtensionAttribute]
public static void ClearReceivedCalls(T substitute);
    [ExtensionAttribute]
public static ConfiguredCall Returns(T value, T returnThis, T[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall Returns(T value, Func`2<CallInfo, T> returnThis, Func`2[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsForAnyArgs(T value, T returnThis, T[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsForAnyArgs(T value, Func`2<CallInfo, T> returnThis, Func`2[] returnThese);
    private static ConfiguredCall ConfigureReturn(MatchArgs matchArgs, T returnThis, T[] returnThese);
    private static ConfiguredCall ConfigureReturn(MatchArgs matchArgs, Func`2<CallInfo, T> returnThis, Func`2[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall Returns(Task`1<T> value, T returnThis, T[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall Returns(Task`1<T> value, Func`2<CallInfo, T> returnThis, Func`2[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsForAnyArgs(Task`1<T> value, T returnThis, T[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsForAnyArgs(Task`1<T> value, Func`2<CallInfo, T> returnThis, Func`2[] returnThese);
    private static void ReThrowOnNSubstituteFault(Task`1<T> task);
    private static Task`1<T> CompletedTask(T result);
    private static Func`2<CallInfo, Task`1<T>> WrapFuncInTask(Func`2<CallInfo, T> returnThis);
    [ExtensionAttribute]
public static ConfiguredCall Returns(ValueTask`1<T> value, T returnThis, T[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall Returns(ValueTask`1<T> value, Func`2<CallInfo, T> returnThis, Func`2[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsForAnyArgs(ValueTask`1<T> value, T returnThis, T[] returnThese);
    [ExtensionAttribute]
public static ConfiguredCall ReturnsForAnyArgs(ValueTask`1<T> value, Func`2<CallInfo, T> returnThis, Func`2[] returnThese);
    private static void ReThrowOnNSubstituteFault(ValueTask`1<T> task);
    private static ValueTask`1<T> CompletedValueTask(T result);
    private static Func`2<CallInfo, ValueTask`1<T>> WrapFuncInValueTask(Func`2<CallInfo, T> returnThis);
    [ExtensionAttribute]
public static WhenCalled`1<T> When(T substitute, Action`1<T> substituteCall);
    [ExtensionAttribute]
public static WhenCalled`1<T> WhenForAnyArgs(T substitute, Action`1<T> substituteCall);
    private static WhenCalled`1<TSubstitute> MakeWhenCalled(TSubstitute substitute, Action`1<TSubstitute> action, MatchArgs matchArgs);
    [ExtensionAttribute]
public static WhenCalled`1<T> When(T substitute, Func`2<T, Task> substituteCall);
    [ExtensionAttribute]
public static WhenCalled`1<T> WhenForAnyArgs(T substitute, Func`2<T, Task> substituteCall);
    [ExtensionAttribute]
public static WhenCalled`1<TSubstitute> When(TSubstitute substitute, Func`2<TSubstitute, ValueTask`1<TResult>> substituteCall);
    [ExtensionAttribute]
public static WhenCalled`1<TSubstitute> WhenForAnyArgs(TSubstitute substitute, Func`2<TSubstitute, ValueTask`1<TResult>> substituteCall);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
