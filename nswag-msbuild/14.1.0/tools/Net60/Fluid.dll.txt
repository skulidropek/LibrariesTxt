public class Fluid.Accessors.AsyncDelegateAccessor : AsyncDelegateAccessor`2<object, object> {
    public AsyncDelegateAccessor(Func`3<object, string, Task`1<object>> getter);
}
public class Fluid.Accessors.AsyncDelegateAccessor`2 : object {
    private Func`4<T, string, TemplateContext, Task`1<TResult>> _getter;
    public AsyncDelegateAccessor`2(Func`4<T, string, TemplateContext, Task`1<TResult>> getter);
    public sealed virtual object Get(object obj, string name, TemplateContext ctx);
    public Task`1<TResult> GetAsync(T obj, string name, TemplateContext ctx);
    [AsyncStateMachineAttribute("Fluid.Accessors.AsyncDelegateAccessor`2/<Fluid-IAsyncMemberAccessor-GetAsync>d__4")]
private sealed virtual override Task`1<object> Fluid.IAsyncMemberAccessor.GetAsync(object obj, string name, TemplateContext ctx);
}
public class Fluid.Accessors.DelegateAccessor : DelegateAccessor`2<object, object> {
    public DelegateAccessor(Func`3<object, string, object> getter);
}
public class Fluid.Accessors.DelegateAccessor`2 : object {
    private Func`4<T, string, TemplateContext, TResult> _getter;
    public DelegateAccessor`2(Func`4<T, string, TemplateContext, TResult> getter);
    private sealed virtual override object Fluid.IMemberAccessor.Get(object obj, string name, TemplateContext ctx);
}
public class Fluid.Accessors.MethodInfoAccessor : object {
    private MethodInfo _methodInfo;
    public MethodInfoAccessor(MethodInfo methodInfo);
    public sealed virtual object Get(object obj, string name, TemplateContext ctx);
}
public class Fluid.Accessors.PropertyInfoAccessor : object {
    private IInvoker _invoker;
    public PropertyInfoAccessor(PropertyInfo propertyInfo);
    public sealed virtual object Get(object obj, string name, TemplateContext ctx);
}
public class Fluid.Ast.AssignStatement : Statement {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Value>k__BackingField;
    public string Identifier { get; }
    public Expression Value { get; }
    public AssignStatement(string identifier, Expression value);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public Expression get_Value();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.AssignStatement/<<WriteToAsync>g__Awaited|7_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Completion> <WriteToAsync>g__Awaited|7_0(ValueTask`1<FluidValue> task, TemplateContext context, string identifier);
}
public abstract class Fluid.Ast.BinaryExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Right>k__BackingField;
    public Expression Left { get; }
    public Expression Right { get; }
    protected BinaryExpression(Expression left, Expression right);
    [CompilerGeneratedAttribute]
public Expression get_Left();
    [CompilerGeneratedAttribute]
public Expression get_Right();
    public virtual ValueTask`1<FluidValue> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.BinaryExpression/<Awaited>d__8")]
private ValueTask`1<FluidValue> Awaited(ValueTask`1<FluidValue> leftTask, ValueTask`1<FluidValue> rightTask);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.AddBinaryExpression : BinaryExpression {
    public AddBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.AndBinaryExpression : BinaryExpression {
    public AndBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.ContainsBinaryExpression : BinaryExpression {
    public ContainsBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.DivideBinaryExpression : BinaryExpression {
    public DivideBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.EndsWithBinaryExpression : BinaryExpression {
    public EndsWithBinaryExpression(Expression left, Expression right);
    [AsyncStateMachineAttribute("Fluid.Ast.BinaryExpressions.EndsWithBinaryExpression/<EvaluateAsync>d__1")]
public virtual ValueTask`1<FluidValue> EvaluateAsync(TemplateContext context);
}
public class Fluid.Ast.BinaryExpressions.EqualBinaryExpression : BinaryExpression {
    public EqualBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.GreaterThanBinaryExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    public bool Strict { get; }
    public GreaterThanBinaryExpression(Expression left, Expression right, bool strict);
    [CompilerGeneratedAttribute]
public bool get_Strict();
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.LowerThanExpression : BinaryExpression {
    [CompilerGeneratedAttribute]
private bool <Strict>k__BackingField;
    public bool Strict { get; }
    public LowerThanExpression(Expression left, Expression right, bool strict);
    [CompilerGeneratedAttribute]
public bool get_Strict();
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.ModuloBinaryExpression : BinaryExpression {
    public ModuloBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.MultiplyBinaryExpression : BinaryExpression {
    public MultiplyBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.NotEqualBinaryExpression : BinaryExpression {
    public NotEqualBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.OrBinaryExpression : BinaryExpression {
    public OrBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BinaryExpressions.StartsWithBinaryExpression : BinaryExpression {
    public StartsWithBinaryExpression(Expression left, Expression right);
    [AsyncStateMachineAttribute("Fluid.Ast.BinaryExpressions.StartsWithBinaryExpression/<EvaluateAsync>d__1")]
public virtual ValueTask`1<FluidValue> EvaluateAsync(TemplateContext context);
}
public class Fluid.Ast.BinaryExpressions.SubstractBinaryExpression : BinaryExpression {
    public SubstractBinaryExpression(Expression left, Expression right);
    internal virtual FluidValue Evaluate(FluidValue leftValue, FluidValue rightValue);
}
public class Fluid.Ast.BreakStatement : Statement {
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.CallbackStatement : Statement {
    [CompilerGeneratedAttribute]
private Func`4<TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> <Action>k__BackingField;
    public Func`4<TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> Action { get; }
    public CallbackStatement(Func`4<TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> action);
    [CompilerGeneratedAttribute]
public Func`4<TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> get_Action();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.CaptureStatement : TagStatement {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; }
    public CaptureStatement(string identifier, List`1<Statement> statements);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [AsyncStateMachineAttribute("Fluid.Ast.CaptureStatement/<WriteToAsync>d__4")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.CaseStatement : TagStatement {
    private WhenStatement[] _whenStatements;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private ElseStatement <Else>k__BackingField;
    public Expression Expression { get; }
    public ElseStatement Else { get; }
    public IReadOnlyList`1<WhenStatement> Whens { get; }
    public CaseStatement(Expression expression, ElseStatement elseStatement, WhenStatement[] whenStatements);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public ElseStatement get_Else();
    public IReadOnlyList`1<WhenStatement> get_Whens();
    [AsyncStateMachineAttribute("Fluid.Ast.CaseStatement/<WriteToAsync>d__10")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.CommentStatement : Statement {
    private TextSpan _text;
    [IsReadOnlyAttribute]
public TextSpan& modreq(System.Runtime.InteropServices.InAttribute) Text { get; }
    public CommentStatement(TextSpan& text);
    public TextSpan& modreq(System.Runtime.InteropServices.InAttribute) get_Text();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public enum Fluid.Ast.Completion : Enum {
    public int value__;
    public static Completion Normal;
    public static Completion Break;
    public static Completion Continue;
}
public class Fluid.Ast.ContinueStatement : Statement {
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.CycleStatement : Statement {
    private Expression[] _values;
    [CompilerGeneratedAttribute]
private Expression <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Expression> <Values2>k__BackingField;
    public Expression Group { get; }
    public IList`1<Expression> Values2 { get; }
    public CycleStatement(Expression group, Expression[] values);
    public CycleStatement(Expression group, IList`1<Expression> values);
    [CompilerGeneratedAttribute]
public Expression get_Group();
    [CompilerGeneratedAttribute]
public IList`1<Expression> get_Values2();
    [AsyncStateMachineAttribute("Fluid.Ast.CycleStatement/<WriteToAsync>d__9")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.DecrementStatement : Statement {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; }
    public DecrementStatement(string identifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.ElseIfStatement : TagStatement {
    [CompilerGeneratedAttribute]
private Expression <Condition>k__BackingField;
    public Expression Condition { get; }
    public ElseIfStatement(Expression condition, List`1<Statement> statements);
    [CompilerGeneratedAttribute]
public Expression get_Condition();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.ElseIfStatement/<Awaited>d__5")]
private ValueTask`1<Completion> Awaited(ValueTask`1<Completion> task, int startIndex, TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.ElseStatement : TagStatement {
    public ElseStatement(List`1<Statement> statements);
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.ElseStatement/<Awaited>d__2")]
private ValueTask`1<Completion> Awaited(ValueTask`1<Completion> task, int startIndex, TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public abstract class Fluid.Ast.Expression : object {
    public abstract virtual ValueTask`1<FluidValue> EvaluateAsync(TemplateContext context);
}
[IsReadOnlyAttribute]
public class Fluid.Ast.FilterArgument : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public string Name { get; }
    public Expression Expression { get; }
    public FilterArgument(string name, Expression expression);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
}
public class Fluid.Ast.FilterExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FilterArgument> <Parameters>k__BackingField;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _canBeCached;
    private FilterArguments modreq(System.Runtime.CompilerServices.IsVolatile) _cachedArguments;
    public Expression Input { get; }
    public string Name { get; }
    public List`1<FilterArgument> Parameters { get; }
    public FilterExpression(Expression input, string name, List`1<FilterArgument> parameters);
    [CompilerGeneratedAttribute]
public Expression get_Input();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public List`1<FilterArgument> get_Parameters();
    [AsyncStateMachineAttribute("Fluid.Ast.FilterExpression/<EvaluateAsync>d__12")]
public virtual ValueTask`1<FluidValue> EvaluateAsync(TemplateContext context);
}
public class Fluid.Ast.ForStatement : TagStatement {
    private bool _isContinueOffset;
    private string _continueOffsetLiteral;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private RangeExpression <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Reversed>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Else>k__BackingField;
    public string Identifier { get; }
    public RangeExpression Range { get; }
    public Expression Source { get; }
    public Expression Limit { get; }
    public Expression Offset { get; }
    public bool Reversed { get; }
    public Statement Else { get; }
    public ForStatement(List`1<Statement> statements, string identifier, Expression source, Expression limit, Expression offset, bool reversed, ElseStatement elseStatement);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public RangeExpression get_Range();
    [CompilerGeneratedAttribute]
public Expression get_Source();
    [CompilerGeneratedAttribute]
public Expression get_Limit();
    [CompilerGeneratedAttribute]
public Expression get_Offset();
    [CompilerGeneratedAttribute]
public bool get_Reversed();
    [CompilerGeneratedAttribute]
public Statement get_Else();
    [AsyncStateMachineAttribute("Fluid.Ast.ForStatement/<WriteToAsync>d__24")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.FromStatement : Statement {
    public static string ViewExtension;
    private FluidParser _parser;
    private CachedTemplate modreq(System.Runtime.CompilerServices.IsVolatile) _cachedTemplate;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private Expression <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Functions>k__BackingField;
    public Expression Path { get; }
    public List`1<string> Functions { get; }
    public FromStatement(FluidParser parser, Expression path, List`1<string> functions);
    [CompilerGeneratedAttribute]
public Expression get_Path();
    [CompilerGeneratedAttribute]
public List`1<string> get_Functions();
    [AsyncStateMachineAttribute("Fluid.Ast.FromStatement/<WriteToAsync>d__11")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
[IsReadOnlyAttribute]
public class Fluid.Ast.FunctionCallArgument : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public string Name { get; }
    public Expression Expression { get; }
    public FunctionCallArgument(string name, Expression expression);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
}
public class Fluid.Ast.FunctionCallSegment : MemberSegment {
    private static FunctionArguments NonCacheableArguments;
    private FunctionArguments modreq(System.Runtime.CompilerServices.IsVolatile) _cachedArguments;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FunctionCallArgument> <Arguments>k__BackingField;
    public IReadOnlyList`1<FunctionCallArgument> Arguments { get; }
    public FunctionCallSegment(IReadOnlyList`1<FunctionCallArgument> arguments);
    private static FunctionCallSegment();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FunctionCallArgument> get_Arguments();
    [AsyncStateMachineAttribute("Fluid.Ast.FunctionCallSegment/<ResolveAsync>d__6")]
public virtual ValueTask`1<FluidValue> ResolveAsync(FluidValue value, TemplateContext context);
}
[DebuggerDisplayAttribute("{Identifier,nq}")]
public class Fluid.Ast.IdentifierSegment : MemberSegment {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; }
    public IdentifierSegment(string identifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    public virtual ValueTask`1<FluidValue> ResolveAsync(FluidValue value, TemplateContext context);
}
public class Fluid.Ast.IfStatement : TagStatement {
    private List`1<ElseIfStatement> _elseIfStatements;
    [CompilerGeneratedAttribute]
private Expression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ElseStatement <Else>k__BackingField;
    public Expression Condition { get; }
    public ElseStatement Else { get; }
    public IReadOnlyList`1<ElseIfStatement> ElseIfs { get; }
    public IfStatement(Expression condition, List`1<Statement> statements, ElseStatement elseStatement, List`1<ElseIfStatement> elseIfStatements);
    [CompilerGeneratedAttribute]
public Expression get_Condition();
    [CompilerGeneratedAttribute]
public ElseStatement get_Else();
    public IReadOnlyList`1<ElseIfStatement> get_ElseIfs();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.IfStatement/<Awaited>d__11")]
private ValueTask`1<Completion> Awaited(ValueTask`1<FluidValue> conditionTask, ValueTask`1<Completion> incompleteStatementTask, TextWriter writer, TextEncoder encoder, TemplateContext context, int statementStartIndex);
    [AsyncStateMachineAttribute("Fluid.Ast.IfStatement/<AwaitedElseBranch>d__12")]
private ValueTask`1<Completion> AwaitedElseBranch(ElseIfStatement elseIf, ValueTask`1<FluidValue> conditionTask, Nullable`1<ValueTask`1<Completion>> elseIfTask, TextWriter writer, TextEncoder encoder, TemplateContext context, int startIndex);
}
public class Fluid.Ast.IncludeStatement : Statement {
    public static string ViewExtension;
    private FluidParser _parser;
    private CachedTemplate modreq(System.Runtime.CompilerServices.IsVolatile) _cachedTemplate;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private Expression <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AssignStatement> <AssignStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <With>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <For>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public Expression Path { get; }
    public IList`1<AssignStatement> AssignStatements { get; }
    public Expression With { get; }
    public Expression For { get; }
    public string Alias { get; }
    public IncludeStatement(FluidParser parser, Expression path, Expression with, Expression for, string alias, IList`1<AssignStatement> assignStatements);
    [CompilerGeneratedAttribute]
public Expression get_Path();
    [CompilerGeneratedAttribute]
public IList`1<AssignStatement> get_AssignStatements();
    [CompilerGeneratedAttribute]
public Expression get_With();
    [CompilerGeneratedAttribute]
public Expression get_For();
    [CompilerGeneratedAttribute]
public string get_Alias();
    [AsyncStateMachineAttribute("Fluid.Ast.IncludeStatement/<WriteToAsync>d__20")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.IncrementStatement : Statement {
    public static string Prefix;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; }
    public IncrementStatement(string identifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.IndexerSegment : MemberSegment {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public Expression Expression { get; }
    public IndexerSegment(Expression expression);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [AsyncStateMachineAttribute("Fluid.Ast.IndexerSegment/<ResolveAsync>d__4")]
public virtual ValueTask`1<FluidValue> ResolveAsync(FluidValue value, TemplateContext context);
}
public class Fluid.Ast.LiquidStatement : TagStatement {
    public LiquidStatement(List`1<Statement> statements);
    [AsyncStateMachineAttribute("Fluid.Ast.LiquidStatement/<WriteToAsync>d__1")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.LiteralExpression : Expression {
    [CompilerGeneratedAttribute]
private FluidValue <Value>k__BackingField;
    public FluidValue Value { get; }
    public LiteralExpression(FluidValue value);
    [CompilerGeneratedAttribute]
public FluidValue get_Value();
    public virtual ValueTask`1<FluidValue> EvaluateAsync(TemplateContext context);
}
public class Fluid.Ast.MacroStatement : TagStatement {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FunctionCallArgument> <Arguments>k__BackingField;
    public string Identifier { get; }
    public IReadOnlyList`1<FunctionCallArgument> Arguments { get; }
    public MacroStatement(string identifier, IReadOnlyList`1<FunctionCallArgument> arguments, List`1<Statement> statements);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FunctionCallArgument> get_Arguments();
    [AsyncStateMachineAttribute("Fluid.Ast.MacroStatement/<WriteToAsync>d__7")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.MemberExpression : Expression {
    [CompilerGeneratedAttribute]
private List`1<MemberSegment> <Segments>k__BackingField;
    public List`1<MemberSegment> Segments { get; }
    public MemberExpression(MemberSegment[] segments);
    public MemberExpression(List`1<MemberSegment> segments);
    [CompilerGeneratedAttribute]
public List`1<MemberSegment> get_Segments();
    public virtual ValueTask`1<FluidValue> EvaluateAsync(TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.MemberExpression/<Awaited>d__6")]
private static ValueTask`1<FluidValue> Awaited(ValueTask`1<FluidValue> task, TemplateContext context, List`1<MemberSegment> segments, int startIndex);
}
public abstract class Fluid.Ast.MemberSegment : object {
    public abstract virtual ValueTask`1<FluidValue> ResolveAsync(FluidValue value, TemplateContext context);
}
[DefaultMemberAttribute("Item")]
public class Fluid.Ast.NamedExpressionList : object {
    public static NamedExpressionList Empty;
    private List`1<Expression> _positional;
    private Dictionary`2<string, Expression> _named;
    public int Count { get; }
    public Expression Item { get; }
    public Expression Item { get; }
    public Expression Item { get; }
    public IEnumerable`1<string> Names { get; }
    public IEnumerable`1<Expression> Values { get; }
    public NamedExpressionList(Expression[] values);
    public NamedExpressionList(List`1<FilterArgument> arguments);
    private static NamedExpressionList();
    public int get_Count();
    public bool HasNamed(string name);
    public Expression get_Item(int index);
    public Expression get_Item(string name);
    public Expression get_Item(string name, int index);
    public NamedExpressionList Add(string name, Expression value);
    public IEnumerable`1<string> get_Names();
    public IEnumerable`1<Expression> get_Values();
}
public class Fluid.Ast.OutputStatement : Statement {
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FilterExpression> <Filters>k__BackingField;
    public Expression Expression { get; }
    public IList`1<FilterExpression> Filters { get; }
    public OutputStatement(Expression expression);
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public IList`1<FilterExpression> get_Filters();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.OutputStatement/<<WriteToAsync>g__Awaited|7_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Completion> <WriteToAsync>g__Awaited|7_0(ValueTask`1<FluidValue> t, TextWriter w, TextEncoder enc, TemplateContext ctx);
}
public class Fluid.Ast.RangeExpression : Expression {
    [CompilerGeneratedAttribute]
private Expression <From>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <To>k__BackingField;
    public Expression From { get; }
    public Expression To { get; }
    public RangeExpression(Expression from, Expression to);
    [CompilerGeneratedAttribute]
public Expression get_From();
    [CompilerGeneratedAttribute]
public Expression get_To();
    public virtual ValueTask`1<FluidValue> EvaluateAsync(TemplateContext context);
    private static ArrayValue BuildArray(int start, int end);
    [AsyncStateMachineAttribute("Fluid.Ast.RangeExpression/<Awaited>d__9")]
private static ValueTask`1<FluidValue> Awaited(ValueTask`1<FluidValue> leftTask, ValueTask`1<FluidValue> rightTask);
}
public class Fluid.Ast.RawStatement : Statement {
    private TextSpan _text;
    [IsReadOnlyAttribute]
public TextSpan& modreq(System.Runtime.InteropServices.InAttribute) Text { get; }
    public RawStatement(TextSpan& text);
    public TextSpan& modreq(System.Runtime.InteropServices.InAttribute) get_Text();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.RawStatement/<<WriteToAsync>g__Awaited|4_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Completion> <WriteToAsync>g__Awaited|4_0(Task task);
}
public class Fluid.Ast.RenderStatement : Statement {
    public static string ViewExtension;
    private FluidParser _parser;
    private CachedTemplate modreq(System.Runtime.CompilerServices.IsVolatile) _cachedTemplate;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AssignStatement> <AssignStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <With>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <For>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Path { get; }
    public IList`1<AssignStatement> AssignStatements { get; }
    public Expression With { get; }
    public Expression For { get; }
    public string Alias { get; }
    public RenderStatement(FluidParser parser, string path, Expression with, Expression for, string alias, IList`1<AssignStatement> assignStatements);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public IList`1<AssignStatement> get_AssignStatements();
    [CompilerGeneratedAttribute]
public Expression get_With();
    [CompilerGeneratedAttribute]
public Expression get_For();
    [CompilerGeneratedAttribute]
public string get_Alias();
    [AsyncStateMachineAttribute("Fluid.Ast.RenderStatement/<WriteToAsync>d__20")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public abstract class Fluid.Ast.Statement : object {
    public static ValueTask`1<Completion> Break();
    public static ValueTask`1<Completion> Normal();
    public static ValueTask`1<Completion> Continue();
    public abstract virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public abstract class Fluid.Ast.TagStatement : Statement {
    protected List`1<Statement> _statements;
    public IReadOnlyList`1<Statement> Statements { get; }
    protected TagStatement(List`1<Statement> statements);
    public IReadOnlyList`1<Statement> get_Statements();
}
public class Fluid.Ast.TextSpanStatement : Statement {
    private bool _isStripped;
    private bool _isEmpty;
    private object _synLock;
    private TextSpan _text;
    private string _buffer;
    [CompilerGeneratedAttribute]
private bool <StripLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripRight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NextIsTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NextIsOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreviousIsTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreviousIsOutput>k__BackingField;
    public bool StripLeft { get; public set; }
    public bool StripRight { get; public set; }
    public bool NextIsTag { get; public set; }
    public bool NextIsOutput { get; public set; }
    public bool PreviousIsTag { get; public set; }
    public bool PreviousIsOutput { get; public set; }
    [IsReadOnlyAttribute]
public TextSpan& modreq(System.Runtime.InteropServices.InAttribute) Text { get; }
    public TextSpanStatement(TextSpan& text);
    public TextSpanStatement(string text);
    [CompilerGeneratedAttribute]
public bool get_StripLeft();
    [CompilerGeneratedAttribute]
public void set_StripLeft(bool value);
    [CompilerGeneratedAttribute]
public bool get_StripRight();
    [CompilerGeneratedAttribute]
public void set_StripRight(bool value);
    [CompilerGeneratedAttribute]
public bool get_NextIsTag();
    [CompilerGeneratedAttribute]
public void set_NextIsTag(bool value);
    [CompilerGeneratedAttribute]
public bool get_NextIsOutput();
    [CompilerGeneratedAttribute]
public void set_NextIsOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreviousIsTag();
    [CompilerGeneratedAttribute]
public void set_PreviousIsTag(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreviousIsOutput();
    [CompilerGeneratedAttribute]
public void set_PreviousIsOutput(bool value);
    public TextSpan& modreq(System.Runtime.InteropServices.InAttribute) get_Text();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Ast.TextSpanStatement/<<WriteToAsync>g__Awaited|33_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Completion> <WriteToAsync>g__Awaited|33_0(Task task);
}
public class Fluid.Ast.UnlessStatement : TagStatement {
    [CompilerGeneratedAttribute]
private Expression <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ElseStatement <Else>k__BackingField;
    public Expression Condition { get; }
    public ElseStatement Else { get; }
    public UnlessStatement(Expression condition, List`1<Statement> statements, ElseStatement elseStatement);
    [CompilerGeneratedAttribute]
public Expression get_Condition();
    [CompilerGeneratedAttribute]
public ElseStatement get_Else();
    [AsyncStateMachineAttribute("Fluid.Ast.UnlessStatement/<WriteToAsync>d__7")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.Ast.WhenStatement : TagStatement {
    private IReadOnlyList`1<Expression> _options;
    public IReadOnlyList`1<Expression> Options { get; }
    public WhenStatement(IReadOnlyList`1<Expression> options, List`1<Statement> statements);
    public IReadOnlyList`1<Expression> get_Options();
    [AsyncStateMachineAttribute("Fluid.Ast.WhenStatement/<WriteToAsync>d__4")]
public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.DefaultMemberAccessStrategy : MemberAccessStrategy {
    private object _synLock;
    private Dictionary`2<Type, Dictionary`2<string, IMemberAccessor>> _map;
    public virtual IMemberAccessor GetAccessor(Type type, string name);
    private IMemberAccessor GetAccessorUnlikely(Type type, string name);
    private bool TryGetAccessor(Type type, string name, IMemberAccessor& accessor);
    public virtual void Register(Type type, IEnumerable`1<KeyValuePair`2<string, IMemberAccessor>> accessors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Fluid.ExceptionHelper : object {
    [DoesNotReturnAttribute]
public static void ThrowArgumentNullException(string paramName, string message);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException(string paramName, string message);
    [DoesNotReturnAttribute]
public static void ThrowParseException(string message);
    [DoesNotReturnAttribute]
public static void ThrowMaximumRecursionException();
    [DoesNotReturnAttribute]
public static void ThrowMaximumStatementsException();
}
internal static class Fluid.ExpressionHelper : object {
    internal static string GetPropertyName(Expression`1<Func`2<T, TProp>> expression);
}
[DefaultMemberAttribute("Item")]
public class Fluid.FilterArguments : object {
    public static FilterArguments Empty;
    private List`1<FluidValue> _positional;
    private Dictionary`2<string, FluidValue> _named;
    public int Count { get; }
    public FluidValue Item { get; }
    public IEnumerable`1<string> Names { get; }
    public IEnumerable`1<FluidValue> Values { get; }
    public FilterArguments(FluidValue[] values);
    private static FilterArguments();
    public int get_Count();
    public FluidValue At(int index);
    public bool HasNamed(string name);
    public FluidValue get_Item(string name);
    public FilterArguments Add(FluidValue value);
    public FilterArguments Add(string name, FluidValue value);
    public IEnumerable`1<string> get_Names();
    public IEnumerable`1<FluidValue> get_Values();
    internal Object[] ValuesToObjectArray();
}
public class Fluid.FilterCollection : object {
    private Dictionary`2<string, FilterDelegate> _filters;
    public int Count { get; }
    public FilterCollection(int capacity);
    public int get_Count();
    public void AddFilter(string name, FilterDelegate d);
    public bool TryGetValue(string name, FilterDelegate& filter);
    public void Remove(string name);
    public void Clear();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, FilterDelegate>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Fluid.FilterDelegate : MulticastDelegate {
    public FilterDelegate(object object, IntPtr method);
    public virtual ValueTask`1<FluidValue> Invoke(FluidValue input, FilterArguments arguments, TemplateContext context);
    public virtual IAsyncResult BeginInvoke(FluidValue input, FilterArguments arguments, TemplateContext context, AsyncCallback callback, object object);
    public virtual ValueTask`1<FluidValue> EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Fluid.Filters.ArrayFilters : object {
    [ExtensionAttribute]
public static FilterCollection WithArrayFilters(FilterCollection filters);
    public static ValueTask`1<FluidValue> Join(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> First(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Last(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Concat(FluidValue input, FilterArguments arguments, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Filters.ArrayFilters/<Map>d__5")]
public static ValueTask`1<FluidValue> Map(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Reverse(FluidValue input, FilterArguments arguments, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Filters.ArrayFilters/<Where>d__7")]
public static ValueTask`1<FluidValue> Where(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Size(FluidValue input, FilterArguments arguments, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Filters.ArrayFilters/<Sort>d__9")]
public static ValueTask`1<FluidValue> Sort(FluidValue input, FilterArguments arguments, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Filters.ArrayFilters/<SortNatural>d__10")]
public static ValueTask`1<FluidValue> SortNatural(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Uniq(FluidValue input, FilterArguments arguments, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Filters.ArrayFilters/<Sum>d__12")]
public static ValueTask`1<FluidValue> Sum(FluidValue input, FilterArguments arguments, TemplateContext context);
}
[ExtensionAttribute]
public static class Fluid.Filters.ColorFilters : object {
    [ExtensionAttribute]
public static FilterCollection WithColorFilters(FilterCollection filters);
    public static ValueTask`1<FluidValue> ToRgb(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ToHex(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ToHsl(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ColorExtract(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ColorModify(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> CalculateBrightness(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ColorSaturate(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ColorDesaturate(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ColorLighten(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ColorDarken(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> GetColorDifference(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> GetColorBrightnessDifference(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> GetColorContrast(FluidValue input, FilterArguments arguments, TemplateContext context);
    private static double GetRelativeLuminance(RgbColor color);
    private static RgbColor GetRgbColor(string value);
}
[ExtensionAttribute]
public static class Fluid.Filters.MiscFilters : object {
    private static char KebabCaseSeparator;
    [ExtensionAttribute]
public static FilterCollection WithMiscFilters(FilterCollection filters);
    public static ValueTask`1<FluidValue> Handleize(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Default(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Raw(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Compact(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> UrlEncode(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> UrlDecode(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Base64Encode(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Base64Decode(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Base64UrlSafeEncode(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Base64UrlSafeDecode(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> StripHtml(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Escape(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> EscapeOnce(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ChangeTimeZone(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Date(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> FormatDate(FluidValue input, FilterArguments arguments, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Filters.MiscFilters/<WriteJson>d__18")]
private static ValueTask WriteJson(Utf8JsonWriter writer, FluidValue input, TemplateContext ctx, HashSet`1<object> stack);
    [AsyncStateMachineAttribute("Fluid.Filters.MiscFilters/<Json>d__19")]
public static ValueTask`1<FluidValue> Json(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> FormatNumber(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> FormatString(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> MD5(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Sha1(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Sha256(FluidValue input, FilterArguments arguments, TemplateContext context);
    [CompilerGeneratedAttribute]
internal static bool <Handleize>g__IsCapitalLetter|2_0(char c);
    [CompilerGeneratedAttribute]
internal static void <Date>g__ForStrf|16_0(DateTimeOffset value, string format, StringBuilder result, <>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
internal static string <Date>g__AbbreviatedDayName|16_2(<>c__DisplayClass16_0& , <>c__DisplayClass16_1& );
    [CompilerGeneratedAttribute]
internal static string <Date>g__Format|16_1(long value, int defaultWidth, <>c__DisplayClass16_0& , <>c__DisplayClass16_1& );
}
[ExtensionAttribute]
public static class Fluid.Filters.NumberFilters : object {
    [ExtensionAttribute]
public static FilterCollection WithNumberFilters(FilterCollection filters);
    public static ValueTask`1<FluidValue> Abs(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> AtLeast(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> AtMost(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Ceil(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> DividedBy(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Floor(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Minus(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Modulo(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Plus(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Round(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Times(FluidValue input, FilterArguments arguments, TemplateContext context);
}
[ExtensionAttribute]
public static class Fluid.Filters.StringFilters : object {
    private static string EllipsisString;
    private static StringValue Ellipsis;
    private static NumberValue DefaultTruncateLength;
    private static StringFilters();
    [ExtensionAttribute]
public static FilterCollection WithStringFilters(FilterCollection filters);
    public static ValueTask`1<FluidValue> Append(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Capitalize(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Downcase(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> LStrip(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> RStrip(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> NewLineToBr(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Prepend(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> RemoveFirst(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Remove(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> RemoveLast(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ReplaceFirst(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Replace(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> ReplaceLast(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Slice(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Split(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Strip(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> StripNewLines(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Truncate(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> TruncateWords(FluidValue input, FilterArguments arguments, TemplateContext context);
    public static ValueTask`1<FluidValue> Upcase(FluidValue input, FilterArguments arguments, TemplateContext context);
}
public class Fluid.FluidParser : object {
    public Parser`1<List`1<Statement>> Grammar;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Parser`1<Statement>> <RegisteredTags>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Func`3<Expression, Expression, Expression>> <RegisteredOperators>k__BackingField;
    protected static Parser`1<char> LBrace;
    protected static Parser`1<char> RBrace;
    protected static Parser`1<char> LParen;
    protected static Parser`1<char> RParen;
    protected static Parser`1<char> LBracket;
    protected static Parser`1<char> RBracket;
    protected static Parser`1<char> Equal;
    protected static Parser`1<char> Colon;
    protected static Parser`1<char> Comma;
    protected static Parser`1<char> Dot;
    protected static Parser`1<char> Pipe;
    protected static Parser`1<TextSpan> String;
    protected static Parser`1<decimal> Number;
    protected static Parser`1<string> DoubleEquals;
    protected static Parser`1<string> NotEquals;
    protected static Parser`1<string> Different;
    protected static Parser`1<string> Greater;
    protected static Parser`1<string> Lower;
    protected static Parser`1<string> GreaterOr;
    protected static Parser`1<string> LowerOr;
    protected static Parser`1<string> Contains;
    protected static Parser`1<string> StartsWith;
    protected static Parser`1<string> EndsWith;
    protected static Parser`1<string> BinaryOr;
    protected static Parser`1<string> BinaryAnd;
    protected static Parser`1<string> Identifier;
    protected Parser`1<List`1<FilterArgument>> ArgumentsList;
    protected Parser`1<List`1<FunctionCallArgument>> FunctionCallArgumentsList;
    protected Parser`1<Expression> LogicalExpression;
    protected Parser`1<Expression> CombinatoryExpression;
    protected Deferred`1<Expression> Primary;
    protected Deferred`1<Expression> FilterExpression;
    protected Deferred`1<List`1<Statement>> KnownTagsList;
    protected Deferred`1<List`1<Statement>> AnyTagsList;
    protected static Parser`1<TagResult> OutputStart;
    protected static Parser`1<TagResult> OutputEnd;
    protected static Parser`1<TagResult> TagStart;
    protected static Parser`1<TagResult> TagStartSpaced;
    protected static Parser`1<TagResult> TagEnd;
    protected static LiteralExpression EmptyKeyword;
    protected static LiteralExpression BlankKeyword;
    protected static LiteralExpression TrueKeyword;
    protected static LiteralExpression FalseKeyword;
    public Dictionary`2<string, Parser`1<Statement>> RegisteredTags { get; }
    public Dictionary`2<string, Func`3<Expression, Expression, Expression>> RegisteredOperators { get; }
    public FluidParser(FluidParserOptions parserOptions);
    private static FluidParser();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Parser`1<Statement>> get_RegisteredTags();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Func`3<Expression, Expression, Expression>> get_RegisteredOperators();
    public static Parser`1<string> CreateTag(string tagName);
    public void RegisterIdentifierTag(string tagName, Func`5<string, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public void RegisterIdentifierBlock(string tagName, Func`6<string, IReadOnlyList`1<Statement>, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public void RegisterExpressionBlock(string tagName, Func`6<Expression, IReadOnlyList`1<Statement>, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public void RegisterExpressionTag(string tagName, Func`5<Expression, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public void RegisterParserBlock(string tagName, Parser`1<T> parser, Func`6<T, IReadOnlyList`1<Statement>, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public void RegisterParserTag(string tagName, Parser`1<T> parser, Func`5<T, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public void RegisterEmptyTag(string tagName, Func`4<TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public void RegisterEmptyBlock(string tagName, Func`5<IReadOnlyList`1<Statement>, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public virtual FluidParser Compile();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__51_29(string x);
    [CompilerGeneratedAttribute]
private Expression <.ctor>b__51_30(ValueTuple`2<Expression, ValueTuple`2<string, Expression>> x);
    [CompilerGeneratedAttribute]
private IncludeStatement <.ctor>b__51_46(ValueTuple`2<Expression, List`1<AssignStatement>> x);
    [CompilerGeneratedAttribute]
private IncludeStatement <.ctor>b__51_47(ValueTuple`3<Expression, Expression, string> x);
    [CompilerGeneratedAttribute]
private IncludeStatement <.ctor>b__51_48(ValueTuple`3<Expression, Expression, string> x);
    [CompilerGeneratedAttribute]
private IncludeStatement <.ctor>b__51_49(Expression x);
    [CompilerGeneratedAttribute]
private FromStatement <.ctor>b__51_51(ValueTuple`2<Expression, List`1<string>> x);
    [CompilerGeneratedAttribute]
private FromStatement <.ctor>b__51_52(Expression x);
    [CompilerGeneratedAttribute]
private RenderStatement <.ctor>b__51_55(ValueTuple`2<TextSpan, List`1<AssignStatement>> x);
    [CompilerGeneratedAttribute]
private RenderStatement <.ctor>b__51_56(ValueTuple`3<TextSpan, Expression, string> x);
    [CompilerGeneratedAttribute]
private RenderStatement <.ctor>b__51_57(ValueTuple`3<TextSpan, Expression, string> x);
    [CompilerGeneratedAttribute]
private RenderStatement <.ctor>b__51_58(TextSpan x);
    [CompilerGeneratedAttribute]
private Parser`1<Statement> <.ctor>b__51_81(ParseContext context, string previous);
    [CompilerGeneratedAttribute]
internal static ValueTuple`3<Expression, Expression, bool> <.ctor>g__ReadForStatementConfiguration|51_85(List`1<ForModifier> modifiers);
    [CompilerGeneratedAttribute]
internal static ValueTuple`3<Expression, Expression, bool> <.ctor>g__ReadFromList|51_90(List`1<ForModifier> modifiers);
    [CompilerGeneratedAttribute]
private Parser`1<Statement> <.ctor>b__51_86(ParseContext context, string previous);
    [CompilerGeneratedAttribute]
private Parser`1<Statement> <.ctor>b__51_87(ParseContext context, string previous);
}
[ExtensionAttribute]
public static class Fluid.FluidParserExtensions : object {
    [ExtensionAttribute]
public static IFluidTemplate Parse(FluidParser parser, string template);
    [ExtensionAttribute]
public static bool TryParse(FluidParser parser, string template, IFluidTemplate& result, String& error);
    [ExtensionAttribute]
public static bool TryParse(FluidParser parser, string template, IFluidTemplate& result);
    [ExtensionAttribute]
public static ValueTask`1<Completion> RenderStatementsAsync(IReadOnlyList`1<Statement> statements, TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.FluidParserExtensions/<<RenderStatementsAsync>g__Awaited|3_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Completion> <RenderStatementsAsync>g__Awaited|3_0(ValueTask`1<Completion> task, int startIndex, IReadOnlyList`1<Statement> statements, TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public class Fluid.FluidParserOptions : object {
    [CompilerGeneratedAttribute]
private bool <AllowFunctions>k__BackingField;
    public bool AllowFunctions { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowFunctions();
    [CompilerGeneratedAttribute]
public void set_AllowFunctions(bool value);
}
[ExtensionAttribute]
public static class Fluid.FluidTemplateExtensions : object {
    [ExtensionAttribute]
public static ValueTask`1<string> RenderAsync(IFluidTemplate template, TemplateContext context);
    [ExtensionAttribute]
public static string Render(IFluidTemplate template, TemplateContext context, TextEncoder encoder);
    [ExtensionAttribute]
public static void Render(IFluidTemplate template, TemplateContext context, TextEncoder encoder, TextWriter writer);
    [AsyncStateMachineAttribute("Fluid.FluidTemplateExtensions/<RenderAsync>d__3")]
[ExtensionAttribute]
public static ValueTask`1<string> RenderAsync(IFluidTemplate template, TemplateContext context, TextEncoder encoder, bool isolateContext);
    [ExtensionAttribute]
public static string Render(IFluidTemplate template, TemplateContext context);
    [ExtensionAttribute]
public static ValueTask`1<string> RenderAsync(IFluidTemplate template);
    [ExtensionAttribute]
public static string Render(IFluidTemplate template);
}
[DefaultMemberAttribute("Item")]
public class Fluid.FunctionArguments : object {
    public static FunctionArguments Empty;
    private List`1<FluidValue> _positional;
    private Dictionary`2<string, FluidValue> _named;
    public int Count { get; }
    public FluidValue Item { get; }
    public IEnumerable`1<string> Names { get; }
    public IEnumerable`1<FluidValue> Values { get; }
    public FunctionArguments(FluidValue[] values);
    private static FunctionArguments();
    public int get_Count();
    public FluidValue At(int index);
    public bool HasNamed(string name);
    public FluidValue get_Item(string name);
    public FunctionArguments Add(FluidValue value);
    public FunctionArguments Add(string name, FluidValue value);
    public IEnumerable`1<string> get_Names();
    public IEnumerable`1<FluidValue> get_Values();
    internal Object[] ValuesToObjectArray();
}
public interface Fluid.IAsyncMemberAccessor {
    public abstract virtual Task`1<object> GetAsync(object obj, string name, TemplateContext ctx);
}
public interface Fluid.IFluidTemplate {
    public abstract virtual ValueTask RenderAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public interface Fluid.IMemberAccessor {
    public abstract virtual object Get(object obj, string name, TemplateContext ctx);
}
public abstract class Fluid.MemberAccessStrategy : object {
    [CompilerGeneratedAttribute]
private MemberNameStrategy <MemberNameStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCasing>k__BackingField;
    public MemberNameStrategy MemberNameStrategy { get; public set; }
    public bool IgnoreCasing { get; public set; }
    public abstract virtual IMemberAccessor GetAccessor(Type type, string name);
    public abstract virtual void Register(Type type, IEnumerable`1<KeyValuePair`2<string, IMemberAccessor>> accessors);
    [CompilerGeneratedAttribute]
public MemberNameStrategy get_MemberNameStrategy();
    [CompilerGeneratedAttribute]
public void set_MemberNameStrategy(MemberNameStrategy value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCasing();
    [CompilerGeneratedAttribute]
public void set_IgnoreCasing(bool value);
}
[ExtensionAttribute]
public static class Fluid.MemberAccessStrategyExtensions : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConcurrentDictionary`2<ValueTuple`2<Type, MemberNameStrategy>, Dictionary`2<string, IMemberAccessor>> _typeMembers;
    private static MemberAccessStrategyExtensions();
    internal static Dictionary`2<string, IMemberAccessor> GetTypeMembers(Type type, MemberNameStrategy memberNameStrategy);
    internal static IMemberAccessor GetNamedAccessor(Type type, string name, MemberNameStrategy strategy);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, Type type);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, String[] names);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, Expression`1[] names);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, Type type, String[] names);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, string name, IMemberAccessor getter);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, IMemberAccessor getter);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, Type type, IMemberAccessor getter);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, Func`3<T, string, TResult> accessor);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, Func`4<T, string, TemplateContext, TResult> accessor);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, Func`3<T, string, Task`1<TResult>> accessor);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, Func`4<T, string, TemplateContext, Task`1<TResult>> accessor);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, string name, Func`2<T, Task`1<TResult>> accessor);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, string name, Func`3<T, TemplateContext, Task`1<TResult>> accessor);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, string name, Func`2<T, TResult> accessor);
    [ExtensionAttribute]
public static void Register(MemberAccessStrategy strategy, string name, Func`3<T, TemplateContext, TResult> accessor);
}
public class Fluid.MemberNameStrategies : object {
    public static MemberNameStrategy Default;
    public static MemberNameStrategy CamelCase;
    public static MemberNameStrategy SnakeCase;
    private static MemberNameStrategies();
    private static string RenameDefault(MemberInfo member);
    public static string RenameCamelCase(MemberInfo member);
    public static string RenameSnakeCase(MemberInfo member);
}
public class Fluid.MemberNameStrategy : MulticastDelegate {
    public MemberNameStrategy(object object, IntPtr method);
    public virtual string Invoke(MemberInfo member);
    public virtual IAsyncResult BeginInvoke(MemberInfo member, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class Fluid.NullEncoder : TextEncoder {
    [CompilerGeneratedAttribute]
private static NullEncoder <Default>k__BackingField;
    public static NullEncoder Default { get; }
    public int MaxOutputCharactersPerInputCharacter { get; }
    private static NullEncoder();
    [CompilerGeneratedAttribute]
public static NullEncoder get_Default();
    public virtual int get_MaxOutputCharactersPerInputCharacter();
    public virtual int FindFirstCharacterToEncode(Char* text, int textLength);
    public virtual bool TryEncodeUnicodeScalar(int unicodeScalar, Char* buffer, int bufferLength, Int32& numberOfCharactersWritten);
    public virtual bool WillEncode(int unicodeScalar);
}
public class Fluid.NullMemberAccessor : object {
    public static IMemberAccessor Instance;
    private static NullMemberAccessor();
    private sealed virtual override object Fluid.IMemberAccessor.Get(object obj, string name, TemplateContext ctx);
}
public class Fluid.ParseException : Exception {
    public ParseException(string message);
    public ParseException(string message, Exception innerException);
}
public class Fluid.Parser.CompositeFluidTemplate : object {
    private List`1<IFluidTemplate> _templates;
    public IReadOnlyList`1<IFluidTemplate> Templates { get; }
    public CompositeFluidTemplate(IFluidTemplate[] templates);
    public CompositeFluidTemplate(IEnumerable`1<IFluidTemplate> templates);
    public IReadOnlyList`1<IFluidTemplate> get_Templates();
    [AsyncStateMachineAttribute("Fluid.Parser.CompositeFluidTemplate/<RenderAsync>d__5")]
public sealed virtual ValueTask RenderAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
internal class Fluid.Parser.EmptyBlockStatement : Statement {
    private Func`5<IReadOnlyList`1<Statement>, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> _render;
    [CompilerGeneratedAttribute]
private List`1<Statement> <Statements>k__BackingField;
    public List`1<Statement> Statements { get; }
    public EmptyBlockStatement(List`1<Statement> statements, Func`5<IReadOnlyList`1<Statement>, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    [CompilerGeneratedAttribute]
public List`1<Statement> get_Statements();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
internal class Fluid.Parser.EmptyTagStatement : Statement {
    private Func`4<TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> _render;
    public EmptyTagStatement(Func`4<TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public static class Fluid.Parser.ErrorMessages : object {
    public static string EqualAfterAssignIdentifier;
    public static string IdentifierAfterAssign;
    public static string IdentifierAfterTagStart;
    public static string LogicalExpressionStartsFilter;
    public static string IdentifierAfterPipe;
    public static string ExpectedTagEnd;
    public static string ExpectedOutputEnd;
    public static string ExpectedStringRender;
    public static string FunctionsNotAllowed;
    [ObsoleteAttribute("Error no longer used")]
public static string IdentifierAfterMacro;
    public static string IdentifierAfterTag;
    public static string ParentesesAfterFunctionName;
}
public class Fluid.Parser.FluidParseContext : ParseContext {
    [CompilerGeneratedAttribute]
private TextSpanStatement <PreviousTextSpanStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripNextTextSpanStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreviousIsTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreviousIsOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsideLiquidTag>k__BackingField;
    public TextSpanStatement PreviousTextSpanStatement { get; public set; }
    public bool StripNextTextSpanStatement { get; public set; }
    public bool PreviousIsTag { get; public set; }
    public bool PreviousIsOutput { get; public set; }
    public bool InsideLiquidTag { get; public set; }
    public FluidParseContext(string text);
    [CompilerGeneratedAttribute]
public TextSpanStatement get_PreviousTextSpanStatement();
    [CompilerGeneratedAttribute]
public void set_PreviousTextSpanStatement(TextSpanStatement value);
    [CompilerGeneratedAttribute]
public bool get_StripNextTextSpanStatement();
    [CompilerGeneratedAttribute]
public void set_StripNextTextSpanStatement(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreviousIsTag();
    [CompilerGeneratedAttribute]
public void set_PreviousIsTag(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreviousIsOutput();
    [CompilerGeneratedAttribute]
public void set_PreviousIsOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_InsideLiquidTag();
    [CompilerGeneratedAttribute]
public void set_InsideLiquidTag(bool value);
}
public class Fluid.Parser.FluidTemplate : object {
    private List`1<Statement> _statements;
    public IReadOnlyList`1<Statement> Statements { get; }
    public FluidTemplate(Statement[] statements);
    public FluidTemplate(List`1<Statement> statements);
    public IReadOnlyList`1<Statement> get_Statements();
    public sealed virtual ValueTask RenderAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Parser.FluidTemplate/<Awaited>d__6")]
private static ValueTask Awaited(ValueTask`1<Completion> task, TextWriter writer, TextEncoder encoder, TemplateContext context, IReadOnlyList`1<Statement> statements, int startIndex);
}
public class Fluid.Parser.ForModifier : ValueType {
    public bool IsReversed;
    public bool IsLimit;
    public bool IsOffset;
    public Expression Value;
}
public class Fluid.Parser.IdentifierParser : Parser`1<TextSpan> {
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    private static bool IsNonDigitStart(char ch);
}
internal class Fluid.Parser.ParserBlockStatement`1 : TagStatement {
    private Func`6<T, IReadOnlyList`1<Statement>, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> _render;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; }
    public ParserBlockStatement`1(T value, List`1<Statement> statements, Func`6<T, IReadOnlyList`1<Statement>, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    [CompilerGeneratedAttribute]
public T get_Value();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
internal class Fluid.Parser.ParserTagStatement`1 : Statement {
    private Func`5<T, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> _render;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; }
    public ParserTagStatement`1(T value, Func`5<T, TextWriter, TextEncoder, TemplateContext, ValueTask`1<Completion>> render);
    [CompilerGeneratedAttribute]
public T get_Value();
    public virtual ValueTask`1<Completion> WriteToAsync(TextWriter writer, TextEncoder encoder, TemplateContext context);
}
public static class Fluid.Parser.TagParsers : object {
    public static Parser`1<TagResult> TagStart(bool skipWhiteSpace);
    public static Parser`1<TagResult> TagEnd(bool skipWhiteSpace);
    public static Parser`1<TagResult> OutputTagStart(bool skipWhiteSpace);
    public static Parser`1<TagResult> OutputTagEnd(bool skipWhiteSpace);
}
[IsReadOnlyAttribute]
public class Fluid.Parser.TagResult : ValueType {
    public static TagResult TagOpen;
    public static TagResult TagOpenTrim;
    public static TagResult TagClose;
    public static TagResult TagCloseTrim;
    public bool Open;
    public bool Trim;
    public TagResult(bool open, bool trim);
    private static TagResult();
}
public class Fluid.Scope : object {
    private Dictionary`2<string, FluidValue> _properties;
    private bool _forLoopScope;
    [CompilerGeneratedAttribute]
private Scope <Parent>k__BackingField;
    public IEnumerable`1<string> Properties { get; }
    public Scope Parent { get; private set; }
    public Scope(Scope parent);
    public Scope(Scope parent, bool forLoopScope);
    public IEnumerable`1<string> get_Properties();
    [CompilerGeneratedAttribute]
public Scope get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(Scope value);
    public FluidValue GetValue(string name);
    public void Delete(string name);
    public void DeleteOwn(string name);
    public void SetValue(string name, FluidValue value);
    public void SetOwnValue(string name, FluidValue value);
    public FluidValue GetIndex(FluidValue index);
    public void CopyTo(Scope scope);
}
internal static class Fluid.Shims : object {
}
public class Fluid.TemplateContext : object {
    protected int _recursion;
    protected int _steps;
    [CompilerGeneratedAttribute]
private TemplateOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTimeOffset> <Now>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeZoneInfo <TimeZone>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <LocalScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <RootScope>k__BackingField;
    private Dictionary`2<string, object> _ambientValues;
    [CompilerGeneratedAttribute]
private FluidValue <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowModelMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, string, ValueTask`1<string>> <Captured>k__BackingField;
    public TemplateOptions Options { get; protected set; }
    public CultureInfo CultureInfo { get; public set; }
    public Func`1<DateTimeOffset> Now { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    internal Scope LocalScope { get; internal set; }
    internal Scope RootScope { get; internal set; }
    public Dictionary`2<string, object> AmbientValues { get; }
    public FluidValue Model { get; }
    public bool AllowModelMembers { get; public set; }
    public Func`3<string, string, ValueTask`1<string>> Captured { get; public set; }
    public IEnumerable`1<string> ValueNames { get; }
    public TemplateContext(object model, TemplateOptions options, bool allowModelMembers);
    public TemplateContext(TemplateOptions options);
    public TemplateContext(object model, bool allowModelMembers);
    [CompilerGeneratedAttribute]
public TemplateOptions get_Options();
    [CompilerGeneratedAttribute]
protected void set_Options(TemplateOptions value);
    [CompilerGeneratedAttribute]
public CultureInfo get_CultureInfo();
    [CompilerGeneratedAttribute]
public void set_CultureInfo(CultureInfo value);
    [CompilerGeneratedAttribute]
public Func`1<DateTimeOffset> get_Now();
    [CompilerGeneratedAttribute]
public void set_Now(Func`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public TimeZoneInfo get_TimeZone();
    [CompilerGeneratedAttribute]
public void set_TimeZone(TimeZoneInfo value);
    public void IncrementSteps();
    [CompilerGeneratedAttribute]
internal Scope get_LocalScope();
    [CompilerGeneratedAttribute]
internal void set_LocalScope(Scope value);
    [CompilerGeneratedAttribute]
internal Scope get_RootScope();
    [CompilerGeneratedAttribute]
internal void set_RootScope(Scope value);
    public Dictionary`2<string, object> get_AmbientValues();
    [CompilerGeneratedAttribute]
public FluidValue get_Model();
    [CompilerGeneratedAttribute]
public bool get_AllowModelMembers();
    [CompilerGeneratedAttribute]
public void set_AllowModelMembers(bool value);
    [CompilerGeneratedAttribute]
public Func`3<string, string, ValueTask`1<string>> get_Captured();
    [CompilerGeneratedAttribute]
public void set_Captured(Func`3<string, string, ValueTask`1<string>> value);
    public void EnterChildScope();
    public void EnterForLoopScope();
    public void ReleaseScope();
    public IEnumerable`1<string> get_ValueNames();
    public FluidValue GetValue(string name);
    public TemplateContext SetValue(string name, FluidValue value);
}
[ExtensionAttribute]
public static class Fluid.TemplateContextExtensions : object {
    [ExtensionAttribute]
public static TemplateContext SetValue(TemplateContext context, string name, int value);
    [ExtensionAttribute]
public static TemplateContext SetValue(TemplateContext context, string name, string value);
    [ExtensionAttribute]
public static TemplateContext SetValue(TemplateContext context, string name, char value);
    [ExtensionAttribute]
public static TemplateContext SetValue(TemplateContext context, string name, bool value);
    [ExtensionAttribute]
public static TemplateContext SetValue(TemplateContext context, string name, object value);
    [ExtensionAttribute]
public static TemplateContext SetValue(TemplateContext context, string name, Func`1<FluidValue> factory);
}
public class Fluid.TemplateOptions : object {
    public static TemplateOptions Default;
    [CompilerGeneratedAttribute]
private MemberAccessStrategy <MemberAccessStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileProvider <FileProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CultureInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTimeOffset> <Now>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeZoneInfo <TimeZone>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRecursion>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterCollection <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private Scope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Func`2<object, object>> <ValueConverters>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, string, ValueTask`1<string>> <Captured>k__BackingField;
    [CompilerGeneratedAttribute]
private TrimmingFlags <Trimming>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Greedy>k__BackingField;
    public MemberAccessStrategy MemberAccessStrategy { get; public set; }
    public IFileProvider FileProvider { get; public set; }
    public int MaxSteps { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public Func`1<DateTimeOffset> Now { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    public int MaxRecursion { get; public set; }
    public FilterCollection Filters { get; }
    public Scope Scope { get; }
    public List`1<Func`2<object, object>> ValueConverters { get; }
    public Func`3<string, string, ValueTask`1<string>> Captured { get; public set; }
    public TrimmingFlags Trimming { get; public set; }
    public bool Greedy { get; public set; }
    private static TemplateOptions();
    [CompilerGeneratedAttribute]
public MemberAccessStrategy get_MemberAccessStrategy();
    [CompilerGeneratedAttribute]
public void set_MemberAccessStrategy(MemberAccessStrategy value);
    [CompilerGeneratedAttribute]
public IFileProvider get_FileProvider();
    [CompilerGeneratedAttribute]
public void set_FileProvider(IFileProvider value);
    [CompilerGeneratedAttribute]
public int get_MaxSteps();
    [CompilerGeneratedAttribute]
public void set_MaxSteps(int value);
    [CompilerGeneratedAttribute]
public CultureInfo get_CultureInfo();
    [CompilerGeneratedAttribute]
public void set_CultureInfo(CultureInfo value);
    [CompilerGeneratedAttribute]
public Func`1<DateTimeOffset> get_Now();
    [CompilerGeneratedAttribute]
public void set_Now(Func`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public TimeZoneInfo get_TimeZone();
    [CompilerGeneratedAttribute]
public void set_TimeZone(TimeZoneInfo value);
    [CompilerGeneratedAttribute]
public int get_MaxRecursion();
    [CompilerGeneratedAttribute]
public void set_MaxRecursion(int value);
    [CompilerGeneratedAttribute]
public FilterCollection get_Filters();
    [CompilerGeneratedAttribute]
public Scope get_Scope();
    [CompilerGeneratedAttribute]
public List`1<Func`2<object, object>> get_ValueConverters();
    [CompilerGeneratedAttribute]
public Func`3<string, string, ValueTask`1<string>> get_Captured();
    [CompilerGeneratedAttribute]
public void set_Captured(Func`3<string, string, ValueTask`1<string>> value);
    [CompilerGeneratedAttribute]
public TrimmingFlags get_Trimming();
    [CompilerGeneratedAttribute]
public void set_Trimming(TrimmingFlags value);
    [CompilerGeneratedAttribute]
public bool get_Greedy();
    [CompilerGeneratedAttribute]
public void set_Greedy(bool value);
}
[FlagsAttribute]
public enum Fluid.TrimmingFlags : Enum {
    public int value__;
    public static TrimmingFlags None;
    public static TrimmingFlags TagLeft;
    public static TrimmingFlags TagRight;
    public static TrimmingFlags OutputLeft;
    public static TrimmingFlags OutputRight;
}
public class Fluid.UnsafeMemberAccessStrategy : DefaultMemberAccessStrategy {
    public static UnsafeMemberAccessStrategy Instance;
    private static UnsafeMemberAccessStrategy();
    public virtual IMemberAccessor GetAccessor(Type type, string name);
}
internal class Fluid.Utils.ObjectPool`1 : object {
    private T _firstItem;
    private Element[] _items;
    private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
}
internal class Fluid.Utils.StringBuilderPool : object {
    private static int DefaultPoolCapacity;
    private int _defaultCapacity;
    private static ObjectPool`1<StringBuilderPool> s_poolInstance;
    public StringBuilder Builder;
    private ObjectPool`1<StringBuilderPool> _pool;
    public int Length { get; }
    private StringBuilderPool(ObjectPool`1<StringBuilderPool> pool, int defaultCapacity);
    private static StringBuilderPool();
    public int get_Length();
    internal static ObjectPool`1<StringBuilderPool> CreatePool(int size, int capacity);
    public static StringBuilderPool GetInstance();
    public virtual string ToString();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Fluid.Utils.TaskExtensions : object {
    [ExtensionAttribute]
public static bool IsCompletedSuccessfully(Task t);
}
public class Fluid.Values.ArrayValue : FluidValue {
    public static ArrayValue Empty;
    private FluidValue[] _value;
    public FluidValues Type { get; }
    public FluidValue[] Values { get; }
    public ArrayValue(FluidValue[] value);
    public ArrayValue(IEnumerable`1<FluidValue> value);
    internal ArrayValue(IList`1<FluidValue> value);
    private static ArrayValue();
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    protected virtual FluidValue GetValue(string name, TemplateContext context);
    protected virtual FluidValue GetIndex(FluidValue index, TemplateContext context);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public FluidValue[] get_Values();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual string ToStringValue();
    public virtual object ToObjectValue();
    public virtual bool Contains(FluidValue value);
    public virtual IEnumerable`1<FluidValue> Enumerate(TemplateContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Fluid.Values.BlankValue : FluidValue {
    public static BlankValue Instance;
    public FluidValues Type { get; }
    private static BlankValue();
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual object ToObjectValue();
    public virtual string ToStringValue();
    public virtual bool IsNil();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Fluid.Values.BooleanValue : FluidValue {
    public static BooleanValue False;
    public static BooleanValue True;
    private static object BoxedTrue;
    private static object BoxedFalse;
    private bool _value;
    public FluidValues Type { get; }
    private BooleanValue(bool value);
    private static BooleanValue();
    public virtual FluidValues get_Type();
    public static BooleanValue Create(bool value);
    public virtual bool Equals(FluidValue other);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual string ToStringValue();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual object ToObjectValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Fluid.Values.DateTimeValue : FluidValue {
    private DateTimeOffset _value;
    public FluidValues Type { get; }
    public DateTimeValue(DateTimeOffset value);
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual string ToStringValue();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual object ToObjectValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Fluid.Values.DictionaryDictionaryFluidIndexable : object {
    private IDictionary _dictionary;
    private TemplateOptions _options;
    public int Count { get; }
    public IEnumerable`1<string> Keys { get; }
    public DictionaryDictionaryFluidIndexable(IDictionary dictionary, TemplateOptions options);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("Fluid.Values.DictionaryDictionaryFluidIndexable/<get_Keys>d__6")]
public sealed virtual IEnumerable`1<string> get_Keys();
    public sealed virtual bool TryGetValue(string name, FluidValue& value);
}
public class Fluid.Values.DictionaryValue : FluidValue {
    private IFluidIndexable _value;
    public FluidValues Type { get; }
    public DictionaryValue(IFluidIndexable value);
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual ValueTask`1<FluidValue> GetValueAsync(string name, TemplateContext context);
    protected virtual FluidValue GetIndex(FluidValue index, TemplateContext context);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual string ToStringValue();
    public virtual object ToObjectValue();
    public virtual bool Contains(FluidValue value);
    [IteratorStateMachineAttribute("Fluid.Values.DictionaryValue/<Enumerate>d__13")]
public virtual IEnumerable`1<FluidValue> Enumerate(TemplateContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Fluid.Values.EmptyValue : FluidValue {
    public static EmptyValue Instance;
    public FluidValues Type { get; }
    private static EmptyValue();
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual object ToObjectValue();
    public virtual string ToStringValue();
    public virtual bool IsNil();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Fluid.Values.FactoryValue : FluidValue {
    private Lazy`1<FluidValue> _factory;
    public FluidValues Type { get; }
    public FactoryValue(Func`1<FluidValue> factory);
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual bool Contains(FluidValue value);
    public virtual IEnumerable`1<FluidValue> Enumerate(TemplateContext context);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual ValueTask`1<FluidValue> GetIndexAsync(FluidValue index, TemplateContext context);
    public virtual ValueTask`1<FluidValue> GetValueAsync(string name, TemplateContext context);
    public virtual bool IsNil();
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual object ToObjectValue();
    public virtual string ToString();
    public virtual string ToStringValue();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
}
public abstract class Fluid.Values.FluidValue : object {
    private static Dictionary`2<Type, Type> _genericDictionaryTypeCache;
    public FluidValues Type { get; }
    private static FluidValue();
    public abstract virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    [ConditionalAttribute("DEBUG")]
protected static void AssertWriteToParameters(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public abstract virtual bool Equals(FluidValue other);
    public abstract virtual bool ToBooleanValue();
    public abstract virtual decimal ToNumberValue();
    public abstract virtual string ToStringValue();
    public abstract virtual object ToObjectValue();
    public virtual ValueTask`1<FluidValue> GetValueAsync(string name, TemplateContext context);
    protected virtual FluidValue GetValue(string name, TemplateContext context);
    public virtual ValueTask`1<FluidValue> GetIndexAsync(FluidValue index, TemplateContext context);
    public virtual ValueTask`1<FluidValue> InvokeAsync(FunctionArguments arguments, TemplateContext context);
    protected virtual FluidValue GetIndex(FluidValue index, TemplateContext context);
    public abstract virtual FluidValues get_Type();
    public virtual bool IsNil();
    public bool IsInteger();
    public static FluidValue Create(object value, TemplateOptions options);
    public virtual bool Contains(FluidValue value);
    public virtual IEnumerable`1<FluidValue> Enumerate(TemplateContext context);
    [ObsoleteAttribute("Use Enumerate(TemplateContext) instead.")]
public virtual IEnumerable`1<FluidValue> Enumerate();
    [ObsoleteAttribute("Use Enumerate(TemplateContext) instead.")]
internal virtual String[] ToStringArray();
    [ObsoleteAttribute("Use Enumerate(TemplateContext) instead.")]
internal virtual List`1<FluidValue> ToList();
    [ObsoleteAttribute("Handle the property 'first' in GetValueAsync() instead")]
internal virtual FluidValue FirstOrDefault();
    [ObsoleteAttribute("Handle the property 'first' in GetValueAsync() instead")]
internal virtual FluidValue FirstOrDefault(TemplateContext context);
    [ObsoleteAttribute("Handle the property 'last' in GetValueAsync() instead")]
internal virtual FluidValue LastOrDefault();
    [ObsoleteAttribute("Handle the property 'last' in GetValueAsync() instead")]
internal virtual FluidValue LastOrDefault(TemplateContext context);
    public static ValueTask`1<FluidValue> op_Implicit(FluidValue value);
}
public class Fluid.Values.FluidValueDictionaryFluidIndexable : object {
    private Dictionary`2<string, FluidValue> _dictionary;
    public int Count { get; }
    public IEnumerable`1<string> Keys { get; }
    public FluidValueDictionaryFluidIndexable(IDictionary`2<string, FluidValue> dictionary);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<string> get_Keys();
    public sealed virtual bool TryGetValue(string name, FluidValue& value);
}
[ExtensionAttribute]
public static class Fluid.Values.FluidValueExtensions : object {
    private static string Now;
    private static string Today;
    private static String[] DefaultFormats;
    private static String[] SecondaryFormats;
    private static FluidValueExtensions();
    [ExtensionAttribute]
public static bool TryGetDateTimeInput(FluidValue input, TemplateContext context, DateTimeOffset& result);
    [ExtensionAttribute]
public static FluidValue Or(FluidValue self, FluidValue other);
}
public enum Fluid.Values.FluidValues : Enum {
    public int value__;
    public static FluidValues Nil;
    public static FluidValues Empty;
    public static FluidValues Blank;
    public static FluidValues Array;
    public static FluidValues Boolean;
    public static FluidValues Dictionary;
    public static FluidValues Number;
    public static FluidValues Object;
    public static FluidValues String;
    public static FluidValues DateTime;
}
public class Fluid.Values.ForLoopValue : FluidValue {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index0>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RIndex0>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <First>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Last>k__BackingField;
    public int Length { get; public set; }
    public int Index { get; public set; }
    public int Index0 { get; public set; }
    public int RIndex { get; public set; }
    public int RIndex0 { get; public set; }
    public bool First { get; public set; }
    public bool Last { get; public set; }
    public int Count { get; }
    public FluidValues Type { get; }
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_Index0();
    [CompilerGeneratedAttribute]
public void set_Index0(int value);
    [CompilerGeneratedAttribute]
public int get_RIndex();
    [CompilerGeneratedAttribute]
public void set_RIndex(int value);
    [CompilerGeneratedAttribute]
public int get_RIndex0();
    [CompilerGeneratedAttribute]
public void set_RIndex0(int value);
    [CompilerGeneratedAttribute]
public bool get_First();
    [CompilerGeneratedAttribute]
public void set_First(bool value);
    [CompilerGeneratedAttribute]
public bool get_Last();
    [CompilerGeneratedAttribute]
public void set_Last(bool value);
    public int get_Count();
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual object ToObjectValue();
    public virtual string ToStringValue();
    public virtual ValueTask`1<FluidValue> GetValueAsync(string name, TemplateContext context);
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
}
public class Fluid.Values.FunctionValue : FluidValue {
    public static FunctionValue NoOp;
    private Func`3<FunctionArguments, TemplateContext, ValueTask`1<FluidValue>> _action;
    public FluidValues Type { get; }
    public FunctionValue(Func`3<FunctionArguments, TemplateContext, ValueTask`1<FluidValue>> asyncAction);
    public FunctionValue(Func`3<FunctionArguments, TemplateContext, FluidValue> action);
    private static FunctionValue();
    public virtual FluidValues get_Type();
    public virtual ValueTask`1<FluidValue> InvokeAsync(FunctionArguments arguments, TemplateContext context);
    public virtual bool Equals(FluidValue other);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual object ToObjectValue();
    public virtual string ToStringValue();
    public virtual bool IsNil();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface Fluid.Values.IFluidIndexable {
    public int Count { get; }
    public IEnumerable`1<string> Keys { get; }
    public abstract virtual int get_Count();
    public abstract virtual IEnumerable`1<string> get_Keys();
    public abstract virtual bool TryGetValue(string name, FluidValue& value);
}
public class Fluid.Values.NilValue : FluidValue {
    public static NilValue Instance;
    public static NilValue Empty;
    public FluidValues Type { get; }
    private static NilValue();
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual object ToObjectValue();
    public virtual string ToStringValue();
    public virtual bool IsNil();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Fluid.Values.NumberValue : FluidValue {
    public static NumberValue Zero;
    private static NumberValue[] IntToString;
    private decimal _value;
    public FluidValues Type { get; }
    private static NumberValue();
    private NumberValue(decimal value);
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual string ToStringValue();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual object ToObjectValue();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NumberValue other);
    public virtual int GetHashCode();
    public static NumberValue Create(string value);
    public static NumberValue Create(decimal value);
    internal static NumberValue Create(UInt32 value);
    internal static NumberValue Create(int value);
    public static int GetScale(decimal value);
}
public class Fluid.Values.ObjectDictionaryFluidIndexable`1 : object {
    private IDictionary`2<string, T> _dictionary;
    private TemplateOptions _options;
    public int Count { get; }
    public IEnumerable`1<string> Keys { get; }
    public ObjectDictionaryFluidIndexable`1(IDictionary`2<string, T> dictionary, TemplateOptions options);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<string> get_Keys();
    public sealed virtual bool TryGetValue(string name, FluidValue& value);
}
public class Fluid.Values.ObjectValue : ObjectValueBase {
    public ObjectValue(object value);
}
public abstract class Fluid.Values.ObjectValueBase : FluidValue {
    protected static Char[] MemberSeparators;
    protected Nullable`1<bool> _isModelType;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public FluidValues Type { get; }
    public ObjectValueBase(object value);
    private static ObjectValueBase();
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual FluidValues get_Type();
    public virtual bool Equals(FluidValue other);
    public virtual ValueTask`1<FluidValue> GetValueAsync(string name, TemplateContext context);
    [AsyncStateMachineAttribute("Fluid.Values.ObjectValueBase/<GetNestedValueAsync>d__10")]
private ValueTask`1<FluidValue> GetNestedValueAsync(string name, TemplateContext context);
    public virtual ValueTask`1<FluidValue> GetIndexAsync(FluidValue index, TemplateContext context);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual string ToStringValue();
    public virtual object ToObjectValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [AsyncStateMachineAttribute("Fluid.Values.ObjectValueBase/<<GetValueAsync>g__Awaited|9_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<FluidValue> <GetValueAsync>g__Awaited|9_0(IAsyncMemberAccessor asyncAccessor, object value, string n, TemplateContext ctx);
}
public class Fluid.Values.StringValue : FluidValue {
    public static StringValue Empty;
    private static StringValue[] CharToString;
    private string _value;
    [CompilerGeneratedAttribute]
private bool <Encode>k__BackingField;
    public bool Encode { get; public set; }
    public FluidValues Type { get; }
    private static StringValue();
    public StringValue(string value);
    public StringValue(string value, bool encode);
    [CompilerGeneratedAttribute]
public bool get_Encode();
    [CompilerGeneratedAttribute]
public void set_Encode(bool value);
    public virtual FluidValues get_Type();
    internal static StringValue Create(char c);
    public static StringValue Create(string s);
    public static StringValue Create(string s, bool encode);
    internal static StringValue Create(TextSpan& span);
    public virtual bool Equals(FluidValue other);
    protected virtual FluidValue GetIndex(FluidValue index, TemplateContext context);
    protected virtual FluidValue GetValue(string name, TemplateContext context);
    public virtual bool ToBooleanValue();
    public virtual decimal ToNumberValue();
    public virtual string ToStringValue();
    public virtual void WriteTo(TextWriter writer, TextEncoder encoder, CultureInfo cultureInfo);
    public virtual object ToObjectValue();
    public virtual bool Contains(FluidValue value);
    [IteratorStateMachineAttribute("Fluid.Values.StringValue/<Enumerate>d__25")]
public virtual IEnumerable`1<FluidValue> Enumerate(TemplateContext context);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringValue other);
    public virtual int GetHashCode();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.ExperimentalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string DiagnosticId { get; }
    [NullableAttribute("2")]
public string UrlFormat { get; public set; }
    public ExperimentalAttribute(string diagnosticId);
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_UrlFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[AttributeUsageAttribute("32")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("2240")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CollectionBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public Type BuilderType { get; }
    public string MethodName { get; }
    public CollectionBuilderAttribute(Type builderType, string methodName);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
    [CompilerGeneratedAttribute]
public string get_MethodName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiresLocationAttribute : Attribute {
}
