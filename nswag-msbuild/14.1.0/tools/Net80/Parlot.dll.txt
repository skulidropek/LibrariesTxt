[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.CodePrinter : object {
    public static Func`3<Type, string, string> PrintTypeStripOuterClasses;
    private static string _nonPubStatMethods;
    private static string _nonPubInstMethods;
    private static Char[] _enumValueSeparators;
    public static ObjectToCode DefaultNotRecognizedToCode;
    private static Type[] TypesImplementedByArray;
    private static CodePrinter();
    [ExtensionAttribute]
public static StringBuilder AppendTypeOf(StringBuilder sb, Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static StringBuilder AppendTypeOfList(StringBuilder sb, Type[] types, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
internal static StringBuilder AppendMember(StringBuilder sb, MemberInfo member, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendField(StringBuilder sb, FieldInfo field, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendProperty(StringBuilder sb, PropertyInfo property, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendEnum(StringBuilder sb, TEnum value, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static StringBuilder AppendMethod(StringBuilder sb, MethodInfo method, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendName(StringBuilder sb, string name, string typeCode, T identity, string suffix);
    [ExtensionAttribute]
internal static StringBuilder AppendName(StringBuilder sb, string name, Type type, T identity, string suffix);
    [ExtensionAttribute]
public static string ToCode(Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static string ToCode(bool x);
    [ExtensionAttribute]
public static string ToCode(string x);
    [ExtensionAttribute]
public static string ToEnumValueCode(Type enumType, object x, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static Type[] GetGenericTypeParametersOrArguments(TypeInfo typeInfo);
    [ExtensionAttribute]
public static string ToCommaSeparatedCode(IEnumerable items, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToArrayInitializerCode(IEnumerable items, Type itemType, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToCode(object x, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdent(StringBuilder sb, int lineIdent);
    [ExtensionAttribute]
internal static StringBuilder NewLine(StringBuilder sb, int lineIdent, int identSpaces);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentExpr(StringBuilder sb, Expression expr, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentArgumentExprs(StringBuilder sb, IReadOnlyList`1<T> exprs, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentArgumentExprs(StringBuilder sb, SmallList2`1<T> exprs, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentCs(StringBuilder sb, Expression expr, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentCs(StringBuilder sb, Expression expr, EnclosedIn enclosedIn, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    public static int CountLambdas(string code);
}
[FlagsAttribute]
internal enum FastExpressionCompiler.CompilerFlags : Enum {
    public byte value__;
    public static CompilerFlags Default;
    public static CompilerFlags NoInvocationLambdaInlining;
    public static CompilerFlags EnableDelegateDebugInfo;
    public static CompilerFlags ThrowOnNotSupportedExpression;
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ExpressionCompiler : object {
    private static Type[] _closureAsASingleParamType;
    private static Type[][] _closureTypePlusParamTypesPool;
    public static ArrayClosure EmptyArrayClosure;
    public static FieldInfo ArrayClosureArrayField;
    public static FieldInfo ArrayClosureWithNonPassedParamsField;
    private static ConstructorInfo[] _nonPassedParamsArrayClosureCtors;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructor;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructorWithoutConstants;
    [CompilerGeneratedAttribute]
private static Result <NotSupported_RuntimeVariables>k__BackingField;
    public static Result NotSupported_RuntimeVariables { get; private set; }
    private static ExpressionCompiler();
    [ExtensionAttribute]
public static TDelegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static bool CompileFastToIL(LambdaExpression lambdaExpr, ILGenerator il, CompilerFlags flags);
    [ExtensionAttribute]
public static Delegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate CompileSys(Expression`1<TDelegate> lambdaExpr);
    [ExtensionAttribute]
public static Delegate CompileSys(LambdaExpression lambdaExpr);
    [ExtensionAttribute]
public static TDelegate CompileFast(Expression`1<TDelegate> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`1<R> CompileFast(Expression`1<Func`1<R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`2<T1, R> CompileFast(Expression`1<Func`2<T1, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`3<T1, T2, R> CompileFast(Expression`1<Func`3<T1, T2, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`4<T1, T2, T3, R> CompileFast(Expression`1<Func`4<T1, T2, T3, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`5<T1, T2, T3, T4, R> CompileFast(Expression`1<Func`5<T1, T2, T3, T4, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`6<T1, T2, T3, T4, T5, R> CompileFast(Expression`1<Func`6<T1, T2, T3, T4, T5, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, R> CompileFast(Expression`1<Func`7<T1, T2, T3, T4, T5, T6, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action CompileFast(Expression`1<Action> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`1<T1> CompileFast(Expression`1<Action`1<T1>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`2<T1, T2> CompileFast(Expression`1<Action`2<T1, T2>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`3<T1, T2, T3> CompileFast(Expression`1<Action`3<T1, T2, T3>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`4<T1, T2, T3, T4> CompileFast(Expression`1<Action`4<T1, T2, T3, T4>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`5<T1, T2, T3, T4, T5> CompileFast(Expression`1<Action`5<T1, T2, T3, T4, T5>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`6<T1, T2, T3, T4, T5, T6> CompileFast(Expression`1<Action`6<T1, T2, T3, T4, T5, T6>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompile(LambdaExpression lambdaExpr, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs, CompilerFlags flags);
    [ExtensionAttribute]
internal static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ClosureInfo& closureInfo, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithoutClosure(LambdaExpression lambdaExpr, CompilerFlags flags);
    private static Delegate CompileNoArgsNew(ConstructorInfo ctor, Type delegateType, Type[] closurePlusParamTypes, Type returnType);
    internal static object TryCompileBoundToFirstClosureParam(Type delegateType, Expression bodyExpr, IReadOnlyList`1<ParameterExpression> paramExprs, Type[] closurePlusParamTypes, Type returnType, CompilerFlags flags);
    private static Type[] RentOrNewClosureTypeToParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    private static void ReturnClosureTypeToParamTypesToPool(Type[] closurePlusParamTypes);
    [ExtensionAttribute]
internal static LabelInfo& GetLabelOrInvokeIndexByTarget(SmallList4`1& labels, object labelTarget, Boolean& found);
    [ExtensionAttribute]
private static Label GetOrDefineLabel(LabelInfo& label, ILGenerator il);
    [CompilerGeneratedAttribute]
public static Result get_NotSupported_RuntimeVariables();
    [CompilerGeneratedAttribute]
private static void set_NotSupported_RuntimeVariables(Result value);
    [ExtensionAttribute]
public static bool TryGetDebugClosureNestedLambdaOrConstant(Delegate parentLambda, Object& item, int itemIndex);
    [ExtensionAttribute]
public static bool TryGetDebugClosureNestedLambda(Delegate parentLambda, int itemIndex, Delegate& d);
    public static bool IsClosureBoundConstant(object value, Type type);
    public static bool TryCollectBoundConstants(ClosureInfo& closure, Expression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    public static Result TryCollectInfo(ClosureInfo& closure, Expression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static bool PropagateNonPassedParamsToOuterLambda(ClosureInfo& closure, NestedLambdaInfo nestedLambda, IReadOnlyList`1<ParameterExpression> paramExprs, IReadOnlyList`1<ParameterExpression> nestedLambdaParamExprs, SmallList`1& nestedNonPassedParams);
    private static bool FindAlreadyCompiledNestedLambdaInfoInLambdas(SmallList`1& nestedLambdas, LambdaExpression lambdaExpr, NestedLambdaInfo& found);
    private static bool TryCompileNestedLambda(ClosureInfo& nestedClosureInfo, NestedLambdaInfo nestedLambdaInfo, CompilerFlags setup);
    [ExtensionAttribute]
public static IDelegateDebugInfo TryGetDebugInfo(D delegat);
    private static Result TryCollectMemberInitExprConstants(ClosureInfo& closure, MemberInitExpression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static Result TryCollectListInitExprConstants(ClosureInfo& closure, ListInitExpression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static Result TryCollectTryExprConstants(ClosureInfo& closure, TryExpression tryExpr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    [ExtensionAttribute]
public static bool IgnoresResult(ParentFlags parent);
    [ExtensionAttribute]
internal static bool EmitPopIfIgnoreResult(ILGenerator il, ParentFlags parent);
    [ExtensionAttribute]
internal static bool TryEmitBoxOf(ILGenerator il, Type sourceType);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.FecHelpers : object {
    [ExtensionAttribute]
public static int GetFirstIndexByReferenceEquals(IReadOnlyList`1<T> source, T item);
    [ExtensionAttribute]
public static T GetArgument(IReadOnlyList`1<T> source, int index);
    [ExtensionAttribute]
public static ParameterExpression GetParameter(IReadOnlyList`1<ParameterExpression> source, int index);
    [ExtensionAttribute]
public static IReadOnlyList`1<ParameterExpression> ToReadOnlyList(IReadOnlyList`1<ParameterExpression> source);
    [ExtensionAttribute]
public static int GetCount(IReadOnlyList`1<ParameterExpression> p);
    [ExtensionAttribute]
public static int GetCount(IArgumentProvider p);
}
internal interface FastExpressionCompiler.IDelegateDebugInfo {
    public LambdaExpression Expression { get; }
    public string ExpressionString { get; }
    public string CSharpString { get; }
    public abstract virtual LambdaExpression get_Expression();
    public abstract virtual string get_ExpressionString();
    public abstract virtual string get_CSharpString();
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ILGeneratorHacks : object {
    private static Func`3<ILGenerator, Type, int> _getNextLocalVarIndex;
    private static ILGeneratorHacks();
    internal static int PostInc(Int32& i);
    [ExtensionAttribute]
public static int GetNextLocalVarIndex(ILGenerator il, Type t);
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ILGeneratorTools : object {
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, Type value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, FieldInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, MethodInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, ConstructorInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, Label value, string valueName);
    [ExtensionAttribute]
public static void DmarkLabel(ILGenerator il, Label& value, string valueName);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, byte value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, sbyte value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, short value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, int value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, long value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, float value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, double value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode& opcode, string value);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.ImTools.FHashMap : object {
    public static UInt32 GoldenRatio32;
    internal static byte MinFreeCapacityShift;
    internal static byte MinHashesCapacityBitShift;
    public static byte MaxProbeBits;
    internal static byte MaxProbeCount;
    internal static byte ProbeCountShift;
    internal static int HashAndIndexMask;
    public static int StackEntriesCount;
    internal static int MinEntriesCapacity;
    public static FHashMap`4<K, V, TEq, SingleArrayEntries`3<K, V, TEq>> New(byte capacityBitShift);
    public static string ToB(int x);
    internal static Int32& GetHashRef(Int32[]& start, int distance);
    internal static int GetHash(Int32[]& start, int distance);
    [ExtensionAttribute]
public static V& TryGetValueRef(FHashMap`4& map, K key, Boolean& found);
    [ExtensionAttribute]
public static V& GetOrAddValueRef(FHashMap`4& map, K key, Boolean& found);
    [ExtensionAttribute]
private static void AddInitialHashWithoutResizing(FHashMap`4& map, K key, int index, int indexMask);
    [ExtensionAttribute]
public static V& AddSureAbsentDefaultAndGetRef(FHashMap`4& map, K key);
    [ExtensionAttribute]
private static V& AddSureAbsentDefaultAndGetRefByHash(FHashMap`4& map, K key);
    [ExtensionAttribute]
public static Entry`2& GetSurePresentEntryRef(FHashMap`4& map, int index);
    [ExtensionAttribute]
internal static V& TryGetValueRefByHash(FHashMap`4& map, K key, Boolean& found);
    [ExtensionAttribute]
private static V& GetOrAddValueRefByHash(FHashMap`4& map, K key, Boolean& found);
}
internal class FastExpressionCompiler.ImTools.FHashMap`4 : ValueType {
    internal static Entry`2<K, V> _missing;
    internal byte _capacityBitShift;
    internal int _count;
    internal Int32[] _packedHashesAndIndexes;
    internal TEntries _entries;
    internal Entry`2<K, V> _e0;
    internal Entry`2<K, V> _e1;
    internal Entry`2<K, V> _e2;
    internal Entry`2<K, V> _e3;
    public int CapacityBitShift { get; }
    public Int32[] PackedHashesAndIndexes { get; }
    public int Count { get; }
    public TEntries Entries { get; }
    public FHashMap`4(byte capacityBitShift);
    public int get_CapacityBitShift();
    public Int32[] get_PackedHashesAndIndexes();
    public int get_Count();
    public TEntries get_Entries();
    internal int ResizeHashes(int indexMask);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.ImTools.SmallList : object {
    internal static int ForLoopCopyCount;
    internal static int InitialCapacity;
    internal static void Expand(TItem[]& items);
    public static TItem& AppendDefaultToNotNullItemsAndGetRef(TItem[]& items, int index);
    public static TItem& AppendDefaultAndGetRef(TItem[]& items, int index, int initialCapacity);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList`1& source, int index);
    [ExtensionAttribute]
public static TItem& Append(SmallList`1& source, int initialCapacity);
    [ExtensionAttribute]
public static void Append(SmallList`1& source, TItem& item, int initialCapacity);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAppend(SmallList`1& source, TItem& item, TEq eq);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList4`1& source, int index);
    [ExtensionAttribute]
public static TItem& GetLastSurePresentItem(SmallList4`1& source);
    [ExtensionAttribute]
public static TItem& NotFound(SmallList4`1& _);
    [ExtensionAttribute]
public static TItem& AppendDefaultAndGetRef(SmallList4`1& source);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList4`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAppend(SmallList4`1& source, TItem& item, TEq eq);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList2`1& source, int index);
    [ExtensionAttribute]
public static TItem& GetLastSurePresentItem(SmallList2`1& source);
    [ExtensionAttribute]
public static TItem& NotFound(SmallList2`1& _);
    [ExtensionAttribute]
public static TItem& AppendDefaultAndGetRef(SmallList2`1& source);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList2`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAppend(SmallList2`1& source, TItem item, TEq eq);
}
internal class FastExpressionCompiler.ImTools.SmallList`1 : ValueType {
    public T[] Items;
    public int Count;
    public SmallList`1(T[] items, int count);
    public SmallList`1(T[] items);
    public void Pop();
}
[DefaultMemberAttribute("Item")]
internal class FastExpressionCompiler.ImTools.SmallList2`1 : ValueType {
    public static int StackItemCount;
    internal static TItem Missing;
    internal int _count;
    internal TItem _it0;
    internal TItem _it1;
    internal TItem[] _rest;
    public int Count { get; }
    public TItem Item { get; }
    public void InitCount(int count);
    public void Init(TItem it0);
    public void Init(TItem it0, TItem it1);
    public void Init(TItem it0, TItem it1, TItem[] rest);
    public void Init(TItem[] items);
    public void Init(TList items);
    public int get_Count();
    public TItem get_Item(int index);
    public void Append(TItem& item);
    public void Add(TItem& item);
    public void AppendDefault();
    public void RemoveLastSurePresentItem();
    public TItem[] CopyToArray();
    public IList`1<TItem> AsList();
}
[DefaultMemberAttribute("Item")]
internal class FastExpressionCompiler.ImTools.SmallList4`1 : ValueType {
    public static int StackItemCount;
    internal static TItem Missing;
    internal int _count;
    internal TItem _it0;
    internal TItem _it1;
    internal TItem _it2;
    internal TItem _it3;
    internal TItem[] _rest;
    public int Count { get; }
    public TItem Item { get; }
    public int get_Count();
    public TItem get_Item(int index);
    public void Append(TItem& item);
    public void Add(TItem& item);
    public void AppendDefault();
    public void RemoveLastSurePresentItem();
}
internal class FastExpressionCompiler.NotSupportedExpressionException : InvalidOperationException {
    public Result Reason;
    public NotSupportedExpressionException(Result reason);
    public NotSupportedExpressionException(Result reason, string message);
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ToCSharpPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr);
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
public static StringBuilder ToCSharpString(Expression e, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToCSharpString(Expression e, StringBuilder sb, EnclosedIn enclosedIn, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder AddSemicolonIfFits(StringBuilder sb);
    private static bool CanBeReturned(ExpressionType nt);
    [ExtensionAttribute]
private static string GetCSharpName(MemberInfo m);
    [ExtensionAttribute]
internal static StringBuilder ToCSharpString(LabelTarget target, StringBuilder sb);
    [ExtensionAttribute]
private static StringBuilder ToCSharpString(IReadOnlyList`1<MemberBinding> bindings, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder BlockToCSharpString(BlockExpression b, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode, bool inTheLastBlock, BinaryExpression blockResultAssignment, bool containerIgnoresResult);
    private static string OperatorToCSharpString(ExpressionType nodeType);
    [CompilerGeneratedAttribute]
internal static void <ToCSharpString>g__PrintPart|4_0(Expression part, <>c__DisplayClass4_0& , <>c__DisplayClass4_1& );
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ToExpressionPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, List`1& paramsExprs, List`1& uniqueExprs, List`1& lts, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(Expression expr, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(ParameterExpression pe, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(LabelTarget lt, StringBuilder sb, List`1<LabelTarget> labelTargets, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<CatchBlock> bs, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(CatchBlock b, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<SwitchCase> items, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(SwitchCase s, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(MemberBinding mb, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(ElementInit ei, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder CreateExpressionString(Expression e, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.Tools : object {
    internal static MethodInfo DelegateTargetGetterMethod;
    private static FHashMap`4<Type, NullableMethods, RefEq`1<Type>, SingleArrayEntries`3<Type, NullableMethods, RefEq`1<Type>>> _nullableMethods;
    private static FHashMap`4<ValueTuple`3<Type, Type, Type>, MethodInfo, RefEq`3<Type, Type, Type>, SingleArrayEntries`3<ValueTuple`3<Type, Type, Type>, MethodInfo, RefEq`3<Type, Type, Type>>> _convertOperatorMethods;
    private static Tools();
    [ExtensionAttribute]
public static Expression AsExpr(object obj);
    [ExtensionAttribute]
public static Expression[] AsExprs(Object[] obj);
    [ExtensionAttribute]
internal static bool IsUnsigned(Type type);
    [ExtensionAttribute]
internal static bool IsNullable(Type type);
    [ExtensionAttribute]
internal static Type GetUnderlyingNullableTypeOrNull(Type type);
    [ExtensionAttribute]
public static string GetArithmeticBinaryOperatorMethodName(ExpressionType nodeType);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindMethod(Type type, string methodName);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindDelegateInvokeMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo GetNullableHasValueGetterMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo GetNullableGetValueOrDefaultMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static ConstructorInfo GetNullableConstructor(Type type);
    [ExtensionAttribute]
internal static void FindAndSetNullableMethods(Type type, NullableMethods& methods);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindValueGetterMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindConvertOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static ConstructorInfo FindSingleParamConstructor(Type type, Type paramType);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> xs);
    [ExtensionAttribute]
internal static IList`1<T> AsList(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static bool TryGetIndexByReferenceEquals(IList`1<T> items, Int32& index, T item, int count);
    public static T[] Empty();
    public static Type[] GetParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    public static Type GetFuncOrActionType(Type returnType);
    public static Type GetFuncOrActionType(Type p, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type p5, Type returnType);
    public static Type GetFuncOrActionType(Type[] paramTypes, Type returnType);
    [ExtensionAttribute]
public static T GetFirst(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T GetFirst(T[] source);
    [CompilerGeneratedAttribute]
internal static Type <GetFuncOrActionType>g__GetAction|32_0(int length);
    [CompilerGeneratedAttribute]
internal static Type <GetFuncOrActionType>g__GetFunc|32_1(int length);
}
internal static class FastExpressionCompiler.Trimming : object {
    public static string Message;
}
internal static class HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static bool IsHexChar(int c);
    public static int FromChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class Parlot.Character : object {
    private static ReadOnlySpan`1<byte> _characterData { get; }
    public static bool IsDecimalDigit(char ch);
    public static bool IsInRange(char ch, char min, char max);
    public static bool IsHexDigit(char ch);
    public static bool IsIdentifierStart(char ch);
    public static bool IsIdentifierPart(char ch);
    public static bool IsWhiteSpace(char ch);
    public static bool IsWhiteSpaceNonAscii(char ch);
    public static bool IsWhiteSpaceOrNewLine(char ch);
    public static bool IsNewLine(char ch);
    public static char ScanHexEscape(string text, int index, Int32& length);
    public static TextSpan DecodeString(string s);
    public static TextSpan DecodeString(TextSpan span);
    private static int HexValue(char ch);
    private static ReadOnlySpan`1<byte> get__characterData();
}
[FlagsAttribute]
internal enum Parlot.CharacterMask : Enum {
    public byte value__;
    public static CharacterMask None;
    public static CharacterMask IdentifierStart;
    public static CharacterMask IdentifierPart;
    public static CharacterMask WhiteSpace;
    public static CharacterMask WhiteSpaceOrNewLine;
}
internal static class Parlot.CharToStringTable : object {
    private static int _size;
    private static String[] _table;
    private static CharToStringTable();
    public static string GetString(char c);
}
public class Parlot.Compilation.CompilationContext : object {
    private int _number;
    [CompilerGeneratedAttribute]
private ParameterExpression <ParseContext>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ParameterExpression> <GlobalVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <GlobalExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <Lambdas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiscardResult>k__BackingField;
    public ParameterExpression ParseContext { get; }
    public int NextNumber { get; }
    public List`1<ParameterExpression> GlobalVariables { get; }
    public List`1<Expression> GlobalExpressions { get; }
    public List`1<Expression> Lambdas { get; }
    public bool DiscardResult { get; public set; }
    [CompilerGeneratedAttribute]
public ParameterExpression get_ParseContext();
    public int get_NextNumber();
    [CompilerGeneratedAttribute]
public List`1<ParameterExpression> get_GlobalVariables();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_GlobalExpressions();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_Lambdas();
    [CompilerGeneratedAttribute]
public bool get_DiscardResult();
    [CompilerGeneratedAttribute]
public void set_DiscardResult(bool value);
}
public class Parlot.Compilation.CompilationResult : object {
    [CompilerGeneratedAttribute]
private List`1<ParameterExpression> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Value>k__BackingField;
    public List`1<ParameterExpression> Variables { get; }
    public List`1<Expression> Body { get; }
    public ParameterExpression Success { get; public set; }
    public ParameterExpression Value { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ParameterExpression> get_Variables();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_Body();
    [CompilerGeneratedAttribute]
public ParameterExpression get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(ParameterExpression value);
    [CompilerGeneratedAttribute]
public ParameterExpression get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ParameterExpression value);
}
public class Parlot.Compilation.CompiledParser`1 : Parser`1<T> {
    private Func`2<ParseContext, ValueTuple`2<bool, T>> _parse;
    [CompilerGeneratedAttribute]
private Parser`1<T> <Source>k__BackingField;
    public Parser`1<T> Source { get; }
    public CompiledParser`1(Func`2<ParseContext, ValueTuple`2<bool, T>> parse, Parser`1<T> source);
    [CompilerGeneratedAttribute]
public Parser`1<T> get_Source();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
}
[ExtensionAttribute]
public static class Parlot.Compilation.ExpressionHelper : object {
    internal static MethodInfo ParserContext_SkipWhiteSpaceMethod;
    internal static MethodInfo Scanner_ReadText;
    internal static MethodInfo Scanner_ReadText_NoResult;
    internal static MethodInfo Scanner_ReadChar;
    internal static MethodInfo Scanner_ReadDecimal;
    internal static MethodInfo Scanner_ReadInteger;
    internal static MethodInfo Scanner_ReadNonWhiteSpace;
    internal static MethodInfo Scanner_ReadNonWhiteSpaceOrNewLine;
    internal static MethodInfo Scanner_SkipWhiteSpace;
    internal static MethodInfo Scanner_SkipWhiteSpaceOrNewLine;
    internal static MethodInfo Scanner_ReadSingleQuotedString;
    internal static MethodInfo Scanner_ReadDoubleQuotedString;
    internal static MethodInfo Scanner_ReadQuotedString;
    internal static MethodInfo Cursor_Advance;
    internal static MethodInfo Cursor_AdvanceNoNewLines;
    internal static ConstructorInfo TextSpan_Constructor;
    private static ExpressionHelper();
    [ExtensionAttribute]
public static Expression NewTextSpan(CompilationContext _, Expression buffer, Expression offset, Expression count);
    [ExtensionAttribute]
public static MemberExpression Scanner(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Cursor(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Position(CompilationContext context);
    [ExtensionAttribute]
public static Expression ResetPosition(CompilationContext context, Expression position);
    [ExtensionAttribute]
public static MemberExpression Offset(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Offset(CompilationContext context, Expression textPosition);
    [ExtensionAttribute]
public static MemberExpression Current(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Eof(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Buffer(CompilationContext context);
    [ExtensionAttribute]
public static Expression ThrowObject(CompilationContext _, Expression o);
    [ExtensionAttribute]
public static Expression ThrowParseException(CompilationContext context, Expression message);
    [ExtensionAttribute]
public static MethodCallExpression ReadSingleQuotedString(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadDoubleQuotedString(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadQuotedString(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadChar(CompilationContext context, char c);
    [ExtensionAttribute]
public static MethodCallExpression ReadDecimal(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadInteger(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadNonWhiteSpace(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadNonWhiteSpaceOrNewLine(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression SkipWhiteSpace(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression SkipWhiteSpaceOrNewLine(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression Advance(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression AdvanceNoNewLine(CompilationContext context, Expression count);
    [ExtensionAttribute]
public static ParameterExpression DeclareSuccessVariable(CompilationContext context, CompilationResult result, bool defaultValue);
    [ExtensionAttribute]
public static ParameterExpression DeclareValueVariable(CompilationContext context, CompilationResult result);
    [ExtensionAttribute]
public static ParameterExpression DeclareValueVariable(CompilationContext context, CompilationResult result, Expression defaultValue);
    [ExtensionAttribute]
public static ParameterExpression DeclarePositionVariable(CompilationContext context, CompilationResult result);
    [ExtensionAttribute]
public static ParameterExpression DeclareOffsetVariable(CompilationContext context, CompilationResult result);
    [ExtensionAttribute]
public static MethodCallExpression ParserSkipWhiteSpace(CompilationContext context);
}
public interface Parlot.Compilation.ICompilable {
    public abstract virtual CompilationResult Compile(CompilationContext context);
}
public interface Parlot.Compilation.ICompiledParser {
}
public class Parlot.Cursor : object {
    public static char NullChar;
    private int _textLength;
    private char _current;
    private int _offset;
    private int _line;
    private int _column;
    private string _buffer;
    [CompilerGeneratedAttribute]
private bool <Eof>k__BackingField;
    public TextPosition Position { get; }
    public char Current { get; }
    public int Offset { get; }
    public bool Eof { get; private set; }
    public string Buffer { get; }
    public Cursor(string buffer, TextPosition& position);
    public Cursor(string buffer);
    public TextPosition get_Position();
    public void Advance();
    public void Advance(int count);
    public void AdvanceNoNewLines(int offset);
    public void ResetPosition(TextPosition& position);
    private void ResetPositionNotInlined(TextPosition& position);
    public char get_Current();
    public int get_Offset();
    public char PeekNext(int index);
    [CompilerGeneratedAttribute]
public bool get_Eof();
    [CompilerGeneratedAttribute]
private void set_Eof(bool value);
    public string get_Buffer();
    public bool Match(char c);
    public bool MatchAnyOf(string s);
    public bool Match(string s);
    public bool Match(string s, StringComparison comparisonType);
}
public class Parlot.Fluent.Between`3 : Parser`1<T> {
    private Parser`1<T> _parser;
    private Parser`1<A> _before;
    private Parser`1<B> _after;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Between`3(Parser`1<A> before, Parser`1<T> parser, Parser`1<B> after);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Capture`1 : Parser`1<TextSpan> {
    private Parser`1<T> _parser;
    public Capture`1(Parser`1<T> parser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.CharLiteral : Parser`1<char> {
    [CompilerGeneratedAttribute]
private char <Char>k__BackingField;
    public char Char { get; }
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public CharLiteral(char c);
    [CompilerGeneratedAttribute]
public char get_Char();
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.DecimalLiteral : Parser`1<decimal> {
    private NumberOptions _numberOptions;
    public DecimalLiteral(NumberOptions numberOptions);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Deferred`1 : Parser`1<T> {
    [CompilerGeneratedAttribute]
private Parser`1<T> <Parser>k__BackingField;
    private bool _initialized;
    private Closure<T> _closure;
    public Parser`1<T> Parser { get; public set; }
    public Deferred`1(Func`2<Deferred`1<T>, Parser`1<T>> parser);
    [CompilerGeneratedAttribute]
public Parser`1<T> get_Parser();
    [CompilerGeneratedAttribute]
public void set_Parser(Parser`1<T> value);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Discard`2 : Parser`1<U> {
    private Parser`1<T> _parser;
    private U _value;
    public Discard`2(Parser`1<T> parser);
    public Discard`2(Parser`1<T> parser, U value);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.DoubleLiteral : Parser`1<double> {
    private NumberOptions _numberOptions;
    public DoubleLiteral(NumberOptions numberOptions);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.ElseError`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    private string _message;
    public ElseError`1(Parser`1<T> parser, string message);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Empty`1 : Parser`1<T> {
    private T _value;
    public Empty`1(T value);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Eof`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    public Eof`1(Parser`1<T> parser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Error`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    private string _message;
    public Error`1(Parser`1<T> parser, string message);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Error`2 : Parser`1<U> {
    private Parser`1<T> _parser;
    private string _message;
    public Error`2(Parser`1<T> parser, string message);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.FloatLiteral : Parser`1<float> {
    private NumberOptions _numberOptions;
    public FloatLiteral(NumberOptions numberOptions);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Identifier : Parser`1<TextSpan> {
    private Func`2<char, bool> _extraStart;
    private Func`2<char, bool> _extraPart;
    public Identifier(Func`2<char, bool> extraStart, Func`2<char, bool> extraPart);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.IntegerLiteral : Parser`1<long> {
    private NumberOptions _numberOptions;
    public IntegerLiteral(NumberOptions numberOptions);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public interface Parlot.Fluent.ISkippableSequenceParser {
    public abstract virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
}
public class Parlot.Fluent.LiteralBuilder : object {
    public Parser`1<TextSpan> WhiteSpace(bool includeNewLines);
    public Parser`1<TextSpan> NonWhiteSpace(bool includeNewLines);
    public Parser`1<string> Text(string text, bool caseInsensitive);
    public Parser`1<char> Char(char c);
    public Parser`1<long> Integer(NumberOptions numberOptions);
    public Parser`1<decimal> Decimal(NumberOptions numberOptions);
    public Parser`1<float> Float(NumberOptions numberOptions);
    public Parser`1<double> Double(NumberOptions numberOptions);
    public Parser`1<TextSpan> String(StringLiteralQuotes quotes);
    public Parser`1<TextSpan> Identifier(Func`2<char, bool> extraStart, Func`2<char, bool> extraPart);
    public Parser`1<TextSpan> Pattern(Func`2<char, bool> predicate, int minSize, int maxSize);
}
public class Parlot.Fluent.NonWhiteSpaceLiteral : Parser`1<TextSpan> {
    private bool _includeNewLines;
    public NonWhiteSpaceLiteral(bool includeNewLines);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Not`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    public Not`1(Parser`1<T> parser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[FlagsAttribute]
public enum Parlot.Fluent.NumberOptions : Enum {
    public int value__;
    public static NumberOptions None;
    public static NumberOptions Default;
    public static NumberOptions AllowSign;
}
public class Parlot.Fluent.OneOf`1 : Parser`1<T> {
    internal Parser`1[] _parsers;
    internal Dictionary`2<char, List`1<Parser`1<T>>> _lookupTable;
    internal bool _skipWhiteSpace;
    public Parser`1[] Parsers { get; }
    public OneOf`1(Parser`1[] parsers);
    public Parser`1[] get_Parsers();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.OneOf`3 : Parser`1<T> {
    private Parser`1<A> _parserA;
    private Parser`1<B> _parserB;
    public OneOf`3(Parser`1<A> parserA, Parser`1<B> parserB);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.OneOrMany`1 : Parser`1<List`1<T>> {
    private Parser`1<T> _parser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public OneOrMany`1(Parser`1<T> parser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.ParseContext : object {
    public static int DefaultCompilationThreshold;
    [CompilerGeneratedAttribute]
private int <CompilationThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNewLines>k__BackingField;
    public Scanner Scanner;
    [CompilerGeneratedAttribute]
private Action`2<object, ParseContext> <OnEnterParser>k__BackingField;
    [CompilerGeneratedAttribute]
private Parser`1<TextSpan> <WhiteSpaceParser>k__BackingField;
    public int CompilationThreshold { get; public set; }
    public bool UseNewLines { get; private set; }
    public Action`2<object, ParseContext> OnEnterParser { get; public set; }
    public Parser`1<TextSpan> WhiteSpaceParser { get; public set; }
    public ParseContext(Scanner scanner, bool useNewLines);
    [CompilerGeneratedAttribute]
public int get_CompilationThreshold();
    [CompilerGeneratedAttribute]
public void set_CompilationThreshold(int value);
    [CompilerGeneratedAttribute]
public bool get_UseNewLines();
    [CompilerGeneratedAttribute]
private void set_UseNewLines(bool value);
    [CompilerGeneratedAttribute]
public Action`2<object, ParseContext> get_OnEnterParser();
    [CompilerGeneratedAttribute]
public void set_OnEnterParser(Action`2<object, ParseContext> value);
    [CompilerGeneratedAttribute]
public Parser`1<TextSpan> get_WhiteSpaceParser();
    [CompilerGeneratedAttribute]
public void set_WhiteSpaceParser(Parser`1<TextSpan> value);
    public void SkipWhiteSpace();
    public void EnterParser(Parser`1<T> parser);
}
public abstract class Parlot.Fluent.Parser`1 : object {
    private int _invocations;
    private Parser`1 modreq(System.Runtime.CompilerServices.IsVolatile) _compiledParser;
    public Parser`1<T> Compile();
    public CompilationResult Build(CompilationContext context, bool requireResult);
    private CompilationResult BuildAsNonCompilableParser(CompilationContext context);
    public abstract virtual bool Parse(ParseContext context, ParseResult`1& result);
    public Parser`1<U> Then(Func`2<T, U> conversion);
    public Parser`1<U> Then(Func`3<ParseContext, T, U> conversion);
    public Parser`1<T> ElseError(string message);
    public Parser`1<T> Error(string message);
    public Parser`1<U> Error(string message);
    public Parser`1<T> When(Func`2<T, bool> predicate);
    public Parser`1<U> Switch(Func`3<ParseContext, T, Parser`1<U>> action);
    public Parser`1<T> Eof();
    public Parser`1<U> Discard();
    public Parser`1<U> Discard(U value);
    public T Parse(string text);
    public T Parse(ParseContext context);
    private Parser`1<T> CheckCompiled(ParseContext context);
    public bool TryParse(string text, T& value);
    public bool TryParse(string text, T& value, ParseError& error);
    public bool TryParse(ParseContext context, T& value, ParseError& error);
}
[ExtensionAttribute]
public static class Parlot.Fluent.Parsers : object {
    public static LiteralBuilder Literals { get; }
    public static TermBuilder Terms { get; }
    [ExtensionAttribute]
public static Parser`1<ValueTuple`2<T1, T2>> And(Parser`1<T1> parser, Parser`1<T2> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`3<T1, T2, T3>> And(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`4<T1, T2, T3, T4>> And(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> And(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> And(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> And(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static Parser`1<T1> AndSkip(Parser`1<T1> parser, Parser`1<T2> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`2<T1, T2>> AndSkip(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`3<T1, T2, T3>> AndSkip(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`4<T1, T2, T3, T4>> AndSkip(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> AndSkip(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> AndSkip(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> AndSkip(Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> parser, Parser`1<T8> and);
    public static LiteralBuilder get_Literals();
    public static TermBuilder get_Terms();
    public static Parser`1<List`1<T>> Separated(Parser`1<U> separator, Parser`1<T> parser);
    public static Parser`1<T> SkipWhiteSpace(Parser`1<T> parser);
    public static Parser`1<T> ZeroOrOne(Parser`1<T> parser);
    public static Parser`1<List`1<T>> ZeroOrMany(Parser`1<T> parser);
    public static Parser`1<List`1<T>> OneOrMany(Parser`1<T> parser);
    public static Parser`1<T> Not(Parser`1<T> parser);
    public static Deferred`1<T> Deferred();
    public static Deferred`1<T> Recursive(Func`2<Deferred`1<T>, Parser`1<T>> parser);
    public static Parser`1<T> Between(Parser`1<A> before, Parser`1<T> parser, Parser`1<B> after);
    public static Parser`1<TextSpan> AnyCharBefore(Parser`1<T> parser, bool canBeEmpty, bool failOnEof, bool consumeDelimiter);
    public static Parser`1<TextSpan> Capture(Parser`1<T> parser);
    public static Parser`1<T> Empty();
    public static Parser`1<object> Empty();
    public static Parser`1<T> Empty(T value);
    [ExtensionAttribute]
public static Parser`1<T> Or(Parser`1<T> parser, Parser`1<T> or);
    [ExtensionAttribute]
public static Parser`1<T> Or(Parser`1<A> parser, Parser`1<B> or);
    public static Parser`1<T> OneOf(Parser`1[] parsers);
    [ExtensionAttribute]
public static Parser`1<T2> SkipAnd(Parser`1<T1> parser, Parser`1<T2> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`2<T1, T3>> SkipAnd(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`3<T1, T2, T4>> SkipAnd(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`4<T1, T2, T3, T5>> SkipAnd(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`5<T1, T2, T3, T4, T6>> SkipAnd(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T7>> SkipAnd(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T8>> SkipAnd(Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> parser, Parser`1<T8> and);
}
public class Parlot.Fluent.PatternLiteral : Parser`1<TextSpan> {
    private Func`2<char, bool> _predicate;
    private int _minSize;
    private int _maxSize;
    public PatternLiteral(Func`2<char, bool> predicate, int minSize, int maxSize);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Separated`2 : Parser`1<List`1<T>> {
    private Parser`1<U> _separator;
    private Parser`1<T> _parser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Separated`2(Parser`1<U> separator, Parser`1<T> parser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Sequence`2 : Parser`1<ValueTuple`2<T1, T2>> {
    internal Parser`1<T1> _parser1;
    internal Parser`1<T2> _parser2;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`2(Parser`1<T1> parser1, Parser`1<T2> parser2);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Sequence`3 : Parser`1<ValueTuple`3<T1, T2, T3>> {
    private Parser`1<ValueTuple`2<T1, T2>> _parser;
    internal Parser`1<T3> _lastParser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`3(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> lastParser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Sequence`4 : Parser`1<ValueTuple`4<T1, T2, T3, T4>> {
    private Parser`1<ValueTuple`3<T1, T2, T3>> _parser;
    internal Parser`1<T4> _lastParser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`4(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> lastParser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Sequence`5 : Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> {
    private Parser`1<ValueTuple`4<T1, T2, T3, T4>> _parser;
    internal Parser`1<T5> _lastParser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`5(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> lastParser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Sequence`6 : Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> {
    private Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> _parser;
    internal Parser`1<T6> _lastParser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`6(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> lastParser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Sequence`7 : Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> {
    private Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> _parser;
    internal Parser`1<T7> _lastParser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`7(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> lastParser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceAndSkip`2 : Parser`1<T1> {
    internal Parser`1<T1> _parser1;
    internal Parser`1<T2> _parser2;
    public SequenceAndSkip`2(Parser`1<T1> parser1, Parser`1<T2> parser2);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceAndSkip`3 : Parser`1<ValueTuple`2<T1, T2>> {
    private Parser`1<ValueTuple`2<T1, T2>> _parser;
    internal Parser`1<T3> _lastParser;
    public SequenceAndSkip`3(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceAndSkip`4 : Parser`1<ValueTuple`3<T1, T2, T3>> {
    private Parser`1<ValueTuple`3<T1, T2, T3>> _parser;
    internal Parser`1<T4> _lastParser;
    public SequenceAndSkip`4(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceAndSkip`5 : Parser`1<ValueTuple`4<T1, T2, T3, T4>> {
    private Parser`1<ValueTuple`4<T1, T2, T3, T4>> _parser;
    internal Parser`1<T5> _lastParser;
    public SequenceAndSkip`5(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceAndSkip`6 : Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> {
    private Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> _parser;
    internal Parser`1<T6> _lastParser;
    public SequenceAndSkip`6(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceAndSkip`7 : Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> {
    private Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> _parser;
    internal Parser`1<T7> _lastParser;
    public SequenceAndSkip`7(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceAndSkip`8 : Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> {
    private Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> _parser;
    internal Parser`1<T8> _lastParser;
    public SequenceAndSkip`8(Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> parser, Parser`1<T8> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal static class Parlot.Fluent.SequenceCompileHelper : object {
    internal static string SequenceRequired;
    private static SequenceCompileHelper();
    public static CompilationResult CreateSequenceCompileResult(SkippableCompilationResult[] parserCompileResults, CompilationContext context);
    [CompilerGeneratedAttribute]
internal static Type <CreateSequenceCompileResult>g__GetValueTuple|1_2(int length);
}
public class Parlot.Fluent.SequenceSkipAnd`2 : Parser`1<T2> {
    internal Parser`1<T1> _parser1;
    internal Parser`1<T2> _parser2;
    public SequenceSkipAnd`2(Parser`1<T1> parser1, Parser`1<T2> parser2);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceSkipAnd`3 : Parser`1<ValueTuple`2<T1, T3>> {
    private Parser`1<ValueTuple`2<T1, T2>> _parser;
    internal Parser`1<T3> _lastParser;
    public SequenceSkipAnd`3(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceSkipAnd`4 : Parser`1<ValueTuple`3<T1, T2, T4>> {
    private Parser`1<ValueTuple`3<T1, T2, T3>> _parser;
    internal Parser`1<T4> _lastParser;
    public SequenceSkipAnd`4(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceSkipAnd`5 : Parser`1<ValueTuple`4<T1, T2, T3, T5>> {
    private Parser`1<ValueTuple`4<T1, T2, T3, T4>> _parser;
    internal Parser`1<T5> _lastParser;
    public SequenceSkipAnd`5(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceSkipAnd`6 : Parser`1<ValueTuple`5<T1, T2, T3, T4, T6>> {
    private Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> _parser;
    internal Parser`1<T6> _lastParser;
    public SequenceSkipAnd`6(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceSkipAnd`7 : Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T7>> {
    private Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> _parser;
    internal Parser`1<T7> _lastParser;
    public SequenceSkipAnd`7(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SequenceSkipAnd`8 : Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T8>> {
    private Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> _parser;
    internal Parser`1<T8> _lastParser;
    public SequenceSkipAnd`8(Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> parser, Parser`1<T8> lastParser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.SkippableCompilationResult : object {
    [CompilerGeneratedAttribute]
private CompilationResult <CompilationResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Skip>k__BackingField;
    public CompilationResult CompilationResult { get; public set; }
    public bool Skip { get; public set; }
    public SkippableCompilationResult(CompilationResult compilationResult, bool skip);
    [CompilerGeneratedAttribute]
public CompilationResult get_CompilationResult();
    [CompilerGeneratedAttribute]
public void set_CompilationResult(CompilationResult value);
    [CompilerGeneratedAttribute]
public bool get_Skip();
    [CompilerGeneratedAttribute]
public void set_Skip(bool value);
}
public class Parlot.Fluent.SkipWhiteSpace`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SkipWhiteSpace`1(Parser`1<T> parser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.StringLiteral : Parser`1<TextSpan> {
    private StringLiteralQuotes _quotes;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public StringLiteral(StringLiteralQuotes quotes);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public enum Parlot.Fluent.StringLiteralQuotes : Enum {
    public int value__;
    public static StringLiteralQuotes Single;
    public static StringLiteralQuotes Double;
    public static StringLiteralQuotes SingleOrDouble;
}
public class Parlot.Fluent.Switch`2 : Parser`1<U> {
    private Parser`1<T> _previousParser;
    private Func`3<ParseContext, T, Parser`1<U>> _action;
    public Switch`2(Parser`1<T> previousParser, Func`3<ParseContext, T, Parser`1<U>> action);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.TermBuilder : object {
    public Parser`1<TextSpan> NonWhiteSpace(bool includeNewLines);
    public Parser`1<string> Text(string text, bool caseInsensitive);
    public Parser`1<char> Char(char c);
    public Parser`1<long> Integer(NumberOptions numberOptions);
    public Parser`1<decimal> Decimal(NumberOptions numberOptions);
    public Parser`1<float> Float(NumberOptions numberOptions);
    public Parser`1<double> Double(NumberOptions numberOptions);
    public Parser`1<TextSpan> String(StringLiteralQuotes quotes);
    public Parser`1<TextSpan> Identifier(Func`2<char, bool> extraStart, Func`2<char, bool> extraPart);
    public Parser`1<TextSpan> Pattern(Func`2<char, bool> predicate, int minSize, int maxSize);
}
public class Parlot.Fluent.TextBefore`1 : Parser`1<TextSpan> {
    private Parser`1<T> _delimiter;
    private bool _canBeEmpty;
    private bool _failOnEof;
    private bool _consumeDelimiter;
    public TextBefore`1(Parser`1<T> delimiter, bool canBeEmpty, bool failOnEof, bool consumeDelimiter);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.TextLiteral : Parser`1<string> {
    private StringComparison _comparisonType;
    private bool _hasNewLines;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public TextLiteral(string text, StringComparison comparisonType);
    [CompilerGeneratedAttribute]
public string get_Text();
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.Then`2 : Parser`1<U> {
    private Func`2<T, U> _action1;
    private Func`3<ParseContext, T, U> _action2;
    private Parser`1<T> _parser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Then`2(Parser`1<T> parser);
    public Then`2(Parser`1<T> parser, Func`2<T, U> action);
    public Then`2(Parser`1<T> parser, Func`3<ParseContext, T, U> action);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.When`1 : Parser`1<T> {
    private Func`2<T, bool> _action;
    private Parser`1<T> _parser;
    public When`1(Parser`1<T> parser, Func`2<T, bool> action);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.WhiteSpaceLiteral : Parser`1<TextSpan> {
    private bool _includeNewLines;
    public WhiteSpaceLiteral(bool includeNewLines);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.ZeroOrMany`1 : Parser`1<List`1<T>> {
    private Parser`1<T> _parser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public ZeroOrMany`1(Parser`1<T> parser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.ZeroOrOne`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public ZeroOrOne`1(Parser`1<T> parser);
    public sealed virtual bool get_CanSeek();
    public sealed virtual Char[] get_ExpectedChars();
    public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.ParseError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private TextPosition <Position>k__BackingField;
    public string Message { get; public set; }
    public TextPosition Position { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public TextPosition get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(TextPosition value);
}
public class Parlot.ParseException : Exception {
    [CompilerGeneratedAttribute]
private TextPosition <Position>k__BackingField;
    public TextPosition Position { get; public set; }
    public ParseException(string message, TextPosition position);
    [CompilerGeneratedAttribute]
public TextPosition get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(TextPosition value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class Parlot.ParseResult`1 : ValueType {
    public int Start;
    public int End;
    public T Value;
    public ParseResult`1(int start, int end, T value);
    public void Set(int start, int end, T value);
}
public interface Parlot.Rewriting.IRewritable`1 {
    public abstract virtual Parser`1<T> Rewrite();
}
public interface Parlot.Rewriting.ISeekable {
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public abstract virtual bool get_CanSeek();
    public abstract virtual Char[] get_ExpectedChars();
    public abstract virtual bool get_SkipWhitespace();
}
public class Parlot.Scanner : object {
    public string Buffer;
    public Cursor Cursor;
    public Scanner(string buffer);
    public bool SkipWhiteSpaceOrNewLine();
    public bool SkipWhiteSpace();
    public bool ReadFirstThenOthers(Func`2<char, bool> first, Func`2<char, bool> other);
    public bool ReadFirstThenOthers(Func`2<char, bool> first, Func`2<char, bool> other, TokenResult& result);
    public bool ReadIdentifier();
    public bool ReadIdentifier(TokenResult& result);
    public bool ReadDecimal();
    public bool ReadDecimal(TokenResult& result);
    public bool ReadInteger();
    public bool ReadInteger(TokenResult& result);
    public bool ReadWhile(Func`2<char, bool> predicate);
    public bool ReadWhile(Func`2<char, bool> predicate, TokenResult& result);
    public bool ReadNonWhiteSpace();
    public bool ReadNonWhiteSpace(TokenResult& result);
    public bool ReadNonWhiteSpaceOrNewLine();
    public bool ReadNonWhiteSpaceOrNewLine(TokenResult& result);
    public bool ReadChar(char c);
    public bool ReadChar(char c, TokenResult& result);
    public bool ReadText(string text, StringComparison comparisonType);
    public bool ReadText(string text, StringComparison comparisonType, TokenResult& result);
    public bool ReadText(string text);
    public bool ReadText(string text, TokenResult& result);
    public bool ReadSingleQuotedString();
    public bool ReadSingleQuotedString(TokenResult& result);
    public bool ReadDoubleQuotedString();
    public bool ReadDoubleQuotedString(TokenResult& result);
    public bool ReadQuotedString();
    public bool ReadQuotedString(TokenResult& result);
    private bool ReadQuotedString(char quoteChar, TokenResult& result);
}
[IsReadOnlyAttribute]
public class Parlot.TextPosition : ValueType {
    public static TextPosition Start;
    public int Offset;
    public int Line;
    public int Column;
    public TextPosition(int offset, int line, int column);
    private static TextPosition();
    public static int op_Subtraction(TextPosition& left, TextPosition& right);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Parlot.TextSpan : ValueType {
    public int Length;
    public int Offset;
    public string Buffer;
    public ReadOnlySpan`1<char> Span { get; }
    public TextSpan(string value);
    public TextSpan(string buffer, int offset, int count);
    public ReadOnlySpan`1<char> get_Span();
    public virtual string ToString();
    public sealed virtual bool Equals(string other);
    public sealed virtual bool Equals(TextSpan other);
    public static TextSpan op_Implicit(string s);
}
internal static class Parlot.ThrowHelper : object {
    [DoesNotReturnAttribute]
public static void ThrowArgumentNullException(string paramName);
}
[IsReadOnlyAttribute]
public class Parlot.TokenResult : ValueType {
    private string _buffer;
    public int Start;
    public int Length;
    public ReadOnlySpan`1<char> Span { get; }
    private TokenResult(string buffer, int start, int length);
    public string GetText();
    public ReadOnlySpan`1<char> get_Span();
    public static TokenResult Succeed(string buffer, int start, int end);
    public static TokenResult Fail();
}
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("1774")]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
