internal class EnumerableAsync`1 : object {
    private SearchFilter _filter;
    private ILogger _logger;
    private string _searchTerm;
    private int _skip;
    private int _take;
    private CancellationToken _token;
    private IV2FeedParser _feedParser;
    private bool _isSearchAvailable;
    private bool _allVersions;
    public EnumerableAsync`1(IV2FeedParser feedParser, string searchTerm, SearchFilter filter, int skip, int take, bool isSearchAvailable, bool allVersions, ILogger logger, CancellationToken token);
    public sealed virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
internal class EnumeratorAsync : object {
    private SearchFilter _filter;
    private ILogger _logger;
    private string _searchTerm;
    private int _skip;
    private int _take;
    private CancellationToken _token;
    private IV2FeedParser _feedParser;
    private bool _isSearchAvailable;
    private bool _allVersions;
    private IEnumerator`1<IPackageSearchMetadata> _currentEnumerator;
    private V2FeedPage _currentPage;
    public IPackageSearchMetadata Current { get; }
    public EnumeratorAsync(IV2FeedParser feedParser, string searchTerm, SearchFilter filter, int skip, int take, bool isSearchAvailable, bool allVersions, ILogger logger, CancellationToken token);
    public sealed virtual IPackageSearchMetadata get_Current();
    [AsyncStateMachineAttribute("EnumeratorAsync/<MoveNextAsync>d__14")]
public sealed virtual Task`1<bool> MoveNextAsync();
}
internal static class FxResources.Microsoft.Extensions.FileProviders.Abstractions.SR : object {
}
internal static class FxResources.Microsoft.Extensions.FileSystemGlobbing.SR : object {
}
internal static class FxResources.Microsoft.Extensions.Primitives.SR : object {
}
internal static class FxResources.System.Buffers.SR : object {
}
internal static class FxResources.System.Memory.SR : object {
}
internal static class FxResources.System.Numerics.Vectors.SR : object {
}
internal static class FxResources.System.Text.Encodings.Web.SR : object {
}
internal static class FxResources.System.Text.Json.SR : object {
}
internal static class FxResources.System.ValueTuple.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[Microsoft.Bcl.AsyncInterfaces.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[Microsoft.Extensions.FileSystemGlobbing.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.Microsoft.Extensions.FileSystemGlobbing.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[Microsoft.Extensions.Primitives.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.Microsoft.Extensions.Primitives.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[Newtonsoft.Json.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.Newtonsoft.Json.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Commands.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Commands.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Common.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Common.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Configuration.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Configuration.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Credentials.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Credentials.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.DependencyResolver.Core.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.DependencyResolver.Core.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Frameworks.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Frameworks.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.LibraryModel.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.LibraryModel.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Packaging.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Packaging.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.ProjectModel.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.ProjectModel.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Protocol.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Protocol.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Versioning.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Versioning.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Memory.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.System.Memory.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Runtime.CompilerServices.Unsafe.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.System.Runtime.CompilerServices.Unsafe.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Encodings.Web.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.System.Text.Encodings.Web.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.System.Text.Json.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Threading.Tasks.Extensions.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.System.Threading.Tasks.Extensions.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Extensions.FileProviders.EmptyDisposable : object {
    [CompilerGeneratedAttribute]
private static EmptyDisposable <Instance>k__BackingField;
    public static EmptyDisposable Instance { get; }
    private static EmptyDisposable();
    [CompilerGeneratedAttribute]
public static EmptyDisposable get_Instance();
    public sealed virtual void Dispose();
}
internal interface Microsoft.Extensions.FileProviders.IDirectoryContents {
    public bool Exists { get; }
    public abstract virtual bool get_Exists();
}
internal interface Microsoft.Extensions.FileProviders.IFileInfo {
    public bool Exists { get; }
    public long Length { get; }
    public string PhysicalPath { get; }
    public string Name { get; }
    public DateTimeOffset LastModified { get; }
    public bool IsDirectory { get; }
    public abstract virtual bool get_Exists();
    public abstract virtual long get_Length();
    public abstract virtual string get_PhysicalPath();
    public abstract virtual string get_Name();
    public abstract virtual DateTimeOffset get_LastModified();
    public abstract virtual bool get_IsDirectory();
    public abstract virtual Stream CreateReadStream();
}
internal interface Microsoft.Extensions.FileProviders.IFileProvider {
    public abstract virtual IFileInfo GetFileInfo(string subpath);
    public abstract virtual IDirectoryContents GetDirectoryContents(string subpath);
    public abstract virtual IChangeToken Watch(string filter);
}
internal class Microsoft.Extensions.FileProviders.NotFoundDirectoryContents : object {
    [CompilerGeneratedAttribute]
private static NotFoundDirectoryContents <Singleton>k__BackingField;
    public static NotFoundDirectoryContents Singleton { get; }
    public bool Exists { get; }
    private static NotFoundDirectoryContents();
    [CompilerGeneratedAttribute]
public static NotFoundDirectoryContents get_Singleton();
    public sealed virtual bool get_Exists();
    public sealed virtual IEnumerator`1<IFileInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Extensions.FileProviders.NotFoundFileInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool Exists { get; }
    public bool IsDirectory { get; }
    public DateTimeOffset LastModified { get; }
    public long Length { get; }
    public string Name { get; }
    public string PhysicalPath { get; }
    public NotFoundFileInfo(string name);
    public sealed virtual bool get_Exists();
    public sealed virtual bool get_IsDirectory();
    public sealed virtual DateTimeOffset get_LastModified();
    public sealed virtual long get_Length();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual string get_PhysicalPath();
    public sealed virtual Stream CreateReadStream();
}
internal class Microsoft.Extensions.FileProviders.NullChangeToken : object {
    [CompilerGeneratedAttribute]
private static NullChangeToken <Singleton>k__BackingField;
    public static NullChangeToken Singleton { get; }
    public bool HasChanged { get; }
    public bool ActiveChangeCallbacks { get; }
    private static NullChangeToken();
    [CompilerGeneratedAttribute]
public static NullChangeToken get_Singleton();
    public sealed virtual bool get_HasChanged();
    public sealed virtual bool get_ActiveChangeCallbacks();
    public sealed virtual IDisposable RegisterChangeCallback(Action`1<object> callback, object state);
}
internal class Microsoft.Extensions.FileProviders.NullFileProvider : object {
    public sealed virtual IDirectoryContents GetDirectoryContents(string subpath);
    public sealed virtual IFileInfo GetFileInfo(string subpath);
    public sealed virtual IChangeToken Watch(string filter);
}
internal abstract class Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoBase : FileSystemInfoBase {
    public abstract virtual IEnumerable`1<FileSystemInfoBase> EnumerateFileSystemInfos();
    public abstract virtual DirectoryInfoBase GetDirectory(string path);
    public abstract virtual FileInfoBase GetFile(string path);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper : DirectoryInfoBase {
    private DirectoryInfo _directoryInfo;
    private bool _isParentPath;
    public string Name { get; }
    public string FullName { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public DirectoryInfoWrapper(DirectoryInfo directoryInfo);
    private DirectoryInfoWrapper(DirectoryInfo directoryInfo, bool isParentPath);
    [IteratorStateMachineAttribute("Microsoft.Extensions.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper/<EnumerateFileSystemInfos>d__4")]
public virtual IEnumerable`1<FileSystemInfoBase> EnumerateFileSystemInfos();
    public virtual DirectoryInfoBase GetDirectory(string name);
    public virtual FileInfoBase GetFile(string name);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual DirectoryInfoBase get_ParentDirectory();
}
internal abstract class Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoBase : FileSystemInfoBase {
}
internal class Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileInfoWrapper : FileInfoBase {
    private FileInfo _fileInfo;
    public string Name { get; }
    public string FullName { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public FileInfoWrapper(FileInfo fileInfo);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual DirectoryInfoBase get_ParentDirectory();
}
internal abstract class Microsoft.Extensions.FileSystemGlobbing.Abstractions.FileSystemInfoBase : object {
    public string Name { get; }
    public string FullName { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
    public abstract virtual DirectoryInfoBase get_ParentDirectory();
}
internal class Microsoft.Extensions.FileSystemGlobbing.FilePatternMatch : ValueType {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stem>k__BackingField;
    public string Path { get; }
    public string Stem { get; }
    public FilePatternMatch(string path, string stem);
    [Microsoft.Extensions.FileSystemGlobbing.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [Microsoft.Extensions.FileSystemGlobbing.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Stem();
    public sealed virtual bool Equals(FilePatternMatch other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static int GetHashCode(string value);
}
internal class Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo : DirectoryInfoBase {
    private static Char[] DirectorySeparators;
    private IEnumerable`1<string> _files;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string FullName { get; }
    public string Name { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public InMemoryDirectoryInfo(string rootDir, IEnumerable`1<string> files);
    private InMemoryDirectoryInfo(string rootDir, IEnumerable`1<string> files, bool normalized);
    private static InMemoryDirectoryInfo();
    [CompilerGeneratedAttribute]
public virtual string get_FullName();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public virtual DirectoryInfoBase get_ParentDirectory();
    [IteratorStateMachineAttribute("Microsoft.Extensions.FileSystemGlobbing.InMemoryDirectoryInfo/<EnumerateFileSystemInfos>d__12")]
public virtual IEnumerable`1<FileSystemInfoBase> EnumerateFileSystemInfos();
    private bool IsRootDirectory(string rootDir, string filePath);
    public virtual DirectoryInfoBase GetDirectory(string path);
    public virtual FileInfoBase GetFile(string path);
}
internal interface Microsoft.Extensions.FileSystemGlobbing.Internal.ILinearPattern {
    public IList`1<IPathSegment> Segments { get; }
    public abstract virtual IList`1<IPathSegment> get_Segments();
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.InMemoryFileInfo : FileInfoBase {
    private InMemoryDirectoryInfo _parent;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string FullName { get; }
    public string Name { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public InMemoryFileInfo(string file, InMemoryDirectoryInfo parent);
    [CompilerGeneratedAttribute]
public virtual string get_FullName();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public virtual DirectoryInfoBase get_ParentDirectory();
}
internal interface Microsoft.Extensions.FileSystemGlobbing.Internal.IPathSegment {
    public bool CanProduceStem { get; }
    public abstract virtual bool get_CanProduceStem();
    public abstract virtual bool Match(string value);
}
internal interface Microsoft.Extensions.FileSystemGlobbing.Internal.IPattern {
    public abstract virtual IPatternContext CreatePatternContextForInclude();
    public abstract virtual IPatternContext CreatePatternContextForExclude();
}
internal interface Microsoft.Extensions.FileSystemGlobbing.Internal.IPatternContext {
    public abstract virtual void Declare(Action`2<IPathSegment, bool> onDeclare);
    public abstract virtual bool Test(DirectoryInfoBase directory);
    public abstract virtual PatternTestResult Test(FileInfoBase file);
    public abstract virtual void PushDirectory(DirectoryInfoBase directory);
    public abstract virtual void PopDirectory();
}
internal interface Microsoft.Extensions.FileSystemGlobbing.Internal.IRaggedPattern {
    public IList`1<IPathSegment> Segments { get; }
    public IList`1<IPathSegment> StartsWith { get; }
    public IList`1<IList`1<IPathSegment>> Contains { get; }
    public IList`1<IPathSegment> EndsWith { get; }
    public abstract virtual IList`1<IPathSegment> get_Segments();
    public abstract virtual IList`1<IPathSegment> get_StartsWith();
    public abstract virtual IList`1<IList`1<IPathSegment>> get_Contains();
    public abstract virtual IList`1<IPathSegment> get_EndsWith();
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.MatcherContext : object {
    private DirectoryInfoBase _root;
    private List`1<IPatternContext> _includePatternContexts;
    private List`1<IPatternContext> _excludePatternContexts;
    private List`1<FilePatternMatch> _files;
    private HashSet`1<string> _declaredLiteralFolderSegmentInString;
    private HashSet`1<LiteralPathSegment> _declaredLiteralFolderSegments;
    private HashSet`1<LiteralPathSegment> _declaredLiteralFileSegments;
    private bool _declaredParentPathSegment;
    private bool _declaredWildcardPathSegment;
    private StringComparison _comparisonType;
    public MatcherContext(IEnumerable`1<IPattern> includePatterns, IEnumerable`1<IPattern> excludePatterns, DirectoryInfoBase directoryInfo, StringComparison comparison);
    public PatternMatchingResult Execute();
    private void Match(DirectoryInfoBase directory, string parentRelativePath);
    private void Declare();
    private void DeclareInclude(IPathSegment patternSegment, bool isLastSegment);
    internal static string CombinePath(string left, string right);
    private bool MatchPatternContexts(TFileInfoBase fileinfo, Func`3<IPatternContext, TFileInfoBase, bool> test);
    private PatternTestResult MatchPatternContexts(TFileInfoBase fileinfo, Func`3<IPatternContext, TFileInfoBase, PatternTestResult> test);
    private void PopDirectory();
    private void PushDirectory(DirectoryInfoBase directory);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment : object {
    public bool CanProduceStem { get; }
    public sealed virtual bool get_CanProduceStem();
    public sealed virtual bool Match(string value);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment : object {
    private StringComparison _comparisonType;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public bool CanProduceStem { get; }
    public string Value { get; }
    public LiteralPathSegment(string value, StringComparison comparisonType);
    public sealed virtual bool get_CanProduceStem();
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual bool Match(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment : object {
    private static string LiteralParent;
    public bool CanProduceStem { get; }
    public sealed virtual bool get_CanProduceStem();
    public sealed virtual bool Match(string value);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment : object {
    public bool CanProduceStem { get; }
    public sealed virtual bool get_CanProduceStem();
    public sealed virtual bool Match(string value);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment : object {
    public static WildcardPathSegment MatchAll;
    private StringComparison _comparisonType;
    [CompilerGeneratedAttribute]
private string <BeginsWith>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Contains>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndsWith>k__BackingField;
    public bool CanProduceStem { get; }
    public string BeginsWith { get; }
    public List`1<string> Contains { get; }
    public string EndsWith { get; }
    public WildcardPathSegment(string beginsWith, List`1<string> contains, string endsWith, StringComparison comparisonType);
    private static WildcardPathSegment();
    public sealed virtual bool get_CanProduceStem();
    [CompilerGeneratedAttribute]
public string get_BeginsWith();
    [CompilerGeneratedAttribute]
public List`1<string> get_Contains();
    [CompilerGeneratedAttribute]
public string get_EndsWith();
    public sealed virtual bool Match(string value);
}
internal abstract class Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContext`1 : object {
    private Stack`1<TFrame> _stack;
    protected TFrame Frame;
    public virtual void Declare(Action`2<IPathSegment, bool> declare);
    public abstract virtual PatternTestResult Test(FileInfoBase file);
    public abstract virtual bool Test(DirectoryInfoBase directory);
    public abstract virtual void PushDirectory(DirectoryInfoBase directory);
    public virtual void PopDirectory();
    protected void PushDataFrame(TFrame frame);
    protected bool IsStackEmpty();
}
internal abstract class Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear : PatternContext`1<FrameData> {
    [CompilerGeneratedAttribute]
private ILinearPattern <Pattern>k__BackingField;
    protected ILinearPattern Pattern { get; }
    public PatternContextLinear(ILinearPattern pattern);
    public virtual PatternTestResult Test(FileInfoBase file);
    public virtual void PushDirectory(DirectoryInfoBase directory);
    [CompilerGeneratedAttribute]
protected ILinearPattern get_Pattern();
    protected bool IsLastSegment();
    protected bool TestMatchingSegment(string value);
    protected string CalculateStem(FileInfoBase matchedFile);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearExclude : PatternContextLinear {
    public PatternContextLinearExclude(ILinearPattern pattern);
    public virtual bool Test(DirectoryInfoBase directory);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude : PatternContextLinear {
    public PatternContextLinearInclude(ILinearPattern pattern);
    public virtual void Declare(Action`2<IPathSegment, bool> onDeclare);
    public virtual bool Test(DirectoryInfoBase directory);
}
internal abstract class Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged : PatternContext`1<FrameData> {
    [CompilerGeneratedAttribute]
private IRaggedPattern <Pattern>k__BackingField;
    protected IRaggedPattern Pattern { get; }
    public PatternContextRagged(IRaggedPattern pattern);
    public virtual PatternTestResult Test(FileInfoBase file);
    public sealed virtual void PushDirectory(DirectoryInfoBase directory);
    public virtual void PopDirectory();
    [CompilerGeneratedAttribute]
protected IRaggedPattern get_Pattern();
    protected bool IsStartingGroup();
    protected bool IsEndingGroup();
    protected bool TestMatchingSegment(string value);
    protected bool TestMatchingGroup(FileSystemInfoBase value);
    protected string CalculateStem(FileInfoBase matchedFile);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedExclude : PatternContextRagged {
    public PatternContextRaggedExclude(IRaggedPattern pattern);
    public virtual bool Test(DirectoryInfoBase directory);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude : PatternContextRagged {
    public PatternContextRaggedInclude(IRaggedPattern pattern);
    public virtual void Declare(Action`2<IPathSegment, bool> onDeclare);
    public virtual bool Test(DirectoryInfoBase directory);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.Patterns.PatternBuilder : object {
    private static Char[] _slashes;
    private static Char[] _star;
    [CompilerGeneratedAttribute]
private StringComparison <ComparisonType>k__BackingField;
    public StringComparison ComparisonType { get; }
    public PatternBuilder(StringComparison comparisonType);
    private static PatternBuilder();
    [CompilerGeneratedAttribute]
public StringComparison get_ComparisonType();
    public IPattern Build(string pattern);
    private static int NextIndex(string pattern, Char[] anyOf, int beginIndex, int endIndex);
    private static string Portion(string pattern, int beginIndex, int endIndex);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Internal.PatternTestResult : ValueType {
    public static PatternTestResult Failed;
    [CompilerGeneratedAttribute]
private bool <IsSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stem>k__BackingField;
    public bool IsSuccessful { get; }
    public string Stem { get; }
    private PatternTestResult(bool isSuccessful, string stem);
    private static PatternTestResult();
    [Microsoft.Extensions.FileSystemGlobbing.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsSuccessful();
    [Microsoft.Extensions.FileSystemGlobbing.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Stem();
    public static PatternTestResult Success(string stem);
}
internal class Microsoft.Extensions.FileSystemGlobbing.Matcher : object {
    private IList`1<IPattern> _includePatterns;
    private IList`1<IPattern> _excludePatterns;
    private PatternBuilder _builder;
    private StringComparison _comparison;
    public Matcher(StringComparison comparisonType);
    public virtual Matcher AddInclude(string pattern);
    public virtual Matcher AddExclude(string pattern);
    public virtual PatternMatchingResult Execute(DirectoryInfoBase directoryInfo);
}
[ExtensionAttribute]
internal static class Microsoft.Extensions.FileSystemGlobbing.MatcherExtensions : object {
    [ExtensionAttribute]
public static void AddExcludePatterns(Matcher matcher, IEnumerable`1[] excludePatternsGroups);
    [ExtensionAttribute]
public static void AddIncludePatterns(Matcher matcher, IEnumerable`1[] includePatternsGroups);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetResultsInFullPath(Matcher matcher, string directoryPath);
    [ExtensionAttribute]
public static PatternMatchingResult Match(Matcher matcher, string file);
    [ExtensionAttribute]
public static PatternMatchingResult Match(Matcher matcher, string rootDir, string file);
    [ExtensionAttribute]
public static PatternMatchingResult Match(Matcher matcher, IEnumerable`1<string> files);
    [ExtensionAttribute]
public static PatternMatchingResult Match(Matcher matcher, string rootDir, IEnumerable`1<string> files);
}
internal class Microsoft.Extensions.FileSystemGlobbing.PatternMatchingResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<FilePatternMatch> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMatches>k__BackingField;
    public IEnumerable`1<FilePatternMatch> Files { get; public set; }
    public bool HasMatches { get; }
    public PatternMatchingResult(IEnumerable`1<FilePatternMatch> files);
    public PatternMatchingResult(IEnumerable`1<FilePatternMatch> files, bool hasMatches);
    [CompilerGeneratedAttribute]
public IEnumerable`1<FilePatternMatch> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IEnumerable`1<FilePatternMatch> value);
    [CompilerGeneratedAttribute]
public bool get_HasMatches();
}
internal static class Microsoft.Extensions.FileSystemGlobbing.Util.StringComparisonHelper : object {
    public static StringComparer GetStringComparer(StringComparison comparisonType);
}
internal class Microsoft.Extensions.Internal.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public void Add(IEnumerable e);
    public static int op_Implicit(HashCodeCombiner self);
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
    public static HashCodeCombiner Start();
}
internal class Microsoft.Extensions.Primitives.CancellationChangeToken : object {
    [CompilerGeneratedAttribute]
private bool <ActiveChangeCallbacks>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    public bool ActiveChangeCallbacks { get; private set; }
    public bool HasChanged { get; }
    private CancellationToken Token { get; }
    public CancellationChangeToken(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ActiveChangeCallbacks();
    [CompilerGeneratedAttribute]
private void set_ActiveChangeCallbacks(bool value);
    public sealed virtual bool get_HasChanged();
    [CompilerGeneratedAttribute]
private CancellationToken get_Token();
    public sealed virtual IDisposable RegisterChangeCallback(Action`1<object> callback, object state);
}
internal static class Microsoft.Extensions.Primitives.ChangeToken : object {
    public static IDisposable OnChange(Func`1<IChangeToken> changeTokenProducer, Action changeTokenConsumer);
    public static IDisposable OnChange(Func`1<IChangeToken> changeTokenProducer, Action`1<TState> changeTokenConsumer, TState state);
}
internal class Microsoft.Extensions.Primitives.CompositeChangeToken : object {
    private static Action`1<object> _onChangeDelegate;
    private object _callbackLock;
    private CancellationTokenSource _cancellationTokenSource;
    private bool _registeredCallbackProxy;
    private List`1<IDisposable> _disposables;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IChangeToken> <ChangeTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ActiveChangeCallbacks>k__BackingField;
    public IReadOnlyList`1<IChangeToken> ChangeTokens { get; }
    public bool HasChanged { get; }
    public bool ActiveChangeCallbacks { get; }
    public CompositeChangeToken(IReadOnlyList`1<IChangeToken> changeTokens);
    private static CompositeChangeToken();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IChangeToken> get_ChangeTokens();
    public sealed virtual IDisposable RegisterChangeCallback(Action`1<object> callback, object state);
    public sealed virtual bool get_HasChanged();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ActiveChangeCallbacks();
    private void EnsureCallbacksInitialized();
    private static void OnChange(object state);
}
internal enum Microsoft.Extensions.Primitives.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument buffer;
    public static ExceptionArgument offset;
    public static ExceptionArgument length;
    public static ExceptionArgument text;
    public static ExceptionArgument start;
    public static ExceptionArgument count;
    public static ExceptionArgument index;
    public static ExceptionArgument value;
    public static ExceptionArgument capacity;
    public static ExceptionArgument separators;
    public static ExceptionArgument comparisonType;
}
internal enum Microsoft.Extensions.Primitives.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource Argument_InvalidOffsetLength;
    public static ExceptionResource Argument_InvalidOffsetLengthStringSegment;
    public static ExceptionResource Capacity_CannotChangeAfterWriteStarted;
    public static ExceptionResource Capacity_NotEnough;
    public static ExceptionResource Capacity_NotUsedEntirely;
}
[ExtensionAttribute]
internal static class Microsoft.Extensions.Primitives.Extensions : object {
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder builder, StringSegment segment);
}
internal interface Microsoft.Extensions.Primitives.IChangeToken {
    public bool HasChanged { get; }
    public bool ActiveChangeCallbacks { get; }
    public abstract virtual bool get_HasChanged();
    public abstract virtual bool get_ActiveChangeCallbacks();
    public abstract virtual IDisposable RegisterChangeCallback(Action`1<object> callback, object state);
}
[Microsoft.Extensions.Primitives.IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Extensions.Primitives.StringSegment : ValueType {
    public static StringSegment Empty;
    [CompilerGeneratedAttribute]
private string <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public string Buffer { get; }
    public int Offset { get; }
    public int Length { get; }
    public string Value { get; }
    public bool HasValue { get; }
    public char Item { get; }
    public StringSegment(string buffer);
    public StringSegment(string buffer, int offset, int length);
    private static StringSegment();
    [CompilerGeneratedAttribute]
public string get_Buffer();
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public int get_Length();
    public string get_Value();
    public bool get_HasValue();
    public char get_Item(int index);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public ReadOnlyMemory`1<char> AsMemory();
    public static int Compare(StringSegment a, StringSegment b, StringComparison comparisonType);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringSegment other);
    public bool Equals(StringSegment other, StringComparison comparisonType);
    public static bool Equals(StringSegment a, StringSegment b, StringComparison comparisonType);
    public bool Equals(string text);
    public bool Equals(string text, StringComparison comparisonType);
    public virtual int GetHashCode();
    public static bool op_Equality(StringSegment left, StringSegment right);
    public static bool op_Inequality(StringSegment left, StringSegment right);
    public static StringSegment op_Implicit(string value);
    public static ReadOnlySpan`1<char> op_Implicit(StringSegment segment);
    public static ReadOnlyMemory`1<char> op_Implicit(StringSegment segment);
    public bool StartsWith(string text, StringComparison comparisonType);
    public bool EndsWith(string text, StringComparison comparisonType);
    public string Substring(int offset);
    public string Substring(int offset, int length);
    public StringSegment Subsegment(int offset);
    public StringSegment Subsegment(int offset, int length);
    public int IndexOf(char c, int start, int count);
    public int IndexOf(char c, int start);
    public int IndexOf(char c);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf);
    public int LastIndexOf(char value);
    public StringSegment Trim();
    public StringSegment TrimStart();
    public StringSegment TrimEnd();
    public StringTokenizer Split(Char[] chars);
    public static bool IsNullOrEmpty(StringSegment value);
    public virtual string ToString();
    private static void CheckStringComparison(StringComparison comparisonType);
    private static void ThrowInvalidArguments(string buffer, int offset, int length);
    private void ThrowInvalidArguments(int offset, int length, ExceptionArgument offsetOrStart);
    private sealed virtual override bool System.IEquatable<System.String>.Equals(string other);
    [CompilerGeneratedAttribute]
internal static Exception <ThrowInvalidArguments>g__GetInvalidArgumentsException|55_0(<>c__DisplayClass55_0& );
    [CompilerGeneratedAttribute]
internal static Exception <ThrowInvalidArguments>g__GetInvalidArgumentsException|56_0(bool hasValue, <>c__DisplayClass56_0& );
}
internal class Microsoft.Extensions.Primitives.StringSegmentComparer : object {
    [CompilerGeneratedAttribute]
private static StringSegmentComparer <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringSegmentComparer <OrdinalIgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <Comparison>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparer <Comparer>k__BackingField;
    public static StringSegmentComparer Ordinal { get; }
    public static StringSegmentComparer OrdinalIgnoreCase { get; }
    private StringComparison Comparison { get; }
    private StringComparer Comparer { get; }
    private StringSegmentComparer(StringComparison comparison, StringComparer comparer);
    private static StringSegmentComparer();
    [CompilerGeneratedAttribute]
public static StringSegmentComparer get_Ordinal();
    [CompilerGeneratedAttribute]
public static StringSegmentComparer get_OrdinalIgnoreCase();
    [CompilerGeneratedAttribute]
private StringComparison get_Comparison();
    [CompilerGeneratedAttribute]
private StringComparer get_Comparer();
    public sealed virtual int Compare(StringSegment x, StringSegment y);
    public sealed virtual bool Equals(StringSegment x, StringSegment y);
    public sealed virtual int GetHashCode(StringSegment obj);
}
[Microsoft.Extensions.Primitives.IsReadOnlyAttribute]
internal class Microsoft.Extensions.Primitives.StringTokenizer : ValueType {
    private StringSegment _value;
    private Char[] _separators;
    public StringTokenizer(string value, Char[] separators);
    public StringTokenizer(StringSegment value, Char[] separators);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<StringSegment> System.Collections.Generic.IEnumerable<Microsoft.Extensions.Primitives.StringSegment>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[Microsoft.Extensions.Primitives.IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Extensions.Primitives.StringValues : ValueType {
    public static StringValues Empty;
    private object _values;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.String>.IsReadOnly { get; }
    private string System.Collections.Generic.IList<System.String>.Item { get; private set; }
    public string Item { get; }
    public StringValues(string value);
    public StringValues(String[] values);
    private static StringValues();
    public static StringValues op_Implicit(string value);
    public static StringValues op_Implicit(String[] values);
    public static string op_Implicit(StringValues values);
    public static String[] op_Implicit(StringValues value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.String>.get_IsReadOnly();
    private sealed virtual override string System.Collections.Generic.IList<System.String>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.String>.set_Item(int index, string value);
    public sealed virtual string get_Item(int index);
    private static string OutOfBounds();
    public virtual string ToString();
    private string GetStringValue();
    public String[] ToArray();
    private String[] GetArrayValue();
    private sealed virtual override int System.Collections.Generic.IList<System.String>.IndexOf(string item);
    private int IndexOf(string item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.String>.Contains(string item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.String>.CopyTo(String[] array, int arrayIndex);
    private void CopyTo(String[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<System.String>.Add(string item);
    private sealed virtual override void System.Collections.Generic.IList<System.String>.Insert(int index, string item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.String>.Remove(string item);
    private sealed virtual override void System.Collections.Generic.IList<System.String>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.String>.Clear();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool IsNullOrEmpty(StringValues value);
    public static StringValues Concat(StringValues values1, StringValues values2);
    public static StringValues Concat(StringValues& values, string value);
    public static StringValues Concat(string value, StringValues& values);
    public static bool Equals(StringValues left, StringValues right);
    public static bool op_Equality(StringValues left, StringValues right);
    public static bool op_Inequality(StringValues left, StringValues right);
    public sealed virtual bool Equals(StringValues other);
    public static bool Equals(string left, StringValues right);
    public static bool Equals(StringValues left, string right);
    public sealed virtual bool Equals(string other);
    public static bool Equals(String[] left, StringValues right);
    public static bool Equals(StringValues left, String[] right);
    public sealed virtual bool Equals(String[] other);
    public static bool op_Equality(StringValues left, string right);
    public static bool op_Inequality(StringValues left, string right);
    public static bool op_Equality(string left, StringValues right);
    public static bool op_Inequality(string left, StringValues right);
    public static bool op_Equality(StringValues left, String[] right);
    public static bool op_Inequality(StringValues left, String[] right);
    public static bool op_Equality(String[] left, StringValues right);
    public static bool op_Inequality(String[] left, StringValues right);
    public static bool op_Equality(StringValues left, object right);
    public static bool op_Inequality(StringValues left, object right);
    public static bool op_Equality(object left, StringValues right);
    public static bool op_Inequality(object left, StringValues right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static string <GetStringValue>g__GetStringValueFromArray|19_0(object value);
    [CompilerGeneratedAttribute]
internal static string <GetStringValue>g__GetJoinedStringValueFromArray|19_1(String[] values);
}
internal static class Microsoft.Extensions.Primitives.ThrowHelper : object {
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    internal static void ThrowArgumentException(ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource);
    internal static void ThrowInvalidOperationException(ExceptionResource resource, Object[] args);
    internal static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    internal static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument);
    internal static ArgumentException GetArgumentException(ExceptionResource resource);
    private static string GetResourceText(ExceptionResource resource);
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceName(ExceptionResource resource);
}
internal class Newtonsoft.Json.Bson.BsonArray : BsonToken {
    private List`1<BsonToken> _children;
    public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Newtonsoft.Json.Bson.BsonBinary : BsonValue {
    [CompilerGeneratedAttribute]
private BsonBinaryType <BinaryType>k__BackingField;
    public BsonBinaryType BinaryType { get; public set; }
    public BsonBinary(Byte[] value, BsonBinaryType binaryType);
    [CompilerGeneratedAttribute]
public BsonBinaryType get_BinaryType();
    [CompilerGeneratedAttribute]
public void set_BinaryType(BsonBinaryType value);
}
internal enum Newtonsoft.Json.Bson.BsonBinaryType : Enum {
    public byte value__;
    public static BsonBinaryType Binary;
    public static BsonBinaryType Function;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Binary instead.")]
public static BsonBinaryType BinaryOld;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Uuid instead.")]
public static BsonBinaryType UuidOld;
    public static BsonBinaryType Uuid;
    public static BsonBinaryType Md5;
    public static BsonBinaryType UserDefined;
}
internal class Newtonsoft.Json.Bson.BsonBinaryWriter : object {
    private static Encoding Encoding;
    private BinaryWriter _writer;
    private Byte[] _largeByteBuffer;
    [CompilerGeneratedAttribute]
private DateTimeKind <DateTimeKindHandling>k__BackingField;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(BinaryWriter writer);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void Close();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    public void WriteUtf8Bytes(string s, int byteCount);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
internal class Newtonsoft.Json.Bson.BsonBoolean : BsonValue {
    public static BsonBoolean False;
    public static BsonBoolean True;
    private BsonBoolean(bool value);
    private static BsonBoolean();
}
internal class Newtonsoft.Json.Bson.BsonEmpty : BsonToken {
    public static BsonToken Null;
    public static BsonToken Undefined;
    [CompilerGeneratedAttribute]
private BsonType <Type>k__BackingField;
    public BsonType Type { get; }
    private BsonEmpty(BsonType type);
    private static BsonEmpty();
    [CompilerGeneratedAttribute]
public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonObject : BsonToken {
    private List`1<BsonProperty> _children;
    public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Newtonsoft.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
}
internal class Newtonsoft.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]
private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonToken <Value>k__BackingField;
    public BsonString Name { get; public set; }
    public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Newtonsoft.Json.Bson.BsonReader : JsonReader {
    private static int MaxCharBytesSize;
    private static Byte[] SeqRange1;
    private static Byte[] SeqRange2;
    private static Byte[] SeqRange3;
    private static Byte[] SeqRange4;
    private BinaryReader _reader;
    private List`1<ContainerContext> _stack;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;
    private bool _readRootValueAsArray;
    private bool _jsonNet35BinaryCompatibility;
    private DateTimeKind _dateTimeKindHandling;
    [ObsoleteAttribute("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
public bool JsonNet35BinaryCompatibility { get; public set; }
    public bool ReadRootValueAsArray { get; public set; }
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(BinaryReader reader);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_JsonNet35BinaryCompatibility();
    public void set_JsonNet35BinaryCompatibility(bool value);
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual bool Read();
    public virtual void Close();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary(BsonBinaryType& binaryType);
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
internal class Newtonsoft.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]
private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonString <Options>k__BackingField;
    public BsonString Pattern { get; public set; }
    public BsonString Options { get; public set; }
    public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
internal class Newtonsoft.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLength>k__BackingField;
    public int ByteCount { get; public set; }
    public bool IncludeLength { get; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
}
internal abstract class Newtonsoft.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]
private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalculatedSize>k__BackingField;
    public BsonType Type { get; }
    public BsonToken Parent { get; public set; }
    public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
internal enum Newtonsoft.Json.Bson.BsonType : Enum {
    public sbyte value__;
    public static BsonType Number;
    public static BsonType String;
    public static BsonType Object;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType Undefined;
    public static BsonType Oid;
    public static BsonType Boolean;
    public static BsonType Date;
    public static BsonType Null;
    public static BsonType Regex;
    public static BsonType Reference;
    public static BsonType Code;
    public static BsonType Symbol;
    public static BsonType CodeWScope;
    public static BsonType Integer;
    public static BsonType TimeStamp;
    public static BsonType Long;
    public static BsonType MinKey;
    public static BsonType MaxKey;
}
internal class Newtonsoft.Json.Bson.BsonValue : BsonToken {
    private object _value;
    private BsonType _type;
    public object Value { get; }
    public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Newtonsoft.Json.Bson.BsonWriter : JsonWriter {
    private BsonBinaryWriter _writer;
    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public BsonWriter(BinaryWriter writer);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    public virtual void Close();
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
internal enum Newtonsoft.Json.ConstructorHandling : Enum {
    public int value__;
    public static ConstructorHandling Default;
    public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.BinaryConverter : JsonConverter {
    private static string BinaryTypeName;
    private static string BinaryToArrayName;
    [Newtonsoft.Json.NullableAttribute("2")]
private static ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    private static void EnsureReflectionObject(Type t);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private Byte[] ReadByteArray(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Newtonsoft.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.DataSetConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type valueType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.DataTableConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void CreateRow(JsonReader reader, DataTable dt, JsonSerializer serializer);
    private static Type GetColumnDataType(JsonReader reader);
    public virtual bool CanConvert(Type valueType);
}
internal abstract class Newtonsoft.Json.Converters.DateTimeConverterBase : JsonConverter {
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual bool CanConvert(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.DiscriminatedUnionConverter : JsonConverter {
    private static string CasePropertyName;
    private static string FieldsPropertyName;
    private static ThreadSafeStore`2<Type, Union> UnionCache;
    private static ThreadSafeStore`2<Type, Type> UnionTypeLookupCache;
    private static DiscriminatedUnionConverter();
    private static Type CreateUnionTypeLookup(Type t);
    private static Union CreateUnion(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.EntityKeyMemberConverter : JsonConverter {
    private static string EntityKeyMemberFullTypeName;
    private static string KeyPropertyName;
    private static string TypePropertyName;
    private static string ValuePropertyName;
    [Newtonsoft.Json.NullableAttribute("2")]
private static ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static void ReadAndAssertProperty(JsonReader reader, string propertyName);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void EnsureReflectionObject(Type objectType);
    public virtual bool CanConvert(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.ExpandoObjectConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadValue(JsonReader reader);
    private object ReadList(JsonReader reader);
    private object ReadObject(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    private static string DefaultDateTimeFormat;
    private DateTimeStyles _dateTimeStyles;
    [Newtonsoft.Json.NullableAttribute("2")]
private string _dateTimeFormat;
    [Newtonsoft.Json.NullableAttribute("2")]
private CultureInfo _culture;
    public DateTimeStyles DateTimeStyles { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public string DateTimeFormat { get; public set; }
    public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public string get_DateTimeFormat();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlDeclaration {
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Converters.IXmlDocument {
    [Newtonsoft.Json.NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public abstract virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public abstract virtual IXmlElement get_DocumentElement();
}
[Newtonsoft.Json.NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlDocumentType {
    [Newtonsoft.Json.NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public abstract virtual string get_Name();
    public abstract virtual string get_System();
    public abstract virtual string get_Public();
    public abstract virtual string get_InternalSubset();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Converters.IXmlElement {
    public bool IsEmpty { get; }
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
    public abstract virtual string GetPrefixOfNamespace(string namespaceUri);
    public abstract virtual bool get_IsEmpty();
}
[Newtonsoft.Json.NullableContextAttribute("2")]
internal interface Newtonsoft.Json.Converters.IXmlNode {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public abstract virtual List`1<IXmlNode> get_ChildNodes();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public abstract virtual List`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceUri();
    public abstract virtual object get_WrappedNode();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.KeyValuePairConverter : JsonConverter {
    private static string KeyName;
    private static string ValueName;
    private static ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType;
    private static KeyValuePairConverter();
    private static ReflectionObject InitializeReflectionObject(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.RegexConverter : JsonConverter {
    private static string PatternName;
    private static string OptionsName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadRegexString(JsonReader reader);
    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private bool IsRegex(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.StringEnumConverter : JsonConverter {
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIntegerValues>k__BackingField;
    [ObsoleteAttribute("StringEnumConverter.CamelCaseText is obsolete. Set StringEnumConverter.NamingStrategy with CamelCaseNamingStrategy instead.")]
public bool CamelCaseText { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public NamingStrategy NamingStrategy { get; public set; }
    public bool AllowIntegerValues { get; public set; }
    [ObsoleteAttribute("StringEnumConverter(bool) is obsolete. Create a converter with StringEnumConverter(NamingStrategy, bool) instead.")]
public StringEnumConverter(bool camelCaseText);
    public StringEnumConverter(NamingStrategy namingStrategy, bool allowIntegerValues);
    public StringEnumConverter(Type namingStrategyType);
    public StringEnumConverter(Type namingStrategyType, Object[] namingStrategyParameters);
    public StringEnumConverter(Type namingStrategyType, Object[] namingStrategyParameters, bool allowIntegerValues);
    public bool get_CamelCaseText();
    public void set_CamelCaseText(bool value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NamingStrategy get_NamingStrategy();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NamingStrategy(NamingStrategy value);
    [CompilerGeneratedAttribute]
public bool get_AllowIntegerValues();
    [CompilerGeneratedAttribute]
public void set_AllowIntegerValues(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.UnixDateTimeConverter : DateTimeConverterBase {
    internal static DateTime UnixEpoch;
    [CompilerGeneratedAttribute]
private bool <AllowPreEpoch>k__BackingField;
    public bool AllowPreEpoch { get; public set; }
    public UnixDateTimeConverter(bool allowPreEpoch);
    private static UnixDateTimeConverter();
    [CompilerGeneratedAttribute]
public bool get_AllowPreEpoch();
    [CompilerGeneratedAttribute]
public void set_AllowPreEpoch(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.VersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XAttributeWrapper : XObjectWrapper {
    [Newtonsoft.Json.NullableAttribute("1")]
private XAttribute Attribute { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public IXmlNode ParentNode { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XAttributeWrapper(XAttribute attribute);
    [Newtonsoft.Json.NullableContextAttribute("1")]
private XAttribute get_Attribute();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual IXmlNode get_ParentNode();
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XCommentWrapper : XObjectWrapper {
    [Newtonsoft.Json.NullableAttribute("1")]
private XComment Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XCommentWrapper(XComment text);
    [Newtonsoft.Json.NullableContextAttribute("1")]
private XComment get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XContainerWrapper : XObjectWrapper {
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _childNodes;
    private XContainer Container { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public IXmlNode ParentNode { get; }
    public XContainerWrapper(XContainer container);
    private XContainer get_Container();
    public virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual IXmlNode get_ParentNode();
    internal static IXmlNode WrapNode(XObject node);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDeclarationWrapper : XObjectWrapper {
    [Newtonsoft.Json.NullableAttribute("1")]
[CompilerGeneratedAttribute]
private XDeclaration <Declaration>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("1")]
internal XDeclaration Declaration { get; }
    public XmlNodeType NodeType { get; }
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XDeclarationWrapper(XDeclaration declaration);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal XDeclaration get_Declaration();
    public virtual XmlNodeType get_NodeType();
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
    [Newtonsoft.Json.NullableAttribute("1")]
private XDocumentType _documentType;
    [Newtonsoft.Json.NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XDocumentTypeWrapper(XDocumentType documentType);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XDocumentWrapper : XContainerWrapper {
    private XDocument Document { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public XDocumentWrapper(XDocument document);
    private XDocument get_Document();
    public virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    public sealed virtual IXmlNode CreateComment(string text);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public sealed virtual IXmlElement get_DocumentElement();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XElementWrapper : XContainerWrapper {
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _attributes;
    private XElement Element { get; }
    public List`1<IXmlNode> Attributes { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public string Value { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public string LocalName { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public string NamespaceUri { get; }
    public bool IsEmpty { get; }
    public XElementWrapper(XElement element);
    private XElement get_Element();
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public virtual List`1<IXmlNode> get_Attributes();
    private bool HasImplicitNamespaceAttribute(string namespaceUri);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual string get_Value();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void set_Value(string value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual string get_LocalName();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual string get_NamespaceUri();
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    [Newtonsoft.Json.NullableAttribute("1")]
private XmlDeclaration _declaration;
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
    [Newtonsoft.Json.NullableAttribute("1")]
private XmlDocumentType _documentType;
    [Newtonsoft.Json.NullableAttribute("1")]
public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public string LocalName { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XmlDocumentTypeWrapper(XmlDocumentType documentType);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    public virtual string get_LocalName();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    private XmlDocument _document;
    [Newtonsoft.Json.NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public sealed virtual IXmlElement get_DocumentElement();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    private XmlElement _element;
    public bool IsEmpty { get; }
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlNodeConverter : JsonConverter {
    internal static List`1<IXmlNode> EmptyChildNodes;
    private static string TextName;
    private static string CommentName;
    private static string CDataName;
    private static string WhitespaceName;
    private static string SignificantWhitespaceName;
    private static string DeclarationName;
    private static string JsonNamespaceUri;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitRootObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncodeSpecialCharacters>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
public string DeserializeRootElementName { get; public set; }
    public bool WriteArrayAttribute { get; public set; }
    public bool OmitRootObject { get; public set; }
    public bool EncodeSpecialCharacters { get; public set; }
    private static XmlNodeConverter();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteArrayAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteArrayAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitRootObject();
    [CompilerGeneratedAttribute]
public void set_OmitRootObject(bool value);
    [CompilerGeneratedAttribute]
public bool get_EncodeSpecialCharacters();
    [CompilerGeneratedAttribute]
public void set_EncodeSpecialCharacters(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private IXmlNode WrapXml(object value);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private bool IsArray(IXmlNode node);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, List`1<IXmlNode> groupedNodes, string elementNames);
    private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, IXmlNode node, string elementNames);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private static bool AllSameName(IXmlNode node);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary`2<string, string> attributeNameValues);
    private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, string attributeName, XmlNamespaceManager manager, string attributePrefix);
    private static string ConvertTokenToXmlValue(JsonReader reader);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document);
    private bool ShouldReadInto(JsonReader reader);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private bool ValueAttributes(List`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
    private bool IsXObject(Type valueType);
    private bool IsXmlNode(Type valueType);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XmlNodeWrapper : object {
    [Newtonsoft.Json.NullableAttribute("1")]
private XmlNode _node;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _childNodes;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _attributes;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    private bool HasAttributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public sealed virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal static IXmlNode WrapNode(XmlNode node);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public sealed virtual List`1<IXmlNode> get_Attributes();
    private bool get_HasAttributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public sealed virtual string get_NamespaceUri();
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XObjectWrapper : object {
    private XObject _xmlObject;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public List`1<IXmlNode> ChildNodes { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XObjectWrapper(XObject xmlObject);
    public sealed virtual object get_WrappedNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual List`1<IXmlNode> get_ChildNodes();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual List`1<IXmlNode> get_Attributes();
    public virtual IXmlNode get_ParentNode();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_NamespaceUri();
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
    [Newtonsoft.Json.NullableAttribute("1")]
private XProcessingInstruction ProcessingInstruction { get; }
    public string LocalName { get; }
    public string Value { get; public set; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction);
    [Newtonsoft.Json.NullableContextAttribute("1")]
private XProcessingInstruction get_ProcessingInstruction();
    public virtual string get_LocalName();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Converters.XTextWrapper : XObjectWrapper {
    [Newtonsoft.Json.NullableAttribute("1")]
private XText Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public XTextWrapper(XText text);
    [Newtonsoft.Json.NullableContextAttribute("1")]
private XText get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
internal enum Newtonsoft.Json.DateFormatHandling : Enum {
    public int value__;
    public static DateFormatHandling IsoDateFormat;
    public static DateFormatHandling MicrosoftDateFormat;
}
internal enum Newtonsoft.Json.DateParseHandling : Enum {
    public int value__;
    public static DateParseHandling None;
    public static DateParseHandling DateTime;
    public static DateParseHandling DateTimeOffset;
}
internal enum Newtonsoft.Json.DateTimeZoneHandling : Enum {
    public int value__;
    public static DateTimeZoneHandling Local;
    public static DateTimeZoneHandling Utc;
    public static DateTimeZoneHandling Unspecified;
    public static DateTimeZoneHandling RoundtripKind;
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.DefaultJsonNameTable : JsonNameTable {
    private static int HashCodeRandomizer;
    private int _count;
    private Entry[] _entries;
    private int _mask;
    private static DefaultJsonNameTable();
    public virtual string Get(Char[] key, int start, int length);
    public string Add(string key);
    private string AddEntry(string str, int hashCode);
    private void Grow();
    private static bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length);
}
[FlagsAttribute]
internal enum Newtonsoft.Json.DefaultValueHandling : Enum {
    public int value__;
    public static DefaultValueHandling Include;
    public static DefaultValueHandling Ignore;
    public static DefaultValueHandling Populate;
    public static DefaultValueHandling IgnoreAndPopulate;
}
internal enum Newtonsoft.Json.FloatFormatHandling : Enum {
    public int value__;
    public static FloatFormatHandling String;
    public static FloatFormatHandling Symbol;
    public static FloatFormatHandling DefaultValue;
}
internal enum Newtonsoft.Json.FloatParseHandling : Enum {
    public int value__;
    public static FloatParseHandling Double;
    public static FloatParseHandling Decimal;
}
internal enum Newtonsoft.Json.Formatting : Enum {
    public int value__;
    public static Formatting None;
    public static Formatting Indented;
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.IArrayPool`1 {
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array);
}
internal interface Newtonsoft.Json.IJsonLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[AttributeUsageAttribute("1028")]
internal class Newtonsoft.Json.JsonArrayAttribute : JsonContainerAttribute {
    private bool _allowNullItems;
    public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[AttributeUsageAttribute("32")]
internal class Newtonsoft.Json.JsonConstructorAttribute : Attribute {
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
internal abstract class Newtonsoft.Json.JsonContainerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategyInstance>k__BackingField;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    private Type _namingStrategyType;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _namingStrategyParameters;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public Type ItemConverterType { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ItemConverterParameters { get; public set; }
    public Type NamingStrategyType { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] NamingStrategyParameters { get; public set; }
    internal NamingStrategy NamingStrategyInstance { get; internal set; }
    public bool IsReference { get; public set; }
    public bool ItemIsReference { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public Type get_NamingStrategyType();
    public void set_NamingStrategyType(Type value);
    public Object[] get_NamingStrategyParameters();
    public void set_NamingStrategyParameters(Object[] value);
    [CompilerGeneratedAttribute]
internal NamingStrategy get_NamingStrategyInstance();
    [CompilerGeneratedAttribute]
internal void set_NamingStrategyInstance(NamingStrategy value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
}
internal enum Newtonsoft.Json.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.JsonConvert : object {
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField;
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`1<JsonSerializerSettings> DefaultSettings { get; public set; }
    private static JsonConvert();
    [CompilerGeneratedAttribute]
public static Func`1<JsonSerializerSettings> get_DefaultSettings();
    [CompilerGeneratedAttribute]
public static void set_DefaultSettings(Func`1<JsonSerializerSettings> value);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, DateFormatHandling format);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    private static string ToStringInternal(BigInteger value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    public static string ToString(double value);
    internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    internal static string ToString(Guid value, char quoteChar);
    public static string ToString(TimeSpan value);
    internal static string ToString(TimeSpan value, char quoteChar);
    public static string ToString(Uri value);
    internal static string ToString(Uri value, char quoteChar);
    public static string ToString(string value);
    public static string ToString(string value, char delimiter);
    public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling);
    public static string ToString(object value);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, JsonConverter[] converters);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, JsonSerializerSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Type type, JsonSerializerSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings);
    private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, Type type);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static T DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value, JsonConverter[] converters);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static T DeserializeObject(string value, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject);
    public static XmlDocument DeserializeXmlNode(string value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters);
    public static string SerializeXNode(XObject node);
    public static string SerializeXNode(XObject node, Formatting formatting);
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject);
    public static XDocument DeserializeXNode(string value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.JsonConverter : object {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.JsonConverter`1 : JsonConverter {
    public sealed virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual void WriteJson(JsonWriter writer, T value, JsonSerializer serializer);
    public sealed virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T ReadJson(JsonReader reader, Type objectType, T existingValue, bool hasExistingValue, JsonSerializer serializer);
    public sealed virtual bool CanConvert(Type objectType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[AttributeUsageAttribute("3484")]
internal class Newtonsoft.Json.JsonConverterAttribute : Attribute {
    private Type _converterType;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ConverterParameters>k__BackingField;
    public Type ConverterType { get; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ConverterParameters { get; }
    public JsonConverterAttribute(Type converterType);
    public JsonConverterAttribute(Type converterType, Object[] converterParameters);
    public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public Object[] get_ConverterParameters();
}
[Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Newtonsoft.Json.JsonConverterCollection : Collection`1<JsonConverter> {
}
[AttributeUsageAttribute("1028")]
internal class Newtonsoft.Json.JsonDictionaryAttribute : JsonContainerAttribute {
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonDictionaryAttribute(string id);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonException : Exception {
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    public JsonException(SerializationInfo info, StreamingContext context);
    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("384")]
internal class Newtonsoft.Json.JsonExtensionDataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WriteData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadData>k__BackingField;
    public bool WriteData { get; public set; }
    public bool ReadData { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WriteData();
    [CompilerGeneratedAttribute]
public void set_WriteData(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadData();
    [CompilerGeneratedAttribute]
public void set_ReadData(bool value);
}
[AttributeUsageAttribute("384")]
internal class Newtonsoft.Json.JsonIgnoreAttribute : Attribute {
}
internal abstract class Newtonsoft.Json.JsonNameTable : object {
    [Newtonsoft.Json.NullableContextAttribute("1")]
public abstract virtual string Get(Char[] key, int start, int length);
}
[AttributeUsageAttribute("1036")]
internal class Newtonsoft.Json.JsonObjectAttribute : JsonContainerAttribute {
    private MemberSerialization _memberSerialization;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<Required> _itemRequired;
    internal Nullable`1<NullValueHandling> _itemNullValueHandling;
    public MemberSerialization MemberSerialization { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling ItemNullValueHandling { get; public set; }
    public Required ItemRequired { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public NullValueHandling get_ItemNullValueHandling();
    public void set_ItemNullValueHandling(NullValueHandling value);
    public Required get_ItemRequired();
    public void set_ItemRequired(Required value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonPosition : ValueType {
    private static Char[] SpecialCharacters;
    internal JsonContainerType Type;
    internal int Position;
    [Newtonsoft.Json.NullableAttribute("2")]
internal string PropertyName;
    internal bool HasIndex;
    public JsonPosition(JsonContainerType type);
    private static JsonPosition();
    internal int CalculateLength();
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal void WriteTo(StringBuilder sb, StringWriter& writer, Char[]& buffer);
    internal static bool TypeHasIndex(JsonContainerType type);
    internal static string BuildPath(List`1<JsonPosition> positions, Nullable`1<JsonPosition> currentPosition);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
internal class Newtonsoft.Json.JsonPropertyAttribute : Attribute {
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<int> _order;
    internal Nullable`1<Required> _required;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NamingStrategyType>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <NamingStrategyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public Type ItemConverterType { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ItemConverterParameters { get; public set; }
    public Type NamingStrategyType { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] NamingStrategyParameters { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public bool IsReference { get; public set; }
    public int Order { get; public set; }
    public Required Required { get; public set; }
    public string PropertyName { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    public bool ItemIsReference { get; public set; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    [CompilerGeneratedAttribute]
public Type get_NamingStrategyType();
    [CompilerGeneratedAttribute]
public void set_NamingStrategyType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_NamingStrategyParameters();
    [CompilerGeneratedAttribute]
public void set_NamingStrategyParameters(Object[] value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public int get_Order();
    public void set_Order(int value);
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    private JsonPosition _currentPosition;
    private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    internal FloatParseHandling _floatParseHandling;
    private string _dateFormatString;
    private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public char QuoteChar { get; protected internal set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public Type ValueType { get; }
    public int Depth { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public string Path { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public CultureInfo Culture { get; public set; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<SkipAsync>d__1")]
public Task SkipAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReaderReadAndAssertAsync>d__2")]
internal Task ReaderReadAndAssertAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<bool>> ReadAsBooleanAsync(CancellationToken cancellationToken);
    public virtual Task`1<Byte[]> ReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReadArrayIntoByteArrayAsync>d__5")]
internal Task`1<Byte[]> ReadArrayIntoByteArrayAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<DateTime>> ReadAsDateTimeAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<decimal>> ReadAsDecimalAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<double>> ReadAsDoubleAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual Task`1<Nullable`1<int>> ReadAsInt32Async(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<ReadAndMoveToContentAsync>d__12")]
internal Task`1<bool> ReadAndMoveToContentAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal Task`1<bool> MoveToContentAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Newtonsoft.Json.JsonReader/<MoveToContentFromNonContentAsync>d__14")]
private Task`1<bool> MoveToContentFromNonContentAsync(CancellationToken cancellationToken);
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual Type get_ValueType();
    public virtual int get_Depth();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual string get_Path();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public CultureInfo get_Culture();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    internal Nullable`1<int> ReadInt32String(string s);
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal Byte[] ReadArrayIntoByteArray();
    [Newtonsoft.Json.NullableContextAttribute("1")]
private bool ReadArrayElementIntoByteArrayReportDone(List`1<byte> buffer);
    public virtual Nullable`1<double> ReadAsDouble();
    internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    internal Nullable`1<decimal> ReadDecimalString(string s);
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    internal Nullable`1<DateTime> ReadDateTimeString(string s);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    internal Nullable`1<DateTimeOffset> ReadDateTimeOffsetString(string s);
    internal void ReaderReadAndAssert();
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal JsonReaderException CreateUnexpectedEndException();
    internal void ReadIntoWrappedTypeObject();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    protected void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    internal void ReadForTypeAndAssert(JsonContract contract, bool hasConverter);
    internal bool ReadForType(JsonContract contract, bool hasConverter);
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonReaderException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public string Path { get; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    public JsonReaderException(SerializationInfo info, StreamingContext context);
    public JsonReaderException(string message, string path, int lineNumber, int linePosition, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonReaderException Create(JsonReader reader, string message);
    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex);
    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[AttributeUsageAttribute("384")]
internal class Newtonsoft.Json.JsonRequiredAttribute : Attribute {
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonSerializationException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public string Path { get; }
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
    public JsonSerializationException(SerializationInfo info, StreamingContext context);
    public JsonSerializationException(string message, string path, int lineNumber, int linePosition, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonSerializationException Create(JsonReader reader, string message);
    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex);
    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonSerializer : object {
    internal TypeNameHandling _typeNameHandling;
    internal TypeNameAssemblyFormatHandling _typeNameAssemblyFormatHandling;
    internal PreserveReferencesHandling _preserveReferencesHandling;
    internal ReferenceLoopHandling _referenceLoopHandling;
    internal MissingMemberHandling _missingMemberHandling;
    internal ObjectCreationHandling _objectCreationHandling;
    internal NullValueHandling _nullValueHandling;
    internal DefaultValueHandling _defaultValueHandling;
    internal ConstructorHandling _constructorHandling;
    internal MetadataPropertyHandling _metadataPropertyHandling;
    [Newtonsoft.Json.NullableAttribute("2")]
internal JsonConverterCollection _converters;
    internal IContractResolver _contractResolver;
    [Newtonsoft.Json.NullableAttribute("2")]
internal ITraceWriter _traceWriter;
    [Newtonsoft.Json.NullableAttribute("2")]
internal IEqualityComparer _equalityComparer;
    internal ISerializationBinder _serializationBinder;
    internal StreamingContext _context;
    [Newtonsoft.Json.NullableAttribute("2")]
private IReferenceResolver _referenceResolver;
    private Nullable`1<Formatting> _formatting;
    private Nullable`1<DateFormatHandling> _dateFormatHandling;
    private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    private Nullable`1<DateParseHandling> _dateParseHandling;
    private Nullable`1<FloatFormatHandling> _floatFormatHandling;
    private Nullable`1<FloatParseHandling> _floatParseHandling;
    private Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _maxDepthSet;
    private Nullable`1<bool> _checkAdditionalContent;
    [Newtonsoft.Json.NullableAttribute("2")]
private string _dateFormatString;
    private bool _dateFormatStringSet;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Error;
    [Newtonsoft.Json.NullableAttribute("2")]
public IReferenceResolver ReferenceResolver { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public ITraceWriter TraceWriter { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public IEqualityComparer EqualityComparer { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public JsonConverterCollection Converters { get; }
    public IContractResolver ContractResolver { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    [CompilerGeneratedAttribute]
public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual IReferenceResolver get_ReferenceResolver();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ISerializationBinder get_SerializationBinder();
    public virtual void set_SerializationBinder(ISerializationBinder value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual ITraceWriter get_TraceWriter();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void set_TraceWriter(ITraceWriter value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual IEqualityComparer get_EqualityComparer();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public virtual void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal bool IsCheckAdditionalContentSet();
    public static JsonSerializer Create();
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public static JsonSerializer CreateDefault();
    public static JsonSerializer CreateDefault(JsonSerializerSettings settings);
    private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public void Populate(TextReader reader, object target);
    [DebuggerStepThroughAttribute]
public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    [DebuggerStepThroughAttribute]
public object Deserialize(JsonReader reader);
    [DebuggerStepThroughAttribute]
public object Deserialize(TextReader reader, Type objectType);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public T Deserialize(JsonReader reader);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public object Deserialize(JsonReader reader, Type objectType);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString);
    public void Serialize(TextWriter textWriter, object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    public void Serialize(TextWriter textWriter, object value, Type objectType);
    public void Serialize(JsonWriter jsonWriter, object value);
    private TraceJsonReader CreateTraceJsonReader(JsonReader reader);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType);
    internal IReferenceResolver GetReferenceResolver();
    internal JsonConverter GetMatchingConverter(Type type);
    internal static JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType);
    internal void OnError(ErrorEventArgs e);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonSerializerSettings : object {
    internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    internal static MissingMemberHandling DefaultMissingMemberHandling;
    internal static NullValueHandling DefaultNullValueHandling;
    internal static DefaultValueHandling DefaultDefaultValueHandling;
    internal static ObjectCreationHandling DefaultObjectCreationHandling;
    internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    internal static ConstructorHandling DefaultConstructorHandling;
    internal static TypeNameHandling DefaultTypeNameHandling;
    internal static MetadataPropertyHandling DefaultMetadataPropertyHandling;
    internal static StreamingContext DefaultContext;
    internal static Formatting DefaultFormatting;
    internal static DateFormatHandling DefaultDateFormatHandling;
    internal static DateTimeZoneHandling DefaultDateTimeZoneHandling;
    internal static DateParseHandling DefaultDateParseHandling;
    internal static FloatParseHandling DefaultFloatParseHandling;
    internal static FloatFormatHandling DefaultFloatFormatHandling;
    internal static StringEscapeHandling DefaultStringEscapeHandling;
    internal static TypeNameAssemblyFormatHandling DefaultTypeNameAssemblyFormatHandling;
    [Newtonsoft.Json.NullableAttribute("1")]
internal static CultureInfo DefaultCulture;
    internal static bool DefaultCheckAdditionalContent;
    [Newtonsoft.Json.NullableAttribute("1")]
internal static string DefaultDateFormatString;
    internal static int DefaultMaxDepth;
    internal Nullable`1<Formatting> _formatting;
    internal Nullable`1<DateFormatHandling> _dateFormatHandling;
    internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    internal Nullable`1<DateParseHandling> _dateParseHandling;
    internal Nullable`1<FloatFormatHandling> _floatFormatHandling;
    internal Nullable`1<FloatParseHandling> _floatParseHandling;
    internal Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    internal CultureInfo _culture;
    internal Nullable`1<bool> _checkAdditionalContent;
    internal Nullable`1<int> _maxDepth;
    internal bool _maxDepthSet;
    internal string _dateFormatString;
    internal bool _dateFormatStringSet;
    internal Nullable`1<TypeNameAssemblyFormatHandling> _typeNameAssemblyFormatHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling;
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<StreamingContext> _context;
    internal Nullable`1<ConstructorHandling> _constructorHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling;
    [Newtonsoft.Json.NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer <EqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializationBinder <SerializationBinder>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    [Newtonsoft.Json.NullableAttribute("1")]
public IList`1<JsonConverter> Converters { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public IEqualityComparer EqualityComparer { get; public set; }
    [ObsoleteAttribute("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
public IReferenceResolver ReferenceResolver { get; public set; }
    public Func`1<IReferenceResolver> ReferenceResolverProvider { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    public StreamingContext Context { get; public set; }
    [Newtonsoft.Json.NullableAttribute("1")]
public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    [Newtonsoft.Json.NullableAttribute("1")]
public CultureInfo Culture { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    private static JsonSerializerSettings();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonSerializerSettings(JsonSerializerSettings original);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [Newtonsoft.Json.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    public PreserveReferencesHandling get_PreserveReferencesHandling();
    public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public MetadataPropertyHandling get_MetadataPropertyHandling();
    public void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public ConstructorHandling get_ConstructorHandling();
    public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public IEqualityComparer get_EqualityComparer();
    [CompilerGeneratedAttribute]
public void set_EqualityComparer(IEqualityComparer value);
    public IReferenceResolver get_ReferenceResolver();
    public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public Func`1<IReferenceResolver> get_ReferenceResolverProvider();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    public SerializationBinder get_Binder();
    public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public ISerializationBinder get_SerializationBinder();
    [CompilerGeneratedAttribute]
public void set_SerializationBinder(ISerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    public StreamingContext get_Context();
    public void set_Context(StreamingContext value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public string get_DateFormatString();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public CultureInfo get_Culture();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public void set_Culture(CultureInfo value);
    public bool get_CheckAdditionalContent();
    public void set_CheckAdditionalContent(bool value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonTextReader : JsonReader {
    private bool _safeAsync;
    private static char UnicodeReplacementChar;
    private static int MaximumJavascriptIntegerCharacterLength;
    private static int LargeBufferLength;
    private TextReader _reader;
    [Newtonsoft.Json.NullableAttribute("2")]
private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _stringBuffer;
    private StringReference _stringReference;
    [Newtonsoft.Json.NullableAttribute("2")]
private IArrayPool`1<char> _arrayPool;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNameTable <PropertyNameTable>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
public JsonNameTable PropertyNameTable { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public IArrayPool`1<char> ArrayPool { get; public set; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    internal Task`1<bool> DoReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsync>d__3")]
private Task`1<bool> DoReadAsync(Task`1<bool> task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParsePostValueAsync>d__4")]
private Task`1<bool> ParsePostValueAsync(bool ignoreComments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadFromFinishedAsync>d__5")]
private Task`1<bool> ReadFromFinishedAsync(CancellationToken cancellationToken);
    private Task`1<int> ReadDataAsync(bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadDataAsync>d__7")]
private Task`1<int> ReadDataAsync(bool append, int charsRequired, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseValueAsync>d__8")]
private Task`1<bool> ParseValueAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadStringIntoBufferAsync>d__9")]
private Task ReadStringIntoBufferAsync(char quote, CancellationToken cancellationToken);
    private Task ProcessCarriageReturnAsync(bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ProcessCarriageReturnAsync>d__11")]
private Task ProcessCarriageReturnAsync(Task`1<bool> task);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseUnicodeAsync>d__12")]
private Task`1<char> ParseUnicodeAsync(CancellationToken cancellationToken);
    private Task`1<bool> EnsureCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadCharsAsync>d__14")]
private Task`1<bool> ReadCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseObjectAsync>d__15")]
private Task`1<bool> ParseObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseCommentAsync>d__16")]
private Task ParseCommentAsync(bool setToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<EatWhitespaceAsync>d__17")]
private Task EatWhitespaceAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseStringAsync>d__18")]
private Task ParseStringAsync(char quote, ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchValueAsync>d__19")]
private Task`1<bool> MatchValueAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchValueWithTrailingSeparatorAsync>d__20")]
private Task`1<bool> MatchValueWithTrailingSeparatorAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<MatchAndSetAsync>d__21")]
private Task MatchAndSetAsync(string value, JsonToken newToken, object tokenValue, CancellationToken cancellationToken);
    private Task ParseTrueAsync(CancellationToken cancellationToken);
    private Task ParseFalseAsync(CancellationToken cancellationToken);
    private Task ParseNullAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseConstructorAsync>d__25")]
private Task ParseConstructorAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberNaNAsync>d__26")]
private Task`1<object> ParseNumberNaNAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberPositiveInfinityAsync>d__27")]
private Task`1<object> ParseNumberPositiveInfinityAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberNegativeInfinityAsync>d__28")]
private Task`1<object> ParseNumberNegativeInfinityAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseNumberAsync>d__29")]
private Task ParseNumberAsync(ReadType readType, CancellationToken cancellationToken);
    private Task ParseUndefinedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParsePropertyAsync>d__31")]
private Task`1<bool> ParsePropertyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNumberIntoBufferAsync>d__32")]
private Task ReadNumberIntoBufferAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ParseUnquotedPropertyAsync>d__33")]
private Task ParseUnquotedPropertyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNullCharAsync>d__34")]
private Task`1<bool> ReadNullCharAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<HandleNullAsync>d__35")]
private Task HandleNullAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadFinishedAsync>d__36")]
private Task ReadFinishedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadStringValueAsync>d__37")]
private Task`1<object> ReadStringValueAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadNumberValueAsync>d__38")]
private Task`1<object> ReadNumberValueAsync(ReadType readType, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<bool>> ReadAsBooleanAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsBooleanAsync>d__40")]
internal Task`1<Nullable`1<bool>> DoReadAsBooleanAsync(CancellationToken cancellationToken);
    public virtual Task`1<Byte[]> ReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsBytesAsync>d__42")]
internal Task`1<Byte[]> DoReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<ReadIntoWrappedTypeObjectAsync>d__43")]
private Task ReadIntoWrappedTypeObjectAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTime>> ReadAsDateTimeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDateTimeAsync>d__45")]
internal Task`1<Nullable`1<DateTime>> DoReadAsDateTimeAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDateTimeOffsetAsync>d__47")]
internal Task`1<Nullable`1<DateTimeOffset>> DoReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<decimal>> ReadAsDecimalAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDecimalAsync>d__49")]
internal Task`1<Nullable`1<decimal>> DoReadAsDecimalAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<double>> ReadAsDoubleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsDoubleAsync>d__51")]
internal Task`1<Nullable`1<double>> DoReadAsDoubleAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<int>> ReadAsInt32Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsInt32Async>d__53")]
internal Task`1<Nullable`1<int>> DoReadAsInt32Async(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextReader/<DoReadAsStringAsync>d__55")]
internal Task`1<string> DoReadAsStringAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNameTable get_PropertyNameTable();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PropertyNameTable(JsonNameTable value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public IArrayPool`1<char> get_ArrayPool();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void set_ArrayPool(IArrayPool`1<char> value);
    private void EnsureBufferNotEmpty();
    private void SetNewLine(bool hasNextChar);
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private void ParseReadString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private void PrepareBufferForReadData(bool append, int charsRequired);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual string ReadAsString();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private object ReadStringValue(ReadType readType);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private object FinishReadQuotedStringValue(ReadType readType);
    private JsonReaderException CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private object ReadNumberValue(ReadType readType);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private object FinishReadQuotedNumber(ReadType readType);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void FinishReadStringIntoBuffer(int charPos, int initialPosition, int lastWritePosition);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ConvertUnicode(bool enoughChars);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private bool ReadNumberCharIntoBuffer(char currentChar, int charPos);
    private void ClearRecentString();
    private bool ParsePostValue(bool ignoreComments);
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition);
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private void EatWhitespace();
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition);
    private JsonReaderException ThrowReaderError(string message, Exception ex);
    private static object BigIntegerParse(string number, CultureInfo culture);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValue(bool enoughChars, string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberNegativeInfinity(ReadType readType, bool matched);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType, bool matched);
    private object ParseNumberNaN(ReadType readType);
    private object ParseNumberNaN(ReadType readType, bool matched);
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonTextWriter : JsonWriter {
    private bool _safeAsync;
    private static int IndentCharBufferSize;
    private TextWriter _writer;
    [Newtonsoft.Json.NullableAttribute("2")]
private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;
    [Newtonsoft.Json.NullableAttribute("2")]
private Boolean[] _charEscapeFlags;
    [Newtonsoft.Json.NullableAttribute("2")]
private Char[] _writeBuffer;
    [Newtonsoft.Json.NullableAttribute("2")]
private IArrayPool`1<char> _arrayPool;
    [Newtonsoft.Json.NullableAttribute("2")]
private Char[] _indentChars;
    private Base64Encoder Base64Encoder { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public IArrayPool`1<char> ArrayPool { get; public set; }
    public int Indentation { get; public set; }
    public char QuoteChar { get; public set; }
    public char IndentChar { get; public set; }
    public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    internal Task DoFlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken);
    internal Task DoWriteValueDelimiterAsync(CancellationToken cancellationToken);
    protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    internal Task DoWriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoCloseAsync>d__8")]
internal Task DoCloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<CloseBufferAndWriterAsync>d__9")]
private Task CloseBufferAndWriterAsync();
    public virtual Task WriteEndAsync(CancellationToken cancellationToken);
    protected virtual Task WriteIndentAsync(CancellationToken cancellationToken);
    internal Task DoWriteIndentAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteIndentAsync>d__13")]
private Task WriteIndentAsync(int currentIndentCount, int newLineLen, CancellationToken cancellationToken);
    private Task WriteValueInternalAsync(JsonToken token, string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueInternalAsync>d__15")]
private Task WriteValueInternalAsync(Task task, string value, CancellationToken cancellationToken);
    protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken);
    internal Task DoWriteIndentSpaceAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawAsync(string json, CancellationToken cancellationToken);
    internal Task DoWriteRawAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteNullAsync(CancellationToken cancellationToken);
    internal Task DoWriteNullAsync(CancellationToken cancellationToken);
    private Task WriteDigitsAsync(ulong uvalue, bool negative, CancellationToken cancellationToken);
    private Task WriteIntegerValueAsync(ulong uvalue, bool negative, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteIntegerValueAsync>d__24")]
private Task WriteIntegerValueAsync(Task task, ulong uvalue, bool negative, CancellationToken cancellationToken);
    internal Task WriteIntegerValueAsync(long value, CancellationToken cancellationToken);
    internal Task WriteIntegerValueAsync(ulong uvalue, CancellationToken cancellationToken);
    private Task WriteEscapedStringAsync(string value, bool quote, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken);
    internal Task DoWritePropertyNameAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWritePropertyNameAsync>d__30")]
private Task DoWritePropertyNameAsync(Task task, string name, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWritePropertyNameAsync>d__32")]
internal Task DoWritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken);
    internal Task DoWriteStartArrayAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartArrayAsync>d__35")]
internal Task DoWriteStartArrayAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken);
    internal Task DoWriteStartObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartObjectAsync>d__38")]
internal Task DoWriteStartObjectAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteStartConstructorAsync>d__40")]
internal Task DoWriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken);
    internal Task DoWriteUndefinedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteUndefinedAsync>d__43")]
private Task DoWriteUndefinedAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    internal Task DoWriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(bool value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueNonNullAsync>d__54")]
internal Task WriteValueNonNullAsync(Byte[] value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(char value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__60")]
internal Task DoWriteValueAsync(DateTime value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__64")]
internal Task DoWriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(decimal value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(double value, bool nullable, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(float value, bool nullable, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__78")]
internal Task DoWriteValueAsync(Guid value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(BigInteger value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(object value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(string value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__97")]
private Task DoWriteValueAsync(Task task, string value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteValueAsync>d__99")]
internal Task DoWriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Uri value, CancellationToken cancellationToken);
    internal Task WriteValueNotNullAsync(Uri value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<WriteValueNotNullAsync>d__110")]
internal Task WriteValueNotNullAsync(Task task, Uri value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public virtual Task WriteCommentAsync(string text, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteCommentAsync>d__115")]
internal Task DoWriteCommentAsync(string text, CancellationToken cancellationToken);
    public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawValueAsync(string json, CancellationToken cancellationToken);
    internal Task DoWriteRawValueAsync(string json, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonTextWriter/<DoWriteRawValueAsync>d__121")]
private Task DoWriteRawValueAsync(Task task, string json, CancellationToken cancellationToken);
    internal Char[] EnsureWriteBuffer(int length, int copyTo);
    private Base64Encoder get_Base64Encoder();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public IArrayPool`1<char> get_ArrayPool();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void set_ArrayPool(IArrayPool`1<char> value);
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    private void CloseBufferAndWriter();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    internal virtual void OnStringEscapeHandlingChanged();
    private void UpdateCharEscapeFlags();
    protected virtual void WriteIndent();
    private int SetIndentChars();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    private void WriteEscapedString(string value, bool quote);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    private int WriteValueToBuffer(DateTime value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    private int WriteValueToBuffer(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void EnsureWriteBuffer();
    private void WriteIntegerValue(long value);
    private void WriteIntegerValue(ulong value, bool negative);
    private int WriteNumberToBuffer(ulong value, bool negative);
    private void WriteIntegerValue(int value);
    private void WriteIntegerValue(UInt32 value, bool negative);
    private int WriteNumberToBuffer(UInt32 value, bool negative);
}
internal enum Newtonsoft.Json.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.JsonValidatingReader : JsonReader {
    private JsonReader _reader;
    private Stack`1<SchemaScope> _stack;
    private JsonSchema _schema;
    private JsonSchemaModel _model;
    private SchemaScope _currentScope;
    [CompilerGeneratedAttribute]
private ValidationEventHandler ValidationEventHandler;
    private static IList`1<JsonSchemaModel> EmptySchemaList;
    public object Value { get; }
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public Type ValueType { get; }
    private IList`1<JsonSchemaModel> CurrentSchemas { get; }
    private IList`1<JsonSchemaModel> CurrentMemberSchemas { get; }
    public JsonSchema Schema { get; public set; }
    public JsonReader Reader { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public JsonValidatingReader(JsonReader reader);
    private static JsonValidatingReader();
    [CompilerGeneratedAttribute]
public void add_ValidationEventHandler(ValidationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ValidationEventHandler(ValidationEventHandler value);
    public virtual object get_Value();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual Type get_ValueType();
    private void Push(SchemaScope scope);
    private SchemaScope Pop();
    private IList`1<JsonSchemaModel> get_CurrentSchemas();
    private IList`1<JsonSchemaModel> get_CurrentMemberSchemas();
    private void RaiseError(string message, JsonSchemaModel schema);
    private void OnValidationEvent(JsonSchemaException exception);
    public JsonSchema get_Schema();
    public void set_Schema(JsonSchema value);
    public JsonReader get_Reader();
    public virtual void Close();
    private void ValidateNotDisallowed(JsonSchemaModel schema);
    private Nullable`1<JsonSchemaType> GetCurrentNodeSchemaType();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    private void ValidateCurrentToken();
    private void WriteToken(IList`1<JsonSchemaModel> schemas);
    private void ValidateEndObject(JsonSchemaModel schema);
    private void ValidateEndArray(JsonSchemaModel schema);
    private void ValidateNull(JsonSchemaModel schema);
    private void ValidateBoolean(JsonSchemaModel schema);
    private void ValidateString(JsonSchemaModel schema);
    private void ValidateInteger(JsonSchemaModel schema);
    private void ProcessValue();
    private void ValidateFloat(JsonSchemaModel schema);
    private static double FloatingPointRemainder(double dividend, double divisor);
    private static bool IsZero(double value);
    private void ValidatePropertyName(JsonSchemaModel schema);
    private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName);
    private bool ValidateArray(JsonSchemaModel schema);
    private bool ValidateObject(JsonSchemaModel schema);
    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.JsonWriter : object {
    private static State[][] StateArray;
    internal static State[][] StateArrayTemplate;
    [Newtonsoft.Json.NullableAttribute("2")]
private List`1<JsonPosition> _stack;
    private JsonPosition _currentPosition;
    private State _currentState;
    private Formatting _formatting;
    [CompilerGeneratedAttribute]
private bool <CloseOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoCompleteOnClose>k__BackingField;
    private DateFormatHandling _dateFormatHandling;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private StringEscapeHandling _stringEscapeHandling;
    private FloatFormatHandling _floatFormatHandling;
    [Newtonsoft.Json.NullableAttribute("2")]
private string _dateFormatString;
    [Newtonsoft.Json.NullableAttribute("2")]
private CultureInfo _culture;
    public bool CloseOutput { get; public set; }
    public bool AutoCompleteOnClose { get; public set; }
    protected internal int Top { get; }
    public WriteState WriteState { get; }
    internal string ContainerPath { get; }
    public string Path { get; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static JsonWriter();
    internal Task AutoCompleteAsync(JsonToken tokenBeingWritten, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<AutoCompleteAsync>d__1")]
private Task AutoCompleteAsync(CancellationToken cancellationToken);
    public virtual Task CloseAsync(CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    protected virtual Task WriteIndentAsync(CancellationToken cancellationToken);
    protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken);
    protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteEndAsync(CancellationToken cancellationToken);
    internal Task WriteEndInternalAsync(CancellationToken cancellationToken);
    internal Task InternalWriteEndAsync(JsonContainerType type, CancellationToken cancellationToken);
    public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken);
    public virtual Task WriteNullAsync(CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    internal Task InternalWritePropertyNameAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<InternalWriteStartAsync>d__20")]
internal Task InternalWriteStartAsync(JsonToken token, JsonContainerType container, CancellationToken cancellationToken);
    public virtual Task WriteCommentAsync(string text, CancellationToken cancellationToken);
    internal Task InternalWriteCommentAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawValueAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonReader reader, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonReader reader, bool writeChildren, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonToken token, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonToken token, object value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteTokenAsync>d__30")]
internal virtual Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteTokenSyncReadingAsync>d__31")]
internal Task WriteTokenSyncReadingAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<WriteConstructorDateAsync>d__32")]
private Task WriteConstructorDateAsync(JsonReader reader, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Byte[] value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(object value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(string value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Uri value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken);
    public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    internal Task InternalWriteValueAsync(JsonToken token, CancellationToken cancellationToken);
    protected Task SetWriteStateAsync(JsonToken token, object value, CancellationToken cancellationToken);
    internal static Task WriteValueAsync(JsonWriter writer, PrimitiveTypeCode typeCode, object value, CancellationToken cancellationToken);
    internal static State[][] BuildStateArray();
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoCompleteOnClose();
    [CompilerGeneratedAttribute]
public void set_AutoCompleteOnClose(bool value);
    protected internal int get_Top();
    public WriteState get_WriteState();
    internal string get_ContainerPath();
    public string get_Path();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    internal virtual void OnStringEscapeHandlingChanged();
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public string get_DateFormatString();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void set_DateFormatString(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal void UpdateScopeWithFinishedValue();
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteEnd();
    public void WriteToken(JsonReader reader);
    public void WriteToken(JsonReader reader, bool writeChildren);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void WriteToken(JsonToken token, object value);
    public void WriteToken(JsonToken token);
    internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
    private bool IsWriteTokenIncomplete(JsonReader reader, bool writeChildren, int initialDepth);
    private int CalculateWriteTokenInitialDepth(JsonReader reader);
    private int CalculateWriteTokenFinalDepth(JsonReader reader);
    private void WriteConstructorDate(JsonReader reader);
    private void WriteEnd(JsonContainerType type);
    private void AutoCompleteAll();
    private JsonToken GetCloseTokenForType(JsonContainerType type);
    private void AutoCompleteClose(JsonContainerType type);
    private int CalculateLevelsToComplete(JsonContainerType type);
    private void UpdateCurrentState();
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteRawValue(string json);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value);
    private static void ResolveConvertibleValue(IConvertible convertible, PrimitiveTypeCode& typeCode, Object& value);
    private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value);
    protected void SetWriteState(JsonToken token, object value);
    internal void InternalWriteEnd(JsonContainerType container);
    internal void InternalWritePropertyName(string name);
    internal void InternalWriteRaw();
    internal void InternalWriteStart(JsonToken token, JsonContainerType container);
    internal void InternalWriteValue(JsonToken token);
    internal void InternalWriteWhitespace(string ws);
    internal void InternalWriteComment();
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitProperty|11_0>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitProperty|11_0(Task task, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitIndent|11_1>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitIndent|11_1(Task task, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitEnd|11_2>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitEnd|11_2(Task task, int LevelsToComplete, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitRemaining|11_3>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitRemaining|11_3(int LevelsToComplete, CancellationToken CancellationToken);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.JsonWriterException : JsonException {
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
public string Path { get; }
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
    public JsonWriterException(SerializationInfo info, StreamingContext context);
    public JsonWriterException(string message, string path, Exception innerException);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex);
    internal static JsonWriterException Create(string path, string message, Exception ex);
}
internal enum Newtonsoft.Json.Linq.CommentHandling : Enum {
    public int value__;
    public static CommentHandling Ignore;
    public static CommentHandling Load;
}
internal enum Newtonsoft.Json.Linq.DuplicatePropertyNameHandling : Enum {
    public int value__;
    public static DuplicatePropertyNameHandling Replace;
    public static DuplicatePropertyNameHandling Ignore;
    public static DuplicatePropertyNameHandling Error;
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Linq.Extensions : object {
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.Extensions/<Values>d__11`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.Extensions/<Convert>d__14`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
internal interface Newtonsoft.Json.Linq.IJEnumerable`1 {
    public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(JArray other);
    internal JArray(JArray other, JsonCloneSettings settings);
    public JArray(Object[] content);
    public JArray(object content);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JArray/<WriteToAsync>d__0")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JArray> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JArray/<LoadAsync>d__2")]
public static Task`1<JArray> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public static JArray Load(JsonReader reader);
    public static JArray Load(JsonReader reader, JsonLoadSettings settings);
    public static JArray Parse(string json);
    public static JArray Parse(string json, JsonLoadSettings settings);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JConstructor : JContainer {
    [Newtonsoft.Json.NullableAttribute("2")]
private string _name;
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public string Name { get; public set; }
    public JTokenType Type { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    internal JConstructor(JConstructor other, JsonCloneSettings settings);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JConstructor/<WriteToAsync>d__0")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JConstructor> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JConstructor/<LoadAsync>d__2")]
public static Task`1<JConstructor> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public string get_Name();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
    public static JConstructor Load(JsonReader reader, JsonLoadSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Linq.JContainer : JToken {
    [Newtonsoft.Json.NullableAttribute("2")]
internal ListChangedEventHandler _listChanged;
    [Newtonsoft.Json.NullableAttribute("2")]
internal AddingNewEventHandler _addingNew;
    [Newtonsoft.Json.NullableAttribute("2")]
internal NotifyCollectionChangedEventHandler _collectionChanged;
    [Newtonsoft.Json.NullableAttribute("2")]
private object _syncRoot;
    private bool _busy;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken First { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Last { get; }
    private JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.ComponentModel.IBindingList.AllowEdit { get; }
    private bool System.ComponentModel.IBindingList.AllowNew { get; }
    private bool System.ComponentModel.IBindingList.AllowRemove { get; }
    private bool System.ComponentModel.IBindingList.IsSorted { get; }
    private ListSortDirection System.ComponentModel.IBindingList.SortDirection { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
private PropertyDescriptor System.ComponentModel.IBindingList.SortProperty { get; }
    private bool System.ComponentModel.IBindingList.SupportsChangeNotification { get; }
    private bool System.ComponentModel.IBindingList.SupportsSearching { get; }
    private bool System.ComponentModel.IBindingList.SupportsSorting { get; }
    internal JContainer(JContainer other, JsonCloneSettings settings);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<ReadTokenFromAsync>d__0")]
internal Task ReadTokenFromAsync(JsonReader reader, JsonLoadSettings options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<ReadContentFromAsync>d__1")]
private Task ReadContentFromAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public sealed virtual void add_ListChanged(ListChangedEventHandler value);
    public sealed virtual void remove_ListChanged(ListChangedEventHandler value);
    public void add_AddingNew(AddingNewEventHandler value);
    public void remove_AddingNew(AddingNewEventHandler value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    internal void CheckReentrancy();
    internal virtual IList`1<JToken> CreateChildrenCollection();
    protected virtual void OnAddingNew(AddingNewEventArgs e);
    protected virtual void OnListChanged(ListChangedEventArgs e);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual JToken get_First();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    public IEnumerable`1<JToken> DescendantsAndSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JContainer/<GetDescendants>d__36")]
internal IEnumerable`1<JToken> GetDescendants(bool self);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck, bool copyAnnotations);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal abstract virtual int IndexOfItem(JToken item);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    internal virtual void RemoveItemAt(int index);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void Add(object content);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal bool TryAdd(object content);
    internal void AddAndSkipParentCheck(JToken token);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void AddFirst(object content);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal bool TryAddInternal(int index, object content, bool skipParentCheck, bool copyAnnotations);
    internal static JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal abstract virtual void MergeItem(object content, JsonMergeSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void Merge(object content);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void Merge(object content, JsonMergeSettings settings);
    private void ValidateContent(object content);
    internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options);
    internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private static JProperty ReadProperty(JsonReader r, JsonLoadSettings settings, IJsonLineInfo lineInfo, JContainer parent);
    internal int ContentsHashCode();
    private sealed virtual override string System.ComponentModel.ITypedList.GetListName(PropertyDescriptor[] listAccessors);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors);
    private sealed virtual override int System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Newtonsoft.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Newtonsoft.Json.Linq.JToken>.Remove(JToken item);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private JToken EnsureValue(object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.ComponentModel.IBindingList.AddIndex(PropertyDescriptor property);
    private sealed virtual override object System.ComponentModel.IBindingList.AddNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowEdit();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowNew();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_AllowRemove();
    private sealed virtual override void System.ComponentModel.IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction);
    private sealed virtual override int System.ComponentModel.IBindingList.Find(PropertyDescriptor property, object key);
    private sealed virtual override bool System.ComponentModel.IBindingList.get_IsSorted();
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveIndex(PropertyDescriptor property);
    private sealed virtual override void System.ComponentModel.IBindingList.RemoveSort();
    private sealed virtual override ListSortDirection System.ComponentModel.IBindingList.get_SortDirection();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override PropertyDescriptor System.ComponentModel.IBindingList.get_SortProperty();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsChangeNotification();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSearching();
    private sealed virtual override bool System.ComponentModel.IBindingList.get_SupportsSorting();
    internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[Newtonsoft.Json.IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JEnumerable`1 : ValueType {
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JEnumerable`1<T> Empty;
    private IEnumerable`1<T> _enumerable;
    public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public sealed virtual bool Equals(JEnumerable`1<T> other);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JObject : JContainer {
    private JPropertyKeyedCollection _properties;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Item { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Keys { get; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    internal JObject(JObject other, JsonCloneSettings settings);
    public JObject(Object[] content);
    public JObject(object content);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JObject> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<LoadAsync>d__2")]
public static Task`1<JObject> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    private static bool IsNull(JToken token);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JProperty Property(string name, StringComparison comparison);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Load(JsonReader reader, JsonLoadSettings settings);
    public static JObject Parse(string json);
    public static JObject Parse(string json, JsonLoadSettings settings);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public JToken GetValue(string propertyName);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public JToken GetValue(string propertyName, StringComparison comparison);
    public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value);
    public sealed virtual void Add(string propertyName, JToken value);
    public sealed virtual bool ContainsKey(string propertyName);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Newtonsoft.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Newtonsoft.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<GetEnumerator>d__64")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanging(string propertyName);
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties();
    private sealed virtual override PropertyDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetProperties(Attribute[] attributes);
    private sealed virtual override AttributeCollection System.ComponentModel.ICustomTypeDescriptor.GetAttributes();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetClassName();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override string System.ComponentModel.ICustomTypeDescriptor.GetComponentName();
    private sealed virtual override TypeConverter System.ComponentModel.ICustomTypeDescriptor.GetConverter();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override EventDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultEvent();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override PropertyDescriptor System.ComponentModel.ICustomTypeDescriptor.GetDefaultProperty();
    private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetEditor(Type editorBaseType);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents(Attribute[] attributes);
    private sealed virtual override EventDescriptorCollection System.ComponentModel.ICustomTypeDescriptor.GetEvents();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override object System.ComponentModel.ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JObject/<<WriteToAsync>g__AwaitProperties|0_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteToAsync>g__AwaitProperties|0_0(Task task, int i, JsonWriter Writer, CancellationToken CancellationToken, JsonConverter[] Converters);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JProperty : JContainer {
    private JPropertyList _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(JProperty other, JsonCloneSettings settings);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JProperty/<WriteToAsync>d__1")]
private Task WriteToAsync(Task task, JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    private Task WriteValueAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JProperty> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JProperty/<LoadAsync>d__4")]
public static Task`1<JProperty> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual void SetItem(int index, JToken item);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck, bool copyAnnotations);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual bool ContainsItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal virtual void ClearItems();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
    public static JProperty Load(JsonReader reader, JsonLoadSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JPropertyDescriptor : PropertyDescriptor {
    public Type ComponentType { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected int NameHashCode { get; }
    public JPropertyDescriptor(string name);
    private static JObject CastInstance(object instance);
    public virtual bool CanResetValue(object component);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual object GetValue(object component);
    public virtual void ResetValue(object component);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void SetValue(object component, object value);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    public virtual bool get_IsReadOnly();
    public virtual Type get_PropertyType();
    protected virtual int get_NameHashCode();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
    private static IEqualityComparer`1<string> Comparer;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, JToken> _dictionary;
    public JToken Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<JToken> Values { get; }
    private static JPropertyKeyedCollection();
    private void AddKey(string key, JToken item);
    protected void ChangeItemKey(JToken item, string newKey);
    protected virtual void ClearItems();
    public bool Contains(string key);
    private bool ContainsItem(JToken item);
    private void EnsureDictionary();
    private string GetKeyForItem(JToken item);
    protected virtual void InsertItem(int index, JToken item);
    public bool Remove(string key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(string key);
    protected virtual void SetItem(int index, JToken item);
    public JToken get_Item(string key);
    public bool TryGetValue(string key, JToken& value);
    public ICollection`1<string> get_Keys();
    public ICollection`1<JToken> get_Values();
    public int IndexOfReference(JToken t);
    public bool Compare(JPropertyKeyedCollection other);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    internal JRaw(JRaw other, JsonCloneSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public JRaw(object rawJson);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JRaw/<CreateAsync>d__0")]
public static Task`1<JRaw> CreateAsync(JsonReader reader, CancellationToken cancellationToken);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken(JsonCloneSettings settings);
}
internal class Newtonsoft.Json.Linq.JsonCloneSettings : object {
    [Newtonsoft.Json.NullableAttribute("1")]
internal static JsonCloneSettings SkipCopyAnnotations;
    [CompilerGeneratedAttribute]
private bool <CopyAnnotations>k__BackingField;
    public bool CopyAnnotations { get; public set; }
    private static JsonCloneSettings();
    [CompilerGeneratedAttribute]
public bool get_CopyAnnotations();
    [CompilerGeneratedAttribute]
public void set_CopyAnnotations(bool value);
}
internal class Newtonsoft.Json.Linq.JsonLoadSettings : object {
    private CommentHandling _commentHandling;
    private LineInfoHandling _lineInfoHandling;
    private DuplicatePropertyNameHandling _duplicatePropertyNameHandling;
    public CommentHandling CommentHandling { get; public set; }
    public LineInfoHandling LineInfoHandling { get; public set; }
    public DuplicatePropertyNameHandling DuplicatePropertyNameHandling { get; public set; }
    public CommentHandling get_CommentHandling();
    public void set_CommentHandling(CommentHandling value);
    public LineInfoHandling get_LineInfoHandling();
    public void set_LineInfoHandling(LineInfoHandling value);
    public DuplicatePropertyNameHandling get_DuplicatePropertyNameHandling();
    public void set_DuplicatePropertyNameHandling(DuplicatePropertyNameHandling value);
}
internal class Newtonsoft.Json.Linq.JsonMergeSettings : object {
    private MergeArrayHandling _mergeArrayHandling;
    private MergeNullValueHandling _mergeNullValueHandling;
    private StringComparison _propertyNameComparison;
    public MergeArrayHandling MergeArrayHandling { get; public set; }
    public MergeNullValueHandling MergeNullValueHandling { get; public set; }
    public StringComparison PropertyNameComparison { get; public set; }
    public MergeArrayHandling get_MergeArrayHandling();
    public void set_MergeArrayHandling(MergeArrayHandling value);
    public MergeNullValueHandling get_MergeNullValueHandling();
    public void set_MergeNullValueHandling(MergeNullValueHandling value);
    public StringComparison get_PropertyNameComparison();
    public void set_PropertyNameComparison(StringComparison value);
}
internal class Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    public Nullable`1<int> Index { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArrayIndexFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
    internal List`1<int> Indexes;
    public ArrayMultipleIndexFilter(List`1<int> indexes);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArrayMultipleIndexFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <End>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Step>k__BackingField;
    public Nullable`1<int> Start { get; public set; }
    public Nullable`1<int> End { get; public set; }
    public Nullable`1<int> Step { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(Nullable`1<int> value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ArraySliceFilter/<ExecuteFilter>d__12")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
    private bool IsValid(int index, int stopIndex, bool positiveStep);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
    public object Left;
    [Newtonsoft.Json.NullableAttribute("2")]
public object Right;
    public BooleanQueryExpression(QueryOperator operator, object left, object right);
    private IEnumerable`1<JToken> GetResult(JToken root, JToken t, object o);
    public virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
    private bool MatchTokens(JToken leftResult, JToken rightResult, JsonSelectSettings settings);
    private static bool RegexEquals(JValue input, JValue pattern, JsonSelectSettings settings);
    internal static bool EqualsWithStringCoercion(JValue value, JValue queryValue);
    internal static bool EqualsWithStrictMatch(JValue value, JValue queryValue);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
    [CompilerGeneratedAttribute]
private List`1<QueryExpression> <Expressions>k__BackingField;
    public List`1<QueryExpression> Expressions { get; public set; }
    public CompositeExpression(QueryOperator operator);
    [CompilerGeneratedAttribute]
public List`1<QueryExpression> get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(List`1<QueryExpression> value);
    public virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.FieldFilter : PathFilter {
    internal string Name;
    public FieldFilter(string name);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.FieldFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
    internal List`1<string> Names;
    public FieldMultipleFilter(List`1<string> names);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.FieldMultipleFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.JPath : object {
    private static Char[] FloatCharacters;
    private string _expression;
    [CompilerGeneratedAttribute]
private List`1<PathFilter> <Filters>k__BackingField;
    private int _currentIndex;
    public List`1<PathFilter> Filters { get; }
    public JPath(string expression);
    private static JPath();
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Filters();
    private void ParseMain();
    private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query);
    private static PathFilter CreatePathFilter(string member, bool scan);
    private PathFilter ParseIndexer(char indexerOpenChar, bool scan);
    private PathFilter ParseArrayIndexer(char indexerCloseChar);
    private void EatWhitespace();
    private PathFilter ParseQuery(char indexerCloseChar, bool scan);
    private bool TryParseExpression(List`1& expressionPath);
    private JsonException CreateUnexpectedCharacterException();
    private object ParseSide();
    private QueryExpression ParseExpression();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool TryParseValue(Object& value);
    private string ReadQuotedString();
    private string ReadRegexString();
    private bool Match(string s);
    private QueryOperator ParseOperator();
    private PathFilter ParseQuotedField(char indexerCloseChar, bool scan);
    private void EnsureLength(string message);
    internal IEnumerable`1<JToken> Evaluate(JToken root, JToken t, JsonSelectSettings settings);
    internal static IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken root, JToken t, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Linq.JsonPath.PathFilter : object {
    [Newtonsoft.Json.NullableContextAttribute("1")]
public abstract virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
    protected static JToken GetTokenIndex(JToken t, JsonSelectSettings settings, int index);
    protected static JToken GetNextScanValue(JToken originalParent, JToken container, JToken value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Linq.JsonPath.QueryExpression : object {
    internal QueryOperator Operator;
    public QueryExpression(QueryOperator operator);
    public bool IsMatch(JToken root, JToken t);
    public abstract virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.QueryFilter : PathFilter {
    internal QueryExpression Expression;
    public QueryFilter(QueryExpression expression);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.QueryFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal enum Newtonsoft.Json.Linq.JsonPath.QueryOperator : Enum {
    public int value__;
    public static QueryOperator None;
    public static QueryOperator Equals;
    public static QueryOperator NotEquals;
    public static QueryOperator Exists;
    public static QueryOperator LessThan;
    public static QueryOperator LessThanOrEquals;
    public static QueryOperator GreaterThan;
    public static QueryOperator GreaterThanOrEquals;
    public static QueryOperator And;
    public static QueryOperator Or;
    public static QueryOperator RegexEquals;
    public static QueryOperator StrictEquals;
    public static QueryOperator StrictNotEquals;
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.QueryScanFilter : PathFilter {
    internal QueryExpression Expression;
    public QueryScanFilter(QueryExpression expression);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.QueryScanFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.RootFilter : PathFilter {
    public static RootFilter Instance;
    private static RootFilter();
    public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ScanFilter : PathFilter {
    internal string Name;
    public ScanFilter(string name);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ScanFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JsonPath.ScanMultipleFilter : PathFilter {
    private List`1<string> _names;
    public ScanMultipleFilter(List`1<string> names);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JsonPath.ScanMultipleFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Newtonsoft.Json.Linq.JsonSelectSettings : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <RegexMatchTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ErrorWhenNoMatch>k__BackingField;
    public Nullable`1<TimeSpan> RegexMatchTimeout { get; public set; }
    public bool ErrorWhenNoMatch { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_RegexMatchTimeout();
    [CompilerGeneratedAttribute]
public void set_RegexMatchTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public bool get_ErrorWhenNoMatch();
    [CompilerGeneratedAttribute]
public void set_ErrorWhenNoMatch(bool value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal abstract class Newtonsoft.Json.Linq.JToken : object {
    [Newtonsoft.Json.NullableAttribute("2")]
private static JTokenEqualityComparer _equalityComparer;
    [Newtonsoft.Json.NullableAttribute("2")]
private JContainer _parent;
    [Newtonsoft.Json.NullableAttribute("2")]
private JToken _previous;
    [Newtonsoft.Json.NullableAttribute("2")]
private JToken _next;
    [Newtonsoft.Json.NullableAttribute("2")]
private object _annotations;
    private static JTokenType[] BooleanTypes;
    private static JTokenType[] NumberTypes;
    private static JTokenType[] BigIntegerTypes;
    private static JTokenType[] StringTypes;
    private static JTokenType[] GuidTypes;
    private static JTokenType[] TimeSpanTypes;
    private static JTokenType[] UriTypes;
    private static JTokenType[] CharTypes;
    private static JTokenType[] DateTimeTypes;
    private static JTokenType[] BytesTypes;
    public static JTokenEqualityComparer EqualityComparer { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JContainer Parent { get; internal set; }
    public JToken Root { get; }
    public JTokenType Type { get; }
    public bool HasValues { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Next { get; internal set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Previous { get; internal set; }
    public string Path { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Item { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken First { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken Last { get; }
    private IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.Item { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    private static JToken();
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public Task WriteToAsync(JsonWriter writer, JsonConverter[] converters);
    public static Task`1<JToken> ReadFromAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<ReadFromAsync>d__3")]
public static Task`1<JToken> ReadFromAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public static Task`1<JToken> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    public static Task`1<JToken> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public static JTokenEqualityComparer get_EqualityComparer();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public JContainer get_Parent();
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken(JsonCloneSettings settings);
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static bool DeepEquals(JToken t1, JToken t2);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public JToken get_Next();
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal void set_Next(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public JToken get_Previous();
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal void set_Previous(JToken value);
    public string get_Path();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void AddAfterSelf(object content);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AncestorsAndSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<GetAncestors>d__48")]
internal IEnumerable`1<JToken> GetAncestors(bool self);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<AfterSelf>d__49")]
public IEnumerable`1<JToken> AfterSelf();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<BeforeSelf>d__50")]
public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual T Value(object key);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual JToken get_First();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    [Newtonsoft.Json.NullableContextAttribute("0")]
public JEnumerable`1<T> Children();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable);
    public static bool op_Explicit(JToken value);
    public static DateTimeOffset op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<DateTime> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<DateTimeOffset> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<decimal> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<double> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<char> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static short op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static char op_Explicit(JToken value);
    public static byte op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<int> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<short> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<byte> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<long> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Byte[] op_Explicit(JToken value);
    public static Guid op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<Guid> op_Explicit(JToken value);
    public static TimeSpan op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Nullable`1<TimeSpan> op_Explicit(JToken value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Uri op_Explicit(JToken value);
    private static BigInteger ToBigInteger(JToken value);
    private static Nullable`1<BigInteger> ToBigIntegerNullable(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(DateTimeOffset value);
    public static JToken op_Implicit(byte value);
    public static JToken op_Implicit(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<sbyte> value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    public static JToken op_Implicit(Uri value);
    public static JToken op_Implicit(TimeSpan value);
    public static JToken op_Implicit(Nullable`1<TimeSpan> value);
    public static JToken op_Implicit(Guid value);
    public static JToken op_Implicit(Nullable`1<Guid> value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Newtonsoft.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Newtonsoft.Json.Linq.IJEnumerable<Newtonsoft.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public T ToObject();
    public object ToObject(Type objectType);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public T ToObject(JsonSerializer jsonSerializer);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public object ToObject(Type objectType, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings);
    public static JToken Parse(string json);
    public static JToken Parse(string json, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public JToken SelectToken(string path, JsonSelectSettings settings);
    public IEnumerable`1<JToken> SelectTokens(string path);
    public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch);
    public IEnumerable`1<JToken> SelectTokens(string path, JsonSelectSettings settings);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private sealed virtual override object System.ICloneable.Clone();
    public JToken DeepClone();
    public JToken DeepClone(JsonCloneSettings settings);
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<Annotations>d__185`1")]
public IEnumerable`1<T> Annotations();
    [IteratorStateMachineAttribute("Newtonsoft.Json.Linq.JToken/<Annotations>d__186")]
public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
    internal void CopyAnnotations(JToken target, JToken source);
}
internal class Newtonsoft.Json.Linq.JTokenEqualityComparer : object {
    [Newtonsoft.Json.NullableContextAttribute("2")]
public sealed virtual bool Equals(JToken x, JToken y);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public sealed virtual int GetHashCode(JToken obj);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JTokenReader : JsonReader {
    private JToken _root;
    [Newtonsoft.Json.NullableAttribute("2")]
private string _initialPath;
    [Newtonsoft.Json.NullableAttribute("2")]
private JToken _parent;
    [Newtonsoft.Json.NullableAttribute("2")]
private JToken _current;
    [Newtonsoft.Json.NullableAttribute("2")]
public JToken CurrentToken { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public string Path { get; }
    public JTokenReader(JToken token);
    public JTokenReader(JToken token, string initialPath);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public JToken get_CurrentToken();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private string SafeToString(object value);
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
    public virtual string get_Path();
}
internal enum Newtonsoft.Json.Linq.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JTokenWriter : JsonWriter {
    private JContainer _token;
    private JContainer _parent;
    private JValue _value;
    private JToken _current;
    public JToken CurrentToken { get; }
    public JToken Token { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JTokenWriter(JContainer container);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal virtual Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken);
    public JToken get_CurrentToken();
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    [Newtonsoft.Json.NullableContextAttribute("1")]
private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual void WritePropertyName(string name);
    private void AddRawValue(object value, JTokenType type, JsonToken token);
    internal void AddJValue(JValue value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Uri value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Linq.JValue : JToken {
    private JTokenType _valueType;
    private object _value;
    public bool HasValues { get; }
    public JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal JValue(JValue other, JsonCloneSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JValue(JValue other);
    public JValue(long value);
    public JValue(decimal value);
    public JValue(char value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(float value);
    public JValue(DateTime value);
    public JValue(DateTimeOffset value);
    public JValue(bool value);
    public JValue(string value);
    public JValue(Guid value);
    public JValue(Uri value);
    public JValue(TimeSpan value);
    public JValue(object value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    [Newtonsoft.Json.NullableContextAttribute("1")]
private static int CompareBigInteger(BigInteger i1, object i2);
    internal static int Compare(JTokenType valueType, object objA, object objB);
    [Newtonsoft.Json.NullableContextAttribute("1")]
private static int CompareFloat(object objA, object objB);
    private static bool Operation(ExpressionType operation, object objA, object objB, Object& result);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal virtual JToken CloneToken(JsonCloneSettings settings);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public static JValue CreateComment(string value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public static JValue CreateString(string value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public static JValue CreateNull();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public static JValue CreateUndefined();
    private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    [Newtonsoft.Json.NullableContextAttribute("1")]
private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual string ToString();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public string ToString(string format);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [Newtonsoft.Json.NullableContextAttribute("1")]
protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [Newtonsoft.Json.NullableContextAttribute("1")]
private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
}
internal enum Newtonsoft.Json.Linq.LineInfoHandling : Enum {
    public int value__;
    public static LineInfoHandling Ignore;
    public static LineInfoHandling Load;
}
internal enum Newtonsoft.Json.Linq.MergeArrayHandling : Enum {
    public int value__;
    public static MergeArrayHandling Concat;
    public static MergeArrayHandling Union;
    public static MergeArrayHandling Replace;
    public static MergeArrayHandling Merge;
}
[FlagsAttribute]
internal enum Newtonsoft.Json.Linq.MergeNullValueHandling : Enum {
    public int value__;
    public static MergeNullValueHandling Ignore;
    public static MergeNullValueHandling Merge;
}
internal enum Newtonsoft.Json.MemberSerialization : Enum {
    public int value__;
    public static MemberSerialization OptOut;
    public static MemberSerialization OptIn;
    public static MemberSerialization Fields;
}
internal enum Newtonsoft.Json.MetadataPropertyHandling : Enum {
    public int value__;
    public static MetadataPropertyHandling Default;
    public static MetadataPropertyHandling ReadAhead;
    public static MetadataPropertyHandling Ignore;
}
internal enum Newtonsoft.Json.MissingMemberHandling : Enum {
    public int value__;
    public static MissingMemberHandling Ignore;
    public static MissingMemberHandling Error;
}
internal enum Newtonsoft.Json.NullValueHandling : Enum {
    public int value__;
    public static NullValueHandling Include;
    public static NullValueHandling Ignore;
}
internal enum Newtonsoft.Json.ObjectCreationHandling : Enum {
    public int value__;
    public static ObjectCreationHandling Auto;
    public static ObjectCreationHandling Reuse;
    public static ObjectCreationHandling Replace;
}
[FlagsAttribute]
internal enum Newtonsoft.Json.PreserveReferencesHandling : Enum {
    public int value__;
    public static PreserveReferencesHandling None;
    public static PreserveReferencesHandling Objects;
    public static PreserveReferencesHandling Arrays;
    public static PreserveReferencesHandling All;
}
internal enum Newtonsoft.Json.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsInt64;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDateTimeOffset;
    public static ReadType ReadAsDouble;
    public static ReadType ReadAsBoolean;
}
internal enum Newtonsoft.Json.ReferenceLoopHandling : Enum {
    public int value__;
    public static ReferenceLoopHandling Error;
    public static ReferenceLoopHandling Ignore;
    public static ReferenceLoopHandling Serialize;
}
internal enum Newtonsoft.Json.Required : Enum {
    public int value__;
    public static Required Default;
    public static Required AllowNull;
    public static Required Always;
    public static Required DisallowNull;
}
[ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal static class Newtonsoft.Json.Schema.Extensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema, IList`1& errorMessages);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchema : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Transient>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Requires>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Disallow>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Extends>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    private string _internalId;
    [CompilerGeneratedAttribute]
private string <DeferredReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencesResolved>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public Nullable`1<bool> Required { get; public set; }
    public Nullable`1<bool> ReadOnly { get; public set; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Transient { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<JsonSchemaType> Type { get; public set; }
    public string Pattern { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public Nullable`1<bool> ExclusiveMinimum { get; public set; }
    public Nullable`1<bool> ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<JsonSchema> Items { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public JsonSchema AdditionalItems { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IDictionary`2<string, JsonSchema> Properties { get; public set; }
    public JsonSchema AdditionalProperties { get; public set; }
    public IDictionary`2<string, JsonSchema> PatternProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public string Requires { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public Nullable`1<JsonSchemaType> Disallow { get; public set; }
    public JToken Default { get; public set; }
    public IList`1<JsonSchema> Extends { get; public set; }
    public string Format { get; public set; }
    internal string Location { get; internal set; }
    internal string InternalId { get; }
    internal string DeferredReference { get; internal set; }
    internal bool ReferencesResolved { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Transient();
    [CompilerGeneratedAttribute]
public void set_Transient(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchema value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchema value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_Requires();
    [CompilerGeneratedAttribute]
public void set_Requires(string value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public JToken get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(JToken value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Extends();
    [CompilerGeneratedAttribute]
public void set_Extends(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
internal string get_Location();
    [CompilerGeneratedAttribute]
internal void set_Location(string value);
    internal string get_InternalId();
    [CompilerGeneratedAttribute]
internal string get_DeferredReference();
    [CompilerGeneratedAttribute]
internal void set_DeferredReference(string value);
    [CompilerGeneratedAttribute]
internal bool get_ReferencesResolved();
    [CompilerGeneratedAttribute]
internal void set_ReferencesResolved(bool value);
    public static JsonSchema Read(JsonReader reader);
    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver);
    public static JsonSchema Parse(string json);
    public static JsonSchema Parse(string json, JsonSchemaResolver resolver);
    public void WriteTo(JsonWriter writer);
    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver);
    public virtual string ToString();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaBuilder : object {
    private IList`1<JsonSchema> _stack;
    private JsonSchemaResolver _resolver;
    private IDictionary`2<string, JsonSchema> _documentSchemas;
    private JsonSchema _currentSchema;
    private JObject _rootSchema;
    private JsonSchema CurrentSchema { get; }
    public JsonSchemaBuilder(JsonSchemaResolver resolver);
    private void Push(JsonSchema value);
    private JsonSchema Pop();
    private JsonSchema get_CurrentSchema();
    internal JsonSchema Read(JsonReader reader);
    private string UnescapeReference(string reference);
    private JsonSchema ResolveReferences(JsonSchema schema);
    private JsonSchema BuildSchema(JToken token);
    private void ProcessSchemaProperties(JObject schemaObject);
    private void ProcessExtends(JToken token);
    private void ProcessEnum(JToken token);
    private void ProcessAdditionalProperties(JToken token);
    private void ProcessAdditionalItems(JToken token);
    private IDictionary`2<string, JsonSchema> ProcessProperties(JToken token);
    private void ProcessItems(JToken token);
    private Nullable`1<JsonSchemaType> ProcessType(JToken token);
    internal static JsonSchemaType MapType(string type);
    internal static string MapType(JsonSchemaType type);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal static class Newtonsoft.Json.Schema.JsonSchemaConstants : object {
    public static string TypePropertyName;
    public static string PropertiesPropertyName;
    public static string ItemsPropertyName;
    public static string AdditionalItemsPropertyName;
    public static string RequiredPropertyName;
    public static string PatternPropertiesPropertyName;
    public static string AdditionalPropertiesPropertyName;
    public static string RequiresPropertyName;
    public static string MinimumPropertyName;
    public static string MaximumPropertyName;
    public static string ExclusiveMinimumPropertyName;
    public static string ExclusiveMaximumPropertyName;
    public static string MinimumItemsPropertyName;
    public static string MaximumItemsPropertyName;
    public static string PatternPropertyName;
    public static string MaximumLengthPropertyName;
    public static string MinimumLengthPropertyName;
    public static string EnumPropertyName;
    public static string ReadOnlyPropertyName;
    public static string TitlePropertyName;
    public static string DescriptionPropertyName;
    public static string FormatPropertyName;
    public static string DefaultPropertyName;
    public static string TransientPropertyName;
    public static string DivisibleByPropertyName;
    public static string HiddenPropertyName;
    public static string DisallowPropertyName;
    public static string ExtendsPropertyName;
    public static string IdPropertyName;
    public static string UniqueItemsPropertyName;
    public static string OptionValuePropertyName;
    public static string OptionLabelPropertyName;
    public static IDictionary`2<string, JsonSchemaType> JsonSchemaTypeMapping;
    private static JsonSchemaConstants();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Path { get; }
    public JsonSchemaException(string message);
    public JsonSchemaException(string message, Exception innerException);
    public JsonSchemaException(SerializationInfo info, StreamingContext context);
    internal JsonSchemaException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
public string get_Path();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaGenerator : object {
    [CompilerGeneratedAttribute]
private UndefinedSchemaIdHandling <UndefinedSchemaIdHandling>k__BackingField;
    private IContractResolver _contractResolver;
    private JsonSchemaResolver _resolver;
    private IList`1<TypeSchema> _stack;
    private JsonSchema _currentSchema;
    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    private JsonSchema CurrentSchema { get; }
    [CompilerGeneratedAttribute]
public UndefinedSchemaIdHandling get_UndefinedSchemaIdHandling();
    [CompilerGeneratedAttribute]
public void set_UndefinedSchemaIdHandling(UndefinedSchemaIdHandling value);
    public IContractResolver get_ContractResolver();
    public void set_ContractResolver(IContractResolver value);
    private JsonSchema get_CurrentSchema();
    private void Push(TypeSchema typeSchema);
    private TypeSchema Pop();
    public JsonSchema Generate(Type type);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver);
    public JsonSchema Generate(Type type, bool rootSchemaNullable);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable);
    private string GetTitle(Type type);
    private string GetDescription(Type type);
    private string GetTypeId(Type type, bool explicitOnly);
    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required);
    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private void GenerateObjectSchema(Type type, JsonObjectContract contract);
    private void GenerateISerializableContract(Type type, JsonISerializableContract contract);
    internal static bool HasFlag(Nullable`1<JsonSchemaType> value, JsonSchemaType flag);
    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaModel : object {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchemaModel> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Disallow>k__BackingField;
    public bool Required { get; public set; }
    public JsonSchemaType Type { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public bool ExclusiveMinimum { get; public set; }
    public bool ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<string> Patterns { get; public set; }
    public IList`1<JsonSchemaModel> Items { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> Properties { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> PatternProperties { get; public set; }
    public JsonSchemaModel AdditionalProperties { get; public set; }
    public JsonSchemaModel AdditionalItems { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public JsonSchemaType Disallow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(JsonSchemaType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Patterns();
    [CompilerGeneratedAttribute]
public void set_Patterns(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchemaModel> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(JsonSchemaType value);
    public static JsonSchemaModel Create(IList`1<JsonSchema> schemata);
    private static void Combine(JsonSchemaModel model, JsonSchema schema);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaModelBuilder : object {
    private JsonSchemaNodeCollection _nodes;
    private Dictionary`2<JsonSchemaNode, JsonSchemaModel> _nodeModels;
    private JsonSchemaNode _node;
    public JsonSchemaModel Build(JsonSchema schema);
    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema);
    public void AddProperties(IDictionary`2<string, JsonSchema> source, IDictionary`2<string, JsonSchemaNode> target);
    public void AddProperty(IDictionary`2<string, JsonSchemaNode> target, string propertyName, JsonSchema schema);
    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema);
    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema);
    public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema);
    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaNode : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<JsonSchema> <Schemas>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JsonSchemaNode> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalItems>k__BackingField;
    public string Id { get; }
    public ReadOnlyCollection`1<JsonSchema> Schemas { get; }
    public Dictionary`2<string, JsonSchemaNode> Properties { get; }
    public Dictionary`2<string, JsonSchemaNode> PatternProperties { get; }
    public List`1<JsonSchemaNode> Items { get; }
    public JsonSchemaNode AdditionalProperties { get; public set; }
    public JsonSchemaNode AdditionalItems { get; public set; }
    public JsonSchemaNode(JsonSchema schema);
    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<JsonSchema> get_Schemas();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_Properties();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_PatternProperties();
    [CompilerGeneratedAttribute]
public List`1<JsonSchemaNode> get_Items();
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaNode value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaNode value);
    public JsonSchemaNode Combine(JsonSchema schema);
    public static string GetId(IEnumerable`1<JsonSchema> schemata);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaNodeCollection : KeyedCollection`2<string, JsonSchemaNode> {
    protected virtual string GetKeyForItem(JsonSchemaNode item);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaResolver : object {
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <LoadedSchemas>k__BackingField;
    public IList`1<JsonSchema> LoadedSchemas { get; protected set; }
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_LoadedSchemas();
    [CompilerGeneratedAttribute]
protected void set_LoadedSchemas(IList`1<JsonSchema> value);
    public virtual JsonSchema GetSchema(string reference);
}
[FlagsAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal enum Newtonsoft.Json.Schema.JsonSchemaType : Enum {
    public int value__;
    public static JsonSchemaType None;
    public static JsonSchemaType String;
    public static JsonSchemaType Float;
    public static JsonSchemaType Integer;
    public static JsonSchemaType Boolean;
    public static JsonSchemaType Object;
    public static JsonSchemaType Array;
    public static JsonSchemaType Null;
    public static JsonSchemaType Any;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.JsonSchemaWriter : object {
    private JsonWriter _writer;
    private JsonSchemaResolver _resolver;
    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver);
    private void ReferenceOrWriteSchema(JsonSchema schema);
    public void WriteSchema(JsonSchema schema);
    private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary`2<string, JsonSchema> properties);
    private void WriteItems(JsonSchema schema);
    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type);
    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal enum Newtonsoft.Json.Schema.UndefinedSchemaIdHandling : Enum {
    public int value__;
    public static UndefinedSchemaIdHandling None;
    public static UndefinedSchemaIdHandling UseTypeName;
    public static UndefinedSchemaIdHandling UseAssemblyQualifiedName;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.ValidationEventArgs : EventArgs {
    private JsonSchemaException _ex;
    public JsonSchemaException Exception { get; }
    public string Path { get; }
    public string Message { get; }
    internal ValidationEventArgs(JsonSchemaException ex);
    public JsonSchemaException get_Exception();
    public string get_Path();
    public string get_Message();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Newtonsoft.Json.Schema.ValidationEventHandler : MulticastDelegate {
    public ValidationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Newtonsoft.Json.Serialization.CachedAttributeGetter`1 : object {
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<object, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public static T GetAttribute(object type);
}
internal class Newtonsoft.Json.Serialization.CamelCaseNamingStrategy : NamingStrategy {
    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [Newtonsoft.Json.NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    private static object TypeContractCacheLock;
    private static DefaultJsonNameTable NameTable;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<StructMultiKey`2<Type, Type>, JsonContract> _contractCache;
    private static CamelCasePropertyNamesContractResolver();
    public virtual JsonContract ResolveContract(Type type);
    internal virtual DefaultJsonNameTable GetNameTable();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DefaultContractResolver : object {
    private static IContractResolver _instance;
    private static String[] BlacklistedTypeNames;
    private static JsonConverter[] BuiltInConverters;
    private DefaultJsonNameTable _nameTable;
    private ThreadSafeStore`2<Type, JsonContract> _contractCache;
    [CompilerGeneratedAttribute]
private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreIsSpecifiedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreShouldSerializeMembers>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategy>k__BackingField;
    internal static IContractResolver Instance { get; }
    public bool DynamicCodeGeneration { get; }
    [ObsoleteAttribute("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
public BindingFlags DefaultMembersSearchFlags { get; public set; }
    public bool SerializeCompilerGeneratedMembers { get; public set; }
    public bool IgnoreSerializableInterface { get; public set; }
    public bool IgnoreSerializableAttribute { get; public set; }
    public bool IgnoreIsSpecifiedMembers { get; public set; }
    public bool IgnoreShouldSerializeMembers { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public NamingStrategy NamingStrategy { get; public set; }
    private static DefaultContractResolver();
    internal static IContractResolver get_Instance();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableInterface();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableAttribute();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreIsSpecifiedMembers();
    [CompilerGeneratedAttribute]
public void set_IgnoreIsSpecifiedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreShouldSerializeMembers();
    [CompilerGeneratedAttribute]
public void set_IgnoreShouldSerializeMembers(bool value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NamingStrategy get_NamingStrategy();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NamingStrategy(NamingStrategy value);
    public virtual JsonContract ResolveContract(Type type);
    private static bool FilterMembers(MemberInfo member);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private static void ThrowUnableToSerializeError(object o, StreamingContext context);
    private MemberInfo GetExtensionDataMemberForType(Type type);
    private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member);
    private ConstructorInfo GetAttributeConstructor(Type objectType);
    private ConstructorInfo GetImmutableConstructor(Type objectType, JsonPropertyCollection memberProperties);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    protected virtual IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    private JsonProperty MatchProperty(JsonPropertyCollection properties, string name, Type type);
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    private void InitializeContract(JsonContract contract);
    private void ResolveCallbackMethods(JsonContract contract, Type t);
    private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError);
    private static bool IsConcurrentOrObservableCollection(Type t);
    private static bool ShouldSkipDeserialized(Type t);
    private static bool ShouldSkipSerializing(Type t);
    private List`1<Type> GetClassHierarchyForType(Type type);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonDynamicContract CreateDynamicContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool IsJsonPrimitiveType(Type t);
    internal static bool IsIConvertible(Type t);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    internal virtual DefaultJsonNameTable GetNameTable();
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess);
    protected virtual string ResolvePropertyName(string propertyName);
    protected virtual string ResolveExtensionDataName(string extensionDataName);
    protected virtual string ResolveDictionaryKey(string dictionaryKey);
    public string GetResolvedPropertyName(string propertyName);
}
internal class Newtonsoft.Json.Serialization.DefaultNamingStrategy : NamingStrategy {
    [Newtonsoft.Json.NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DefaultReferenceResolver : object {
    private int _referenceCount;
    private BidirectionalDictionary`2<string, object> GetMappings(object context);
    public sealed virtual object ResolveReference(object context, string reference);
    public sealed virtual string GetReference(object context, object value);
    public sealed virtual void AddReference(object context, string reference, object value);
    public sealed virtual bool IsReferenced(object context, object value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    internal static DefaultSerializationBinder Instance;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadSafeStore`2<StructMultiKey`2<string, string>, Type> _typeCache;
    private static DefaultSerializationBinder();
    private Type GetTypeFromTypeNameKey(StructMultiKey`2<string, string> typeNameKey);
    private Type GetGenericTypeFromTypeName(string typeName, Assembly assembly);
    private Type GetTypeByName(StructMultiKey`2<string, string> typeNameKey);
    public virtual Type BindToType(string assemblyName, string typeName);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
internal class Newtonsoft.Json.Serialization.DiagnosticsTraceWriter : object {
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    private TraceEventType GetTraceEventType(TraceLevel level);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.DynamicValueProvider : object {
    private MemberInfo _memberInfo;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _getter;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _setter;
    public DynamicValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]
private bool <Traced>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <OriginalObject>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    internal bool Traced { get; internal set; }
    public Exception Error { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public object OriginalObject { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public object Member { get; }
    public string Path { get; }
    public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, string path, Exception error);
    [CompilerGeneratedAttribute]
internal bool get_Traced();
    [CompilerGeneratedAttribute]
internal void set_Traced(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_OriginalObject();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.ErrorEventArgs : EventArgs {
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorContext <ErrorContext>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
public object CurrentObject { get; }
    public ErrorContext ErrorContext { get; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.ExpressionValueProvider : object {
    private MemberInfo _memberInfo;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _getter;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _setter;
    public ExpressionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Newtonsoft.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
    public ExtensionDataGetter(object object, IntPtr method);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
    public ExtensionDataSetter(object object, IntPtr method);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual void Invoke(object o, string key, object value);
    public virtual IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Serialization.IAttributeProvider {
    public abstract virtual IList`1<Attribute> GetAttributes(bool inherit);
    public abstract virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(object context, string reference);
    public abstract virtual string GetReference(object context, object value);
    public abstract virtual bool IsReferenced(object context, object value);
    public abstract virtual void AddReference(object context, string reference, object value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Serialization.ISerializationBinder {
    public abstract virtual Type BindToType(string assemblyName, string typeName);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public abstract virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Serialization.ITraceWriter {
    public TraceLevel LevelFilter { get; }
    public abstract virtual TraceLevel get_LevelFilter();
    public abstract virtual void Trace(TraceLevel level, string message, Exception ex);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
internal interface Newtonsoft.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonArrayContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private Type <CollectionItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultidimensionalArray>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _genericWrapperCreator;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _genericTemporaryCollectionCreator;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    public Type CollectionItemType { get; }
    public bool IsMultidimensionalArray { get; }
    internal bool IsArray { get; }
    internal bool ShouldCreateWrapper { get; }
    internal bool CanDeserialize { get; private set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensionalArray();
    [CompilerGeneratedAttribute]
internal bool get_IsArray();
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal IWrappedCollection CreateWrapper(object list);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal IList CreateTemporaryCollection();
    [Newtonsoft.Json.NullableContextAttribute("1")]
private void StoreFSharpListCreatorIfNecessary(Type underlyingType);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonContainerContract : JsonContract {
    private JsonContract _itemContract;
    private JsonContract _finalItemContract;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContract FinalItemContract { get; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
    internal JsonContract get_FinalItemContract();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Serialization.JsonContract : object {
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onDeserializedCallbacks;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onDeserializingCallbacks;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onSerializedCallbacks;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onSerializingCallbacks;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationErrorCallback> _onErrorCallbacks;
    private Type _createdType;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonConverter <InternalConverter>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCreatorNonPublic>k__BackingField;
    public Type UnderlyingType { get; }
    public Type CreatedType { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JsonConverter Converter { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public JsonConverter InternalConverter { get; internal set; }
    public IList`1<SerializationCallback> OnDeserializedCallbacks { get; }
    public IList`1<SerializationCallback> OnDeserializingCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializedCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializingCallbacks { get; }
    public IList`1<SerializationErrorCallback> OnErrorCallbacks { get; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<object> DefaultCreator { get; public set; }
    public bool DefaultCreatorNonPublic { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonConverter get_InternalConverter();
    [Newtonsoft.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    public IList`1<SerializationCallback> get_OnDeserializedCallbacks();
    public IList`1<SerializationCallback> get_OnDeserializingCallbacks();
    public IList`1<SerializationCallback> get_OnSerializedCallbacks();
    public IList`1<SerializationCallback> get_OnSerializingCallbacks();
    public IList`1<SerializationErrorCallback> get_OnErrorCallbacks();
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo);
    internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo);
}
internal enum Newtonsoft.Json.Serialization.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <DictionaryKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _genericWrapperCreator;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _genericTemporaryDictionaryCreator;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> DictionaryKeyResolver { get; public set; }
    public Type DictionaryKeyType { get; }
    public Type DictionaryValueType { get; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_DictionaryKeyResolver();
    [CompilerGeneratedAttribute]
public void set_DictionaryKeyResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal IWrappedDictionary CreateWrapper(object dictionary);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal IDictionary CreateTemporaryDictionary();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonDynamicContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <PropertyNameResolver>k__BackingField;
    private ThreadSafeStore`2<string, CallSite`1<Func`3<CallSite, object, object>>> _callSiteGetters;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadSafeStore`2<string, CallSite`1<Func`4<CallSite, object, object, object>>> _callSiteSetters;
    public JsonPropertyCollection Properties { get; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> PropertyNameResolver { get; public set; }
    public JsonDynamicContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_PropertyNameResolver();
    [CompilerGeneratedAttribute]
public void set_PropertyNameResolver(Func`2<string, string> value);
    private static CallSite`1<Func`3<CallSite, object, object>> CreateCallSiteGetter(string name);
    private static CallSite`1<Func`4<CallSite, object, object, object>> CreateCallSiteSetter(string name);
    internal bool TryGetMember(IDynamicMetaObjectProvider dynamicProvider, string name, Object& value);
    internal bool TrySetMember(IDynamicMetaObjectProvider dynamicProvider, string name, object value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonFormatterConverter : object {
    private JsonSerializerInternalReader _reader;
    private JsonISerializableContract _contract;
    [Newtonsoft.Json.NullableAttribute("2")]
private JsonProperty _member;
    public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
internal class Newtonsoft.Json.Serialization.JsonISerializableContract : JsonContainerContract {
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
internal class Newtonsoft.Json.Serialization.JsonLinqContract : JsonContract {
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonLinqContract(Type underlyingType);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonObjectContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MissingMemberHandling> <MissingMemberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Required> <ItemRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <ItemNullValueHandling>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("1")]
[CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataGetter <ExtensionDataGetter>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <ExtensionDataNameResolver>k__BackingField;
    internal bool ExtensionDataIsJToken;
    private Nullable`1<bool> _hasRequiredOrDefaultValueProperties;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    private JsonPropertyCollection _creatorParameters;
    private Type _extensionDataValueType;
    public MemberSerialization MemberSerialization { get; public set; }
    public Nullable`1<MissingMemberHandling> MissingMemberHandling { get; public set; }
    public Nullable`1<Required> ItemRequired { get; public set; }
    public Nullable`1<NullValueHandling> ItemNullValueHandling { get; public set; }
    [Newtonsoft.Json.NullableAttribute("1")]
public JsonPropertyCollection Properties { get; }
    [Newtonsoft.Json.NullableAttribute("1")]
public JsonPropertyCollection CreatorParameters { get; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; internal set; }
    public ExtensionDataSetter ExtensionDataSetter { get; public set; }
    public ExtensionDataGetter ExtensionDataGetter { get; public set; }
    public Type ExtensionDataValueType { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> ExtensionDataNameResolver { get; public set; }
    internal bool HasRequiredOrDefaultValueProperties { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public Nullable`1<MissingMemberHandling> get_MissingMemberHandling();
    [CompilerGeneratedAttribute]
public void set_MissingMemberHandling(Nullable`1<MissingMemberHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Required> get_ItemRequired();
    [CompilerGeneratedAttribute]
public void set_ItemRequired(Nullable`1<Required> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_ItemNullValueHandling();
    [CompilerGeneratedAttribute]
public void set_ItemNullValueHandling(Nullable`1<NullValueHandling> value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonPropertyCollection get_CreatorParameters();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    internal void set_ParameterizedCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public ExtensionDataSetter get_ExtensionDataSetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataSetter(ExtensionDataSetter value);
    [CompilerGeneratedAttribute]
public ExtensionDataGetter get_ExtensionDataGetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataGetter(ExtensionDataGetter value);
    public Type get_ExtensionDataValueType();
    public void set_ExtensionDataValueType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_ExtensionDataNameResolver();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataNameResolver(Func`2<string, string> value);
    internal bool get_HasRequiredOrDefaultValueProperties();
    [Newtonsoft.Json.NullableContextAttribute("1")]
[SecuritySafeCriticalAttribute]
internal object GetUninitializedObject();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    private static Dictionary`2<Type, ReadType> ReadTypeMap;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonProperty : object {
    internal Nullable`1<Required> _required;
    internal bool _hasExplicitDefaultValue;
    private object _defaultValue;
    private bool _hasGeneratedDefaultValue;
    private string _propertyName;
    internal bool _skipPropertyNameEscape;
    private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnderlyingName>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IAttributeProvider <AttributeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldSerialize>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldDeserialize>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <GetIsSpecified>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <SetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Type DeclaringType { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public string UnderlyingName { get; public set; }
    public IValueProvider ValueProvider { get; public set; }
    public IAttributeProvider AttributeProvider { get; public set; }
    public Type PropertyType { get; public set; }
    public JsonConverter Converter { get; public set; }
    [ObsoleteAttribute("MemberConverter is obsolete. Use Converter instead.")]
public JsonConverter MemberConverter { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    public object DefaultValue { get; public set; }
    public Required Required { get; public set; }
    public bool IsRequiredSpecified { get; }
    public Nullable`1<bool> IsReference { get; public set; }
    public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> ShouldSerialize { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> ShouldDeserialize { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> GetIsSpecified { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> SetIsSpecified { get; public set; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UnderlyingName();
    [CompilerGeneratedAttribute]
public void set_UnderlyingName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public IAttributeProvider get_AttributeProvider();
    [CompilerGeneratedAttribute]
public void set_AttributeProvider(IAttributeProvider value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    public JsonConverter get_MemberConverter();
    public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetResolvedDefaultValue();
    public Required get_Required();
    public void set_Required(Required value);
    public bool get_IsRequiredSpecified();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
public void set_ShouldDeserialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_GetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_GetIsSpecified(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_SetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_SetIsSpecified(Action`2<object, object> value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
internal void WritePropertyName(JsonWriter writer);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Newtonsoft.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetProperty(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Serialization.JsonSerializerInternalBase : object {
    [Newtonsoft.Json.NullableAttribute("2")]
private ErrorContext _currentErrorContext;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BidirectionalDictionary`2<string, object> _mappings;
    internal JsonSerializer Serializer;
    [Newtonsoft.Json.NullableAttribute("2")]
internal ITraceWriter TraceWriter;
    [Newtonsoft.Json.NullableAttribute("2")]
protected JsonSerializerProxy InternalSerializer;
    internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings { get; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings();
    protected NullValueHandling ResolvedNullValueHandling(JsonObjectContract containerContract, JsonProperty property);
    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error);
    protected void ClearErrorContext();
    [Newtonsoft.Json.NullableContextAttribute("2")]
protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private JsonContract GetContractSafe(Type type);
    private JsonContract GetContract(Type type);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent);
    private JsonSerializerProxy GetInternalSerializer();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName);
    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool HasNoDefinedType(JsonContract contract);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue, Boolean& ignoredValue);
    private void AddReference(JsonReader reader, string id, object value);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool ShouldSetPropertyValue(JsonProperty property, JsonObjectContract contract, object value);
    private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator);
    private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator);
    private void OnDeserializing(JsonReader reader, JsonContract contract, object value);
    private void OnDeserialized(JsonReader reader, JsonContract contract, object value);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id);
    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message);
    private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id);
    internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member);
    private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, JsonProperty member, string id);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id);
    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue);
    private List`1<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id);
    private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target);
    private bool CheckPropertyName(JsonReader reader, string memberName);
    private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o);
    private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader);
    private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue);
    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties);
    private void HandleError(JsonReader reader, bool readPastError, int initialDepth);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    [Newtonsoft.Json.NullableAttribute("2")]
private Type _rootType;
    private int _rootLevel;
    private List`1<object> _serializeStack;
    public JsonSerializerInternalWriter(JsonSerializer serializer);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private JsonContract GetContractSafe(object value);
    private JsonContract GetContract(object value);
    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool ShouldWriteProperty(object memberValue, JsonObjectContract containerContract, JsonProperty property);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void WriteReference(JsonWriter writer, object value);
    private string GetReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void OnSerializing(JsonWriter writer, JsonContract contract, object value);
    private void OnSerialized(JsonWriter writer, JsonContract contract, object value);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue);
    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool HasCreatorParameter(JsonContainerContract contract, JsonProperty property);
    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices);
    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [SecuritySafeCriticalAttribute]
private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeDynamic(JsonWriter writer, IDynamicMetaObjectProvider value, JsonDynamicContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool ShouldWriteDynamicProperty(object memberValue);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target);
    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    [Newtonsoft.Json.NullableAttribute("2")]
private JsonSerializerInternalReader _serializerReader;
    [Newtonsoft.Json.NullableAttribute("2")]
private JsonSerializerInternalWriter _serializerWriter;
    internal JsonSerializer _serializer;
    [Newtonsoft.Json.NullableAttribute("2")]
public IReferenceResolver ReferenceResolver { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public ITraceWriter TraceWriter { get; public set; }
    [Newtonsoft.Json.NullableAttribute("2")]
public IEqualityComparer EqualityComparer { get; public set; }
    public JsonConverterCollection Converters { get; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual IReferenceResolver get_ReferenceResolver();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void set_ReferenceResolver(IReferenceResolver value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual ITraceWriter get_TraceWriter();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void set_TraceWriter(ITraceWriter value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual IEqualityComparer get_EqualityComparer();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public virtual void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ISerializationBinder get_SerializationBinder();
    public virtual void set_SerializationBinder(ISerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal JsonSerializerInternalBase GetInternalSerializer();
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    [Newtonsoft.Json.NullableContextAttribute("2")]
internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType);
}
internal class Newtonsoft.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
    [Newtonsoft.Json.NullableContextAttribute("1")]
public JsonStringContract(Type underlyingType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.Serialization.JsonTypeReflector : object {
    private static Nullable`1<bool> _dynamicCodeGeneration;
    private static Nullable`1<bool> _fullyTrusted;
    public static string IdPropertyName;
    public static string RefPropertyName;
    public static string TypePropertyName;
    public static string ValuePropertyName;
    public static string ArrayValuesPropertyName;
    public static string ShouldSerializePrefix;
    public static string SpecifiedPostfix;
    public static string ConcurrentDictionaryTypeName;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Func`2<Object[], object>> CreatorCache;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    [Newtonsoft.Json.NullableAttribute("2")]
private static ReflectionObject _metadataTypeAttributeReflectionObject;
    public static bool DynamicCodeGeneration { get; }
    public static bool FullyTrusted { get; }
    public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static T GetCachedAttribute(object attributeProvider);
    public static bool CanTypeDescriptorConvertString(Type type, TypeConverter& typeConverter);
    public static DataContractAttribute GetDataContractAttribute(Type type);
    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute);
    public static JsonConverter GetJsonConverter(object attributeProvider);
    public static JsonConverter CreateJsonConverterInstance(Type converterType, Object[] args);
    public static NamingStrategy CreateNamingStrategyInstance(Type namingStrategyType, Object[] args);
    public static NamingStrategy GetContainerNamingStrategy(JsonContainerAttribute containerAttribute);
    private static Func`2<Object[], object> GetCreator(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    private static T GetAttribute(Type type);
    private static T GetAttribute(MemberInfo memberInfo);
    public static bool IsNonSerializable(object provider);
    public static bool IsSerializable(object provider);
    public static T GetAttribute(object provider);
    [SecuritySafeCriticalAttribute]
public static bool get_DynamicCodeGeneration();
    public static bool get_FullyTrusted();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
internal class Newtonsoft.Json.Serialization.KebabCaseNamingStrategy : NamingStrategy {
    public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [Newtonsoft.Json.NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.MemoryTraceWriter : object {
    private Queue`1<string> _traceMessages;
    private object _lock;
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    public IEnumerable`1<string> GetTraceMessages();
    public virtual string ToString();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Serialization.NamingStrategy : object {
    [CompilerGeneratedAttribute]
private bool <ProcessDictionaryKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessExtensionDataNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverrideSpecifiedNames>k__BackingField;
    public bool ProcessDictionaryKeys { get; public set; }
    public bool ProcessExtensionDataNames { get; public set; }
    public bool OverrideSpecifiedNames { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ProcessDictionaryKeys();
    [CompilerGeneratedAttribute]
public void set_ProcessDictionaryKeys(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProcessExtensionDataNames();
    [CompilerGeneratedAttribute]
public void set_ProcessExtensionDataNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_OverrideSpecifiedNames();
    [CompilerGeneratedAttribute]
public void set_OverrideSpecifiedNames(bool value);
    public virtual string GetPropertyName(string name, bool hasSpecifiedName);
    public virtual string GetExtensionDataName(string name);
    public virtual string GetDictionaryKey(string key);
    protected abstract virtual string ResolvePropertyName(string name);
    public virtual int GetHashCode();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [Newtonsoft.Json.NullableContextAttribute("2")]
protected bool Equals(NamingStrategy other);
}
internal class Newtonsoft.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
internal class Newtonsoft.Json.Serialization.OnErrorAttribute : Attribute {
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.ReflectionAttributeProvider : object {
    private object _attributeProvider;
    public ReflectionAttributeProvider(object attributeProvider);
    public sealed virtual IList`1<Attribute> GetAttributes(bool inherit);
    public sealed virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.ReflectionValueProvider : object {
    private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.SerializationBinderAdapter : object {
    public SerializationBinder SerializationBinder;
    public SerializationBinderAdapter(SerializationBinder serializationBinder);
    public sealed virtual Type BindToType(string assemblyName, string typeName);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public sealed virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
internal class Newtonsoft.Json.Serialization.SerializationCallback : MulticastDelegate {
    public SerializationCallback(object object, IntPtr method);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual void Invoke(object o, StreamingContext context);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
    public SerializationErrorCallback(object object, IntPtr method);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual void Invoke(object o, StreamingContext context, ErrorContext errorContext);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Newtonsoft.Json.Serialization.SnakeCaseNamingStrategy : NamingStrategy {
    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    [Newtonsoft.Json.NullableContextAttribute("1")]
protected virtual string ResolvePropertyName(string name);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.TraceJsonReader : JsonReader {
    private JsonReader _innerReader;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public object Value { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
public Type ValueType { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LineNumber { get; }
    private int Newtonsoft.Json.IJsonLineInfo.LinePosition { get; }
    public TraceJsonReader(JsonReader innerReader);
    public string GetDeserializedJsonMessage();
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual string ReadAsString();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public void WriteCurrentToken();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual object get_Value();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual Type get_ValueType();
    public virtual void Close();
    private sealed virtual override bool Newtonsoft.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Newtonsoft.Json.IJsonLineInfo.get_LinePosition();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Serialization.TraceJsonWriter : JsonWriter {
    private JsonWriter _innerWriter;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public TraceJsonWriter(JsonWriter innerWriter);
    public string GetSerializedJsonMessage();
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Nullable`1<char> value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteUndefined();
    public virtual void WriteNull();
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(Nullable`1<int> value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(Nullable`1<long> value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(Nullable`1<short> value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Nullable`1<ulong> value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteWhitespace(string ws);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteRawValue(string json);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    public virtual void Close();
    public virtual void Flush();
}
internal enum Newtonsoft.Json.StringEscapeHandling : Enum {
    public int value__;
    public static StringEscapeHandling Default;
    public static StringEscapeHandling EscapeNonAscii;
    public static StringEscapeHandling EscapeHtml;
}
internal enum Newtonsoft.Json.TypeNameAssemblyFormatHandling : Enum {
    public int value__;
    public static TypeNameAssemblyFormatHandling Simple;
    public static TypeNameAssemblyFormatHandling Full;
}
[FlagsAttribute]
internal enum Newtonsoft.Json.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Arrays;
    public static TypeNameHandling All;
    public static TypeNameHandling Auto;
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.AsyncUtils : object {
    public static Task`1<bool> False;
    public static Task`1<bool> True;
    internal static Task CompletedTask;
    private static AsyncUtils();
    [ExtensionAttribute]
internal static Task`1<bool> ToAsync(bool value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task CancelIfRequestedAsync(CancellationToken cancellationToken);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task`1<T> CancelIfRequestedAsync(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task FromCanceled(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> FromCanceled(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, char value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, string value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, Char[] value, int start, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> ReadAsync(TextReader reader, Char[] buffer, int index, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsCompletedSuccessfully(Task task);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.Base64Encoder : object {
    private static int Base64LineSize;
    private static int LineSizeInBytes;
    private Char[] _charsLine;
    private TextWriter _writer;
    [Newtonsoft.Json.NullableAttribute("2")]
private Byte[] _leftOverBytes;
    private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    private void ValidateEncode(Byte[] buffer, int index, int count);
    public void Encode(Byte[] buffer, int index, int count);
    private void StoreLeftOverBytes(Byte[] buffer, int index, Int32& count);
    private bool FulfillFromLeftover(Byte[] buffer, int index, Int32& count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.Base64Encoder/<EncodeAsync>d__13")]
public Task EncodeAsync(Byte[] buffer, int index, int count, CancellationToken cancellationToken);
    private Task WriteCharsAsync(Char[] chars, int index, int count, CancellationToken cancellationToken);
    public Task FlushAsync(CancellationToken cancellationToken);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.BidirectionalDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> _firstToSecond;
    private IDictionary`2<TSecond, TFirst> _secondToFirst;
    private string _duplicateFirstErrorMessage;
    private string _duplicateSecondErrorMessage;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage);
    public void Set(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.BoxedPrimitives : object {
    internal static object BooleanTrue;
    internal static object BooleanFalse;
    internal static object Int32_M1;
    internal static object Int32_0;
    internal static object Int32_1;
    internal static object Int32_2;
    internal static object Int32_3;
    internal static object Int32_4;
    internal static object Int32_5;
    internal static object Int32_6;
    internal static object Int32_7;
    internal static object Int32_8;
    internal static object Int64_M1;
    internal static object Int64_0;
    internal static object Int64_1;
    internal static object Int64_2;
    internal static object Int64_3;
    internal static object Int64_4;
    internal static object Int64_5;
    internal static object Int64_6;
    internal static object Int64_7;
    internal static object Int64_8;
    internal static object DoubleNaN;
    internal static object DoublePositiveInfinity;
    internal static object DoubleNegativeInfinity;
    internal static object DoubleZero;
    internal static object DoubleNegativeZero;
    private static BoxedPrimitives();
    internal static object Get(bool value);
    internal static object Get(int value);
    internal static object Get(long value);
    internal static object Get(decimal value);
    internal static object Get(double value);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.BufferUtils : object {
    [Newtonsoft.Json.NullableContextAttribute("1")]
public static Char[] RentBuffer(IArrayPool`1<char> bufferPool, int minSize);
    public static void ReturnBuffer(IArrayPool`1<char> bufferPool, Char[] buffer);
    public static Char[] EnsureBufferSize(IArrayPool`1<char> bufferPool, int size, Char[] buffer);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.CollectionUtils : object {
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    public static bool IsDictionaryType(Type type);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(List`1<T> list, T value, IEqualityComparer comparer);
    [ExtensionAttribute]
public static int IndexOfReference(List`1<T> list, T item);
    [ExtensionAttribute]
public static void FastReverse(List`1<T> list);
    private static IList`1<int> GetDimensions(IList values, int dimensionsCount);
    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices);
    private static object JaggedArrayGetValue(IList values, Int32[] indices);
    public static Array ToMultidimensionalArray(IList values, Type type, int rank);
    public static T[] ArrayEmpty();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.CollectionWrapper`1 : object {
    [Newtonsoft.Json.NullableAttribute("2")]
private IList _list;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<T> _genericCollection;
    [Newtonsoft.Json.NullableAttribute("2")]
private object _syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [Newtonsoft.Json.NullableContextAttribute("2")]
private static void VerifyValueType(object value);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.ConvertUtils : object {
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static TypeInformation[] PrimitiveTypeCodes;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, Type>, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static TypeInformation GetTypeInformation(IConvertible convertable);
    public static bool IsConvertible(Type t);
    public static TimeSpan ParseTimeSpan(string input);
    [Newtonsoft.Json.NullableContextAttribute("2")]
private static Func`2<object, object> CreateCastConverter(StructMultiKey`2<Type, Type> t);
    internal static BigInteger ToBigInteger(object value);
    public static object FromBigInteger(BigInteger i, Type targetType);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value);
    private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    public static bool VersionTryParse(string input, Version& result);
    public static bool IsInteger(object value);
    public static ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value);
    public static ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value);
    public static ParseResult DecimalTryParse(Char[] chars, int start, int length, Decimal& value);
    public static bool TryConvertGuid(string s, Guid& g);
    public static bool TryHexTextToInt(Char[] text, int start, int end, Int32& value);
}
internal class Newtonsoft.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DateTimeParser : ValueType {
    public int Year;
    public int Month;
    public int Day;
    public int Hour;
    public int Minute;
    public int Second;
    public int Fraction;
    public int ZoneHour;
    public int ZoneMinute;
    public ParserTimeZone Zone;
    private Char[] _text;
    private int _end;
    private static Int32[] Power10;
    private static int Lzyyyy;
    private static int Lzyyyy_;
    private static int Lzyyyy_MM;
    private static int Lzyyyy_MM_;
    private static int Lzyyyy_MM_dd;
    private static int Lzyyyy_MM_ddT;
    private static int LzHH;
    private static int LzHH_;
    private static int LzHH_mm;
    private static int LzHH_mm_;
    private static int LzHH_mm_ss;
    private static int Lz_;
    private static int Lz_zz;
    private static short MaxFractionDigits;
    private static DateTimeParser();
    public bool Parse(Char[] text, int startIndex, int length);
    private bool ParseDate(int start);
    private bool ParseTimeAndZoneAndWhitespace(int start);
    private bool ParseTime(Int32& start);
    private bool ParseZone(int start);
    private bool Parse4Digit(int start, Int32& num);
    private bool Parse2Digit(int start, Int32& num);
    private bool ParseChar(int start, char ch);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DateTimeUtils : object {
    internal static long InitialJavaScriptDateTicks;
    private static string IsoDateFormat;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysPer4Years;
    private static int DaysPerYear;
    private static long TicksPerDay;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversalTicksToJavaScriptTicks(long universalTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    internal static bool TryParseDateTimeOffsetIso(StringReference text, DateTimeOffset& dt);
    private static DateTime CreateDateTime(DateTimeParser dateTimeParser);
    internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    internal static bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryParseMicrosoftDate(StringReference text, Int64& ticks, TimeSpan& offset, DateTimeKind& kind);
    private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, DateTimeOffset& dt);
    private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryReadOffset(StringReference offsetText, int startIndex, TimeSpan& offset);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.DictionaryWrapper`2 : object {
    [Newtonsoft.Json.NullableAttribute("2")]
private IDictionary _dictionary;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TKey, TValue> _genericDictionary;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<TKey, TValue> _readOnlyDictionary;
    [Newtonsoft.Json.NullableAttribute("2")]
private object _syncRoot;
    internal IDictionary`2<TKey, TValue> GenericDictionary { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [Newtonsoft.Json.NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public DictionaryWrapper`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    internal IDictionary`2<TKey, TValue> get_GenericDictionary();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicProxy`1 : object {
    public virtual IEnumerable`1<string> GetDynamicMemberNames(T instance);
    public virtual bool TryBinaryOperation(T instance, BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(T instance, ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(T instance, CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryDeleteIndex(T instance, DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryDeleteMember(T instance, DeleteMemberBinder binder);
    public virtual bool TryGetIndex(T instance, GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(T instance, GetMemberBinder binder, Object& result);
    public virtual bool TryInvoke(T instance, InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(T instance, InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TrySetIndex(T instance, SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(T instance, SetMemberBinder binder, object value);
    public virtual bool TryUnaryOperation(T instance, UnaryOperationBinder binder, Object& result);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1 : DynamicMetaObject {
    private DynamicProxy`1<T> _proxy;
    private static Expression[] NoArgs { get; }
    internal DynamicProxyMetaObject`1(Expression expression, T value, DynamicProxy`1<T> proxy);
    private bool IsOverridden(string method);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    private static Expression[] get_NoArgs();
    private static IEnumerable`1<Expression> GetArgs(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args, DynamicMetaObject value);
    private static ConstantExpression Constant(DynamicMetaObjectBinder binder);
    private DynamicMetaObject CallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, Fallback<T> fallback, Fallback<T> fallbackInvoke);
    private DynamicMetaObject BuildCallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, DynamicMetaObject fallbackResult, Fallback<T> fallbackInvoke);
    private DynamicMetaObject CallMethodReturnLast(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, Fallback<T> fallback);
    private DynamicMetaObject CallMethodNoResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback);
    private BindingRestrictions GetRestrictions();
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.DynamicReflectionDelegateFactory : ReflectionDelegateFactory {
    [CompilerGeneratedAttribute]
private static DynamicReflectionDelegateFactory <Instance>k__BackingField;
    internal static DynamicReflectionDelegateFactory Instance { get; }
    private static DynamicReflectionDelegateFactory();
    [CompilerGeneratedAttribute]
internal static DynamicReflectionDelegateFactory get_Instance();
    private static DynamicMethod CreateDynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private void GenerateCreateMethodCallIL(MethodBase method, ILGenerator generator, int argsIndex);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    private void GenerateCreateDefaultConstructorIL(Type type, ILGenerator generator, Type delegateType);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    internal static void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    internal static void GenerateCreateSetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.DynamicUtils : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDynamicMemberNames(IDynamicMetaObjectProvider dynamicProvider);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.EnumInfo : object {
    public bool IsFlags;
    public UInt64[] Values;
    public String[] Names;
    public String[] ResolvedNames;
    public EnumInfo(bool isFlags, UInt64[] values, String[] names, String[] resolvedNames);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.EnumUtils : object {
    private static char EnumSeparatorChar;
    private static string EnumSeparatorString;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, NamingStrategy>, EnumInfo> ValuesAndNamesPerEnum;
    private static CamelCaseNamingStrategy _camelCaseNamingStrategy;
    private static EnumUtils();
    private static EnumInfo InitializeValuesAndNames(StructMultiKey`2<Type, NamingStrategy> key);
    [Newtonsoft.Json.NullableContextAttribute("0")]
public static IList`1<T> GetFlagsValues(T value);
    public static bool TryToString(Type enumType, object value, bool camelCase, String& name);
    public static bool TryToString(Type enumType, object value, NamingStrategy namingStrategy, String& name);
    private static string InternalFlagsFormat(EnumInfo entry, ulong result);
    public static EnumInfo GetEnumValuesAndNames(Type enumType);
    private static ulong ToUInt64(object value);
    public static object ParseEnum(Type enumType, NamingStrategy namingStrategy, string value, bool disallowNumber);
    private static Nullable`1<int> MatchName(string value, String[] enumNames, String[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison);
    private static Nullable`1<int> FindIndexByName(String[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ExpressionReflectionDelegateFactory : ReflectionDelegateFactory {
    private static ExpressionReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static ExpressionReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private Expression BuildMethodCall(MethodBase method, Type type, ParameterExpression targetParameterExpression, ParameterExpression argsParameterExpression);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    private Expression EnsureCastExpression(Expression expression, Type targetType, bool allowWidening);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.FSharpFunction : object {
    private object _instance;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MethodCall`2<object, object> _invoker;
    public FSharpFunction(object instance, MethodCall`2<object, object> invoker);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public object Invoke(Object[] args);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.FSharpUtils : object {
    private static object Lock;
    [Newtonsoft.Json.NullableAttribute("2")]
private static FSharpUtils _instance;
    private MethodInfo _ofSeq;
    private Type _mapType;
    [CompilerGeneratedAttribute]
private Assembly <FSharpCoreAssembly>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <IsUnion>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <GetUnionCases>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionTagReader>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionReader>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoDeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoTag>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <GetUnionCaseInfoFields>k__BackingField;
    public static string FSharpSetTypeName;
    public static string FSharpListTypeName;
    public static string FSharpMapTypeName;
    public static FSharpUtils Instance { get; }
    public Assembly FSharpCoreAssembly { get; private set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> IsUnion { get; private set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> GetUnionCases { get; private set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionTagReader { get; private set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionReader { get; private set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionConstructor { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoDeclaringType { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoName { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoTag { get; private set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> GetUnionCaseInfoFields { get; private set; }
    private FSharpUtils(Assembly fsharpCoreAssembly);
    private static FSharpUtils();
    public static FSharpUtils get_Instance();
    [CompilerGeneratedAttribute]
public Assembly get_FSharpCoreAssembly();
    [CompilerGeneratedAttribute]
private void set_FSharpCoreAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_IsUnion();
    [CompilerGeneratedAttribute]
private void set_IsUnion(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_GetUnionCases();
    [CompilerGeneratedAttribute]
private void set_GetUnionCases(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionTagReader();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionTagReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionReader();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionConstructor();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionConstructor(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoDeclaringType();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoDeclaringType(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoName();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoName(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoTag();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoTag(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_GetUnionCaseInfoFields();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoFields(MethodCall`2<object, object> value);
    public static void EnsureInitialized(Assembly fsharpCoreAssembly);
    private static MethodInfo GetMethodWithNonPublicFallback(Type type, string methodName, BindingFlags bindingFlags);
    private static MethodCall`2<object, object> CreateFSharpFuncCall(Type type, string methodName);
    public ObjectConstructor`1<object> CreateSeq(Type t);
    public ObjectConstructor`1<object> CreateMap(Type keyType, Type valueType);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public ObjectConstructor`1<object> BuildMapCreator();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void PushInstance(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void PushArrayInstance(ILGenerator generator, int argsIndex, int arrayIndex);
    [ExtensionAttribute]
public static void BoxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void UnboxIfNeeded(ILGenerator generator, Type type);
    [ExtensionAttribute]
public static void CallMethod(ILGenerator generator, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void Return(ILGenerator generator);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.ImmutableCollectionsUtils : object {
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> ArrayContractImmutableCollectionDefinitions;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> DictionaryContractImmutableCollectionDefinitions;
    private static ImmutableCollectionsUtils();
    internal static bool TryBuildImmutableForArrayContract(Type underlyingType, Type collectionItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
    internal static bool TryBuildImmutableForDictionaryContract(Type underlyingType, Type keyItemType, Type valueItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
}
internal interface Newtonsoft.Json.Utilities.IWrappedCollection {
    [Newtonsoft.Json.NullableAttribute("1")]
public object UnderlyingCollection { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public abstract virtual object get_UnderlyingCollection();
}
internal interface Newtonsoft.Json.Utilities.IWrappedDictionary {
    [Newtonsoft.Json.NullableAttribute("1")]
public object UnderlyingDictionary { get; }
    [Newtonsoft.Json.NullableContextAttribute("1")]
public abstract virtual object get_UnderlyingDictionary();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.JavaScriptUtils : object {
    internal static Boolean[] SingleQuoteCharEscapeFlags;
    internal static Boolean[] DoubleQuoteCharEscapeFlags;
    internal static Boolean[] HtmlCharEscapeFlags;
    private static int UnicodeTextLength;
    private static string EscapedUnicodeText;
    private static JavaScriptUtils();
    public static Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar);
    public static bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool`1<char> bufferPool, Char[]& writeBuffer);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling);
    private static int FirstCharToEscape(string s, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling);
    public static Task WriteEscapedJavaScriptStringAsync(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(TextWriter writer, string s, char delimiter, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteEscapedJavaScriptStringWithDelimitersAsync>d__13")]
private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(Task task, TextWriter writer, string s, char delimiter, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteCharAsync>d__14")]
public static Task WriteCharAsync(Task task, TextWriter writer, char c, CancellationToken cancellationToken);
    private static Task WriteEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Newtonsoft.Json.Utilities.JavaScriptUtils/<WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync>d__16")]
private static Task WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, int lastWritePosition, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    public static bool TryGetDateFromConstructorJson(JsonReader reader, DateTime& dateTime, String& errorMessage);
    private static bool TryGetDateConstructorValue(JsonReader reader, Nullable`1& integer, String& errorMessage);
}
internal static class Newtonsoft.Json.Utilities.JsonTokenUtils : object {
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    private static LateBoundReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
internal static class Newtonsoft.Json.Utilities.MathUtils : object {
    public static int IntLength(ulong i);
    public static char IntToHex(int n);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
    public static bool ApproxEquals(double d1, double d2);
}
internal class Newtonsoft.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal static class Newtonsoft.Json.Utilities.MiscellaneousUtils : object {
    [Newtonsoft.Json.NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static bool ValueEquals(object objA, object objB);
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
    internal static RegexOptions GetRegexOptions(string optionsText);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowExpressionVisitor : ExpressionVisitor {
    internal static object ErrorResult;
    private static NoThrowExpressionVisitor();
    protected virtual Expression VisitConditional(ConditionalExpression node);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowGetBinderMember : GetMemberBinder {
    private GetMemberBinder _innerBinder;
    public NoThrowGetBinderMember(GetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.NoThrowSetBinderMember : SetMemberBinder {
    private SetMemberBinder _innerBinder;
    public NoThrowSetBinderMember(SetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal enum Newtonsoft.Json.Utilities.ParseResult : Enum {
    public int value__;
    public static ParseResult None;
    public static ParseResult Success;
    public static ParseResult Overflow;
    public static ParseResult Invalid;
}
internal enum Newtonsoft.Json.Utilities.ParserTimeZone : Enum {
    public int value__;
    public static ParserTimeZone Unspecified;
    public static ParserTimeZone Utc;
    public static ParserTimeZone LocalWestOfUtc;
    public static ParserTimeZone LocalEastOfUtc;
}
internal enum Newtonsoft.Json.Utilities.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal abstract class Newtonsoft.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ReflectionMember : object {
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<object, object> <Getter>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <Setter>k__BackingField;
    public Type MemberType { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> Getter { get; public set; }
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> Setter { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Action`2<object, object> value);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ReflectionObject : object {
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField;
    [Newtonsoft.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> Creator { get; }
    public IDictionary`2<string, ReflectionMember> Members { get; }
    private ReflectionObject(ObjectConstructor`1<object> creator);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_Creator();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ReflectionMember> get_Members();
    public object GetValue(object target, string member);
    public void SetValue(object target, string member, object value);
    public Type GetType(string member);
    public static ReflectionObject Create(Type t, String[] memberNames);
    public static ReflectionObject Create(Type t, MethodBase creator, String[] memberNames);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.ReflectionUtils : object {
    public static Type[] EmptyTypes;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetBaseDefinition(PropertyInfo propertyInfo);
    public static bool IsPublic(PropertyInfo property);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, TypeNameAssemblyFormatHandling assemblyFormat, ISerializationBinder binder);
    private static string GetFullyQualifiedTypeName(Type t, ISerializationBinder binder);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static Type EnsureNotNullableType(Type t);
    public static Type EnsureNotByRefType(Type t);
    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type type, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsByRefLikeType(Type type);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit);
    public static StructMultiKey`2<string, string> SplitFullyQualifiedTypeName(string fullyQualifiedTypeName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type type, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type type, BindingFlags bindingAttr);
    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method);
    public static object GetDefaultValue(Type type);
}
[Newtonsoft.Json.NullableContextAttribute("2")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.StringBuffer : ValueType {
    private Char[] _buffer;
    private int _position;
    public int Position { get; public set; }
    public bool IsEmpty { get; }
    public Char[] InternalBuffer { get; }
    public StringBuffer(IArrayPool`1<char> bufferPool, int initalSize);
    [Newtonsoft.Json.NullableContextAttribute("1")]
private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(IArrayPool`1<char> bufferPool, char value);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public void Append(IArrayPool`1<char> bufferPool, Char[] buffer, int startIndex, int count);
    public void Clear(IArrayPool`1<char> bufferPool);
    private void EnsureSize(IArrayPool`1<char> bufferPool, int appendLength);
    [Newtonsoft.Json.NullableContextAttribute("1")]
public virtual string ToString();
    [Newtonsoft.Json.NullableContextAttribute("1")]
public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[Newtonsoft.Json.IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Newtonsoft.Json.Utilities.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public char Item { get; }
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public char get_Item(int i);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringReferenceExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(StringReference s, char c, int startIndex, int length);
    [ExtensionAttribute]
public static bool StartsWith(StringReference s, string text);
    [ExtensionAttribute]
public static bool EndsWith(StringReference s, string text);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.StringUtils : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    [Newtonsoft.Json.NullableContextAttribute("2")]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [Newtonsoft.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
private static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool IsWhiteSpace(string s);
    public static StringWriter CreateStringWriter(int capacity);
    public static void ToCharAsUnicode(char c, Char[] buffer);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
    public static string ToCamelCase(string s);
    private static char ToLower(char c);
    public static string ToSnakeCase(string s);
    public static string ToKebabCase(string s);
    private static string ToSeparatedCase(string s, char separator);
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
    public static int IndexOf(string s, char c);
    public static string Replace(string s, string oldValue, string newValue);
    [ExtensionAttribute]
public static bool StartsWith(string source, char value);
    [ExtensionAttribute]
public static bool EndsWith(string source, char value);
    [ExtensionAttribute]
public static string Trim(string s, int start, int length);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[Newtonsoft.Json.IsReadOnlyAttribute]
internal class Newtonsoft.Json.Utilities.StructMultiKey`2 : ValueType {
    public T1 Value1;
    public T2 Value2;
    public StructMultiKey`2(T1 v1, T2 v2);
    public virtual int GetHashCode();
    [Newtonsoft.Json.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StructMultiKey`2<T1, T2> other);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.ThreadSafeStore`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> _concurrentStore;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class Newtonsoft.Json.Utilities.TypeExtensions : object {
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces);
    [ExtensionAttribute]
public static bool ImplementInterface(Type type, Type interfaceType);
}
[Newtonsoft.Json.NullableContextAttribute("1")]
[Newtonsoft.Json.NullableAttribute("0")]
internal class Newtonsoft.Json.Utilities.TypeInformation : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    public Type Type { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public TypeInformation(Type type, PrimitiveTypeCode typeCode);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public PrimitiveTypeCode get_TypeCode();
}
internal static class Newtonsoft.Json.Utilities.ValidationUtils : object {
    [Newtonsoft.Json.NullableContextAttribute("1")]
public static void ArgumentNotNull(object value, string parameterName);
}
internal enum Newtonsoft.Json.WriteState : Enum {
    public int value__;
    public static WriteState Error;
    public static WriteState Closed;
    public static WriteState Object;
    public static WriteState Array;
    public static WriteState Constructor;
    public static WriteState Property;
    public static WriteState Start;
}
public class NuGet.Build.MSBuildLogger : LoggerBase {
    private TaskLoggingHelper _taskLogging;
    public MSBuildLogger(TaskLoggingHelper taskLogging);
    public virtual void Log(ILogMessage message);
    private void LogForNonMono(INuGetLogMessage message);
    private void LogForMono(ILogMessage message);
    private void LogMessage(INuGetLogMessage logMessage, MessageImportance importance, LogMessageWithDetails logWithDetails, LogMessageAsString logAsString);
    private void LogError(INuGetLogMessage logMessage, LogErrorWithDetails logWithDetails, LogErrorAsString logAsString);
    public virtual Task LogAsync(ILogMessage message);
}
public class NuGet.Build.Tasks.GetProjectTargetFrameworksTask : Task {
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformMinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectTargetFrameworks>k__BackingField;
    [RequiredAttribute]
public string ProjectPath { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    public string TargetPlatformIdentifier { get; public set; }
    public string TargetPlatformMinVersion { get; public set; }
    public string TargetPlatformVersion { get; public set; }
    public string TargetFrameworks { get; public set; }
    public string TargetFramework { get; public set; }
    [OutputAttribute]
public string ProjectTargetFrameworks { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMoniker(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformMinVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformMinVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectTargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_ProjectTargetFrameworks(string value);
    public virtual bool Execute();
}
public class NuGet.Build.Tasks.Pack.GetPackOutputItemsTask : Task {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SymbolPackageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OutputPackItems>k__BackingField;
    [RequiredAttribute]
public string PackageId { get; public set; }
    [RequiredAttribute]
public string PackageVersion { get; public set; }
    [RequiredAttribute]
public string PackageOutputPath { get; public set; }
    [RequiredAttribute]
public string NuspecOutputPath { get; public set; }
    public bool IncludeSymbols { get; public set; }
    public bool IncludeSource { get; public set; }
    public string SymbolPackageFormat { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputPackItems { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
    [CompilerGeneratedAttribute]
public void set_PackageVersion(string value);
    [CompilerGeneratedAttribute]
public string get_PackageOutputPath();
    [CompilerGeneratedAttribute]
public void set_PackageOutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_NuspecOutputPath();
    [CompilerGeneratedAttribute]
public void set_NuspecOutputPath(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSymbols();
    [CompilerGeneratedAttribute]
public void set_IncludeSymbols(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeSource();
    [CompilerGeneratedAttribute]
public void set_IncludeSource(bool value);
    [CompilerGeneratedAttribute]
public string get_SymbolPackageFormat();
    [CompilerGeneratedAttribute]
public void set_SymbolPackageFormat(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OutputPackItems();
    [CompilerGeneratedAttribute]
public void set_OutputPackItems(ITaskItem[] value);
    public virtual bool Execute();
}
public class NuGet.Build.Tasks.Pack.GetProjectReferencesFromAssetsFileTask : Task {
    [CompilerGeneratedAttribute]
private string <RestoreOutputAbsolutePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectAssetsFileAbsolutePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ProjectReferences>k__BackingField;
    public string RestoreOutputAbsolutePath { get; public set; }
    public string ProjectAssetsFileAbsolutePath { get; public set; }
    [OutputAttribute]
public ITaskItem[] ProjectReferences { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RestoreOutputAbsolutePath();
    [CompilerGeneratedAttribute]
public void set_RestoreOutputAbsolutePath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectAssetsFileAbsolutePath();
    [CompilerGeneratedAttribute]
public void set_ProjectAssetsFileAbsolutePath(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ProjectReferences(ITaskItem[] value);
    public virtual bool Execute();
}
public interface NuGet.Build.Tasks.Pack.IPackTaskLogic {
    public abstract virtual PackArgs GetPackArgs(IPackTaskRequest`1<IMSBuildItem> request);
    public abstract virtual PackageBuilder GetPackageBuilder(IPackTaskRequest`1<IMSBuildItem> request);
    public abstract virtual PackCommandRunner GetPackCommandRunner(IPackTaskRequest`1<IMSBuildItem> request, PackArgs packArgs, PackageBuilder packageBuilder);
    public abstract virtual bool BuildPackage(PackCommandRunner runner);
}
public interface NuGet.Build.Tasks.Pack.IPackTaskRequest`1 {
    public String[] AllowedOutputExtensionsInPackageBuildOutputFolder { get; }
    public String[] AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder { get; }
    public string AssemblyName { get; }
    public String[] Authors { get; }
    public TItem[] BuildOutputInPackage { get; }
    public String[] BuildOutputFolders { get; }
    public String[] ContentTargetFolders { get; }
    public bool ContinuePackingAfterGeneratingNuspec { get; }
    public string Copyright { get; }
    public string Description { get; }
    public bool DevelopmentDependency { get; }
    public TItem[] FrameworkAssemblyReferences { get; }
    public TItem[] FrameworksWithSuppressedDependencies { get; }
    public string IconUrl { get; }
    public bool IncludeBuildOutput { get; }
    public bool IncludeSource { get; }
    public bool IncludeSymbols { get; }
    public bool InstallPackageToOutputPath { get; }
    public bool IsTool { get; }
    public string LicenseUrl { get; }
    public ILogger Logger { get; }
    public string MinClientVersion { get; }
    public bool NoDefaultExcludes { get; }
    public bool NoPackageAnalysis { get; }
    public string NoWarn { get; }
    public string NuspecBasePath { get; }
    public string NuspecFile { get; }
    public String[] NuspecProperties { get; }
    public string NuspecOutputPath { get; }
    public bool OutputFileNamesWithoutVersion { get; }
    public TItem[] PackageFiles { get; }
    public TItem[] PackageFilesToExclude { get; }
    public string PackageId { get; }
    public string PackageOutputPath { get; }
    public String[] PackageTypes { get; }
    public string PackageVersion { get; }
    public TItem PackItem { get; }
    public TItem[] ProjectReferencesWithVersions { get; }
    public string ProjectUrl { get; }
    public string ReleaseNotes { get; }
    public string RepositoryType { get; }
    public string RepositoryUrl { get; }
    public string RepositoryBranch { get; }
    public string RepositoryCommit { get; }
    public bool RequireLicenseAcceptance { get; }
    public string RestoreOutputPath { get; }
    public bool Serviceable { get; }
    public TItem[] SourceFiles { get; }
    public string SymbolPackageFormat { get; }
    public String[] Tags { get; }
    public String[] TargetFrameworks { get; }
    public TItem[] TargetPathsToSymbols { get; }
    public string Title { get; }
    public string TreatWarningsAsErrors { get; }
    public string WarningsAsErrors { get; }
    public string WarningsNotAsErrors { get; }
    public string PackageLicenseExpression { get; }
    public string PackageLicenseExpressionVersion { get; }
    public string PackageLicenseFile { get; }
    public string Readme { get; }
    public bool Deterministic { get; }
    public string PackageIcon { get; }
    public abstract virtual String[] get_AllowedOutputExtensionsInPackageBuildOutputFolder();
    public abstract virtual String[] get_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder();
    public abstract virtual string get_AssemblyName();
    public abstract virtual String[] get_Authors();
    public abstract virtual TItem[] get_BuildOutputInPackage();
    public abstract virtual String[] get_BuildOutputFolders();
    public abstract virtual String[] get_ContentTargetFolders();
    public abstract virtual bool get_ContinuePackingAfterGeneratingNuspec();
    public abstract virtual string get_Copyright();
    public abstract virtual string get_Description();
    public abstract virtual bool get_DevelopmentDependency();
    public abstract virtual TItem[] get_FrameworkAssemblyReferences();
    public abstract virtual TItem[] get_FrameworksWithSuppressedDependencies();
    public abstract virtual string get_IconUrl();
    public abstract virtual bool get_IncludeBuildOutput();
    public abstract virtual bool get_IncludeSource();
    public abstract virtual bool get_IncludeSymbols();
    public abstract virtual bool get_InstallPackageToOutputPath();
    public abstract virtual bool get_IsTool();
    public abstract virtual string get_LicenseUrl();
    public abstract virtual ILogger get_Logger();
    public abstract virtual string get_MinClientVersion();
    public abstract virtual bool get_NoDefaultExcludes();
    public abstract virtual bool get_NoPackageAnalysis();
    public abstract virtual string get_NoWarn();
    public abstract virtual string get_NuspecBasePath();
    public abstract virtual string get_NuspecFile();
    public abstract virtual String[] get_NuspecProperties();
    public abstract virtual string get_NuspecOutputPath();
    public abstract virtual bool get_OutputFileNamesWithoutVersion();
    public abstract virtual TItem[] get_PackageFiles();
    public abstract virtual TItem[] get_PackageFilesToExclude();
    public abstract virtual string get_PackageId();
    public abstract virtual string get_PackageOutputPath();
    public abstract virtual String[] get_PackageTypes();
    public abstract virtual string get_PackageVersion();
    public abstract virtual TItem get_PackItem();
    public abstract virtual TItem[] get_ProjectReferencesWithVersions();
    public abstract virtual string get_ProjectUrl();
    public abstract virtual string get_ReleaseNotes();
    public abstract virtual string get_RepositoryType();
    public abstract virtual string get_RepositoryUrl();
    public abstract virtual string get_RepositoryBranch();
    public abstract virtual string get_RepositoryCommit();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual string get_RestoreOutputPath();
    public abstract virtual bool get_Serviceable();
    public abstract virtual TItem[] get_SourceFiles();
    public abstract virtual string get_SymbolPackageFormat();
    public abstract virtual String[] get_Tags();
    public abstract virtual String[] get_TargetFrameworks();
    public abstract virtual TItem[] get_TargetPathsToSymbols();
    public abstract virtual string get_Title();
    public abstract virtual string get_TreatWarningsAsErrors();
    public abstract virtual string get_WarningsAsErrors();
    public abstract virtual string get_WarningsNotAsErrors();
    public abstract virtual string get_PackageLicenseExpression();
    public abstract virtual string get_PackageLicenseExpressionVersion();
    public abstract virtual string get_PackageLicenseFile();
    public abstract virtual string get_Readme();
    public abstract virtual bool get_Deterministic();
    public abstract virtual string get_PackageIcon();
}
public class NuGet.Build.Tasks.Pack.IsPackableFalseWarningTask : Task {
    public ILogger Logger { get; }
    public ILogger get_Logger();
    public virtual bool Execute();
}
public class NuGet.Build.Tasks.Pack.MSBuildTaskItem : object {
    [CompilerGeneratedAttribute]
private ITaskItem <Item>k__BackingField;
    public ITaskItem Item { get; }
    public string Identity { get; }
    public IReadOnlyList`1<string> Properties { get; }
    public MSBuildTaskItem(ITaskItem item);
    [CompilerGeneratedAttribute]
public ITaskItem get_Item();
    public sealed virtual string get_Identity();
    public sealed virtual IReadOnlyList`1<string> get_Properties();
    public sealed virtual string GetProperty(string property);
    public sealed virtual string GetProperty(string property, bool trim);
    public virtual string ToString();
    public IDictionary CloneCustomMetadata();
}
internal static class NuGet.Build.Tasks.Pack.MSBuildUtility : object {
    public static IMSBuildItem WrapMSBuildItem(ITaskItem item);
    public static IMSBuildItem[] WrapMSBuildItem(IEnumerable`1<ITaskItem> items);
}
public class NuGet.Build.Tasks.Pack.PackTask : Task {
    [CompilerGeneratedAttribute]
private ITaskItem <PackItem>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <PackageFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <PackageFilesToExclude>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <BuildOutputInPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ProjectReferencesWithVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <TargetPathsToSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <FrameworksWithSuppressedDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTool>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstallPackageToOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputFileNamesWithoutVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoPackageAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SymbolPackageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <FrameworkAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContinuePackingAfterGeneratingNuspec>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoDefaultExcludes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeBuildOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BuildOutputFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ContentTargetFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <NuspecProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecBasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AllowedOutputExtensionsInPackageBuildOutputFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TreatWarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WarningsNotAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageLicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageLicenseFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageLicenseExpressionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageIcon>k__BackingField;
    private IPackTaskLogic _packTaskLogic;
    [RequiredAttribute]
public ITaskItem PackItem { get; public set; }
    public ITaskItem[] PackageFiles { get; public set; }
    public ITaskItem[] PackageFilesToExclude { get; public set; }
    public String[] TargetFrameworks { get; public set; }
    public String[] PackageTypes { get; public set; }
    public ITaskItem[] BuildOutputInPackage { get; public set; }
    public ITaskItem[] ProjectReferencesWithVersions { get; public set; }
    public string PackageId { get; public set; }
    public string PackageVersion { get; public set; }
    public string Title { get; public set; }
    public String[] Authors { get; public set; }
    public string Description { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Copyright { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public string RestoreOutputPath { get; public set; }
    public string LicenseUrl { get; public set; }
    public string ProjectUrl { get; public set; }
    public string IconUrl { get; public set; }
    public String[] Tags { get; public set; }
    public string ReleaseNotes { get; public set; }
    public ITaskItem[] TargetPathsToSymbols { get; public set; }
    public ITaskItem[] FrameworksWithSuppressedDependencies { get; public set; }
    public string AssemblyName { get; public set; }
    public string PackageOutputPath { get; public set; }
    public bool IsTool { get; public set; }
    public bool IncludeSymbols { get; public set; }
    public bool IncludeSource { get; public set; }
    public bool InstallPackageToOutputPath { get; public set; }
    public bool OutputFileNamesWithoutVersion { get; public set; }
    public string RepositoryUrl { get; public set; }
    public string RepositoryType { get; public set; }
    public string RepositoryBranch { get; public set; }
    public string RepositoryCommit { get; public set; }
    public ITaskItem[] SourceFiles { get; public set; }
    public bool NoPackageAnalysis { get; public set; }
    public string NuspecFile { get; public set; }
    public string SymbolPackageFormat { get; public set; }
    public string MinClientVersion { get; public set; }
    public bool Serviceable { get; public set; }
    public ITaskItem[] FrameworkAssemblyReferences { get; public set; }
    public bool ContinuePackingAfterGeneratingNuspec { get; public set; }
    public bool NoDefaultExcludes { get; public set; }
    public string NuspecOutputPath { get; public set; }
    public bool IncludeBuildOutput { get; public set; }
    public String[] BuildOutputFolders { get; public set; }
    public String[] ContentTargetFolders { get; public set; }
    public String[] NuspecProperties { get; public set; }
    public string NuspecBasePath { get; public set; }
    public String[] AllowedOutputExtensionsInPackageBuildOutputFolder { get; public set; }
    public String[] AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder { get; public set; }
    public string NoWarn { get; public set; }
    public string TreatWarningsAsErrors { get; public set; }
    public string WarningsAsErrors { get; public set; }
    public string WarningsNotAsErrors { get; public set; }
    public string PackageLicenseExpression { get; public set; }
    public string PackageLicenseFile { get; public set; }
    public string PackageLicenseExpressionVersion { get; public set; }
    public string Readme { get; public set; }
    public bool Deterministic { get; public set; }
    public string PackageIcon { get; public set; }
    public ILogger Logger { get; }
    public IPackTaskLogic PackTaskLogic { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem get_PackItem();
    [CompilerGeneratedAttribute]
public void set_PackItem(ITaskItem value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_PackageFiles();
    [CompilerGeneratedAttribute]
public void set_PackageFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_PackageFilesToExclude();
    [CompilerGeneratedAttribute]
public void set_PackageFilesToExclude(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_BuildOutputInPackage();
    [CompilerGeneratedAttribute]
public void set_BuildOutputInPackage(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_ProjectReferencesWithVersions();
    [CompilerGeneratedAttribute]
public void set_ProjectReferencesWithVersions(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageId();
    [CompilerGeneratedAttribute]
public void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageVersion();
    [CompilerGeneratedAttribute]
public void set_PackageVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RestoreOutputPath();
    [CompilerGeneratedAttribute]
public void set_RestoreOutputPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_TargetPathsToSymbols();
    [CompilerGeneratedAttribute]
public void set_TargetPathsToSymbols(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_FrameworksWithSuppressedDependencies();
    [CompilerGeneratedAttribute]
public void set_FrameworksWithSuppressedDependencies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageOutputPath();
    [CompilerGeneratedAttribute]
public void set_PackageOutputPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTool();
    [CompilerGeneratedAttribute]
public void set_IsTool(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeSymbols();
    [CompilerGeneratedAttribute]
public void set_IncludeSymbols(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeSource();
    [CompilerGeneratedAttribute]
public void set_IncludeSource(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InstallPackageToOutputPath();
    [CompilerGeneratedAttribute]
public void set_InstallPackageToOutputPath(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_OutputFileNamesWithoutVersion();
    [CompilerGeneratedAttribute]
public void set_OutputFileNamesWithoutVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RepositoryUrl();
    [CompilerGeneratedAttribute]
public void set_RepositoryUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RepositoryType();
    [CompilerGeneratedAttribute]
public void set_RepositoryType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RepositoryBranch();
    [CompilerGeneratedAttribute]
public void set_RepositoryBranch(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RepositoryCommit();
    [CompilerGeneratedAttribute]
public void set_RepositoryCommit(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoPackageAnalysis();
    [CompilerGeneratedAttribute]
public void set_NoPackageAnalysis(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NuspecFile();
    [CompilerGeneratedAttribute]
public void set_NuspecFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SymbolPackageFormat();
    [CompilerGeneratedAttribute]
public void set_SymbolPackageFormat(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_FrameworkAssemblyReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkAssemblyReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ContinuePackingAfterGeneratingNuspec();
    [CompilerGeneratedAttribute]
public void set_ContinuePackingAfterGeneratingNuspec(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoDefaultExcludes();
    [CompilerGeneratedAttribute]
public void set_NoDefaultExcludes(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NuspecOutputPath();
    [CompilerGeneratedAttribute]
public void set_NuspecOutputPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeBuildOutput();
    [CompilerGeneratedAttribute]
public void set_IncludeBuildOutput(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_BuildOutputFolders();
    [CompilerGeneratedAttribute]
public void set_BuildOutputFolders(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ContentTargetFolders();
    [CompilerGeneratedAttribute]
public void set_ContentTargetFolders(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_NuspecProperties();
    [CompilerGeneratedAttribute]
public void set_NuspecProperties(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NuspecBasePath();
    [CompilerGeneratedAttribute]
public void set_NuspecBasePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_AllowedOutputExtensionsInPackageBuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_AllowedOutputExtensionsInPackageBuildOutputFolder(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NoWarn();
    [CompilerGeneratedAttribute]
public void set_NoWarn(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TreatWarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_TreatWarningsAsErrors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_WarningsNotAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsNotAsErrors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageLicenseExpression();
    [CompilerGeneratedAttribute]
public void set_PackageLicenseExpression(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageLicenseFile();
    [CompilerGeneratedAttribute]
public void set_PackageLicenseFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageLicenseExpressionVersion();
    [CompilerGeneratedAttribute]
public void set_PackageLicenseExpressionVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Deterministic();
    [CompilerGeneratedAttribute]
public void set_Deterministic(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageIcon();
    [CompilerGeneratedAttribute]
public void set_PackageIcon(string value);
    public sealed virtual ILogger get_Logger();
    public IPackTaskLogic get_PackTaskLogic();
    public void set_PackTaskLogic(IPackTaskLogic value);
    public virtual bool Execute();
    private IPackTaskRequest`1<IMSBuildItem> GetRequest();
}
public class NuGet.Build.Tasks.Pack.PackTaskLogic : object {
    private static string IdentityProperty;
    private PackageSpecificWarningProperties _packageSpecificWarningProperties;
    public sealed virtual PackArgs GetPackArgs(IPackTaskRequest`1<IMSBuildItem> request);
    public sealed virtual PackageBuilder GetPackageBuilder(IPackTaskRequest`1<IMSBuildItem> request);
    private LicenseMetadata BuildLicenseMetadata(IPackTaskRequest`1<IMSBuildItem> request);
    private static Version GetLicenseExpressionVersion(IPackTaskRequest`1<IMSBuildItem> request);
    private LockFile GetAssetsFile(IPackTaskRequest`1<IMSBuildItem> request);
    private void PopulateFrameworkAssemblyReferences(PackageBuilder builder, IPackTaskRequest`1<IMSBuildItem> request);
    private void PopulateFrameworkReferences(PackageBuilder builder, LockFile assetsFile);
    public sealed virtual PackCommandRunner GetPackCommandRunner(IPackTaskRequest`1<IMSBuildItem> request, PackArgs packArgs, PackageBuilder packageBuilder);
    public sealed virtual bool BuildPackage(PackCommandRunner runner);
    private IEnumerable`1<OutputLibFile> InitLibFiles(IMSBuildItem[] libFiles, IDictionary`2<string, string> aliases);
    private ISet`1<NuGetFramework> ParseFrameworks(IPackTaskRequest`1<IMSBuildItem> request, IDictionary`2<string, string> aliases);
    private ICollection`1<PackageType> ParsePackageTypes(IPackTaskRequest`1<IMSBuildItem> request);
    private void InitCurrentDirectoryAndFileName(IPackTaskRequest`1<IMSBuildItem> request, PackArgs packArgs);
    private void InitNuspecOutputPath(IPackTaskRequest`1<IMSBuildItem> request, PackArgs packArgs);
    private Dictionary`2<string, IEnumerable`1<ContentMetadata>> ProcessContentToIncludeInPackage(IPackTaskRequest`1<IMSBuildItem> request, PackArgs packArgs);
    private IEnumerable`1<ContentMetadata> GetContentMetadata(IMSBuildItem packageFile, string sourcePath, PackArgs packArgs, String[] contentTargetFolders);
    private string GetSourcePath(IMSBuildItem packageFile);
    private ISet`1<string> CalculateFilesToExcludeInPack(IPackTaskRequest`1<IMSBuildItem> request);
    private IDictionary`2<string, string> GetSourceFiles(IPackTaskRequest`1<IMSBuildItem> request, string currentProjectDirectory);
    private void PopulateProjectAndPackageReferences(PackageBuilder packageBuilder, LockFile assetsFile, IDictionary`2<string, string> projectRefToVersionMap, ISet`1<NuGetFramework> frameworksWithSuppressedDependencies);
    private static void InitializeProjectDependencies(LockFile assetsFile, IDictionary`2<NuGetFramework, HashSet`1<LibraryDependency>> dependenciesByFramework, IDictionary`2<string, string> projectRefToVersionMap, ISet`1<NuGetFramework> frameworkWithSuppressedDependencies);
    private void InitializePackageDependencies(LockFile assetsFile, Dictionary`2<NuGetFramework, HashSet`1<LibraryDependency>> dependenciesByFramework, ISet`1<NuGetFramework> frameworkWithSuppressedDependencies);
    private static IDictionary`2<string, string> ParsePropertiesAsDictionary(String[] properties);
    private HashSet`1<string> InitOutputExtensions(IEnumerable`1<string> outputExtensions);
}
public class NuGet.Build.Tasks.Pack.PackTaskRequest : object {
    [CompilerGeneratedAttribute]
private String[] <AllowedOutputExtensionsInPackageBuildOutputFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem[] <BuildOutputInPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BuildOutputFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ContentTargetFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContinuePackingAfterGeneratingNuspec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem[] <FrameworkAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeBuildOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstallPackageToOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoDefaultExcludes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoPackageAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem[] <PackageFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem[] <PackageFilesToExclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem <PackItem>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem[] <ProjectReferencesWithVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecBasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <NuspecProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputFileNamesWithoutVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryBranch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem[] <TargetPathsToSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TreatWarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WarningsNotAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildItem[] <FrameworksWithSuppressedDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SymbolPackageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageLicenseFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageLicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageLicenseExpressionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageIcon>k__BackingField;
    public String[] AllowedOutputExtensionsInPackageBuildOutputFolder { get; public set; }
    public String[] AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder { get; public set; }
    public string AssemblyName { get; public set; }
    public String[] Authors { get; public set; }
    public IMSBuildItem[] BuildOutputInPackage { get; public set; }
    public String[] BuildOutputFolders { get; public set; }
    public String[] ContentTargetFolders { get; public set; }
    public bool ContinuePackingAfterGeneratingNuspec { get; public set; }
    public string Copyright { get; public set; }
    public string Description { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public IMSBuildItem[] FrameworkAssemblyReferences { get; public set; }
    public string IconUrl { get; public set; }
    public bool IncludeBuildOutput { get; public set; }
    public bool IncludeSource { get; public set; }
    public bool IncludeSymbols { get; public set; }
    public bool InstallPackageToOutputPath { get; public set; }
    public bool IsTool { get; public set; }
    public string LicenseUrl { get; public set; }
    public ILogger Logger { get; public set; }
    public string MinClientVersion { get; public set; }
    public bool NoDefaultExcludes { get; public set; }
    public bool NoPackageAnalysis { get; public set; }
    public string NuspecFile { get; public set; }
    public string NuspecOutputPath { get; public set; }
    public IMSBuildItem[] PackageFiles { get; public set; }
    public IMSBuildItem[] PackageFilesToExclude { get; public set; }
    public string PackageId { get; public set; }
    public string PackageOutputPath { get; public set; }
    public String[] PackageTypes { get; public set; }
    public string PackageVersion { get; public set; }
    public IMSBuildItem PackItem { get; public set; }
    public IMSBuildItem[] ProjectReferencesWithVersions { get; public set; }
    public string ProjectUrl { get; public set; }
    public string NuspecBasePath { get; public set; }
    public String[] NuspecProperties { get; public set; }
    public bool OutputFileNamesWithoutVersion { get; public set; }
    public string Readme { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string RepositoryType { get; public set; }
    public string RepositoryUrl { get; public set; }
    public string RepositoryBranch { get; public set; }
    public string RepositoryCommit { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public string RestoreOutputPath { get; public set; }
    public bool Serviceable { get; public set; }
    public IMSBuildItem[] SourceFiles { get; public set; }
    public String[] Tags { get; public set; }
    public String[] TargetFrameworks { get; public set; }
    public IMSBuildItem[] TargetPathsToSymbols { get; public set; }
    public string Title { get; public set; }
    public string NoWarn { get; public set; }
    public string TreatWarningsAsErrors { get; public set; }
    public string WarningsAsErrors { get; public set; }
    public string WarningsNotAsErrors { get; public set; }
    public IMSBuildItem[] FrameworksWithSuppressedDependencies { get; public set; }
    public string SymbolPackageFormat { get; public set; }
    public string PackageLicenseFile { get; public set; }
    public string PackageLicenseExpression { get; public set; }
    public string PackageLicenseExpressionVersion { get; public set; }
    public bool Deterministic { get; public set; }
    public string PackageIcon { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_AllowedOutputExtensionsInPackageBuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_AllowedOutputExtensionsInPackageBuildOutputFolder(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem[] get_BuildOutputInPackage();
    [CompilerGeneratedAttribute]
public void set_BuildOutputInPackage(IMSBuildItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_BuildOutputFolders();
    [CompilerGeneratedAttribute]
public void set_BuildOutputFolders(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ContentTargetFolders();
    [CompilerGeneratedAttribute]
public void set_ContentTargetFolders(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ContinuePackingAfterGeneratingNuspec();
    [CompilerGeneratedAttribute]
public void set_ContinuePackingAfterGeneratingNuspec(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem[] get_FrameworkAssemblyReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkAssemblyReferences(IMSBuildItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeBuildOutput();
    [CompilerGeneratedAttribute]
public void set_IncludeBuildOutput(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeSource();
    [CompilerGeneratedAttribute]
public void set_IncludeSource(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeSymbols();
    [CompilerGeneratedAttribute]
public void set_IncludeSymbols(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InstallPackageToOutputPath();
    [CompilerGeneratedAttribute]
public void set_InstallPackageToOutputPath(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTool();
    [CompilerGeneratedAttribute]
public void set_IsTool(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoDefaultExcludes();
    [CompilerGeneratedAttribute]
public void set_NoDefaultExcludes(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoPackageAnalysis();
    [CompilerGeneratedAttribute]
public void set_NoPackageAnalysis(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NuspecFile();
    [CompilerGeneratedAttribute]
public void set_NuspecFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NuspecOutputPath();
    [CompilerGeneratedAttribute]
public void set_NuspecOutputPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem[] get_PackageFiles();
    [CompilerGeneratedAttribute]
public void set_PackageFiles(IMSBuildItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem[] get_PackageFilesToExclude();
    [CompilerGeneratedAttribute]
public void set_PackageFilesToExclude(IMSBuildItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageId();
    [CompilerGeneratedAttribute]
public void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageOutputPath();
    [CompilerGeneratedAttribute]
public void set_PackageOutputPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageVersion();
    [CompilerGeneratedAttribute]
public void set_PackageVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem get_PackItem();
    [CompilerGeneratedAttribute]
public void set_PackItem(IMSBuildItem value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem[] get_ProjectReferencesWithVersions();
    [CompilerGeneratedAttribute]
public void set_ProjectReferencesWithVersions(IMSBuildItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NuspecBasePath();
    [CompilerGeneratedAttribute]
public void set_NuspecBasePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_NuspecProperties();
    [CompilerGeneratedAttribute]
public void set_NuspecProperties(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_OutputFileNamesWithoutVersion();
    [CompilerGeneratedAttribute]
public void set_OutputFileNamesWithoutVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RepositoryType();
    [CompilerGeneratedAttribute]
public void set_RepositoryType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RepositoryUrl();
    [CompilerGeneratedAttribute]
public void set_RepositoryUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RepositoryBranch();
    [CompilerGeneratedAttribute]
public void set_RepositoryBranch(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RepositoryCommit();
    [CompilerGeneratedAttribute]
public void set_RepositoryCommit(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RestoreOutputPath();
    [CompilerGeneratedAttribute]
public void set_RestoreOutputPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(IMSBuildItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem[] get_TargetPathsToSymbols();
    [CompilerGeneratedAttribute]
public void set_TargetPathsToSymbols(IMSBuildItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_NoWarn();
    [CompilerGeneratedAttribute]
public void set_NoWarn(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TreatWarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_TreatWarningsAsErrors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_WarningsNotAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsNotAsErrors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IMSBuildItem[] get_FrameworksWithSuppressedDependencies();
    [CompilerGeneratedAttribute]
public void set_FrameworksWithSuppressedDependencies(IMSBuildItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SymbolPackageFormat();
    [CompilerGeneratedAttribute]
public void set_SymbolPackageFormat(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageLicenseFile();
    [CompilerGeneratedAttribute]
public void set_PackageLicenseFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageLicenseExpression();
    [CompilerGeneratedAttribute]
public void set_PackageLicenseExpression(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageLicenseExpressionVersion();
    [CompilerGeneratedAttribute]
public void set_PackageLicenseExpressionVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Deterministic();
    [CompilerGeneratedAttribute]
public void set_Deterministic(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageIcon();
    [CompilerGeneratedAttribute]
public void set_PackageIcon(string value);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Build.Tasks.Pack.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AssetsFileDoesNotHaveValidPackageSpec { get; }
    internal static string AssetsFileNotFound { get; }
    internal static string Error_FileNotFound { get; }
    internal static string InvalidLicenseCombination { get; }
    internal static string InvalidLicenseExppressionVersion_VersionTooHigh { get; }
    internal static string InvalidLicenseExpression { get; }
    internal static string InvalidLicenseExpressionVersion { get; }
    internal static string InvalidMinClientVersion { get; }
    internal static string InvalidNuspecProperties { get; }
    internal static string InvalidPackageReferenceVersion { get; }
    internal static string InvalidPackageVersion { get; }
    internal static string InvalidTargetFramework { get; }
    internal static string IsPackableFalseError { get; }
    internal static string NoPackItemProvided { get; }
    internal static string NuGetLicenses_LicenseUrlCannotBeUsedInConjuctionWithLicense { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AssetsFileDoesNotHaveValidPackageSpec();
    internal static string get_AssetsFileNotFound();
    internal static string get_Error_FileNotFound();
    internal static string get_InvalidLicenseCombination();
    internal static string get_InvalidLicenseExppressionVersion_VersionTooHigh();
    internal static string get_InvalidLicenseExpression();
    internal static string get_InvalidLicenseExpressionVersion();
    internal static string get_InvalidMinClientVersion();
    internal static string get_InvalidNuspecProperties();
    internal static string get_InvalidPackageReferenceVersion();
    internal static string get_InvalidPackageVersion();
    internal static string get_InvalidTargetFramework();
    internal static string get_IsPackableFalseError();
    internal static string get_NoPackItemProvided();
    internal static string get_NuGetLicenses_LicenseUrlCannotBeUsedInConjuctionWithLicense();
}
internal class NuGet.Client.AnyFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private static AnyFramework <Instance>k__BackingField;
    internal static AnyFramework Instance { get; }
    private static AnyFramework();
    [CompilerGeneratedAttribute]
internal static AnyFramework get_Instance();
}
internal class NuGet.Client.ManagedCodeConventions : object {
    private static ContentPropertyDefinition LocaleProperty;
    private static ContentPropertyDefinition AnyProperty;
    private static ContentPropertyDefinition AssemblyProperty;
    private static ContentPropertyDefinition MSBuildProperty;
    private static ContentPropertyDefinition SatelliteAssemblyProperty;
    private static ContentPropertyDefinition CodeLanguageProperty;
    private static Dictionary`2<string, object> NetTFMTable;
    private static Dictionary`2<string, object> DefaultTfmAny;
    private static PatternTable DotnetAnyTable;
    private static PatternTable AnyTable;
    private static FrameworkReducer FrameworkReducer;
    private RuntimeGraph _runtimeGraph;
    private Dictionary`2<string, NuGetFramework> _frameworkCache;
    [CompilerGeneratedAttribute]
private ManagedCodeCriteria <Criteria>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedCodePatterns <Patterns>k__BackingField;
    public ManagedCodeCriteria Criteria { get; }
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> Properties { get; }
    public ManagedCodePatterns Patterns { get; }
    public ManagedCodeConventions(RuntimeGraph runtimeGraph);
    private static ManagedCodeConventions();
    [CompilerGeneratedAttribute]
public ManagedCodeCriteria get_Criteria();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
public ManagedCodePatterns get_Patterns();
    private bool RuntimeIdentifier_CompatibilityTest(object criteria, object available);
    private static object CodeLanguage_Parser(string name, PatternTable table);
    private static object Locale_Parser(string name, PatternTable table);
    private object TargetFrameworkName_Parser(string name, PatternTable table);
    private static NuGetFramework TargetFrameworkName_ParserCore(string name);
    private static object AllowEmptyFolderParser(string s, PatternTable table);
    private static bool TargetFrameworkName_CompatibilityTest(object criteria, object available);
    private static int TargetFrameworkName_NearestCompareTest(object projectFramework, object criteria, object available);
    private static Version NormalizeVersion(Version version);
}
internal class NuGet.Commands.AddClientCertArgs : object {
    [CompilerGeneratedAttribute]
private string <PackageSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StorePasswordInClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StoreLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StoreName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FindBy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FindValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string PackageSource { get; public set; }
    public string Path { get; public set; }
    public string Password { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public string StoreLocation { get; public set; }
    public string StoreName { get; public set; }
    public string FindBy { get; public set; }
    public string FindValue { get; public set; }
    public bool Force { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageSource();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageSource(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Password();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Password(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StorePasswordInClearText();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StorePasswordInClearText(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StoreLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StoreLocation(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StoreName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StoreName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FindBy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FindBy(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FindValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FindValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Force();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Force(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configfile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configfile(string value);
}
internal static class NuGet.Commands.AddClientCertRunner : object {
    public static void Run(AddClientCertArgs args, Func`1<ILogger> getLogger);
}
internal class NuGet.Commands.AddSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StorePasswordInClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValidAuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Source { get; public set; }
    public string Name { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public string ValidAuthenticationTypes { get; public set; }
    public string ProtocolVersion { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public bool get_StorePasswordInClearText();
    [CompilerGeneratedAttribute]
public void set_StorePasswordInClearText(bool value);
    [CompilerGeneratedAttribute]
public string get_ValidAuthenticationTypes();
    [CompilerGeneratedAttribute]
public void set_ValidAuthenticationTypes(string value);
    [CompilerGeneratedAttribute]
public string get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
internal static class NuGet.Commands.AddSourceRunner : object {
    public static void Run(AddSourceArgs args, Func`1<ILogger> getLogger);
}
internal static class NuGet.Commands.AssetTargetFallbackUtility : object {
    public static string AssetTargetFallback;
    private static AssetTargetFallbackUtility();
    public static void EnsureValidFallback(IEnumerable`1<NuGetFramework> packageTargetFallback, IEnumerable`1<NuGetFramework> assetTargetFallback, string filePath);
    public static RestoreLogMessage GetInvalidFallbackCombinationMessage(string path);
    public static NuGetFramework GetFallbackFramework(NuGetFramework projectFramework, IEnumerable`1<NuGetFramework> packageTargetFallback, IEnumerable`1<NuGetFramework> assetTargetFallback);
    public static void ApplyFramework(TargetFrameworkInformation targetFrameworkInfo, IEnumerable`1<NuGetFramework> packageTargetFallback, IEnumerable`1<NuGetFramework> assetTargetFallback);
}
[ExtensionAttribute]
internal static class NuGet.Commands.BuildAssetsUtils : object {
    private static XNamespace Namespace;
    internal static string CrossTargetingCondition;
    internal static string TargetFrameworkCondition;
    internal static string LanguageCondition;
    internal static string NegativeLanguageCondition;
    internal static string ExcludeAllCondition;
    public static string TargetsExtension;
    public static string PropsExtension;
    public static String[] MacroCandidates;
    private static BuildAssetsUtils();
    public static void WriteFiles(IEnumerable`1<MSBuildOutputFile> files, ILogger log);
    public static List`1<MSBuildOutputFile> GenerateMultiTargetFailureFiles(string targetsPath, string propsPath, ProjectStyle restoreType);
    private static string ReplacePathsWithMacros(string path);
    public static XDocument GenerateMultiTargetFrameworkWarning();
    public static void AddNuGetPropertiesToFirstImport(IEnumerable`1<MSBuildOutputFile> files, IEnumerable`1<string> packageFolders, string repositoryRoot, ProjectStyle projectStyle, string assetsFilePath, bool success);
    public static void AddNuGetProperties(XDocument doc, IEnumerable`1<string> packageFolders, string repositoryRoot, ProjectStyle projectStyle, string assetsFilePath, bool success);
    public static XDocument GenerateEmptyImportsFile();
    public static XElement GenerateProperty(string propertyName, string content);
    internal static XElement GenerateItem(string itemName, string path);
    public static XElement GenerateImport(string path);
    public static XElement GenerateContentFilesItem(string path, LockFileContentFile item, string packageId, string packageVersion);
    public static XDocument GenerateMSBuildFile(List`1<MSBuildRestoreItemGroup> groups, ProjectStyle outputType);
    public static void WriteXML(string path, XDocument doc);
    public static string GetPathWithMacros(string absolutePath, string repositoryRoot);
    public static bool HasChanges(XDocument newFile, string path, ILogger log);
    public static XDocument ReadExisting(string path, ILogger log);
    public static string GetMSBuildFilePath(PackageSpec project, string extension);
    public static string GetMSBuildFilePathForPackageReferenceStyleProject(PackageSpec project, string extension);
    public static List`1<MSBuildOutputFile> GetMSBuildOutputFiles(PackageSpec project, LockFile assetsFile, IEnumerable`1<RestoreTargetGraph> targetGraphs, IReadOnlyList`1<NuGetv3LocalRepository> repositories, RestoreRequest request, string assetsFilePath, bool restoreSuccess, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Commands.BuildAssetsUtils/<GetLanguageConditions>d__28")]
private static IEnumerable`1<string> GetLanguageConditions(string language, SortedSet`1<string> allLanguages);
    public static string GetLanguage(string nugetLanguage);
    private static IEnumerable`1<MSBuildRestoreItemGroup> GetLanguageGroups(List`1<ValueTuple`3<LockFileTargetLibrary, LockFileContentFile, string>> currentItems);
    [IteratorStateMachineAttribute("NuGet.Commands.BuildAssetsUtils/<GenerateGroupsWithConditions>d__31")]
private static IEnumerable`1<MSBuildRestoreItemGroup> GenerateGroupsWithConditions(MSBuildRestoreItemGroup original, bool isCrossTargeting, String[] conditions);
    [ExtensionAttribute]
private static string GetAbsolutePath(Lazy`1<LocalPackageSourceInfo> package, LockFileItem item);
    [ExtensionAttribute]
private static bool Exists(Lazy`1<LocalPackageSourceInfo> package);
    [ExtensionAttribute]
private static IEnumerable`1<LockFileItem> WithExtension(IList`1<LockFileItem> items, string extension);
    private static string GetMatchingFrameworkStrings(PackageSpec spec, NuGetFramework framework);
    private static HashSet`1<PackageDependencyInfo> ConvertToPackageDependencyInfo(ISet`1<GraphItem`1<RemoteResolveResult>> items);
    private static XElement GeneratePackagePathProperty(LocalPackageInfo localPackageInfo);
    [CompilerGeneratedAttribute]
internal static MSBuildRestoreItemGroup <GetMSBuildOutputFiles>g__GenerateBuildGroup|27_1(string repositoryRoot, List`1<KeyValuePair`2<LockFileTargetLibrary, Lazy`1<LocalPackageSourceInfo>>> sortedPackages, string extension);
    [CompilerGeneratedAttribute]
internal static MSBuildRestoreItemGroup <GetMSBuildOutputFiles>g__GenerateMultiTargetingGroup|27_2(string repositoryRoot, List`1<KeyValuePair`2<LockFileTargetLibrary, Lazy`1<LocalPackageSourceInfo>>> sortedPackages, HashSet`1<string> multiTargetingImportsAdded, string extension);
    [IteratorStateMachineAttribute("NuGet.Commands.BuildAssetsUtils/<<WithExtension>g__FilterExtensions|34_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<LockFileItem> <WithExtension>g__FilterExtensions|34_0(IList`1<LockFileItem> items, string extension);
}
internal static class NuGet.Commands.CertificateProvider : object {
    private static int ERROR_FILE_NOT_FOUND_HRESULT;
    private static int OPENSSL_BIO_R_NO_SUCH_FILE;
    private static int ERROR_INVALID_PASSWORD_HRESULT;
    private static int OPENSSL_PKCS12_R_MAC_VERIFY_FAILURE;
    private static int MACOS_PKCS12_MAC_VERIFY_FAILURE;
    private static int CRYPT_E_NO_MATCH_HRESULT;
    private static int MACOS_INVALID_CERT;
    private static int OPENSSL_ERR_R_NESTED_ASN1_ERROR;
    [AsyncStateMachineAttribute("NuGet.Commands.CertificateProvider/<GetCertificatesAsync>d__8")]
public static Task`1<X509Certificate2Collection> GetCertificatesAsync(CertificateSourceOptions options);
    [AsyncStateMachineAttribute("NuGet.Commands.CertificateProvider/<LoadCertificateFromFileAsync>d__9")]
private static Task`1<X509Certificate2> LoadCertificateFromFileAsync(CertificateSourceOptions options);
    private static X509Certificate2Collection LoadCertificateFromStore(CertificateSourceOptions options);
    private static void OpenStore(X509Store store);
    private static X509Certificate2Collection GetValidCertificates(X509Certificate2Collection certificates);
    private static bool IsValid(X509Certificate2 certificate, X509Certificate2Collection extraStore);
}
internal class NuGet.Commands.CertificateSourceOptions : object {
    [CompilerGeneratedAttribute]
private string <CertificatePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePassword>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreName <StoreName>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreLocation <StoreLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private IPasswordProvider <PasswordProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    public string CertificatePath { get; public set; }
    public string CertificatePassword { get; public set; }
    public StoreName StoreName { get; public set; }
    public StoreLocation StoreLocation { get; public set; }
    public string SubjectName { get; public set; }
    public string Fingerprint { get; public set; }
    public bool NonInteractive { get; public set; }
    public IPasswordProvider PasswordProvider { get; public set; }
    public CancellationToken Token { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CertificatePath();
    [CompilerGeneratedAttribute]
public void set_CertificatePath(string value);
    [CompilerGeneratedAttribute]
public string get_CertificatePassword();
    [CompilerGeneratedAttribute]
public void set_CertificatePassword(string value);
    [CompilerGeneratedAttribute]
public StoreName get_StoreName();
    [CompilerGeneratedAttribute]
public void set_StoreName(StoreName value);
    [CompilerGeneratedAttribute]
public StoreLocation get_StoreLocation();
    [CompilerGeneratedAttribute]
public void set_StoreLocation(StoreLocation value);
    [CompilerGeneratedAttribute]
public string get_SubjectName();
    [CompilerGeneratedAttribute]
public void set_SubjectName(string value);
    [CompilerGeneratedAttribute]
public string get_Fingerprint();
    [CompilerGeneratedAttribute]
public void set_Fingerprint(string value);
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_NonInteractive(bool value);
    [CompilerGeneratedAttribute]
public IPasswordProvider get_PasswordProvider();
    [CompilerGeneratedAttribute]
public void set_PasswordProvider(IPasswordProvider value);
    [CompilerGeneratedAttribute]
public CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(CancellationToken value);
}
[ExtensionAttribute]
internal static class NuGet.Commands.ClientCertArgsExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<X509FindType> GetFindBy(IClientCertArgsWithStoreData args);
    [ExtensionAttribute]
public static Nullable`1<StoreLocation> GetStoreLocation(IClientCertArgsWithStoreData args);
    [ExtensionAttribute]
public static Nullable`1<StoreName> GetStoreName(IClientCertArgsWithStoreData args);
    [ExtensionAttribute]
public static bool IsFileCertSettingsProvided(IClientCertArgsWithFileData args);
    [ExtensionAttribute]
public static bool IsPackageSourceSettingProvided(IClientCertArgsWithPackageSource args);
    [ExtensionAttribute]
public static bool IsStoreCertSettingsProvided(IClientCertArgsWithStoreData args);
    [ExtensionAttribute]
public static void Validate(RemoveClientCertArgs args);
    [ExtensionAttribute]
public static void Validate(AddClientCertArgs args);
    [ExtensionAttribute]
public static void Validate(UpdateClientCertArgs args);
}
internal class NuGet.Commands.CommandException : Exception {
    public CommandException(string message);
    public CommandException(string format, Object[] args);
    public CommandException(string message, Exception exception);
    protected CommandException(SerializationInfo info, StreamingContext context);
}
internal static class NuGet.Commands.CommandRunnerUtility : object {
    public static string ResolveSource(IPackageSourceProvider sourceProvider, string source);
    public static string ResolveSymbolSource(IPackageSourceProvider sourceProvider, string symbolSource);
    public static string GetApiKey(ISettings settings, string endpoint, string source);
    [AsyncStateMachineAttribute("NuGet.Commands.CommandRunnerUtility/<GetPackageUpdateResource>d__3")]
public static Task`1<PackageUpdateResource> GetPackageUpdateResource(IPackageSourceProvider sourceProvider, PackageSource packageSource, CancellationToken cancellationToken);
    public static PackageSource GetOrCreatePackageSource(IPackageSourceProvider sourceProvider, string source);
    [AsyncStateMachineAttribute("NuGet.Commands.CommandRunnerUtility/<GetSymbolPackageUpdateResource>d__5")]
public static Task`1<SymbolPackageUpdateResourceV3> GetSymbolPackageUpdateResource(IPackageSourceProvider sourceProvider, string source, CancellationToken cancellationToken);
}
internal class NuGet.Commands.CompatibilityChecker : object {
    private IReadOnlyList`1<NuGetv3LocalRepository> _localRepositories;
    private LockFile _lockFile;
    private ILogger _log;
    private bool _validateRuntimeAssets;
    public CompatibilityChecker(IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, LockFile lockFile, bool validateRuntimeAssets, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Commands.CompatibilityChecker/<CheckAsync>d__5")]
internal Task`1<CompatibilityCheckResult> CheckAsync(RestoreTargetGraph graph, Dictionary`2<string, LibraryIncludeFlags> includeFlags, PackageSpec packageSpec);
    private static RestoreLogMessage GetErrorMessage(NuGetLogCode logCode, CompatibilityIssue issue, RestoreTargetGraph graph);
    private static IEnumerable`1<NuGetFramework> GetPackageFrameworks(CompatibilityData compatibilityData, RestoreTargetGraph graph);
    private static List`1<NuGetFramework> GetProjectFrameworks(Library localLibrary);
    private static bool IsProjectFrameworkCompatible(Library library);
    private bool IsPackageCompatible(CompatibilityData compatibilityData);
    private bool IsPackageTypeCompatible(CompatibilityData compatibilityData);
    private static HashSet`1<FrameworkRuntimePair> GetAvailableFrameworkRuntimePairs(CompatibilityData compatibilityData, RestoreTargetGraph graph);
    [AsyncStateMachineAttribute("NuGet.Commands.CompatibilityChecker/<VerifyDotnetToolCompatibilityChecks>d__13")]
private Task VerifyDotnetToolCompatibilityChecks(CompatibilityData compatibilityData, GraphItem`1<RemoteResolveResult> node, RestoreTargetGraph graph, List`1<CompatibilityIssue> issues);
    internal static bool HasCompatibleAssets(LockFileTargetLibrary targetLibrary);
    internal static bool HasCompatibleToolsAssets(LockFileTargetLibrary targetLibrary);
    private CompatibilityData GetCompatibilityData(RestoreTargetGraph graph, LibraryIdentity libraryId, PackageSpec packageSpec);
}
internal class NuGet.Commands.CompatibilityCheckResult : object {
    [CompilerGeneratedAttribute]
private RestoreTargetGraph <Graph>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CompatibilityIssue> <Issues>k__BackingField;
    public RestoreTargetGraph Graph { get; }
    public IReadOnlyList`1<CompatibilityIssue> Issues { get; }
    public bool Success { get; }
    public CompatibilityCheckResult(RestoreTargetGraph graph, IEnumerable`1<CompatibilityIssue> issues);
    [CompilerGeneratedAttribute]
public RestoreTargetGraph get_Graph();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CompatibilityIssue> get_Issues();
    public bool get_Success();
}
internal class NuGet.Commands.CompatibilityIssue : object {
    [CompilerGeneratedAttribute]
private CompatibilityIssueType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageIdentity <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NuGetFramework> <AvailableFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FrameworkRuntimePair> <AvailableFrameworkRuntimePairs>k__BackingField;
    public CompatibilityIssueType Type { get; }
    public NuGetFramework Framework { get; }
    public string RuntimeIdentifier { get; }
    public string AssemblyName { get; }
    public PackageIdentity Package { get; }
    public List`1<NuGetFramework> AvailableFrameworks { get; }
    public List`1<FrameworkRuntimePair> AvailableFrameworkRuntimePairs { get; }
    private CompatibilityIssue(CompatibilityIssueType type, PackageIdentity package, string assemblyName, NuGetFramework framework, string runtimeIdentifier, IEnumerable`1<NuGetFramework> availableFrameworks, IEnumerable`1<FrameworkRuntimePair> availableFrameworkRuntimePairs);
    [CompilerGeneratedAttribute]
public CompatibilityIssueType get_Type();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public PackageIdentity get_Package();
    [CompilerGeneratedAttribute]
public List`1<NuGetFramework> get_AvailableFrameworks();
    [CompilerGeneratedAttribute]
public List`1<FrameworkRuntimePair> get_AvailableFrameworkRuntimePairs();
    public static CompatibilityIssue ReferenceAssemblyNotImplemented(string assemblyName, PackageIdentity referenceAssemblyPackage, NuGetFramework framework, string runtimeIdentifier);
    public static CompatibilityIssue IncompatiblePackage(PackageIdentity referenceAssemblyPackage, NuGetFramework framework, string runtimeIdentifier, IEnumerable`1<NuGetFramework> packageFrameworks);
    public static CompatibilityIssue IncompatiblePackageWithDotnetTool(PackageIdentity referenceAssemblyPackage);
    public static CompatibilityIssue ToolsPackageWithExtraPackageTypes(PackageIdentity referenceAssemblyPackage);
    public static CompatibilityIssue IncompatibleToolsPackage(PackageIdentity packageIdentity, NuGetFramework framework, string runtimeIdentifier, HashSet`1<FrameworkRuntimePair> available);
    public static CompatibilityIssue IncompatibleProject(PackageIdentity project, NuGetFramework framework, string runtimeIdentifier, IEnumerable`1<NuGetFramework> projectFrameworks);
    public static CompatibilityIssue IncompatibleProjectType(PackageIdentity project);
    internal static CompatibilityIssue IncompatiblePackageType(PackageIdentity packageIdentity, NuGetFramework framework, string runtimeIdentifier);
    public virtual string ToString();
    public string Format();
    private string FormatMessage(string message, string supports, string noSupports);
    private static string FormatFramework(NuGetFramework framework);
    private static string FormatFramework(NuGetFramework framework, string runtimeId);
    public sealed virtual bool Equals(CompatibilityIssue other);
}
internal enum NuGet.Commands.CompatibilityIssueType : Enum {
    public int value__;
    public static CompatibilityIssueType ReferenceAssemblyNotImplemented;
    public static CompatibilityIssueType PackageIncompatible;
    public static CompatibilityIssueType ProjectIncompatible;
    public static CompatibilityIssueType PackageToolsAssetsIncompatible;
    public static CompatibilityIssueType ProjectWithIncorrectDependencyCount;
    public static CompatibilityIssueType IncompatiblePackageWithDotnetTool;
    public static CompatibilityIssueType ToolsPackageWithExtraPackageTypes;
    public static CompatibilityIssueType PackageTypeIncompatible;
}
internal static class NuGet.Commands.ContentFileUtils : object {
    private static string ContentFilesFolderName;
    internal static List`1<ContentItemGroup> GetContentGroupsForFramework(NuGetFramework framework, IEnumerable`1<ContentItemGroup> contentGroups);
    internal static List`1<LockFileContentFile> GetContentFileGroup(NuspecReader nuspec, List`1<ContentItemGroup> contentFileGroups);
    internal static LockFileContentFile CreateEmptyItem();
    internal static string GetContentFileFolderRelativeToFramework(ReadOnlySpan`1<char> itemPath);
}
internal class NuGet.Commands.ContentMetadata : ValueType {
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flatten>k__BackingField;
    public string Target { get; public set; }
    public string Source { get; public set; }
    public string BuildAction { get; public set; }
    public string CopyToOutput { get; public set; }
    public string Flatten { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(string value);
}
internal static class NuGet.Commands.DeleteRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.DeleteRunner/<Run>d__0")]
public static Task Run(ISettings settings, IPackageSourceProvider sourceProvider, string packageId, string packageVersion, string source, string apiKey, bool nonInteractive, bool noServiceEndpoint, Func`2<string, bool> confirmFunc, ILogger logger);
}
internal class NuGet.Commands.DependencyGraphFileRequestProvider : object {
    private RestoreCommandProvidersCache _providerCache;
    public DependencyGraphFileRequestProvider(RestoreCommandProvidersCache providerCache);
    public virtual Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(string inputPath, RestoreArgs restoreContext);
    public virtual Task`1<bool> Supports(string path);
}
internal class NuGet.Commands.DependencyGraphSpecRequestProvider : object {
    private static bool DefaultRestoreLegacyPackagesDirectory;
    private DependencyGraphSpec _dgFile;
    private RestoreCommandProvidersCache _providerCache;
    private LockFileBuilderCache _lockFileBuilderCache;
    private ISettings _settings;
    public DependencyGraphSpecRequestProvider(RestoreCommandProvidersCache providerCache, DependencyGraphSpec dgFile);
    public DependencyGraphSpecRequestProvider(RestoreCommandProvidersCache providerCache, DependencyGraphSpec dgFile, ISettings settings);
    public sealed virtual Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(RestoreArgs restoreContext);
    private IReadOnlyList`1<RestoreSummaryRequest> GetRequestsFromItems(RestoreArgs restoreContext, DependencyGraphSpec dgFile);
    public static IEnumerable`1<ExternalProjectReference> GetExternalClosure(DependencyGraphSpec dgFile, string projectNameToRestore);
    private static ExternalProjectReference GetExternalProject(PackageSpec rootProject);
    private RestoreSummaryRequest Create(string projectNameToRestore, ExternalProjectReference project, HashSet`1<ExternalProjectReference> projectReferenceClosure, RestoreArgs restoreArgs, DependencyGraphSpec projectDgSpec, SettingsLoadingContext settingsLoadingContext);
    private string GetPackagesPath(RestoreArgs restoreArgs, PackageSpec project);
    private static void CollectReferences(ExternalProjectReference root, Dictionary`2<string, ExternalProjectReference> allProjects, HashSet`1<ExternalProjectReference> references);
    internal static IReadOnlyList`1<IAssetsLogMessage> GetMessagesForProject(IReadOnlyList`1<IAssetsLogMessage> allMessages, string projectPath);
}
internal static class NuGet.Commands.DiagnosticUtility : object {
    public static string FormatIdentity(LibraryIdentity identity);
    public static string FormatDependency(string id, VersionRange range);
    public static string FormatExpectedIdentity(string id, VersionRange range);
    public static string FormatGraphName(RestoreTargetGraph graph);
    public static string GetMultiLineMessage(IEnumerable`1<string> lines);
    public static IEnumerable`1<RestoreLogMessage> MergeOnTargetGraph(IEnumerable`1<RestoreLogMessage> messages);
}
internal class NuGet.Commands.DisableSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Name { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
internal static class NuGet.Commands.DisableSourceRunner : object {
    public static void Run(DisableSourceArgs args, Func`1<ILogger> getLogger);
}
internal class NuGet.Commands.DownloadDependencyResolutionResult : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Tuple`2<LibraryRange, RemoteMatch>> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<RemoteMatch> <Install>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<LibraryRange> <Unresolved>k__BackingField;
    public NuGetFramework Framework { get; }
    public IList`1<Tuple`2<LibraryRange, RemoteMatch>> Dependencies { get; }
    public ISet`1<RemoteMatch> Install { get; }
    public ISet`1<LibraryRange> Unresolved { get; }
    private DownloadDependencyResolutionResult(NuGetFramework framework, IList`1<Tuple`2<LibraryRange, RemoteMatch>> dependencies, ISet`1<RemoteMatch> install, ISet`1<LibraryRange> unresolved);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public IList`1<Tuple`2<LibraryRange, RemoteMatch>> get_Dependencies();
    [CompilerGeneratedAttribute]
public ISet`1<RemoteMatch> get_Install();
    [CompilerGeneratedAttribute]
public ISet`1<LibraryRange> get_Unresolved();
    public static DownloadDependencyResolutionResult Create(NuGetFramework framework, IList`1<Tuple`2<LibraryRange, RemoteMatch>> dependencies, IList`1<IRemoteDependencyProvider> remoteDependencyProviders);
}
internal class NuGet.Commands.EnableSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Name { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
internal static class NuGet.Commands.EnableSourceRunner : object {
    public static void Run(EnableSourceArgs args, Func`1<ILogger> getLogger);
}
[ExtensionAttribute]
internal static class NuGet.Commands.Extensions : object {
    [ExtensionAttribute]
public static ISet`1<LibraryDependency> GetAllPackageDependencies(PackageSpec project);
    [ExtensionAttribute]
public static ISet`1<LibraryDependency> GetPackageDependenciesForFramework(PackageSpec project, NuGetFramework framework);
    [ExtensionAttribute]
public static void LogMessages(ILogger logger, IEnumerable`1<ILogMessage> messages);
    [ExtensionAttribute]
public static Task LogMessagesAsync(ILogger logger, ILogMessage[] messages);
    [AsyncStateMachineAttribute("NuGet.Commands.Extensions/<LogMessagesAsync>d__4")]
[ExtensionAttribute]
public static Task LogMessagesAsync(ILogger logger, IEnumerable`1<ILogMessage> messages);
    [ExtensionAttribute]
public static RestoreLogMessage AsRestoreLogMessage(IAssetsLogMessage logMessage);
    [ExtensionAttribute]
public static RestoreLogMessage AsRestoreLogMessage(LogMessage logMessage);
}
internal class NuGet.Commands.FileProviderGlobbingDirectory : DirectoryInfoBase {
    private static char DirectorySeparatorChar;
    private IFileProvider _fileProvider;
    private IFileInfo _fileInfo;
    private FileProviderGlobbingDirectory _parent;
    private bool _isRoot;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    public string RelativePath { get; }
    public string FullName { get; }
    public string Name { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public FileProviderGlobbingDirectory(IFileProvider fileProvider, IFileInfo fileInfo, FileProviderGlobbingDirectory parent);
    [CompilerGeneratedAttribute]
public string get_RelativePath();
    public virtual string get_FullName();
    public virtual string get_Name();
    public virtual DirectoryInfoBase get_ParentDirectory();
    [IteratorStateMachineAttribute("NuGet.Commands.FileProviderGlobbingDirectory/<EnumerateFileSystemInfos>d__15")]
public virtual IEnumerable`1<FileSystemInfoBase> EnumerateFileSystemInfos();
    public virtual DirectoryInfoBase GetDirectory(string path);
    public virtual FileInfoBase GetFile(string path);
    private FileSystemInfoBase BuildFileResult(IFileInfo fileInfo);
}
internal class NuGet.Commands.FileProviderGlobbingFile : FileInfoBase {
    private static char DirectorySeparatorChar;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryInfoBase <ParentDirectory>k__BackingField;
    public string FullName { get; }
    public string Name { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public FileProviderGlobbingFile(IFileInfo fileInfo, DirectoryInfoBase parent);
    [CompilerGeneratedAttribute]
public virtual string get_FullName();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual DirectoryInfoBase get_ParentDirectory();
}
internal interface NuGet.Commands.IClientCertArgsWithConfigFile {
    public string Configfile { get; public set; }
    public abstract virtual string get_Configfile();
    public abstract virtual void set_Configfile(string value);
}
internal interface NuGet.Commands.IClientCertArgsWithFileData {
    public string Password { get; public set; }
    public string Path { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public abstract virtual string get_Password();
    public abstract virtual void set_Password(string value);
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual bool get_StorePasswordInClearText();
    public abstract virtual void set_StorePasswordInClearText(bool value);
}
internal interface NuGet.Commands.IClientCertArgsWithForce {
    public bool Force { get; public set; }
    public abstract virtual bool get_Force();
    public abstract virtual void set_Force(bool value);
}
internal interface NuGet.Commands.IClientCertArgsWithPackageSource {
    public string PackageSource { get; public set; }
    public abstract virtual string get_PackageSource();
    public abstract virtual void set_PackageSource(string value);
}
internal interface NuGet.Commands.IClientCertArgsWithStoreData {
    public string FindBy { get; public set; }
    public string FindValue { get; public set; }
    public string StoreLocation { get; public set; }
    public string StoreName { get; public set; }
    public abstract virtual string get_FindBy();
    public abstract virtual void set_FindBy(string value);
    public abstract virtual string get_FindValue();
    public abstract virtual void set_FindValue(string value);
    public abstract virtual string get_StoreLocation();
    public abstract virtual void set_StoreLocation(string value);
    public abstract virtual string get_StoreName();
    public abstract virtual void set_StoreName(string value);
}
internal interface NuGet.Commands.IListCommandRunner {
    public abstract virtual Task ExecuteCommand(ListArgs listArgs);
}
internal interface NuGet.Commands.ILocalsCommandRunner {
    public abstract virtual void ExecuteCommand(LocalsArgs localsArgs);
}
internal interface NuGet.Commands.IMSBuildItem {
    public string Identity { get; }
    public IReadOnlyList`1<string> Properties { get; }
    public abstract virtual string get_Identity();
    public abstract virtual string GetProperty(string property);
    public abstract virtual string GetProperty(string property, bool trim);
    public abstract virtual IReadOnlyList`1<string> get_Properties();
}
internal static class NuGet.Commands.IncludeFlagUtils : object {
    internal static Dictionary`2<string, LibraryIncludeFlags> FlattenDependencyTypes(Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> includeFlagGraphs, PackageSpec project, RestoreTargetGraph graph);
    internal static Dictionary`2<string, LibraryIncludeFlags> FlattenDependencyTypes(RestoreTargetGraph targetGraph, PackageSpec spec);
    private static void FlattenDependencyTypesUnified(RestoreTargetGraph targetGraph, Dictionary`2<string, LibraryIncludeFlags> result);
    private static LibraryIncludeFlags GetDependencyType(GraphNode`1<RemoteResolveResult> parent, GraphNode`1<RemoteResolveResult> child);
    private static bool IsPackageOrProject(GraphItem`1<RemoteResolveResult> item);
    private static int OrderType(GraphItem`1<RemoteResolveResult> item);
}
internal class NuGet.Commands.IndexedRestoreTargetGraph : object {
    private Dictionary`2<string, GraphItem`1<RemoteResolveResult>> _lookup;
    private HashSet`1<string> _idsWithErrors;
    [CompilerGeneratedAttribute]
private IRestoreTargetGraph <Graph>k__BackingField;
    public IRestoreTargetGraph Graph { get; }
    private IndexedRestoreTargetGraph(IRestoreTargetGraph graph);
    [CompilerGeneratedAttribute]
public IRestoreTargetGraph get_Graph();
    public static IndexedRestoreTargetGraph Create(IRestoreTargetGraph graph);
    public GraphItem`1<RemoteResolveResult> GetItemById(string id);
    public GraphItem`1<RemoteResolveResult> GetItemById(string id, LibraryType libraryType);
    public bool HasErrors(string id);
}
internal interface NuGet.Commands.IPreLoadedRestoreRequestProvider {
    public abstract virtual Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(RestoreArgs restoreContext);
}
internal interface NuGet.Commands.IProjectFactory {
    public ILogger Logger { get; public set; }
    public abstract virtual WarningProperties GetWarningPropertiesForProject();
    public abstract virtual Dictionary`2<string, string> GetProjectProperties();
    public abstract virtual void SetIncludeSymbols(bool includeSymbols);
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual PackageBuilder CreateBuilder(string basePath, NuGetVersion version, string suffix, bool buildIfNeeded, PackageBuilder builder);
}
[NuGet.Commands.NullableContextAttribute("1")]
internal interface NuGet.Commands.IRestoreProgressReporter {
    public abstract virtual void StartProjectUpdate(string projectPath, IReadOnlyList`1<string> updatedFiles);
    public abstract virtual void EndProjectUpdate(string projectPath, IReadOnlyList`1<string> updatedFiles);
}
internal interface NuGet.Commands.IRestoreRequestProvider {
    public abstract virtual Task`1<bool> Supports(string path);
    public abstract virtual Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(string inputPath, RestoreArgs restoreContext);
}
internal interface NuGet.Commands.IRestoreResult {
    public bool Success { get; }
    public string LockFilePath { get; }
    public LockFile LockFile { get; }
    public LockFile PreviousLockFile { get; }
    public IEnumerable`1<MSBuildOutputFile> MSBuildOutputFiles { get; }
    public abstract virtual bool get_Success();
    public abstract virtual string get_LockFilePath();
    public abstract virtual LockFile get_LockFile();
    public abstract virtual LockFile get_PreviousLockFile();
    public abstract virtual IEnumerable`1<MSBuildOutputFile> get_MSBuildOutputFiles();
}
internal interface NuGet.Commands.IRestoreTargetGraph {
    public string Name { get; }
    public string TargetGraphName { get; }
    public string RuntimeIdentifier { get; }
    public NuGetFramework Framework { get; }
    public ManagedCodeConventions Conventions { get; }
    public RuntimeGraph RuntimeGraph { get; }
    public IEnumerable`1<GraphNode`1<RemoteResolveResult>> Graphs { get; }
    public ISet`1<RemoteMatch> Install { get; }
    public ISet`1<GraphItem`1<RemoteResolveResult>> Flattened { get; }
    public ISet`1<LibraryRange> Unresolved { get; }
    public bool InConflict { get; }
    public IEnumerable`1<ResolverConflict> Conflicts { get; }
    public AnalyzeResult`1<RemoteResolveResult> AnalyzeResult { get; }
    public ISet`1<ResolvedDependencyKey> ResolvedDependencies { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_TargetGraphName();
    public abstract virtual string get_RuntimeIdentifier();
    public abstract virtual NuGetFramework get_Framework();
    public abstract virtual ManagedCodeConventions get_Conventions();
    public abstract virtual RuntimeGraph get_RuntimeGraph();
    public abstract virtual IEnumerable`1<GraphNode`1<RemoteResolveResult>> get_Graphs();
    public abstract virtual ISet`1<RemoteMatch> get_Install();
    public abstract virtual ISet`1<GraphItem`1<RemoteResolveResult>> get_Flattened();
    public abstract virtual ISet`1<LibraryRange> get_Unresolved();
    public abstract virtual bool get_InConflict();
    public abstract virtual IEnumerable`1<ResolverConflict> get_Conflicts();
    public abstract virtual AnalyzeResult`1<RemoteResolveResult> get_AnalyzeResult();
    public abstract virtual ISet`1<ResolvedDependencyKey> get_ResolvedDependencies();
}
internal interface NuGet.Commands.ISignCommandRunner {
    public abstract virtual Task`1<int> ExecuteCommandAsync(SignArgs signArgs);
}
internal interface NuGet.Commands.ITrustedSignersCommandRunner {
    public abstract virtual Task`1<int> ExecuteCommandAsync(TrustedSignersArgs trustedSignersArgs);
}
internal interface NuGet.Commands.IVerifyCommandRunner {
    public abstract virtual Task`1<int> ExecuteCommandAsync(VerifyArgs verifyArgs);
}
internal interface NuGet.Commands.IVulnerabilityInformationProvider {
    public abstract virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInformationAsync(CancellationToken cancellationToken);
}
internal class NuGet.Commands.ListArgs : object {
    [CompilerGeneratedAttribute]
private bool <AllVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDelisted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Prerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private Log <PrintJustified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDetailed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListCommandNoPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListCommandLicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListCommandListNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageSource> <ListEndpoints>k__BackingField;
    public bool AllVersions { get; }
    public bool IncludeDelisted { get; }
    public bool Prerelease { get; }
    public IList`1<string> Arguments { get; }
    public ISettings Settings { get; }
    public ILogger Logger { get; }
    public Log PrintJustified { get; }
    public bool IsDetailed { get; }
    public string ListCommandNoPackages { get; }
    public string ListCommandLicenseUrl { get; }
    public string ListCommandListNotSupported { get; }
    public CancellationToken CancellationToken { get; }
    public IList`1<PackageSource> ListEndpoints { get; }
    public ListArgs(IList`1<string> arguments, IList`1<PackageSource> listEndpoints, ISettings settings, ILogger logger, Log printJustified, bool isDetailedl, string listCommandNoPackages, string listCommandLicenseUrl, string listCommandListNotSupported, bool allVersions, bool includeDelisted, bool prerelease, CancellationToken token);
    [CompilerGeneratedAttribute]
public bool get_AllVersions();
    [CompilerGeneratedAttribute]
public bool get_IncludeDelisted();
    [CompilerGeneratedAttribute]
public bool get_Prerelease();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Arguments();
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public Log get_PrintJustified();
    [CompilerGeneratedAttribute]
public bool get_IsDetailed();
    [CompilerGeneratedAttribute]
public string get_ListCommandNoPackages();
    [CompilerGeneratedAttribute]
public string get_ListCommandLicenseUrl();
    [CompilerGeneratedAttribute]
public string get_ListCommandListNotSupported();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public IList`1<PackageSource> get_ListEndpoints();
}
internal class NuGet.Commands.ListClientCertArgs : object {
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configfile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configfile(string value);
}
internal static class NuGet.Commands.ListClientCertRunner : object {
    private static int PaddingWidth;
    public static void Run(ListClientCertArgs args, Func`1<ILogger> getLogger);
}
internal class NuGet.Commands.ListCommandRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.ListCommandRunner/<ExecuteCommand>d__0")]
public sealed virtual Task ExecuteCommand(ListArgs listArgs);
    private static void WarnForHTTPSources(ListArgs listArgs);
    [AsyncStateMachineAttribute("NuGet.Commands.ListCommandRunner/<PrintPackages>d__3")]
private Task PrintPackages(ListArgs listArgs, IEnumeratorAsync`1<IPackageSearchMetadata> asyncEnumerator);
}
internal class NuGet.Commands.ListSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Format { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
internal static class NuGet.Commands.ListSourceRunner : object {
    public static void Run(ListSourceArgs args, Func`1<ILogger> getLogger);
    private static void WarnForHttpSources(IEnumerable`1<PackageSource> sources, Func`1<ILogger> getLogger);
}
internal class NuGet.Commands.LocalsArgs : object {
    [CompilerGeneratedAttribute]
private bool <Clear>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <List>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private Log <LogError>k__BackingField;
    [CompilerGeneratedAttribute]
private Log <LogInformation>k__BackingField;
    public bool Clear { get; }
    public bool List { get; }
    public IList`1<string> Arguments { get; }
    public ISettings Settings { get; }
    public Log LogError { get; }
    public Log LogInformation { get; }
    public LocalsArgs(IList`1<string> arguments, ISettings settings, Log logInformation, Log logError, bool clear, bool list);
    [CompilerGeneratedAttribute]
public bool get_Clear();
    [CompilerGeneratedAttribute]
public bool get_List();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Arguments();
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public Log get_LogError();
    [CompilerGeneratedAttribute]
public Log get_LogInformation();
}
internal class NuGet.Commands.LocalsCommandRunner : object {
    private static string HttpCacheResourceName;
    private static string GlobalPackagesResourceName;
    private static string PluginsCacheResourceName;
    private static string AllResourceName;
    private static string TempResourceName;
    public sealed virtual void ExecuteCommand(LocalsArgs localsArgs);
    private void ListLocalResource(LocalResourceName localResourceName, LocalsArgs localsArgs);
    private void PrintLocalResourcePath(string resourceName, string path, LocalsArgs localsArgs);
    private void ClearLocalResource(LocalResourceName localResourceName, LocalsArgs localsArgs);
    private bool ClearNuGetPluginsCache(LocalsArgs localsArgs);
    private bool ClearNuGetGlobalPackagesFolder(LocalsArgs localsArgs);
    private bool ClearNuGetHttpCache(LocalsArgs localsArgs);
    private bool ClearNuGetTempFolder(LocalsArgs localsArgs);
    private static LocalResourceName GetLocalResourceName(string localResourceName);
    private bool ClearCacheDirectory(string folderPath, LocalsArgs localsArgs);
}
internal class NuGet.Commands.LockFileBuilder : object {
    private int _lockFileVersion;
    private ILogger _logger;
    private Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> _includeFlagGraphs;
    public LockFileBuilder(int lockFileVersion, ILogger logger, Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> includeFlagGraphs);
    [ObsoleteAttribute("Use method with LockFileBuilderCache parameter")]
public LockFile CreateLockFile(LockFile previousLockFile, PackageSpec project, IEnumerable`1<RestoreTargetGraph> targetGraphs, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, RemoteWalkContext context);
    public LockFile CreateLockFile(LockFile previousLockFile, PackageSpec project, IEnumerable`1<RestoreTargetGraph> targetGraphs, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, RemoteWalkContext context, LockFileBuilderCache lockFileBuilderCache);
    private Dictionary`2<ValueTuple`2<string, NuGetVersion>, LockFileLibrary> EnsureUniqueLockFileLibraries(LockFile lockFile);
    private static void EnsureUniqueLockFileTargetLibraries(LockFileTarget lockFileTarget);
    private static int RankReferences(string referenceType);
    private static string GetFallbackFrameworkString(NuGetFramework framework);
    private static void AddProjectFileDependenciesForSpec(PackageSpec project, LockFile lockFile);
    private static void AddProjectFileDependenciesForPackageReference(PackageSpec project, LockFile lockFile, IEnumerable`1<RestoreTargetGraph> targetGraphs);
    private void AddCentralTransitiveDependencyGroupsForPackageReference(PackageSpec project, LockFile lockFile, IEnumerable`1<RestoreTargetGraph> targetGraphs);
    [IteratorStateMachineAttribute("NuGet.Commands.LockFileBuilder/<GetLibraryDependenciesForCentralTransitiveDependencies>d__13")]
private IEnumerable`1<LibraryDependency> GetLibraryDependenciesForCentralTransitiveDependencies(RestoreTargetGraph targetGraph, TargetFrameworkInformation targetFrameworkInformation);
    [IteratorStateMachineAttribute("NuGet.Commands.LockFileBuilder/<EnumerateNodesForDependencyChecks>d__14`1")]
private static IEnumerable`1<GraphNode`1<T>> EnumerateNodesForDependencyChecks(HashSet`1<GraphNode`1<T>> visitedNodes, Queue`1<GraphNode`1<T>> queue, GraphNode`1<T> rootNode, GraphNode`1<T> graphNode);
    private static void PopulatePackageFolders(IEnumerable`1<string> packageFolders, LockFile lockFile);
    private static LockFileLibrary CreateLockFileLibrary(LocalPackageInfo package, string sha512, string path);
    private static bool HasTools(string file);
}
internal class NuGet.Commands.LockFileBuilderCache : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`3<string, NuGetVersion, string>, ContentItemCollection> _contentItems;
    private ConcurrentDictionary`2<CriteriaKey, List`1<ValueTuple`2<List`1<SelectionCriteria>, bool>>> _criteriaSets;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`4<CriteriaKey, string, string, LibraryIncludeFlags>, Lazy`1<ValueTuple`2<LockFileTargetLibrary, bool>>> _lockFileTargetLibraryCache;
    public List`1<List`1<SelectionCriteria>> GetSelectionCriteria(RestoreTargetGraph graph, NuGetFramework framework);
    internal List`1<ValueTuple`2<List`1<SelectionCriteria>, bool>> GetLabeledSelectionCriteria(RestoreTargetGraph graph, NuGetFramework framework);
    public ContentItemCollection GetContentItems(LockFileLibrary library, LocalPackageInfo package);
    internal ValueTuple`2<LockFileTargetLibrary, bool> GetLockFileTargetLibrary(RestoreTargetGraph graph, NuGetFramework framework, LocalPackageInfo localPackageInfo, string aliases, LibraryIncludeFlags libraryIncludeFlags, Func`1<ValueTuple`2<LockFileTargetLibrary, bool>> valueFactory);
}
internal static class NuGet.Commands.LockFileUtils : object {
    public static string LIBANY;
    private static LockFileUtils();
    public static LockFileTargetLibrary CreateLockFileTargetLibrary(LockFileLibrary library, LocalPackageInfo package, RestoreTargetGraph targetGraph, LibraryIncludeFlags dependencyType);
    internal static ValueTuple`2<LockFileTargetLibrary, bool> CreateLockFileTargetLibrary(string aliases, LockFileLibrary library, LocalPackageInfo package, RestoreTargetGraph targetGraph, LibraryIncludeFlags dependencyType, NuGetFramework targetFrameworkOverride, List`1<LibraryDependency> dependencies, LockFileBuilderCache cache);
    internal static List`1<ValueTuple`2<List`1<SelectionCriteria>, bool>> CreateOrderedCriteriaSets(ManagedCodeConventions codeConventions, NuGetFramework framework, string runtimeIdentifier);
    private static void ApplyAliases(string aliases, LockFileItem item);
    private static void AddAssets(string aliases, LockFileLibrary library, LocalPackageInfo package, ManagedCodeConventions managedCodeConventions, LibraryIncludeFlags dependencyType, LockFileTargetLibrary lockFileLib, NuGetFramework framework, string runtimeIdentifier, ContentItemCollection contentItems, NuspecReader nuspec, List`1<SelectionCriteria> orderedCriteria);
    private static void AddMSBuildAssets(string libraryName, ManagedCodeConventions managedCodeConventions, LockFileTargetLibrary lockFileLib, List`1<SelectionCriteria> orderedCriteria, ContentItemCollection contentItems);
    private static void AddToolsAssets(ManagedCodeConventions managedCodeConventions, LockFileTargetLibrary lockFileLib, ContentItemCollection contentItems, List`1<SelectionCriteria> orderedCriteria);
    private static void AddContentFiles(ManagedCodeConventions managedCodeConventions, LockFileTargetLibrary lockFileLib, NuGetFramework framework, ContentItemCollection contentItems, NuspecReader nuspec);
    private static void AddRuntimeTargets(ManagedCodeConventions managedCodeConventions, LibraryIncludeFlags dependencyType, LockFileTargetLibrary lockFileLib, NuGetFramework framework, string runtimeIdentifier, ContentItemCollection contentItems);
    private static void AddFrameworkReferences(LockFileTargetLibrary lockFileLib, NuGetFramework framework, NuspecReader nuspec);
    private static void ApplyReferenceFilter(LockFileTargetLibrary lockFileLib, NuGetFramework framework, NuspecReader nuspec);
    private static void ApplyLibContract(LocalPackageInfo package, LockFileTargetLibrary lockFileLib, NuGetFramework framework, ContentItemCollection contentItems);
    private static void AddDependencies(IEnumerable`1<LibraryDependency> dependencies, LockFileTargetLibrary lockFileLib, NuGetFramework framework, NuspecReader nuspec);
    public static LockFileTargetLibrary CreateLockFileTargetProject(GraphItem`1<RemoteResolveResult> graphItem, LibraryIdentity library, LibraryIncludeFlags dependencyType, RestoreTargetGraph targetGraph, ProjectStyle rootProjectStyle);
    [IteratorStateMachineAttribute("NuGet.Commands.LockFileUtils/<ConvertToProjectPaths>d__15")]
private static IEnumerable`1<LockFileItem> ConvertToProjectPaths(Dictionary`2<string, ProjectRestoreMetadataFile> fileLookup, string projectDir, IEnumerable`1<LockFileItem> items);
    [IteratorStateMachineAttribute("NuGet.Commands.LockFileUtils/<GetLockFileItems>d__16")]
private static IEnumerable`1<LockFileItem> GetLockFileItems(List`1<SelectionCriteria> criteria, ContentItemCollection items, Action`1<LockFileItem> additionalAction, PatternSet[] patterns);
    private static IEnumerable`1<LockFileItem> GetLockFileItems(List`1<SelectionCriteria> criteria, ContentItemCollection items, PatternSet[] patterns);
    [IteratorStateMachineAttribute("NuGet.Commands.LockFileUtils/<GetBuildItemsForPackageId>d__18")]
private static IEnumerable`1<LockFileItem> GetBuildItemsForPackageId(IEnumerable`1<LockFileItem> items, string packageId);
    private static List`1<SelectionCriteria> CreateCriteria(ManagedCodeConventions conventions, NuGetFramework framework, string runtimeIdentifier);
    private static void ClearIfExists(IList`1<T> group);
    private static bool GroupHasNonEmptyItems(IEnumerable`1<LockFileItem> group);
    private static List`1<ContentItemGroup> GetContentGroupsForFramework(NuGetFramework framework, List`1<ContentItemGroup> contentGroups, string primaryKey);
    private static List`1<LockFileRuntimeTarget> GetRuntimeTargetLockFileItems(ContentItemCollection contentItems, NuGetFramework framework, LibraryIncludeFlags dependencyType, LibraryIncludeFlags groupType, PatternSet patternSet, string assetType);
    private static List`1<LockFileRuntimeTarget> GetRuntimeTargetItems(List`1<ContentItemGroup> groups, string assetType);
    public static string ToDirectorySeparator(string path);
    private static PackageDependency GetDependencyVersionRange(LibraryDependency dependency);
    public static void ExcludeItems(LockFileTargetLibrary lockFileLib, LibraryIncludeFlags dependencyType);
}
internal class NuGet.Commands.MSBuildItem : object {
    private IDictionary`2<string, string> _metadata;
    [CompilerGeneratedAttribute]
private string <Identity>k__BackingField;
    public string Identity { get; }
    public IReadOnlyList`1<string> Properties { get; }
    public MSBuildItem(string identity, IDictionary`2<string, string> metadata);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Identity();
    public sealed virtual IReadOnlyList`1<string> get_Properties();
    public sealed virtual string GetProperty(string property);
    public sealed virtual string GetProperty(string property, bool trim);
    public virtual string ToString();
}
internal class NuGet.Commands.MSBuildItemIdentityComparer : object {
    [CompilerGeneratedAttribute]
private static MSBuildItemIdentityComparer <Default>k__BackingField;
    public static MSBuildItemIdentityComparer Default { get; }
    private static MSBuildItemIdentityComparer();
    [CompilerGeneratedAttribute]
public static MSBuildItemIdentityComparer get_Default();
    public sealed virtual bool Equals(IMSBuildItem x, IMSBuildItem y);
    public sealed virtual int GetHashCode(IMSBuildItem obj);
}
internal class NuGet.Commands.MSBuildOutputFile : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private XDocument <Content>k__BackingField;
    public string Path { get; }
    public XDocument Content { get; }
    public MSBuildOutputFile(string path, XDocument content);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public XDocument get_Content();
}
internal class NuGet.Commands.MSBuildPackTargetArgs : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<OutputLibFile> <TargetPathsToSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<OutputLibFile> <TargetPathsToAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AllowedOutputExtensionsInPackageBuildOutputFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IEnumerable`1<ContentMetadata>> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetFramework> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeBuildOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BuildOutputFolder>k__BackingField;
    public IEnumerable`1<OutputLibFile> TargetPathsToSymbols { get; public set; }
    public IEnumerable`1<OutputLibFile> TargetPathsToAssemblies { get; public set; }
    public HashSet`1<string> AllowedOutputExtensionsInPackageBuildOutputFolder { get; public set; }
    public HashSet`1<string> AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder { get; public set; }
    public string AssemblyName { get; public set; }
    public string NuspecOutputPath { get; public set; }
    public Dictionary`2<string, IEnumerable`1<ContentMetadata>> ContentFiles { get; public set; }
    public ISet`1<NuGetFramework> TargetFrameworks { get; public set; }
    public IDictionary`2<string, string> SourceFiles { get; public set; }
    public bool IncludeBuildOutput { get; public set; }
    public String[] BuildOutputFolder { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<OutputLibFile> get_TargetPathsToSymbols();
    [CompilerGeneratedAttribute]
public void set_TargetPathsToSymbols(IEnumerable`1<OutputLibFile> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<OutputLibFile> get_TargetPathsToAssemblies();
    [CompilerGeneratedAttribute]
public void set_TargetPathsToAssemblies(IEnumerable`1<OutputLibFile> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AllowedOutputExtensionsInPackageBuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_AllowedOutputExtensionsInPackageBuildOutputFolder(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_NuspecOutputPath();
    [CompilerGeneratedAttribute]
public void set_NuspecOutputPath(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IEnumerable`1<ContentMetadata>> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(Dictionary`2<string, IEnumerable`1<ContentMetadata>> value);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetFramework> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(ISet`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeBuildOutput();
    [CompilerGeneratedAttribute]
public void set_IncludeBuildOutput(bool value);
    [CompilerGeneratedAttribute]
public String[] get_BuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_BuildOutputFolder(String[] value);
}
internal class NuGet.Commands.MSBuildProjectFactory : object {
    private ILogger _logger;
    private static string SourcesFolder;
    [CompilerGeneratedAttribute]
private MSBuildPackTargetArgs <PackTargetArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private PackArgs <PackArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ProjectProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTool>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private IMachineWideSettings <MachineWideSettings>k__BackingField;
    private MSBuildPackTargetArgs PackTargetArgs { get; private set; }
    private PackArgs PackArgs { get; private set; }
    public bool IncludeSymbols { get; public set; }
    public bool Build { get; public set; }
    public Dictionary`2<string, string> ProjectProperties { get; private set; }
    public bool IsTool { get; public set; }
    public ICollection`1<ManifestFile> Files { get; public set; }
    public ILogger Logger { get; public set; }
    public IMachineWideSettings MachineWideSettings { get; public set; }
    private static MSBuildProjectFactory();
    [CompilerGeneratedAttribute]
private MSBuildPackTargetArgs get_PackTargetArgs();
    [CompilerGeneratedAttribute]
private void set_PackTargetArgs(MSBuildPackTargetArgs value);
    [CompilerGeneratedAttribute]
private PackArgs get_PackArgs();
    [CompilerGeneratedAttribute]
private void set_PackArgs(PackArgs value);
    public sealed virtual void SetIncludeSymbols(bool includeSymbols);
    [CompilerGeneratedAttribute]
public bool get_IncludeSymbols();
    [CompilerGeneratedAttribute]
public void set_IncludeSymbols(bool value);
    [CompilerGeneratedAttribute]
public bool get_Build();
    [CompilerGeneratedAttribute]
public void set_Build(bool value);
    public sealed virtual Dictionary`2<string, string> GetProjectProperties();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ProjectProperties();
    [CompilerGeneratedAttribute]
private void set_ProjectProperties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_IsTool();
    [CompilerGeneratedAttribute]
public void set_IsTool(bool value);
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ICollection`1<ManifestFile> value);
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public IMachineWideSettings get_MachineWideSettings();
    [CompilerGeneratedAttribute]
public void set_MachineWideSettings(IMachineWideSettings value);
    public static IProjectFactory ProjectCreator(PackArgs packArgs, string path);
    public sealed virtual PackageBuilder CreateBuilder(string basePath, NuGetVersion version, string suffix, bool buildIfNeeded, PackageBuilder builder);
    private void AddOutputFiles();
    private void AddOutputLibFiles(IEnumerable`1<OutputLibFile> libFiles, HashSet`1<string> allowedExtensions);
    private bool AddFileToBuilder(ManifestFile packageFile);
    private void AddContentFiles(PackageBuilder builder);
    private void AddSourceFiles();
    public static string GetTargetPathForSourceFile(string sourcePath, string projectDirectory);
    private static bool IsContentFile(string contentFileTargetPath);
    public sealed virtual WarningProperties GetWarningPropertiesForProject();
}
internal static class NuGet.Commands.MSBuildProjectFrameworkUtility : object {
    public static IEnumerable`1<string> GetProjectFrameworkStrings(string projectFilePath, string targetFrameworks, string targetFramework, string targetFrameworkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion);
    public static NuGetFramework GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformMinVersion);
    public static NuGetFramework GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformMinVersion, string clrSupport, string windowsTargetPlatformMinVersion);
    [ObsoleteAttribute("If you need ClrSupport support parameter to be accounted for in the calculation, the method with the windowsTargetPlatformMinVersion is the only correct one.")]
public static NuGetFramework GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformMinVersion, string clrSupport);
    public static IEnumerable`1<string> GetProjectFrameworkStrings(string projectFilePath, string targetFrameworks, string targetFramework, string targetFrameworkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion, bool isXnaWindowsPhoneProject, bool isManagementPackProject);
    internal static IEnumerable`1<string> GetProjectFrameworks(string projectFilePath, string targetFrameworks, string targetFramework, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion, string clrSupport, string windowsTargetPlatformMinVersion, bool isXnaWindowsPhoneProject, bool isManagementPackProject);
    internal static NuGetFramework GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion, string clrSupport, string windowsTargetPlatformMinVersion, bool isXnaWindowsPhoneProject, bool isManagementPackProject);
    private static NuGetFramework GetFrameworkFromMoniker(string platformIdentifier, string platformMoniker, string platformMinVersion);
    private static String[] GetParts(string targetPlatformMoniker);
    public static IEnumerable`1<NuGetFramework> GetProjectFrameworks(IEnumerable`1<string> frameworkStrings);
    public static NuGetFramework GetProjectFrameworkReplacement(NuGetFramework framework);
}
internal class NuGet.Commands.MSBuildRestoreItemGroup : object {
    public static string ItemGroup;
    public static string ImportGroup;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<XElement> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootName>k__BackingField;
    public int Position { get; public set; }
    public List`1<string> Conditions { get; public set; }
    public List`1<XElement> Items { get; public set; }
    public string RootName { get; public set; }
    public string Condition { get; }
    private static MSBuildRestoreItemGroup();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<XElement> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<XElement> value);
    [CompilerGeneratedAttribute]
public string get_RootName();
    [CompilerGeneratedAttribute]
public void set_RootName(string value);
    public string get_Condition();
    internal static MSBuildRestoreItemGroup Create(string rootName, int position);
    public static MSBuildRestoreItemGroup Create(string rootName, IEnumerable`1<XElement> items, int position, IEnumerable`1<string> conditions);
}
[ExtensionAttribute]
internal static class NuGet.Commands.MSBuildRestoreUtility : object {
    public static string Clear;
    private static String[] HttpPrefixes;
    private static string DoubleSlash;
    private static MSBuildRestoreUtility();
    public static DependencyGraphSpec GetDependencySpec(IEnumerable`1<IMSBuildItem> items);
    public static DependencyGraphSpec GetDependencySpec(IEnumerable`1<IMSBuildItem> items, bool readOnly);
    public static void ApplyIncludeFlags(LibraryDependency dependency, string includeAssets, string excludeAssets, string privateAssets);
    public static void ApplyIncludeFlags(ProjectRestoreReference dependency, string includeAssets, string excludeAssets, string privateAssets);
    public static PackageSpec GetPackageSpec(IEnumerable`1<IMSBuildItem> items);
    public static void RemoveMissingProjects(DependencyGraphSpec graphSpec);
    public static void NormalizePathCasings(Dictionary`2<string, string> paths, DependencyGraphSpec graphSpec);
    public static void NormalizePathCasings(IDictionary`2<string, string> paths, DependencyGraphSpec graphSpec);
    public static bool ContainsClearKeyword(IEnumerable`1<string> values);
    public static bool HasInvalidClear(IEnumerable`1<string> values);
    public static bool LogErrorForClearIfInvalid(IEnumerable`1<string> values, string projectPath, ILogger logger);
    public static RestoreLogMessage GetWarningForUnsupportedProject(string path);
    public static RestoreLogMessage GetMessageForUnsupportedProject(string path);
    [IteratorStateMachineAttribute("NuGet.Commands.MSBuildRestoreUtility/<GetTargetFrameworkInformation>d__16")]
private static IEnumerable`1<TargetFrameworkInformation> GetTargetFrameworkInformation(string filePath, ProjectStyle restoreType, IEnumerable`1<IMSBuildItem> items);
    public static IEnumerable`1<string> AggregateSources(IEnumerable`1<string> values, IEnumerable`1<string> excludeValues);
    private static RuntimeGraph GetRuntimeGraph(IMSBuildItem specItem);
    private static void AddProjectReferences(PackageSpec spec, IEnumerable`1<IMSBuildItem> items);
    private static Tuple`2<List`1<string>, ProjectRestoreReference> GetProjectRestoreReference(IMSBuildItem item);
    private static bool AddDownloadDependencyIfNotExist(PackageSpec spec, string targetAlias, DownloadDependency dependency);
    private static bool AddDependencyIfNotExist(PackageSpec spec, LibraryDependency dependency);
    private static bool AddDependencyIfNotExist(PackageSpec spec, string targetAlias, LibraryDependency dependency);
    private static void AddPackageReferences(PackageSpec spec, IEnumerable`1<IMSBuildItem> items, bool isCpvmEnabled);
    internal static void AddPackageDownloads(PackageSpec spec, IEnumerable`1<IMSBuildItem> items);
    private static void ApplyIncludeFlags(LibraryDependency dependency, IMSBuildItem item);
    private static LibraryIncludeFlags GetIncludeFlags(string value, LibraryIncludeFlags defaultValue);
    private static void AddFrameworkReferences(PackageSpec spec, IEnumerable`1<IMSBuildItem> items);
    private static bool AddFrameworkReferenceIfNotExists(PackageSpec spec, string targetAlias, string frameworkReference, string privateAssetsValue);
    private static VersionRange GetVersionRange(IMSBuildItem item, VersionRange defaultValue, string propertyName);
    private static VersionRange GetVersionRange(string rangeString, VersionRange defaultValue);
    private static PackageSpec GetProjectJsonSpec(IMSBuildItem specItem);
    private static PackageSpec GetBaseSpec(IMSBuildItem specItem, ProjectStyle projectStyle, IEnumerable`1<IMSBuildItem> items);
    private static HashSet`1<string> GetFrameworks(IMSBuildItem item);
    private static HashSet`1<string> GetTargetFrameworkStrings(IMSBuildItem item);
    private static IEnumerable`1<IMSBuildItem> GetItemByType(IEnumerable`1<IMSBuildItem> items, string type);
    [ExtensionAttribute]
private static bool IsType(IMSBuildItem item, string type);
    private static NuGetVersion GetVersion(IMSBuildItem item);
    public static void Dump(IEnumerable`1<IMSBuildItem> items, ILogger log);
    private static WarningProperties GetWarningProperties(IMSBuildItem specItem);
    private static RestoreLockProperties GetRestoreLockProperties(IMSBuildItem specItem);
    public static RestoreAuditProperties GetRestoreAuditProperties(IMSBuildItem specItem, HashSet`1<string> suppressionItems);
    private static HashSet`1<string> GetAuditSuppressions(IEnumerable`1<IMSBuildItem> items);
    public static string FixSourcePath(string s);
    private static string FixSourcePath(string s, string prefixWithoutSlashes, string slashes);
    internal static bool IsPropertyFalse(IMSBuildItem item, string propertyName, bool defaultValue);
    internal static bool IsPropertyTrue(IMSBuildItem item, string propertyName, bool defaultValue);
    public static Task ReplayWarningsAndErrorsAsync(IEnumerable`1<IAssetsLogMessage> messages, ILogger logger);
    private static Dictionary`2<string, Dictionary`2<string, CentralPackageVersion>> CreateCentralVersionDependencies(IEnumerable`1<IMSBuildItem> items, IList`1<TargetFrameworkInformation> specFrameworks);
    private static void AddCentralPackageVersion(Dictionary`2<string, Dictionary`2<string, CentralPackageVersion>> centralPackageVersions, CentralPackageVersion centralPackageVersion, IEnumerable`1<string> frameworks);
    private static ProjectStyle GetProjectStyle(IMSBuildItem projectSpecItem);
    public static ValueTuple`4<bool, bool, bool, bool> GetCentralPackageManagementSettings(IMSBuildItem projectSpecItem, ProjectStyle projectStyle);
    private static void AddCentralPackageVersions(PackageSpec spec, IEnumerable`1<IMSBuildItem> items);
}
internal class NuGet.Commands.NoOpRestoreResult : RestoreResult {
    private Lazy`1<LockFile> _lockFileLazy;
    public LockFile LockFile { get; }
    public LockFile PreviousLockFile { get; }
    public NoOpRestoreResult(bool success, string lockFilePath, Lazy`1<LockFile> lockFileLazy, CacheFile cacheFile, string cacheFilePath, ProjectStyle projectStyle, TimeSpan elapsedTime);
    public virtual LockFile get_LockFile();
    public virtual LockFile get_PreviousLockFile();
    public virtual Task CommitAsync(ILogger log, CancellationToken token);
    public virtual ISet`1<LibraryIdentity> GetAllInstalled();
    internal virtual IReadOnlyList`1<string> GetDirtyFiles();
}
internal static class NuGet.Commands.NoOpRestoreUtilities : object {
    internal static string NoOpCacheFileName;
    internal static bool IsNoOpSupported(RestoreRequest request);
    private static string GetBuildIntegratedProjectCacheFilePath(RestoreRequest request);
    public static string GetProjectCacheFilePath(string cacheRoot, string projectPath);
    public static string GetProjectCacheFilePath(string cacheRoot);
    internal static string GetToolCacheFilePath(RestoreRequest request, LockFile lockFile);
    internal static string GetToolCacheFilePath(string toolDirectory, string toolName);
    internal static string GetCacheFilePath(RestoreRequest request);
    internal static string GetCacheFilePath(RestoreRequest request, LockFile lockFile);
    internal static bool VerifyRestoreOutput(RestoreRequest request, CacheFile cacheFile);
    internal static DependencyGraphSpec GetNoOpDgSpec(RestoreRequest request);
    internal static string GetPersistedDGSpecFilePath(RestoreRequest request);
    internal static void UpdateRequestBestMatchingToolPathsIfAvailable(RestoreRequest request);
    internal static List`1<string> GetRestoreOutput(RestoreRequest request, LockFile lockFile);
    [IteratorStateMachineAttribute("NuGet.Commands.NoOpRestoreUtilities/<GetPackageFiles>d__14")]
private static IEnumerable`1<string> GetPackageFiles(LocalPackageFileCache packageFileCache, string packageId, NuGetVersion version, List`1<VersionFolderPathResolver> resolvers);
}
internal class NuGet.Commands.OriginalCaseGlobalPackageFolder : object {
    private List`1<NuGetv3LocalRepository> _localRepositories;
    private RestoreRequest _request;
    private ToolPathResolver _toolPathResolver;
    private VersionFolderPathResolver _pathResolver;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    public Guid ParentId { get; }
    public OriginalCaseGlobalPackageFolder(RestoreRequest request);
    public OriginalCaseGlobalPackageFolder(RestoreRequest request, Guid parentId);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [AsyncStateMachineAttribute("NuGet.Commands.OriginalCaseGlobalPackageFolder/<CopyPackagesToOriginalCaseAsync>d__9")]
public Task CopyPackagesToOriginalCaseAsync(IEnumerable`1<RestoreTargetGraph> graphs, CancellationToken token);
    public void ConvertLockFileToOriginalCase(LockFile lockFile);
    private PackageExtractionContext GetPathContext();
    private static PackageIdentity GetPackageIdentity(RemoteMatch remoteMatch);
    private LocalPackageSourceInfo GetLocalPackageSourceInfo(RemoteMatch remoteMatch);
}
internal class NuGet.Commands.OutputLibFile : ValueType {
    [CompilerGeneratedAttribute]
private string <FinalOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    public string FinalOutputPath { get; public set; }
    public string TargetPath { get; public set; }
    public string TargetFramework { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FinalOutputPath();
    [CompilerGeneratedAttribute]
public void set_FinalOutputPath(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TargetPath();
    [CompilerGeneratedAttribute]
public void set_TargetPath(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
}
internal class NuGet.Commands.PackagesLockFileBuilder : object {
    public PackagesLockFile CreateNuGetLockFile(LockFile assetsFile);
    private int GetPackagesLockFileVersion(LockFile assetsFile);
}
[ExtensionAttribute]
internal static class NuGet.Commands.PackageSourceProviderExtensions : object {
    public static PackageSource ResolveSource(IEnumerable`1<PackageSource> availableSources, string source);
    [ExtensionAttribute]
public static string ResolveAndValidateSource(IPackageSourceProvider sourceProvider, string source);
    private static void ValidateSource(string source);
}
internal class NuGet.Commands.PackageSpecificWarningProperties : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> <Properties>k__BackingField;
    public IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> Properties { get; private set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> value);
    public static PackageSpecificWarningProperties CreatePackageSpecificWarningProperties(PackageSpec packageSpec);
    public static PackageSpecificWarningProperties CreatePackageSpecificWarningProperties(PackageSpec packageSpec, NuGetFramework framework);
    public void Add(NuGetLogCode code, string libraryId, NuGetFramework framework);
    public void AddRangeOfCodes(IEnumerable`1<NuGetLogCode> codes, string libraryId, NuGetFramework framework);
    public void AddRangeOfFrameworks(NuGetLogCode code, string libraryId, IEnumerable`1<NuGetFramework> frameworks);
    public bool Contains(NuGetLogCode code, string libraryId, NuGetFramework framework);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageSpecificWarningProperties other);
}
internal class NuGet.Commands.PackArgs : object {
    private string _currentDirectory;
    private Dictionary`2<string, string> _properties;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeEmptyDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeReferencedProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstallPackageToOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IMachineWideSettings <MachineWideSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolPackageFormat <SymbolPackageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<string> <MsBuildDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoDefaultExcludes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoPackageAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputFileNamesWithoutVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Tool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningProperties <WarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private MSBuildPackTargetArgs <PackTargetArgs>k__BackingField;
    public IEnumerable`1<string> Arguments { get; public set; }
    public string BasePath { get; public set; }
    public bool Build { get; public set; }
    public IEnumerable`1<string> Exclude { get; public set; }
    public bool ExcludeEmptyDirectories { get; public set; }
    public ILogger Logger { get; public set; }
    public LogLevel LogLevel { get; public set; }
    public bool IncludeReferencedProjects { get; public set; }
    public bool InstallPackageToOutputPath { get; public set; }
    public IMachineWideSettings MachineWideSettings { get; public set; }
    public Version MinClientVersion { get; public set; }
    public SymbolPackageFormat SymbolPackageFormat { get; public set; }
    public Lazy`1<string> MsBuildDirectory { get; public set; }
    public bool NoDefaultExcludes { get; public set; }
    public bool NoPackageAnalysis { get; public set; }
    public string OutputDirectory { get; public set; }
    public bool OutputFileNamesWithoutVersion { get; public set; }
    public string PackagesDirectory { get; public set; }
    public string Path { get; public set; }
    public bool Serviceable { get; public set; }
    public string SolutionDirectory { get; public set; }
    public string Suffix { get; public set; }
    public bool Symbols { get; public set; }
    public bool Tool { get; public set; }
    public string Version { get; public set; }
    public bool Deterministic { get; public set; }
    public WarningProperties WarningProperties { get; public set; }
    public MSBuildPackTargetArgs PackTargetArgs { get; public set; }
    public Dictionary`2<string, string> Properties { get; }
    public string CurrentDirectory { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
public void set_BasePath(string value);
    [CompilerGeneratedAttribute]
public bool get_Build();
    [CompilerGeneratedAttribute]
public void set_Build(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeEmptyDirectories();
    [CompilerGeneratedAttribute]
public void set_ExcludeEmptyDirectories(bool value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public bool get_IncludeReferencedProjects();
    [CompilerGeneratedAttribute]
public void set_IncludeReferencedProjects(bool value);
    [CompilerGeneratedAttribute]
public bool get_InstallPackageToOutputPath();
    [CompilerGeneratedAttribute]
public void set_InstallPackageToOutputPath(bool value);
    [CompilerGeneratedAttribute]
public IMachineWideSettings get_MachineWideSettings();
    [CompilerGeneratedAttribute]
public void set_MachineWideSettings(IMachineWideSettings value);
    [CompilerGeneratedAttribute]
public Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public SymbolPackageFormat get_SymbolPackageFormat();
    [CompilerGeneratedAttribute]
public void set_SymbolPackageFormat(SymbolPackageFormat value);
    [CompilerGeneratedAttribute]
public Lazy`1<string> get_MsBuildDirectory();
    [CompilerGeneratedAttribute]
public void set_MsBuildDirectory(Lazy`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_NoDefaultExcludes();
    [CompilerGeneratedAttribute]
public void set_NoDefaultExcludes(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoPackageAnalysis();
    [CompilerGeneratedAttribute]
public void set_NoPackageAnalysis(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_OutputFileNamesWithoutVersion();
    [CompilerGeneratedAttribute]
public void set_OutputFileNamesWithoutVersion(bool value);
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_PackagesDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public string get_SolutionDirectory();
    [CompilerGeneratedAttribute]
public void set_SolutionDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public void set_Suffix(string value);
    [CompilerGeneratedAttribute]
public bool get_Symbols();
    [CompilerGeneratedAttribute]
public void set_Symbols(bool value);
    [CompilerGeneratedAttribute]
public bool get_Tool();
    [CompilerGeneratedAttribute]
public void set_Tool(bool value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Deterministic();
    [CompilerGeneratedAttribute]
public void set_Deterministic(bool value);
    [CompilerGeneratedAttribute]
public WarningProperties get_WarningProperties();
    [CompilerGeneratedAttribute]
public void set_WarningProperties(WarningProperties value);
    [CompilerGeneratedAttribute]
public MSBuildPackTargetArgs get_PackTargetArgs();
    [CompilerGeneratedAttribute]
public void set_PackTargetArgs(MSBuildPackTargetArgs value);
    public Dictionary`2<string, string> get_Properties();
    public string get_CurrentDirectory();
    public void set_CurrentDirectory(string value);
    public string GetPropertyValue(string propertyName);
    public static SymbolPackageFormat GetSymbolPackageFormat(string symbolPackageFormat);
}
internal class NuGet.Commands.PackCollectorLogger : LoggerBase {
    private ConcurrentQueue`1<ILogMessage> _errors;
    private ILogger _innerLogger;
    [CompilerGeneratedAttribute]
private WarningProperties <WarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpecificWarningProperties <PackageSpecificWarningProperties>k__BackingField;
    public WarningProperties WarningProperties { get; public set; }
    private PackageSpecificWarningProperties PackageSpecificWarningProperties { get; private set; }
    public IEnumerable`1<ILogMessage> Errors { get; }
    public PackCollectorLogger(ILogger innerLogger, WarningProperties warningProperties);
    public PackCollectorLogger(ILogger innerLogger, WarningProperties warningProperties, PackageSpecificWarningProperties packageSpecificWarningProperties);
    [CompilerGeneratedAttribute]
public WarningProperties get_WarningProperties();
    [CompilerGeneratedAttribute]
public void set_WarningProperties(WarningProperties value);
    [CompilerGeneratedAttribute]
private PackageSpecificWarningProperties get_PackageSpecificWarningProperties();
    [CompilerGeneratedAttribute]
private void set_PackageSpecificWarningProperties(PackageSpecificWarningProperties value);
    public IEnumerable`1<ILogMessage> get_Errors();
    public virtual void Log(ILogMessage message);
    public virtual Task LogAsync(ILogMessage message);
    private bool IsWarningSuppressed(ILogMessage message);
    private void UpgradeWarningToErrorIfNeeded(ILogMessage message);
    private bool DisplayMessage(ILogMessage message);
}
internal class NuGet.Commands.PackCommand.PackageSpecificWarningProperties : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> <Properties>k__BackingField;
    internal IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> Properties { get; private set; }
    [CompilerGeneratedAttribute]
internal IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> value);
    public static PackageSpecificWarningProperties CreatePackageSpecificWarningProperties(IDictionary`2<string, HashSet`1<ValueTuple`2<NuGetLogCode, NuGetFramework>>> noWarnProperties);
    internal void Add(NuGetLogCode code, string libraryId, NuGetFramework framework);
    internal bool Contains(NuGetLogCode code, string libraryId, NuGetFramework framework);
    internal bool ApplyNoWarnProperties(IPackLogMessage message);
    private bool ApplyPackageSpecificNoWarnProperties(IPackLogMessage message);
}
internal class NuGet.Commands.PackCommandRunner : object {
    private PackArgs _packArgs;
    private PackageBuilder _packageBuilder;
    private CreateProjectFactory _createProjectFactory;
    private static HashSet`1<string> AllowedExtensions;
    private static String[] LibPackageExcludes;
    private static String[] SymbolPackageExcludes;
    private HashSet`1<string> _excludes;
    [CompilerGeneratedAttribute]
private bool <GenerateNugetPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPackageRule> <Rules>k__BackingField;
    public bool GenerateNugetPackage { get; public set; }
    public IEnumerable`1<IPackageRule> Rules { get; public set; }
    public PackCommandRunner(PackArgs packArgs, CreateProjectFactory createProjectFactory, PackageBuilder packageBuilder);
    public PackCommandRunner(PackArgs packArgs, CreateProjectFactory createProjectFactory);
    private static PackCommandRunner();
    [CompilerGeneratedAttribute]
public bool get_GenerateNugetPackage();
    [CompilerGeneratedAttribute]
public void set_GenerateNugetPackage(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IPackageRule> get_Rules();
    [CompilerGeneratedAttribute]
public void set_Rules(IEnumerable`1<IPackageRule> value);
    public bool RunPackageBuild();
    [ObsoleteAttribute("Do not use this. Use RunPackageBuild() instead as it accounts for the effects of package analysis to the complete operation status.")]
public void BuildPackage();
    private bool BuildPackage(string path);
    [ObsoleteAttribute("Do not use this. Use RunPackageBuild() instead as it accounts for the effects of package analysis to the complete operation status.")]
public PackageArchiveReader BuildPackage(PackageBuilder builder, string outputPath);
    private bool BuildPackage(PackageBuilder builder, string outputPath, bool symbolsPackage);
    private void WriteResolvedNuSpecToPackageOutputDirectory(PackageBuilder builder);
    private void WriteSHA512PackageHash(PackageBuilder builder);
    private void InitCommonPackageBuilderProperties(PackageBuilder builder);
    [ObsoleteAttribute]
public static bool ProcessProjectJsonFile(PackageBuilder builder, string basePath, string id, NuGetVersion version, string suffix, Func`2<string, string> propertyProvider);
    [ObsoleteAttribute]
private static void LoadProjectJsonFile(PackageBuilder builder, string path, string basePath, string id, Stream stream, NuGetVersion version, string suffix);
    private static void CalculateExcludes(IncludeExcludeFiles files, String& fullExclude, String& filesExclude);
    public static void AddDependencyGroups(IEnumerable`1<LibraryDependency> dependencies, NuGetFramework framework, PackageBuilder builder);
    private bool BuildFromNuspec(string path);
    private PackageBuilder CreatePackageBuilderFromNuspec(string path);
    private bool BuildFromProjectFile(string path);
    private void CheckForUnsupportedFrameworks(PackageBuilder builder);
    private void PrintVerbose(string outputPath, PackageBuilder builder);
    internal void ExcludeFiles(ICollection`1<IPackageFile> packageFiles);
    private IEnumerable`1<IPackageFile> RemoveDefaultExclusions(ICollection`1<IPackageFile> packageFiles);
    private string ResolvePath(IPackageFile packageFile);
    private static string ResolvePath(IPackageFile packageFile, string basePath);
    private bool BuildSymbolsPackage(string path);
    internal void AnalyzePackage(PackageArchiveReader package);
    private void PrintPackageLogMessage(PackagingLogMessage message);
    internal static void ExcludeFilesForLibPackage(ICollection`1<IPackageFile> files);
    internal static void ExcludeFilesForSymbolPackage(ICollection`1<IPackageFile> files, SymbolPackageFormat symbolPackageFormat);
    public static string GetOutputPath(PackageBuilder builder, PackArgs packArgs, bool symbols, NuGetVersion nugetVersion, string outputDirectory, bool isNupkg);
    public static string GetOutputFileName(string packageId, NuGetVersion version, bool isNupkg, bool symbols, SymbolPackageFormat symbolPackageFormat, bool excludeVersion);
    public static void SetupCurrentDirectory(PackArgs packArgs);
    public static string GetInputFile(PackArgs packArgs);
    internal static string GetInputFile(PackArgs packArgs, IEnumerable`1<string> files);
    private void WriteLine(string message, object arg);
    public static void AddLibraryDependency(LibraryDependency dependency, ISet`1<LibraryDependency> list);
    public static void AddPackageDependency(PackageDependency dependency, ISet`1<PackageDependency> set);
}
internal class NuGet.Commands.ProjectRestoreCommand : object {
    private RestoreCollectorLogger _logger;
    private ProjectRestoreRequest _request;
    private static string WalkFrameworkDependencyDuration;
    private static string WalkRuntimeDependencyDuration;
    private static string EvaluateDownloadDependenciesDuration;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    public Guid ParentId { get; }
    public ProjectRestoreCommand(ProjectRestoreRequest request);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<TryRestoreAsync>d__9")]
public Task`1<Tuple`3<bool, List`1<RestoreTargetGraph>, RuntimeGraph>> TryRestoreAsync(LibraryRange projectRange, IEnumerable`1<FrameworkRuntimePair> frameworkRuntimePairs, NuGetv3LocalRepository userPackageFolder, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, RemoteDependencyWalker remoteWalker, RemoteWalkContext context, bool forceRuntimeGraphCreation, CancellationToken token, TelemetryActivity telemetryActivity, string telemetryPrefix);
    private RuntimeGraph GetRuntimeGraph(string runtimeGraphPath);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<ResolveDownloadDependenciesAsync>d__11")]
private Task`1<DownloadDependencyResolutionResult> ResolveDownloadDependenciesAsync(RemoteWalkContext context, TargetFrameworkInformation targetFrameworkInformation, CancellationToken token);
    private Task`1<RestoreTargetGraph> WalkDependenciesAsync(LibraryRange projectRange, NuGetFramework framework, RemoteDependencyWalker walker, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<WalkDependenciesAsync>d__13")]
private Task`1<RestoreTargetGraph> WalkDependenciesAsync(LibraryRange projectRange, NuGetFramework framework, string runtimeIdentifier, RuntimeGraph runtimeGraph, RemoteDependencyWalker walker, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<ResolutionSucceeded>d__14")]
private Task`1<bool> ResolutionSucceeded(IEnumerable`1<RestoreTargetGraph> graphs, IList`1<DownloadDependencyResolutionResult> downloadDependencyResults, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<InstallPackagesAsync>d__15")]
private Task`1<bool> InstallPackagesAsync(HashSet`1<LibraryIdentity> uniquePackages, IEnumerable`1<RestoreTargetGraph> graphs, IList`1<DownloadDependencyResolutionResult> downloadDependencyInformations, NuGetv3LocalRepository userPackageFolder, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<InstallPackageAsync>d__16")]
private Task`1<bool> InstallPackageAsync(RemoteMatch installItem, NuGetv3LocalRepository userPackageFolder, PackageExtractionContext packageExtractionContext, CancellationToken token);
    private Task`1<RestoreTargetGraph[]> WalkRuntimeDependenciesAsync(LibraryRange projectRange, RestoreTargetGraph graph, IEnumerable`1<string> runtimeIds, RemoteDependencyWalker walker, RemoteWalkContext context, RuntimeGraph runtimes, CancellationToken token);
    private RuntimeGraph GetRuntimeGraph(RestoreTargetGraph graph, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, RuntimeGraph projectRuntimeGraph);
}
internal class NuGet.Commands.ProjectRestoreRequest : object {
    [CompilerGeneratedAttribute]
private SourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreCollectorLogger <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFile <ExistingLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpec <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageExtractionContext <PackageExtractionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    public SourceCacheContext CacheContext { get; }
    public RestoreCollectorLogger Log { get; }
    public string PackagesDirectory { get; }
    public int MaxDegreeOfConcurrency { get; }
    public LockFile ExistingLockFile { get; }
    public PackageSpec Project { get; }
    public PackageExtractionContext PackageExtractionContext { get; }
    public Guid ParentId { get; public set; }
    public ProjectRestoreRequest(RestoreRequest request, PackageSpec packageSpec, LockFile existingLockFile, RestoreCollectorLogger log);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public RestoreCollectorLogger get_Log();
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfConcurrency();
    [CompilerGeneratedAttribute]
public LockFile get_ExistingLockFile();
    [CompilerGeneratedAttribute]
public PackageSpec get_Project();
    [CompilerGeneratedAttribute]
public PackageExtractionContext get_PackageExtractionContext();
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
}
internal static class NuGet.Commands.PushRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.PushRunner/<Run>d__0")]
public static Task Run(ISettings settings, IPackageSourceProvider sourceProvider, IList`1<string> packagePaths, string source, string apiKey, string symbolSource, string symbolApiKey, int timeoutSeconds, bool disableBuffering, bool noSymbols, bool noServiceEndpoint, bool skipDuplicate, ILogger logger);
    [ObsoleteAttribute("Use Run method which takes multiple package paths.")]
public static Task Run(ISettings settings, IPackageSourceProvider sourceProvider, string packagePath, string source, string apiKey, string symbolSource, string symbolApiKey, int timeoutSeconds, bool disableBuffering, bool noSymbols, bool noServiceEndpoint, bool skipDuplicate, ILogger logger);
}
internal class NuGet.Commands.RemoveClientCertArgs : object {
    [CompilerGeneratedAttribute]
private string <PackageSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string PackageSource { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageSource();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageSource(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configfile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configfile(string value);
}
internal static class NuGet.Commands.RemoveClientCertRunner : object {
    public static void Run(RemoveClientCertArgs args, Func`1<ILogger> getLogger);
}
internal class NuGet.Commands.RemoveSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Name { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
internal static class NuGet.Commands.RemoveSourceRunner : object {
    public static void Run(RemoveSourceArgs args, Func`1<ILogger> getLogger);
}
internal static class NuGet.Commands.RequestRuntimeUtility : object {
    internal static ISet`1<string> GetRestoreRuntimes(RestoreRequest request);
    [IteratorStateMachineAttribute("NuGet.Commands.RequestRuntimeUtility/<GetDefaultRestoreRuntimes>d__1")]
public static IEnumerable`1<string> GetDefaultRestoreRuntimes(string os, string runtimeOsName);
}
[IsReadOnlyAttribute]
internal class NuGet.Commands.ResolvedDependencyKey : ValueType {
    [CompilerGeneratedAttribute]
private LibraryIdentity <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIdentity <Child>k__BackingField;
    public LibraryIdentity Parent { get; }
    public VersionRange Range { get; }
    public LibraryIdentity Child { get; }
    public ResolvedDependencyKey(LibraryIdentity parent, VersionRange range, LibraryIdentity child);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Parent();
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Child();
    public sealed virtual bool Equals(ResolvedDependencyKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ResolvedDependencyKey left, ResolvedDependencyKey right);
    public static bool op_Inequality(ResolvedDependencyKey left, ResolvedDependencyKey right);
}
internal class NuGet.Commands.ResolverConflict : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ResolverRequest> <Requests>k__BackingField;
    public string Name { get; }
    public IList`1<ResolverRequest> Requests { get; }
    public ResolverConflict(string name, IEnumerable`1<ResolverRequest> requests);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<ResolverRequest> get_Requests();
}
internal class NuGet.Commands.ResolverRequest : object {
    [CompilerGeneratedAttribute]
private LibraryIdentity <Requestor>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryRange <Request>k__BackingField;
    public LibraryIdentity Requestor { get; }
    public LibraryRange Request { get; }
    public ResolverRequest(LibraryIdentity requestor, LibraryRange request);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Requestor();
    [CompilerGeneratedAttribute]
public LibraryRange get_Request();
    public virtual string ToString();
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
internal class NuGet.Commands.Restore.Utility.AuditUtility : object {
    [NuGet.Commands.NullableAttribute("2")]
private RestoreAuditProperties _restoreAuditProperties;
    private string _projectFullPath;
    private IEnumerable`1<RestoreTargetGraph> _targetGraphs;
    private IReadOnlyList`1<IVulnerabilityInformationProvider> _vulnerabilityInfoProviders;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private PackageVulnerabilitySeverity <MinSeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetAuditMode <AuditMode>k__BackingField;
    [NuGet.Commands.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, bool> <SuppressedAdvisories>k__BackingField;
    [NuGet.Commands.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <DirectPackagesWithAdvisory>k__BackingField;
    [NuGet.Commands.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <TransitivePackagesWithAdvisory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev0DirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev1DirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev2DirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev3DirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InvalidSevDirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev0TransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev1TransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev2TransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev3TransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InvalidSevTransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DownloadDurationSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <CheckPackagesDurationSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <GenerateOutputDurationSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourcesWithVulnerabilityData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DistinctAdvisoriesSuppressedCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalWarningsSuppressedCount>k__BackingField;
    internal PackageVulnerabilitySeverity MinSeverity { get; }
    internal NuGetAuditMode AuditMode { get; }
    [NuGet.Commands.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<string, bool> SuppressedAdvisories { get; }
    [NuGet.Commands.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<string> DirectPackagesWithAdvisory { get; private set; }
    [NuGet.Commands.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<string> TransitivePackagesWithAdvisory { get; private set; }
    internal int Sev0DirectMatches { get; private set; }
    internal int Sev1DirectMatches { get; private set; }
    internal int Sev2DirectMatches { get; private set; }
    internal int Sev3DirectMatches { get; private set; }
    internal int InvalidSevDirectMatches { get; private set; }
    internal int Sev0TransitiveMatches { get; private set; }
    internal int Sev1TransitiveMatches { get; private set; }
    internal int Sev2TransitiveMatches { get; private set; }
    internal int Sev3TransitiveMatches { get; private set; }
    internal int InvalidSevTransitiveMatches { get; private set; }
    internal Nullable`1<double> DownloadDurationSeconds { get; private set; }
    internal Nullable`1<double> CheckPackagesDurationSeconds { get; private set; }
    internal Nullable`1<double> GenerateOutputDurationSeconds { get; private set; }
    internal int SourcesWithVulnerabilityData { get; private set; }
    internal int DistinctAdvisoriesSuppressedCount { get; private set; }
    internal int TotalWarningsSuppressedCount { get; private set; }
    public AuditUtility(RestoreAuditProperties restoreAuditProperties, string projectFullPath, IEnumerable`1<RestoreTargetGraph> graphs, IReadOnlyList`1<IVulnerabilityInformationProvider> vulnerabilityInformationProviders, ILogger logger);
    [CompilerGeneratedAttribute]
internal PackageVulnerabilitySeverity get_MinSeverity();
    [CompilerGeneratedAttribute]
internal NuGetAuditMode get_AuditMode();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, bool> get_SuppressedAdvisories();
    [CompilerGeneratedAttribute]
internal List`1<string> get_DirectPackagesWithAdvisory();
    [CompilerGeneratedAttribute]
private void set_DirectPackagesWithAdvisory(List`1<string> value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_TransitivePackagesWithAdvisory();
    [CompilerGeneratedAttribute]
private void set_TransitivePackagesWithAdvisory(List`1<string> value);
    [CompilerGeneratedAttribute]
internal int get_Sev0DirectMatches();
    [CompilerGeneratedAttribute]
private void set_Sev0DirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev1DirectMatches();
    [CompilerGeneratedAttribute]
private void set_Sev1DirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev2DirectMatches();
    [CompilerGeneratedAttribute]
private void set_Sev2DirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev3DirectMatches();
    [CompilerGeneratedAttribute]
private void set_Sev3DirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_InvalidSevDirectMatches();
    [CompilerGeneratedAttribute]
private void set_InvalidSevDirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev0TransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_Sev0TransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev1TransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_Sev1TransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev2TransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_Sev2TransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev3TransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_Sev3TransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_InvalidSevTransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_InvalidSevTransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_DownloadDurationSeconds();
    [CompilerGeneratedAttribute]
private void set_DownloadDurationSeconds(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_CheckPackagesDurationSeconds();
    [CompilerGeneratedAttribute]
private void set_CheckPackagesDurationSeconds(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_GenerateOutputDurationSeconds();
    [CompilerGeneratedAttribute]
private void set_GenerateOutputDurationSeconds(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
internal int get_SourcesWithVulnerabilityData();
    [CompilerGeneratedAttribute]
private void set_SourcesWithVulnerabilityData(int value);
    [CompilerGeneratedAttribute]
internal int get_DistinctAdvisoriesSuppressedCount();
    [CompilerGeneratedAttribute]
private void set_DistinctAdvisoriesSuppressedCount(int value);
    [CompilerGeneratedAttribute]
internal int get_TotalWarningsSuppressedCount();
    [CompilerGeneratedAttribute]
private void set_TotalWarningsSuppressedCount(int value);
    [AsyncStateMachineAttribute("NuGet.Commands.Restore.Utility.AuditUtility/<CheckPackageVulnerabilitiesAsync>d__87")]
public Task CheckPackageVulnerabilitiesAsync(CancellationToken cancellationToken);
    private void ReplayErrors(AggregateException exceptions);
    private void CheckPackageVulnerabilities(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
    private static List`1<PackageVulnerabilityInfo> GetKnownVulnerabilities(string name, NuGetVersion version, IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
    private static ValueTuple`2<string, NuGetLogCode> GetSeverityLabelAndCode(PackageVulnerabilitySeverity severity);
    private Dictionary`2<PackageIdentity, PackageAuditInfo> FindPackagesWithKnownVulnerabilities(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
    [AsyncStateMachineAttribute("NuGet.Commands.Restore.Utility.AuditUtility/<GetAllVulnerabilityDataAsync>d__93")]
private Task`1<GetVulnerabilityInfoResult> GetAllVulnerabilityDataAsync(CancellationToken cancellationToken);
    private PackageVulnerabilitySeverity ParseAuditLevel();
    private NuGetAuditMode ParseAuditMode();
    public static bool ParseEnableValue(RestoreAuditProperties value, string projectFullPath, ILogger logger);
    internal static string GetString(NuGetAuditMode auditMode);
    [CompilerGeneratedAttribute]
private bool <CheckPackageVulnerabilitiesAsync>g__HasPackages|87_0();
    [CompilerGeneratedAttribute]
internal static bool <CheckPackageVulnerabilitiesAsync>g__AnyVulnerabilityDataFound|87_1(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
}
internal class NuGet.Commands.RestoreArgs : object {
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IMachineWideSettings <MachineWideSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlobalPackagesFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsLowercaseGlobalPackagesFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableParallel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNoOp>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Runtimes>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <FallbackRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private CachingSourceProvider <CachingSourceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IRestoreRequestProvider> <RequestProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IPreLoadedRestoreRequestProvider> <PreLoadedRequestProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LockFileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ValidateRuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideWarningsAndErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRestoreOriginalAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestoreForceEvaluate>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IAssetsLogMessage> <AdditionalMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IRestoreProgressReporter <ProgressReporter>k__BackingField;
    private ConcurrentDictionary`2<string, ISettings> _settingsCache;
    private ConcurrentDictionary`2<string, List`1<SourceRepository>> _sourcesCache;
    public string ConfigFile { get; public set; }
    public IMachineWideSettings MachineWideSettings { get; public set; }
    public string GlobalPackagesFolder { get; public set; }
    public Nullable`1<bool> IsLowercaseGlobalPackagesFolder { get; public set; }
    public bool DisableParallel { get; public set; }
    public bool AllowNoOp { get; public set; }
    public HashSet`1<string> Runtimes { get; public set; }
    public HashSet`1<string> FallbackRuntimes { get; public set; }
    public List`1<string> Inputs { get; public set; }
    public SourceCacheContext CacheContext { get; public set; }
    public ILogger Log { get; public set; }
    public List`1<string> Sources { get; public set; }
    public CachingSourceProvider CachingSourceProvider { get; public set; }
    public List`1<IRestoreRequestProvider> RequestProviders { get; public set; }
    public List`1<IPreLoadedRestoreRequestProvider> PreLoadedRequestProviders { get; public set; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public Nullable`1<int> LockFileVersion { get; public set; }
    public Nullable`1<bool> ValidateRuntimeAssets { get; public set; }
    public bool HideWarningsAndErrors { get; public set; }
    public Guid ParentId { get; public set; }
    public bool IsRestoreOriginalAction { get; public set; }
    public bool RestoreForceEvaluate { get; public set; }
    public IReadOnlyList`1<IAssetsLogMessage> AdditionalMessages { get; public set; }
    public IRestoreProgressReporter ProgressReporter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [CompilerGeneratedAttribute]
public IMachineWideSettings get_MachineWideSettings();
    [CompilerGeneratedAttribute]
public void set_MachineWideSettings(IMachineWideSettings value);
    [CompilerGeneratedAttribute]
public string get_GlobalPackagesFolder();
    [CompilerGeneratedAttribute]
public void set_GlobalPackagesFolder(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsLowercaseGlobalPackagesFolder();
    [CompilerGeneratedAttribute]
public void set_IsLowercaseGlobalPackagesFolder(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_DisableParallel();
    [CompilerGeneratedAttribute]
public void set_DisableParallel(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowNoOp();
    [CompilerGeneratedAttribute]
public void set_AllowNoOp(bool value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Runtimes();
    [CompilerGeneratedAttribute]
public void set_Runtimes(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_FallbackRuntimes();
    [CompilerGeneratedAttribute]
public void set_FallbackRuntimes(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Inputs();
    [CompilerGeneratedAttribute]
public void set_Inputs(List`1<string> value);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public void set_CacheContext(SourceCacheContext value);
    [CompilerGeneratedAttribute]
public ILogger get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(ILogger value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(List`1<string> value);
    [CompilerGeneratedAttribute]
public CachingSourceProvider get_CachingSourceProvider();
    [CompilerGeneratedAttribute]
public void set_CachingSourceProvider(CachingSourceProvider value);
    [CompilerGeneratedAttribute]
public List`1<IRestoreRequestProvider> get_RequestProviders();
    [CompilerGeneratedAttribute]
public void set_RequestProviders(List`1<IRestoreRequestProvider> value);
    [CompilerGeneratedAttribute]
public List`1<IPreLoadedRestoreRequestProvider> get_PreLoadedRequestProviders();
    [CompilerGeneratedAttribute]
public void set_PreLoadedRequestProviders(List`1<IPreLoadedRestoreRequestProvider> value);
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LockFileVersion();
    [CompilerGeneratedAttribute]
public void set_LockFileVersion(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ValidateRuntimeAssets();
    [CompilerGeneratedAttribute]
public void set_ValidateRuntimeAssets(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_HideWarningsAndErrors();
    [CompilerGeneratedAttribute]
public void set_HideWarningsAndErrors(bool value);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_IsRestoreOriginalAction();
    [CompilerGeneratedAttribute]
public void set_IsRestoreOriginalAction(bool value);
    [CompilerGeneratedAttribute]
public bool get_RestoreForceEvaluate();
    [CompilerGeneratedAttribute]
public void set_RestoreForceEvaluate(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IAssetsLogMessage> get_AdditionalMessages();
    [CompilerGeneratedAttribute]
public void set_AdditionalMessages(IReadOnlyList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
public IRestoreProgressReporter get_ProgressReporter();
    [CompilerGeneratedAttribute]
public void set_ProgressReporter(IRestoreProgressReporter value);
    public ISettings GetSettings(string projectDirectory);
    public string GetEffectiveGlobalPackagesFolder(string rootDirectory, ISettings settings);
    public IReadOnlyList`1<string> GetEffectiveFallbackPackageFolders(ISettings settings);
    internal List`1<SourceRepository> GetEffectiveSources(ISettings settings, IList`1<PackageSource> dgSpecSources);
    private List`1<SourceRepository> GetEffectiveSourcesCore(ISettings settings, IList`1<PackageSource> dgSpecSources);
    public void ApplyStandardProperties(RestoreRequest request);
    [CompilerGeneratedAttribute]
private ISettings <GetSettings>b__98_0(string dir);
    [CompilerGeneratedAttribute]
private SourceRepository <GetEffectiveSourcesCore>b__102_0(KeyValuePair`2<string, PackageSource> entry);
}
internal class NuGet.Commands.RestoreCollectorLogger : LoggerBase {
    private ILogger _innerLogger;
    private ConcurrentQueue`1<IRestoreLogMessage> _errors;
    private bool _hideWarningsAndErrors;
    private IEnumerable`1<RestoreTargetGraph> _restoreTargetGraphs;
    private PackageSpec _projectSpec;
    private WarningPropertiesCollection _transitiveWarningPropertiesCollection;
    [CompilerGeneratedAttribute]
private WarningPropertiesCollection <ProjectWarningPropertiesCollection>k__BackingField;
    public string ProjectPath { get; }
    public IEnumerable`1<IRestoreLogMessage> Errors { get; }
    public WarningPropertiesCollection ProjectWarningPropertiesCollection { get; public set; }
    public WarningPropertiesCollection TransitiveWarningPropertiesCollection { get; public set; }
    public RestoreCollectorLogger(ILogger innerLogger, LogLevel verbosity, bool hideWarningsAndErrors);
    public RestoreCollectorLogger(ILogger innerLogger, bool hideWarningsAndErrors);
    public RestoreCollectorLogger(ILogger innerLogger, LogLevel verbosity);
    public RestoreCollectorLogger(ILogger innerLogger);
    public string get_ProjectPath();
    public sealed virtual IEnumerable`1<IRestoreLogMessage> get_Errors();
    [CompilerGeneratedAttribute]
public WarningPropertiesCollection get_ProjectWarningPropertiesCollection();
    [CompilerGeneratedAttribute]
public void set_ProjectWarningPropertiesCollection(WarningPropertiesCollection value);
    public WarningPropertiesCollection get_TransitiveWarningPropertiesCollection();
    public void set_TransitiveWarningPropertiesCollection(WarningPropertiesCollection value);
    public void ApplyRestoreInputs(PackageSpec projectSpec);
    public void ApplyRestoreOutput(IEnumerable`1<RestoreTargetGraph> restoreTargetGraphs);
    public void Log(IRestoreLogMessage message);
    public Task LogAsync(IRestoreLogMessage message);
    public virtual void Log(ILogMessage message);
    public virtual Task LogAsync(ILogMessage message);
    protected bool DisplayMessage(IRestoreLogMessage message);
    private bool IsWarningSuppressed(IRestoreLogMessage message);
    private void UpgradeWarningToErrorIfNeeded(IRestoreLogMessage message);
    private static IRestoreLogMessage ToRestoreLogMessage(ILogMessage message);
}
internal class NuGet.Commands.RestoreCommand : object {
    private RestoreCollectorLogger _logger;
    private RestoreRequest _request;
    private LockFileBuilderCache _lockFileBuilderCache;
    private bool _success;
    private Guid _operationId;
    private Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> _includeFlagGraphs;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    private static string ProjectRestoreInformation;
    private static string ErrorCodes;
    private static string WarningCodes;
    private static string RestoreSuccess;
    private static string ProjectFilePath;
    private static string IsCentralVersionManagementEnabled;
    private static string TotalUniquePackagesCount;
    private static string NewPackagesInstalledCount;
    private static string SourcesCount;
    private static string HttpSourcesCount;
    private static string LocalSourcesCount;
    private static string FallbackFoldersCount;
    private static string NoOpDuration;
    private static string NoOpResult;
    private static string NoOpCacheFileEvaluateDuration;
    private static string NoOpCacheFileEvaluationResult;
    private static string NoOpRestoreOutputEvaluationDuration;
    private static string NoOpRestoreOutputEvaluationResult;
    private static string NoOpReplayLogsDuration;
    private static string NoOpCacheFileAgeDays;
    private static string EvaluateLockFileDuration;
    private static string ValidatePackagesShaDuration;
    private static string IsLockFileEnabled;
    private static string ReadLockFileDuration;
    private static string ValidateLockFileDuration;
    private static string IsLockFileValidForRestore;
    private static string LockFileEvaluationResult;
    private static string GenerateRestoreGraphDuration;
    private static string CreateRestoreTargetGraphDuration;
    private static string CreateAdditionalRestoreTargetGraphDuration;
    private static string GenerateAssetsFileDuration;
    private static string ValidateRestoreGraphsDuration;
    private static string CreateRestoreResultDuration;
    private static string IsCentralPackageTransitivePinningEnabled;
    private static string PackageSourceMappingIsMappingEnabled;
    private static string AuditEnabled;
    private static string AuditLevel;
    private static string AuditMode;
    private static string AuditSuppressedAdvisoriesDefinedCount;
    private static string AuditSuppressedAdvisoriesTotalWarningsSuppressedCount;
    private static string AuditSuppressedAdvisoriesDistinctAdvisoriesSuppressedCount;
    private static string AuditDataSources;
    private static string AuditDirectVulnerabilitiesPackages;
    private static string AuditDirectVulnerabilitiesCount;
    private static string AuditDirectVulnerabilitySev0;
    private static string AuditDirectVulnerabilitySev1;
    private static string AuditDirectVulnerabilitySev2;
    private static string AuditDirectVulnerabilitySev3;
    private static string AuditDirectVulnerabilitySevInvalid;
    private static string AuditTransitiveVulnerabilitiesPackages;
    private static string AuditTransitiveVulnerabilitiesCount;
    private static string AuditTransitiveVulnerabilitySev0;
    private static string AuditTransitiveVulnerabilitySev1;
    private static string AuditTransitiveVulnerabilitySev2;
    private static string AuditTransitiveVulnerabilitySev3;
    private static string AuditTransitiveVulnerabilitySevInvalid;
    private static string AuditDurationDownload;
    private static string AuditDurationCheck;
    private static string AuditDurationOutput;
    private static string AuditDurationTotal;
    public Guid ParentId { get; }
    public RestoreCommand(RestoreRequest request);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    public Task`1<RestoreResult> ExecuteAsync();
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ExecuteAsync>d__71")]
public Task`1<RestoreResult> ExecuteAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<PerformAuditAsync>d__72")]
private Task PerformAuditAsync(IEnumerable`1<RestoreTargetGraph> graphs, TelemetryActivity telemetry, CancellationToken token);
    private bool HasValidPlatformVersions();
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<AreCentralVersionRequirementsSatisfiedAsync>d__74")]
private Task`1<bool> AreCentralVersionRequirementsSatisfiedAsync(RestoreRequest restoreRequest, int httpSourcesCount);
    private string ConcatAsString(IEnumerable`1<T> enumerable);
    private bool VerifyCacheFileMatchesProject(CacheFile cacheFile);
    private bool ValidatePackagesSha512(PackagesLockFile lockFile, LockFile assetsFile);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<EvaluatePackagesLockFileAsync>d__78")]
private Task`1<ValueTuple`3<bool, bool, PackagesLockFile>> EvaluatePackagesLockFileAsync(string packagesLockFilePath, RemoteWalkContext contextForProject, TelemetryActivity lockFileTelemetry);
    private ValueTuple`3<CacheFile, bool, Nullable`1<TimeSpan>> EvaluateCacheFile();
    private string GetAssetsFilePath(LockFile lockFile);
    private void DowngradeLockFileIfNeeded(LockFile lockFile);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<FixCaseForLegacyReaders>d__82")]
private Task FixCaseForLegacyReaders(IEnumerable`1<RestoreTargetGraph> graphs, LockFile lockFile, CancellationToken token);
    private LockFile BuildAssetsFile(LockFile existingLockFile, PackageSpec project, IEnumerable`1<RestoreTargetGraph> graphs, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, RemoteWalkContext contextForProject);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ValidateRestoreGraphsAsync>d__84")]
private Task`1<bool> ValidateRestoreGraphsAsync(IEnumerable`1<RestoreTargetGraph> graphs, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ValidateCyclesAsync>d__85")]
private static Task`1<bool> ValidateCyclesAsync(IEnumerable`1<RestoreTargetGraph> graphs, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ValidateConflictsAsync>d__86")]
private Task`1<bool> ValidateConflictsAsync(IEnumerable`1<RestoreTargetGraph> graphs, ILogger logger);
    internal static Task LogDowngradeWarningsOrErrorsAsync(IEnumerable`1<RestoreTargetGraph> graphs, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<VerifyCompatibilityAsync>d__88")]
private static Task`1<IList`1<CompatibilityCheckResult>> VerifyCompatibilityAsync(PackageSpec project, Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> includeFlagGraphs, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, LockFile lockFile, IEnumerable`1<RestoreTargetGraph> graphs, bool validateRuntimeAssets, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ExecuteRestoreAsync>d__89")]
private Task`1<IEnumerable`1<RestoreTargetGraph>> ExecuteRestoreAsync(NuGetv3LocalRepository userPackageFolder, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, RemoteWalkContext context, CancellationToken token, TelemetryActivity telemetryActivity);
    private List`1<ExternalProjectReference> GetProjectReferences();
    private static IEnumerable`1<FrameworkRuntimePair> CreateFrameworkRuntimePairs(PackageSpec packageSpec, ISet`1<string> runtimeIds);
    private static RemoteWalkContext CreateRemoteWalkContext(RestoreRequest request, RestoreCollectorLogger logger);
    private static void DowngradeLockFileToV1(LockFile lockFile);
    private static ExternalProjectReference ToExternalProjectReference(PackageSpec project);
    [CompilerGeneratedAttribute]
private LockFile <ExecuteAsync>b__71_2();
    [CompilerGeneratedAttribute]
internal static void <PerformAuditAsync>g__AddPackagesList|72_0(TelemetryActivity telemetry, string eventName, List`1<string> packages);
    [NuGet.Commands.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private CacheFile <EvaluateCacheFile>b__79_0(FileStream stream, string path);
    [CompilerGeneratedAttribute]
internal static bool <EvaluateCacheFile>g__CacheFileExists|79_1(string path, Nullable`1& cacheFileAge);
    [CompilerGeneratedAttribute]
private bool <GetProjectReferences>b__90_0(ExternalProjectReference proj);
}
internal class NuGet.Commands.RestoreCommandException : Exception {
    private IRestoreLogMessage _logMessage;
    public RestoreCommandException(IRestoreLogMessage logMessage);
    public sealed virtual ILogMessage AsLogMessage();
}
internal class NuGet.Commands.RestoreCommandProviders : object {
    [CompilerGeneratedAttribute]
private NuGetv3LocalRepository <GlobalPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetv3LocalRepository> <FallbackPackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IRemoteDependencyProvider> <LocalProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IRemoteDependencyProvider> <RemoteProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalPackageFileCache <PackageFileCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IVulnerabilityInformationProvider> <VulnerabilityInfoProviders>k__BackingField;
    public NuGetv3LocalRepository GlobalPackages { get; }
    public IReadOnlyList`1<NuGetv3LocalRepository> FallbackPackageFolders { get; }
    public IReadOnlyList`1<IRemoteDependencyProvider> LocalProviders { get; }
    public IReadOnlyList`1<IRemoteDependencyProvider> RemoteProviders { get; }
    public LocalPackageFileCache PackageFileCache { get; }
    internal IReadOnlyList`1<IVulnerabilityInformationProvider> VulnerabilityInfoProviders { get; }
    [ObsoleteAttribute("Create via RestoreCommandProvidersCache")]
public RestoreCommandProviders(NuGetv3LocalRepository globalPackages, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, IReadOnlyList`1<IRemoteDependencyProvider> localProviders, IReadOnlyList`1<IRemoteDependencyProvider> remoteProviders, LocalPackageFileCache packageFileCache);
    internal RestoreCommandProviders(NuGetv3LocalRepository globalPackages, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, IReadOnlyList`1<IRemoteDependencyProvider> localProviders, IReadOnlyList`1<IRemoteDependencyProvider> remoteProviders, LocalPackageFileCache packageFileCache, IReadOnlyList`1<IVulnerabilityInformationProvider> vulnerabilityInformationProviders);
    private static IReadOnlyList`1<IVulnerabilityInformationProvider> CreateVulnerabilityInfoProviders(IReadOnlyList`1<IRemoteDependencyProvider> remoteProviders);
    [CompilerGeneratedAttribute]
public NuGetv3LocalRepository get_GlobalPackages();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetv3LocalRepository> get_FallbackPackageFolders();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IRemoteDependencyProvider> get_LocalProviders();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IRemoteDependencyProvider> get_RemoteProviders();
    [CompilerGeneratedAttribute]
public LocalPackageFileCache get_PackageFileCache();
    [CompilerGeneratedAttribute]
internal IReadOnlyList`1<IVulnerabilityInformationProvider> get_VulnerabilityInfoProviders();
    public static RestoreCommandProviders Create(string globalFolderPath, IEnumerable`1<string> fallbackPackageFolderPaths, IEnumerable`1<SourceRepository> sources, SourceCacheContext cacheContext, LocalPackageFileCache packageFileCache, ILogger log);
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
internal class NuGet.Commands.RestoreCommandProvidersCache : object {
    private ConcurrentDictionary`2<SourceRepository, IRemoteDependencyProvider> _remoteProviders;
    private ConcurrentDictionary`2<string, IRemoteDependencyProvider> _localProvider;
    private ConcurrentDictionary`2<string, NuGetv3LocalRepository> _globalCache;
    private ConcurrentDictionary`2<SourceRepository, IVulnerabilityInformationProvider> _vulnerabilityInformationProviders;
    private LocalPackageFileCache _fileCache;
    public RestoreCommandProviders GetOrCreate(string globalPackagesPath, IReadOnlyList`1<string> fallbackPackagesPaths, IReadOnlyList`1<SourceRepository> sources, SourceCacheContext cacheContext, ILogger log);
    public RestoreCommandProviders GetOrCreate(string globalPackagesPath, IReadOnlyList`1<string> fallbackPackagesPaths, IReadOnlyList`1<SourceRepository> sources, SourceCacheContext cacheContext, ILogger log, bool updateLastAccess);
    private NuGetv3LocalRepository CreateGlobalPackagedRepository(string globalPackagesPath, bool updateLastAccess);
    private List`1<NuGetv3LocalRepository> GetFallbackFolderRepositories(IReadOnlyList`1<string> fallbackPackagesPaths);
    private List`1<IRemoteDependencyProvider> CreateLocalProviders(string globalPackagesPath, IReadOnlyList`1<string> fallbackPackagesPaths, SourceCacheContext cacheContext, ILogger log);
    private List`1<IRemoteDependencyProvider> CreateRemoveProviders(IReadOnlyList`1<SourceRepository> sources, SourceCacheContext cacheContext, ILogger log);
    private List`1<IVulnerabilityInformationProvider> CreateVulnerabilityProviders(IReadOnlyList`1<SourceRepository> sources, ILogger log);
    [CompilerGeneratedAttribute]
private NuGetv3LocalRepository <GetFallbackFolderRepositories>b__8_0(string path);
}
internal class NuGet.Commands.RestoreRequest : object {
    public static int DefaultDegreeOfConcurrency;
    private string _lockFilePath;
    private Lazy`1<LockFile> _lockFileLazy;
    [CompilerGeneratedAttribute]
private DependencyGraphSpec <DependencyGraphSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNoOp>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFileBuilderCache <LockFileBuilderCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpec <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLowercasePackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ExternalProjectReference> <ExternalProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<FrameworkRuntimePair> <CompatibilityProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LockFileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <RequestedRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <FallbackRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreCommandProviders <DependencyProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectExtensionsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateRuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideWarningsAndErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocFileSaveMode <XmlDocFileSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceMapping <PackageSourceMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSignatureVerifier <SignedPackageVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRestoreOriginalAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestoreForceEvaluate>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IAssetsLogMessage> <AdditionalMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdatePackageLastAccessTime>k__BackingField;
    public DependencyGraphSpec DependencyGraphSpec { get; public set; }
    public bool AllowNoOp { get; public set; }
    public SourceCacheContext CacheContext { get; public set; }
    internal LockFileBuilderCache LockFileBuilderCache { get; }
    public ILogger Log { get; public set; }
    public PackageSpec Project { get; }
    public string PackagesDirectory { get; }
    public bool IsLowercasePackagesDirectory { get; public set; }
    public IList`1<ExternalProjectReference> ExternalProjects { get; public set; }
    public string LockFilePath { get; public set; }
    public LockFile ExistingLockFile { get; public set; }
    public int MaxDegreeOfConcurrency { get; public set; }
    public ISet`1<FrameworkRuntimePair> CompatibilityProfiles { get; }
    public int LockFileVersion { get; public set; }
    public ISet`1<string> RequestedRuntimes { get; }
    public ISet`1<string> FallbackRuntimes { get; }
    public RestoreCommandProviders DependencyProviders { get; public set; }
    public ProjectStyle ProjectStyle { get; public set; }
    public string RestoreOutputPath { get; public set; }
    public string MSBuildProjectExtensionsPath { get; public set; }
    public bool ValidateRuntimeAssets { get; public set; }
    public bool HideWarningsAndErrors { get; public set; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; }
    public PackageSourceMapping PackageSourceMapping { get; }
    internal IPackageSignatureVerifier SignedPackageVerifier { get; internal set; }
    public Guid ParentId { get; public set; }
    public bool IsRestoreOriginalAction { get; public set; }
    public bool RestoreForceEvaluate { get; public set; }
    public IReadOnlyList`1<IAssetsLogMessage> AdditionalMessages { get; public set; }
    public bool UpdatePackageLastAccessTime { get; public set; }
    [ObsoleteAttribute("Use constructor with LockFileBuilderCache parameter")]
public RestoreRequest(PackageSpec project, RestoreCommandProviders dependencyProviders, SourceCacheContext cacheContext, ClientPolicyContext clientPolicyContext, ILogger log);
    public RestoreRequest(PackageSpec project, RestoreCommandProviders dependencyProviders, SourceCacheContext cacheContext, ClientPolicyContext clientPolicyContext, PackageSourceMapping packageSourceMapping, ILogger log, LockFileBuilderCache lockFileBuilderCache);
    private static RestoreRequest();
    [CompilerGeneratedAttribute]
public DependencyGraphSpec get_DependencyGraphSpec();
    [CompilerGeneratedAttribute]
public void set_DependencyGraphSpec(DependencyGraphSpec value);
    [CompilerGeneratedAttribute]
public bool get_AllowNoOp();
    [CompilerGeneratedAttribute]
public void set_AllowNoOp(bool value);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public void set_CacheContext(SourceCacheContext value);
    [CompilerGeneratedAttribute]
internal LockFileBuilderCache get_LockFileBuilderCache();
    [CompilerGeneratedAttribute]
public ILogger get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(ILogger value);
    [CompilerGeneratedAttribute]
public PackageSpec get_Project();
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public bool get_IsLowercasePackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_IsLowercasePackagesDirectory(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ExternalProjectReference> get_ExternalProjects();
    [CompilerGeneratedAttribute]
public void set_ExternalProjects(IList`1<ExternalProjectReference> value);
    public string get_LockFilePath();
    public void set_LockFilePath(string value);
    public LockFile get_ExistingLockFile();
    public void set_ExistingLockFile(LockFile value);
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfConcurrency();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfConcurrency(int value);
    [CompilerGeneratedAttribute]
public ISet`1<FrameworkRuntimePair> get_CompatibilityProfiles();
    [CompilerGeneratedAttribute]
public int get_LockFileVersion();
    [CompilerGeneratedAttribute]
public void set_LockFileVersion(int value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_RequestedRuntimes();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_FallbackRuntimes();
    [CompilerGeneratedAttribute]
public RestoreCommandProviders get_DependencyProviders();
    [CompilerGeneratedAttribute]
public void set_DependencyProviders(RestoreCommandProviders value);
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
public void set_ProjectStyle(ProjectStyle value);
    [CompilerGeneratedAttribute]
public string get_RestoreOutputPath();
    [CompilerGeneratedAttribute]
public void set_RestoreOutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectExtensionsPath();
    [CompilerGeneratedAttribute]
public void set_MSBuildProjectExtensionsPath(string value);
    [CompilerGeneratedAttribute]
public bool get_ValidateRuntimeAssets();
    [CompilerGeneratedAttribute]
public void set_ValidateRuntimeAssets(bool value);
    [CompilerGeneratedAttribute]
public bool get_HideWarningsAndErrors();
    [CompilerGeneratedAttribute]
public void set_HideWarningsAndErrors(bool value);
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public XmlDocFileSaveMode get_XmlDocFileSaveMode();
    [CompilerGeneratedAttribute]
public void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public PackageSourceMapping get_PackageSourceMapping();
    [CompilerGeneratedAttribute]
internal IPackageSignatureVerifier get_SignedPackageVerifier();
    [CompilerGeneratedAttribute]
internal void set_SignedPackageVerifier(IPackageSignatureVerifier value);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_IsRestoreOriginalAction();
    [CompilerGeneratedAttribute]
public void set_IsRestoreOriginalAction(bool value);
    [CompilerGeneratedAttribute]
public bool get_RestoreForceEvaluate();
    [CompilerGeneratedAttribute]
public void set_RestoreForceEvaluate(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IAssetsLogMessage> get_AdditionalMessages();
    [CompilerGeneratedAttribute]
public void set_AdditionalMessages(IReadOnlyList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
public bool get_UpdatePackageLastAccessTime();
    [CompilerGeneratedAttribute]
public void set_UpdatePackageLastAccessTime(bool value);
    [CompilerGeneratedAttribute]
private LockFile <set_LockFilePath>b__40_0();
}
internal class NuGet.Commands.RestoreResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LockFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<RestoreTargetGraph> <RestoreGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CompatibilityCheckResult> <CompatibilityCheckResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MSBuildOutputFile> <MSBuildOutputFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFile <LockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFile <PreviousLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ElapsedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheFile <CacheFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFilePath>k__BackingField;
    private string _newPackagesLockFilePath;
    [CompilerGeneratedAttribute]
private PackagesLockFile <_newPackagesLockFile>k__BackingField;
    private string _dependencyGraphSpecFilePath;
    private DependencyGraphSpec _dependencyGraphSpec;
    private Lazy`1<bool> _isAssetsFileDirty;
    private Lazy`1<List`1<MSBuildOutputFile>> _dirtyMSBuildFiles;
    public bool Success { get; }
    public string LockFilePath { get; public set; }
    public IEnumerable`1<RestoreTargetGraph> RestoreGraphs { get; }
    public IEnumerable`1<CompatibilityCheckResult> CompatibilityCheckResults { get; }
    public IEnumerable`1<MSBuildOutputFile> MSBuildOutputFiles { get; }
    public ProjectStyle ProjectStyle { get; }
    public LockFile LockFile { get; }
    public LockFile PreviousLockFile { get; }
    public TimeSpan ElapsedTime { get; }
    public IList`1<IAssetsLogMessage> LogMessages { get; internal set; }
    private CacheFile CacheFile { get; }
    protected string CacheFilePath { get; }
    internal PackagesLockFile _newPackagesLockFile { get; }
    public RestoreResult(bool success, IEnumerable`1<RestoreTargetGraph> restoreGraphs, IEnumerable`1<CompatibilityCheckResult> compatibilityCheckResults, IEnumerable`1<MSBuildOutputFile> msbuildFiles, LockFile lockFile, LockFile previousLockFile, string lockFilePath, CacheFile cacheFile, string cacheFilePath, string packagesLockFilePath, PackagesLockFile packagesLockFile, string dependencyGraphSpecFilePath, DependencyGraphSpec dependencyGraphSpec, ProjectStyle projectStyle, TimeSpan elapsedTime);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Success();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LockFilePath();
    [CompilerGeneratedAttribute]
public void set_LockFilePath(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<RestoreTargetGraph> get_RestoreGraphs();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CompatibilityCheckResult> get_CompatibilityCheckResults();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<MSBuildOutputFile> get_MSBuildOutputFiles();
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
public virtual LockFile get_LockFile();
    [CompilerGeneratedAttribute]
public virtual LockFile get_PreviousLockFile();
    [CompilerGeneratedAttribute]
public TimeSpan get_ElapsedTime();
    [CompilerGeneratedAttribute]
public virtual IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
internal virtual void set_LogMessages(IList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
private CacheFile get_CacheFile();
    [CompilerGeneratedAttribute]
protected string get_CacheFilePath();
    [CompilerGeneratedAttribute]
internal PackagesLockFile get__newPackagesLockFile();
    public virtual ISet`1<LibraryIdentity> GetAllInstalled();
    public ISet`1<LibraryRange> GetAllUnresolved();
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitAsync>d__49")]
public virtual Task CommitAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitAssetsFileAsync>d__50")]
private Task CommitAssetsFileAsync(LockFileFormat lockFileFormat, ILogger log, bool toolCommit, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitCacheFileAsync>d__51")]
private Task CommitCacheFileAsync(ILogger log, bool toolCommit);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitLockFileAsync>d__52")]
private Task CommitLockFileAsync(ILogger log, bool toolCommit);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitDgSpecFileAsync>d__53")]
private Task CommitDgSpecFileAsync(ILogger log, bool toolCommit);
    internal virtual IReadOnlyList`1<string> GetDirtyFiles();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__46_0();
    [CompilerGeneratedAttribute]
private List`1<MSBuildOutputFile> <.ctor>b__46_1();
    [NuGet.Commands.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CommitCacheFileAsync>b__51_0(string outPath);
    [NuGet.Commands.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CommitLockFileAsync>b__52_0(string outputPath);
    [NuGet.Commands.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CommitDgSpecFileAsync>b__53_0(string outputPath);
}
internal class NuGet.Commands.RestoreResultPair : object {
    [CompilerGeneratedAttribute]
private RestoreSummaryRequest <SummaryRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreResult <Result>k__BackingField;
    public RestoreSummaryRequest SummaryRequest { get; }
    public RestoreResult Result { get; }
    public RestoreResultPair(RestoreSummaryRequest request, RestoreResult result);
    [CompilerGeneratedAttribute]
public RestoreSummaryRequest get_SummaryRequest();
    [CompilerGeneratedAttribute]
public RestoreResult get_Result();
}
internal static class NuGet.Commands.RestoreRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<RunAsync>d__0")]
public static Task`1<IReadOnlyList`1<RestoreSummary>> RunAsync(RestoreArgs restoreContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<RunAsync>d__1")]
public static Task`1<IReadOnlyList`1<RestoreSummary>> RunAsync(RestoreArgs restoreContext);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<RunAsync>d__2")]
private static Task`1<IReadOnlyList`1<RestoreSummary>> RunAsync(IEnumerable`1<RestoreSummaryRequest> restoreRequests, RestoreArgs restoreArgs, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<RunWithoutCommit>d__3")]
public static Task`1<IReadOnlyList`1<RestoreResultPair>> RunWithoutCommit(IEnumerable`1<RestoreSummaryRequest> restoreRequests, RestoreArgs restoreContext);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<GetRequests>d__4")]
public static Task`1<IReadOnlyList`1<RestoreSummaryRequest>> GetRequests(RestoreArgs restoreContext);
    private static int GetMaxTaskCount(RestoreArgs restoreContext);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<ExecuteAndCommitAsync>d__6")]
private static Task`1<RestoreSummary> ExecuteAndCommitAsync(RestoreSummaryRequest summaryRequest, IRestoreProgressReporter progressReporter, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<ExecuteAsync>d__7")]
private static Task`1<RestoreResultPair> ExecuteAsync(RestoreSummaryRequest summaryRequest, CancellationToken token);
    public static Task`1<RestoreSummary> CommitAsync(RestoreResultPair restoreResult, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CommitAsync>d__9")]
private static Task`1<RestoreSummary> CommitAsync(RestoreResultPair restoreResult, IRestoreProgressReporter progressReporter, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CompleteTaskAsync>d__10")]
private static Task`1<RestoreSummary> CompleteTaskAsync(List`1<Task`1<RestoreSummary>> restoreTasks);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CompleteTaskAsync>d__11")]
private static Task`1<RestoreResultPair> CompleteTaskAsync(List`1<Task`1<RestoreResultPair>> restoreTasks);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CreatePreLoadedRequests>d__12")]
private static Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreatePreLoadedRequests(RestoreArgs restoreContext);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CreateRequests>d__13")]
private static Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(string input, RestoreArgs restoreContext);
    public static string GetInvalidInputErrorMessage(string input);
}
internal class NuGet.Commands.RestoreSpecException : Exception {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Files>k__BackingField;
    public IEnumerable`1<string> Files { get; }
    private RestoreSpecException(string message, IEnumerable`1<string> files, Exception innerException);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Files();
    public static RestoreSpecException Create(string message, IEnumerable`1<string> files);
    public static RestoreSpecException Create(string message, IEnumerable`1<string> files, Exception innerException);
}
internal class NuGet.Commands.RestoreSummary : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoOpRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ConfigFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <FeedsUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InstallCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IRestoreLogMessage> <Errors>k__BackingField;
    public bool Success { get; }
    public bool NoOpRestore { get; }
    public string InputPath { get; }
    public IReadOnlyList`1<string> ConfigFiles { get; }
    public IReadOnlyList`1<string> FeedsUsed { get; }
    public int InstallCount { get; }
    public IReadOnlyList`1<IRestoreLogMessage> Errors { get; }
    public RestoreSummary(bool success);
    public RestoreSummary(RestoreResult result, string inputPath, IEnumerable`1<string> configFiles, IEnumerable`1<SourceRepository> sourceRepositories, IEnumerable`1<RestoreLogMessage> errors);
    public RestoreSummary(bool success, string inputPath, IReadOnlyList`1<string> configFiles, IReadOnlyList`1<string> feedsUsed, int installCount, IReadOnlyList`1<IRestoreLogMessage> errors);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public bool get_NoOpRestore();
    [CompilerGeneratedAttribute]
public string get_InputPath();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ConfigFiles();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_FeedsUsed();
    [CompilerGeneratedAttribute]
public int get_InstallCount();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IRestoreLogMessage> get_Errors();
    public static void Log(ILogger logger, IReadOnlyList`1<RestoreSummary> restoreSummaries, bool logErrors);
    private static void LogErrorsToConsole(RestoreSummary restoreSummary, string logHeading, ILogger logger);
    [IteratorStateMachineAttribute("NuGet.Commands.RestoreSummary/<IndentLines>d__26")]
private static IEnumerable`1<string> IndentLines(string input);
}
internal class NuGet.Commands.RestoreSummaryRequest : object {
    [CompilerGeneratedAttribute]
private RestoreRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ConfigFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SourceRepository> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputPath>k__BackingField;
    public RestoreRequest Request { get; }
    public IEnumerable`1<string> ConfigFiles { get; }
    public IReadOnlyList`1<SourceRepository> Sources { get; }
    public string InputPath { get; }
    public RestoreSummaryRequest(RestoreRequest request, string inputPath, IEnumerable`1<string> configFiles, IReadOnlyList`1<SourceRepository> sources);
    [CompilerGeneratedAttribute]
public RestoreRequest get_Request();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ConfigFiles();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SourceRepository> get_Sources();
    [CompilerGeneratedAttribute]
public string get_InputPath();
}
internal class NuGet.Commands.RestoreTargetGraph : object {
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedCodeConventions <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeGraph <RuntimeGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<GraphNode`1<RemoteResolveResult>> <Graphs>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<RemoteMatch> <Install>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<GraphItem`1<RemoteResolveResult>> <Flattened>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<LibraryRange> <Unresolved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InConflict>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetGraphName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ResolverConflict> <Conflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalyzeResult`1<RemoteResolveResult> <AnalyzeResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<ResolvedDependencyKey> <ResolvedDependencies>k__BackingField;
    public string RuntimeIdentifier { get; }
    public NuGetFramework Framework { get; }
    public ManagedCodeConventions Conventions { get; }
    public RuntimeGraph RuntimeGraph { get; }
    public IEnumerable`1<GraphNode`1<RemoteResolveResult>> Graphs { get; }
    public ISet`1<RemoteMatch> Install { get; }
    public ISet`1<GraphItem`1<RemoteResolveResult>> Flattened { get; }
    public ISet`1<LibraryRange> Unresolved { get; }
    public bool InConflict { get; }
    public string Name { get; }
    public string TargetGraphName { get; }
    public IEnumerable`1<ResolverConflict> Conflicts { get; internal set; }
    public AnalyzeResult`1<RemoteResolveResult> AnalyzeResult { get; private set; }
    public ISet`1<ResolvedDependencyKey> ResolvedDependencies { get; }
    private RestoreTargetGraph(IEnumerable`1<ResolverConflict> conflicts, NuGetFramework framework, string runtimeIdentifier, RuntimeGraph runtimeGraph, IEnumerable`1<GraphNode`1<RemoteResolveResult>> graphs, ISet`1<RemoteMatch> install, ISet`1<GraphItem`1<RemoteResolveResult>> flattened, ISet`1<LibraryRange> unresolved, AnalyzeResult`1<RemoteResolveResult> analyzeResult, ISet`1<ResolvedDependencyKey> resolvedDependencies);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public sealed virtual ManagedCodeConventions get_Conventions();
    [CompilerGeneratedAttribute]
public sealed virtual RuntimeGraph get_RuntimeGraph();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<GraphNode`1<RemoteResolveResult>> get_Graphs();
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<RemoteMatch> get_Install();
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<GraphItem`1<RemoteResolveResult>> get_Flattened();
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<LibraryRange> get_Unresolved();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InConflict();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetGraphName();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ResolverConflict> get_Conflicts();
    [CompilerGeneratedAttribute]
internal void set_Conflicts(IEnumerable`1<ResolverConflict> value);
    [CompilerGeneratedAttribute]
public sealed virtual AnalyzeResult`1<RemoteResolveResult> get_AnalyzeResult();
    [CompilerGeneratedAttribute]
private void set_AnalyzeResult(AnalyzeResult`1<RemoteResolveResult> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<ResolvedDependencyKey> get_ResolvedDependencies();
    public static RestoreTargetGraph Create(IEnumerable`1<GraphNode`1<RemoteResolveResult>> graphs, RemoteWalkContext context, ILogger logger, NuGetFramework framework);
    public static RestoreTargetGraph Create(RuntimeGraph runtimeGraph, IEnumerable`1<GraphNode`1<RemoteResolveResult>> graphs, RemoteWalkContext context, ILogger log, NuGetFramework framework, string runtimeIdentifier);
}
internal static class NuGet.Commands.RunnerHelper : object {
    public static ISettings GetSettings(string configfile);
    public static PackageSourceProvider GetSourceProvider(ISettings settings);
    public static void EnableOrDisableSource(PackageSourceProvider sourceProvider, string name, bool enable, Func`1<ILogger> getLogger);
    public static void ValidateCredentials(string username, string password, string validAuthenticationTypes);
    public static int ParseProtocolVersion(string protocolVersionString);
}
internal class NuGet.Commands.SignArgs : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackagePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePath>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreName <CertificateStoreName>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreLocation <CertificateStoreLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateSubjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateFingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <SignatureHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Timestamper>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <TimestampHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePassword>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IPasswordProvider <PasswordProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    [ObsoleteAttribute("Use PackagePaths instead")]
public string PackagePath { get; public set; }
    public IReadOnlyList`1<string> PackagePaths { get; public set; }
    public string OutputDirectory { get; public set; }
    public string CertificatePath { get; public set; }
    public StoreName CertificateStoreName { get; public set; }
    public StoreLocation CertificateStoreLocation { get; public set; }
    public string CertificateSubjectName { get; public set; }
    public string CertificateFingerprint { get; public set; }
    public HashAlgorithmName SignatureHashAlgorithm { get; public set; }
    public string Timestamper { get; public set; }
    public HashAlgorithmName TimestampHashAlgorithm { get; public set; }
    public string CertificatePassword { get; public set; }
    public bool Overwrite { get; public set; }
    public bool NonInteractive { get; public set; }
    public ILogger Logger { get; public set; }
    public IPasswordProvider PasswordProvider { get; public set; }
    public CancellationToken Token { get; public set; }
    public string get_PackagePath();
    public void set_PackagePath(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackagePaths();
    [CompilerGeneratedAttribute]
public void set_PackagePaths(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_CertificatePath();
    [CompilerGeneratedAttribute]
public void set_CertificatePath(string value);
    [CompilerGeneratedAttribute]
public StoreName get_CertificateStoreName();
    [CompilerGeneratedAttribute]
public void set_CertificateStoreName(StoreName value);
    [CompilerGeneratedAttribute]
public StoreLocation get_CertificateStoreLocation();
    [CompilerGeneratedAttribute]
public void set_CertificateStoreLocation(StoreLocation value);
    [CompilerGeneratedAttribute]
public string get_CertificateSubjectName();
    [CompilerGeneratedAttribute]
public void set_CertificateSubjectName(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateFingerprint();
    [CompilerGeneratedAttribute]
public void set_CertificateFingerprint(string value);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_SignatureHashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_SignatureHashAlgorithm(HashAlgorithmName value);
    [CompilerGeneratedAttribute]
public string get_Timestamper();
    [CompilerGeneratedAttribute]
public void set_Timestamper(string value);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_TimestampHashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_TimestampHashAlgorithm(HashAlgorithmName value);
    [CompilerGeneratedAttribute]
public string get_CertificatePassword();
    [CompilerGeneratedAttribute]
public void set_CertificatePassword(string value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_NonInteractive(bool value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public IPasswordProvider get_PasswordProvider();
    [CompilerGeneratedAttribute]
public void set_PasswordProvider(IPasswordProvider value);
    [CompilerGeneratedAttribute]
public CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(CancellationToken value);
}
internal interface NuGet.Commands.SignCommand.IPasswordProvider {
    public abstract virtual Task`1<SecureString> GetPassword(string filePath, CancellationToken token);
}
internal class NuGet.Commands.SignCommandException : Exception {
    private ILogMessage _logMessage;
    public SignCommandException(ILogMessage logMessage);
    public sealed virtual ILogMessage AsLogMessage();
}
internal class NuGet.Commands.SignCommandRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.SignCommandRunner/<ExecuteCommandAsync>d__0")]
public sealed virtual Task`1<int> ExecuteCommandAsync(SignArgs signArgs);
    [AsyncStateMachineAttribute("NuGet.Commands.SignCommandRunner/<ExecuteCommandAsync>d__1")]
public Task`1<int> ExecuteCommandAsync(IEnumerable`1<string> packagesToSign, SignPackageRequest signPackageRequest, string timestamper, ILogger logger, string outputDirectory, bool overwrite, CancellationToken token);
    private static ISignatureProvider GetSignatureProvider(string timestamper);
    [AsyncStateMachineAttribute("NuGet.Commands.SignCommandRunner/<GetCertificateAsync>d__3")]
private static Task`1<X509Certificate2> GetCertificateAsync(SignArgs signArgs);
    private static X509Certificate2Collection FilterCodeSigningCertificates(X509Certificate2Collection matchingCollection);
}
internal class NuGet.Commands.SingleFileProvider : object {
    public static string RootDir;
    private string _path;
    public SingleFileProvider(string path);
    public sealed virtual IDirectoryContents GetDirectoryContents(string subpath);
    public sealed virtual IFileInfo GetFileInfo(string subpath);
    public sealed virtual IChangeToken Watch(string filter);
}
internal class NuGet.Commands.SourceRepositoryDependencyProvider : object {
    private object _lock;
    private SourceRepository _sourceRepository;
    private ILogger _logger;
    private SourceCacheContext _cacheContext;
    private LocalPackageFileCache _packageFileCache;
    private FindPackageByIdResource _findPackagesByIdResource;
    private bool _ignoreFailedSources;
    private bool _ignoreWarning;
    private bool _isFallbackFolderSource;
    private bool _useLegacyAssetTargetFallbackBehavior;
    private NuGet.Commands486115.TaskResultCache`2<LibraryRangeCacheKey, LibraryDependencyInfo> _dependencyInfoCache;
    private NuGet.Commands486115.TaskResultCache`2<LibraryRange, LibraryIdentity> _libraryMatchCache;
    private static SemaphoreSlim _throttle;
    public bool IsHttp { get; }
    public PackageSource Source { get; }
    public SourceRepository SourceRepository { get; }
    public SourceRepositoryDependencyProvider(SourceRepository sourceRepository, ILogger logger, SourceCacheContext cacheContext, bool ignoreFailedSources, bool ignoreWarning);
    public SourceRepositoryDependencyProvider(SourceRepository sourceRepository, ILogger logger, SourceCacheContext cacheContext, bool ignoreFailedSources, bool ignoreWarning, LocalPackageFileCache fileCache, bool isFallbackFolderSource);
    internal SourceRepositoryDependencyProvider(SourceRepository sourceRepository, ILogger logger, SourceCacheContext cacheContext, bool ignoreFailedSources, bool ignoreWarning, LocalPackageFileCache fileCache, bool isFallbackFolderSource, IEnvironmentVariableReader environmentVariableReader);
    private static SourceRepositoryDependencyProvider();
    internal static SemaphoreSlim GetThrottleSemaphoreSlim(IEnvironmentVariableReader env);
    public sealed virtual bool get_IsHttp();
    public sealed virtual PackageSource get_Source();
    public sealed virtual SourceRepository get_SourceRepository();
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<FindLibraryAsync>d__23")]
public sealed virtual Task`1<LibraryIdentity> FindLibraryAsync(LibraryRange libraryRange, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<FindLibraryCoreAsync>d__24")]
private Task`1<LibraryIdentity> FindLibraryCoreAsync(LibraryRange libraryRange, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual Task`1<LibraryDependencyInfo> GetDependenciesAsync(LibraryIdentity libraryIdentity, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<GetDependenciesCoreAsync>d__26")]
private Task`1<LibraryDependencyInfo> GetDependenciesCoreAsync(LibraryIdentity match, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<GetPackageDownloaderAsync>d__27")]
public sealed virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private IEnumerable`1<LibraryDependency> GetDependencies(FindPackageByIdDependencyInfo packageInfo, NuGetFramework targetFramework);
    private static NuGetFramework DeconstructFallbackFrameworks(NuGetFramework nuGetFramework);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<EnsureResource>d__30")]
private Task EnsureResource(CancellationToken cancellationToken);
    private void AddLocalV3ResourceOptions(FindPackageByIdResource resource);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<GetAllVersionsAsync>d__32")]
public sealed virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<GetAllVersionsInternalAsync>d__33")]
internal Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsInternalAsync(string id, SourceCacheContext cacheContext, ILogger logger, bool catchAndLogExceptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<LogWarningAsync>d__34")]
private Task LogWarningAsync(ILogger logger, string id, FatalProtocolException e);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<LogErrorAsync>d__35")]
private Task LogErrorAsync(ILogger logger, string id, FatalProtocolException e);
    [CompilerGeneratedAttribute]
internal static ILogMessage <LogErrorAsync>g__UnwrapToLogMessage|35_0(Exception e);
}
internal enum NuGet.Commands.SourcesAction : Enum {
    public int value__;
    public static SourcesAction None;
    public static SourcesAction List;
    public static SourcesAction Add;
    public static SourcesAction Remove;
    public static SourcesAction Enable;
    public static SourcesAction Disable;
    public static SourcesAction Update;
}
internal enum NuGet.Commands.SourcesListFormat : Enum {
    public int value__;
    public static SourcesListFormat None;
    public static SourcesListFormat Detailed;
    public static SourcesListFormat Short;
}
internal static class NuGet.Commands.SpecValidationUtility : object {
    public static void ValidateDependencySpec(DependencyGraphSpec spec);
    public static void ValidateDependencySpec(DependencyGraphSpec spec, HashSet`1<string> projectsToSkip);
    public static void ValidateProjectSpec(PackageSpec spec);
    private static void ValidateFrameworks(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectSpecPackageReference(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectSpecUAP(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateStandaloneSpec(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateToolSpec(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectSpecOther(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectMetadata(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectMSBuildMetadata(PackageSpec spec, IEnumerable`1<string> files);
    private static IEnumerable`1<LibraryDependency> GetAllDependencies(PackageSpec spec);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Commands.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string CannotBeUsedWithOtherValues { get; }
    internal static string ClientCertificatesFileCertFilePath { get; }
    internal static string ClientCertificatesFileCertNoPassword { get; }
    internal static string ClientCertificatesFileCertWithPassword { get; }
    internal static string ClientCertificatesItemCertificateError { get; }
    internal static string ClientCertificatesItemCertificateMessage { get; }
    internal static string ClientCertificatesLogTitle { get; }
    internal static string ClientCertificatesStoreCertFindBy { get; }
    internal static string ClientCertificatesStoreCertFindValue { get; }
    internal static string ClientCertificatesStoreCertStoreLocation { get; }
    internal static string ClientCertificatesStoreCertStoreName { get; }
    internal static string ClientCertificateSuccessfullyAdded { get; }
    internal static string ClientCertificateSuccessfullyRemoved { get; }
    internal static string ClientCertificateSuccessfullyUpdated { get; }
    internal static string Error_AuthorTrustExpectedAuthorSignature { get; }
    internal static string Error_CannotFindMsbuild { get; }
    internal static string Error_CannotTrustOwnersForAuthor { get; }
    internal static string Error_CentralPackageVersions_AutoreferencedReferencesNotAllowed { get; }
    internal static string Error_CentralPackageVersions_FloatingVersionsAreNotAllowed { get; }
    internal static string Error_CentralPackageVersions_MissingPackageVersion { get; }
    internal static string Error_CentralPackageVersions_VersionOverrideDisabled { get; }
    internal static string Error_CentralPackageVersions_VersionsNotAllowed { get; }
    internal static string Error_ClientCertificateAlreadyExist { get; }
    internal static string Error_ClientCertificateNotExist { get; }
    internal static string Error_ClientCertificatesNotFound { get; }
    internal static string Error_ClientCertificateTypeMismatch { get; }
    internal static string Error_CouldNotAdd { get; }
    internal static string Error_CouldNotList { get; }
    internal static string Error_CouldNotRemove { get; }
    internal static string Error_CouldNotSync { get; }
    internal static string Error_CouldNotUpdateClientCertificate { get; }
    internal static string Error_CouldNotUpdateMetadataLastAccessTime { get; }
    internal static string Error_EmptyCertificateListInRepository { get; }
    internal static string Error_EmptySourceFilePath { get; }
    internal static string Error_EmptySourceFileProjectDirectory { get; }
    internal static string Error_IncompatiblePackageType { get; }
    internal static string Error_InputFileNotSpecified { get; }
    internal static string Error_InvalidATF { get; }
    internal static string Error_InvalidCertificateInformationFromServer { get; }
    internal static string Error_InvalidCombinationOfArguments { get; }
    internal static string Error_InvalidCommandLineInput { get; }
    internal static string Error_InvalidCommandLineInputConfig { get; }
    internal static string Error_InvalidCommandLineInputJson { get; }
    internal static string Error_InvalidDependencyVersionConstraints { get; }
    internal static string Error_InvalidLockFileInput { get; }
    internal static string Error_InvalidNuGetAuditLevelValue { get; }
    internal static string Error_InvalidNuGetAuditModeValue { get; }
    internal static string Error_InvalidNuGetAuditValue { get; }
    internal static string Error_InvalidProjectPackageCombo { get; }
    internal static string Error_InvalidSymbolPackageFormat { get; }
    internal static string Error_InvalidTargetFramework { get; }
    internal static string Error_InvalidWindowsTargetPlatformMinVersion { get; }
    internal static string Error_MissingSourceParameter { get; }
    internal static string Error_MultiplePackagePaths { get; }
    internal static string Error_NoClientAllowList { get; }
    internal static string Error_NoMatchingCertificate { get; }
    internal static string Error_NoMatchingClientCertificate { get; }
    internal static string Error_NoPackageVersionsExist { get; }
    internal static string Error_NoPackageVersionsExistInRange { get; }
    internal static string Error_NoSignatureTrustedForPackage { get; }
    internal static string Error_NoSourcesInformation { get; }
    internal static string Error_NoStablePackageVersionsExist { get; }
    internal static string Error_NotSupportedHashAlgorithm { get; }
    internal static string Error_PackageCommandNoFilesForLibPackage { get; }
    internal static string Error_PackageCommandNoFilesForSymbolsPackage { get; }
    internal static string Error_PackageDownload_NoVersion { get; }
    internal static string Error_PackageDownload_OnlyExactVersionsAreAllowed { get; }
    internal static string Error_PackageNotSigned { get; }
    internal static string Error_PackageValidationFailed { get; }
    internal static string Error_PackFailed { get; }
    internal static string Error_PlatformVersionNotPresent { get; }
    internal static string Error_ProjectDoesNotExist { get; }
    internal static string Error_ProjectRuntimeJsonIsUnreadable { get; }
    internal static string Error_ProjectRuntimeJsonNotFound { get; }
    internal static string Error_ProjectWithIncorrectDependenciesCount { get; }
    internal static string Error_PropertyCannotBeNullOrEmpty { get; }
    internal static string Error_RepoTrustExpectedRepoSignature { get; }
    internal static string Error_RestoreInLockedMode { get; }
    internal static string Error_ServiceIndexShouldBeHttps { get; }
    internal static string Error_ToolsPackageWithExtraPackageTypes { get; }
    internal static string Error_TrustedAuthorNoOwners { get; }
    internal static string Error_TrustedRepoAlreadyExists { get; }
    internal static string Error_TrustedRepositoryDoesNotExist { get; }
    internal static string Error_TrustedSignerAlreadyExists { get; }
    internal static string Error_UnableToFindProjectInfo { get; }
    internal static string Error_UnableToLocateBuildOutput { get; }
    internal static string Error_UnableToLocateRestoreTarget { get; }
    internal static string Error_UnableToSignPackage { get; }
    internal static string Error_UnavailableSource { get; }
    internal static string Error_UnknownBuildAction { get; }
    internal static string Error_UnknownClientCertificatesFindBy { get; }
    internal static string Error_UnknownClientCertificatesStoreLocation { get; }
    internal static string Error_UnknownClientCertificatesStoreName { get; }
    internal static string Error_UnknownClientCertificateStoreType { get; }
    internal static string Error_UnsupportedTrustTarget { get; }
    internal static string Error_VulnerabilityDataFetch { get; }
    internal static string Error_WriteResolvedNuSpecOverwriteOriginal { get; }
    internal static string Error_XPROJNotAllowed { get; }
    internal static string FailedToBuildProject { get; }
    internal static string FileNotAddedToPackage { get; }
    internal static string FoundVersionsInSource { get; }
    internal static string FoundVersionsInSourceWithoutMatch { get; }
    internal static string InvalidRestoreInput { get; }
    internal static string InvalidRestoreInputWithFiles { get; }
    internal static string InvalidSource { get; }
    internal static string LocalsCommand_ClearedSuccessful { get; }
    internal static string LocalsCommand_ClearFailed { get; }
    internal static string LocalsCommand_ClearingNuGetGlobalPackagesFolder { get; }
    internal static string LocalsCommand_ClearingNuGetHttpCache { get; }
    internal static string LocalsCommand_ClearingNuGetPluginsCache { get; }
    internal static string LocalsCommand_ClearingNuGetTempCache { get; }
    internal static string LocalsCommand_FailedToDeletePath { get; }
    internal static string LocalsCommand_Help { get; }
    internal static string LocalsCommand_InvalidLocalResourceName { get; }
    internal static string LocalsCommand_LocalResourcePathNotSet { get; }
    internal static string LocalsCommand_LocalsPartiallyCleared { get; }
    internal static string Log_AllProjectsUpToDate { get; }
    internal static string Log_AssetsFileNotOnDisk { get; }
    internal static string Log_Committing { get; }
    internal static string Log_ConfigFileSummary { get; }
    internal static string Log_ConvertedPackageToOriginalCase { get; }
    internal static string Log_CPVM_DowngradeError { get; }
    internal static string Log_CycleDetected { get; }
    internal static string Log_DependencyBumpedUp { get; }
    internal static string Log_DowngradeWarning { get; }
    internal static string Log_ErrorSummary { get; }
    internal static string Log_FeedsUsedSummary { get; }
    internal static string Log_FrameworkDisplay { get; }
    internal static string Log_FrameworkRIDDisplay { get; }
    internal static string Log_GeneratingMsBuildFile { get; }
    internal static string Log_ImportsFallbackWarning { get; }
    internal static string Log_InstalledSummary { get; }
    internal static string Log_InstalledSummaryCount { get; }
    internal static string Log_LockFileNotOnDisk { get; }
    internal static string Log_MergingRuntimes { get; }
    internal static string Log_MissingImplementationFx { get; }
    internal static string Log_MissingImplementationFxRuntime { get; }
    internal static string Log_MissingPackagesOnDisk { get; }
    internal static string Log_PackageCommandAddedFile { get; }
    internal static string Log_PackageCommandAttemptingToBuildSymbolsPackage { get; }
    internal static string Log_PackageCommandInstallPackageToOutputPath { get; }
    internal static string Log_PackageCommandSuccess { get; }
    internal static string Log_PackageContentHashValidationFailed { get; }
    internal static string Log_PackageNotCompatibleWithFx { get; }
    internal static string Log_PackageNotCompatibleWithFx_NoSupports { get; }
    internal static string Log_PackageNotCompatibleWithFx_Supports { get; }
    internal static string Log_PackagesAndProjectsAreCompatible { get; }
    internal static string Log_ProjectDoesNotSpecifyTargetFrameworks { get; }
    internal static string Log_ProjectNotCompatibleWithFx { get; }
    internal static string Log_ProjectNotCompatibleWithFx_NoSupports { get; }
    internal static string Log_ProjectNotCompatibleWithFx_Supports { get; }
    internal static string Log_ProjectUpToDateSummary { get; }
    internal static string Log_PropsFileNotOnDisk { get; }
    internal static string Log_ReadingProject { get; }
    internal static string Log_ResolverConflict { get; }
    internal static string Log_ResolvingConflicts { get; }
    internal static string Log_RestoreComplete { get; }
    internal static string Log_RestoreCompleteDotnetTool { get; }
    internal static string Log_RestoreFailed { get; }
    internal static string Log_RestoreFailedDotnetTool { get; }
    internal static string Log_RestoreNoOpDGChanged { get; }
    internal static string Log_RestoreNoOpFinish { get; }
    internal static string Log_RestoringPackages { get; }
    internal static string Log_RunningNonParallelRestore { get; }
    internal static string Log_RunningParallelRestore { get; }
    internal static string Log_ScanningForRuntimeJson { get; }
    internal static string Log_SkippingAssetsFile { get; }
    internal static string Log_SkippingCacheFile { get; }
    internal static string Log_SkippingCompatibiilityCheckOnRidlessGraphForDotnetToolReferenceProject { get; }
    internal static string Log_SkippingPackagesLockFileGeneration { get; }
    internal static string Log_SourceMappingEnabledNoMatchingPackageSources { get; }
    internal static string Log_TargetsFileNotOnDisk { get; }
    internal static string Log_ToolSkippingAssetsFile { get; }
    internal static string Log_ToolWritingAssetsFile { get; }
    internal static string Log_ToolWritingCacheFile { get; }
    internal static string Log_UnknownCompatibilityProfile { get; }
    internal static string Log_UnresolvedDependency { get; }
    internal static string Log_VersionConflict { get; }
    internal static string Log_WritingAssetsFile { get; }
    internal static string Log_WritingCacheFile { get; }
    internal static string Log_WritingPackagesLockFile { get; }
    internal static string MissingRequiredProperty { get; }
    internal static string MissingRequiredPropertyForProjectType { get; }
    internal static string MSBuildWarning_MultiTarget { get; }
    internal static string Multiple_Nupkgs_Detected { get; }
    internal static string NoClientCertificates { get; }
    internal static string NoClientCertificatesMatching { get; }
    internal static string NonMatchingProperties { get; }
    internal static string NoTrustedSigners { get; }
    internal static string NoTrustedSignersMatching { get; }
    internal static string NuGetDocs { get; }
    internal static string PropertyNotAllowed { get; }
    internal static string PropertyNotAllowedForProjectType { get; }
    internal static string RegsiteredClientCertificates { get; }
    internal static string RegsiteredTrustedSigners { get; }
    internal static string ReservedPackageNameAll { get; }
    internal static string ResolverRequest_ToStringFormat { get; }
    internal static string SignCommandCertificateFileNotFound { get; }
    internal static string SignCommandCertificateStoreNotFound { get; }
    internal static string SignCommandDialogMessage { get; }
    internal static string SignCommandDialogTitle { get; }
    internal static string SignCommandDisplayCertificate { get; }
    internal static string SignCommandDisplayTimestamper { get; }
    internal static string SignCommandInvalidCertException { get; }
    internal static string SignCommandInvalidPasswordException { get; }
    internal static string SignCommandMultipleCertException { get; }
    internal static string SignCommandNoCertException { get; }
    internal static string SignCommandOutputPath { get; }
    internal static string SignCommandSuccess { get; }
    internal static string Source_DefaultNamePrefix { get; }
    internal static string Source_InvalidFormatValue { get; }
    internal static string SourceNotConsidered { get; }
    internal static string SourcesCommandAllNameIsReserved { get; }
    internal static string SourcesCommandClearingExistingAuthTypes { get; }
    internal static string SourcesCommandCredentialsRequired { get; }
    internal static string SourcesCommandCredentialsRequiredWithAuthTypes { get; }
    internal static string SourcesCommandDisabled { get; }
    internal static string SourcesCommandEnabled { get; }
    internal static string SourcesCommandInvalidSource { get; }
    internal static string SourcesCommandNoMatchingSourcesFound { get; }
    internal static string SourcesCommandNoSources { get; }
    internal static string SourcesCommandRegisteredSources { get; }
    internal static string SourcesCommandSourceAddedSuccessfully { get; }
    internal static string SourcesCommandSourceDisabledSuccessfully { get; }
    internal static string SourcesCommandSourceEnabledSuccessfully { get; }
    internal static string SourcesCommandSourceRemovedSuccessfully { get; }
    internal static string SourcesCommandUniqueName { get; }
    internal static string SourcesCommandUniqueSource { get; }
    internal static string SourcesCommandUpdateSuccessful { get; }
    internal static string SourcesCommandValidProtocolVersion { get; }
    internal static string SpecValidation_OriginalTargetFrameworksMustMatchAliases { get; }
    internal static string SpecValidationDuplicateFrameworks { get; }
    internal static string SpecValidationInvalidFramework { get; }
    internal static string SpecValidationMissingProject { get; }
    internal static string SpecValidationNoFrameworks { get; }
    internal static string SpecValidationUAPSingleFramework { get; }
    internal static string SpecValidationZeroRestoreRequests { get; }
    internal static string SuccessfullUpdatedTrustedSigner { get; }
    internal static string SuccessfullyAddedTrustedAuthor { get; }
    internal static string SuccessfullyAddedTrustedRepository { get; }
    internal static string SuccessfullyRemovedTrustedSigner { get; }
    internal static string SuccessfullySynchronizedTrustedRepository { get; }
    internal static string TrustedSignerLogCertificates { get; }
    internal static string TrustedSignerLogCertificateSummaryAllowUntrustedRoot { get; }
    internal static string TrustedSignerLogCertificateSummaryUnallowUntrustedRoot { get; }
    internal static string TrustedSignerLogOwners { get; }
    internal static string TrustedSignerLogServiceIndex { get; }
    internal static string TrustedSignerLogTitle { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UnsupportedProject { get; }
    internal static string VerifyCommand_Failed { get; }
    internal static string VerifyCommand_FinishedWithErrors { get; }
    internal static string VerifyCommand_NotSupported { get; }
    internal static string VerifyCommand_PackageIsNotValid { get; }
    internal static string VerifyCommand_Success { get; }
    internal static string VerifyCommand_VerificationTypeNotSupported { get; }
    internal static string VerifyCommand_VerifyingPackage { get; }
    internal static string Vulnerability_Severity_Critical { get; }
    internal static string Vulnerability_Severity_High { get; }
    internal static string Vulnerability_Severity_Low { get; }
    internal static string Vulnerability_Severity_Moderate { get; }
    internal static string Vulnerability_Severity_unknown { get; }
    internal static string Warning_CentralPackageVersions_MultipleSourcesWithoutPackageSourceMapping { get; }
    internal static string Warning_DuplicatePropertyKey { get; }
    internal static string Warning_FileExcludedByDefault { get; }
    internal static string Warning_HttpServerUsage { get; }
    internal static string Warning_HttpServerUsage_MultipleSources { get; }
    internal static string Warning_MinVersionDoesNotExist { get; }
    internal static string Warning_MinVersionNonInclusive { get; }
    internal static string Warning_NoVulnerabilityData { get; }
    internal static string Warning_PackageWithKnownVulnerability { get; }
    internal static string Warning_ProjectDependencyMissingLowerBound { get; }
    internal static string Warning_ProjectDependencyMissingVersion { get; }
    internal static string Warning_VersionAboveUpperBound { get; }
    internal static string WarningAsError { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_CannotBeUsedWithOtherValues();
    internal static string get_ClientCertificatesFileCertFilePath();
    internal static string get_ClientCertificatesFileCertNoPassword();
    internal static string get_ClientCertificatesFileCertWithPassword();
    internal static string get_ClientCertificatesItemCertificateError();
    internal static string get_ClientCertificatesItemCertificateMessage();
    internal static string get_ClientCertificatesLogTitle();
    internal static string get_ClientCertificatesStoreCertFindBy();
    internal static string get_ClientCertificatesStoreCertFindValue();
    internal static string get_ClientCertificatesStoreCertStoreLocation();
    internal static string get_ClientCertificatesStoreCertStoreName();
    internal static string get_ClientCertificateSuccessfullyAdded();
    internal static string get_ClientCertificateSuccessfullyRemoved();
    internal static string get_ClientCertificateSuccessfullyUpdated();
    internal static string get_Error_AuthorTrustExpectedAuthorSignature();
    internal static string get_Error_CannotFindMsbuild();
    internal static string get_Error_CannotTrustOwnersForAuthor();
    internal static string get_Error_CentralPackageVersions_AutoreferencedReferencesNotAllowed();
    internal static string get_Error_CentralPackageVersions_FloatingVersionsAreNotAllowed();
    internal static string get_Error_CentralPackageVersions_MissingPackageVersion();
    internal static string get_Error_CentralPackageVersions_VersionOverrideDisabled();
    internal static string get_Error_CentralPackageVersions_VersionsNotAllowed();
    internal static string get_Error_ClientCertificateAlreadyExist();
    internal static string get_Error_ClientCertificateNotExist();
    internal static string get_Error_ClientCertificatesNotFound();
    internal static string get_Error_ClientCertificateTypeMismatch();
    internal static string get_Error_CouldNotAdd();
    internal static string get_Error_CouldNotList();
    internal static string get_Error_CouldNotRemove();
    internal static string get_Error_CouldNotSync();
    internal static string get_Error_CouldNotUpdateClientCertificate();
    internal static string get_Error_CouldNotUpdateMetadataLastAccessTime();
    internal static string get_Error_EmptyCertificateListInRepository();
    internal static string get_Error_EmptySourceFilePath();
    internal static string get_Error_EmptySourceFileProjectDirectory();
    internal static string get_Error_IncompatiblePackageType();
    internal static string get_Error_InputFileNotSpecified();
    internal static string get_Error_InvalidATF();
    internal static string get_Error_InvalidCertificateInformationFromServer();
    internal static string get_Error_InvalidCombinationOfArguments();
    internal static string get_Error_InvalidCommandLineInput();
    internal static string get_Error_InvalidCommandLineInputConfig();
    internal static string get_Error_InvalidCommandLineInputJson();
    internal static string get_Error_InvalidDependencyVersionConstraints();
    internal static string get_Error_InvalidLockFileInput();
    internal static string get_Error_InvalidNuGetAuditLevelValue();
    internal static string get_Error_InvalidNuGetAuditModeValue();
    internal static string get_Error_InvalidNuGetAuditValue();
    internal static string get_Error_InvalidProjectPackageCombo();
    internal static string get_Error_InvalidSymbolPackageFormat();
    internal static string get_Error_InvalidTargetFramework();
    internal static string get_Error_InvalidWindowsTargetPlatformMinVersion();
    internal static string get_Error_MissingSourceParameter();
    internal static string get_Error_MultiplePackagePaths();
    internal static string get_Error_NoClientAllowList();
    internal static string get_Error_NoMatchingCertificate();
    internal static string get_Error_NoMatchingClientCertificate();
    internal static string get_Error_NoPackageVersionsExist();
    internal static string get_Error_NoPackageVersionsExistInRange();
    internal static string get_Error_NoSignatureTrustedForPackage();
    internal static string get_Error_NoSourcesInformation();
    internal static string get_Error_NoStablePackageVersionsExist();
    internal static string get_Error_NotSupportedHashAlgorithm();
    internal static string get_Error_PackageCommandNoFilesForLibPackage();
    internal static string get_Error_PackageCommandNoFilesForSymbolsPackage();
    internal static string get_Error_PackageDownload_NoVersion();
    internal static string get_Error_PackageDownload_OnlyExactVersionsAreAllowed();
    internal static string get_Error_PackageNotSigned();
    internal static string get_Error_PackageValidationFailed();
    internal static string get_Error_PackFailed();
    internal static string get_Error_PlatformVersionNotPresent();
    internal static string get_Error_ProjectDoesNotExist();
    internal static string get_Error_ProjectRuntimeJsonIsUnreadable();
    internal static string get_Error_ProjectRuntimeJsonNotFound();
    internal static string get_Error_ProjectWithIncorrectDependenciesCount();
    internal static string get_Error_PropertyCannotBeNullOrEmpty();
    internal static string get_Error_RepoTrustExpectedRepoSignature();
    internal static string get_Error_RestoreInLockedMode();
    internal static string get_Error_ServiceIndexShouldBeHttps();
    internal static string get_Error_ToolsPackageWithExtraPackageTypes();
    internal static string get_Error_TrustedAuthorNoOwners();
    internal static string get_Error_TrustedRepoAlreadyExists();
    internal static string get_Error_TrustedRepositoryDoesNotExist();
    internal static string get_Error_TrustedSignerAlreadyExists();
    internal static string get_Error_UnableToFindProjectInfo();
    internal static string get_Error_UnableToLocateBuildOutput();
    internal static string get_Error_UnableToLocateRestoreTarget();
    internal static string get_Error_UnableToSignPackage();
    internal static string get_Error_UnavailableSource();
    internal static string get_Error_UnknownBuildAction();
    internal static string get_Error_UnknownClientCertificatesFindBy();
    internal static string get_Error_UnknownClientCertificatesStoreLocation();
    internal static string get_Error_UnknownClientCertificatesStoreName();
    internal static string get_Error_UnknownClientCertificateStoreType();
    internal static string get_Error_UnsupportedTrustTarget();
    internal static string get_Error_VulnerabilityDataFetch();
    internal static string get_Error_WriteResolvedNuSpecOverwriteOriginal();
    internal static string get_Error_XPROJNotAllowed();
    internal static string get_FailedToBuildProject();
    internal static string get_FileNotAddedToPackage();
    internal static string get_FoundVersionsInSource();
    internal static string get_FoundVersionsInSourceWithoutMatch();
    internal static string get_InvalidRestoreInput();
    internal static string get_InvalidRestoreInputWithFiles();
    internal static string get_InvalidSource();
    internal static string get_LocalsCommand_ClearedSuccessful();
    internal static string get_LocalsCommand_ClearFailed();
    internal static string get_LocalsCommand_ClearingNuGetGlobalPackagesFolder();
    internal static string get_LocalsCommand_ClearingNuGetHttpCache();
    internal static string get_LocalsCommand_ClearingNuGetPluginsCache();
    internal static string get_LocalsCommand_ClearingNuGetTempCache();
    internal static string get_LocalsCommand_FailedToDeletePath();
    internal static string get_LocalsCommand_Help();
    internal static string get_LocalsCommand_InvalidLocalResourceName();
    internal static string get_LocalsCommand_LocalResourcePathNotSet();
    internal static string get_LocalsCommand_LocalsPartiallyCleared();
    internal static string get_Log_AllProjectsUpToDate();
    internal static string get_Log_AssetsFileNotOnDisk();
    internal static string get_Log_Committing();
    internal static string get_Log_ConfigFileSummary();
    internal static string get_Log_ConvertedPackageToOriginalCase();
    internal static string get_Log_CPVM_DowngradeError();
    internal static string get_Log_CycleDetected();
    internal static string get_Log_DependencyBumpedUp();
    internal static string get_Log_DowngradeWarning();
    internal static string get_Log_ErrorSummary();
    internal static string get_Log_FeedsUsedSummary();
    internal static string get_Log_FrameworkDisplay();
    internal static string get_Log_FrameworkRIDDisplay();
    internal static string get_Log_GeneratingMsBuildFile();
    internal static string get_Log_ImportsFallbackWarning();
    internal static string get_Log_InstalledSummary();
    internal static string get_Log_InstalledSummaryCount();
    internal static string get_Log_LockFileNotOnDisk();
    internal static string get_Log_MergingRuntimes();
    internal static string get_Log_MissingImplementationFx();
    internal static string get_Log_MissingImplementationFxRuntime();
    internal static string get_Log_MissingPackagesOnDisk();
    internal static string get_Log_PackageCommandAddedFile();
    internal static string get_Log_PackageCommandAttemptingToBuildSymbolsPackage();
    internal static string get_Log_PackageCommandInstallPackageToOutputPath();
    internal static string get_Log_PackageCommandSuccess();
    internal static string get_Log_PackageContentHashValidationFailed();
    internal static string get_Log_PackageNotCompatibleWithFx();
    internal static string get_Log_PackageNotCompatibleWithFx_NoSupports();
    internal static string get_Log_PackageNotCompatibleWithFx_Supports();
    internal static string get_Log_PackagesAndProjectsAreCompatible();
    internal static string get_Log_ProjectDoesNotSpecifyTargetFrameworks();
    internal static string get_Log_ProjectNotCompatibleWithFx();
    internal static string get_Log_ProjectNotCompatibleWithFx_NoSupports();
    internal static string get_Log_ProjectNotCompatibleWithFx_Supports();
    internal static string get_Log_ProjectUpToDateSummary();
    internal static string get_Log_PropsFileNotOnDisk();
    internal static string get_Log_ReadingProject();
    internal static string get_Log_ResolverConflict();
    internal static string get_Log_ResolvingConflicts();
    internal static string get_Log_RestoreComplete();
    internal static string get_Log_RestoreCompleteDotnetTool();
    internal static string get_Log_RestoreFailed();
    internal static string get_Log_RestoreFailedDotnetTool();
    internal static string get_Log_RestoreNoOpDGChanged();
    internal static string get_Log_RestoreNoOpFinish();
    internal static string get_Log_RestoringPackages();
    internal static string get_Log_RunningNonParallelRestore();
    internal static string get_Log_RunningParallelRestore();
    internal static string get_Log_ScanningForRuntimeJson();
    internal static string get_Log_SkippingAssetsFile();
    internal static string get_Log_SkippingCacheFile();
    internal static string get_Log_SkippingCompatibiilityCheckOnRidlessGraphForDotnetToolReferenceProject();
    internal static string get_Log_SkippingPackagesLockFileGeneration();
    internal static string get_Log_SourceMappingEnabledNoMatchingPackageSources();
    internal static string get_Log_TargetsFileNotOnDisk();
    internal static string get_Log_ToolSkippingAssetsFile();
    internal static string get_Log_ToolWritingAssetsFile();
    internal static string get_Log_ToolWritingCacheFile();
    internal static string get_Log_UnknownCompatibilityProfile();
    internal static string get_Log_UnresolvedDependency();
    internal static string get_Log_VersionConflict();
    internal static string get_Log_WritingAssetsFile();
    internal static string get_Log_WritingCacheFile();
    internal static string get_Log_WritingPackagesLockFile();
    internal static string get_MissingRequiredProperty();
    internal static string get_MissingRequiredPropertyForProjectType();
    internal static string get_MSBuildWarning_MultiTarget();
    internal static string get_Multiple_Nupkgs_Detected();
    internal static string get_NoClientCertificates();
    internal static string get_NoClientCertificatesMatching();
    internal static string get_NonMatchingProperties();
    internal static string get_NoTrustedSigners();
    internal static string get_NoTrustedSignersMatching();
    internal static string get_NuGetDocs();
    internal static string get_PropertyNotAllowed();
    internal static string get_PropertyNotAllowedForProjectType();
    internal static string get_RegsiteredClientCertificates();
    internal static string get_RegsiteredTrustedSigners();
    internal static string get_ReservedPackageNameAll();
    internal static string get_ResolverRequest_ToStringFormat();
    internal static string get_SignCommandCertificateFileNotFound();
    internal static string get_SignCommandCertificateStoreNotFound();
    internal static string get_SignCommandDialogMessage();
    internal static string get_SignCommandDialogTitle();
    internal static string get_SignCommandDisplayCertificate();
    internal static string get_SignCommandDisplayTimestamper();
    internal static string get_SignCommandInvalidCertException();
    internal static string get_SignCommandInvalidPasswordException();
    internal static string get_SignCommandMultipleCertException();
    internal static string get_SignCommandNoCertException();
    internal static string get_SignCommandOutputPath();
    internal static string get_SignCommandSuccess();
    internal static string get_Source_DefaultNamePrefix();
    internal static string get_Source_InvalidFormatValue();
    internal static string get_SourceNotConsidered();
    internal static string get_SourcesCommandAllNameIsReserved();
    internal static string get_SourcesCommandClearingExistingAuthTypes();
    internal static string get_SourcesCommandCredentialsRequired();
    internal static string get_SourcesCommandCredentialsRequiredWithAuthTypes();
    internal static string get_SourcesCommandDisabled();
    internal static string get_SourcesCommandEnabled();
    internal static string get_SourcesCommandInvalidSource();
    internal static string get_SourcesCommandNoMatchingSourcesFound();
    internal static string get_SourcesCommandNoSources();
    internal static string get_SourcesCommandRegisteredSources();
    internal static string get_SourcesCommandSourceAddedSuccessfully();
    internal static string get_SourcesCommandSourceDisabledSuccessfully();
    internal static string get_SourcesCommandSourceEnabledSuccessfully();
    internal static string get_SourcesCommandSourceRemovedSuccessfully();
    internal static string get_SourcesCommandUniqueName();
    internal static string get_SourcesCommandUniqueSource();
    internal static string get_SourcesCommandUpdateSuccessful();
    internal static string get_SourcesCommandValidProtocolVersion();
    internal static string get_SpecValidation_OriginalTargetFrameworksMustMatchAliases();
    internal static string get_SpecValidationDuplicateFrameworks();
    internal static string get_SpecValidationInvalidFramework();
    internal static string get_SpecValidationMissingProject();
    internal static string get_SpecValidationNoFrameworks();
    internal static string get_SpecValidationUAPSingleFramework();
    internal static string get_SpecValidationZeroRestoreRequests();
    internal static string get_SuccessfullUpdatedTrustedSigner();
    internal static string get_SuccessfullyAddedTrustedAuthor();
    internal static string get_SuccessfullyAddedTrustedRepository();
    internal static string get_SuccessfullyRemovedTrustedSigner();
    internal static string get_SuccessfullySynchronizedTrustedRepository();
    internal static string get_TrustedSignerLogCertificates();
    internal static string get_TrustedSignerLogCertificateSummaryAllowUntrustedRoot();
    internal static string get_TrustedSignerLogCertificateSummaryUnallowUntrustedRoot();
    internal static string get_TrustedSignerLogOwners();
    internal static string get_TrustedSignerLogServiceIndex();
    internal static string get_TrustedSignerLogTitle();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UnsupportedProject();
    internal static string get_VerifyCommand_Failed();
    internal static string get_VerifyCommand_FinishedWithErrors();
    internal static string get_VerifyCommand_NotSupported();
    internal static string get_VerifyCommand_PackageIsNotValid();
    internal static string get_VerifyCommand_Success();
    internal static string get_VerifyCommand_VerificationTypeNotSupported();
    internal static string get_VerifyCommand_VerifyingPackage();
    internal static string get_Vulnerability_Severity_Critical();
    internal static string get_Vulnerability_Severity_High();
    internal static string get_Vulnerability_Severity_Low();
    internal static string get_Vulnerability_Severity_Moderate();
    internal static string get_Vulnerability_Severity_unknown();
    internal static string get_Warning_CentralPackageVersions_MultipleSourcesWithoutPackageSourceMapping();
    internal static string get_Warning_DuplicatePropertyKey();
    internal static string get_Warning_FileExcludedByDefault();
    internal static string get_Warning_HttpServerUsage();
    internal static string get_Warning_HttpServerUsage_MultipleSources();
    internal static string get_Warning_MinVersionDoesNotExist();
    internal static string get_Warning_MinVersionNonInclusive();
    internal static string get_Warning_NoVulnerabilityData();
    internal static string get_Warning_PackageWithKnownVulnerability();
    internal static string get_Warning_ProjectDependencyMissingLowerBound();
    internal static string get_Warning_ProjectDependencyMissingVersion();
    internal static string get_Warning_VersionAboveUpperBound();
    internal static string get_WarningAsError();
}
internal enum NuGet.Commands.SymbolPackageFormat : Enum {
    public int value__;
    public static SymbolPackageFormat Snupkg;
    public static SymbolPackageFormat SymbolsNupkg;
}
internal static class NuGet.Commands.ToolRestoreUtility : object {
    public static PackageSpec GetSpec(string projectFilePath, string id, VersionRange versionRange, NuGetFramework framework, string packagesPath, IList`1<string> fallbackFolders, IList`1<PackageSource> sources, WarningProperties projectWideWarningProperties);
    public static string GetUniqueName(string id, string framework, VersionRange versionRange);
    public static IReadOnlyList`1<RestoreSummaryRequest> GetSubSetRequests(IEnumerable`1<RestoreSummaryRequest> requestSummaries);
    public static IReadOnlyList`1<RestoreSummaryRequest> GetSubSetRequestsForSingleId(IEnumerable`1<RestoreSummaryRequest> requests);
    public static string GetToolIdOrNullFromSpec(PackageSpec spec);
    public static LibraryDependency GetToolDependencyOrNullFromSpec(PackageSpec spec);
    public static LockFileTargetLibrary GetToolTargetLibrary(LockFile toolLockFile, string toolId);
}
internal static class NuGet.Commands.TransitiveNoWarnUtils : object {
    public static WarningPropertiesCollection CreateTransitiveWarningPropertiesCollection(IEnumerable`1<RestoreTargetGraph> targetGraphs, PackageSpec parentProjectSpec);
    private static PackageSpecificWarningProperties ExtractTransitiveNoWarnProperties(RestoreTargetGraph targetGraph, string parentProjectName, HashSet`1<NuGetLogCode> parentProjectWideNoWarn, Dictionary`2<string, HashSet`1<NuGetLogCode>> parentPackageSpecificNoWarn, Dictionary`2<string, Dictionary`2<NuGetFramework, WarningPropertiesCollection>> warningPropertiesCache);
    private static WarningPropertiesCollection GetNodeWarningProperties(PackageSpec nodeProjectSpec, NuGetFramework framework, Dictionary`2<string, Dictionary`2<NuGetFramework, WarningPropertiesCollection>> warningPropertiesCache);
    private static bool AddToSeen(Dictionary`2<string, NodeWarningProperties> seen, DependencyNode node);
    private static void AddDependenciesToQueue(IEnumerable`1<LibraryDependency> dependencies, Queue`1<DependencyNode> queue, NodeWarningProperties nodeWarningProperties);
    private static PackageSpec GetNodePackageSpec(LocalMatch localMatch);
    public static HashSet`1<NuGetLogCode> ExtractPathNoWarnProperties(NodeWarningProperties nodeWarningProperties, string libraryId);
    public static HashSet`1<NuGetLogCode> MergeCodes(HashSet`1<NuGetLogCode> first, HashSet`1<NuGetLogCode> second);
    public static Dictionary`2<string, HashSet`1<NuGetLogCode>> MergePackageSpecificNoWarn(Dictionary`2<string, HashSet`1<NuGetLogCode>> first, Dictionary`2<string, HashSet`1<NuGetLogCode>> second);
    public static PackageSpecificWarningProperties MergePackageSpecificWarningProperties(PackageSpecificWarningProperties first, PackageSpecificWarningProperties second);
    public static bool TryMergeNullObjects(T first, T second, T& merged);
    private static bool IsProject(LibraryDependencyTarget type);
    private static bool IsProject(LibraryType type);
    public static Dictionary`2<NuGetFramework, Dictionary`2<string, HashSet`1<NuGetLogCode>>> ExtractPackageSpecificNoWarnPerFramework(PackageSpecificWarningProperties packageSpecificWarningProperties);
    public static Dictionary`2<string, HashSet`1<NuGetLogCode>> ExtractPackageSpecificNoWarnForFramework(PackageSpecificWarningProperties packageSpecificWarningProperties, NuGetFramework framework);
}
internal class NuGet.Commands.TrustedSignerActionsProvider : object {
    private ITrustedSignersProvider _trustedSignersProvider;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private SourceRepository <ServiceIndexSourceRepository>k__BackingField;
    internal SourceRepository ServiceIndexSourceRepository { get; internal set; }
    public TrustedSignerActionsProvider(ITrustedSignersProvider trustedSignersProvider, ILogger logger);
    [CompilerGeneratedAttribute]
internal SourceRepository get_ServiceIndexSourceRepository();
    [CompilerGeneratedAttribute]
internal void set_ServiceIndexSourceRepository(SourceRepository value);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignerActionsProvider/<SyncTrustedRepositoryAsync>d__7")]
public Task SyncTrustedRepositoryAsync(string name, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignerActionsProvider/<AddTrustedSignerAsync>d__8")]
public Task AddTrustedSignerAsync(string name, ISignedPackageReader package, VerificationTarget trustTarget, bool allowUntrustedRoot, IEnumerable`1<string> owners, CancellationToken token);
    public void AddOrUpdateTrustedSigner(string name, string fingerprint, HashAlgorithmName hashAlgorithm, bool allowUntrustedRoot);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignerActionsProvider/<AddTrustedRepositoryAsync>d__10")]
public Task AddTrustedRepositoryAsync(string name, Uri serviceIndex, IEnumerable`1<string> owners, CancellationToken token);
    private void ValidateNoExistingSigner(string name, string serviceIndex, bool validateServiceIndex);
    private CertificateItem GetCertificateItemForSignature(ISignature signature, bool allowUntrustedRoot);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignerActionsProvider/<GetCertificateItemsFromServiceIndexAsync>d__13")]
private Task`1<CertificateItem[]> GetCertificateItemsFromServiceIndexAsync(string serviceIndex, CancellationToken token);
    private string CreateOwnersList(IEnumerable`1<string> owners);
}
internal class NuGet.Commands.TrustedSignersArgs : object {
    [CompilerGeneratedAttribute]
private TrustedSignersAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateFingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FingerprintAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrustedRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public TrustedSignersAction Action { get; public set; }
    public string Name { get; public set; }
    public string ServiceIndex { get; public set; }
    public string CertificateFingerprint { get; public set; }
    public string FingerprintAlgorithm { get; public set; }
    public bool AllowUntrustedRoot { get; public set; }
    public bool Author { get; public set; }
    public bool Repository { get; public set; }
    public IEnumerable`1<string> Owners { get; public set; }
    public string PackagePath { get; public set; }
    public ILogger Logger { get; public set; }
    [CompilerGeneratedAttribute]
public TrustedSignersAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(TrustedSignersAction value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ServiceIndex();
    [CompilerGeneratedAttribute]
public void set_ServiceIndex(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateFingerprint();
    [CompilerGeneratedAttribute]
public void set_CertificateFingerprint(string value);
    [CompilerGeneratedAttribute]
public string get_FingerprintAlgorithm();
    [CompilerGeneratedAttribute]
public void set_FingerprintAlgorithm(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowUntrustedRoot();
    [CompilerGeneratedAttribute]
public void set_AllowUntrustedRoot(bool value);
    [CompilerGeneratedAttribute]
public bool get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(bool value);
    [CompilerGeneratedAttribute]
public bool get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public void set_PackagePath(string value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
}
internal class NuGet.Commands.TrustedSignersCommandRunner : object {
    private static int SuccessCode;
    private ITrustedSignersProvider _trustedSignersProvider;
    private IPackageSourceProvider _packageSourceProvider;
    public TrustedSignersCommandRunner(ITrustedSignersProvider trustedSignersProvider, IPackageSourceProvider packageSourceProvider);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignersCommandRunner/<ExecuteCommandAsync>d__4")]
public sealed virtual Task`1<int> ExecuteCommandAsync(TrustedSignersArgs trustedSignersArgs);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignersCommandRunner/<ListAllTrustedSignersAsync>d__5")]
private Task ListAllTrustedSignersAsync(ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignersCommandRunner/<RemoveTrustedSignerAsync>d__6")]
private Task RemoveTrustedSignerAsync(string name, ILogger logger);
    private void ValidateListArguments(TrustedSignersArgs args);
    private void ValidateRemoveArguments(TrustedSignersArgs args);
    private void ValidateSyncArguments(TrustedSignersArgs args);
    private void ValidateNameExists(string name);
    private HashAlgorithmName ValidateAndParseFingerprintAlgorithm(string algorithm);
    private Uri ValidateAndParseV3ServiceIndexUrl(string serviceIndex);
}
[ExtensionAttribute]
internal static class NuGet.Commands.UnexpectedDependencyMessages : object {
    [AsyncStateMachineAttribute("NuGet.Commands.UnexpectedDependencyMessages/<LogAsync>d__0")]
public static Task LogAsync(IEnumerable`1<IRestoreTargetGraph> graphs, PackageSpec project, ILogger logger);
    public static IEnumerable`1<RestoreLogMessage> GetMissingLowerBounds(IEnumerable`1<IRestoreTargetGraph> graphs, ISet`1<string> ignoreIds);
    public static RestoreLogMessage GetMissingLowerBoundMessage(ResolvedDependencyKey dependency, String[] targetGraphs);
    public static IEnumerable`1<RestoreLogMessage> GetBumpedUpDependencies(List`1<IndexedRestoreTargetGraph> graphs, PackageSpec project, ISet`1<string> ignoreIds);
    internal static IEnumerable`1<RestoreLogMessage> GetProjectDependenciesMissingVersion(PackageSpec project);
    public static IEnumerable`1<RestoreLogMessage> GetProjectDependenciesMissingLowerBounds(PackageSpec project);
    public static bool DependencyRangeHasMissingExactMatch(ResolvedDependencyKey dependency);
    public static bool HasMissingLowerBound(VersionRange range);
    public static IEnumerable`1<RestoreLogMessage> GetDependenciesAboveUpperBounds(List`1<IndexedRestoreTargetGraph> graphs, ILogger logger);
    [ExtensionAttribute]
private static bool IsNonFloatingPackageDependency(LibraryDependency dependency);
    private static String[] GetDependencyTargetGraphs(PackageSpec spec, LibraryDependency dependency);
}
internal static class NuGet.Commands.UnresolvedMessages : object {
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<LogAsync>d__0")]
internal static Task LogAsync(IEnumerable`1<IRestoreTargetGraph> graphs, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<LogAsync>d__1")]
internal static Task LogAsync(IList`1<DownloadDependencyResolutionResult> downloadDependencyResults, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<GetMessageAsync>d__2")]
internal static Task`1<RestoreLogMessage> GetMessageAsync(string targetGraphName, LibraryRange unresolved, IList`1<IRemoteDependencyProvider> applicableRemoteLibraryProviders, bool isPackageSourceMappingEnabled, IList`1<IRemoteDependencyProvider> allRemoteLibraryProviders, SourceCacheContext sourceCacheContext, ILogger logger, CancellationToken token);
    private static IEnumerable`1<IRemoteDependencyProvider> GetUnusedLibraryProviders(IList`1<IRemoteDependencyProvider> applicableRemoteLibraryProviders, IList`1<IRemoteDependencyProvider> allRemoteLibraryProviders);
    private static string FormatProviderNames(IEnumerable`1<IRemoteDependencyProvider> allRemoteLibraryProviders);
    internal static bool HasPrereleaseVersionsOnly(VersionRange range, IEnumerable`1<NuGetVersion> versions);
    internal static bool IsPrereleaseAllowed(VersionRange range);
    internal static string FormatSourceInfo(KeyValuePair`2<PackageSource, SortedSet`1<NuGetVersion>> sourceInfo, VersionRange range);
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<GetSourceInfosForIdAsync>d__8")]
internal static Task`1<List`1<KeyValuePair`2<PackageSource, SortedSet`1<NuGetVersion>>>> GetSourceInfosForIdAsync(string id, IList`1<IRemoteDependencyProvider> remoteLibraryProviders, SourceCacheContext sourceCacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<GetSourceInfoForIdAsync>d__9")]
internal static Task`1<KeyValuePair`2<PackageSource, SortedSet`1<NuGetVersion>>> GetSourceInfoForIdAsync(IRemoteDependencyProvider provider, string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    internal static NuGetVersion GetBestMatch(SortedSet`1<NuGetVersion> versions, VersionRange range);
}
internal class NuGet.Commands.UpdateClientCertArgs : object {
    [CompilerGeneratedAttribute]
private string <PackageSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StorePasswordInClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StoreLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StoreName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FindBy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FindValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string PackageSource { get; public set; }
    public string Path { get; public set; }
    public string Password { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public string StoreLocation { get; public set; }
    public string StoreName { get; public set; }
    public string FindBy { get; public set; }
    public string FindValue { get; public set; }
    public bool Force { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageSource();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageSource(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Password();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Password(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StorePasswordInClearText();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StorePasswordInClearText(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StoreLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StoreLocation(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StoreName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StoreName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FindBy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FindBy(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FindValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FindValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Force();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Force(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configfile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configfile(string value);
}
internal static class NuGet.Commands.UpdateClientCertRunner : object {
    public static void Run(UpdateClientCertArgs args, Func`1<ILogger> getLogger);
}
internal class NuGet.Commands.UpdateSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StorePasswordInClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValidAuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Name { get; public set; }
    public string Source { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public string ValidAuthenticationTypes { get; public set; }
    public string ProtocolVersion { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public bool get_StorePasswordInClearText();
    [CompilerGeneratedAttribute]
public void set_StorePasswordInClearText(bool value);
    [CompilerGeneratedAttribute]
public string get_ValidAuthenticationTypes();
    [CompilerGeneratedAttribute]
public void set_ValidAuthenticationTypes(string value);
    [CompilerGeneratedAttribute]
public string get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
internal static class NuGet.Commands.UpdateSourceRunner : object {
    public static void Run(UpdateSourceArgs args, Func`1<ILogger> getLogger);
}
internal class NuGet.Commands.VerifyArgs : object {
    [CompilerGeneratedAttribute]
private IList`1<Verification> <Verifications>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackagePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CertificateFingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    public IList`1<Verification> Verifications { get; public set; }
    [ObsoleteAttribute("Use PackagePaths instead")]
public string PackagePath { get; public set; }
    public IReadOnlyList`1<string> PackagePaths { get; public set; }
    public ILogger Logger { get; public set; }
    public LogLevel LogLevel { get; public set; }
    public IEnumerable`1<string> CertificateFingerprint { get; public set; }
    public ISettings Settings { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<Verification> get_Verifications();
    [CompilerGeneratedAttribute]
public void set_Verifications(IList`1<Verification> value);
    public string get_PackagePath();
    public void set_PackagePath(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackagePaths();
    [CompilerGeneratedAttribute]
public void set_PackagePaths(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CertificateFingerprint();
    [CompilerGeneratedAttribute]
public void set_CertificateFingerprint(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(ISettings value);
}
internal class NuGet.Commands.VerifyCommandRunner : object {
    private static int SuccessCode;
    private static int FailureCode;
    private static HashAlgorithmName _defaultFingerprintAlgorithm;
    [AsyncStateMachineAttribute("NuGet.Commands.VerifyCommandRunner/<ExecuteCommandAsync>d__3")]
public sealed virtual Task`1<int> ExecuteCommandAsync(VerifyArgs verifyArgs);
    [AsyncStateMachineAttribute("NuGet.Commands.VerifyCommandRunner/<VerifySignatureForPackageAsync>d__4")]
private Task`1<int> VerifySignatureForPackageAsync(string packagePath, ILogger logger, PackageSignatureVerifier verifier, SignedPackageVerifierSettings verifierSettings);
    private bool ShouldExecuteVerification(VerifyArgs args, Verification v);
    private bool IsSignatureVerifyCommandSupported();
}
internal class NuGet.Commands.VirtualFileInfo : object {
    private string _path;
    private bool _isDirectory;
    private string _name;
    public bool Exists { get; }
    public bool IsDirectory { get; }
    public DateTimeOffset LastModified { get; }
    public long Length { get; }
    public string Name { get; }
    public string PhysicalPath { get; }
    public VirtualFileInfo(string path);
    public VirtualFileInfo(string path, bool isDirectory);
    public sealed virtual bool get_Exists();
    public sealed virtual bool get_IsDirectory();
    public sealed virtual DateTimeOffset get_LastModified();
    public sealed virtual long get_Length();
    public sealed virtual string get_Name();
    public sealed virtual string get_PhysicalPath();
    public sealed virtual Stream CreateReadStream();
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
internal class NuGet.Commands.VulnerabilityInformationProvider : object {
    private SourceRepository _source;
    private ILogger _logger;
    [NuGet.Commands.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLazy`1<GetVulnerabilityInfoResult> _vulnerabilityInfo;
    public VulnerabilityInformationProvider(SourceRepository source, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.VulnerabilityInformationProvider/<GetVulnerabilityInformationAsync>d__4")]
public sealed virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInformationAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.VulnerabilityInformationProvider/<GetVulnerabilityInfoAsync>d__5")]
private Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync();
}
internal class NuGet.Commands.WarningPropertiesCollection : object {
    private ConcurrentDictionary`2<string, NuGetFramework> _getFrameworkCache;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetFramework> <ProjectFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningProperties <ProjectWideWarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpecificWarningProperties <PackageSpecificWarningProperties>k__BackingField;
    public IReadOnlyList`1<NuGetFramework> ProjectFrameworks { get; }
    public WarningProperties ProjectWideWarningProperties { get; }
    public PackageSpecificWarningProperties PackageSpecificWarningProperties { get; }
    public WarningPropertiesCollection(WarningProperties projectWideWarningProperties, PackageSpecificWarningProperties packageSpecificWarningProperties, IReadOnlyList`1<NuGetFramework> projectFrameworks);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetFramework> get_ProjectFrameworks();
    [CompilerGeneratedAttribute]
public WarningProperties get_ProjectWideWarningProperties();
    [CompilerGeneratedAttribute]
public PackageSpecificWarningProperties get_PackageSpecificWarningProperties();
    public bool ApplyWarningProperties(IRestoreLogMessage message);
    public bool ApplyNoWarnProperties(IRestoreLogMessage message);
    public void ApplyWarningAsErrorProperties(IRestoreLogMessage message);
    private bool ApplyPackageSpecificNoWarnProperties(IRestoreLogMessage message);
    public static bool ApplyProjectWideNoWarnProperties(ILogMessage message, WarningProperties warningProperties);
    public static void ApplyProjectWideWarningsAsErrorProperties(ILogMessage message, WarningProperties warningProperties);
    private NuGetFramework GetNuGetFramework(string targetGraph);
    private static NuGetFramework GetNuGetFrameworkFromTargetGraph(string targetGraph);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WarningPropertiesCollection other);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.ActivityCorrelationId : object {
    private static string CorrelationIdSlot;
    private static string DefaultCorrelationId;
    public static string Current { get; }
    private static ActivityCorrelationId();
    public static string get_Current();
    public static void StartNew();
    public static void Clear();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.AggregateEnumerableAsync`1 : object {
    private IList`1<IEnumerableAsync`1<T>> _asyncEnumerables;
    [NuGet.Common.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> _comparer;
    [NuGet.Common.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<T> _equalityComparer;
    public AggregateEnumerableAsync`1(IList`1<IEnumerableAsync`1<T>> asyncEnumerables, IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.AggregateEnumeratorAsync`1 : object {
    private HashSet`1<T> _seen;
    private IComparer`1<T> _orderingComparer;
    private List`1<IEnumeratorAsync`1<T>> _asyncEnumerators;
    [NuGet.Common.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumeratorAsync`1<T> _currentEnumeratorAsync;
    [NuGet.Common.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumeratorAsync`1<T> _lastAwaitedEnumeratorAsync;
    private bool firstPass;
    public T Current { get; }
    public AggregateEnumeratorAsync`1(IList`1<IEnumerableAsync`1<T>> asyncEnumerables, IComparer`1<T> orderingComparer, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual T get_Current();
    [AsyncStateMachineAttribute("NuGet.Common.AggregateEnumeratorAsync`1/<MoveNextAsync>d__9")]
public sealed virtual Task`1<bool> MoveNextAsync();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.AsyncLazy : object {
    public static AsyncLazy`1<T> New(Func`1<Task`1<T>> asyncValueFactory);
    public static AsyncLazy`1<T> New(Func`1<T> valueFactory);
    public static AsyncLazy`1<T> New(Lazy`1<Task`1<T>> inner);
    public static AsyncLazy`1<T> New(T innerData);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[CLSCompliantAttribute("True")]
internal class NuGet.Common.AsyncLazy`1 : object {
    private Lazy`1<Task`1<T>> _inner;
    public AsyncLazy`1(Func`1<Task`1<T>> valueFactory);
    public AsyncLazy`1(Lazy`1<Task`1<T>> inner);
    public TaskAwaiter`1<T> GetAwaiter();
    public static Lazy`1<Task`1<T>> op_Implicit(AsyncLazy`1<T> outer);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.AuthTypeFilteredCredentials : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AuthTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <InnerCredential>k__BackingField;
    public IReadOnlyList`1<string> AuthTypes { get; }
    public NetworkCredential InnerCredential { get; }
    public AuthTypeFilteredCredentials(NetworkCredential innerCredential, IEnumerable`1<string> authTypes);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AuthTypes();
    [CompilerGeneratedAttribute]
public NetworkCredential get_InnerCredential();
    public sealed virtual NetworkCredential GetCredential(Uri uri, string authType);
}
internal static class NuGet.Common.ClientVersionUtility : object {
    [NuGet.Common.NullableAttribute("2")]
private static string _clientVersion;
    [NuGet.Common.NullableContextAttribute("1")]
public static string GetNuGetAssemblyVersion();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.CommandLineArgumentCombinationException : Exception {
    private ILogMessage _logMessage;
    public CommandLineArgumentCombinationException(string message);
    public virtual ILogMessage AsLogMessage();
}
internal static class NuGet.Common.ComparisonUtility : object {
    [NuGet.Common.NullableAttribute("1")]
public static StringComparer FrameworkReferenceNameComparer;
    private static ComparisonUtility();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.ConcurrencyUtilities : object {
    private static int NumberOfRetries;
    private static int HashLength;
    private static TimeSpan SleepDuration;
    private static KeyedLock PerFileLock;
    private static bool UseDeleteOnClose;
    [NuGet.Common.NullableAttribute("2")]
private static string _basePath;
    private static string BasePath { get; }
    private static ConcurrencyUtilities();
    [AsyncStateMachineAttribute("NuGet.Common.ConcurrencyUtilities/<ExecuteWithFileLockedAsync>d__5`1")]
public static Task`1<T> ExecuteWithFileLockedAsync(string filePath, Func`2<CancellationToken, Task`1<T>> action, CancellationToken token);
    public static void ExecuteWithFileLocked(string filePath, Action action);
    internal static void ExecuteWithFileLocked(string filePath, Action action, Func`2<string, FileStream> acquireFileStream, int numberOfRetries);
    private static FileStream AcquireFileStream(string lockPath);
    private static string get_BasePath();
    private static string FileLockPath(string filePath);
    private static string FilePathToLockName(string filePath);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.CryptoHashProvider : object {
    private static string SHA512HashAlgorithm;
    private static string SHA256HashAlgorithm;
    private string _hashAlgorithm;
    [NuGet.Common.NullableContextAttribute("2")]
public CryptoHashProvider(string hashAlgorithm);
    public Byte[] CalculateHash(Stream stream);
    public Byte[] CalculateHash(Byte[] data);
    public bool VerifyHash(Byte[] data, Byte[] hash);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Common.CryptoHashUtility : object {
    private static string SHA256_OID;
    private static string SHA384_OID;
    private static string SHA512_OID;
    private static string SHA256_RSA_OID;
    private static string SHA384_RSA_OID;
    private static string SHA512_RSA_OID;
    private static Lazy`1<bool> AllowFipsAlgorithmsOnly;
    private static CryptoHashUtility();
    [ExtensionAttribute]
public static string ComputeHashAsBase64(HashAlgorithm hashAlgorithm, Stream data);
    [ExtensionAttribute]
public static string ComputeHashAsBase64(HashAlgorithm hashAlgorithm, Stream data, bool leaveStreamOpen);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithmName hashAlgorithmName, Byte[] data);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithm hashAlgorithm, Stream data);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithm hashAlgorithm, Stream data, bool leaveStreamOpen);
    public static HashAlgorithm GetHashAlgorithm(string hashAlgorithmName);
    public static HashAlgorithmName GetHashAlgorithmName(string hashAlgorithm);
    public static HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static HashAlgorithm GetHashProvider(HashAlgorithmName hashAlgorithmName);
    private static bool ReadFipsConfigValue();
    [ExtensionAttribute]
public static HashAlgorithmName ConvertToSystemSecurityHashAlgorithmName(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static string ConvertToOidString(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static Oid ConvertToOid(HashAlgorithmName hashAlgorithm);
    public static HashAlgorithmName OidToHashAlgorithmName(string oid);
    [ExtensionAttribute]
public static string ConvertToOidString(SignatureAlgorithmName signatureAlgorithmName);
}
internal static class NuGet.Common.CultureUtility : object {
    public static void DisableLocalization();
    [NuGet.Common.NullableContextAttribute("1")]
private static void SetCulture(CultureInfo culture);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.DatetimeUtility : object {
    public static string ToReadableTimeFormat(TimeSpan time);
    internal static string ToReadableTimeFormat(TimeSpan time, IFormatProvider format);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.EnvironmentVariableWrapper : object {
    [CompilerGeneratedAttribute]
private static IEnvironmentVariableReader <Instance>k__BackingField;
    public static IEnvironmentVariableReader Instance { get; }
    private static EnvironmentVariableWrapper();
    [CompilerGeneratedAttribute]
public static IEnvironmentVariableReader get_Instance();
    public sealed virtual string GetEnvironmentVariable(string variable);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.ExceptionLogger : object {
    [CompilerGeneratedAttribute]
private bool <ShowStack>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExceptionLogger <Instance>k__BackingField;
    public bool ShowStack { get; }
    public static ExceptionLogger Instance { get; }
    public ExceptionLogger(IEnvironmentVariableReader reader);
    private static ExceptionLogger();
    [CompilerGeneratedAttribute]
public bool get_ShowStack();
    private static bool ShouldShowStack(IEnvironmentVariableReader reader);
    [CompilerGeneratedAttribute]
public static ExceptionLogger get_Instance();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.ExceptionUtilities : object {
    public static void LogException(Exception ex, ILogger logger);
    public static void LogException(Exception ex, ILogger logger, bool logStackAsError);
    public static string DisplayMessage(Exception exception, bool indent);
    public static string DisplayMessage(Exception exception);
    public static string DisplayMessage(AggregateException exception);
    public static string DisplayMessage(TargetInvocationException exception);
    public static Exception Unwrap(Exception exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetMessages>d__7")]
private static IEnumerable`1<string> GetMessages(AggregateException exception);
    private static IEnumerable`1<string> GetMessages(TargetInvocationException exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetMessages>d__9")]
private static IEnumerable`1<string> GetMessages(Exception exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetLines>d__10")]
private static IEnumerable`1<string> GetLines(string input);
    private static string JoinMessages(IEnumerable`1<string> messages, bool indent);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.FileUtility : object {
    public static int MaxTries;
    public static FileShare FileSharePermissions;
    private static FileUtility();
    public static string GetTempFilePath(string directory);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<DeleteWithLock>d__3")]
public static Task DeleteWithLock(string filePath);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<ReplaceWithLock>d__4")]
public static Task ReplaceWithLock(Action`1<string> writeSourceFile, string destFilePath);
    public static void Replace(Action`1<string> writeSourceFile, string destFilePath);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<ReplaceAsync>d__6")]
public static Task ReplaceAsync(Func`2<string, Task> writeSourceFile, string destFilePath);
    public static void Replace(string sourceFileName, string destFileName);
    public static void Move(string sourceFileName, string destFileName);
    public static void Delete(string path);
    public static T SafeRead(string filePath, Func`3<FileStream, string, T> read);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<SafeReadAsync>d__11`1")]
public static Task`1<T> SafeReadAsync(string filePath, Func`3<FileStream, string, Task`1<T>> read);
    private static void Sleep(int ms);
}
internal enum NuGet.Common.HashAlgorithmName : Enum {
    public int value__;
    public static HashAlgorithmName Unknown;
    public static HashAlgorithmName SHA256;
    public static HashAlgorithmName SHA384;
    public static HashAlgorithmName SHA512;
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.ICollectorLogger {
    public IEnumerable`1<IRestoreLogMessage> Errors { get; }
    public abstract virtual IEnumerable`1<IRestoreLogMessage> get_Errors();
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.IEnumerableAsync`1 {
    public abstract virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.IEnumeratorAsync`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
    public abstract virtual Task`1<bool> MoveNextAsync();
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.IEnvironmentVariableReader {
    public abstract virtual string GetEnvironmentVariable(string variable);
}
[NuGet.Common.NullableContextAttribute("2")]
internal interface NuGet.Common.ILogFileContext {
    public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public abstract virtual string get_FilePath();
    public abstract virtual void set_FilePath(string value);
    public abstract virtual int get_StartLineNumber();
    public abstract virtual void set_StartLineNumber(int value);
    public abstract virtual int get_StartColumnNumber();
    public abstract virtual void set_StartColumnNumber(int value);
    public abstract virtual int get_EndLineNumber();
    public abstract virtual void set_EndLineNumber(int value);
    public abstract virtual int get_EndColumnNumber();
    public abstract virtual void set_EndColumnNumber(int value);
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.ILogger {
    public abstract virtual void LogDebug(string data);
    public abstract virtual void LogVerbose(string data);
    public abstract virtual void LogInformation(string data);
    public abstract virtual void LogMinimal(string data);
    public abstract virtual void LogWarning(string data);
    public abstract virtual void LogError(string data);
    public abstract virtual void LogInformationSummary(string data);
    public abstract virtual void Log(LogLevel level, string data);
    public abstract virtual Task LogAsync(LogLevel level, string data);
    public abstract virtual void Log(ILogMessage message);
    public abstract virtual Task LogAsync(ILogMessage message);
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.ILogMessage {
    public LogLevel Level { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    [NuGet.Common.NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public abstract virtual LogLevel get_Level();
    public abstract virtual void set_Level(LogLevel value);
    public abstract virtual WarningLevel get_WarningLevel();
    public abstract virtual void set_WarningLevel(WarningLevel value);
    public abstract virtual NuGetLogCode get_Code();
    public abstract virtual void set_Code(NuGetLogCode value);
    public abstract virtual string get_Message();
    public abstract virtual void set_Message(string value);
    [NuGet.Common.NullableContextAttribute("2")]
public abstract virtual string get_ProjectPath();
    [NuGet.Common.NullableContextAttribute("2")]
public abstract virtual void set_ProjectPath(string value);
    public abstract virtual DateTimeOffset get_Time();
    public abstract virtual void set_Time(DateTimeOffset value);
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.ILogMessageException {
    public abstract virtual ILogMessage AsLogMessage();
}
internal interface NuGet.Common.INuGetLogMessage {
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.INuGetPathContext {
    public string UserPackageFolder { get; }
    public IReadOnlyList`1<string> FallbackPackageFolders { get; }
    public string HttpCacheFolder { get; }
    public abstract virtual string get_UserPackageFolder();
    public abstract virtual IReadOnlyList`1<string> get_FallbackPackageFolders();
    public abstract virtual string get_HttpCacheFolder();
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.INuGetTelemetryService {
    public abstract virtual void EmitTelemetryEvent(TelemetryEvent telemetryData);
    public abstract virtual IDisposable StartActivity(string activityName);
}
[NuGet.Common.NullableContextAttribute("2")]
internal interface NuGet.Common.IPackLogMessage {
    public string LibraryId { get; public set; }
    public NuGetFramework Framework { get; public set; }
    public abstract virtual string get_LibraryId();
    public abstract virtual void set_LibraryId(string value);
    public abstract virtual NuGetFramework get_Framework();
    public abstract virtual void set_Framework(NuGetFramework value);
}
internal interface NuGet.Common.IRestoreLogMessage {
    [NuGet.Common.NullableAttribute("2")]
public string LibraryId { get; public set; }
    [NuGet.Common.NullableAttribute("1")]
public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public bool ShouldDisplay { get; public set; }
    [NuGet.Common.NullableContextAttribute("2")]
public abstract virtual string get_LibraryId();
    [NuGet.Common.NullableContextAttribute("2")]
public abstract virtual void set_LibraryId(string value);
    [NuGet.Common.NullableContextAttribute("1")]
public abstract virtual IReadOnlyList`1<string> get_TargetGraphs();
    [NuGet.Common.NullableContextAttribute("1")]
public abstract virtual void set_TargetGraphs(IReadOnlyList`1<string> value);
    public abstract virtual bool get_ShouldDisplay();
    public abstract virtual void set_ShouldDisplay(bool value);
}
[NuGet.Common.NullableContextAttribute("1")]
internal interface NuGet.Common.ITelemetrySession {
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.KeyedLock : object {
    private Dictionary`2<string, LockState> _locks;
    private SemaphoreSlim _dictionaryLock;
    [AsyncStateMachineAttribute("NuGet.Common.KeyedLock/<EnterAsync>d__3")]
internal Task EnterAsync(string key, CancellationToken token);
    internal void Enter(string key);
    private LockState GetOrCreate(string key);
    [AsyncStateMachineAttribute("NuGet.Common.KeyedLock/<ExitAsync>d__6")]
internal Task ExitAsync(string key);
    internal void Exit(string key);
    private void Cleanup(string key);
    public sealed virtual void Dispose();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal abstract class NuGet.Common.LegacyLoggerAdapter : object {
    public sealed virtual void Log(LogLevel level, string data);
    public sealed virtual Task LogAsync(LogLevel level, string data);
    public virtual void Log(ILogMessage message);
    [AsyncStateMachineAttribute("NuGet.Common.LegacyLoggerAdapter/<LogAsync>d__3")]
public virtual Task LogAsync(ILogMessage message);
    public abstract virtual void LogDebug(string data);
    public abstract virtual void LogVerbose(string data);
    public abstract virtual void LogInformation(string data);
    public abstract virtual void LogMinimal(string data);
    public abstract virtual void LogWarning(string data);
    public abstract virtual void LogError(string data);
    public abstract virtual void LogInformationSummary(string data);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.LocalResourceUtils : object {
    public static void DeleteDirectoryTree(string folderPath, List`1<string> failedDeletes);
    private static void SafeDeleteDirectoryTree(string folderPath);
    private static void DeleteFilesInDirectoryTree(string folderPath, List`1<string> failedDeletes);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal abstract class NuGet.Common.LoggerBase : object {
    [CompilerGeneratedAttribute]
private LogLevel <VerbosityLevel>k__BackingField;
    public LogLevel VerbosityLevel { get; public set; }
    public LoggerBase(LogLevel verbosityLevel);
    [CompilerGeneratedAttribute]
public LogLevel get_VerbosityLevel();
    [CompilerGeneratedAttribute]
public void set_VerbosityLevel(LogLevel value);
    public abstract virtual void Log(ILogMessage message);
    public abstract virtual Task LogAsync(ILogMessage message);
    public virtual void Log(LogLevel level, string data);
    public virtual Task LogAsync(LogLevel level, string data);
    public virtual void LogDebug(string data);
    public virtual void LogError(string data);
    public virtual void LogInformation(string data);
    public virtual void LogInformationSummary(string data);
    public virtual void LogMinimal(string data);
    public virtual void LogVerbose(string data);
    public virtual void LogWarning(string data);
    protected virtual bool DisplayMessage(LogLevel messageLevel);
    protected virtual bool CollectMessage(LogLevel messageLevel);
}
[NuGet.Common.NullableContextAttribute("2")]
[NuGet.Common.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Common.LoggingExtensions : object {
    [NuGet.Common.NullableContextAttribute("1")]
[ExtensionAttribute]
public static string FormatWithCode(ILogMessage message);
    [ExtensionAttribute]
public static string GetName(NuGetLogCode code);
    [ExtensionAttribute]
public static bool TryGetName(NuGetLogCode code, String& codeString);
}
internal enum NuGet.Common.LogLevel : Enum {
    public int value__;
    public static LogLevel Debug;
    public static LogLevel Verbose;
    public static LogLevel Information;
    public static LogLevel Minimal;
    public static LogLevel Warning;
    public static LogLevel Error;
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.LogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NuGet.Common.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    public LogLevel Level { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    [NuGet.Common.NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public LogMessage(LogLevel level, string message, NuGetLogCode code);
    public LogMessage(LogLevel level, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    public virtual string ToString();
    public static LogMessage CreateError(NuGetLogCode code, string message);
    public static LogMessage CreateWarning(NuGetLogCode code, string message);
    public static LogMessage Create(LogLevel level, string message);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.LogMessageProperties : object {
    public static string LEVEL;
    public static string CODE;
    public static string MESSAGE;
    public static string LIBRARY_ID;
    public static string TARGET_GRAPHS;
    public static string WARNING_LEVEL;
    public static string FILE_PATH;
    public static string START_LINE_NUMBER;
    public static string START_COLUMN_NUMBER;
    public static string END_LINE_NUMBER;
    public static string END_COLUMN_NUMBER;
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.Migrations.Migration1 : object {
    public static void Run();
    internal static void DeleteMigratedDirectories(string nugetBaseDirectory);
    internal static void EnsureExpectedPermissions(HashSet`1<string> pathsToCheck, PosixPermissions umask);
    private static HashSet`1<string> GetPathsToCheck();
    private static string GetMonoConfigPath();
    private static string GetDotnetConfigPath();
    private static void EnsureConfigFilePermissions();
    internal static void EnsureConfigFilePermissions(string directory, PosixPermissions umask);
    private static PosixPermissions GetUmask();
    private static void FixPermissions(string path, PosixPermissions umask);
    internal static Nullable`1<PosixPermissions> GetPermissions(string path);
    internal static string Exec(string command, string args);
    [CompilerGeneratedAttribute]
internal static void <GetPathsToCheck>g__AddAllParentDirectoriesUpToHome|3_0(string path, <>c__DisplayClass3_0& );
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.Migrations.MigrationRunner : object {
    private static string MaxMigrationFilename;
    public static void Run();
    internal static void Run(string migrationsDirectory);
    internal static string GetMigrationsDirectory();
    [CompilerGeneratedAttribute]
internal static bool <Run>g__WaitForMutex|2_0(Mutex mutex);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.Migrations.PosixPermissions : ValueType {
    private int _mode;
    public PosixPermissions(int mode);
    public virtual string ToString();
    public static PosixPermissions Parse(string input);
    public bool SatisfiesUmask(PosixPermissions umask);
    public PosixPermissions WithUmask(PosixPermissions umask);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.MSBuildStringUtility : object {
    public static String[] Split(string s);
    public static String[] Split(string s, Char[] chars);
    [NuGet.Common.NullableContextAttribute("2")]
public static string TrimAndGetNullForEmpty(string s);
    public static String[] TrimAndExcludeNullOrEmpty(String[] strings);
    [NuGet.Common.NullableContextAttribute("2")]
public static bool IsTrue(string value);
    [NuGet.Common.NullableContextAttribute("2")]
public static bool IsTrueOrEmpty(string value);
    public static IList`1<NuGetLogCode> GetNuGetLogCodes(string s);
    [NuGet.Common.NullableContextAttribute("2")]
public static Nullable`1<bool> GetBooleanOrNull(string value);
    [NuGet.Common.NullableContextAttribute("2")]
public static string Convert(string value);
    public static IEnumerable`1<NuGetLogCode> GetDistinctNuGetLogCodesOrDefault(IEnumerable`1<IEnumerable`1<NuGetLogCode>> nugetLogCodeLists);
}
internal static class NuGet.Common.NetworkProtocolUtility : object {
    public static void SetConnectionLimit();
}
internal static class NuGet.Common.NuGetEnvironment : object {
    private static string DotNet;
    private static string DotNetExe;
    private static string Home;
    private static string UserProfile;
    private static Lazy`1<string> _getHome;
    private static string _nuGetTempDirectory;
    internal static string NuGetTempDirectory { get; }
    private static NuGetEnvironment();
    internal static string get_NuGetTempDirectory();
    private static string GetNuGetTempDirectory();
    public static string GetFolderPath(NuGetFolderPath folder);
    private static int chmod(string pathname, int mode);
    internal static string GetFolderPath(SpecialFolder folder);
    private static string GetHome();
    private static string GetHomeWindows();
    private static string GetValueOrThrowMissingEnvVarsDotnet(Func`1<string> getValue, string home, string dotnetHome);
    private static string GetValueOrThrowMissingEnvVar(Func`1<string> getValue, string name);
    public static string GetDotNetLocation();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.NuGetEventSource : object {
    [CompilerGeneratedAttribute]
private static EventSource <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsEnabled>k__BackingField;
    public static EventSource Instance { get; }
    public static bool IsEnabled { get; }
    private static NuGetEventSource();
    [CompilerGeneratedAttribute]
public static EventSource get_Instance();
    [CompilerGeneratedAttribute]
public static bool get_IsEnabled();
}
internal enum NuGet.Common.NuGetFolderPath : Enum {
    public int value__;
    public static NuGetFolderPath MachineWideSettingsBaseDirectory;
    public static NuGetFolderPath MachineWideConfigDirectory;
    public static NuGetFolderPath UserSettingsDirectory;
    public static NuGetFolderPath HttpCacheDirectory;
    public static NuGetFolderPath NuGetHome;
    public static NuGetFolderPath DefaultMsBuildPath;
    public static NuGetFolderPath Temp;
    public static NuGetFolderPath NuGetPluginsCacheDirectory;
}
internal enum NuGet.Common.NuGetLogCode : Enum {
    public int value__;
    public static NuGetLogCode Undefined;
    public static NuGetLogCode NU1000;
    public static NuGetLogCode NU1001;
    public static NuGetLogCode NU1002;
    public static NuGetLogCode NU1003;
    public static NuGetLogCode NU1004;
    public static NuGetLogCode NU1005;
    public static NuGetLogCode NU1006;
    public static NuGetLogCode NU1007;
    public static NuGetLogCode NU1008;
    public static NuGetLogCode NU1009;
    public static NuGetLogCode NU1010;
    public static NuGetLogCode NU1011;
    public static NuGetLogCode NU1012;
    public static NuGetLogCode NU1013;
    public static NuGetLogCode NU1014;
    public static NuGetLogCode NU1100;
    public static NuGetLogCode NU1101;
    public static NuGetLogCode NU1102;
    public static NuGetLogCode NU1103;
    public static NuGetLogCode NU1104;
    public static NuGetLogCode NU1105;
    public static NuGetLogCode NU1106;
    public static NuGetLogCode NU1107;
    public static NuGetLogCode NU1108;
    public static NuGetLogCode NU1109;
    public static NuGetLogCode NU1110;
    public static NuGetLogCode NU1201;
    public static NuGetLogCode NU1202;
    public static NuGetLogCode NU1203;
    public static NuGetLogCode NU1204;
    public static NuGetLogCode NU1211;
    public static NuGetLogCode NU1212;
    public static NuGetLogCode NU1213;
    public static NuGetLogCode NU1301;
    public static NuGetLogCode NU1401;
    public static NuGetLogCode NU1402;
    public static NuGetLogCode NU1403;
    public static NuGetLogCode NU1410;
    public static NuGetLogCode NU1500;
    public static NuGetLogCode NU1501;
    public static NuGetLogCode NU1502;
    public static NuGetLogCode NU1503;
    public static NuGetLogCode NU1504;
    public static NuGetLogCode NU1505;
    public static NuGetLogCode NU1506;
    public static NuGetLogCode NU1507;
    public static NuGetLogCode NU1601;
    public static NuGetLogCode NU1602;
    public static NuGetLogCode NU1603;
    public static NuGetLogCode NU1604;
    public static NuGetLogCode NU1605;
    public static NuGetLogCode NU1608;
    public static NuGetLogCode NU1701;
    public static NuGetLogCode NU1702;
    public static NuGetLogCode NU1703;
    public static NuGetLogCode NU1801;
    public static NuGetLogCode NU1802;
    public static NuGetLogCode NU1803;
    public static NuGetLogCode NU1900;
    public static NuGetLogCode NU1901;
    public static NuGetLogCode NU1902;
    public static NuGetLogCode NU1903;
    public static NuGetLogCode NU1904;
    public static NuGetLogCode NU3000;
    public static NuGetLogCode NU3001;
    public static NuGetLogCode NU3002;
    public static NuGetLogCode NU3003;
    public static NuGetLogCode NU3004;
    public static NuGetLogCode NU3005;
    public static NuGetLogCode NU3006;
    public static NuGetLogCode NU3007;
    public static NuGetLogCode NU3008;
    public static NuGetLogCode NU3009;
    public static NuGetLogCode NU3010;
    public static NuGetLogCode NU3011;
    public static NuGetLogCode NU3012;
    public static NuGetLogCode NU3013;
    public static NuGetLogCode NU3014;
    public static NuGetLogCode NU3015;
    public static NuGetLogCode NU3016;
    public static NuGetLogCode NU3017;
    public static NuGetLogCode NU3018;
    public static NuGetLogCode NU3019;
    public static NuGetLogCode NU3020;
    public static NuGetLogCode NU3021;
    public static NuGetLogCode NU3022;
    public static NuGetLogCode NU3023;
    public static NuGetLogCode NU3024;
    public static NuGetLogCode NU3025;
    public static NuGetLogCode NU3026;
    public static NuGetLogCode NU3027;
    public static NuGetLogCode NU3028;
    public static NuGetLogCode NU3029;
    public static NuGetLogCode NU3030;
    public static NuGetLogCode NU3031;
    public static NuGetLogCode NU3032;
    public static NuGetLogCode NU3033;
    public static NuGetLogCode NU3034;
    public static NuGetLogCode NU3035;
    public static NuGetLogCode NU3036;
    public static NuGetLogCode NU3037;
    public static NuGetLogCode NU3038;
    public static NuGetLogCode NU3039;
    public static NuGetLogCode NU3040;
    public static NuGetLogCode NU3041;
    public static NuGetLogCode NU3042;
    public static NuGetLogCode NU5000;
    public static NuGetLogCode NU5001;
    public static NuGetLogCode NU5002;
    public static NuGetLogCode NU5003;
    public static NuGetLogCode NU5004;
    public static NuGetLogCode NU5005;
    public static NuGetLogCode NU5007;
    public static NuGetLogCode NU5008;
    public static NuGetLogCode NU5009;
    public static NuGetLogCode NU5010;
    public static NuGetLogCode NU5011;
    public static NuGetLogCode NU5012;
    public static NuGetLogCode NU5013;
    public static NuGetLogCode NU5014;
    public static NuGetLogCode NU5015;
    public static NuGetLogCode NU5016;
    public static NuGetLogCode NU5017;
    public static NuGetLogCode NU5018;
    public static NuGetLogCode NU5019;
    public static NuGetLogCode NU5020;
    public static NuGetLogCode NU5021;
    public static NuGetLogCode NU5022;
    public static NuGetLogCode NU5023;
    public static NuGetLogCode NU5024;
    public static NuGetLogCode NU5025;
    public static NuGetLogCode NU5026;
    public static NuGetLogCode NU5027;
    public static NuGetLogCode NU5028;
    public static NuGetLogCode NU5029;
    public static NuGetLogCode NU5030;
    public static NuGetLogCode NU5031;
    public static NuGetLogCode NU5032;
    public static NuGetLogCode NU5033;
    public static NuGetLogCode NU5034;
    public static NuGetLogCode NU5035;
    public static NuGetLogCode NU5036;
    public static NuGetLogCode NU5037;
    public static NuGetLogCode NU5038;
    public static NuGetLogCode NU5039;
    public static NuGetLogCode NU5040;
    public static NuGetLogCode NU5041;
    public static NuGetLogCode NU5042;
    public static NuGetLogCode NU5045;
    public static NuGetLogCode NU5046;
    public static NuGetLogCode NU5047;
    public static NuGetLogCode NU5048;
    public static NuGetLogCode NU5049;
    public static NuGetLogCode NU5050;
    public static NuGetLogCode NU5100;
    public static NuGetLogCode NU5101;
    public static NuGetLogCode NU5102;
    public static NuGetLogCode NU5103;
    public static NuGetLogCode NU5104;
    public static NuGetLogCode NU5105;
    public static NuGetLogCode NU5106;
    public static NuGetLogCode NU5107;
    public static NuGetLogCode NU5108;
    public static NuGetLogCode NU5109;
    public static NuGetLogCode NU5110;
    public static NuGetLogCode NU5111;
    public static NuGetLogCode NU5112;
    public static NuGetLogCode NU5114;
    public static NuGetLogCode NU5115;
    public static NuGetLogCode NU5116;
    public static NuGetLogCode NU5117;
    public static NuGetLogCode NU5118;
    public static NuGetLogCode NU5119;
    public static NuGetLogCode NU5120;
    public static NuGetLogCode NU5121;
    public static NuGetLogCode NU5122;
    public static NuGetLogCode NU5123;
    public static NuGetLogCode NU5124;
    public static NuGetLogCode NU5125;
    public static NuGetLogCode NU5126;
    public static NuGetLogCode NU5127;
    public static NuGetLogCode NU5128;
    public static NuGetLogCode NU5129;
    public static NuGetLogCode NU5130;
    public static NuGetLogCode NU5131;
    public static NuGetLogCode NU5132;
    public static NuGetLogCode NU5133;
    public static NuGetLogCode NU5500;
    public static NuGetLogCode NU5501;
}
internal enum NuGet.Common.NuGetOperationStatus : Enum {
    public int value__;
    public static NuGetOperationStatus NoOp;
    public static NuGetOperationStatus Succeeded;
    public static NuGetOperationStatus Failed;
    public static NuGetOperationStatus Cancelled;
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.NullLogger : LoggerBase {
    [NuGet.Common.NullableAttribute("2")]
private static ILogger _instance;
    public static ILogger Instance { get; }
    public static ILogger get_Instance();
    public virtual void Log(ILogMessage message);
    public virtual void Log(LogLevel level, string data);
    public virtual Task LogAsync(ILogMessage message);
    public virtual Task LogAsync(LogLevel level, string data);
}
[NuGet.Common.NullableContextAttribute("2")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.PackagingLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [NuGet.Common.NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    public LogLevel Level { get; public set; }
    public NuGetLogCode Code { get; public set; }
    [NuGet.Common.NullableAttribute("1")]
public string Message { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public string LibraryId { get; public set; }
    public NuGetFramework Framework { get; public set; }
    [NuGet.Common.NullableContextAttribute("1")]
private PackagingLogMessage(LogLevel logLevel, NuGetLogCode logCode, string message);
    private PackagingLogMessage(LogLevel logLevel, NuGetLogCode logCode, string message, string libraryId, NuGetFramework framework);
    [NuGet.Common.NullableContextAttribute("1")]
private PackagingLogMessage(LogLevel logLevel, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [NuGet.Common.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [NuGet.Common.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Framework(NuGetFramework value);
    [NuGet.Common.NullableContextAttribute("1")]
public static PackagingLogMessage CreateError(string message, NuGetLogCode code);
    [NuGet.Common.NullableContextAttribute("1")]
public static PackagingLogMessage CreateWarning(string message, NuGetLogCode code);
    [NuGet.Common.NullableContextAttribute("1")]
public static PackagingLogMessage CreateMessage(string message, LogLevel logLevel);
    [NuGet.Common.NullableContextAttribute("1")]
public static PackagingLogMessage CreateWarning(string message, NuGetLogCode code, string libraryId, NuGetFramework framework);
    private static NuGetLogCode GetDefaultLogCode(LogLevel logLevel);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.PathResolver : object {
    public static IEnumerable`1<T> GetMatches(IEnumerable`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static void FilterPackageFiles(ICollection`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static IEnumerable`1<T> GetFilteredPackageFiles(ICollection`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static string NormalizeWildcardForExcludedFiles(string basePath, string wildcard);
    private static Regex WildcardToRegex(string wildcard);
    public static IEnumerable`1<string> PerformWildcardSearch(string basePath, string searchPath);
    public static IEnumerable`1<SearchPathResult> PerformWildcardSearch(string basePath, string searchPath, bool includeEmptyDirectories, String& normalizedBasePath);
    internal static string GetPathToEnumerateFrom(string basePath, string searchPath);
    internal static string NormalizeBasePath(string basePath, String& searchPath);
    public static bool IsWildcardSearch(string filter);
    [NuGet.Common.NullableContextAttribute("2")]
public static bool IsDirectoryPath(string path);
    private static bool IsEmptyDirectory(string directory);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.PathUtility : object {
    private static Lazy`1<bool> _isFileSystemCaseInsensitive;
    public static bool IsFileSystemCaseInsensitive { get; }
    private static PathUtility();
    public static StringComparer GetStringComparerBasedOnOS();
    public static StringComparison GetStringComparisonBasedOnOS();
    [IteratorStateMachineAttribute("NuGet.Common.PathUtility/<GetUniquePathsBasedOnOS>d__3")]
public static IEnumerable`1<string> GetUniquePathsBasedOnOS(IEnumerable`1<string> paths);
    public static string GetPathWithForwardSlashes(string path);
    public static string EnsureTrailingSlash(string path);
    public static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
    public static bool IsChildOfDirectory(string dir, string candidate);
    [NuGet.Common.NullableContextAttribute("2")]
public static bool HasTrailingDirectorySeparator(string path);
    public static bool IsDirectorySeparatorChar(char ch);
    public static void EnsureParentDirectory(string filePath);
    public static string GetRelativePath(string path1, string path2);
    public static string GetRelativePath(string path1, string path2, char separator);
    public static string GetAbsolutePath(string basePath, string relativePath);
    public static string GetDirectoryName(string path);
    public static string GetPathWithBackSlashes(string path);
    public static string GetPathWithDirectorySeparator(string path);
    public static string GetPath(Uri uri);
    public static string EscapePSPath(string path);
    public static string SmartTruncate(string path, int maxWidth);
    public static bool IsSubdirectory(string basePath, string path);
    public static string ReplaceAltDirSeparatorWithDirSeparator(string path);
    public static string ReplaceDirSeparatorWithAltDirSeparator(string path);
    public static ZipArchiveEntry GetEntry(ZipArchive archive, string path);
    public static bool get_IsFileSystemCaseInsensitive();
    private static bool CheckIfFileSystemIsCaseInsensitive();
    private static string GetFirstParentDirectoryThatExists(string path);
    private static bool CheckIfFileSystemIsCaseInsensitive(string path);
    public static string StripLeadingDirectorySeparators(string filename);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.PathValidator : object {
    public static bool IsValidSource(string source);
    public static bool IsValidLocalPath(string path);
    public static bool IsValidUncPath(string path);
    public static bool IsValidUrl(string url);
    public static bool IsValidRelativePath(string path);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.Preprocessor : object {
    [AsyncStateMachineAttribute("NuGet.Common.Preprocessor/<ProcessAsync>d__0")]
public static Task`1<string> ProcessAsync(Func`1<Task`1<Stream>> streamTaskFactory, Func`2<string, string> tokenReplacement, CancellationToken cancellationToken);
    public static string Process(Stream stream, Func`2<string, string> tokenReplacement);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.ProjectJsonPathUtilities : object {
    public static string ProjectConfigFileName;
    public static string ProjectConfigFileEnding;
    public static string ProjectLockFileName;
    private static ProjectJsonPathUtilities();
    public static string GetProjectConfigPath(string directoryPath, string projectName);
    public static string GetProjectConfigWithProjectName(string projectName);
    public static string GetProjectLockFileNameWithProjectName(string projectName);
    public static string GetLockFilePath(string configFilePath);
    public static string GetProjectNameFromConfigFileName(string configPath);
    public static bool IsProjectConfig(string configPath);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.RestoreLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [NuGet.Common.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [NuGet.Common.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    [NuGet.Common.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <TargetGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDisplay>k__BackingField;
    public LogLevel Level { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    public DateTimeOffset Time { get; public set; }
    [NuGet.Common.NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    [NuGet.Common.NullableAttribute("2")]
public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    [NuGet.Common.NullableAttribute("2")]
public string LibraryId { get; public set; }
    public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public bool ShouldDisplay { get; public set; }
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph, bool logToInnerLogger);
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph);
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString);
    public RestoreLogMessage(LogLevel logLevel, string errorString);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndColumnNumber(int value);
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_TargetGraphs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetGraphs(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldDisplay(bool value);
    public static RestoreLogMessage CreateWarning(NuGetLogCode code, string message, string libraryId, String[] targetGraphs);
    public static RestoreLogMessage CreateWarning(NuGetLogCode code, string message);
    public static RestoreLogMessage CreateError(NuGetLogCode code, string message);
    public static RestoreLogMessage CreateError(NuGetLogCode code, string message, string libraryId, String[] targetGraphs);
    private static NuGetLogCode GetDefaultLogCode(LogLevel logLevel);
}
internal enum NuGet.Common.RevocationMode : Enum {
    public int value__;
    public static RevocationMode Online;
    public static RevocationMode Offline;
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.RuntimeEnvironmentHelper : object {
    private static String[] VisualStudioProcesses;
    private static Lazy`1<bool> _isMono;
    private static Lazy`1<bool> _isWindows;
    private static Lazy`1<bool> _IsMacOSX;
    private static Lazy`1<bool> _IsLinux;
    private static Lazy`1<bool> _isRunningInVisualStudio;
    public static bool IsWindows { get; }
    public static bool IsMono { get; }
    public static bool IsRunningInVisualStudio { get; }
    public static bool IsMacOSX { get; }
    public static bool IsLinux { get; }
    private static RuntimeEnvironmentHelper();
    private static int uname(IntPtr buf);
    public static bool get_IsWindows();
    private static bool GetIsWindows();
    public static bool get_IsMono();
    public static bool get_IsRunningInVisualStudio();
    private static string GetCurrentProcessFilePath();
    public static bool get_IsMacOSX();
    private static bool GetIsMacOSX();
    public static bool get_IsLinux();
    private static bool GetIsLinux();
}
internal enum NuGet.Common.SignatureAlgorithmName : Enum {
    public int value__;
    public static SignatureAlgorithmName Unknown;
    public static SignatureAlgorithmName SHA256RSA;
    public static SignatureAlgorithmName SHA384RSA;
    public static SignatureAlgorithmName SHA512RSA;
}
internal enum NuGet.Common.SignatureValidationMode : Enum {
    public int value__;
    public static SignatureValidationMode Accept;
    public static SignatureValidationMode Require;
}
[ExtensionAttribute]
internal static class NuGet.Common.StringExtensions : object {
    [NuGet.Common.NullableContextAttribute("2")]
[ExtensionAttribute]
internal static string FormatWithDoubleQuotes(string s);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Common.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Must_Be_GreaterThanOrEqualTo { get; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string MissingRequiredEnvVar { get; }
    internal static string MissingRequiredEnvVarsDotnet { get; }
    internal static string TimeUnits_Hour { get; }
    internal static string TimeUnits_Millisecond { get; }
    internal static string TimeUnits_Minute { get; }
    internal static string TimeUnits_Second { get; }
    internal static string UnableToDetemineClientVersion { get; }
    internal static string UnableToSetNuGetTempFolderPermission { get; }
    internal static string UnauthorizedLockFail { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UnsupportedHashAlgorithmName { get; }
    internal static string UnsupportedSignatureAlgorithmName { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Must_Be_GreaterThanOrEqualTo();
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_MissingRequiredEnvVar();
    internal static string get_MissingRequiredEnvVarsDotnet();
    internal static string get_TimeUnits_Hour();
    internal static string get_TimeUnits_Millisecond();
    internal static string get_TimeUnits_Minute();
    internal static string get_TimeUnits_Second();
    internal static string get_UnableToDetemineClientVersion();
    internal static string get_UnableToSetNuGetTempFolderPermission();
    internal static string get_UnauthorizedLockFail();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UnsupportedHashAlgorithmName();
    internal static string get_UnsupportedSignatureAlgorithmName();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.TelemetryActivity : object {
    private DateTime _startTime;
    private Stopwatch _stopwatch;
    private Stopwatch _intervalWatch;
    private List`1<Tuple`2<string, TimeSpan>> _intervalList;
    [NuGet.Common.NullableAttribute("2")]
private IDisposable _telemetryActivity;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private TelemetryEvent <TelemetryEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    [NuGet.Common.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static INuGetTelemetryService <NuGetTelemetryService>k__BackingField;
    public TelemetryEvent TelemetryEvent { get; public set; }
    public Guid ParentId { get; }
    public Guid OperationId { get; }
    [NuGet.Common.NullableAttribute("2")]
public static INuGetTelemetryService NuGetTelemetryService { get; public set; }
    private TelemetryActivity(Guid parentId, TelemetryEvent telemetryEvent, Guid operationId);
    [CompilerGeneratedAttribute]
public TelemetryEvent get_TelemetryEvent();
    [CompilerGeneratedAttribute]
public void set_TelemetryEvent(TelemetryEvent value);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public Guid get_OperationId();
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static INuGetTelemetryService get_NuGetTelemetryService();
    [NuGet.Common.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_NuGetTelemetryService(INuGetTelemetryService value);
    public void StartIntervalMeasure();
    public void EndIntervalMeasure(string propertyName);
    public IDisposable StartIndependentInterval(string propertyName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static void EmitTelemetryEvent(TelemetryEvent TelemetryEvent);
    public static TelemetryActivity Create(string eventName);
    public static TelemetryActivity Create(TelemetryEvent telemetryEvent);
    public static TelemetryActivity Create(Guid parentId, string eventName);
    public static TelemetryActivity Create(Guid parentId, TelemetryEvent telemetryEvent);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class NuGet.Common.TelemetryEvent : object {
    [NuGet.Common.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> _properties;
    [NuGet.Common.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> _piiProperties;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NuGet.Common.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ComplexData>k__BackingField;
    public string Name { get; }
    public int Count { get; }
    [NuGet.Common.NullableAttribute("2")]
public object Item { get; public set; }
    [NuGet.Common.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ComplexData { get; }
    public TelemetryEvent(string eventName);
    public TelemetryEvent(string eventName, Dictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public string get_Name();
    public int get_Count();
    public object get_Item(string key);
    public void set_Item(string key, object value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_ComplexData();
    public IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    public void AddPiiData(string key, object value);
    public IEnumerable`1<KeyValuePair`2<string, object>> GetPiiData();
}
internal static class NuGet.Common.TelemetryServiceUtility : object {
    [NuGet.Common.NullableAttribute("2")]
private static Stopwatch StopWatch;
    public static void StartOrResumeTimer();
    public static void StopTimer();
    public static TimeSpan GetTimerElapsedTime();
    public static double GetTimerElapsedTimeInSeconds();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.Token : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCategory <Category>k__BackingField;
    public string Value { get; private set; }
    public TokenCategory Category { get; private set; }
    public Token(TokenCategory category, string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public TokenCategory get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(TokenCategory value);
}
internal enum NuGet.Common.TokenCategory : Enum {
    public int value__;
    public static TokenCategory Text;
    public static TokenCategory Variable;
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.Common.Tokenizer : object {
    private string _text;
    private int _index;
    public Tokenizer(string text);
    [NuGet.Common.NullableContextAttribute("2")]
public Token Read();
    private static bool IsWordChar(char ch);
    private Token ParseTokenAfterDollarSign();
    private Token ParseText();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Common.UriUtility : object {
    private static string FilePrefix;
    private static bool IsHttpUrl(Uri uri);
    public static Uri CreateSourceUri(string source, UriKind kind);
    public static Uri TryCreateSourceUri(string source, UriKind kind);
    private static string FixSourceUri(string source);
    public static string UrlEncodeOdataParameter(string value);
    public static string GetLocalPath(string localOrUriPath);
    public static string GetAbsolutePathFromFile(string sourceFile, string path);
    [NuGet.Common.NullableContextAttribute("2")]
public static string GetAbsolutePath(string rootDirectory, string path);
    [NuGet.Common.NullableContextAttribute("2")]
public static bool IsNuGetOrg(string source);
}
internal enum NuGet.Common.WarningLevel : Enum {
    public int value__;
    public static WarningLevel Severe;
    public static WarningLevel Important;
    public static WarningLevel Minimal;
    public static WarningLevel Default;
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release.")]
internal static class NuGet.Common.XmlUtility : object {
    [NuGet.Common.NullableContextAttribute("1")]
public static XDocument Load(string filePath);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.AddItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <DisallowedValues>k__BackingField;
    public string ElementName { get; }
    public string Key { get; }
    public string Value { get; public set; }
    public IReadOnlyDictionary`2<string, string> AdditionalAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> DisallowedValues { get; }
    public AddItem(string key, string value);
    internal AddItem(XElement element, SettingsFile origin);
    public AddItem(string key, string value, IReadOnlyDictionary`2<string, string> additionalAttributes);
    public virtual string get_ElementName();
    public string get_Key();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public IReadOnlyDictionary`2<string, string> get_AdditionalAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_DisallowedValues();
    public virtual string GetValueAsPath();
    public void AddOrUpdateAdditionalAttribute(string attributeName, string value);
    [NuGet.Configuration.NullableContextAttribute("2")]
public sealed virtual bool Equals(object other);
    public sealed virtual int GetHashCode();
    public virtual SettingBase Clone();
    internal virtual void Update(SettingItem other);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.AuthorItem : TrustedSignerItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public AuthorItem(string name, CertificateItem[] certificates);
    internal AuthorItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.CertificateItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string Fingerprint { get; public set; }
    public HashAlgorithmName HashAlgorithm { get; public set; }
    public bool AllowUntrustedRoot { get; public set; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public CertificateItem(string fingerprint, HashAlgorithmName hashAlgorithm, bool allowUntrustedRoot);
    internal CertificateItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_Fingerprint();
    public void set_Fingerprint(string value);
    public HashAlgorithmName get_HashAlgorithm();
    public void set_HashAlgorithm(HashAlgorithmName value);
    public bool get_AllowUntrustedRoot();
    public void set_AllowUntrustedRoot(bool value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.ClearItem : SettingItem {
    public string ElementName { get; }
    internal ClearItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public virtual bool IsEmpty();
    public virtual SettingBase Clone();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.ClientCertificateProvider : object {
    private ISettings _settings;
    public ClientCertificateProvider(ISettings settings);
    public sealed virtual void AddOrUpdate(ClientCertItem item);
    public sealed virtual void Remove(IReadOnlyList`1<ClientCertItem> items);
    public sealed virtual IReadOnlyList`1<ClientCertItem> GetClientCertificates();
    public ClientCertItem GetClientCertificate(string packageSourceName);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal abstract class NuGet.Configuration.ClientCertItem : SettingItem {
    public string PackageSource { get; }
    protected bool CanHaveChildren { get; }
    protected ClientCertItem(string packageSource);
    internal ClientCertItem(XElement element, SettingsFile origin);
    public string get_PackageSource();
    protected virtual bool get_CanHaveChildren();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public abstract virtual IEnumerable`1<X509Certificate> Search();
    protected void SetPackageSource(string value);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.Configuration.ConfigurationConstants : object {
    public static string ActivePackageSourceSectionName;
    public static string Add;
    public static string AllowUntrustedRoot;
    public static string AllowInsecureConnections;
    public static string ApiKeys;
    public static string AuditSources;
    public static string Author;
    public static string BeginIgnoreMarker;
    public static string BindingRedirectsSection;
    public static string Certificate;
    public static string Package;
    public static string Clear;
    public static string ClearTextPasswordAttribute;
    public static string ClearTextPasswordToken;
    public static string ClientCertificates;
    public static string Config;
    public static string Configuration;
    public static string ConfigurationDefaultsFile;
    public static string CredentialsSectionName;
    public static string DefaultPackageManagementFormatKey;
    public static string DefaultPushSource;
    public static string DependencyVersion;
    public static string DisabledPackageSources;
    public static string DisableTLSCertificateValidation;
    public static string DoNotShowPackageManagementSelectionKey;
    public static string Enabled;
    public static string EndIgnoreMarker;
    public static string FailOnBindingRedirects;
    public static string FallbackPackageFolders;
    public static string FileCertificate;
    public static string FindByAttribute;
    public static string FindValueAttribute;
    public static string Fingerprint;
    public static string FingerprintAlgorithm;
    public static string UpdatePackageLastAccessTime;
    public static string GlobalPackagesFolder;
    public static string HashAlgorithm;
    public static string HostKey;
    public static string KeyAttribute;
    public static string MaxHttpRequestsPerSource;
    public static string NameAttribute;
    public static string NoProxy;
    public static string Owners;
    public static string PackageManagementSection;
    public static string PackageRestore;
    public static string PackageSourceAttribute;
    public static string PackageSources;
    public static string PasswordAttribute;
    public static string PasswordKey;
    public static string PasswordToken;
    public static string PathAttribute;
    public static string ProtocolVersionAttribute;
    public static string Repository;
    public static string RepositoryPath;
    public static string ServiceIndex;
    public static string SignatureValidationMode;
    public static string SkipBindingRedirectsKey;
    public static string StoreCertificate;
    public static string StoreLocationAttribute;
    public static string StoreNameAttribute;
    public static string TrustedSigners;
    public static string PackageSourceMapping;
    public static string UserKey;
    public static string UsernameToken;
    public static string ValidAuthenticationTypesToken;
    public static string ValueAttribute;
    public static string PatternAttribute;
    private static ConfigurationConstants();
    public static IReadOnlyList`1<string> GetConfigKeys();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.ConfigurationDefaults : object {
    private ISettings _settingsManager;
    private bool _defaultPackageSourceInitialized;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<PackageSource> _defaultPackageSources;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<PackageSource> _defaultAuditSources;
    [NuGet.Configuration.NullableAttribute("2")]
private string _defaultPushSource;
    [CompilerGeneratedAttribute]
private static ConfigurationDefaults <Instance>k__BackingField;
    public static ConfigurationDefaults Instance { get; }
    public IEnumerable`1<PackageSource> DefaultPackageSources { get; }
    public IReadOnlyList`1<PackageSource> DefaultAuditSources { get; }
    [NuGet.Configuration.NullableAttribute("2")]
public string DefaultPushSource { get; }
    [NuGet.Configuration.NullableAttribute("2")]
public string DefaultPackageRestoreConsent { get; }
    internal ConfigurationDefaults(string directory, string configFile);
    internal ConfigurationDefaults(ISettings settingsManager);
    private static ConfigurationDefaults();
    private static ConfigurationDefaults InitializeInstance();
    [CompilerGeneratedAttribute]
public static ConfigurationDefaults get_Instance();
    private IReadOnlyList`1<PackageSource> GetSourceItems(string sectionName);
    public IEnumerable`1<PackageSource> get_DefaultPackageSources();
    public IReadOnlyList`1<PackageSource> get_DefaultAuditSources();
    [NuGet.Configuration.NullableContextAttribute("2")]
public string get_DefaultPushSource();
    [NuGet.Configuration.NullableContextAttribute("2")]
public string get_DefaultPackageRestoreConsent();
}
internal enum NuGet.Configuration.CredentialRequestType : Enum {
    public int value__;
    public static CredentialRequestType Proxy;
    public static CredentialRequestType Unauthorized;
    public static CredentialRequestType Forbidden;
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.CredentialsItem : SettingItem {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    internal AddItem _username;
    internal AddItem _password;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AddItem <_validAuthenticationTypes>k__BackingField;
    public string ElementName { get; }
    public string Username { get; public set; }
    public bool IsPasswordClearText { get; private set; }
    public string Password { get; }
    [NuGet.Configuration.NullableAttribute("2")]
public string ValidAuthenticationTypes { get; public set; }
    protected bool CanHaveChildren { get; }
    [NuGet.Configuration.NullableAttribute("2")]
internal AddItem _validAuthenticationTypes { get; internal set; }
    public CredentialsItem(string name, string username, string password, bool isPasswordClearText, string validAuthenticationTypes);
    internal CredentialsItem(XElement element, SettingsFile origin);
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    public string get_Username();
    public void set_Username(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    [CompilerGeneratedAttribute]
private void set_IsPasswordClearText(bool value);
    public string get_Password();
    public void UpdatePassword(string password, bool isPasswordClearText);
    [NuGet.Configuration.NullableContextAttribute("2")]
public string get_ValidAuthenticationTypes();
    [NuGet.Configuration.NullableContextAttribute("2")]
public void set_ValidAuthenticationTypes(string value);
    protected virtual bool get_CanHaveChildren();
    public virtual bool IsEmpty();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal AddItem get__validAuthenticationTypes();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set__validAuthenticationTypes(AddItem value);
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem other);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.Configuration.EncryptionUtility : object {
    private static Byte[] _entropyBytes;
    private static EncryptionUtility();
    public static string EncryptString(string value);
    public static string DecryptString(string encryptedString);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.FileClientCertItem : ClientCertItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string FilePath { get; }
    public bool IsPasswordIsClearText { get; }
    [NuGet.Configuration.NullableAttribute("2")]
public string Password { get; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public FileClientCertItem(string packageSource, string filePath, string password, bool storePasswordInClearText, string settingsFilePath);
    internal FileClientCertItem(string packageSource, string filePath, string password, bool storePasswordInClearText, SettingsFile origin);
    internal FileClientCertItem(XElement element, SettingsFile origin);
    private static SettingsFile GetSettingsFile(string settingsFilePath);
    public virtual string get_ElementName();
    public string get_FilePath();
    public bool get_IsPasswordIsClearText();
    [NuGet.Configuration.NullableContextAttribute("2")]
public string get_Password();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    internal virtual XNode AsXNode();
    public virtual SettingBase Clone();
    public virtual IEnumerable`1<X509Certificate> Search();
    public void Update(string filePath, string password, bool storePasswordInClearText);
    [NuGet.Configuration.NullableContextAttribute("2")]
private string FindAbsoluteFilePath();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.Configuration.FileSystemUtility : object {
    internal static XDocument GetOrCreateDocument(XDocument content, string fullPath);
    internal static void AddFile(string fullPath, Action`1<Stream> writeToStream);
    private static int chmod(string pathname, int mode);
    internal static bool IsPathAFile(string path);
    internal static bool DoesFileExistIn(string root, string file);
    internal static IEnumerable`1<string> GetFilesRelativeToRoot(string root, string path, String[] filters, SearchOption searchOption);
    internal static string GetRelativePath(string root, string fullPath);
    internal static string EnsureTrailingSlash(string path);
    internal static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.IClientCertificateProvider {
    public abstract virtual void AddOrUpdate(ClientCertItem item);
    public abstract virtual IReadOnlyList`1<ClientCertItem> GetClientCertificates();
    public abstract virtual void Remove(IReadOnlyList`1<ClientCertItem> items);
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.ICredentialCache {
    public abstract virtual void Add(Uri uri, ICredentials credentials);
    public abstract virtual ICredentials GetCredentials(Uri uri);
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.ICredentialService {
    public bool HandlesDefaultCredentials { get; }
    public abstract virtual Task`1<ICredentials> GetCredentialsAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, CancellationToken cancellationToken);
    public abstract virtual bool TryGetLastKnownGoodCredentialsFromCache(Uri uri, bool isProxy, ICredentials& credentials);
    public abstract virtual bool get_HandlesDefaultCredentials();
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.IExtensionLocator {
    public abstract virtual IEnumerable`1<string> FindExtensions();
    public abstract virtual IEnumerable`1<string> FindCredentialProviders();
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.IMachineWideSettings {
    public ISettings Settings { get; }
    public abstract virtual ISettings get_Settings();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.ImmutableSettings : object {
    private ISettings _settings;
    internal ImmutableSettings(ISettings settings);
    [NuGet.Configuration.NullableContextAttribute("2")]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [NuGet.Configuration.NullableContextAttribute("2")]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    public sealed virtual void SaveToDisk();
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.IPackageSourceProvider {
    [NuGet.Configuration.NullableAttribute("2")]
public string ActivePackageSourceName { get; }
    [NuGet.Configuration.NullableAttribute("2")]
public string DefaultPushSource { get; }
    public abstract virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public abstract virtual IReadOnlyList`1<PackageSource> LoadAuditSources();
    public abstract virtual PackageSource GetPackageSourceByName(string name);
    public abstract virtual PackageSource GetPackageSourceBySource(string source);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void add_PackageSourcesChanged(EventHandler value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void remove_PackageSourcesChanged(EventHandler value);
    public abstract virtual void RemovePackageSource(string name);
    public abstract virtual void EnablePackageSource(string name);
    public abstract virtual void DisablePackageSource(string name);
    public abstract virtual void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    public abstract virtual void AddPackageSource(PackageSource source);
    public abstract virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    public abstract virtual bool IsPackageSourceEnabled(string name);
    [NuGet.Configuration.NullableContextAttribute("2")]
public abstract virtual string get_ActivePackageSourceName();
    [NuGet.Configuration.NullableContextAttribute("2")]
public abstract virtual string get_DefaultPushSource();
    public abstract virtual void SaveActivePackageSource(PackageSource source);
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.IProxyCache {
    public abstract virtual void Add(IWebProxy proxy);
    public abstract virtual IWebProxy GetProxy(Uri uri);
}
internal interface NuGet.Configuration.IProxyCredentialCache {
    public Guid Version { get; }
    public abstract virtual Guid get_Version();
    [NuGet.Configuration.NullableContextAttribute("1")]
public abstract virtual void UpdateCredential(Uri proxyAddress, NetworkCredential credentials);
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.ISettings {
    public abstract virtual SettingSection GetSection(string sectionName);
    public abstract virtual void AddOrUpdate(string sectionName, SettingItem item);
    public abstract virtual void Remove(string sectionName, SettingItem item);
    public abstract virtual void SaveToDisk();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void add_SettingsChanged(EventHandler value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public abstract virtual void remove_SettingsChanged(EventHandler value);
    public abstract virtual IList`1<string> GetConfigFilePaths();
    public abstract virtual IList`1<string> GetConfigRoots();
}
[NuGet.Configuration.NullableContextAttribute("1")]
internal interface NuGet.Configuration.ISettingsGroup {
    public abstract virtual void Remove(SettingElement setting);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NuGet.Configuration.NuGetConfiguration : SettingsGroup`1<SettingSection> {
    internal IReadOnlyDictionary`2<string, SettingSection> Sections { get; }
    protected bool CanBeCleared { get; }
    private NuGetConfiguration(IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingSection> children);
    internal NuGetConfiguration(SettingSection[] sections);
    internal NuGetConfiguration(SettingsFile origin);
    internal NuGetConfiguration(XElement element, SettingsFile origin);
    internal IReadOnlyDictionary`2<string, SettingSection> get_Sections();
    protected virtual bool get_CanBeCleared();
    public void AddOrUpdate(string sectionName, SettingItem item);
    public void Remove(string sectionName, SettingItem item);
    public SettingSection GetSection(string sectionName);
    internal void MergeSectionsInto(Dictionary`2<string, VirtualSettingSection> sectionsContainer);
    public virtual SettingBase Clone();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.NuGetConfigurationException : Exception {
    public NuGetConfigurationException(string message);
    public NuGetConfigurationException(string message, Exception innerException);
    protected NuGetConfigurationException(SerializationInfo info, StreamingContext context);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.Configuration.NuGetConstants : object {
    public static string NuGetHostName;
    public static string NuGetSymbolHostName;
    public static string V3FeedUrl;
    public static string V2FeedUrl;
    public static string V2LegacyOfficialPackageSourceUrl;
    public static string V2LegacyFeedUrl;
    public static string V1FeedUrl;
    public static string DefaultGalleryServerUrl;
    public static string ReadmeFileName;
    public static string NuGetSolutionSettingsFolder;
    public static string PackageExtension;
    public static string SnupkgExtension;
    public static string SymbolsExtension;
    public static string ManifestExtension;
    public static string ManifestSymbolsExtension;
    public static string ReadmeExtension;
    public static string PackageReferenceFile;
    public static string PackageSpecFileName;
    public static string FeedName;
    public static string DefaultConfigContent;
    private static NuGetConstants();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[NuGet.Configuration724319.RequiredMemberAttribute]
internal class NuGet.Configuration.NuGetPathContext : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <FallbackPackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserPackageFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpCacheFolder>k__BackingField;
    [NuGet.Configuration724319.RequiredMemberAttribute]
public IReadOnlyList`1<string> FallbackPackageFolders { get; public set; }
    [NuGet.Configuration724319.RequiredMemberAttribute]
public string UserPackageFolder { get; public set; }
    [NuGet.Configuration724319.RequiredMemberAttribute]
public string HttpCacheFolder { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_FallbackPackageFolders();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Configuration724319.IsExternalInit) set_FallbackPackageFolders(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserPackageFolder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Configuration724319.IsExternalInit) set_UserPackageFolder(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HttpCacheFolder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Configuration724319.IsExternalInit) set_HttpCacheFolder(string value);
    public static NuGetPathContext Create(ISettings settings);
    public static NuGetPathContext Create(string settingsRoot);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.NullSettings : object {
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    [CompilerGeneratedAttribute]
private static NullSettings <Instance>k__BackingField;
    public static NullSettings Instance { get; }
    private static NullSettings();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static NullSettings get_Instance();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    public sealed virtual void SaveToDisk();
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.OwnersItem : SettingItem {
    public static char OwnersListSeparator;
    [CompilerGeneratedAttribute]
private IList`1<string> <Content>k__BackingField;
    private SettingText _content;
    public string ElementName { get; }
    protected bool CanHaveChildren { get; }
    public IList`1<string> Content { get; private set; }
    public OwnersItem(string owners);
    internal OwnersItem(XElement element, SettingsFile origin);
    private static OwnersItem();
    public virtual string get_ElementName();
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Content();
    [CompilerGeneratedAttribute]
private void set_Content(IList`1<string> value);
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem other);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.PackagePatternItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string Pattern { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public PackagePatternItem(string pattern);
    internal PackagePatternItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_Pattern();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.PackageSource : object {
    public static int DefaultProtocolVersion;
    public static int MaxProtocolVersion;
    internal static bool DefaultAllowInsecureConnections;
    internal static bool DefaultDisableTLSCertificateValidation;
    private int _hashCode;
    private string _source;
    private bool _isHttp;
    private bool _isHttps;
    private bool _isLocal;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOfficial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PackageSourceCredential <Credentials>k__BackingField;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPersistable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxHttpRequestsPerSource>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<X509Certificate> <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowInsecureConnections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableTLSCertificateValidation>k__BackingField;
    public string Name { get; }
    public string Source { get; public set; }
    [NuGet.Configuration.NullableAttribute("2")]
public Uri TrySourceAsUri { get; }
    public Uri SourceUri { get; }
    public bool IsOfficial { get; public set; }
    public bool IsMachineWide { get; public set; }
    public bool IsEnabled { get; public set; }
    [NuGet.Configuration.NullableAttribute("2")]
public PackageSourceCredential Credentials { get; public set; }
    [NuGet.Configuration.NullableAttribute("2")]
public string Description { get; public set; }
    public bool IsPersistable { get; }
    public int MaxHttpRequestsPerSource { get; public set; }
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<X509Certificate> ClientCertificates { get; public set; }
    public int ProtocolVersion { get; public set; }
    public bool AllowInsecureConnections { get; public set; }
    public bool DisableTLSCertificateValidation { get; public set; }
    public bool IsHttp { get; }
    public bool IsHttps { get; }
    public bool IsLocal { get; }
    public PackageSource(string source);
    public PackageSource(string source, string name);
    public PackageSource(string source, string name, bool isEnabled);
    public PackageSource(string source, string name, bool isEnabled, bool isOfficial, bool isPersistable);
    [CompilerGeneratedAttribute]
public string get_Name();
    public string get_Source();
    public void set_Source(string value);
    [NuGet.Configuration.NullableContextAttribute("2")]
public Uri get_TrySourceAsUri();
    public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
public bool get_IsOfficial();
    [CompilerGeneratedAttribute]
public void set_IsOfficial(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
public void set_IsMachineWide(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PackageSourceCredential get_Credentials();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Credentials(PackageSourceCredential value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Description();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPersistable();
    [CompilerGeneratedAttribute]
public int get_MaxHttpRequestsPerSource();
    [CompilerGeneratedAttribute]
public void set_MaxHttpRequestsPerSource(int value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<X509Certificate> get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(IReadOnlyList`1<X509Certificate> value);
    [CompilerGeneratedAttribute]
public int get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowInsecureConnections();
    [CompilerGeneratedAttribute]
public void set_AllowInsecureConnections(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableTLSCertificateValidation();
    [CompilerGeneratedAttribute]
public void set_DisableTLSCertificateValidation(bool value);
    public bool get_IsHttp();
    public bool get_IsHttps();
    public bool get_IsLocal();
    public SourceItem AsSourceItem();
    [NuGet.Configuration.NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageSource other);
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
    public PackageSource Clone();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.PackageSourceCredential : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PasswordText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    private Lazy`1<int> _hashCode;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ValidAuthenticationTypesText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Username { get; }
    public string PasswordText { get; }
    public bool IsPasswordClearText { get; }
    public IEnumerable`1<string> ValidAuthenticationTypes { get; }
    [NuGet.Configuration.NullableAttribute("2")]
public string ValidAuthenticationTypesText { get; }
    public string Password { get; }
    public string Source { get; }
    public PackageSourceCredential(string source, string username, string passwordText, bool isPasswordClearText, string validAuthenticationTypesText);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_PasswordText();
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    public IEnumerable`1<string> get_ValidAuthenticationTypes();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ValidAuthenticationTypesText();
    public string get_Password();
    [CompilerGeneratedAttribute]
public string get_Source();
    public bool IsValid();
    public static PackageSourceCredential FromUserInput(string source, string username, string password, bool storePasswordInClearText, string validAuthenticationTypesText);
    public ICredentials ToICredentials();
    internal PackageSourceCredential Clone();
    private static IEnumerable`1<string> ParseAuthTypeFilterString(string str);
    public CredentialsItem AsCredentialsItem();
    [NuGet.Configuration.NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageSourceCredential other);
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private int <.ctor>b__21_0();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.PackageSourceMapping : object {
    [CompilerGeneratedAttribute]
private static int <PackageIdMaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> <Patterns>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Lazy`1<SearchTree> <SearchTree>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    internal static int PackageIdMaxLength { get; }
    internal IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> Patterns { get; }
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<SearchTree> SearchTree { get; }
    public bool IsEnabled { get; }
    public PackageSourceMapping(IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> patterns);
    private static PackageSourceMapping();
    [CompilerGeneratedAttribute]
internal static int get_PackageIdMaxLength();
    [CompilerGeneratedAttribute]
internal IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> get_Patterns();
    [CompilerGeneratedAttribute]
private Lazy`1<SearchTree> get_SearchTree();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public IReadOnlyList`1<string> GetConfiguredPackageSources(string packageId);
    public string SearchForPattern(string packageId);
    public static PackageSourceMapping GetPackageSourceMapping(ISettings settings);
    private SearchTree GetSearchTree();
    [CompilerGeneratedAttribute]
private SearchTree <.ctor>b__14_0();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.PackageSourceMappingProvider : object {
    private ISettings _settings;
    [CompilerGeneratedAttribute]
private bool <ShouldSkipSave>k__BackingField;
    public bool ShouldSkipSave { get; }
    public PackageSourceMappingProvider(ISettings settings);
    public PackageSourceMappingProvider(ISettings settings, bool shouldSkipSave);
    [CompilerGeneratedAttribute]
public bool get_ShouldSkipSave();
    public IReadOnlyList`1<PackageSourceMappingSourceItem> GetPackageSourceMappingItems();
    internal void Remove(IReadOnlyList`1<PackageSourceMappingSourceItem> packageSourceMappingSourceItems);
    internal void AddOrUpdatePackageSourceMappingSourceItem(PackageSourceMappingSourceItem packageSourceMappingSourceItem);
    public void SavePackageSourceMappings(IReadOnlyList`1<PackageSourceMappingSourceItem> packageSourceMappingsSourceItems);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.PackageSourceMappingSourceItem : SettingItem {
    [CompilerGeneratedAttribute]
private IList`1<PackagePatternItem> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    protected bool CanHaveChildren { get; }
    public IList`1<PackagePatternItem> Patterns { get; }
    public string ElementName { get; }
    public string Key { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public PackageSourceMappingSourceItem(string name, IEnumerable`1<PackagePatternItem> packagePatternItems);
    internal PackageSourceMappingSourceItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<PackagePatternItem> get_Patterns();
    public virtual string get_ElementName();
    public virtual string get_Key();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    protected void SetKey(string value);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    internal virtual void Update(SettingItem other);
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.PackageSourceProvider : object {
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    internal static int MaxSupportedProtocolVersion;
    private IReadOnlyList`1<PackageSource> _configurationDefaultSources;
    private IReadOnlyList`1<PackageSource> _configurationDefaultAuditSources;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler PackageSourcesChanged;
    public ISettings Settings { get; private set; }
    [NuGet.Configuration.NullableAttribute("2")]
public string DefaultPushSource { get; }
    [NuGet.Configuration.NullableAttribute("2")]
public string ActivePackageSourceName { get; }
    public PackageSourceProvider(ISettings settings);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, bool enablePackageSourcesChangedEvent);
    public PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources, bool enablePackageSourcesChangedEvent);
    public PackageSourceProvider(ISettings settings, ConfigurationDefaults configurationDefaults);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, ConfigurationDefaults configurationDefaults, bool enablePackageSourcesChangedEvent);
    private PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources, IReadOnlyList`1<PackageSource> configurationDefaultAuditSources, bool enablePackageSourcesChangedEvent);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(ISettings value);
    private static IReadOnlyList`1<PackageSource> LoadConfigurationDefaultSources(IEnumerable`1<PackageSource> configurationDefaultSources);
    private static List`1<PackageSource> GetPackageSourceFromSettings(ISettings settings, string sectionName);
    public sealed virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public sealed virtual IReadOnlyList`1<PackageSource> LoadAuditSources();
    public static IEnumerable`1<PackageSource> LoadPackageSources(ISettings settings);
    private static List`1<PackageSource> LoadPackageSources(ISettings settings, string sectionName, IEnumerable`1<PackageSource> defaultSources);
    private static void AddDefaultPackageSources(List`1<PackageSource> loadedPackageSources, IEnumerable`1<PackageSource> defaultPackageSources);
    internal static PackageSource ReadPackageSource(SourceItem setting, bool isEnabled, ISettings settings);
    private static int ReadProtocolVersion(SourceItem setting);
    private static bool ReadDisableTLSCertificateValidation(SourceItem setting);
    private static bool ReadAllowInsecureConnections(SourceItem setting);
    private static void AddOrUpdateIndexedSource(Dictionary`2<string, IndexedPackageSource> packageSourceLookup, PackageSource packageSource, Int32& packageIndex);
    private static PackageSourceCredential ReadCredential(string sourceName, ISettings settings);
    private static PackageSourceCredential ReadCredentialFromEnvironment(string sourceName);
    public sealed virtual PackageSource GetPackageSourceByName(string name);
    public HashSet`1<string> GetPackageSourceNamesMatchingNamePrefix(string namePrefix);
    public sealed virtual PackageSource GetPackageSourceBySource(string source);
    public sealed virtual void RemovePackageSource(string name);
    private void RemovePackageSource(string name, bool shouldSkipSave, Boolean& isDirty);
    [ObsoleteAttribute("DisablePackageSource(PackageSource source) is deprecated. Please use DisablePackageSource(string name) instead.")]
public void DisablePackageSource(PackageSource source);
    public sealed virtual void DisablePackageSource(string name);
    private void AddDisabledSource(string name, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void EnablePackageSource(string name);
    private void RemoveDisabledSource(string name, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    private void UpdatePackageSource(PackageSource newSource, PackageSource existingSource, AddItem existingDisabledSourceItem, CredentialsItem existingCredentialsItem, bool updateEnabled, bool updateCredentials, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void AddPackageSource(PackageSource source);
    private void AddPackageSource(PackageSource source, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    private Dictionary`2<string, SourceItem> GetExistingSettingsLookup();
    private void OnPackageSourcesChanged();
    [NuGet.Configuration.NullableContextAttribute("2")]
public sealed virtual string get_DefaultPushSource();
    public sealed virtual bool IsPackageSourceEnabled(string name);
    [ObsoleteAttribute("IsPackageSourceEnabled(PackageSource source) is deprecated. Please use IsPackageSourceEnabled(string name) instead.")]
public bool IsPackageSourceEnabled(PackageSource source);
    [NuGet.Configuration.NullableContextAttribute("2")]
public sealed virtual string get_ActivePackageSourceName();
    public sealed virtual void SaveActivePackageSource(PackageSource source);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PackageSourcesChanged(EventHandler value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PackageSourcesChanged(EventHandler value);
    [NuGet.Configuration.NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__13_0(object _, EventArgs __);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.ParsedSettingSection : SettingSection {
    internal ParsedSettingSection(string name, XElement element, SettingsFile origin);
    internal ParsedSettingSection(string name, SettingItem[] children);
    public virtual SettingBase Clone();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.ProxyCache : object {
    private static IWebProxy _originalSystemProxy;
    private ConcurrentDictionary`2<Uri, ICredentials> _cachedCredentials;
    private ISettings _settings;
    private IEnvironmentVariableReader _environment;
    private static Lazy`1<ProxyCache> _instance;
    [CompilerGeneratedAttribute]
private Guid <Version>k__BackingField;
    public static ProxyCache Instance { get; }
    public Guid Version { get; private set; }
    public ProxyCache(ISettings settings, IEnvironmentVariableReader environment);
    private static ProxyCache();
    private static ProxyCache FromDefaultSettings();
    public static ProxyCache get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Guid value);
    public sealed virtual IWebProxy GetProxy(Uri sourceUri);
    private bool TryAddProxyCredentialsToCache(WebProxy configuredProxy);
    [NuGet.Configuration.NullableContextAttribute("2")]
public WebProxy GetUserConfiguredProxy();
    public sealed virtual void UpdateCredential(Uri proxyAddress, NetworkCredential credentials);
    public sealed virtual NetworkCredential GetCredential(Uri proxyAddress, string authType);
    [NuGet.Configuration.NullableContextAttribute("2")]
[ObsoleteAttribute("Retained for backcompat only. Use UpdateCredential instead")]
public sealed virtual void Add(IWebProxy proxy);
    private static WebProxy GetSystemProxy(Uri uri);
    private static bool IsSystemProxySet(Uri uri);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.RepositoryItem : TrustedSignerItem {
    [NuGet.Configuration.NullableAttribute("2")]
private OwnersItem _owners;
    [CompilerGeneratedAttribute]
private IList`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string ServiceIndex { get; }
    public string Name { get; public set; }
    public IList`1<string> Owners { get; private set; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public RepositoryItem(string name, string serviceIndex, CertificateItem[] certificates);
    public RepositoryItem(string name, string serviceIndex, string owners, CertificateItem[] certificates);
    internal RepositoryItem(XElement element, SettingsFile origin);
    internal RepositoryItem(XElement element, SettingsFile origin, IEnumerable`1<SettingBase> parsedDescendants);
    public virtual string get_ElementName();
    public string get_ServiceIndex();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(IList`1<string> value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual void Update(SettingItem otherRepository);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Configuration.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Cannot_Be_Null_Empty_Or_WhiteSpaceOnly { get; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string AttributeNotAllowed { get; }
    internal static string AttributeValueNotAllowed { get; }
    internal static string CannotUpdateDifferentItems { get; }
    internal static string CannotUpdateMachineWide { get; }
    internal static string CannotUpdateNode { get; }
    internal static string CannotUpdateReadOnlyConfig { get; }
    internal static string ClientCertificateDuplicateConfiguration { get; }
    internal static string CredentialsItemMustHaveUsernamePassword { get; }
    internal static string Error_DuplicatePackageSource { get; }
    internal static string Error_EncryptionUnsupported { get; }
    internal static string Error_InvalidAttribute { get; }
    internal static string Error_ItemNeedsAtLeastOnePackagePattern { get; }
    internal static string Error_ItemNeedsAtLeastOnePackagePatternWithPath { get; }
    internal static string Error_MergeTwoDifferentSections { get; }
    internal static string Error_MoreThanOnePassword { get; }
    internal static string Error_MoreThanOneUsername { get; }
    internal static string Error_MoreThanOneValidAuthenticationTypes { get; }
    internal static string Error_StoreCertCertificateNotFound { get; }
    internal static string FileCertItemPasswordAndClearTextPasswordAtSameTime { get; }
    internal static string FileCertItemPasswordCannotBeDecrypted { get; }
    internal static string FileCertItemPathFileNotExist { get; }
    internal static string FileCertItemPathFileNotSet { get; }
    internal static string FileDoesNotExist { get; }
    internal static string InvalidNullSettingsOperation { get; }
    internal static string ItemDoesNotExist { get; }
    internal static string MissingRequiredAttribute { get; }
    internal static string MustContainAbsolutePath { get; }
    internal static string NoAttributesAllowed { get; }
    internal static string NoWritteableConfig { get; }
    internal static string OwnersItemMustHaveAtLeastOneOwner { get; }
    internal static string OwnersMustOnlyHaveContent { get; }
    internal static string PropertyCannotBeNullOrEmpty { get; }
    internal static string RepositoryMustHaveOneOwners { get; }
    internal static string SectionDoesNotExist { get; }
    internal static string Settings_FileName_Cannot_Be_A_Path { get; }
    internal static string ShowError_CannotHaveChildren { get; }
    internal static string ShowError_ConfigDuplicateDisabledSources { get; }
    internal static string ShowError_ConfigHasInvalidPackageSource { get; }
    internal static string ShowError_ConfigInvalidOperation { get; }
    internal static string ShowError_ConfigInvalidXml { get; }
    internal static string ShowError_ConfigRootInvalid { get; }
    internal static string ShowError_ConfigUnauthorizedAccess { get; }
    internal static string ShowError_UnknownOrigin { get; }
    internal static string TextShouldNotBeEmpty { get; }
    internal static string TrustedSignerMustHaveCertificates { get; }
    internal static string Unknown_Config_Exception { get; }
    internal static string UnknownHashAlgorithmNotSupported { get; }
    internal static string UnsupportedDecryptPassword { get; }
    internal static string UnsupportedEncryptPassword { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UserSettings_UnableToParseConfigFile { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Cannot_Be_Null_Empty_Or_WhiteSpaceOnly();
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_AttributeNotAllowed();
    internal static string get_AttributeValueNotAllowed();
    internal static string get_CannotUpdateDifferentItems();
    internal static string get_CannotUpdateMachineWide();
    internal static string get_CannotUpdateNode();
    internal static string get_CannotUpdateReadOnlyConfig();
    internal static string get_ClientCertificateDuplicateConfiguration();
    internal static string get_CredentialsItemMustHaveUsernamePassword();
    internal static string get_Error_DuplicatePackageSource();
    internal static string get_Error_EncryptionUnsupported();
    internal static string get_Error_InvalidAttribute();
    internal static string get_Error_ItemNeedsAtLeastOnePackagePattern();
    internal static string get_Error_ItemNeedsAtLeastOnePackagePatternWithPath();
    internal static string get_Error_MergeTwoDifferentSections();
    internal static string get_Error_MoreThanOnePassword();
    internal static string get_Error_MoreThanOneUsername();
    internal static string get_Error_MoreThanOneValidAuthenticationTypes();
    internal static string get_Error_StoreCertCertificateNotFound();
    internal static string get_FileCertItemPasswordAndClearTextPasswordAtSameTime();
    internal static string get_FileCertItemPasswordCannotBeDecrypted();
    internal static string get_FileCertItemPathFileNotExist();
    internal static string get_FileCertItemPathFileNotSet();
    internal static string get_FileDoesNotExist();
    internal static string get_InvalidNullSettingsOperation();
    internal static string get_ItemDoesNotExist();
    internal static string get_MissingRequiredAttribute();
    internal static string get_MustContainAbsolutePath();
    internal static string get_NoAttributesAllowed();
    internal static string get_NoWritteableConfig();
    internal static string get_OwnersItemMustHaveAtLeastOneOwner();
    internal static string get_OwnersMustOnlyHaveContent();
    internal static string get_PropertyCannotBeNullOrEmpty();
    internal static string get_RepositoryMustHaveOneOwners();
    internal static string get_SectionDoesNotExist();
    internal static string get_Settings_FileName_Cannot_Be_A_Path();
    internal static string get_ShowError_CannotHaveChildren();
    internal static string get_ShowError_ConfigDuplicateDisabledSources();
    internal static string get_ShowError_ConfigHasInvalidPackageSource();
    internal static string get_ShowError_ConfigInvalidOperation();
    internal static string get_ShowError_ConfigInvalidXml();
    internal static string get_ShowError_ConfigRootInvalid();
    internal static string get_ShowError_ConfigUnauthorizedAccess();
    internal static string get_ShowError_UnknownOrigin();
    internal static string get_TextShouldNotBeEmpty();
    internal static string get_TrustedSignerMustHaveCertificates();
    internal static string get_Unknown_Config_Exception();
    internal static string get_UnknownHashAlgorithmNotSupported();
    internal static string get_UnsupportedDecryptPassword();
    internal static string get_UnsupportedEncryptPassword();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UserSettings_UnableToParseConfigFile();
}
internal class NuGet.Configuration.SearchNode : object {
    [NuGet.Configuration.NullableAttribute("1")]
public Dictionary`2<char, SearchNode> Children;
    [CompilerGeneratedAttribute]
private bool <IsGlobbing>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<string> PackageSources;
    public bool IsGlobbing { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsGlobbing();
    [CompilerGeneratedAttribute]
public void set_IsGlobbing(bool value);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.SearchTree : object {
    private SearchNode _root;
    internal SearchTree(PackageSourceMapping configuration);
    private void Add(string packageSourceKey, string packagePattern);
    public string SearchForPattern(string term);
    public IReadOnlyList`1<string> GetConfiguredPackageSources(string term);
    private SearchNode SearchNodeByTerm(string term);
    private string SearchPatternByTerm(string term);
}
[NuGet.Configuration.NullableContextAttribute("2")]
[NuGet.Configuration.NullableAttribute("0")]
internal abstract class NuGet.Configuration.SettingBase : object {
    [CompilerGeneratedAttribute]
private XNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsGroup <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsFile <Origin>k__BackingField;
    internal XNode Node { get; private set; }
    internal ISettingsGroup Parent { get; internal set; }
    internal SettingsFile Origin { get; private set; }
    [NuGet.Configuration.NullableContextAttribute("1")]
internal SettingBase(XNode node, SettingsFile origin);
    [CompilerGeneratedAttribute]
internal XNode get_Node();
    [CompilerGeneratedAttribute]
private void set_Node(XNode value);
    [CompilerGeneratedAttribute]
internal ISettingsGroup get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ISettingsGroup value);
    [CompilerGeneratedAttribute]
internal SettingsFile get_Origin();
    [CompilerGeneratedAttribute]
private void set_Origin(SettingsFile value);
    internal bool IsAbstract();
    internal bool IsCopy();
    public abstract virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    [NuGet.Configuration.NullableContextAttribute("1")]
public abstract virtual SettingBase Clone();
    [NuGet.Configuration.NullableContextAttribute("1")]
internal void SetNode(XNode node);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal abstract class NuGet.Configuration.SettingElement : SettingBase {
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <AllowedValues>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <DisallowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <MutableAttributes>k__BackingField;
    public string ElementName { get; }
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> AllowedValues { get; }
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> DisallowedValues { get; }
    protected Dictionary`2<string, string> MutableAttributes { get; }
    internal IReadOnlyDictionary`2<string, string> Attributes { get; }
    [NuGet.Configuration.NullableAttribute("2")]
public string ConfigPath { get; }
    protected SettingElement(IReadOnlyDictionary`2<string, string> attributes);
    internal SettingElement(XElement element, SettingsFile origin);
    public abstract virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_AllowedValues();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_DisallowedValues();
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, string> get_MutableAttributes();
    internal IReadOnlyDictionary`2<string, string> get_Attributes();
    public virtual bool IsEmpty();
    [NuGet.Configuration.NullableContextAttribute("2")]
public string get_ConfigPath();
    internal virtual XNode AsXNode();
    protected void AddOrUpdateAttribute(string attributeName, string value);
    internal bool UpdateAttribute(string attributeName, string newValue);
    protected void AddAttribute(string attributeName, string value);
    private bool IsAttributeValid(string attributeName, string value);
    private void ValidateAttributes(XElement element, SettingsFile origin);
}
internal enum NuGet.Configuration.SettingElementType : Enum {
    public int value__;
    public static SettingElementType Unknown;
    public static SettingElementType Configuration;
    public static SettingElementType ActivePackageSource;
    public static SettingElementType BindingRedirects;
    public static SettingElementType Config;
    public static SettingElementType PackageManagement;
    public static SettingElementType PackageRestore;
    public static SettingElementType PackageSourceCredentials;
    public static SettingElementType PackageSources;
    public static SettingElementType Add;
    public static SettingElementType Author;
    public static SettingElementType Certificate;
    public static SettingElementType Clear;
    public static SettingElementType Owners;
    public static SettingElementType Repository;
    public static SettingElementType FileCert;
    public static SettingElementType StoreCert;
    public static SettingElementType PackageSourceMapping;
    public static SettingElementType PackageSource;
    public static SettingElementType Package;
    public static SettingElementType AuditSources;
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.Configuration.SettingFactory : object {
    internal static SettingBase Parse(XNode node, SettingsFile origin);
    internal static IEnumerable`1<T> ParseChildren(XElement xElement, SettingsFile origin, bool canBeCleared);
}
[NuGet.Configuration.NullableContextAttribute("2")]
[NuGet.Configuration.NullableAttribute("0")]
internal abstract class NuGet.Configuration.SettingItem : SettingElement {
    [CompilerGeneratedAttribute]
private SettingItem <MergedWith>k__BackingField;
    protected bool CanHaveChildren { get; }
    internal SettingItem MergedWith { get; internal set; }
    protected SettingItem(IReadOnlyDictionary`2<string, string> attributes);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal SettingItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
internal SettingItem get_MergedWith();
    [CompilerGeneratedAttribute]
internal void set_MergedWith(SettingItem value);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal virtual void Update(SettingItem setting);
    [NuGet.Configuration.NullableContextAttribute("1")]
public IReadOnlyDictionary`2<string, string> GetAttributes();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.Settings : object {
    public static string DefaultSettingsFileName;
    public static String[] OrderedSettingsFileNames;
    public static String[] SupportedMachineWideConfigExtension;
    private Dictionary`2<string, VirtualSettingSection> _computedSections;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    [CompilerGeneratedAttribute]
private IList`1<SettingsFile> <SettingsFiles>k__BackingField;
    private IList`1<SettingsFile> SettingsFiles { get; }
    internal IEnumerable`1<SettingsFile> Priority { get; }
    public Settings(string root);
    public Settings(string root, string fileName);
    public Settings(string root, string fileName, bool isMachineWide);
    internal Settings(IList`1<SettingsFile> settingsFiles);
    private static Settings();
    public sealed virtual SettingSection GetSection(string sectionName);
    public IEnumerable`1<string> GetAllSettingSections();
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    internal void AddOrUpdate(SettingsFile settingsFile, string sectionName, SettingItem item);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private IList`1<SettingsFile> get_SettingsFiles();
    private SettingsFile GetOutputSettingFileForSection(string sectionName);
    internal IEnumerable`1<SettingsFile> get_Priority();
    public sealed virtual void SaveToDisk();
    public static ISettings LoadDefaultSettings(string root);
    [NuGet.Configuration.NullableContextAttribute("2")]
public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings);
    [NuGet.Configuration.NullableContextAttribute("2")]
public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings, SettingsLoadingContext settingsLoadingContext);
    public static ISettings LoadSpecificSettings(string root, string configFileName);
    public static ISettings LoadImmutableSettingsGivenConfigPaths(IList`1<string> configFilePaths, SettingsLoadingContext settingsLoadingContext);
    public static ISettings LoadSettingsGivenConfigPaths(IList`1<string> configFilePaths);
    private static ISettings LoadSettingsGivenSettingsFiles(List`1<SettingsFile> settings);
    [NuGet.Configuration.NullableContextAttribute("2")]
internal static ISettings LoadSettings(string root, string configFileName, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    internal static ISettings LoadSettings(DirectoryInfo root, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    [NuGet.Configuration.NullableContextAttribute("2")]
private static ISettings LoadSettingsForSpecificConfigs(string root, string configFileName, List`1<SettingsFile> validSettingFiles, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    [NuGet.Configuration.NullableContextAttribute("2")]
[IteratorStateMachineAttribute("NuGet.Configuration.Settings/<LoadUserSpecificSettings>d__33")]
internal static IEnumerable`1<SettingsFile> LoadUserSpecificSettings(string root, string configFileName, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    private static string GetUserSettingsDirectory(string rootDirectory, bool useTestingGlobalPath);
    private static string GetAdditionalUserWideConfigurationDirectory(string userSettingsDirectory);
    public static ISettings LoadMachineWideSettings(string root, String[] paths);
    public static string ApplyEnvironmentTransform(string value);
    public static Tuple`2<string, string> GetFileNameAndItsRoot(string root, string settingsPath);
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
    internal static string ResolvePathFromOrigin(string originDirectoryPath, string originFilePath, string path);
    private static string ResolveRelativePath(string originDirectoryPath, string originFilePath, string path);
    private static string ResolvePath(string configDirectory, string value);
    private static SettingsFile ReadSettings(string settingsRoot, string settingsPath, bool isMachineWideSettings, bool isAdditionalUserWideConfig, SettingsLoadingContext settingsLoadingContext);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<GetSettingsFilesFullPath>d__45")]
private static IEnumerable`1<string> GetSettingsFilesFullPath(string root);
    private static string GetSettingsFileNameFromDir(string directory);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<GetSettingsFilePaths>d__47")]
private static IEnumerable`1<string> GetSettingsFilePaths(string root);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class NuGet.Configuration.SettingSection : SettingsGroup`1<SettingItem> {
    public IReadOnlyCollection`1<SettingItem> Items { get; }
    protected SettingSection(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingItem> children);
    internal SettingSection(string name, XElement element, SettingsFile origin);
    public IReadOnlyCollection`1<SettingItem> get_Items();
    public T GetFirstItemWithAttribute(string attributeName, string expectedAttributeValue);
    internal bool Update(SettingItem item);
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.SettingsFile : object {
    [CompilerGeneratedAttribute]
private string <ConfigFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private XDocument _xDocument;
    private NuGetConfiguration _rootElement;
    internal string ConfigFilePath { get; }
    internal string DirectoryPath { get; }
    internal string FileName { get; }
    internal bool IsDirty { get; internal set; }
    internal bool IsMachineWide { get; }
    internal bool IsReadOnly { get; }
    public SettingsFile(string directoryPath);
    public SettingsFile(string directoryPath, string fileName);
    public SettingsFile(string directoryPath, string fileName, bool isMachineWide, bool isReadOnly);
    [CompilerGeneratedAttribute]
internal string get_ConfigFilePath();
    [CompilerGeneratedAttribute]
internal string get_DirectoryPath();
    [CompilerGeneratedAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
internal bool get_IsDirty();
    [CompilerGeneratedAttribute]
internal void set_IsDirty(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
internal bool get_IsReadOnly();
    public SettingSection GetSection(string sectionName);
    internal void AddOrUpdate(string sectionName, SettingItem item);
    internal void Remove(string sectionName, SettingItem item);
    internal void SaveToDisk();
    internal bool IsEmpty();
    internal bool TryGetSection(string sectionName, SettingSection& section);
    internal void MergeSectionsInto(Dictionary`2<string, VirtualSettingSection> sectionsContainer);
    private XDocument CreateDefaultConfig();
    private T ExecuteSynchronized(Func`1<T> ioOperation);
    [NuGet.Configuration.NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private XDocument <.ctor>b__23_0();
    [CompilerGeneratedAttribute]
private int <SaveToDisk>b__27_0();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal abstract class NuGet.Configuration.SettingsGroup`1 : SettingElement {
    [CompilerGeneratedAttribute]
private IList`1<T> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    protected IList`1<T> Children { get; private set; }
    protected bool CanBeCleared { get; }
    public string ElementName { get; }
    protected SettingsGroup`1(string name);
    protected SettingsGroup`1(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<T> children);
    internal SettingsGroup`1(string name, XElement element, SettingsFile origin);
    [CompilerGeneratedAttribute]
protected IList`1<T> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(IList`1<T> value);
    protected virtual bool get_CanBeCleared();
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    public virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual bool Add(T setting);
    internal virtual void Remove(T setting);
    protected bool TryGetChild(T expectedChild, T& currentChild);
    private sealed virtual override void NuGet.Configuration.ISettingsGroup.Remove(SettingElement setting);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.SettingsLoadingContext : object {
    private ConcurrentDictionary`2<string, Lazy`1<SettingsFile>> _cache;
    private bool _isDisposed;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<string> FileRead;
    [CompilerGeneratedAttribute]
internal void add_FileRead(EventHandler`1<string> value);
    [CompilerGeneratedAttribute]
internal void remove_FileRead(EventHandler`1<string> value);
    public sealed virtual void Dispose();
    internal SettingsFile GetOrCreateSettingsFile(string filePath, bool isMachineWide, bool isReadOnly);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.Configuration.SettingsUtility : object {
    private static string GlobalPackagesFolderEnvironmentKey;
    private static string FallbackPackagesFolderEnvironmentKey;
    private static string HttpCacheEnvironmentKey;
    private static string PluginsCacheEnvironmentKey;
    public static string DefaultGlobalPackagesFolderPath;
    private static string RevocationModeEnvironmentKey;
    private static SettingsUtility();
    public static string GetValueForAddItem(ISettings settings, string section, string key, bool isPath);
    public static bool DeleteValue(ISettings settings, string section, string attributeKey, string attributeValue);
    public static string GetRepositoryPath(ISettings settings);
    public static int GetMaxHttpRequest(ISettings settings);
    public static SignatureValidationMode GetSignatureValidationMode(ISettings settings);
    public static bool GetUpdatePackageLastAccessTimeEnabledStatus(ISettings settings);
    public static string GetDecryptedValueForAddItem(ISettings settings, string section, string key, bool isPath);
    public static void SetEncryptedValueForAddItem(ISettings settings, string section, string key, string value);
    public static string GetConfigValue(ISettings settings, string key, bool decrypt, bool isPath);
    public static void SetConfigValue(ISettings settings, string key, string value, bool encrypt);
    public static bool DeleteConfigValue(ISettings settings, string key);
    public static string GetGlobalPackagesFolder(ISettings settings);
    public static IReadOnlyList`1<string> GetFallbackPackageFolders(ISettings settings);
    private static IReadOnlyList`1<string> GetFallbackPackageFoldersFromConfig(ISettings settings);
    public static string GetHttpCacheFolder();
    public static string GetPluginsCacheFolder();
    public static IEnumerable`1<PackageSource> GetEnabledSources(ISettings settings);
    public static string GetDefaultPushSource(ISettings settings);
    [NuGet.Configuration.NullableContextAttribute("2")]
public static RevocationMode GetRevocationMode(IEnvironmentVariableReader environmentVariableReader);
    private static void VerifyPathIsRooted(string key, string path);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.SettingText : SettingBase {
    private string _value;
    public string Value { get; public set; }
    public SettingText(string value);
    internal SettingText(XText text, SettingsFile origin);
    public string get_Value();
    public void set_Value(string value);
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual bool IsEmpty();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
}
[NuGet.Configuration.NullableContextAttribute("2")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.SourceItem : AddItem {
    public string ProtocolVersion { get; public set; }
    public string AllowInsecureConnections { get; public set; }
    public string DisableTLSCertificateValidation { get; public set; }
    [NuGet.Configuration.NullableContextAttribute("1")]
public SourceItem(string key, string value);
    [NuGet.Configuration.NullableContextAttribute("1")]
public SourceItem(string key, string value, string protocolVersion);
    [NuGet.Configuration.NullableContextAttribute("1")]
public SourceItem(string key, string value, string protocolVersion, string allowInsecureConnections);
    public SourceItem(string key, string value, string protocolVersion, string allowInsecureConnections, string disableTLSCertificateValidation);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal SourceItem(XElement element, SettingsFile origin);
    public string get_ProtocolVersion();
    public void set_ProtocolVersion(string value);
    public string get_AllowInsecureConnections();
    public void set_AllowInsecureConnections(string value);
    public string get_DisableTLSCertificateValidation();
    public void set_DisableTLSCertificateValidation(string value);
    [NuGet.Configuration.NullableContextAttribute("1")]
public virtual SettingBase Clone();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.StoreClientCertItem : ClientCertItem {
    private static X509FindType DefaultFindBy;
    private static StoreLocation DefaultStoreLocation;
    private static StoreName DefaultStoreName;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <AllowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public X509FindType FindType { get; }
    public string FindValue { get; }
    public StoreLocation StoreLocation { get; }
    public StoreName StoreName { get; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> AllowedValues { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public StoreClientCertItem(string packageSource, string findValue, Nullable`1<StoreLocation> storeLocation, Nullable`1<StoreName> storeName, Nullable`1<X509FindType> findBy);
    internal StoreClientCertItem(XElement element, SettingsFile origin);
    public static string GetString(X509FindType type);
    public static string GetString(StoreName storeName);
    public static string GetString(StoreLocation storeLocation);
    public virtual string get_ElementName();
    public X509FindType get_FindType();
    public string get_FindValue();
    public StoreLocation get_StoreLocation();
    public StoreName get_StoreName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_AllowedValues();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    internal virtual XNode AsXNode();
    public virtual SettingBase Clone();
    public virtual IEnumerable`1<X509Certificate> Search();
    [NuGet.Configuration.NullableContextAttribute("2")]
public void Update(string findValue, Nullable`1<StoreLocation> storeLocation, Nullable`1<StoreName> storeName, Nullable`1<X509FindType> findBy);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal abstract class NuGet.Configuration.TrustedSignerItem : SettingItem {
    [CompilerGeneratedAttribute]
private IList`1<CertificateItem> <Certificates>k__BackingField;
    protected bool CanHaveChildren { get; }
    public IList`1<CertificateItem> Certificates { get; }
    public string Name { get; }
    protected TrustedSignerItem(string name, IEnumerable`1<CertificateItem> certificates);
    internal TrustedSignerItem(XElement element, SettingsFile origin);
    internal TrustedSignerItem(XElement element, SettingsFile origin, IEnumerable`1<SettingBase> parsedDescendants);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<CertificateItem> get_Certificates();
    public virtual string get_Name();
    protected void SetName(string value);
    internal static IEnumerable`1<SettingBase> ParseDescendants(XElement element, SettingsFile origin);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual void Update(SettingItem other);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.UnknownItem : SettingItem {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    private Dictionary`2<SettingBase, SettingBase> _mutableChildren;
    public string ElementName { get; }
    public IReadOnlyList`1<SettingBase> Children { get; }
    protected bool CanHaveChildren { get; }
    internal UnknownItem(XElement element, SettingsFile origin);
    public UnknownItem(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingBase> children);
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    public IReadOnlyList`1<SettingBase> get_Children();
    public virtual bool IsEmpty();
    protected virtual bool get_CanHaveChildren();
    public virtual SettingBase Clone();
    internal bool Add(SettingBase setting);
    private sealed virtual override void NuGet.Configuration.ISettingsGroup.Remove(SettingElement setting);
    internal void Remove(SettingBase setting);
    internal virtual XNode AsXNode();
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem setting);
    internal void Merge(UnknownItem item);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.VirtualSettingSection : SettingSection {
    internal VirtualSettingSection(SettingSection section);
    internal VirtualSettingSection(string name, SettingItem[] children);
    internal VirtualSettingSection(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingItem> children);
    internal VirtualSettingSection Merge(SettingSection other);
    internal virtual bool Add(SettingItem setting);
    internal virtual void Remove(SettingItem setting);
    private bool TryRemoveAllMergedWith(SettingItem currentSetting, SettingItem& undeletedItem);
    public virtual SettingBase Clone();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.WebProxy : object {
    private IReadOnlyList`1<string> _bypassList;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Regex[] _regExBypassList;
    [CompilerGeneratedAttribute]
private Uri <ProxyAddress>k__BackingField;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    public Uri ProxyAddress { get; private set; }
    [NuGet.Configuration.NullableAttribute("2")]
public ICredentials Credentials { get; public set; }
    public IReadOnlyList`1<string> BypassList { get; public set; }
    public WebProxy(string proxyAddress);
    public WebProxy(Uri proxyAddress);
    [CompilerGeneratedAttribute]
public Uri get_ProxyAddress();
    [CompilerGeneratedAttribute]
private void set_ProxyAddress(Uri value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    public IReadOnlyList`1<string> get_BypassList();
    public void set_BypassList(IReadOnlyList`1<string> value);
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri uri);
    private void UpdateRegExList();
    private static string WildcardToRegex(string pattern);
    private static Uri CreateProxyUri(string address);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.Configuration.XElementUtility : object {
    internal static string GetOptionalAttributeValue(XElement element, string localName);
    internal static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [NuGet.Configuration.NullableContextAttribute("2")]
internal static void AddIndented(XContainer container, XNode content);
    [NuGet.Configuration.NullableContextAttribute("2")]
internal static void RemoveIndented(XNode element);
    private static string ComputeOneLevelOfIndentation(XNode node);
    private static bool IsWhiteSpace(XText textNode);
    private static void IndentChildrenElements(XContainer container, string containerIndent, string oneIndentLevel);
    private static void AddLeadingIndentation(XContainer container, string containerIndent, string oneIndentLevel);
    private static void AddTrailingIndentation(XContainer container, string containerIndent);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.XPlatMachineWideSetting : object {
    private Lazy`1<ISettings> _settings;
    public ISettings Settings { get; }
    public sealed virtual ISettings get_Settings();
}
internal class NuGet.ContentModel.Asset : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Link>k__BackingField;
    public string Path { get; public set; }
    public string Link { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Link();
    [CompilerGeneratedAttribute]
public void set_Link(string value);
    public virtual string ToString();
}
internal class NuGet.ContentModel.ContentItem : object {
    private Dictionary`2<string, object> _properties;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; public set; }
    public Dictionary`2<string, object> Properties { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public Dictionary`2<string, object> get_Properties();
    internal void set_Properties(Dictionary`2<string, object> value);
    public virtual string ToString();
    private Dictionary`2<string, object> CreateDictionary();
}
internal class NuGet.ContentModel.ContentItemCollection : object {
    private List`1<Asset> _assets;
    private ConcurrentDictionary`2<string, string> _assemblyRelatedExtensions;
    [CompilerGeneratedAttribute]
private bool <HasContract>k__BackingField;
    public bool HasContract { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_HasContract();
    [CompilerGeneratedAttribute]
private void set_HasContract(bool value);
    public void Load(IEnumerable`1<string> paths);
    public IEnumerable`1<ContentItem> FindItems(PatternSet definition);
    [IteratorStateMachineAttribute("NuGet.ContentModel.ContentItemCollection/<FindItemGroups>d__8")]
[ObsoleteAttribute("This method causes excessive memory allocation with yield return. Use ContentItemCollection.PopulateItemGroups instead.")]
public IEnumerable`1<ContentItemGroup> FindItemGroups(PatternSet definition);
    public void PopulateItemGroups(PatternSet definition, IList`1<ContentItemGroup> contentItemGroupList);
    public bool HasItemGroup(SelectionCriteria criteria, PatternSet[] definitions);
    public ContentItemGroup FindBestItemGroup(SelectionCriteria criteria, PatternSet[] definitions);
    private List`1<ContentItem> FindItemsImplementation(PatternSet definition, IEnumerable`1<Asset> assets);
    internal string GetRelatedFileExtensionProperty(string assemblyPath, IEnumerable`1<Asset> assets);
    private static bool IsValidAsset(string path);
}
[DebuggerDisplayAttribute("Items: {Items.Count}, Properties: {Properties.Count}")]
internal class NuGet.ContentModel.ContentItemGroup : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ContentItem> <Items>k__BackingField;
    public IDictionary`2<string, object> Properties { get; }
    public IList`1<ContentItem> Items { get; }
    internal ContentItemGroup(IDictionary`2<string, object> properties, IList`1<ContentItem> items);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public IList`1<ContentItem> get_Items();
}
internal class NuGet.ContentModel.ContentPropertyDefinition : object {
    private static Func`3<object, object, bool> EqualsTest;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <FileExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileExtensionAllowSubFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, PatternTable, object> <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<object, object, bool> <CompatibilityTest>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<object, object, object, int> <CompareTest>k__BackingField;
    public string Name { get; }
    public List`1<string> FileExtensions { get; }
    public bool FileExtensionAllowSubFolders { get; }
    public Func`3<string, PatternTable, object> Parser { get; }
    public Func`3<object, object, bool> CompatibilityTest { get; }
    public Func`4<object, object, object, int> CompareTest { get; }
    public ContentPropertyDefinition(string name);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser);
    public ContentPropertyDefinition(string name, Func`3<object, object, bool> compatibilityTest);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest, Func`4<object, object, object, int> compareTest);
    public ContentPropertyDefinition(string name, IEnumerable`1<string> fileExtensions);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, IEnumerable`1<string> fileExtensions);
    public ContentPropertyDefinition(string name, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest, Func`4<object, object, object, int> compareTest, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    private static ContentPropertyDefinition();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public List`1<string> get_FileExtensions();
    [CompilerGeneratedAttribute]
public bool get_FileExtensionAllowSubFolders();
    [CompilerGeneratedAttribute]
public Func`3<string, PatternTable, object> get_Parser();
    public virtual bool TryLookup(string name, PatternTable table, Object& value);
    private static bool ContainsSlash(string name);
    [CompilerGeneratedAttribute]
public Func`3<object, object, bool> get_CompatibilityTest();
    [CompilerGeneratedAttribute]
public Func`4<object, object, object, int> get_CompareTest();
    public virtual bool IsCriteriaSatisfied(object critieriaValue, object candidateValue);
    public virtual int Compare(object criteriaValue, object candidateValue1, object candidateValue2);
}
internal class NuGet.ContentModel.Infrastructure.PatternExpression : object {
    private List`1<Segment> _segments;
    private Dictionary`2<string, object> _defaults;
    private PatternTable _table;
    public PatternExpression(PatternDefinition pattern);
    private void Initialize(string pattern);
    internal ContentItem Match(string path, IReadOnlyDictionary`2<string, ContentPropertyDefinition> propertyDefinitions);
}
internal class NuGet.ContentModel.PatternDefinition : object {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternTable <Table>k__BackingField;
    public string Pattern { get; }
    public IReadOnlyDictionary`2<string, object> Defaults { get; }
    public PatternTable Table { get; }
    public PatternDefinition(string pattern);
    public PatternDefinition(string pattern, PatternTable table);
    public PatternDefinition(string pattern, PatternTable table, IEnumerable`1<KeyValuePair`2<string, object>> defaults);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Defaults();
    [CompilerGeneratedAttribute]
public PatternTable get_Table();
    public static PatternDefinition op_Implicit(string pattern);
}
internal class NuGet.ContentModel.PatternSet : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PatternDefinition> <GroupPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternExpression[] <GroupExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PatternDefinition> <PathPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternExpression[] <PathExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <PropertyDefinitions>k__BackingField;
    public IEnumerable`1<PatternDefinition> GroupPatterns { get; }
    internal PatternExpression[] GroupExpressions { get; }
    public IEnumerable`1<PatternDefinition> PathPatterns { get; }
    internal PatternExpression[] PathExpressions { get; }
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> PropertyDefinitions { get; public set; }
    public PatternSet(IReadOnlyDictionary`2<string, ContentPropertyDefinition> properties, IEnumerable`1<PatternDefinition> groupPatterns, IEnumerable`1<PatternDefinition> pathPatterns);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PatternDefinition> get_GroupPatterns();
    [CompilerGeneratedAttribute]
internal PatternExpression[] get_GroupExpressions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PatternDefinition> get_PathPatterns();
    [CompilerGeneratedAttribute]
internal PatternExpression[] get_PathExpressions();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_PropertyDefinitions();
    [CompilerGeneratedAttribute]
public void set_PropertyDefinitions(IReadOnlyDictionary`2<string, ContentPropertyDefinition> value);
}
internal class NuGet.ContentModel.PatternTable : object {
    private Dictionary`2<string, Dictionary`2<string, object>> _table;
    public PatternTable(IEnumerable`1<PatternTableEntry> entries);
    public bool TryLookup(string propertyName, string name, Object& value);
}
internal class NuGet.ContentModel.PatternTableEntry : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string PropertyName { get; }
    public string Name { get; }
    public object Value { get; }
    public PatternTableEntry(string propertyName, string name, object value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
}
internal class NuGet.ContentModel.SelectionCriteria : object {
    [CompilerGeneratedAttribute]
private IList`1<SelectionCriteriaEntry> <Entries>k__BackingField;
    public IList`1<SelectionCriteriaEntry> Entries { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<SelectionCriteriaEntry> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(IList`1<SelectionCriteriaEntry> value);
}
internal class NuGet.ContentModel.SelectionCriteriaBuilder : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionCriteria <Criteria>k__BackingField;
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> Properties { get; }
    public SelectionCriteria Criteria { get; }
    public SelectionCriteriaEntryBuilder Add { get; }
    public SelectionCriteriaBuilder(IReadOnlyDictionary`2<string, ContentPropertyDefinition> properties);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
public virtual SelectionCriteria get_Criteria();
    public virtual SelectionCriteriaEntryBuilder get_Add();
}
internal class NuGet.ContentModel.SelectionCriteriaEntry : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public IDictionary`2<string, object> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
}
[DefaultMemberAttribute("Item")]
internal class NuGet.ContentModel.SelectionCriteriaEntryBuilder : SelectionCriteriaBuilder {
    [CompilerGeneratedAttribute]
private SelectionCriteriaEntry <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionCriteriaBuilder <Builder>k__BackingField;
    public SelectionCriteriaEntry Entry { get; }
    public SelectionCriteriaBuilder Builder { get; }
    public SelectionCriteriaEntryBuilder Item { get; }
    public SelectionCriteriaEntryBuilder Item { get; }
    public SelectionCriteriaEntryBuilder Add { get; }
    public SelectionCriteria Criteria { get; }
    internal SelectionCriteriaEntryBuilder(SelectionCriteriaBuilder builder, SelectionCriteriaEntry entry);
    [CompilerGeneratedAttribute]
public SelectionCriteriaEntry get_Entry();
    [CompilerGeneratedAttribute]
public SelectionCriteriaBuilder get_Builder();
    public SelectionCriteriaEntryBuilder get_Item(string key, string value);
    public SelectionCriteriaEntryBuilder get_Item(string key, object value);
    public virtual SelectionCriteriaEntryBuilder get_Add();
    public virtual SelectionCriteria get_Criteria();
}
internal class NuGet.Credentials.CredentialResponse : object {
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private CredentialStatus <Status>k__BackingField;
    public ICredentials Credentials { get; }
    public CredentialStatus Status { get; }
    public CredentialResponse(CredentialStatus status);
    public CredentialResponse(ICredentials credentials);
    private CredentialResponse(ICredentials credentials, CredentialStatus status);
    [CompilerGeneratedAttribute]
public ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public CredentialStatus get_Status();
}
internal static class NuGet.Credentials.CredentialsConstants : object {
    public static int ProviderTimeoutSecondsDefault;
    public static string ProviderTimeoutSecondsEnvar;
    public static string ProviderTimeoutSecondsSetting;
    private static CredentialsConstants();
}
[NuGet.Credentials.NullableContextAttribute("1")]
[NuGet.Credentials.NullableAttribute("0")]
internal class NuGet.Credentials.CredentialService : object {
    private ConcurrentDictionary`2<string, bool> _retryCache;
    private ConcurrentDictionary`2<string, CredentialResponse> _providerCredentialCache;
    private bool _nonInteractive;
    private static Semaphore ProviderSemaphore;
    [CompilerGeneratedAttribute]
private bool <HandlesDefaultCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncLazy`1<IEnumerable`1<ICredentialProvider>> <_providers>k__BackingField;
    public bool HandlesDefaultCredentials { get; }
    private AsyncLazy`1<IEnumerable`1<ICredentialProvider>> _providers { get; }
    public CredentialService(AsyncLazy`1<IEnumerable`1<ICredentialProvider>> providers, bool nonInteractive, bool handlesDefaultCredentials);
    private static CredentialService();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HandlesDefaultCredentials();
    [AsyncStateMachineAttribute("NuGet.Credentials.CredentialService/<GetCredentialsAsync>d__8")]
public sealed virtual Task`1<ICredentials> GetCredentialsAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, CancellationToken cancellationToken);
    public sealed virtual bool TryGetLastKnownGoodCredentialsFromCache(Uri uri, bool isProxy, ICredentials& credentials);
    [CompilerGeneratedAttribute]
private AsyncLazy`1<IEnumerable`1<ICredentialProvider>> get__providers();
    private bool TryFromCredentialCache(Uri uri, CredentialRequestType type, bool isRetry, ICredentialProvider provider, CredentialResponse& credentials);
    private void AddToCredentialCache(Uri uri, CredentialRequestType type, ICredentialProvider provider, CredentialResponse credentials);
    private static string RetryCacheKey(Uri uri, CredentialRequestType type, ICredentialProvider provider);
    private static string CredentialCacheKey(Uri uri, CredentialRequestType type, ICredentialProvider provider);
    private static Uri GetRootUri(Uri uri);
    private static string GetUriKey(Uri uri, CredentialRequestType type, ICredentialProvider provider);
}
internal enum NuGet.Credentials.CredentialStatus : Enum {
    public int value__;
    public static CredentialStatus Success;
    public static CredentialStatus ProviderNotApplicable;
    public static CredentialStatus UserCanceled;
}
internal static class NuGet.Credentials.DefaultCredentialServiceUtility : object {
    private static DelegatingLogger DelegatingLogger;
    public static void SetupDefaultCredentialService(ILogger logger, bool nonInteractive);
    public static void UpdateCredentialServiceDelegatingLogger(ILogger log);
    [AsyncStateMachineAttribute("NuGet.Credentials.DefaultCredentialServiceUtility/<GetCredentialProvidersAsync>d__3")]
private static Task`1<IEnumerable`1<ICredentialProvider>> GetCredentialProvidersAsync(ILogger logger);
}
internal class NuGet.Credentials.DefaultNetworkCredentialsCredentialProvider : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual Task`1<CredentialResponse> GetAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, bool isRetry, bool nonInteractive, CancellationToken cancellationToken);
}
internal class NuGet.Credentials.DelegatingLogger : LoggerBase {
    private SemaphoreSlim _semaphore;
    private ILogger _delegateLogger;
    private bool _disposed;
    internal DelegatingLogger(ILogger delegateLogger);
    internal void UpdateDelegate(ILogger logger);
    public virtual void Log(ILogMessage message);
    [AsyncStateMachineAttribute("NuGet.Credentials.DelegatingLogger/<LogAsync>d__6")]
public virtual Task LogAsync(ILogMessage message);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal interface NuGet.Credentials.ICredentialProvider {
    public string Id { get; }
    public abstract virtual string get_Id();
    public abstract virtual Task`1<CredentialResponse> GetAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, bool isRetry, bool nonInteractive, CancellationToken cancellationToken);
}
internal class NuGet.Credentials.PluginCredentialProvider : object {
    private ILogger _logger;
    private string _verbosity;
    private static string NormalVerbosity;
    private static string CrossPlatformPluginLink;
    private int _deprecationMessageWarningLogged;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeoutSeconds>k__BackingField;
    public string Id { get; }
    public string Path { get; }
    public int TimeoutSeconds { get; }
    public PluginCredentialProvider(ILogger logger, string path, int timeoutSeconds, string verbosity);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    public sealed virtual Task`1<CredentialResponse> GetAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, bool isRetry, bool nonInteractive, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public int get_TimeoutSeconds();
    private PluginCredentialResponse GetPluginResponse(PluginCredentialRequest request, CancellationToken cancellationToken);
    public virtual int Execute(ProcessStartInfo startInfo, CancellationToken cancellationToken, String& stdOut);
    private bool PassVerbosityFlag(PluginCredentialRequest request);
    private static void Kill(Process p);
}
internal class NuGet.Credentials.PluginCredentialProviderBuilder : object {
    private ISettings _settings;
    private IEnvironmentVariableReader _envarReader;
    private IExtensionLocator _extensionLocator;
    private ILogger _logger;
    private int TimeoutSeconds { get; }
    public PluginCredentialProviderBuilder(IExtensionLocator extensionLocator, ISettings settings, ILogger logger);
    public PluginCredentialProviderBuilder(IExtensionLocator extensionLocator, ISettings settings, ILogger logger, IEnvironmentVariableReader envarReader);
    public IEnumerable`1<ICredentialProvider> BuildAll(string verbosity);
    private int get_TimeoutSeconds();
}
internal class NuGet.Credentials.PluginCredentialRequest : object {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Verbosity>k__BackingField;
    public string Uri { get; public set; }
    public bool NonInteractive { get; public set; }
    public bool IsRetry { get; public set; }
    public string Verbosity { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(string value);
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_NonInteractive(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public string get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(string value);
}
internal class NuGet.Credentials.PluginCredentialResponse : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <AuthTypes>k__BackingField;
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Message { get; public set; }
    public IList`1<string> AuthTypes { get; public set; }
    public bool IsValid { get; }
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_AuthTypes();
    [CompilerGeneratedAttribute]
public void set_AuthTypes(IList`1<string> value);
    public bool get_IsValid();
}
internal enum NuGet.Credentials.PluginCredentialResponseExitCode : Enum {
    public int value__;
    public static PluginCredentialResponseExitCode Success;
    public static PluginCredentialResponseExitCode ProviderNotApplicable;
    public static PluginCredentialResponseExitCode Failure;
}
internal class NuGet.Credentials.PluginException : Exception {
    private static string RedactedPassword;
    public PluginException(string message);
    public PluginException(string message, Exception inner);
    protected PluginException(SerializationInfo info, StreamingContext context);
    public static PluginException Create(string path, Exception inner);
    public static PluginException CreateTimeoutMessage(string path, int timeoutMillis);
    public static PluginException CreateNotStartedMessage(string path);
    public static PluginException CreatePathNotFoundMessage(string path, string attempted);
    public static PluginException CreateAbortMessage(string path, string message);
    public static PluginException CreateUnreadableResponseExceptionMessage(string path, PluginCredentialResponseExitCode status);
    public static PluginException CreateInvalidResponseExceptionMessage(string path, PluginCredentialResponseExitCode status, PluginCredentialResponse response);
}
internal class NuGet.Credentials.PluginUnexpectedStatusException : PluginException {
    public PluginUnexpectedStatusException(string message);
    public PluginUnexpectedStatusException(string message, Exception inner);
    protected PluginUnexpectedStatusException(SerializationInfo info, StreamingContext context);
    public static PluginException CreateUnexpectedStatusMessage(string path, PluginCredentialResponseExitCode status);
}
internal static class NuGet.Credentials.PreviewFeatureSettings : object {
    public static string DefaultCredentialsAfterCredentialProvidersEnvironmentVariableName;
    [CompilerGeneratedAttribute]
private static bool <DefaultCredentialsAfterCredentialProviders>k__BackingField;
    public static bool DefaultCredentialsAfterCredentialProviders { get; public set; }
    private static PreviewFeatureSettings();
    [CompilerGeneratedAttribute]
public static bool get_DefaultCredentialsAfterCredentialProviders();
    [CompilerGeneratedAttribute]
public static void set_DefaultCredentialsAfterCredentialProviders(bool value);
    private static bool GetFlagFromEnvironmentVariable(string variableName);
}
internal class NuGet.Credentials.ProviderException : Exception {
    public ProviderException(string message);
    public ProviderException(string message, Exception inner);
    protected ProviderException(SerializationInfo info, StreamingContext context);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Credentials.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string PluginException_Abort_Format { get; }
    internal static string PluginException_Exception_Format { get; }
    internal static string PluginException_InvalidResponse_Format { get; }
    internal static string PluginException_NotStarted_Format { get; }
    internal static string PluginException_PathNotFound_Format { get; }
    internal static string PluginException_Timeout_Format { get; }
    internal static string PluginException_UnexpectedStatus_Format { get; }
    internal static string PluginException_UnreadableResponse_Format { get; }
    internal static string PluginWarning_PluginIsBeingDeprecated { get; }
    internal static string ProviderException_InvalidCredentialResponse { get; }
    internal static string ProviderException_MalformedResponse { get; }
    internal static string SecurePluginNotice_UsingPluginAsProvider { get; }
    internal static string SecurePluginWarning_UseInteractiveOption { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_PluginException_Abort_Format();
    internal static string get_PluginException_Exception_Format();
    internal static string get_PluginException_InvalidResponse_Format();
    internal static string get_PluginException_NotStarted_Format();
    internal static string get_PluginException_PathNotFound_Format();
    internal static string get_PluginException_Timeout_Format();
    internal static string get_PluginException_UnexpectedStatus_Format();
    internal static string get_PluginException_UnreadableResponse_Format();
    internal static string get_PluginWarning_PluginIsBeingDeprecated();
    internal static string get_ProviderException_InvalidCredentialResponse();
    internal static string get_ProviderException_MalformedResponse();
    internal static string get_SecurePluginNotice_UsingPluginAsProvider();
    internal static string get_SecurePluginWarning_UseInteractiveOption();
}
internal class NuGet.Credentials.SecurePluginCredentialProvider : object {
    private static string _basicAuthenticationType;
    private PluginDiscoveryResult _discoveredPlugin;
    private ILogger _logger;
    private IPluginManager _pluginManager;
    private bool _canShowDialog;
    private bool _isAnAuthenticationPlugin;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    public SecurePluginCredentialProvider(IPluginManager pluginManager, PluginDiscoveryResult pluginDiscoveryResult, bool canShowDialog, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [AsyncStateMachineAttribute("NuGet.Credentials.SecurePluginCredentialProvider/<GetAsync>d__10")]
public sealed virtual Task`1<CredentialResponse> GetAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, bool isRetry, bool nonInteractive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Credentials.SecurePluginCredentialProvider/<SetPluginLogLevelAsync>d__11")]
private Task SetPluginLogLevelAsync(PluginCreationResult plugin, ILogger logger, CancellationToken cancellationToken);
    private void AddOrUpdateLogger(IPlugin plugin);
    [AsyncStateMachineAttribute("NuGet.Credentials.SecurePluginCredentialProvider/<SetProxyCredentialsToPlugin>d__13")]
private Task SetProxyCredentialsToPlugin(Uri uri, IWebProxy proxy, PluginCreationResult plugin, CancellationToken cancellationToken);
    private static CredentialResponse GetAuthenticationCredentialsResponseToCredentialResponse(GetAuthenticationCredentialsResponse credentialResponse);
    [CompilerGeneratedAttribute]
private IRequestHandler <AddOrUpdateLogger>b__12_0();
    [CompilerGeneratedAttribute]
private IRequestHandler <AddOrUpdateLogger>b__12_1(IRequestHandler existingHandler);
}
internal class NuGet.Credentials.SecurePluginCredentialProviderBuilder : object {
    private ILogger _logger;
    private IPluginManager _pluginManager;
    private bool _canShowDialog;
    public SecurePluginCredentialProviderBuilder(IPluginManager pluginManager, bool canShowDialog, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Credentials.SecurePluginCredentialProviderBuilder/<BuildAllAsync>d__4")]
public Task`1<IEnumerable`1<ICredentialProvider>> BuildAllAsync();
}
internal class NuGet.DependencyResolver.AnalyzeResult`1 : object {
    [CompilerGeneratedAttribute]
private List`1<DowngradeResult`1<TItem>> <Downgrades>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<VersionConflictResult`1<TItem>> <VersionConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<GraphNode`1<TItem>> <Cycles>k__BackingField;
    public List`1<DowngradeResult`1<TItem>> Downgrades { get; }
    public List`1<VersionConflictResult`1<TItem>> VersionConflicts { get; }
    public List`1<GraphNode`1<TItem>> Cycles { get; }
    [CompilerGeneratedAttribute]
public List`1<DowngradeResult`1<TItem>> get_Downgrades();
    [CompilerGeneratedAttribute]
public List`1<VersionConflictResult`1<TItem>> get_VersionConflicts();
    [CompilerGeneratedAttribute]
public List`1<GraphNode`1<TItem>> get_Cycles();
    public void Combine(AnalyzeResult`1<TItem> result);
}
internal enum NuGet.DependencyResolver.Disposition : Enum {
    public int value__;
    public static Disposition Acceptable;
    public static Disposition Rejected;
    public static Disposition Accepted;
    public static Disposition PotentiallyDowngraded;
    public static Disposition Cycle;
}
internal class NuGet.DependencyResolver.DowngradeResult`1 : object {
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <DowngradedFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <DowngradedTo>k__BackingField;
    public GraphNode`1<TItem> DowngradedFrom { get; public set; }
    public GraphNode`1<TItem> DowngradedTo { get; public set; }
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_DowngradedFrom();
    [CompilerGeneratedAttribute]
public void set_DowngradedFrom(GraphNode`1<TItem> value);
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_DowngradedTo();
    [CompilerGeneratedAttribute]
public void set_DowngradedTo(GraphNode`1<TItem> value);
}
internal class NuGet.DependencyResolver.GraphEdge`1 : object {
    [CompilerGeneratedAttribute]
private GraphEdge`1<TItem> <OuterEdge>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphItem`1<TItem> <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDependency <Edge>k__BackingField;
    public GraphEdge`1<TItem> OuterEdge { get; }
    public GraphItem`1<TItem> Item { get; }
    public LibraryDependency Edge { get; }
    public GraphEdge`1(GraphEdge`1<TItem> outerEdge, GraphItem`1<TItem> item, LibraryDependency edge);
    [CompilerGeneratedAttribute]
public GraphEdge`1<TItem> get_OuterEdge();
    [CompilerGeneratedAttribute]
public GraphItem`1<TItem> get_Item();
    [CompilerGeneratedAttribute]
public LibraryDependency get_Edge();
}
[DebuggerDisplayAttribute("{Key}")]
internal class NuGet.DependencyResolver.GraphItem`1 : object {
    [CompilerGeneratedAttribute]
private LibraryIdentity <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TItem <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCentralTransitive>k__BackingField;
    public LibraryIdentity Key { get; public set; }
    public TItem Data { get; public set; }
    public bool IsCentralTransitive { get; public set; }
    public GraphItem`1(LibraryIdentity key);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(LibraryIdentity value);
    [CompilerGeneratedAttribute]
public TItem get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(TItem value);
    [CompilerGeneratedAttribute]
public bool get_IsCentralTransitive();
    [CompilerGeneratedAttribute]
public void set_IsCentralTransitive(bool value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GraphItem`1<TItem> other);
    public virtual int GetHashCode();
    private bool KeyCompare(GraphItem`1<TItem> other);
}
internal class NuGet.DependencyResolver.GraphItemKeyComparer`1 : object {
    private static Lazy`1<GraphItemKeyComparer`1<T>> DefaultComparer;
    public static GraphItemKeyComparer`1<T> Instance { get; }
    private static GraphItemKeyComparer`1();
    public static GraphItemKeyComparer`1<T> get_Instance();
    public sealed virtual bool Equals(GraphItem`1<T> x, GraphItem`1<T> y);
    public sealed virtual int GetHashCode(GraphItem`1<T> obj);
}
internal class NuGet.DependencyResolver.GraphNode`1 : object {
    internal static IList`1<GraphNode`1<TItem>> EmptyList;
    [CompilerGeneratedAttribute]
private LibraryRange <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphItem`1<TItem> <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <OuterNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<GraphNode`1<TItem>> <InnerNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private Disposition <Disposition>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<GraphNode`1<TItem>> <ParentNodes>k__BackingField;
    public LibraryRange Key { get; public set; }
    public GraphItem`1<TItem> Item { get; public set; }
    public GraphNode`1<TItem> OuterNode { get; public set; }
    public IList`1<GraphNode`1<TItem>> InnerNodes { get; public set; }
    public Disposition Disposition { get; public set; }
    public IList`1<GraphNode`1<TItem>> ParentNodes { get; }
    public GraphNode`1(LibraryRange key);
    internal GraphNode`1(LibraryRange key, bool hasInnerNodes, bool hasParentNodes);
    private static GraphNode`1();
    [CompilerGeneratedAttribute]
public LibraryRange get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(LibraryRange value);
    [CompilerGeneratedAttribute]
public GraphItem`1<TItem> get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(GraphItem`1<TItem> value);
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_OuterNode();
    [CompilerGeneratedAttribute]
public void set_OuterNode(GraphNode`1<TItem> value);
    [CompilerGeneratedAttribute]
public IList`1<GraphNode`1<TItem>> get_InnerNodes();
    [CompilerGeneratedAttribute]
public void set_InnerNodes(IList`1<GraphNode`1<TItem>> value);
    [CompilerGeneratedAttribute]
public Disposition get_Disposition();
    [CompilerGeneratedAttribute]
public void set_Disposition(Disposition value);
    [CompilerGeneratedAttribute]
public IList`1<GraphNode`1<TItem>> get_ParentNodes();
    internal bool AreAllParentsRejected();
    internal void EnsureInnerNodeCapacity(int additionalSpace);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class NuGet.DependencyResolver.GraphOperations : object {
    private static string NodeArrow;
    [ThreadStaticAttribute]
private static Dictionary`2<GraphNode`1<RemoteResolveResult>, GraphNode`1<RemoteResolveResult>> _tempDowngrades;
    private static char LIGHT_HORIZONTAL;
    private static char LIGHT_VERTICAL_AND_RIGHT;
    [ExtensionAttribute]
public static AnalyzeResult`1<RemoteResolveResult> Analyze(GraphNode`1<RemoteResolveResult> root);
    private static bool IsRelevantDowngrade(DowngradeResult`1<RemoteResolveResult> d);
    [ExtensionAttribute]
private static void CheckCycleAndNearestWins(GraphNode`1<RemoteResolveResult> root, List`1<DowngradeResult`1<RemoteResolveResult>> downgrades, List`1<GraphNode`1<RemoteResolveResult>> cycles);
    private static void WalkTreeCheckCycleAndNearestWins(CyclesAndDowngrades context, GraphNode`1<RemoteResolveResult> node);
    [ExtensionAttribute]
public static string GetPath(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static string GetPathWithLastRange(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static GraphNode`1<TItem> Path(GraphNode`1<TItem> node, String[] path);
    [ExtensionAttribute]
public static string GetIdAndRange(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static string GetIdAndVersionOrRange(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static string GetId(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static NuGetVersion GetVersionOrDefault(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static VersionRange GetVersionRange(GraphNode`1<TItem> node);
    [ExtensionAttribute]
public static bool IsPackage(GraphNode`1<TItem> node);
    [ExtensionAttribute]
private static bool TryResolveConflicts(GraphNode`1<TItem> root, List`1<VersionConflictResult`1<TItem>> versionConflicts);
    private static void WalkTreeDectectConflicts(GraphNode`1<TItem> node, ConflictsAndAccepted`1<TItem> context);
    private static WalkState WalkTreeMarkAmbiguousNodes(GraphNode`1<TItem> node, WalkState state, Tracker`1<TItem> context);
    private static bool WalkTreeRejectNodesOfRejectedNodes(bool state, GraphNode`1<TItem> node, Tracker`1<TItem> context);
    private static bool WalkTreeAcceptOrRejectNodes(TrackerAndAccepted`1<TItem> context, bool state, GraphNode`1<TItem> node);
    [ExtensionAttribute]
private static TState ForEachGlobalState(GraphNode`1<TItem> root, TState state, Func`3<GraphNode`1<TItem>, TState, TState> visitor, Func`2<GraphNode`1<TItem>, bool> skipNode);
    [ExtensionAttribute]
private static void ForEach(GraphNode`1<TItem> root, TState state, Func`4<GraphNode`1<TItem>, TState, TContext, TState> visitor, TContext context, Func`2<GraphNode`1<TItem>, bool> skipNode);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<GraphNode`1<TItem>> roots, Action`1<GraphNode`1<TItem>> visitor);
    [ExtensionAttribute]
private static void ForEach(GraphNode`1<TItem> root, Action`1<GraphNode`1<TItem>> visitor, Func`2<GraphNode`1<TItem>, bool> skipNode);
    [ExtensionAttribute]
public static void ForEach(GraphNode`1<TItem> root, Action`1<GraphNode`1<TItem>> visitor);
    [ExtensionAttribute]
private static void ForEach(GraphNode`1<TItem> root, Action`2<GraphNode`1<TItem>, TContext> visitor, TContext context, Func`2<GraphNode`1<TItem>, bool> skipNode);
    [ExtensionAttribute]
public static void ForEach(GraphNode`1<TItem> root, Action`2<GraphNode`1<TItem>, TContext> visitor, TContext context);
    private static void AddInnerNodesToQueue(IList`1<GraphNode`1<TItem>> innerNodes, Queue`1<NodeWithState`2<TItem, TState>> queue, TState innerState);
    private static void AddInnerNodesToQueue(IList`1<GraphNode`1<TItem>> innerNodes, Queue`1<GraphNode`1<TItem>> queue);
    public static Dictionary`2<GraphNode`1<RemoteResolveResult>, GraphNode`1<RemoteResolveResult>> RentDowngradesDictionary();
    public static void ReleaseDowngradesDictionary(Dictionary`2<GraphNode`1<RemoteResolveResult>, GraphNode`1<RemoteResolveResult>> dictionary);
    private static ConflictsAndAccepted`1<TItem> CreateState(List`1<VersionConflictResult`1<TItem>> versionConflicts, Dictionary`2<string, GraphNode`1<TItem>> acceptedLibraries);
    private static TrackerAndAccepted`1<TItem> CreateState(Tracker`1<TItem> tracker, Dictionary`2<string, GraphNode`1<TItem>> acceptedLibraries);
    private static CyclesAndDowngrades CreateState(List`1<GraphNode`1<RemoteResolveResult>> cycles, Dictionary`2<GraphNode`1<RemoteResolveResult>, GraphNode`1<RemoteResolveResult>> downgrades);
    private static void DetectAndMarkAmbiguousCentralTransitiveDependencies(Tracker`1<TItem> tracker, List`1<GraphNode`1<TItem>> centralTransitiveNodes);
    [ExtensionAttribute]
private static void RejectCentralTransitiveBecauseOfRejectedParents(GraphNode`1<TItem> root, Tracker`1<TItem> tracker, List`1<GraphNode`1<TItem>> centralTransitiveNodes);
    private static bool WalkTreeRejectNodesOfRejectedNodes(bool state, GraphNode`1<TItem> node, HashSet`1<GraphNode`1<TItem>> context);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void Dump(GraphNode`1<TItem> root, Action`1<string> write);
    private static void DumpChildren(GraphNode`1<TItem> root, Action`1<string> write, int level);
    private static void DumpNode(GraphNode`1<TItem> node, Action`1<string> write, int level);
    [CompilerGeneratedAttribute]
internal static bool <IsRelevantDowngrade>g__AreAllParentsAccepted|3_0(DowngradeResult`1<RemoteResolveResult> d);
}
internal interface NuGet.DependencyResolver.IDependencyProvider {
    public abstract virtual bool SupportsType(LibraryDependencyTarget libraryTypeFlag);
    public abstract virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
}
internal interface NuGet.DependencyResolver.IRemoteDependencyProvider {
    public bool IsHttp { get; }
    public PackageSource Source { get; }
    public SourceRepository SourceRepository { get; }
    public abstract virtual bool get_IsHttp();
    public abstract virtual PackageSource get_Source();
    public abstract virtual SourceRepository get_SourceRepository();
    public abstract virtual Task`1<LibraryIdentity> FindLibraryAsync(LibraryRange libraryRange, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<LibraryDependencyInfo> GetDependenciesAsync(LibraryIdentity libraryIdentity, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
}
[IsReadOnlyAttribute]
internal class NuGet.DependencyResolver.LibraryRangeCacheKey : ValueType {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryRange <LibraryRange>k__BackingField;
    public NuGetFramework Framework { get; }
    public LibraryRange LibraryRange { get; }
    public LibraryRangeCacheKey(LibraryRange range, NuGetFramework framework);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public LibraryRange get_LibraryRange();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(LibraryRangeCacheKey other);
    public virtual string ToString();
    public static bool op_Equality(LibraryRangeCacheKey left, LibraryRangeCacheKey right);
    public static bool op_Inequality(LibraryRangeCacheKey left, LibraryRangeCacheKey right);
}
[DefaultMemberAttribute("Item")]
internal class NuGet.DependencyResolver.LightweightList`1 : ValueType {
    private static int Fields;
    private int _expectedCapacity;
    private int _count;
    private T _firstItem;
    private T _secondItem;
    private T _thirdItem;
    private T _fourthItem;
    private T _fifthItem;
    private List`1<T> _additionalItems;
    public int Count { get; }
    public T Item { get; }
    public LightweightList`1(int expectedCapacity);
    [IsReadOnlyAttribute]
public int get_Count();
    [IsReadOnlyAttribute]
public T get_Item(int index);
    public void Add(T task);
    [IsReadOnlyAttribute]
public Enumerator<T> GetEnumerator();
}
internal class NuGet.DependencyResolver.LocalDependencyProvider : object {
    private IDependencyProvider _dependencyProvider;
    [CompilerGeneratedAttribute]
private bool <IsHttp>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceRepository <SourceRepository>k__BackingField;
    public bool IsHttp { get; private set; }
    public PackageSource Source { get; private set; }
    public SourceRepository SourceRepository { get; private set; }
    public LocalDependencyProvider(IDependencyProvider dependencyProvider);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsHttp();
    [CompilerGeneratedAttribute]
private void set_IsHttp(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual PackageSource get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(PackageSource value);
    [CompilerGeneratedAttribute]
public sealed virtual SourceRepository get_SourceRepository();
    [CompilerGeneratedAttribute]
private void set_SourceRepository(SourceRepository value);
    public sealed virtual Task`1<LibraryIdentity> FindLibraryAsync(LibraryRange libraryRange, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual Task`1<LibraryDependencyInfo> GetDependenciesAsync(LibraryIdentity libraryIdentity, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
}
internal class NuGet.DependencyResolver.LocalMatch : RemoteMatch {
    [CompilerGeneratedAttribute]
private Library <LocalLibrary>k__BackingField;
    [CompilerGeneratedAttribute]
private IDependencyProvider <LocalProvider>k__BackingField;
    public Library LocalLibrary { get; public set; }
    public IDependencyProvider LocalProvider { get; public set; }
    [CompilerGeneratedAttribute]
public Library get_LocalLibrary();
    [CompilerGeneratedAttribute]
public void set_LocalLibrary(Library value);
    [CompilerGeneratedAttribute]
public IDependencyProvider get_LocalProvider();
    [CompilerGeneratedAttribute]
public void set_LocalProvider(IDependencyProvider value);
}
internal class NuGet.DependencyResolver.LockFileCacheKey : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public string RuntimeIdentifier { get; }
    public string Name { get; }
    public LockFileCacheKey(NuGetFramework framework, string runtimeIdentifier);
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    public string get_Name();
    public sealed virtual bool Equals(LockFileCacheKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static string GetNameString(string framework, string runtime);
}
internal static class NuGet.DependencyResolver.PackagingUtility : object {
    public static LibraryDependency GetLibraryDependencyFromNuspec(PackageDependency dependency);
}
internal class NuGet.DependencyResolver.RemoteDependencyWalker : object {
    private RemoteWalkContext _context;
    public RemoteDependencyWalker(RemoteWalkContext context);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.RemoteDependencyWalker/<WalkAsync>d__2")]
public Task`1<GraphNode`1<RemoteResolveResult>> WalkAsync(LibraryRange library, NuGetFramework framework, string runtimeIdentifier, RuntimeGraph runtimeGraph, bool recursive);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.RemoteDependencyWalker/<CreateGraphNodeAsync>d__3")]
private ValueTask`1<GraphNode`1<RemoteResolveResult>> CreateGraphNodeAsync(LibraryRange libraryRange, NuGetFramework framework, string runtimeName, RuntimeGraph runtimeGraph, Func`2<LibraryRange, ValueTuple`2<DependencyResult, LibraryDependency>> predicate, GraphEdge`1<RemoteResolveResult> outerEdge, TransitiveCentralPackageVersions transitiveCentralPackageVersions, bool hasParentNodes);
    private static ValueTuple`2<DependencyResult, LibraryDependency> WalkParentsAndCalculateDependencyResult(GraphEdge`1<RemoteResolveResult> graphEdge, LibraryDependency dependency, Func`2<LibraryRange, ValueTuple`2<DependencyResult, LibraryDependency>> rootPredicate);
    private static Func`2<LibraryRange, ValueTuple`2<DependencyResult, LibraryDependency>> ChainPredicate(Func`2<LibraryRange, ValueTuple`2<DependencyResult, LibraryDependency>> predicate, GraphNode`1<RemoteResolveResult> node, LibraryDependency dependency);
    private static ValueTuple`2<Nullable`1<DependencyResult>, LibraryDependency> CalculateDependencyResult(GraphItem`1<RemoteResolveResult> item, LibraryDependency parentDependency, LibraryRange childDependencyLibrary, bool isRoot);
    public static bool IsGreaterThanOrEqualTo(VersionRange nearVersion, VersionRange farVersion);
    private static NuGetVersion GetReleaseLabelFreeVersion(VersionRange versionRange);
    private void MarkCentralVersionForTransitiveProcessing(LibraryDependency libraryDependency, TransitiveCentralPackageVersions transitiveCentralPackageVersions, GraphNode`1<RemoteResolveResult> parentNode);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.RemoteDependencyWalker/<AddTransitiveCentralPackageVersionNodesAsync>d__11")]
private Task`1<GraphNode`1<RemoteResolveResult>> AddTransitiveCentralPackageVersionNodesAsync(GraphNode`1<RemoteResolveResult> rootNode, LibraryDependency centralPackageVersionDependency, NuGetFramework framework, string runtimeIdentifier, RuntimeGraph runtimeGraph, TransitiveCentralPackageVersions transitiveCentralPackageVersions);
    internal bool IsDependencyValidForGraph(LibraryDependency dependency);
    [CompilerGeneratedAttribute]
internal static void <CreateGraphNodeAsync>g__EvaluateRuntimeDependencies|3_0(LibraryRange& libraryRange, string runtimeName, RuntimeGraph runtimeGraph, HashSet`1& runtimeDependencies);
    [CompilerGeneratedAttribute]
internal static void <CreateGraphNodeAsync>g__MergeRuntimeDependencies|3_1(HashSet`1<LibraryDependency> runtimeDependencies, GraphNode`1<RemoteResolveResult> node);
}
internal class NuGet.DependencyResolver.RemoteMatch : object {
    [CompilerGeneratedAttribute]
private IRemoteDependencyProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIdentity <Library>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public IRemoteDependencyProvider Provider { get; public set; }
    public LibraryIdentity Library { get; public set; }
    public string Path { get; public set; }
    [CompilerGeneratedAttribute]
public IRemoteDependencyProvider get_Provider();
    [CompilerGeneratedAttribute]
public void set_Provider(IRemoteDependencyProvider value);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Library();
    [CompilerGeneratedAttribute]
public void set_Library(LibraryIdentity value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RemoteMatch other);
    public virtual int GetHashCode();
}
internal class NuGet.DependencyResolver.RemoteResolveResult : object {
    internal static List`1<LibraryDependency> EmptyDependencies;
    [CompilerGeneratedAttribute]
private RemoteMatch <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LibraryDependency> <Dependencies>k__BackingField;
    public RemoteMatch Match { get; public set; }
    public List`1<LibraryDependency> Dependencies { get; public set; }
    private static RemoteResolveResult();
    [CompilerGeneratedAttribute]
public RemoteMatch get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(RemoteMatch value);
    [CompilerGeneratedAttribute]
public List`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(List`1<LibraryDependency> value);
}
internal class NuGet.DependencyResolver.RemoteWalkContext : object {
    [CompilerGeneratedAttribute]
private SourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDependencyProvider> <ProjectLibraryProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IRemoteDependencyProvider> <LocalLibraryProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IRemoteDependencyProvider> <RemoteLibraryProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceMapping <PackageSourceMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<LockFileCacheKey, IList`1<LibraryIdentity>> <LockFileLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGet.DependencyResolver.Core818074.TaskResultCache`2<LibraryRangeCacheKey, GraphItem`1<RemoteResolveResult>> <FindLibraryEntryCache>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGet.DependencyResolver.Core818074.TaskResultCache`2<LibraryRange, Tuple`2<LibraryRange, RemoteMatch>> <ResolvePackageLibraryMatchCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMsBuildBased>k__BackingField;
    public SourceCacheContext CacheContext { get; }
    public ILogger Logger { get; }
    public IList`1<IDependencyProvider> ProjectLibraryProviders { get; }
    public IList`1<IRemoteDependencyProvider> LocalLibraryProviders { get; }
    public IList`1<IRemoteDependencyProvider> RemoteLibraryProviders { get; }
    public PackageSourceMapping PackageSourceMapping { get; }
    public IDictionary`2<LockFileCacheKey, IList`1<LibraryIdentity>> LockFileLibraries { get; }
    internal NuGet.DependencyResolver.Core818074.TaskResultCache`2<LibraryRangeCacheKey, GraphItem`1<RemoteResolveResult>> FindLibraryEntryCache { get; }
    internal NuGet.DependencyResolver.Core818074.TaskResultCache`2<LibraryRange, Tuple`2<LibraryRange, RemoteMatch>> ResolvePackageLibraryMatchCache { get; }
    public bool IsMsBuildBased { get; public set; }
    public RemoteWalkContext(SourceCacheContext cacheContext, PackageSourceMapping packageSourceMapping, ILogger logger);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public IList`1<IDependencyProvider> get_ProjectLibraryProviders();
    [CompilerGeneratedAttribute]
public IList`1<IRemoteDependencyProvider> get_LocalLibraryProviders();
    [CompilerGeneratedAttribute]
public IList`1<IRemoteDependencyProvider> get_RemoteLibraryProviders();
    [CompilerGeneratedAttribute]
public PackageSourceMapping get_PackageSourceMapping();
    [CompilerGeneratedAttribute]
public IDictionary`2<LockFileCacheKey, IList`1<LibraryIdentity>> get_LockFileLibraries();
    [CompilerGeneratedAttribute]
internal NuGet.DependencyResolver.Core818074.TaskResultCache`2<LibraryRangeCacheKey, GraphItem`1<RemoteResolveResult>> get_FindLibraryEntryCache();
    [CompilerGeneratedAttribute]
internal NuGet.DependencyResolver.Core818074.TaskResultCache`2<LibraryRange, Tuple`2<LibraryRange, RemoteMatch>> get_ResolvePackageLibraryMatchCache();
    [CompilerGeneratedAttribute]
public bool get_IsMsBuildBased();
    [CompilerGeneratedAttribute]
public void set_IsMsBuildBased(bool value);
    public IList`1<IRemoteDependencyProvider> FilterDependencyProvidersForLibrary(LibraryRange libraryRange);
}
internal static class NuGet.DependencyResolver.ResolverUtility : object {
    public static Task`1<GraphItem`1<RemoteResolveResult>> FindLibraryCachedAsync(LibraryRange libraryRange, NuGetFramework framework, string runtimeIdentifier, RemoteWalkContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindLibraryEntryAsync>d__1")]
public static Task`1<GraphItem`1<RemoteResolveResult>> FindLibraryEntryAsync(LibraryRange libraryRange, NuGetFramework framework, string runtimeIdentifier, RemoteWalkContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<CreateGraphItemAsync>d__2")]
private static Task`1<GraphItem`1<RemoteResolveResult>> CreateGraphItemAsync(RemoteMatch match, NuGetFramework framework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindLibraryMatchAsync>d__3")]
public static Task`1<RemoteMatch> FindLibraryMatchAsync(LibraryRange libraryRange, NuGetFramework framework, string runtimeIdentifier, IEnumerable`1<IRemoteDependencyProvider> remoteProviders, IEnumerable`1<IRemoteDependencyProvider> localProviders, IEnumerable`1<IDependencyProvider> projectProviders, IDictionary`2<LockFileCacheKey, IList`1<LibraryIdentity>> lockFileLibraries, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public static Task`1<Tuple`2<LibraryRange, RemoteMatch>> FindPackageLibraryMatchCachedAsync(LibraryRange libraryRange, RemoteWalkContext remoteWalkContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<ResolvePackageLibraryMatchAsync>d__5")]
private static Task`1<Tuple`2<LibraryRange, RemoteMatch>> ResolvePackageLibraryMatchAsync(LibraryRange libraryRange, RemoteWalkContext remoteWalkContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindPackageLibraryMatchAsync>d__6")]
private static Task`1<RemoteMatch> FindPackageLibraryMatchAsync(LibraryRange libraryRange, NuGetFramework framework, IEnumerable`1<IRemoteDependencyProvider> remoteProviders, IEnumerable`1<IRemoteDependencyProvider> localProviders, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public static Task`1<RemoteMatch> FindProjectMatchAsync(LibraryRange libraryRange, NuGetFramework framework, IEnumerable`1<IDependencyProvider> projectProviders, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindLibraryByVersionAsync>d__8")]
public static Task`1<RemoteMatch> FindLibraryByVersionAsync(LibraryRange libraryRange, NuGetFramework framework, IEnumerable`1<IRemoteDependencyProvider> providers, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<FindLibraryFromSourcesAsync>d__9")]
private static Task`1<RemoteMatch> FindLibraryFromSourcesAsync(LibraryRange libraryRange, IEnumerable`1<IRemoteDependencyProvider> providers, NuGetFramework framework, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    private static GraphItem`1<RemoteResolveResult> CreateUnresolvedResult(LibraryRange libraryRange);
    private static RemoteMatch CreateUnresolvedMatch(LibraryRange libraryRange);
    private static void LogIfPackageSourceMappingIsEnabled(string packageName, RemoteWalkContext context, IList`1<IRemoteDependencyProvider> remoteDependencyProviders);
    [AsyncStateMachineAttribute("NuGet.DependencyResolver.ResolverUtility/<<FindLibraryFromSourcesAsync>g__FindLibraryFromProviderAsync|9_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<RemoteMatch> <FindLibraryFromSourcesAsync>g__FindLibraryFromProviderAsync|9_0(IRemoteDependencyProvider provider, LibraryRange libraryRange, NuGetFramework framework, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.DependencyResolver.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Error_PackageNotFoundWhenExpected { get; }
    internal static string Log_MatchingSourceFoundForPackage { get; }
    internal static string Log_NoMatchingSourceFoundForPackage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Error_PackageNotFoundWhenExpected();
    internal static string get_Log_MatchingSourceFoundForPackage();
    internal static string get_Log_NoMatchingSourceFoundForPackage();
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
internal class NuGet.DependencyResolver.Tracker`1 : object {
    [NuGet.DependencyResolver.Core.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, Entry<TItem>> _entryByLibraryName;
    public void Track(GraphItem`1<TItem> item);
    public bool IsDisputed(GraphItem`1<TItem> item);
    public bool IsAmbiguous(GraphItem`1<TItem> item);
    public void MarkAmbiguous(GraphItem`1<TItem> item);
    public bool IsBestVersion(GraphItem`1<TItem> item);
    public IEnumerable`1<GraphItem`1<TItem>> GetDisputes(GraphItem`1<TItem> item);
    internal void Clear();
    private Entry<TItem> TryGetEntry(GraphItem`1<TItem> item);
    private Entry<TItem> GetOrAddEntry(GraphItem`1<TItem> item);
}
internal class NuGet.DependencyResolver.VersionConflictResult`1 : object {
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <Selected>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphNode`1<TItem> <Conflicting>k__BackingField;
    public GraphNode`1<TItem> Selected { get; public set; }
    public GraphNode`1<TItem> Conflicting { get; public set; }
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_Selected();
    [CompilerGeneratedAttribute]
public void set_Selected(GraphNode`1<TItem> value);
    [CompilerGeneratedAttribute]
public GraphNode`1<TItem> get_Conflicting();
    [CompilerGeneratedAttribute]
public void set_Conflicting(GraphNode`1<TItem> value);
}
[CompilerGeneratedAttribute]
internal class NuGet.Frameworks.<PrivateImplementationDetails> : object {
    internal static __StaticArrayInitTypeSize=100 F5B43748C6833FBADDF4E5A7B9940B46CBAAC288E37B8AF1BA1CE3EC174609C5;
    internal static UInt32 ComputeStringHash(string s);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.AssetTargetFallbackFramework : NuGetFramework {
    private Nullable`1<int> _hashCode;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetFramework> <Fallback>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <RootFramework>k__BackingField;
    public IReadOnlyList`1<NuGetFramework> Fallback { get; }
    public NuGetFramework RootFramework { get; }
    public AssetTargetFallbackFramework(NuGetFramework framework, IReadOnlyList`1<NuGetFramework> fallbackFrameworks);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetFramework> get_Fallback();
    [CompilerGeneratedAttribute]
public NuGetFramework get_RootFramework();
    private static NuGetFramework ValidateFrameworkArgument(NuGetFramework framework);
    public FallbackFramework AsFallbackFramework();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(AssetTargetFallbackFramework other);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NuGet.Frameworks.CompatibilityCacheKey : ValueType {
    [CompilerGeneratedAttribute]
private NuGetFramework <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Candidate>k__BackingField;
    private int _hashCode;
    public NuGetFramework Target { get; }
    public NuGetFramework Candidate { get; }
    public CompatibilityCacheKey(NuGetFramework target, NuGetFramework candidate);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Target();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Candidate();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(CompatibilityCacheKey other);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.CompatibilityListProvider : object {
    private IFrameworkNameProvider _nameProvider;
    private IFrameworkCompatibilityProvider _compatibilityProvider;
    private FrameworkReducer _reducer;
    [NuGet.Frameworks.NullableAttribute("2")]
private static IFrameworkCompatibilityListProvider _default;
    public static IFrameworkCompatibilityListProvider Default { get; }
    public CompatibilityListProvider(IFrameworkNameProvider nameProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public sealed virtual IEnumerable`1<NuGetFramework> GetFrameworksSupporting(NuGetFramework target);
    private IEnumerable`1<NuGetFramework> ReduceDownwards(IEnumerable`1<NuGetFramework> frameworks);
    public static IFrameworkCompatibilityListProvider get_Default();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.CompatibilityMappingComparer : object {
    [CompilerGeneratedAttribute]
private static CompatibilityMappingComparer <Instance>k__BackingField;
    public static CompatibilityMappingComparer Instance { get; }
    private static CompatibilityMappingComparer();
    [CompilerGeneratedAttribute]
public static CompatibilityMappingComparer get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(OneWayCompatibilityMappingEntry x, OneWayCompatibilityMappingEntry y);
    public sealed virtual int GetHashCode(OneWayCompatibilityMappingEntry obj);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.CompatibilityProvider : object {
    private IFrameworkNameProvider _mappings;
    private FrameworkExpander _expander;
    private static NuGetFrameworkFullComparer FullComparer;
    private ConcurrentDictionary`2<CompatibilityCacheKey, bool> _cache;
    public CompatibilityProvider(IFrameworkNameProvider mappings);
    private static CompatibilityProvider();
    public sealed virtual bool IsCompatible(NuGetFramework target, NuGetFramework candidate);
    private Nullable`1<bool> IsCompatibleCore(NuGetFramework target, NuGetFramework candidate);
    private Nullable`1<bool> IsSpecialFrameworkCompatible(NuGetFramework target, NuGetFramework candidate);
    private bool IsPCLCompatible(NuGetFramework target, NuGetFramework candidate);
    private bool PCLInnerCompare(IEnumerable`1<NuGetFramework> targetFrameworks, IEnumerable`1<NuGetFramework> candidateFrameworks);
    private bool IsCompatibleWithTarget(NuGetFramework target, NuGetFramework candidate);
    private static bool IsCompatibleWithTargetCore(NuGetFramework target, NuGetFramework candidate);
    private static bool IsVersionCompatible(Version target, Version candidate);
    [IteratorStateMachineAttribute("NuGet.Frameworks.CompatibilityProvider/<GetEquivalentFrameworksClosure>d__13")]
private IEnumerable`1<NuGetFramework> GetEquivalentFrameworksClosure(NuGetFramework framework);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.CompatibilityTable : object {
    private IFrameworkNameProvider _mappings;
    private IFrameworkCompatibilityProvider _compat;
    private Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> _table;
    private FrameworkReducer _reducer;
    public CompatibilityTable(IEnumerable`1<NuGetFramework> frameworks);
    public CompatibilityTable(IEnumerable`1<NuGetFramework> frameworks, IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    public bool HasFramework(NuGetFramework framework);
    public IEnumerable`1<NuGetFramework> GetNearest(NuGetFramework framework);
    public bool TryGetCompatible(NuGetFramework framework, IEnumerable`1& compatible);
    private static Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> GetTable(IEnumerable`1<NuGetFramework> frameworks, IFrameworkCompatibilityProvider compat);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.DefaultCompatibilityProvider : CompatibilityProvider {
    [NuGet.Frameworks.NullableAttribute("2")]
private static IFrameworkCompatibilityProvider _instance;
    public static IFrameworkCompatibilityProvider Instance { get; }
    public static IFrameworkCompatibilityProvider get_Instance();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.DefaultFrameworkMappings : object {
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> IdentifierSynonymsLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> IdentifierShortNamesLazy;
    private static Lazy`1<FrameworkSpecificMapping[]> ProfileShortNamesLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> EquivalentFrameworksLazy;
    private static Lazy`1<FrameworkSpecificMapping[]> EquivalentProfilesLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> SubSetFrameworksLazy;
    private static Lazy`1<OneWayCompatibilityMappingEntry[]> CompatibilityMappingsLazy;
    private static Lazy`1<String[]> NonPackageBasedFrameworkPrecedenceLazy;
    private static Lazy`1<String[]> PackageBasedFrameworkPrecedenceLazy;
    private static Lazy`1<String[]> EquivalentFrameworkPrecedenceLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> ShortNameReplacementsLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> FullNameReplacementsLazy;
    private static Lazy`1<IFrameworkMappings> InstanceLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierSynonyms { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierShortNames { get; }
    public IEnumerable`1<FrameworkSpecificMapping> ProfileShortNames { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> EquivalentFrameworks { get; }
    public IEnumerable`1<FrameworkSpecificMapping> EquivalentProfiles { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> SubSetFrameworks { get; }
    public IEnumerable`1<OneWayCompatibilityMappingEntry> CompatibilityMappings { get; }
    public IEnumerable`1<string> NonPackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> PackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> EquivalentFrameworkPrecedence { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> ShortNameReplacements { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> FullNameReplacements { get; }
    public static IFrameworkMappings Instance { get; }
    private static DefaultFrameworkMappings();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierSynonyms();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierShortNames();
    public sealed virtual IEnumerable`1<FrameworkSpecificMapping> get_ProfileShortNames();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_EquivalentFrameworks();
    public sealed virtual IEnumerable`1<FrameworkSpecificMapping> get_EquivalentProfiles();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_SubSetFrameworks();
    public sealed virtual IEnumerable`1<OneWayCompatibilityMappingEntry> get_CompatibilityMappings();
    private static OneWayCompatibilityMappingEntry CreateGenerationMapping(NuGetFramework framework, NuGetFramework netPlatform);
    private static OneWayCompatibilityMappingEntry CreateStandardMapping(NuGetFramework framework, NuGetFramework netPlatform);
    [IteratorStateMachineAttribute("NuGet.Frameworks.DefaultFrameworkMappings/<CreateGenerationAndStandardMapping>d__23")]
private static IEnumerable`1<OneWayCompatibilityMappingEntry> CreateGenerationAndStandardMapping(NuGetFramework framework, NuGetFramework netPlatform, NuGetFramework netStandard);
    private static IEnumerable`1<OneWayCompatibilityMappingEntry> CreateGenerationAndStandardMappingForAllVersions(string framework, NuGetFramework netPlatform, NuGetFramework netStandard);
    public sealed virtual IEnumerable`1<string> get_NonPackageBasedFrameworkPrecedence();
    public sealed virtual IEnumerable`1<string> get_PackageBasedFrameworkPrecedence();
    public sealed virtual IEnumerable`1<string> get_EquivalentFrameworkPrecedence();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_ShortNameReplacements();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_FullNameReplacements();
    public static IFrameworkMappings get_Instance();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.DefaultFrameworkNameProvider : FrameworkNameProvider {
    private static Lazy`1<IFrameworkNameProvider> InstanceLazy;
    public static IFrameworkNameProvider Instance { get; }
    private static DefaultFrameworkNameProvider();
    public static IFrameworkNameProvider get_Instance();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.DefaultPortableFrameworkMappings : object {
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> ProfileFrameworksLazy;
    private static Int32[] ProfilesWithOptionalFrameworks;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<List`1<KeyValuePair`2<int, NuGetFramework[]>>> ProfileOptionalFrameworksLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> CompatibilityMappingsLazy;
    private static Lazy`1<IPortableFrameworkMappings> InstanceLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public static IPortableFrameworkMappings Instance { get; }
    private static DefaultPortableFrameworkMappings();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    private static KeyValuePair`2<int, NuGetFramework[]> CreateProfileFrameworks(int profile, NuGetFramework[] frameworks);
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
    private static KeyValuePair`2<int, FrameworkRange> CreateStandardMapping(int profileNumber, NuGetFramework netStandard);
    public static IPortableFrameworkMappings get_Instance();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.DualCompatibilityFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private NuGetFramework <RootFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <SecondaryFramework>k__BackingField;
    private Nullable`1<int> _hashCode;
    [NuGet.Frameworks.NullableAttribute("2")]
private FallbackFramework _fallbackFramework;
    public NuGetFramework RootFramework { get; }
    public NuGetFramework SecondaryFramework { get; }
    public DualCompatibilityFramework(NuGetFramework framework, NuGetFramework secondaryFramework);
    [CompilerGeneratedAttribute]
public NuGetFramework get_RootFramework();
    [CompilerGeneratedAttribute]
public NuGetFramework get_SecondaryFramework();
    public FallbackFramework AsFallbackFramework();
    private static NuGetFramework ValidateFrameworkArgument(NuGetFramework framework);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public bool Equals(DualCompatibilityFramework other);
    public virtual int GetHashCode();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FallbackFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetFramework> <Fallback>k__BackingField;
    private Nullable`1<int> _hashCode;
    public IReadOnlyList`1<NuGetFramework> Fallback { get; }
    public FallbackFramework(NuGetFramework framework, IReadOnlyList`1<NuGetFramework> fallbackFrameworks);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetFramework> get_Fallback();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(FallbackFramework other);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal static class NuGet.Frameworks.FrameworkConstants : object {
    public static Version EmptyVersion;
    public static Version MaxVersion;
    public static Version Version5;
    public static Version Version6;
    public static Version Version7;
    public static Version Version8;
    public static Version Version10;
    public static FrameworkRange DotNetAll;
    private static FrameworkConstants();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkException : Exception {
    public FrameworkException(string message);
    protected FrameworkException(SerializationInfo info, StreamingContext context);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkExpander : object {
    private IFrameworkNameProvider _mappings;
    public FrameworkExpander(IFrameworkNameProvider mappings);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkExpander/<Expand>d__3")]
public IEnumerable`1<NuGetFramework> Expand(NuGetFramework framework);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkExpander/<ExpandInternal>d__4")]
private IEnumerable`1<NuGetFramework> ExpandInternal(NuGetFramework framework);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal static class NuGet.Frameworks.FrameworkNameHelpers : object {
    public static string GetPortableProfileNumberString(int profileNumber);
    public static string GetFolderName(string identifierShortName, string versionString, string profileShortName);
    public static string GetVersionString(Version version);
    public static Version GetVersion(string versionString);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkNameProvider : object {
    private static HashSet`1<NuGetFramework> EmptyFrameworkSet;
    private static HashSet`1<string> SingleDigitVersionFrameworks;
    private static HashSet`1<string> DecimalPointFrameworks;
    private Dictionary`2<string, string> _identifierSynonyms;
    private Dictionary`2<string, string> _identifierToShortName;
    private Dictionary`2<string, string> _profilesToShortName;
    private Dictionary`2<string, string> _identifierShortToLong;
    private Dictionary`2<string, string> _profileShortToLong;
    private Dictionary`2<int, HashSet`1<NuGetFramework>> _portableFrameworks;
    private Dictionary`2<int, HashSet`1<NuGetFramework>> _portableOptionalFrameworks;
    private Dictionary`2<int, HashSet`1<FrameworkRange>> _portableCompatibilityMappings;
    private Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> _equivalentFrameworks;
    private Dictionary`2<string, Dictionary`2<string, HashSet`1<string>>> _equivalentProfiles;
    private Dictionary`2<string, HashSet`1<OneWayCompatibilityMappingEntry>> _compatibilityMappings;
    private Dictionary`2<string, HashSet`1<string>> _subSetFrameworks;
    private Dictionary`2<string, int> _nonPackageBasedFrameworkPrecedence;
    private Dictionary`2<string, int> _packageBasedFrameworkPrecedence;
    private Dictionary`2<string, int> _equivalentFrameworkPrecedence;
    private Dictionary`2<NuGetFramework, NuGetFramework> _shortNameRewrites;
    private Dictionary`2<NuGetFramework, NuGetFramework> _fullNameRewrites;
    private List`1<NuGetFramework> _netStandardVersions;
    private List`1<NuGetFramework> _compatibleCandidates;
    public FrameworkNameProvider(IEnumerable`1<IFrameworkMappings> mappings, IEnumerable`1<IPortableFrameworkMappings> portableMappings);
    private static FrameworkNameProvider();
    private static bool TryConvertOrNormalize(string key, IDictionary`2<string, string> mappings, IDictionary`2<string, string> reverse, String& value);
    public sealed virtual bool TryGetIdentifier(string framework, String& identifier);
    public sealed virtual bool TryGetProfile(string frameworkIdentifier, string profileShortName, String& profile);
    public sealed virtual bool TryGetShortIdentifier(string identifier, String& identifierShortName);
    public sealed virtual bool TryGetShortProfile(string frameworkIdentifier, string profile, String& profileShortName);
    public sealed virtual bool TryGetVersion(string versionString, Version& version);
    public sealed virtual bool TryGetPlatformVersion(string versionString, Version& version);
    public sealed virtual string GetVersionString(string framework, Version version);
    public sealed virtual bool TryGetPortableProfile(IEnumerable`1<NuGetFramework> supportedFrameworks, Int32& profileNumber);
    private HashSet`1<NuGetFramework> RemoveDuplicateFramework(IEnumerable`1<NuGetFramework> supportedFrameworks);
    private HashSet`1<NuGetFramework> GetAllEquivalentFrameworks(NuGetFramework framework);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkNameProvider/<GetEquivalentPermutations>d__34")]
private IEnumerable`1<HashSet`1<NuGetFramework>> GetEquivalentPermutations(HashSet`1<NuGetFramework> frameworks);
    private HashSet`1<NuGetFramework> GetOptionalFrameworks(int profile);
    public sealed virtual bool TryGetPortableFrameworks(int profile, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableFrameworks(int profile, bool includeOptional, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableFrameworks(string shortPortableProfiles, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableCompatibilityMappings(int profile, IEnumerable`1& supportedFrameworkRanges);
    public sealed virtual bool TryGetPortableProfileNumber(string profile, Int32& profileNumber);
    public sealed virtual bool TryGetPortableFrameworks(string profile, bool includeOptional, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetEquivalentFrameworks(NuGetFramework framework, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetEquivalentFrameworks(FrameworkRange range, IEnumerable`1& frameworks);
    private void InitMappings(IEnumerable`1<IFrameworkMappings> mappings);
    private void InitPortableMappings(IEnumerable`1<IPortableFrameworkMappings> portableMappings);
    private void InitNetStandard();
    private void AddShortNameRewriteMappings(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddFullNameRewriteMappings(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddCompatibilityMappings(IEnumerable`1<OneWayCompatibilityMappingEntry> mappings);
    private void AddSubSetFrameworks(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddEquivalentProfiles(IEnumerable`1<FrameworkSpecificMapping> mappings);
    private void AddEquivalentFrameworks(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddFrameworkSynonyms(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddIdentifierShortNames(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddProfileShortNames(IEnumerable`1<FrameworkSpecificMapping> mappings);
    private void AddPortableProfileMappings(IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> mappings);
    private void AddPortableOptionalFrameworks(IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> mappings);
    private void AddPortableCompatibilityMappings(IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> mappings);
    public void AddFrameworkPrecedenceMappings(IDictionary`2<string, int> destination, IEnumerable`1<string> mappings);
    public sealed virtual bool TryGetCompatibilityMappings(NuGetFramework framework, IEnumerable`1& supportedFrameworkRanges);
    public sealed virtual bool TryGetSubSetFrameworks(string frameworkIdentifier, IEnumerable`1& subSetFrameworks);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int CompareFrameworks(NuGetFramework x, NuGetFramework y);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int CompareEquivalentFrameworks(NuGetFramework x, NuGetFramework y);
    [NuGet.Frameworks.NullableContextAttribute("2")]
private static int CompareUsingPrecedence(NuGetFramework x, NuGetFramework y, Dictionary`2<string, int> precedence);
    public sealed virtual NuGetFramework GetShortNameReplacement(NuGetFramework framework);
    public sealed virtual NuGetFramework GetFullNameReplacement(NuGetFramework framework);
    public sealed virtual IEnumerable`1<NuGetFramework> GetNetStandardVersions();
    public sealed virtual IEnumerable`1<NuGetFramework> GetCompatibleCandidates();
    private void AddNetStandardVersions();
    private void AddCompatibleCandidates();
    private static bool SetEquals(HashSet`1<NuGetFramework> left, HashSet`1<NuGetFramework> right);
    private static void UnionWith(HashSet`1<NuGetFramework> toAccumulate, HashSet`1<NuGetFramework> toAdd);
    [CompilerGeneratedAttribute]
internal static bool <GetVersionString>g__HasGreaterThanNinePart|30_0(<>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetVersionString>g__IsZero|30_1(Version version);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkPrecedenceSorter : object {
    private IFrameworkNameProvider _mappings;
    private bool _allEquivalent;
    public FrameworkPrecedenceSorter(IFrameworkNameProvider mappings, bool allEquivalent);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int Compare(NuGetFramework x, NuGetFramework y);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkRange : object {
    private bool _includeMin;
    private bool _includeMax;
    [CompilerGeneratedAttribute]
private NuGetFramework <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Max>k__BackingField;
    public NuGetFramework Min { get; }
    public NuGetFramework Max { get; }
    public bool IncludeMin { get; }
    public bool IncludeMax { get; }
    public string FrameworkIdentifier { get; }
    public FrameworkRange(NuGetFramework min, NuGetFramework max);
    public FrameworkRange(NuGetFramework min, NuGetFramework max, bool includeMin, bool includeMax);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Min();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Max();
    public bool get_IncludeMin();
    public bool get_IncludeMax();
    public string get_FrameworkIdentifier();
    public bool Satisfies(NuGetFramework framework);
    private static bool SameExceptForVersion(NuGetFramework x, NuGetFramework y);
    public virtual string ToString();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRange other);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkRangeComparer : object {
    [CompilerGeneratedAttribute]
private static FrameworkRangeComparer <Instance>k__BackingField;
    public static FrameworkRangeComparer Instance { get; }
    private static FrameworkRangeComparer();
    [CompilerGeneratedAttribute]
public static FrameworkRangeComparer get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRange x, FrameworkRange y);
    public sealed virtual int GetHashCode(FrameworkRange obj);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkReducer : object {
    private IFrameworkNameProvider _mappings;
    private IFrameworkCompatibilityProvider _compat;
    public FrameworkReducer(IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    public NuGetFramework GetNearest(NuGetFramework framework, IEnumerable`1<NuGetFramework> possibleFrameworks);
    private NuGetFramework GetNearestInternal(NuGetFramework framework, IEnumerable`1<NuGetFramework> possibleFrameworks);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkReducer/<ReduceEquivalent>d__6")]
public IEnumerable`1<NuGetFramework> ReduceEquivalent(IEnumerable`1<NuGetFramework> frameworks);
    public IEnumerable`1<NuGetFramework> ReduceUpwards(IEnumerable`1<NuGetFramework> frameworks);
    public IEnumerable`1<NuGetFramework> ReduceDownwards(IEnumerable`1<NuGetFramework> frameworks);
    private IEnumerable`1<NuGetFramework> ReduceCore(IEnumerable`1<NuGetFramework> frameworks, Func`3<NuGetFramework, NuGetFramework, bool> isCompat);
    private IEnumerable`1<NuGetFramework> GetNearestNonPCLtoPCL(NuGetFramework framework, IEnumerable`1<NuGetFramework> reduced);
    private IEnumerable`1<NuGetFramework> GetNearestPCLtoPCL(NuGetFramework framework, IEnumerable`1<NuGetFramework> reduced);
    private Dictionary`2<NuGetFramework, IEnumerable`1<NuGetFramework>> ExplodePortableFrameworks(IEnumerable`1<NuGetFramework> pcls);
    private IEnumerable`1<NuGetFramework> ExplodePortableFramework(NuGetFramework pcl, bool includeOptional);
    private NuGetFramework GetBestPCL(IEnumerable`1<NuGetFramework> reduced);
    private bool IsBetterPCL(NuGetFramework current, NuGetFramework considering);
    [CompilerGeneratedAttribute]
private bool <ReduceUpwards>b__7_2(NuGetFramework x, NuGetFramework y);
    [CompilerGeneratedAttribute]
private bool <ReduceDownwards>b__8_1(NuGetFramework x, NuGetFramework y);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkRuntimePair : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public NuGetFramework Framework { get; }
    public string RuntimeIdentifier { get; }
    public string Name { get; }
    public FrameworkRuntimePair(NuGetFramework framework, string runtimeIdentifier);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRuntimePair other);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public FrameworkRuntimePair Clone();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int CompareTo(FrameworkRuntimePair other);
    public static string GetName(NuGetFramework framework, string runtimeIdentifier);
    public static string GetTargetGraphName(NuGetFramework framework, string runtimeIdentifier);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.FrameworkSpecificMapping : object {
    [CompilerGeneratedAttribute]
private string <FrameworkIdentifier>k__BackingField;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private KeyValuePair`2<string, string> <Mapping>k__BackingField;
    public string FrameworkIdentifier { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<string, string> Mapping { get; }
    public FrameworkSpecificMapping(string frameworkIdentifier, string key, string value);
    public FrameworkSpecificMapping(string frameworkIdentifier, KeyValuePair`2<string, string> mapping);
    [CompilerGeneratedAttribute]
public string get_FrameworkIdentifier();
    [CompilerGeneratedAttribute]
public KeyValuePair`2<string, string> get_Mapping();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
internal interface NuGet.Frameworks.IFrameworkCompatibilityListProvider {
    public abstract virtual IEnumerable`1<NuGetFramework> GetFrameworksSupporting(NuGetFramework target);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
internal interface NuGet.Frameworks.IFrameworkCompatibilityProvider {
    public abstract virtual bool IsCompatible(NuGetFramework framework, NuGetFramework other);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
internal interface NuGet.Frameworks.IFrameworkMappings {
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierSynonyms { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierShortNames { get; }
    public IEnumerable`1<FrameworkSpecificMapping> ProfileShortNames { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> EquivalentFrameworks { get; }
    public IEnumerable`1<FrameworkSpecificMapping> EquivalentProfiles { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> SubSetFrameworks { get; }
    public IEnumerable`1<OneWayCompatibilityMappingEntry> CompatibilityMappings { get; }
    public IEnumerable`1<string> NonPackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> PackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> EquivalentFrameworkPrecedence { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> ShortNameReplacements { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> FullNameReplacements { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierSynonyms();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierShortNames();
    public abstract virtual IEnumerable`1<FrameworkSpecificMapping> get_ProfileShortNames();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_EquivalentFrameworks();
    public abstract virtual IEnumerable`1<FrameworkSpecificMapping> get_EquivalentProfiles();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_SubSetFrameworks();
    public abstract virtual IEnumerable`1<OneWayCompatibilityMappingEntry> get_CompatibilityMappings();
    public abstract virtual IEnumerable`1<string> get_NonPackageBasedFrameworkPrecedence();
    public abstract virtual IEnumerable`1<string> get_PackageBasedFrameworkPrecedence();
    public abstract virtual IEnumerable`1<string> get_EquivalentFrameworkPrecedence();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_ShortNameReplacements();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_FullNameReplacements();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
internal interface NuGet.Frameworks.IFrameworkNameProvider {
    public abstract virtual bool TryGetIdentifier(string identifierShortName, String& identifier);
    public abstract virtual bool TryGetShortIdentifier(string identifier, String& identifierShortName);
    public abstract virtual bool TryGetProfile(string frameworkIdentifier, string profileShortName, String& profile);
    public abstract virtual bool TryGetShortProfile(string frameworkIdentifier, string profile, String& profileShortName);
    public abstract virtual bool TryGetVersion(string versionString, Version& version);
    public abstract virtual bool TryGetPlatformVersion(string versionString, Version& version);
    public abstract virtual string GetVersionString(string framework, Version version);
    public abstract virtual bool TryGetPortableProfileNumber(string profile, Int32& profileNumber);
    public abstract virtual bool TryGetPortableProfile(IEnumerable`1<NuGetFramework> supportedFrameworks, Int32& profileNumber);
    public abstract virtual bool TryGetPortableFrameworks(int profile, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(int profile, bool includeOptional, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(string profile, bool includeOptional, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(string shortPortableProfiles, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableCompatibilityMappings(int profile, IEnumerable`1& supportedFrameworkRanges);
    public abstract virtual bool TryGetEquivalentFrameworks(NuGetFramework framework, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetEquivalentFrameworks(FrameworkRange range, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetCompatibilityMappings(NuGetFramework framework, IEnumerable`1& supportedFrameworkRanges);
    public abstract virtual bool TryGetSubSetFrameworks(string frameworkIdentifier, IEnumerable`1& subSetFrameworkIdentifiers);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public abstract virtual int CompareFrameworks(NuGetFramework x, NuGetFramework y);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public abstract virtual int CompareEquivalentFrameworks(NuGetFramework x, NuGetFramework y);
    public abstract virtual NuGetFramework GetShortNameReplacement(NuGetFramework framework);
    public abstract virtual NuGetFramework GetFullNameReplacement(NuGetFramework framework);
    public abstract virtual IEnumerable`1<NuGetFramework> GetNetStandardVersions();
    public abstract virtual IEnumerable`1<NuGetFramework> GetCompatibleCandidates();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
internal interface NuGet.Frameworks.IFrameworkSpecific {
    public NuGetFramework TargetFramework { get; }
    public abstract virtual NuGetFramework get_TargetFramework();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
internal interface NuGet.Frameworks.IFrameworkTargetable {
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; }
    public abstract virtual IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
}
internal interface NuGet.Frameworks.IPortableFrameworkMappings {
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.NuGetFramework : object {
    private string _frameworkIdentifier;
    private Version _frameworkVersion;
    private string _frameworkProfile;
    [NuGet.Frameworks.NullableAttribute("2")]
private string _targetFrameworkMoniker;
    [NuGet.Frameworks.NullableAttribute("2")]
private string _targetPlatformMoniker;
    private Nullable`1<int> _hashCode;
    private static int Version5;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <PlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNet5Era>k__BackingField;
    public static IEqualityComparer`1<NuGetFramework> Comparer;
    public static IEqualityComparer`1<NuGetFramework> FrameworkNameComparer;
    private static SortedSet`1<string> PackagesBased;
    public static NuGetFramework UnsupportedFramework;
    public static NuGetFramework AgnosticFramework;
    public static NuGetFramework AnyFramework;
    private static Char[] CommaSeparator;
    public string Framework { get; }
    public Version Version { get; }
    public string Platform { get; }
    public Version PlatformVersion { get; }
    public bool HasPlatform { get; }
    public bool HasProfile { get; }
    public string Profile { get; }
    public string DotNetFrameworkName { get; }
    public string DotNetPlatformName { get; }
    public bool IsPCL { get; }
    public bool IsPackageBased { get; }
    public bool AllFrameworkVersions { get; }
    public bool IsUnsupported { get; }
    public bool IsAgnostic { get; }
    public bool IsAny { get; }
    public bool IsSpecificFramework { get; }
    internal bool IsNet5Era { get; private set; }
    public NuGetFramework(NuGetFramework framework);
    public NuGetFramework(string framework);
    public NuGetFramework(string framework, Version version);
    public NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string frameworkProfile);
    public NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string platform, Version platformVersion);
    internal NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string profile, string platform, Version platformVersion);
    private static NuGetFramework();
    public string get_Framework();
    public Version get_Version();
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Version get_PlatformVersion();
    public bool get_HasPlatform();
    public bool get_HasProfile();
    public string get_Profile();
    public string get_DotNetFrameworkName();
    public string GetDotNetFrameworkName(IFrameworkNameProvider mappings);
    public string get_DotNetPlatformName();
    public string GetShortFolderName();
    private string GetFrameworkIdentifier();
    public virtual string GetShortFolderName(IFrameworkNameProvider mappings);
    private static string GetDisplayVersion(Version version);
    private static string GetLettersAndDigitsOnly(string s);
    public bool get_IsPCL();
    public bool get_IsPackageBased();
    public bool get_AllFrameworkVersions();
    public bool get_IsUnsupported();
    public bool get_IsAgnostic();
    public bool get_IsAny();
    public bool get_IsSpecificFramework();
    [CompilerGeneratedAttribute]
internal bool get_IsNet5Era();
    [CompilerGeneratedAttribute]
private void set_IsNet5Era(bool value);
    public virtual string ToString();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework other);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public static bool op_Equality(NuGetFramework left, NuGetFramework right);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public static bool op_Inequality(NuGetFramework left, NuGetFramework right);
    public virtual int GetHashCode();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private static Version NormalizeVersion(Version version);
    public static NuGetFramework Parse(string folderName);
    public static NuGetFramework Parse(string folderName, IFrameworkNameProvider mappings);
    public static NuGetFramework ParseComponents(string targetFrameworkMoniker, string targetPlatformMoniker);
    internal static NuGetFramework ParseComponents(string targetFrameworkMoniker, string targetPlatformMoniker, IFrameworkNameProvider mappings);
    private static String[] GetParts(string targetPlatformMoniker);
    public static NuGetFramework ParseFrameworkName(string frameworkName, IFrameworkNameProvider mappings);
    private static void ParseFrameworkNameParts(IFrameworkNameProvider mappings, String[] parts, String& framework, Version& version, String& profile);
    private static void ParsePlatformParts(String[] parts, String& targetPlatformIdentifier, Version& platformVersion);
    public static NuGetFramework ParseFolder(string folderName);
    public static NuGetFramework ParseFolder(string folderName, IFrameworkNameProvider mappings);
    private static bool TryParseDeprecatedFramework(string s, NuGetFramework& framework);
    private static Tuple`3<string, string, string> RawParse(string s);
    private static bool IsLetterOrDot(char c);
    private static bool IsDigitOrDot(char c);
    private static bool IsValidProfileChar(char c);
    private static bool TryParseSpecialFramework(string frameworkString, NuGetFramework& framework);
    private static bool TryParseCommonFramework(string frameworkString, NuGetFramework& framework);
    private static string SingleOrDefaultSafe(IEnumerable`1<string> items);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Frameworks.NuGetFrameworkExtensions : object {
    [ExtensionAttribute]
public static bool IsDesktop(NuGetFramework framework);
    [ExtensionAttribute]
public static T GetNearest(IEnumerable`1<T> items, NuGetFramework projectFramework);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.NuGetFrameworkFullComparer : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkFullComparer <Instance>k__BackingField;
    public static NuGetFrameworkFullComparer Instance { get; }
    private static NuGetFrameworkFullComparer();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkFullComparer get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework x, NuGetFramework y);
    public sealed virtual int GetHashCode(NuGetFramework obj);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.NuGetFrameworkNameComparer : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkNameComparer <Instance>k__BackingField;
    public static NuGetFrameworkNameComparer Instance { get; }
    private static NuGetFrameworkNameComparer();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkNameComparer get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework x, NuGetFramework y);
    public sealed virtual int GetHashCode(NuGetFramework obj);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.NuGetFrameworkSorter : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkSorter <Instance>k__BackingField;
    public static NuGetFrameworkSorter Instance { get; }
    private static NuGetFrameworkSorter();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkSorter get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int Compare(NuGetFramework x, NuGetFramework y);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal static class NuGet.Frameworks.NuGetFrameworkUtility : object {
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, Func`2<T, NuGetFramework> selector);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, IFrameworkNameProvider frameworkMappings, IFrameworkCompatibilityProvider compatibilityProvider, Func`2<T, NuGetFramework> selector);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, IFrameworkNameProvider frameworkMappings, IFrameworkCompatibilityProvider compatibilityProvider);
    public static bool IsCompatibleWithFallbackCheck(NuGetFramework projectFramework, NuGetFramework candidate);
    public static bool IsNetCore50AndUp(NuGetFramework framework);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.Frameworks.OneWayCompatibilityMappingEntry : object {
    private FrameworkRange _targetFramework;
    private FrameworkRange _supportedFramework;
    public FrameworkRange TargetFrameworkRange { get; }
    public FrameworkRange SupportedFrameworkRange { get; }
    public static CompatibilityMappingComparer Comparer { get; }
    public OneWayCompatibilityMappingEntry(FrameworkRange targetFramework, FrameworkRange supportedFramework);
    public FrameworkRange get_TargetFrameworkRange();
    public FrameworkRange get_SupportedFrameworkRange();
    public static CompatibilityMappingComparer get_Comparer();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(OneWayCompatibilityMappingEntry other);
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Frameworks.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string FrameworkDoesNotSupportProfiles { get; }
    internal static string FrameworkMismatch { get; }
    internal static string InvalidFrameworkIdentifier { get; }
    internal static string InvalidFrameworkVersion { get; }
    internal static string InvalidPlatformVersion { get; }
    internal static string InvalidPortableFrameworksDueToHyphen { get; }
    internal static string MissingPortableFrameworks { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_FrameworkDoesNotSupportProfiles();
    internal static string get_FrameworkMismatch();
    internal static string get_InvalidFrameworkIdentifier();
    internal static string get_InvalidFrameworkVersion();
    internal static string get_InvalidPlatformVersion();
    internal static string get_InvalidPortableFrameworksDueToHyphen();
    internal static string get_MissingPortableFrameworks();
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.LibraryModel.CentralPackageVersion : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    public string Name { get; }
    public VersionRange VersionRange { get; }
    public CentralPackageVersion(string name, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual bool Equals(CentralPackageVersion other);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.LibraryModel.CentralPackageVersionNameComparer : object {
    [CompilerGeneratedAttribute]
private static CentralPackageVersionNameComparer <Default>k__BackingField;
    public static CentralPackageVersionNameComparer Default { get; }
    private static CentralPackageVersionNameComparer();
    [CompilerGeneratedAttribute]
public static CentralPackageVersionNameComparer get_Default();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual bool Equals(CentralPackageVersion x, CentralPackageVersion y);
    public sealed virtual int GetHashCode(CentralPackageVersion obj);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.LibraryModel.DownloadDependency : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    public string Name { get; }
    public VersionRange VersionRange { get; }
    public DownloadDependency(string name, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    public static LibraryRange op_Implicit(DownloadDependency library);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual int CompareTo(DownloadDependency other);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual bool Equals(DownloadDependency other);
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public DownloadDependency Clone();
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.LibraryModel.FrameworkDependency : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameworkDependencyFlags <PrivateAssets>k__BackingField;
    public string Name { get; }
    public FrameworkDependencyFlags PrivateAssets { get; }
    public FrameworkDependency(string name, FrameworkDependencyFlags privateAssets);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public FrameworkDependencyFlags get_PrivateAssets();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual int CompareTo(FrameworkDependency other);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkDependency other);
    public virtual int GetHashCode();
}
[FlagsAttribute]
internal enum NuGet.LibraryModel.FrameworkDependencyFlags : Enum {
    public ushort value__;
    public static FrameworkDependencyFlags None;
    public static FrameworkDependencyFlags All;
}
internal static class NuGet.LibraryModel.FrameworkDependencyFlagsUtils : object {
    public static FrameworkDependencyFlags Default;
    public static FrameworkDependencyFlags GetFlags(IEnumerable`1<string> values);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
public static string GetFlagString(FrameworkDependencyFlags flags);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public static FrameworkDependencyFlags GetFlags(string flags);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal static class NuGet.LibraryModel.KnownLibraryProperties : object {
    public static string AssemblyPath;
    public static string LockFileLibrary;
    public static string LockFileTargetLibrary;
    public static string PackageSpec;
    public static string TargetFrameworkInformation;
    public static string MSBuildProjectPath;
    public static string ProjectRestoreMetadataFiles;
    public static string FrameworkAssemblies;
    public static string ProjectFrameworks;
    public static string ProjectStyle;
    public static string FrameworkReferences;
    private static KnownLibraryProperties();
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[NuGet.LibraryModel904366.RequiredMemberAttribute]
internal class NuGet.LibraryModel.Library : object {
    public static IEqualityComparer`1<Library> IdentityComparer;
    [CompilerGeneratedAttribute]
private LibraryRange <LibraryRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Resolved>k__BackingField;
    [NuGet.LibraryModel.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Items>k__BackingField;
    [NuGet.LibraryModel904366.RequiredMemberAttribute]
public LibraryRange LibraryRange { get; public set; }
    [NuGet.LibraryModel904366.RequiredMemberAttribute]
public LibraryIdentity Identity { get; public set; }
    [NuGet.LibraryModel904366.RequiredMemberAttribute]
public IEnumerable`1<LibraryDependency> Dependencies { get; public set; }
    public bool Resolved { get; public set; }
    [NuGet.LibraryModel.NullableAttribute("2")]
public string Path { get; public set; }
    public IDictionary`2<string, object> Items { get; public set; }
    public object Item { get; public set; }
    [NuGet.LibraryModel904366.SetsRequiredMembersAttribute]
public Library(LibraryRange libraryRange, LibraryIdentity identity, IEnumerable`1<LibraryDependency> dependencies);
    private static Library();
    [CompilerGeneratedAttribute]
public LibraryRange get_LibraryRange();
    [CompilerGeneratedAttribute]
public void set_LibraryRange(LibraryRange value);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Identity();
    [CompilerGeneratedAttribute]
public void set_Identity(LibraryIdentity value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IEnumerable`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public bool get_Resolved();
    [CompilerGeneratedAttribute]
public void set_Resolved(bool value);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IDictionary`2<string, object> value);
    public object get_Item(string key);
    public void set_Item(string key, object value);
    public virtual string ToString();
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[NuGet.LibraryModel904366.RequiredMemberAttribute]
internal class NuGet.LibraryModel.LibraryDependency : object {
    [CompilerGeneratedAttribute]
private LibraryRange <LibraryRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <IncludeType>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <SuppressParent>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetLogCode> <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoReferenced>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VersionCentrallyManaged>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDependencyReferenceType <ReferenceType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GeneratePathProperty>k__BackingField;
    [NuGet.LibraryModel.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Aliases>k__BackingField;
    [NuGet.LibraryModel.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private VersionRange <VersionOverride>k__BackingField;
    [NuGet.LibraryModel904366.RequiredMemberAttribute]
public LibraryRange LibraryRange { get; public set; }
    public LibraryIncludeFlags IncludeType { get; public set; }
    public LibraryIncludeFlags SuppressParent { get; public set; }
    public IList`1<NuGetLogCode> NoWarn { get; public set; }
    public string Name { get; }
    public bool AutoReferenced { get; public set; }
    public bool VersionCentrallyManaged { get; public set; }
    public LibraryDependencyReferenceType ReferenceType { get; public set; }
    public bool GeneratePathProperty { get; public set; }
    [NuGet.LibraryModel.NullableAttribute("2")]
public string Aliases { get; public set; }
    [NuGet.LibraryModel.NullableAttribute("2")]
public VersionRange VersionOverride { get; public set; }
    [ObsoleteAttribute("Constructors of types with required members are not supported in this version of your compiler.", "True")]
[NuGet.LibraryModel904366.CompilerFeatureRequiredAttribute("RequiredMembers")]
public LibraryDependency(IList`1<NuGetLogCode> noWarn);
    [NuGet.LibraryModel904366.SetsRequiredMembersAttribute]
public LibraryDependency(LibraryRange libraryRange);
    [NuGet.LibraryModel904366.SetsRequiredMembersAttribute]
internal LibraryDependency(LibraryRange libraryRange, LibraryIncludeFlags includeType, LibraryIncludeFlags suppressParent, IList`1<NuGetLogCode> noWarn, bool autoReferenced, bool generatePathProperty, bool versionCentrallyManaged, LibraryDependencyReferenceType libraryDependencyReferenceType, string aliases, VersionRange versionOverride);
    [CompilerGeneratedAttribute]
public LibraryRange get_LibraryRange();
    [CompilerGeneratedAttribute]
public void set_LibraryRange(LibraryRange value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_IncludeType();
    [CompilerGeneratedAttribute]
public void set_IncludeType(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_SuppressParent();
    [CompilerGeneratedAttribute]
public void set_SuppressParent(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetLogCode> get_NoWarn();
    [CompilerGeneratedAttribute]
public void set_NoWarn(IList`1<NuGetLogCode> value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_AutoReferenced();
    [CompilerGeneratedAttribute]
public void set_AutoReferenced(bool value);
    [CompilerGeneratedAttribute]
public bool get_VersionCentrallyManaged();
    [CompilerGeneratedAttribute]
public void set_VersionCentrallyManaged(bool value);
    [CompilerGeneratedAttribute]
public LibraryDependencyReferenceType get_ReferenceType();
    [CompilerGeneratedAttribute]
public void set_ReferenceType(LibraryDependencyReferenceType value);
    [CompilerGeneratedAttribute]
public bool get_GeneratePathProperty();
    [CompilerGeneratedAttribute]
public void set_GeneratePathProperty(bool value);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Aliases();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Aliases(string value);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public VersionRange get_VersionOverride();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_VersionOverride(VersionRange value);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual bool Equals(LibraryDependency other);
    public LibraryDependency Clone();
    public static void ApplyCentralVersionInformation(IList`1<LibraryDependency> packageReferences, IDictionary`2<string, CentralPackageVersion> centralPackageVersions);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.LibraryModel.LibraryDependencyInfo : object {
    [CompilerGeneratedAttribute]
private bool <Resolved>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIdentity <Library>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    public bool Resolved { get; }
    public LibraryIdentity Library { get; }
    public IEnumerable`1<LibraryDependency> Dependencies { get; }
    public NuGetFramework Framework { get; }
    public LibraryDependencyInfo(LibraryIdentity library, bool resolved, NuGetFramework framework, IEnumerable`1<LibraryDependency> dependencies);
    [CompilerGeneratedAttribute]
public bool get_Resolved();
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Library();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    public static LibraryDependencyInfo CreateUnresolved(LibraryIdentity library, NuGetFramework framework);
    public static LibraryDependencyInfo Create(LibraryIdentity library, NuGetFramework framework, IEnumerable`1<LibraryDependency> dependencies);
}
internal enum NuGet.LibraryModel.LibraryDependencyReferenceType : Enum {
    public int value__;
    public static LibraryDependencyReferenceType None;
    public static LibraryDependencyReferenceType Transitive;
    public static LibraryDependencyReferenceType Direct;
}
[FlagsAttribute]
internal enum NuGet.LibraryModel.LibraryDependencyTarget : Enum {
    public ushort value__;
    public static LibraryDependencyTarget None;
    public static LibraryDependencyTarget Package;
    public static LibraryDependencyTarget Project;
    public static LibraryDependencyTarget ExternalProject;
    public static LibraryDependencyTarget Assembly;
    public static LibraryDependencyTarget Reference;
    public static LibraryDependencyTarget WinMD;
    public static LibraryDependencyTarget All;
    public static LibraryDependencyTarget PackageProjectExternal;
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.LibraryModel.LibraryDependencyTargetUtils : object {
    private static ConcurrentDictionary`2<LibraryDependencyTarget, string> LibraryDependencyTargetCache;
    private static LibraryDependencyTargetUtils();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public static LibraryDependencyTarget Parse(string flag);
    private static LibraryDependencyTarget ParseMultiFlag(string flag, int end);
    private static LibraryDependencyTarget ParseSingleFlag(StringSegment flag);
    public static string GetFlagString(LibraryDependencyTarget flags);
    [ExtensionAttribute]
public static string AsString(LibraryDependencyTarget includeFlags);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.LibraryModel.LibraryExtensions : object {
    [ExtensionAttribute]
public static bool IsEclipsedBy(LibraryRange library, LibraryRange other);
    [ExtensionAttribute]
public static T GetItem(Library library, string key);
    [ExtensionAttribute]
public static T GetRequiredItem(Library library, string key);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[NuGet.LibraryModel904366.RequiredMemberAttribute]
internal class NuGet.LibraryModel.LibraryIdentity : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryType <Type>k__BackingField;
    [NuGet.LibraryModel904366.RequiredMemberAttribute]
public string Name { get; public set; }
    [NuGet.LibraryModel904366.RequiredMemberAttribute]
public NuGetVersion Version { get; public set; }
    [NuGet.LibraryModel904366.RequiredMemberAttribute]
public LibraryType Type { get; public set; }
    [NuGet.LibraryModel904366.SetsRequiredMembersAttribute]
public LibraryIdentity(string name, NuGetVersion version, LibraryType type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public LibraryType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(LibraryType value);
    public virtual string ToString();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual bool Equals(LibraryIdentity other);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public static bool op_Equality(LibraryIdentity left, LibraryIdentity right);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public static bool op_Inequality(LibraryIdentity left, LibraryIdentity right);
    public static LibraryRange op_Implicit(LibraryIdentity library);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public sealed virtual int CompareTo(LibraryIdentity other);
}
[FlagsAttribute]
internal enum NuGet.LibraryModel.LibraryIncludeFlags : Enum {
    public ushort value__;
    public static LibraryIncludeFlags None;
    public static LibraryIncludeFlags Runtime;
    public static LibraryIncludeFlags Compile;
    public static LibraryIncludeFlags Build;
    public static LibraryIncludeFlags Native;
    public static LibraryIncludeFlags ContentFiles;
    public static LibraryIncludeFlags Analyzers;
    public static LibraryIncludeFlags BuildTransitive;
    public static LibraryIncludeFlags All;
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.LibraryModel.LibraryIncludeFlagUtils : object {
    public static LibraryIncludeFlags DefaultSuppressParent;
    public static LibraryIncludeFlags NoContent;
    private static ConcurrentDictionary`2<LibraryIncludeFlags, string> LibraryIncludeFlagsCache;
    private static LibraryIncludeFlagUtils();
    public static LibraryIncludeFlags GetFlags(IEnumerable`1<string> flags);
    public static string GetFlagString(LibraryIncludeFlags flags);
    public static LibraryIncludeFlags GetFlags(string flags, LibraryIncludeFlags defaultFlags);
    [ExtensionAttribute]
public static string AsString(LibraryIncludeFlags includeFlags);
}
[NuGet.LibraryModel.NullableContextAttribute("2")]
[NuGet.LibraryModel.NullableAttribute("0")]
[NuGet.LibraryModel904366.RequiredMemberAttribute]
internal class NuGet.LibraryModel.LibraryRange : object {
    [NuGet.LibraryModel.NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDependencyTarget <TypeConstraint>k__BackingField;
    [NuGet.LibraryModel.NullableAttribute("1")]
[NuGet.LibraryModel904366.RequiredMemberAttribute]
public string Name { get; public set; }
    public VersionRange VersionRange { get; public set; }
    public LibraryDependencyTarget TypeConstraint { get; public set; }
    [NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel904366.SetsRequiredMembersAttribute]
public LibraryRange(string name);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel904366.SetsRequiredMembersAttribute]
public LibraryRange(string name, LibraryDependencyTarget typeConstraint);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel904366.SetsRequiredMembersAttribute]
public LibraryRange(string name, VersionRange versionRange, LibraryDependencyTarget typeConstraint);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NuGet.LibraryModel.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    [CompilerGeneratedAttribute]
public void set_VersionRange(VersionRange value);
    [CompilerGeneratedAttribute]
public LibraryDependencyTarget get_TypeConstraint();
    [CompilerGeneratedAttribute]
public void set_TypeConstraint(LibraryDependencyTarget value);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
public virtual string ToString();
    public string ToLockFileDependencyGroupString();
    public bool TypeConstraintAllows(LibraryDependencyTarget flag);
    public bool TypeConstraintAllowsAnyOf(LibraryDependencyTarget flag);
    public sealed virtual bool Equals(LibraryRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LibraryRange left, LibraryRange right);
    public static bool op_Inequality(LibraryRange left, LibraryRange right);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.LibraryModel.LibraryType : ValueType {
    private static ConcurrentDictionary`2<string, LibraryType> _knownLibraryTypes;
    public static LibraryType Project;
    public static LibraryType ExternalProject;
    public static LibraryType Package;
    public static LibraryType Assembly;
    public static LibraryType Reference;
    public static LibraryType WinMD;
    public static LibraryType Unresolved;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKnown>k__BackingField;
    public string Value { get; }
    public bool IsKnown { get; }
    private LibraryType(string value, bool isKnown);
    private static LibraryType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsKnown();
    public static LibraryType Parse(string value);
    public virtual string ToString();
    public sealed virtual bool Equals(LibraryType other);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(LibraryType left, LibraryType right);
    public static bool op_Inequality(LibraryType left, LibraryType right);
    public static string op_Implicit(LibraryType libraryType);
    public virtual int GetHashCode();
    private static LibraryType Define(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Commands486115.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
internal class NuGet.NuGet.Commands486115.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Commands486115.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
internal class NuGet.NuGet.Commands486115.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Commands486115.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Commands486115.StringBuilderPool Shared;
    private static NuGet.Commands486115.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
internal static class NuGet.NuGet.Commands486115.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Commands486115.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
internal class NuGet.NuGet.Commands486115.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.Commands486115.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Common674679.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.NuGet.Common674679.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Common674679.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.NuGet.Common674679.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Common674679.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Common674679.StringBuilderPool Shared;
    private static NuGet.Common674679.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.NuGet.Common674679.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Common674679.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal class NuGet.NuGet.Common674679.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.Common674679.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Configuration724319.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.NuGet.Configuration724319.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Configuration724319.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.NuGet.Configuration724319.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Configuration724319.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Configuration724319.StringBuilderPool Shared;
    private static NuGet.Configuration724319.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.NuGet.Configuration724319.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Configuration724319.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.NuGet.Configuration724319.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.Configuration724319.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.Credentials.NullableContextAttribute("1")]
[NuGet.Credentials.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Credentials795379.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Credentials.NullableContextAttribute("1")]
[NuGet.Credentials.NullableAttribute("0")]
internal class NuGet.NuGet.Credentials795379.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Credentials795379.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Credentials.NullableContextAttribute("1")]
[NuGet.Credentials.NullableAttribute("0")]
internal class NuGet.NuGet.Credentials795379.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Credentials795379.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Credentials795379.StringBuilderPool Shared;
    private static NuGet.Credentials795379.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Credentials.NullableContextAttribute("1")]
[NuGet.Credentials.NullableAttribute("0")]
internal static class NuGet.NuGet.Credentials795379.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Credentials795379.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Credentials.NullableContextAttribute("1")]
[NuGet.Credentials.NullableAttribute("0")]
internal class NuGet.NuGet.Credentials795379.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.Credentials795379.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.DependencyResolver.Core818074.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
internal class NuGet.NuGet.DependencyResolver.Core818074.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.DependencyResolver.Core818074.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
internal class NuGet.NuGet.DependencyResolver.Core818074.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.DependencyResolver.Core818074.SimplePool`1<StringBuilder> _pool;
    public static NuGet.DependencyResolver.Core818074.StringBuilderPool Shared;
    private static NuGet.DependencyResolver.Core818074.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
internal static class NuGet.NuGet.DependencyResolver.Core818074.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.DependencyResolver.Core818074.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
internal class NuGet.NuGet.DependencyResolver.Core818074.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.DependencyResolver.Core818074.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Frameworks856443.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.NuGet.Frameworks856443.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Frameworks856443.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.NuGet.Frameworks856443.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Frameworks856443.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Frameworks856443.StringBuilderPool Shared;
    private static NuGet.Frameworks856443.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal static class NuGet.NuGet.Frameworks856443.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Frameworks856443.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.NuGet.Frameworks856443.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.Frameworks856443.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.LibraryModel904366.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.NuGet.LibraryModel904366.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.LibraryModel904366.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.NuGet.LibraryModel904366.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.LibraryModel904366.SimplePool`1<StringBuilder> _pool;
    public static NuGet.LibraryModel904366.StringBuilderPool Shared;
    private static NuGet.LibraryModel904366.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal static class NuGet.NuGet.LibraryModel904366.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.LibraryModel904366.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal class NuGet.NuGet.LibraryModel904366.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.LibraryModel904366.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Packaging925837.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal class NuGet.NuGet.Packaging925837.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Packaging925837.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal class NuGet.NuGet.Packaging925837.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Packaging925837.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Packaging925837.StringBuilderPool Shared;
    private static NuGet.Packaging925837.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal static class NuGet.NuGet.Packaging925837.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Packaging925837.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal class NuGet.NuGet.Packaging925837.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.Packaging925837.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.ProjectModel1175159.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
internal class NuGet.NuGet.ProjectModel1175159.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.ProjectModel1175159.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
internal class NuGet.NuGet.ProjectModel1175159.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.ProjectModel1175159.SimplePool`1<StringBuilder> _pool;
    public static NuGet.ProjectModel1175159.StringBuilderPool Shared;
    private static NuGet.ProjectModel1175159.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
internal static class NuGet.NuGet.ProjectModel1175159.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.ProjectModel1175159.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
internal class NuGet.NuGet.ProjectModel1175159.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.ProjectModel1175159.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Protocol1276564.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.NuGet.Protocol1276564.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Protocol1276564.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.NuGet.Protocol1276564.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Protocol1276564.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Protocol1276564.StringBuilderPool Shared;
    private static NuGet.Protocol1276564.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal static class NuGet.NuGet.Protocol1276564.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Protocol1276564.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.NuGet.Protocol1276564.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.Protocol1276564.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Versioning1599207.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.NuGet.Versioning1599207.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Versioning1599207.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.NuGet.Versioning1599207.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Versioning1599207.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Versioning1599207.StringBuilderPool Shared;
    private static NuGet.Versioning1599207.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal static class NuGet.NuGet.Versioning1599207.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Versioning1599207.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.NuGet.Versioning1599207.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public NuGet.Versioning1599207.TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.<PrivateImplementationDetails> : object {
    internal static __StaticArrayInitTypeSize=72 1322D1B39533BDAC158534C6038A6604353F624FE00BA8853ACE014F39F256F6;
    internal static __StaticArrayInitTypeSize=32 2EF83B43314F8CD03190EEE30ECCF048DA37791237F27C62A579F23EACE9FD70;
    internal static __StaticArrayInitTypeSize=12 4636993D3E1DA4E9D6B8F87B79E8F7C6D018580D52661950EABC3845C5897A4D;
    internal static int 6A3DB24B8BC57D2CCDC198B2D7858EC657F34A7B2C9153BC04CA82D73170876D;
    internal static __StaticArrayInitTypeSize=10 95F9CC13D5B6AC6BF42EDD70B77562DFD84CC4209CCD22831FD3663E74F841EE;
}
[ExtensionAttribute]
internal static class NuGet.Packaging.CollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
internal static class NuGet.Packaging.Core.ContentExtractor : object {
    internal static void GetContentForPattern(ContentItemCollection collection, PatternSet pattern, IList`1<ContentItemGroup> itemGroups);
    internal static IEnumerable`1<NuGetFramework> GetGroupFrameworks(IEnumerable`1<ContentItemGroup> groups);
}
internal class NuGet.Packaging.Core.ContentFilesEntry : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Flatten>k__BackingField;
    public string Include { get; }
    public string Exclude { get; }
    public string BuildAction { get; }
    public Nullable`1<bool> CopyToOutput { get; }
    public Nullable`1<bool> Flatten { get; }
    public ContentFilesEntry(string include, string exclude, string buildAction, Nullable`1<bool> copyToOutput, Nullable`1<bool> flatten);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CopyToOutput();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Flatten();
}
internal class NuGet.Packaging.Core.ExtractPackageFileDelegate : MulticastDelegate {
    public ExtractPackageFileDelegate(object object, IntPtr method);
    public virtual string Invoke(string sourceFile, string targetPath, Stream fileStream);
    public virtual IAsyncResult BeginInvoke(string sourceFile, string targetPath, Stream fileStream, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class NuGet.Packaging.Core.Fingerprints : object {
    private IDictionary`2<string, string> _keyValuePairs;
    public string Item { get; }
    public Fingerprints(IDictionary`2<string, string> fingerPrints);
    public string get_Item(string key);
    public IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
}
internal interface NuGet.Packaging.Core.IAsyncPackageCoreReader {
    public abstract virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
}
internal interface NuGet.Packaging.Core.INuspecCoreReader {
    public abstract virtual string GetId();
    public abstract virtual NuGetVersion GetVersion();
    public abstract virtual NuGetVersion GetMinClientVersion();
    public abstract virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public abstract virtual PackageIdentity GetIdentity();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> GetMetadata();
}
internal interface NuGet.Packaging.Core.IPackageCoreReader {
    public abstract virtual PackageIdentity GetIdentity();
    public abstract virtual NuGetVersion GetMinClientVersion();
    public abstract virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual Stream GetNuspec();
    public abstract virtual string GetNuspecFile();
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
}
internal interface NuGet.Packaging.Core.IPackageIdentityComparer {
}
internal interface NuGet.Packaging.Core.IRepositoryCertificateInfo {
    public string ContentUrl { get; }
    public Fingerprints Fingerprints { get; }
    public string Issuer { get; }
    public DateTimeOffset NotAfter { get; }
    public DateTimeOffset NotBefore { get; }
    public string Subject { get; }
    public abstract virtual string get_ContentUrl();
    public abstract virtual Fingerprints get_Fingerprints();
    public abstract virtual string get_Issuer();
    public abstract virtual DateTimeOffset get_NotAfter();
    public abstract virtual DateTimeOffset get_NotBefore();
    public abstract virtual string get_Subject();
}
internal class NuGet.Packaging.Core.NuspecCoreReader : NuspecCoreReaderBase {
    public NuspecCoreReader(Stream stream);
    public NuspecCoreReader(XDocument xml);
    [IteratorStateMachineAttribute("NuGet.Packaging.Core.NuspecCoreReader/<GetDependencies>d__2")]
public virtual IEnumerable`1<PackageDependency> GetDependencies();
}
internal abstract class NuGet.Packaging.Core.NuspecCoreReaderBase : object {
    private XDocument _xml;
    private XElement _metadataNode;
    private Dictionary`2<string, string> _metadataValues;
    protected static string Metadata;
    protected static string Id;
    protected static string Version;
    protected static string MinClientVersion;
    protected static string DevelopmentDependency;
    protected Dictionary`2<string, string> MetadataValues { get; }
    protected XElement MetadataNode { get; }
    public XDocument Xml { get; }
    public NuspecCoreReaderBase(string path);
    public NuspecCoreReaderBase(Stream stream);
    public NuspecCoreReaderBase(Stream stream, bool leaveStreamOpen);
    public NuspecCoreReaderBase(XDocument xml);
    public virtual string GetId();
    public virtual NuGetVersion GetVersion();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual bool IsServiceable();
    public virtual bool GetDevelopmentDependency();
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> GetMetadata();
    public virtual string GetMetadataValue(string name);
    protected Dictionary`2<string, string> get_MetadataValues();
    protected XElement get_MetadataNode();
    public XDocument get_Xml();
    public virtual PackageIdentity GetIdentity();
    private static XDocument LoadXml(Stream stream, bool leaveStreamOpen);
}
internal static class NuGet.Packaging.Core.NuspecUtility : object {
    public static string PackageTypes;
    public static string PackageType;
    public static string Name;
    public static string Version;
    public static string Serviceable;
    public static string Repository;
    public static string Type;
    public static string RepositoryUrl;
    public static string RepositoryBranch;
    public static string RepositoryCommit;
    public static string License;
    public static string Group;
    public static string FrameworkReferences;
    public static string FrameworkReference;
    public static string TargetFramework;
    private static NuspecUtility();
    public static IReadOnlyList`1<PackageType> GetPackageTypes(XElement metadataNode, bool useMetadataNamespace);
    public static bool IsServiceable(XElement metadataNode);
    [IteratorStateMachineAttribute("NuGet.Packaging.Core.NuspecUtility/<GetFrameworkReferenceGroups>d__17")]
internal static IEnumerable`1<FrameworkReferenceGroup> GetFrameworkReferenceGroups(XElement metadataNode, IFrameworkNameProvider frameworkProvider, bool useMetadataNamespace);
    private static IEnumerable`1<string> GetFrameworkReferences(IEnumerable`1<XElement> nodes);
    private static string GetAttributeValue(XElement element, string attributeName);
}
internal class NuGet.Packaging.Core.PackageDependency : object {
    private VersionRange _versionRange;
    private static List`1<string> EmptyList;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Exclude>k__BackingField;
    public string Id { get; }
    public IReadOnlyList`1<string> Include { get; }
    public IReadOnlyList`1<string> Exclude { get; }
    public VersionRange VersionRange { get; }
    public PackageDependency(string id);
    public PackageDependency(string id, VersionRange versionRange);
    public PackageDependency(string id, VersionRange versionRange, IReadOnlyList`1<string> include, IReadOnlyList`1<string> exclude);
    private static PackageDependency();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Include();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Exclude();
    public VersionRange get_VersionRange();
    public sealed virtual bool Equals(PackageDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class NuGet.Packaging.Core.PackageDependencyComparer : object {
    private IVersionRangeComparer _versionRangeComparer;
    public static PackageDependencyComparer Default;
    public PackageDependencyComparer(IVersionRangeComparer versionRangeComparer);
    private static PackageDependencyComparer();
    public sealed virtual bool Equals(PackageDependency x, PackageDependency y);
    public sealed virtual int GetHashCode(PackageDependency obj);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal class NuGet.Packaging.Core.PackageDependencyInfo : PackageIdentity {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependency> <Dependencies>k__BackingField;
    public IEnumerable`1<PackageDependency> Dependencies { get; }
    public PackageDependencyInfo(string id, NuGetVersion version);
    public PackageDependencyInfo(PackageIdentity identity, IEnumerable`1<PackageDependency> dependencies);
    public PackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependency> get_Dependencies();
    [NuGet.Packaging.NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageDependencyInfo other);
    [NuGet.Packaging.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class NuGet.Packaging.Core.PackageDependencyInfoComparer : object {
    private IPackageIdentityComparer _identityComparer;
    private PackageDependencyComparer _dependencyComparer;
    [CompilerGeneratedAttribute]
private static PackageDependencyInfoComparer <Default>k__BackingField;
    public static PackageDependencyInfoComparer Default { get; }
    public PackageDependencyInfoComparer(IPackageIdentityComparer identityComparer, PackageDependencyComparer dependencyComparer);
    private static PackageDependencyInfoComparer();
    [CompilerGeneratedAttribute]
public static PackageDependencyInfoComparer get_Default();
    public sealed virtual bool Equals(PackageDependencyInfo x, PackageDependencyInfo y);
    public sealed virtual int GetHashCode(PackageDependencyInfo obj);
}
internal class NuGet.Packaging.Core.PackageIdentity : object {
    private string _id;
    private NuGetVersion _version;
    private static string ToStringFormat;
    public string Id { get; }
    public NuGetVersion Version { get; }
    public bool HasVersion { get; }
    public static PackageIdentityComparer Comparer { get; }
    public PackageIdentity(string id, NuGetVersion version);
    public string get_Id();
    public NuGetVersion get_Version();
    public bool get_HasVersion();
    public sealed virtual bool Equals(PackageIdentity other);
    public virtual bool Equals(PackageIdentity other, VersionComparison versionComparison);
    public sealed virtual int CompareTo(PackageIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PackageIdentityComparer get_Comparer();
    public virtual string ToString();
}
internal class NuGet.Packaging.Core.PackageIdentityComparer : object {
    private IVersionComparer _versionComparer;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <VersionRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <VersionReleaseMetadata>k__BackingField;
    public static PackageIdentityComparer Default { get; }
    internal static PackageIdentityComparer Version { get; }
    internal static PackageIdentityComparer VersionRelease { get; }
    internal static PackageIdentityComparer VersionReleaseMetadata { get; }
    public PackageIdentityComparer(VersionComparison versionComparison);
    public PackageIdentityComparer(IVersionComparer versionComparer);
    private static PackageIdentityComparer();
    [CompilerGeneratedAttribute]
public static PackageIdentityComparer get_Default();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_Version();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_VersionRelease();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_VersionReleaseMetadata();
    internal static PackageIdentityComparer Get(VersionComparison versionComparison);
    public sealed virtual bool Equals(PackageIdentity x, PackageIdentity y);
    public sealed virtual int GetHashCode(PackageIdentity obj);
    public sealed virtual int Compare(PackageIdentity x, PackageIdentity y);
}
internal class NuGet.Packaging.Core.PackageType : object {
    public static Version EmptyVersion;
    public static PackageType Legacy;
    public static PackageType DotnetCliTool;
    public static PackageType Dependency;
    public static PackageType DotnetTool;
    public static PackageType SymbolsPackage;
    public static PackageType DotnetPlatform;
    public static StringComparer PackageTypeNameComparer;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public PackageType(string name, Version version);
    private static PackageType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public virtual bool Equals(object obj);
    public static bool op_Equality(PackageType a, PackageType b);
    public static bool op_Inequality(PackageType a, PackageType b);
    public sealed virtual bool Equals(PackageType other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(PackageType other);
}
internal static class NuGet.Packaging.Core.PackagingCoreConstants : object {
    public static string HashFileExtension;
    public static string NupkgExtension;
    public static string NuspecExtension;
    public static string PackageDownloadMarkerFileExtension;
    public static string NupkgMetadataFileExtension;
    public static string EmptyFolder;
    public static string ForwardSlashEmptyFolder;
    private static PackagingCoreConstants();
}
internal class NuGet.Packaging.Core.PackagingException : Exception {
    private IPackLogMessage _logMessage;
    public PackagingException(string message);
    public PackagingException(NuGetLogCode logCode, string message);
    public PackagingException(NuGetLogCode logCode, string message, Exception innerException);
    public PackagingException(string message, Exception innerException);
    public virtual ILogMessage AsLogMessage();
}
internal class NuGet.Packaging.Core.RepositoryMetadata : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Commit>k__BackingField;
    public string Type { get; public set; }
    public string Url { get; public set; }
    public string Branch { get; public set; }
    public string Commit { get; public set; }
    public RepositoryMetadata(string type, string url, string branch, string commit);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(string value);
    [CompilerGeneratedAttribute]
public string get_Commit();
    [CompilerGeneratedAttribute]
public void set_Commit(string value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RepositoryMetadata a, RepositoryMetadata b);
    public static bool op_Inequality(RepositoryMetadata a, RepositoryMetadata b);
    public sealed virtual bool Equals(RepositoryMetadata other);
    public virtual int GetHashCode();
}
internal class NuGet.Packaging.EmptyFrameworkFolderFile : PhysicalPackageFile {
    public EmptyFrameworkFolderFile(string directoryPathInPackage);
}
internal enum NuGet.Packaging.ExtractionSource : Enum {
    public int value__;
    public static ExtractionSource RestoreCommand;
    public static ExtractionSource DownloadResource;
    public static ExtractionSource NuGetFolderProject;
}
internal class NuGet.Packaging.FallbackPackagePathInfo : object {
    [CompilerGeneratedAttribute]
private VersionFolderPathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    public VersionFolderPathResolver PathResolver { get; }
    public string Id { get; }
    public NuGetVersion Version { get; }
    public FallbackPackagePathInfo(string id, NuGetVersion version, VersionFolderPathResolver resolver);
    [CompilerGeneratedAttribute]
public VersionFolderPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
}
internal class NuGet.Packaging.FallbackPackagePathResolver : object {
    private List`1<VersionFolderPathResolver> _pathResolvers;
    public FallbackPackagePathResolver(INuGetPathContext pathContext);
    public FallbackPackagePathResolver(string userPackageFolder, IEnumerable`1<string> fallbackPackageFolders);
    public string GetPackageDirectory(string packageId, string version);
    public string GetPackageDirectory(string packageId, NuGetVersion version);
    public FallbackPackagePathInfo GetPackageInfo(string packageId, NuGetVersion version);
}
internal class NuGet.Packaging.FrameworkAssemblyReference : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NuGetFramework> <SupportedFrameworks>k__BackingField;
    public string AssemblyName { get; private set; }
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; private set; }
    public FrameworkAssemblyReference(string assemblyName, IEnumerable`1<NuGetFramework> supportedFrameworks);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
private void set_SupportedFrameworks(IEnumerable`1<NuGetFramework> value);
}
internal static class NuGet.Packaging.FrameworkNameUtility : object {
    public static FrameworkName ParseFrameworkNameFromFilePath(string filePath, String& effectivePath);
    public static FrameworkName ParseFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
    public static NuGetFramework ParseNuGetFrameworkFromFilePath(string filePath, String& effectivePath);
    public static NuGetFramework ParseNuGetFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
}
internal class NuGet.Packaging.FrameworkReference : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public FrameworkReference(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual int Compare(FrameworkReference x, FrameworkReference y);
    public sealed virtual bool Equals(FrameworkReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(FrameworkReference other);
}
internal class NuGet.Packaging.FrameworkReferenceGroup : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkReference> <FrameworkReferences>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<FrameworkReference> FrameworkReferences { get; }
    public FrameworkReferenceGroup(NuGetFramework targetFramework, IEnumerable`1<FrameworkReference> frameworkReferences);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public IEnumerable`1<FrameworkReference> get_FrameworkReferences();
    public sealed virtual bool Equals(FrameworkReferenceGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class NuGet.Packaging.FrameworksExtensions : object {
    [ExtensionAttribute]
public static string GetFrameworkString(NuGetFramework self);
}
internal class NuGet.Packaging.FrameworkSpecificGroup : object {
    private NuGetFramework _targetFramework;
    private String[] _items;
    [CompilerGeneratedAttribute]
private bool <HasEmptyFolder>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<string> Items { get; }
    public bool HasEmptyFolder { get; }
    public FrameworkSpecificGroup(NuGetFramework targetFramework, IEnumerable`1<string> items);
    public sealed virtual NuGetFramework get_TargetFramework();
    public IEnumerable`1<string> get_Items();
    [CompilerGeneratedAttribute]
public bool get_HasEmptyFolder();
    public sealed virtual bool Equals(FrameworkSpecificGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface NuGet.Packaging.IAsyncPackageContentReader {
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
}
internal interface NuGet.Packaging.IHashFunction {
    public abstract virtual string GetHash();
    public abstract virtual void Update(Byte[] data, int offset, int count);
}
internal interface NuGet.Packaging.INuspecReader {
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public abstract virtual string GetLanguage();
}
internal interface NuGet.Packaging.IPackageContentReader {
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
}
internal interface NuGet.Packaging.IPackageDownloader {
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public abstract virtual IAsyncPackageContentReader get_ContentReader();
    public abstract virtual IAsyncPackageCoreReader get_CoreReader();
    public abstract virtual ISignedPackageReader get_SignedPackageReader();
    public abstract virtual string get_Source();
    public abstract virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public abstract virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public abstract virtual void SetThrottle(SemaphoreSlim throttle);
}
internal interface NuGet.Packaging.IPackageFile {
    public string Path { get; }
    public string EffectivePath { get; }
    [ObsoleteAttribute("Use NuGetFramework instead. This property will be null for any frameworks net5.0 or above.")]
public FrameworkName TargetFramework { get; }
    public NuGetFramework NuGetFramework { get; }
    public DateTimeOffset LastWriteTime { get; }
    public abstract virtual string get_Path();
    public abstract virtual string get_EffectivePath();
    public abstract virtual FrameworkName get_TargetFramework();
    public abstract virtual NuGetFramework get_NuGetFramework();
    public abstract virtual DateTimeOffset get_LastWriteTime();
    public abstract virtual Stream GetStream();
}
internal interface NuGet.Packaging.IPackageMetadata {
    public string Id { get; }
    public NuGetVersion Version { get; }
    public string Title { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public Uri IconUrl { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public bool DevelopmentDependency { get; }
    public string Description { get; }
    public string Summary { get; }
    public string ReleaseNotes { get; }
    public string Language { get; }
    public string Tags { get; }
    public bool Serviceable { get; }
    public string Copyright { get; }
    public string Icon { get; }
    public string Readme { get; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; }
    public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; }
    public Version MinClientVersion { get; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; }
    public IEnumerable`1<PackageType> PackageTypes { get; }
    public RepositoryMetadata Repository { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; }
    public abstract virtual string get_Id();
    public abstract virtual NuGetVersion get_Version();
    public abstract virtual string get_Title();
    public abstract virtual IEnumerable`1<string> get_Authors();
    public abstract virtual IEnumerable`1<string> get_Owners();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual bool get_DevelopmentDependency();
    public abstract virtual string get_Description();
    public abstract virtual string get_Summary();
    public abstract virtual string get_ReleaseNotes();
    public abstract virtual string get_Language();
    public abstract virtual string get_Tags();
    public abstract virtual bool get_Serviceable();
    public abstract virtual string get_Copyright();
    public abstract virtual string get_Icon();
    public abstract virtual string get_Readme();
    public abstract virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    public abstract virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public abstract virtual Version get_MinClientVersion();
    public abstract virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    public abstract virtual IEnumerable`1<PackageType> get_PackageTypes();
    public abstract virtual RepositoryMetadata get_Repository();
    public abstract virtual LicenseMetadata get_LicenseMetadata();
    public abstract virtual IEnumerable`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
}
internal interface NuGet.Packaging.IPackageResolver {
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
}
internal class NuGet.Packaging.LicenseMetadata : object {
    public static Version EmptyVersion;
    public static Version CurrentVersion;
    public static Uri LicenseFileDeprecationUrl;
    public static string LicenseServiceLinkTemplate;
    [CompilerGeneratedAttribute]
private LicenseType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <LicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <WarningsAndErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public LicenseType Type { get; }
    public string License { get; }
    public NuGetLicenseExpression LicenseExpression { get; }
    public IReadOnlyList`1<string> WarningsAndErrors { get; }
    public Version Version { get; }
    public Uri LicenseUrl { get; }
    public LicenseMetadata(LicenseType type, string license, NuGetLicenseExpression expression, IReadOnlyList`1<string> warningsAndErrors, Version version);
    private static LicenseMetadata();
    [CompilerGeneratedAttribute]
public LicenseType get_Type();
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_LicenseExpression();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_WarningsAndErrors();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public sealed virtual bool Equals(LicenseMetadata other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Uri get_LicenseUrl();
    private static string GenerateLicenseServiceLink(string license);
}
internal class NuGet.Packaging.Licenses.ExceptionData : object {
    [CompilerGeneratedAttribute]
private string <LicenseExceptionID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecatedLicenseId>k__BackingField;
    public string LicenseExceptionID { get; }
    public bool IsDeprecatedLicenseId { get; }
    public ExceptionData(string licenseID, bool isDeprecatedLicenseId);
    [CompilerGeneratedAttribute]
public string get_LicenseExceptionID();
    [CompilerGeneratedAttribute]
public bool get_IsDeprecatedLicenseId();
}
internal class NuGet.Packaging.Licenses.LicenseData : object {
    [CompilerGeneratedAttribute]
private string <LicenseID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOsiApproved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecatedLicenseId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFsfLibre>k__BackingField;
    public string LicenseID { get; }
    public bool IsOsiApproved { get; }
    public bool IsDeprecatedLicenseId { get; }
    public bool IsFsfLibre { get; }
    public LicenseData(string licenseID, bool isOsiApproved, bool isDeprecatedLicenseId, bool isFsfLibre);
    [CompilerGeneratedAttribute]
public string get_LicenseID();
    [CompilerGeneratedAttribute]
public bool get_IsOsiApproved();
    [CompilerGeneratedAttribute]
public bool get_IsDeprecatedLicenseId();
    [CompilerGeneratedAttribute]
public bool get_IsFsfLibre();
}
internal class NuGet.Packaging.Licenses.LicenseExpressionToken : object {
    [CompilerGeneratedAttribute]
private LicenseTokenType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    internal LicenseTokenType TokenType { get; }
    internal string Value { get; }
    internal LicenseExpressionToken(string value, LicenseTokenType tokenType);
    [CompilerGeneratedAttribute]
internal LicenseTokenType get_TokenType();
    [CompilerGeneratedAttribute]
internal string get_Value();
    public virtual string ToString();
}
internal class NuGet.Packaging.Licenses.LicenseExpressionTokenizer : object {
    private string _value;
    internal LicenseExpressionTokenizer(string value);
    internal bool HasValidCharacters();
    [IteratorStateMachineAttribute("NuGet.Packaging.Licenses.LicenseExpressionTokenizer/<Tokenize>d__3")]
internal IEnumerable`1<LicenseExpressionToken> Tokenize();
    private LicenseExpressionToken ParseBracket(char bracket);
    private LicenseExpressionToken ParseTokenType(string token);
}
internal enum NuGet.Packaging.Licenses.LicenseExpressionType : Enum {
    public int value__;
    public static LicenseExpressionType License;
    public static LicenseExpressionType Operator;
}
internal abstract class NuGet.Packaging.Licenses.LicenseOperator : NuGetLicenseExpression {
    [CompilerGeneratedAttribute]
private LicenseOperatorType <OperatorType>k__BackingField;
    public LicenseOperatorType OperatorType { get; }
    protected LicenseOperator(LicenseOperatorType operatorType);
    [CompilerGeneratedAttribute]
public LicenseOperatorType get_OperatorType();
}
internal enum NuGet.Packaging.Licenses.LicenseOperatorType : Enum {
    public int value__;
    public static LicenseOperatorType WithOperator;
    public static LicenseOperatorType LogicalOperator;
}
internal enum NuGet.Packaging.Licenses.LicenseTokenType : Enum {
    public int value__;
    public static LicenseTokenType WITH;
    public static LicenseTokenType AND;
    public static LicenseTokenType OR;
    public static LicenseTokenType OPENING_BRACKET;
    public static LicenseTokenType CLOSING_BRACKET;
    public static LicenseTokenType IDENTIFIER;
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Licenses.LicenseTokenTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsOperator(LicenseTokenType tokenType);
    [ExtensionAttribute]
public static bool IsValidPrecedingToken(LicenseTokenType current, LicenseTokenType precedingToken);
}
internal class NuGet.Packaging.Licenses.LogicalOperator : LicenseOperator {
    [CompilerGeneratedAttribute]
private LogicalOperatorType <LogicalOperatorType>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <Right>k__BackingField;
    public LogicalOperatorType LogicalOperatorType { get; }
    public NuGetLicenseExpression Left { get; }
    public NuGetLicenseExpression Right { get; }
    public LogicalOperator(LogicalOperatorType logicalOperatorType, NuGetLicenseExpression left, NuGetLicenseExpression right);
    [CompilerGeneratedAttribute]
public LogicalOperatorType get_LogicalOperatorType();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_Left();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_Right();
    public virtual string ToString();
}
internal enum NuGet.Packaging.Licenses.LogicalOperatorType : Enum {
    public int value__;
    public static LogicalOperatorType And;
    public static LogicalOperatorType Or;
}
internal class NuGet.Packaging.Licenses.NuGetLicense : NuGetLicenseExpression {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Plus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStandardLicense>k__BackingField;
    internal static string UNLICENSED;
    public string Identifier { get; }
    public bool Plus { get; }
    public bool IsStandardLicense { get; }
    private NuGetLicense(string identifier, bool plus, bool isStandardLicense);
    private static NuGetLicense();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public bool get_Plus();
    [CompilerGeneratedAttribute]
public bool get_IsStandardLicense();
    internal static NuGetLicense ParseIdentifier(string licenseIdentifier, bool allowUnlicensed);
    private static bool HasValidCharacters(string value);
    private static NuGetLicense ProcessLicenseNotInStandardData(string licenseIdentifier, bool plus, bool allowUnlicensed);
    public virtual string ToString();
}
internal static class NuGet.Packaging.Licenses.NuGetLicenseData : object {
    [CompilerGeneratedAttribute]
private static string <LicenseListVersion>k__BackingField;
    public static IReadOnlyDictionary`2<string, LicenseData> LicenseList;
    public static IReadOnlyDictionary`2<string, ExceptionData> ExceptionList;
    public static string LicenseListVersion { get; }
    private static NuGetLicenseData();
    [CompilerGeneratedAttribute]
public static string get_LicenseListVersion();
}
internal class NuGet.Packaging.Licenses.NuGetLicenseException : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; }
    private NuGetLicenseException(string identifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    internal static NuGetLicenseException ParseIdentifier(string exceptionIdentifier);
    public virtual string ToString();
}
internal abstract class NuGet.Packaging.Licenses.NuGetLicenseExpression : object {
    [CompilerGeneratedAttribute]
private LicenseExpressionType <Type>k__BackingField;
    public LicenseExpressionType Type { get; protected set; }
    [CompilerGeneratedAttribute]
public LicenseExpressionType get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(LicenseExpressionType value);
    public static NuGetLicenseExpression Parse(string expression);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions : object {
    [ExtensionAttribute]
public static bool HasOnlyStandardIdentifiers(NuGetLicenseExpression expression);
    [ExtensionAttribute]
public static void OnEachLeafNode(NuGetLicenseExpression expression, Action`1<NuGetLicense> licenseProcessor, Action`1<NuGetLicenseException> exceptionProcessor);
    [ExtensionAttribute]
public static bool IsUnlicensed(NuGetLicense license);
    [ExtensionAttribute]
public static bool IsUnlicensed(NuGetLicenseExpression expression);
}
internal static class NuGet.Packaging.Licenses.NuGetLicenseExpressionParser : object {
    internal static NuGetLicenseExpression Parse(string expression);
    private static IEnumerable`1<LicenseExpressionToken> GetTokens(string expression);
    private static void ProcessOperators(Stack`1<LicenseExpressionToken> operatorStack, Stack`1<Tuple`2<bool, object>> operandStack);
    private static Tuple`2<bool, object> PopIfNotEmpty(Stack`1<Tuple`2<bool, object>> operandStack);
}
internal class NuGet.Packaging.Licenses.NuGetLicenseExpressionParsingException : Exception {
    public NuGetLicenseExpressionParsingException(string message);
    public NuGetLicenseExpressionParsingException(string message, Exception innerException);
    protected NuGetLicenseExpressionParsingException(SerializationInfo info, StreamingContext context);
}
internal class NuGet.Packaging.Licenses.WithOperator : LicenseOperator {
    [CompilerGeneratedAttribute]
private NuGetLicense <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseException <Exception>k__BackingField;
    public NuGetLicense License { get; private set; }
    public NuGetLicenseException Exception { get; private set; }
    public WithOperator(NuGetLicense license, NuGetLicenseException exception);
    [CompilerGeneratedAttribute]
public NuGetLicense get_License();
    [CompilerGeneratedAttribute]
private void set_License(NuGetLicense value);
    [CompilerGeneratedAttribute]
public NuGetLicenseException get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(NuGetLicenseException value);
    public virtual string ToString();
}
internal enum NuGet.Packaging.LicenseType : Enum {
    public int value__;
    public static LicenseType File;
    public static LicenseType Expression;
}
[ObsoleteAttribute("Use NuGet.Protocol.LocalPackageArchiveDownloader")]
internal class NuGet.Packaging.LocalPackageArchiveDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private string _packageFilePath;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private Lazy`1<FileStream> _sourceStream;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public LocalPackageArchiveDownloader(string source, string packageFilePath, PackageIdentity packageIdentity, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Packaging.LocalPackageArchiveDownloader/<CopyNupkgFileToAsync>d__19")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetSourceStream();
    private void ThrowIfDisposed();
}
internal class NuGet.Packaging.Manifest : object {
    [CompilerGeneratedAttribute]
private ManifestMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFilesNode>k__BackingField;
    public ManifestMetadata Metadata { get; }
    public ICollection`1<ManifestFile> Files { get; }
    public bool HasFilesNode { get; }
    public Manifest(ManifestMetadata metadata);
    public Manifest(ManifestMetadata metadata, ICollection`1<ManifestFile> files);
    [CompilerGeneratedAttribute]
public ManifestMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestFile> get_Files();
    [CompilerGeneratedAttribute]
public bool get_HasFilesNode();
    public void Save(Stream stream);
    public void Save(Stream stream, bool generateBackwardsCompatible);
    public void Save(Stream stream, int minimumManifestVersion);
    public void Save(Stream stream, int minimumManifestVersion, bool generateBackwardsCompatible);
    public static Manifest ReadFrom(Stream stream, bool validateSchema);
    public static Manifest ReadFrom(Stream stream, Func`2<string, string> propertyProvider, bool validateSchema);
    private static string GetSchemaNamespace(XDocument document);
    public static Manifest Create(IPackageMetadata metadata);
    private static void ValidateManifestSchema(XDocument document, string schemaNamespace);
    private static void CheckSchemaVersion(XDocument document);
    private static string GetPackageId(XElement metadataElement);
    private static XElement GetMetadataElement(XDocument document);
    public static void Validate(Manifest manifest);
    private static void ValidateDependencyGroups(IPackageMetadata metadata);
    private static void ValidateDependencyVersion(PackageDependency dependency);
}
internal class NuGet.Packaging.ManifestContentFiles : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flatten>k__BackingField;
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public string BuildAction { get; public set; }
    public string CopyToOutput { get; public set; }
    public string Flatten { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(string value);
    [CompilerGeneratedAttribute]
public string get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(string value);
    [CompilerGeneratedAttribute]
public string get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(string value);
}
internal class NuGet.Packaging.ManifestFile : object {
    private static Char[] _invalidSourceCharacters;
    internal static Char[] ReferenceFileInvalidCharacters;
    private static Char[] _invalidTargetChars;
    private string _target;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    public string Source { get; public set; }
    public string Target { get; public set; }
    public string Exclude { get; public set; }
    private static ManifestFile();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    public string get_Target();
    public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestFile/<Validate>d__15")]
public IEnumerable`1<string> Validate();
}
internal class NuGet.Packaging.ManifestMetadata : object {
    private string _minClientVersionString;
    private IEnumerable`1<string> _authors;
    private IEnumerable`1<string> _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitRequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    private IEnumerable`1<PackageDependencyGroup> _dependencyGroups;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    private IEnumerable`1<PackageReferenceSet> _packageAssemblyReferences;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [ManifestVersionAttribute("5")]
public string MinClientVersionString { get; public set; }
    public Version MinClientVersion { get; private set; }
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public string Title { get; public set; }
    public IEnumerable`1<string> Authors { get; public set; }
    public IEnumerable`1<string> Owners { get; public set; }
    public Uri IconUrl { get; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool EmitRequireLicenseAcceptance { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    [ManifestVersionAttribute("2")]
public string ReleaseNotes { get; public set; }
    [ManifestVersionAttribute("2")]
public string Copyright { get; public set; }
    public string Language { get; public set; }
    public string Tags { get; public set; }
    public string Readme { get; public set; }
    public bool Serviceable { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; public set; }
    public IEnumerable`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; public set; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; public set; }
    [ManifestVersionAttribute("2")]
public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; public set; }
    public IEnumerable`1<PackageType> PackageTypes { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public ManifestMetadata(IPackageMetadata copy);
    public string get_MinClientVersionString();
    public void set_MinClientVersionString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
private void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public sealed virtual IEnumerable`1<string> get_Authors();
    public void set_Authors(IEnumerable`1<string> value);
    public sealed virtual IEnumerable`1<string> get_Owners();
    public void set_Owners(IEnumerable`1<string> value);
    public void SetIconUrl(string iconUrl);
    public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    public void SetLicenseUrl(string licenseUrl);
    public sealed virtual Uri get_LicenseUrl();
    public void SetProjectUrl(string projectUrl);
    public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitRequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_EmitRequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public void set_DependencyGroups(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferenceGroups(IEnumerable`1<FrameworkReferenceGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferences(IEnumerable`1<FrameworkAssemblyReference> value);
    public sealed virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public void set_PackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> value);
    private static IEnumerable`1<PackageReferenceSet> MergePackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> referenceSets);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IEnumerable`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(IEnumerable`1<PackageType> value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    private static IEnumerable`1<PackageDependencyGroup> MergeDependencyGroups(IEnumerable`1<PackageDependencyGroup> actualDependencyGroups);
    private static PackageDependencyGroup CreatePackageDependencyGroup(PackageDependencyGroup dependencyGroup);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestMetadata/<Validate>d__125")]
public IEnumerable`1<string> Validate();
}
internal static class NuGet.Packaging.ManifestReader : object {
    private static String[] RequiredElements;
    private static ManifestReader();
    public static Manifest ReadManifest(XDocument document);
    private static ManifestMetadata ReadMetadata(XElement xElement);
    private static void ReadMetadataValue(ManifestMetadata manifestMetadata, XElement element, HashSet`1<string> allElements);
    private static IEnumerable`1<FrameworkReferenceGroup> ReadFrameworkReferenceGroups(XElement frameworkReferenceGroupsElement);
    private static LicenseMetadata ReadLicenseMetadata(XElement licenseNode);
    private static List`1<ManifestContentFiles> ReadContentFiles(XElement contentFilesElement);
    private static List`1<PackageReferenceSet> ReadReferenceSets(XElement referencesElement);
    public static List`1<string> ReadReference(XElement referenceElement, bool throwIfEmpty);
    private static List`1<FrameworkAssemblyReference> ReadFrameworkAssemblies(XElement frameworkElement);
    private static List`1<PackageDependencyGroup> ReadDependencyGroups(XElement dependenciesElement);
    private static ISet`1<PackageDependency> ReadDependencies(XElement containerElement);
    private static List`1<ManifestFile> ReadFilesList(XElement xElement);
    private static RepositoryMetadata ReadRepository(XElement element);
}
internal static class NuGet.Packaging.ManifestSchemaUtility : object {
    internal static string SchemaVersionV1;
    internal static string SchemaVersionV2;
    internal static string SchemaVersionV3;
    internal static string SchemaVersionV4;
    internal static string SchemaVersionV5;
    internal static string SchemaVersionV6;
    private static String[] VersionToSchemaMappings;
    private static ConcurrentDictionary`2<string, XmlSchemaSet> _manifestSchemaSetCache;
    private static ManifestSchemaUtility();
    public static int GetVersionFromNamespace(string namespace);
    public static string GetSchemaNamespace(int version);
    public static XmlSchemaSet GetManifestSchemaSet(string schemaNamespace);
    public static bool IsKnownSchema(string schemaNamespace);
}
[AttributeUsageAttribute("128")]
internal class NuGet.Packaging.ManifestVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; private set; }
    public ManifestVersionAttribute(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
}
internal static class NuGet.Packaging.ManifestVersionUtility : object {
    public static int DefaultVersion;
    public static int SemverVersion;
    public static int TargetFrameworkSupportForDependencyContentsAndToolsVersion;
    public static int TargetFrameworkSupportForReferencesVersion;
    public static int XdtTransformationVersion;
    public static int GetManifestVersion(ManifestMetadata metadata);
    private static int GetMaxVersionFromMetadata(ManifestMetadata metadata);
    private static int GetVersionFromObject(object obj);
    private static int GetVersionFromPropertyInfo(object obj, PropertyInfo property);
    private static int VisitList(IEnumerable list);
    private static Nullable`1<int> GetPropertyVersion(PropertyInfo property);
}
internal class NuGet.Packaging.MinClientVersionException : PackagingException {
    public MinClientVersionException(string message);
    public virtual ILogMessage AsLogMessage();
}
internal static class NuGet.Packaging.MinClientVersionUtility : object {
    private static NuGetVersion _clientVersion;
    public static void VerifyMinClientVersion(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuGetVersion packageMinClientVersion);
    public static NuGetVersion GetNuGetClientVersion();
}
internal static class NuGet.Packaging.NuGetExtractionFileIO : object {
    private static int _unixPermissions;
    private static Lazy`1<Func`2<string, FileStream>> _createFileMethod;
    private static NuGetExtractionFileIO();
    internal static FileStream CreateFile(string path);
    private static Func`2<string, FileStream> CreateFileMethodSelector();
    private static FileStream DotnetCoreCreateFile(string path);
    private static FileStream MonoPosixCreateFile(string path);
    private static void ApplyUMaskToUnixPermissions();
    private static bool ApplyUMaskToUnixPermissionsFromProcess();
    private static void ApplyUMaskToUnixPermissionsFromLibc();
    private static int PosixCreate(string pathname, int mode);
    private static int PosixChmod(string pathname, int mode);
    private static int PosixUMask(int mask);
}
internal class NuGet.Packaging.NupkgMetadataFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public int Version { get; public set; }
    public string ContentHash { get; public set; }
    public string Source { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    public sealed virtual bool Equals(NupkgMetadataFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class NuGet.Packaging.NupkgMetadataFileFormat : object {
    public static int Version;
    private static string VersionProperty;
    private static string HashProperty;
    private static string SourceProperty;
    private static JsonSerializer JsonSerializer;
    private static NupkgMetadataFileFormat();
    public static NupkgMetadataFile Read(string filePath);
    public static NupkgMetadataFile Read(string filePath, ILogger log);
    public static NupkgMetadataFile Read(Stream stream, ILogger log, string path);
    public static NupkgMetadataFile Read(TextReader reader, ILogger log, string path);
    public static void Write(string filePath, NupkgMetadataFile hashFile);
    public static void Write(Stream stream, NupkgMetadataFile hashFile);
    public static void Write(TextWriter textWriter, NupkgMetadataFile hashFile);
    private static JsonSerializerSettings GetSerializerSettings();
}
internal class NuGet.Packaging.NuspecReader : NuspecCoreReaderBase {
    private static string Dependencies;
    private static string Group;
    private static string TargetFramework;
    private static string Dependency;
    private static string References;
    private static string Reference;
    private static string File;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Language;
    private static string ContentFiles;
    private static string Files;
    private static string BuildAction;
    private static string Flatten;
    private static string CopyToOutput;
    private static string IncludeFlags;
    private static string ExcludeFlags;
    private static string LicenseUrl;
    private static string Repository;
    private static string Icon;
    private static string Readme;
    private static Char[] CommaArray;
    private IFrameworkNameProvider _frameworkProvider;
    private static List`1<string> EmptyList;
    public NuspecReader(string path);
    public NuspecReader(string path, IFrameworkNameProvider frameworkProvider);
    public NuspecReader(Stream stream);
    public NuspecReader(XDocument xml);
    public NuspecReader(Stream stream, IFrameworkNameProvider frameworkProvider, bool leaveStreamOpen);
    public NuspecReader(XDocument xml, IFrameworkNameProvider frameworkProvider);
    private static NuspecReader();
    public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetDependencyGroups>d__31")]
public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups(bool useStrictVersionCheck);
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetReferenceGroups>d__32")]
public IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    [ObsoleteAttribute("GetFrameworkReferenceGroups() is deprecated. Please use GetFrameworkAssemblyGroups() instead.")]
public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkAssemblyGroups();
    public string GetLanguage();
    public string GetLicenseUrl();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetContentFiles>d__37")]
public IEnumerable`1<ContentFilesEntry> GetContentFiles();
    public string GetTitle();
    public string GetAuthors();
    public string GetTags();
    public string GetOwners();
    public string GetDescription();
    public string GetReleaseNotes();
    public string GetSummary();
    public string GetProjectUrl();
    public string GetIconUrl();
    public string GetCopyright();
    public RepositoryMetadata GetRepositoryMetadata();
    public LicenseMetadata GetLicenseMetadata();
    private static IList`1<string> GetNonStandardLicenseIdentifiers(NuGetLicenseExpression expression);
    public bool GetRequireLicenseAcceptance();
    public IEnumerable`1<FrameworkReferenceGroup> GetFrameworkRefGroups();
    public string GetIcon();
    public string GetReadme();
    private Nullable`1<bool> AttributeAsNullableBool(XElement element, string attributeName);
    private static string GetAttributeValue(XElement element, string attributeName);
    private static List`1<string> GetFlags(string flags);
    private HashSet`1<PackageDependency> GetPackageDependencies(IEnumerable`1<XElement> nodes, bool useStrictVersionCheck);
}
internal class NuGet.Packaging.PackageArchiveReader : PackageReaderBase {
    private ZipArchive _zipArchive;
    private SigningSpecifications _signingSpecifications;
    private IEnvironmentVariableReader _environmentVariableReader;
    [CompilerGeneratedAttribute]
private Stream <ZipReadStream>k__BackingField;
    private Nullable`1<bool> _isSigned;
    protected SigningSpecifications SigningSpecifications { get; }
    protected Stream ZipReadStream { get; protected set; }
    private PackageArchiveReader(IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    internal PackageArchiveReader(Stream stream, IEnvironmentVariableReader environmentVariableReader);
    public PackageArchiveReader(Stream stream);
    public PackageArchiveReader(Stream stream, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(ZipArchive zipArchive);
    public PackageArchiveReader(ZipArchive zipArchive, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(string filePath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    protected SigningSpecifications get_SigningSpecifications();
    [CompilerGeneratedAttribute]
protected Stream get_ZipReadStream();
    [CompilerGeneratedAttribute]
protected void set_ZipReadStream(Stream value);
    public virtual IEnumerable`1<string> GetFiles();
    public virtual IEnumerable`1<string> GetFiles(string folder);
    public virtual Stream GetStream(string path);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<CopyNupkgAsync>d__22")]
public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public string ExtractFile(string packageFile, string targetFilePath, ILogger logger);
    public ZipArchiveEntry GetEntry(string packageFile);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<EnumeratePackageEntries>d__28")]
public IEnumerable`1<ZipFilePair> EnumeratePackageEntries(IEnumerable`1<string> packageFiles, string packageDirectory);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<ValidatePackageEntriesAsync>d__29")]
public Task ValidatePackageEntriesAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<GetPrimarySignatureAsync>d__30")]
public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<ValidateIntegrityAsync>d__32")]
public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithmName, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    protected void ThrowIfZipReadStreamIsNull();
    private string GetContentHashForSignedPackage(CancellationToken token);
}
internal class NuGet.Packaging.PackageBuilder : object {
    private static Uri DefaultUri;
    private static DateTime ZipFormatMinDate;
    private static DateTime ZipFormatMaxDate;
    internal static string ManifestRelationType;
    private bool _includeEmptyDirectories;
    private bool _deterministic;
    private ILogger _logger;
    public static int MaxIconFileSize;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSnapshotVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitRequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IPackageFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageReferenceSet> <PackageAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    private static Char[] HexValues;
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public bool HasSnapshotVersion { get; public set; }
    public string Title { get; public set; }
    public ISet`1<string> Authors { get; private set; }
    public ISet`1<string> Owners { get; private set; }
    public Uri IconUrl { get; public set; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool EmitRequireLicenseAcceptance { get; public set; }
    public bool Serviceable { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public string OutputName { get; public set; }
    public ISet`1<string> Tags { get; private set; }
    public string Readme { get; public set; }
    public Dictionary`2<string, string> Properties { get; private set; }
    public string Copyright { get; public set; }
    public Collection`1<PackageDependencyGroup> DependencyGroups { get; private set; }
    public ICollection`1<IPackageFile> Files { get; private set; }
    public Collection`1<FrameworkAssemblyReference> FrameworkReferences { get; private set; }
    public Collection`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; private set; }
    public IList`1<NuGetFramework> TargetFrameworks { get; public set; }
    public ICollection`1<ManifestContentFiles> ContentFiles { get; private set; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public ICollection`1<PackageType> PackageTypes { get; public set; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Owners { get; }
    private string NuGet.Packaging.IPackageMetadata.Tags { get; }
    private IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences { get; }
    private IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.DependencyGroups { get; }
    private IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.FrameworkReferences { get; }
    private IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.ContentFiles { get; }
    private IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.PackageTypes { get; }
    private IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.FrameworkReferenceGroups { get; }
    public Version MinClientVersion { get; public set; }
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic);
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic, ILogger logger);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic, ILogger logger);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic);
    public PackageBuilder(Stream stream, string basePath);
    public PackageBuilder(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public PackageBuilder(bool deterministic);
    public PackageBuilder(bool deterministic, ILogger logger);
    private PackageBuilder(bool includeEmptyDirectories, bool deterministic);
    private PackageBuilder(bool includeEmptyDirectories, bool deterministic, ILogger logger);
    private static PackageBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    [CompilerGeneratedAttribute]
public bool get_HasSnapshotVersion();
    [CompilerGeneratedAttribute]
public void set_HasSnapshotVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitRequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_EmitRequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public Collection`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
private void set_DependencyGroups(Collection`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public ICollection`1<IPackageFile> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(ICollection`1<IPackageFile> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferences(Collection`1<FrameworkAssemblyReference> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferenceGroups(Collection`1<FrameworkReferenceGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
private void set_ContentFiles(ICollection`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    [CompilerGeneratedAttribute]
public void set_PackageAssemblyReferences(ICollection`1<PackageReferenceSet> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(ICollection`1<PackageType> value);
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Owners();
    private sealed virtual override string NuGet.Packaging.IPackageMetadata.get_Tags();
    private sealed virtual override IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.get_PackageAssemblyReferences();
    private sealed virtual override IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.get_DependencyGroups();
    private sealed virtual override IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.get_FrameworkReferences();
    private sealed virtual override IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.get_ContentFiles();
    private sealed virtual override IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.get_PackageTypes();
    private sealed virtual override IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    public void Save(Stream stream);
    private static Byte[] ReadAllBytes(Stream stream);
    private string CalcPsmdcpName();
    internal static string EncodeHexString(Byte[] sArray);
    private static string CreatorInfo();
    private static int DetermineMinimumSchemaVersion(ICollection`1<IPackageFile> Files, ICollection`1<PackageDependencyGroup> package);
    private static bool RequiresV4TargetFrameworkSchema(ICollection`1<IPackageFile> files);
    private static bool HasContentFilesV2(ICollection`1<IPackageFile> contentFiles);
    private static bool HasIncludeExclude(IEnumerable`1<PackageDependencyGroup> dependencyGroups);
    private static bool HasXdtTransformFile(ICollection`1<IPackageFile> contentFiles);
    private static void ValidateDependencies(SemanticVersion version, IEnumerable`1<PackageDependencyGroup> dependencies);
    public static void ValidateReferenceAssemblies(IEnumerable`1<IPackageFile> files, IEnumerable`1<PackageReferenceSet> packageAssemblyReferences);
    private static void ValidateFrameworkAssemblies(IEnumerable`1<FrameworkAssemblyReference> references, IEnumerable`1<FrameworkReferenceGroup> referenceGroups);
    private static IPackageFile FindFileInPackage(string filePath, IEnumerable`1<IPackageFile> packageFiles, String& filePathIncorrectCase);
    private void ValidateFilesUnique(IEnumerable`1<IPackageFile> files);
    private void ValidateLicenseFile(IEnumerable`1<IPackageFile> files, LicenseMetadata licenseMetadata);
    private void ValidateIconFile(IEnumerable`1<IPackageFile> files, string iconPath);
    private static void ValidateFileFrameworks(IEnumerable`1<IPackageFile> files);
    private void ValidateReadmeFile(IEnumerable`1<IPackageFile> files, string readmePath);
    private void ReadManifest(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public void Populate(ManifestMetadata manifestMetadata);
    public void PopulateFiles(string basePath, IEnumerable`1<ManifestFile> files);
    private ZipArchiveEntry CreateEntry(ZipArchive package, string entryName, CompressionLevel compressionLevel);
    private static ZipArchiveEntry CreatePackageFileEntry(ZipArchive package, string entryName, DateTimeOffset timeOffset, CompressionLevel compressionLevel, StringBuilder warningMessage);
    private void WriteManifest(ZipArchive package, int minimumManifestVersion, string psmdcpPath);
    private HashSet`1<string> WriteFiles(ZipArchive package, HashSet`1<string> filesWithoutExtensions);
    public void AddFiles(string basePath, string source, string destination, string exclude);
    internal static IEnumerable`1<PhysicalPackageFile> ResolveSearchPattern(string basePath, string searchPath, string targetPath, bool includeEmptyDirectories);
    internal static string ResolvePackagePath(string searchDirectory, string searchPattern, string fullPath, string targetPath);
    private static bool IsKnownFolder(string targetPath);
    private static void ExcludeFiles(List`1<PhysicalPackageFile> searchFiles, string basePath, string exclude);
    private void CreatePart(ZipArchive package, string path, Stream sourceStream, DateTimeOffset lastWriteTime, StringBuilder warningMessage);
    internal static string CreatePartEntryName(string path);
    internal static string GetStringForPartUri(string escapedPath);
    private static IEnumerable`1<string> ParseTags(string tags);
    private void WriteOpcManifestRelationship(ZipArchive package, string path, string psmdcpPath);
    private void WriteOpcContentTypes(ZipArchive package, HashSet`1<string> extensions, HashSet`1<string> filesWithoutExtensions);
    private void WriteOpcPackageProperties(ZipArchive package, string psmdcpPath);
    private string GenerateRelationshipId(string path);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.PackageCreation.Resources.NuGetResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotCreateEmptyPackage { get; }
    internal static string DependencyHasInvalidVersion { get; }
    internal static string DuplicateDependenciesDefined { get; }
    internal static string FoundDuplicateFile { get; }
    internal static string IconCannotOpenFile { get; }
    internal static string IconErrorEmpty { get; }
    internal static string IconInvalidExtension { get; }
    internal static string IconMaxFileSizeExceeded { get; }
    internal static string IconMissingRequiredValue { get; }
    internal static string IconNoFileElement { get; }
    internal static string IconNoFileElementWithHint { get; }
    internal static string IncompatibleSchema { get; }
    internal static string InvalidPackageId { get; }
    internal static string Manifest_DependenciesHasMixedElements { get; }
    internal static string Manifest_ExcludeContainsInvalidCharacters { get; }
    internal static string Manifest_IdMaxLengthExceeded { get; }
    internal static string Manifest_InvalidMinClientVersion { get; }
    internal static string Manifest_InvalidReference { get; }
    internal static string Manifest_InvalidReferenceFile { get; }
    internal static string Manifest_LicenseFileExtensionIsInvalid { get; }
    internal static string Manifest_LicenseFileIsNotInNupkg { get; }
    internal static string Manifest_LicenseFileIsNotInNupkgWithHint { get; }
    internal static string Manifest_LicenseUrlCannotBeUsedWithLicenseMetadata { get; }
    internal static string Manifest_PropertyValueReadFailure { get; }
    internal static string Manifest_ReferencesHasMixedElements { get; }
    internal static string Manifest_ReferencesIsEmpty { get; }
    internal static string Manifest_RequiredElementMissing { get; }
    internal static string Manifest_RequiredMetadataMissing { get; }
    internal static string Manifest_RequireLicenseAcceptanceRequiresEmit { get; }
    internal static string Manifest_RequireLicenseAcceptanceRequiresLicenseUrl { get; }
    internal static string Manifest_SourceContainsInvalidCharacters { get; }
    internal static string Manifest_TargetContainsInvalidCharacters { get; }
    internal static string Manifest_UriCannotBeEmpty { get; }
    internal static string PackageAuthoring_FileNotFound { get; }
    internal static string ReadmeCannotOpenFile { get; }
    internal static string ReadmeErrorEmpty { get; }
    internal static string ReadmeFileExtensionIsInvalid { get; }
    internal static string ReadmeMissingRequiredValue { get; }
    internal static string ReadmeNoFileElement { get; }
    internal static string UnknownSchemaVersion { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotCreateEmptyPackage();
    internal static string get_DependencyHasInvalidVersion();
    internal static string get_DuplicateDependenciesDefined();
    internal static string get_FoundDuplicateFile();
    internal static string get_IconCannotOpenFile();
    internal static string get_IconErrorEmpty();
    internal static string get_IconInvalidExtension();
    internal static string get_IconMaxFileSizeExceeded();
    internal static string get_IconMissingRequiredValue();
    internal static string get_IconNoFileElement();
    internal static string get_IconNoFileElementWithHint();
    internal static string get_IncompatibleSchema();
    internal static string get_InvalidPackageId();
    internal static string get_Manifest_DependenciesHasMixedElements();
    internal static string get_Manifest_ExcludeContainsInvalidCharacters();
    internal static string get_Manifest_IdMaxLengthExceeded();
    internal static string get_Manifest_InvalidMinClientVersion();
    internal static string get_Manifest_InvalidReference();
    internal static string get_Manifest_InvalidReferenceFile();
    internal static string get_Manifest_LicenseFileExtensionIsInvalid();
    internal static string get_Manifest_LicenseFileIsNotInNupkg();
    internal static string get_Manifest_LicenseFileIsNotInNupkgWithHint();
    internal static string get_Manifest_LicenseUrlCannotBeUsedWithLicenseMetadata();
    internal static string get_Manifest_PropertyValueReadFailure();
    internal static string get_Manifest_ReferencesHasMixedElements();
    internal static string get_Manifest_ReferencesIsEmpty();
    internal static string get_Manifest_RequiredElementMissing();
    internal static string get_Manifest_RequiredMetadataMissing();
    internal static string get_Manifest_RequireLicenseAcceptanceRequiresEmit();
    internal static string get_Manifest_RequireLicenseAcceptanceRequiresLicenseUrl();
    internal static string get_Manifest_SourceContainsInvalidCharacters();
    internal static string get_Manifest_TargetContainsInvalidCharacters();
    internal static string get_Manifest_UriCannotBeEmpty();
    internal static string get_PackageAuthoring_FileNotFound();
    internal static string get_ReadmeCannotOpenFile();
    internal static string get_ReadmeErrorEmpty();
    internal static string get_ReadmeFileExtensionIsInvalid();
    internal static string get_ReadmeMissingRequiredValue();
    internal static string get_ReadmeNoFileElement();
    internal static string get_UnknownSchemaVersion();
}
internal class NuGet.Packaging.PackageDependencyGroup : object {
    private NuGetFramework _targetFramework;
    private IEnumerable`1<PackageDependency> _packages;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<PackageDependency> Packages { get; }
    public PackageDependencyGroup(NuGetFramework targetFramework, IEnumerable`1<PackageDependency> packages);
    public sealed virtual NuGetFramework get_TargetFramework();
    public IEnumerable`1<PackageDependency> get_Packages();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageDependencyGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class NuGet.Packaging.PackageExtraction.PackageExtractionBehavior : object {
    private static string XmlDocFileSaveModeEnvironmentKey;
    private static Nullable`1<XmlDocFileSaveMode> _xmlDocFileSaveMode;
    public static XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public static XmlDocFileSaveMode get_XmlDocFileSaveMode();
    public static void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
}
internal class NuGet.Packaging.PackageExtractionContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocFileSaveMode <XmlDocFileSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopySatelliteFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSignatureVerifier <SignedPackageVerifier>k__BackingField;
    public ILogger Logger { get; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; }
    public bool CopySatelliteFiles { get; public set; }
    public IPackageSignatureVerifier SignedPackageVerifier { get; public set; }
    public PackageExtractionContext(PackageSaveMode packageSaveMode, XmlDocFileSaveMode xmlDocFileSaveMode, ClientPolicyContext clientPolicyContext, ILogger logger);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public XmlDocFileSaveMode get_XmlDocFileSaveMode();
    [CompilerGeneratedAttribute]
public void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public bool get_CopySatelliteFiles();
    [CompilerGeneratedAttribute]
public void set_CopySatelliteFiles(bool value);
    [CompilerGeneratedAttribute]
public IPackageSignatureVerifier get_SignedPackageVerifier();
    [CompilerGeneratedAttribute]
public void set_SignedPackageVerifier(IPackageSignatureVerifier value);
}
internal class NuGet.Packaging.PackageExtractionResult : object {
    [CompilerGeneratedAttribute]
private bool <Cached>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SignVerifyDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSignType <PackageType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignVerifyStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignVerifyEndTime>k__BackingField;
    public bool Cached { get; }
    public TimeSpan SignVerifyDelay { get; }
    public PackageSignType PackageType { get; }
    public bool Success { get; }
    public TimeSpan Duration { get; public set; }
    public DateTimeOffset SignVerifyStartTime { get; }
    public DateTimeOffset SignVerifyEndTime { get; }
    public PackageExtractionResult(bool cached, TimeSpan signVerifyDelay, PackageSignType packageType, bool success, DateTimeOffset signVerifyStartTime, DateTimeOffset signVerifyEndTime);
    public PackageExtractionResult(bool cached, TimeSpan signVerifyDelay, PackageSignType packageType, bool success, TimeSpan duration);
    [CompilerGeneratedAttribute]
public bool get_Cached();
    [CompilerGeneratedAttribute]
public TimeSpan get_SignVerifyDelay();
    [CompilerGeneratedAttribute]
public PackageSignType get_PackageType();
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignVerifyStartTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignVerifyEndTime();
}
internal class NuGet.Packaging.PackageExtractionTelemetryEvent : TelemetryEvent {
    public static string EventName;
    public PackageSaveMode PackageSaveMode { get; }
    public NuGetOperationStatus Status { get; }
    public ExtractionSource ExtractionSource { get; }
    public string PackageId { get; }
    public string PackageVersion { get; }
    public PackageExtractionTelemetryEvent(PackageSaveMode packageSaveMode, NuGetOperationStatus status, ExtractionSource extractionSource, PackageIdentity packageId);
    public PackageSaveMode get_PackageSaveMode();
    public NuGetOperationStatus get_Status();
    public ExtractionSource get_ExtractionSource();
    public string get_PackageId();
    public string get_PackageVersion();
    public void LogPackageIdentity(PackageIdentity packageId);
    public void SetResult(NuGetOperationStatus status);
}
internal static class NuGet.Packaging.PackageExtractor : object {
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__0")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__1")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, PackageReaderBase packageReader, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__2")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__3")]
public static Task`1<bool> InstallFromSourceAsync(string source, PackageIdentity packageIdentity, Func`2<Stream, Task> copyToAsync, VersionFolderPathResolver versionFolderPathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    private static void DeleteTargetAndTempPaths(string targetPath, string targetTempNupkg);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__5")]
public static Task`1<bool> InstallFromSourceAsync(PackageIdentity packageIdentity, IPackageDownloader packageDownloader, VersionFolderPathResolver versionFolderPathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    private static bool ShouldInclude(string fullName, string hashFileName, string nupkgMetadataFileName);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<CopySatelliteFilesAsync>d__7")]
public static Task`1<IEnumerable`1<string>> CopySatelliteFilesAsync(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<CopySatelliteFilesAsync>d__8")]
private static Task`1<IEnumerable`1<string>> CopySatelliteFilesAsync(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<VerifyPackageSignatureAsync>d__9")]
private static Task VerifyPackageSignatureAsync(string source, Guid parentId, PackageIdentity package, PackageExtractionContext packageExtractionContext, ISignedPackageReader signedPackageReader, CancellationToken token);
    private static void UpdateSignatureLog(string source, PackageIdentity package, ClientPolicyContext policyContext, SignatureLog message);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<LogPackageSignatureVerificationAsync>d__11")]
private static Task LogPackageSignatureVerificationAsync(string source, PackageIdentity package, ILogger logger, VerifySignaturesResult verifyResult);
    private static RepositorySignatureInfo GetRepositorySignatureInfo(string source);
}
internal class NuGet.Packaging.PackageFileExtractor : object {
    private HashSet`1<string> _intellisenseXmlFiles;
    private XmlDocFileSaveMode _xmlDocFileSaveMode;
    public PackageFileExtractor(IEnumerable`1<string> packageFiles, XmlDocFileSaveMode xmlDocFileSaveMode);
    private static HashSet`1<string> GatherIntellisenseXmlFiles(IEnumerable`1<string> packageFiles);
    private static string GetBinaryForLanguageSpecificXml(string file);
    public string ExtractPackageFile(string source, string target, Stream stream);
}
internal class NuGet.Packaging.PackageFolderReader : PackageReaderBase {
    private DirectoryInfo _root;
    public PackageFolderReader(string folderPath);
    public PackageFolderReader(DirectoryInfo folder);
    public PackageFolderReader(string folderPath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageFolderReader(DirectoryInfo folder, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public virtual string GetNuspecFile();
    public virtual Stream GetStream(string path);
    private FileInfo GetFile(string path);
    public virtual IEnumerable`1<string> GetFiles();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageFolderReader/<GetFiles>d__9")]
public virtual IEnumerable`1<string> GetFiles(string folder);
    private static bool IsFileInRoot(string path);
    private static bool IsNupkg(string path);
    private static string GetRelativePath(DirectoryInfo root, FileInfo file);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    protected virtual void Dispose(bool disposing);
    public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
}
internal static class NuGet.Packaging.PackageHelper : object {
    private static String[] ExcludePaths;
    private static Char[] Slashes;
    private static PackageHelper();
    public static bool IsAssembly(string path);
    public static bool IsNuspec(string path);
    public static bool IsManifest(string path);
    public static bool IsRoot(string path);
    public static bool IsPackageFile(string packageFileName, PackageSaveMode packageSaveMode);
    private static bool IsNuGetGeneratedFile(string path);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetSatellitePackageInfoAsync>d__8")]
private static Task`1<SatellitePackageInfo> GetSatellitePackageInfoAsync(IAsyncPackageCoreReader packageReader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetSatelliteFilesAsync>d__9")]
public static Task`1<Tuple`2<string, IEnumerable`1<string>>> GetSatelliteFilesAsync(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetInstalledPackageFilesAsync>d__10")]
public static Task`1<IEnumerable`1<ZipFilePair>> GetInstalledPackageFilesAsync(PackageArchiveReader packageReader, PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetInstalledSatelliteFilesAsync>d__11")]
public static Task`1<Tuple`2<string, IEnumerable`1<ZipFilePair>>> GetInstalledSatelliteFilesAsync(PackageArchiveReader packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
}
internal static class NuGet.Packaging.PackageIdValidator : object {
    public static int MaxPackageIdLength;
    private static Regex IdRegex;
    private static PackageIdValidator();
    public static bool IsValidPackageId(string packageId);
    public static void ValidatePackageId(string packageId);
}
internal static class NuGet.Packaging.PackagePathHelper : object {
    internal static IEnumerable`1<string> GetFiles(string root, string path, string filter, bool recursive);
    internal static IEnumerable`1<string> GetDirectories(string root, string path);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackagePathHelper/<GetPackageFiles>d__2")]
private static IEnumerable`1<string> GetPackageFiles(string root, string filter);
    private static bool FileNameMatchesPattern(PackageIdentity packageIdentity, string path);
    public static IEnumerable`1<string> GetPackageLookupPaths(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
    public static string GetInstalledPackageFilePath(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
}
internal class NuGet.Packaging.PackagePathResolver : object {
    private string _rootDirectory;
    [CompilerGeneratedAttribute]
private bool <UseSideBySidePaths>k__BackingField;
    public bool UseSideBySidePaths { get; }
    protected internal string Root { get; }
    public PackagePathResolver(string rootDirectory, bool useSideBySidePaths);
    [CompilerGeneratedAttribute]
public bool get_UseSideBySidePaths();
    protected internal string get_Root();
    public virtual string GetPackageDirectoryName(PackageIdentity packageIdentity);
    public virtual string GetPackageFileName(PackageIdentity packageIdentity);
    public string GetPackageDownloadMarkerFileName(PackageIdentity packageIdentity);
    public string GetManifestFileName(PackageIdentity packageIdentity);
    public virtual string GetInstallPath(PackageIdentity packageIdentity);
    public virtual string GetInstalledPath(PackageIdentity packageIdentity);
    public virtual string GetInstalledPackageFilePath(PackageIdentity packageIdentity);
    private string GetId(PackageIdentity identity);
    private string GetVersion(PackageIdentity identity);
    private StringBuilder GetPathBase(PackageIdentity packageIdentity);
}
internal abstract class NuGet.Packaging.PackageReaderBase : object {
    private NuspecReader _nuspecReader;
    [CompilerGeneratedAttribute]
private IFrameworkNameProvider <FrameworkProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IFrameworkCompatibilityProvider <CompatibilityProvider>k__BackingField;
    protected IFrameworkNameProvider FrameworkProvider { get; protected set; }
    protected IFrameworkCompatibilityProvider CompatibilityProvider { get; protected set; }
    public NuspecReader NuspecReader { get; }
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider);
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    [CompilerGeneratedAttribute]
protected IFrameworkNameProvider get_FrameworkProvider();
    [CompilerGeneratedAttribute]
protected void set_FrameworkProvider(IFrameworkNameProvider value);
    [CompilerGeneratedAttribute]
protected IFrameworkCompatibilityProvider get_CompatibilityProvider();
    [CompilerGeneratedAttribute]
protected void set_CompatibilityProvider(IFrameworkCompatibilityProvider value);
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public virtual PackageIdentity GetIdentity();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual Stream GetNuspec();
    public virtual string GetNuspecFile();
    public virtual NuspecReader get_NuspecReader();
    public virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<NuGetFramework> GetSupportedFrameworks();
    public virtual Task`1<IEnumerable`1<NuGetFramework>> GetSupportedFrameworksAsync(CancellationToken cancellationToken);
    public virtual bool IsServiceable();
    public virtual Task`1<bool> IsServiceableAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetItems(string folderName);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetItemsAsync(string folderName, CancellationToken cancellationToken);
    public virtual bool GetDevelopmentDependency();
    public virtual Task`1<bool> GetDevelopmentDependencyAsync(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReaderBase/<GetFileGroups>d__55")]
protected IEnumerable`1<FrameworkSpecificGroup> GetFileGroups(string folder);
    protected NuGetFramework GetFrameworkFromPath(string path, bool allowSubFolders);
    protected static bool IsAllowedBuildFile(string packageId, string path);
    protected static bool IsReferenceAssembly(string path);
    protected static string GetNuspecFile(IEnumerable`1<string> files);
    protected static void ValidatePackageEntry(string normalizedDestination, string normalizedFilePath, PackageIdentity packageIdentity);
    protected string NormalizeDirectoryPath(string path);
    protected static void ValidatePackageEntries(string normalizedDestination, IEnumerable`1<string> packageFiles, PackageIdentity packageIdentity);
    public virtual Task`1<NuspecReader> GetNuspecReaderAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public abstract virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public abstract virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public abstract virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public abstract virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public abstract virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.PackageReaderExtensions : object {
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageReaderExtensions/<GetPackageFilesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<string>> GetPackageFilesAsync(IAsyncPackageCoreReader packageReader, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageReaderExtensions/<GetSatelliteFilesAsync>d__1")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<string>> GetSatelliteFilesAsync(IAsyncPackageContentReader packageReader, string packageLanguage, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{PackageIdentity} {TargetFramework}")]
internal class NuGet.Packaging.PackageReference : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <AllowedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUserInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireReinstallation>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public VersionRange AllowedVersions { get; }
    public bool HasAllowedVersions { get; }
    public NuGetFramework TargetFramework { get; }
    public bool IsDevelopmentDependency { get; }
    public bool IsUserInstalled { get; }
    public bool RequireReinstallation { get; }
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation, VersionRange allowedVersions);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public VersionRange get_AllowedVersions();
    public bool get_HasAllowedVersions();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public bool get_IsDevelopmentDependency();
    [CompilerGeneratedAttribute]
public bool get_IsUserInstalled();
    [CompilerGeneratedAttribute]
public bool get_RequireReinstallation();
    public virtual string ToString();
}
internal class NuGet.Packaging.PackageReferenceSet : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    public IReadOnlyCollection`1<string> References { get; }
    public NuGetFramework TargetFramework { get; }
    public PackageReferenceSet(IEnumerable`1<string> references);
    public PackageReferenceSet(string targetFramework, IEnumerable`1<string> references);
    public PackageReferenceSet(NuGetFramework targetFramework, IEnumerable`1<string> references);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_References();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReferenceSet/<Validate>d__9")]
public IEnumerable`1<string> Validate();
}
[FlagsAttribute]
internal enum NuGet.Packaging.PackageSaveMode : Enum {
    public int value__;
    public static PackageSaveMode None;
    public static PackageSaveMode Nuspec;
    public static PackageSaveMode Nupkg;
    public static PackageSaveMode Files;
    public static PackageSaveMode Defaultv2;
    public static PackageSaveMode Defaultv3;
}
internal static class NuGet.Packaging.PackagesConfig : object {
    public static string PackagesNodeName;
    public static string PackageNodeName;
    public static string IdAttributeName;
    public static string VersionAttributeName;
    public static string TargetFrameworkAttributeName;
    public static string MinClientAttributeName;
    public static string developmentDependencyAttributeName;
    public static string allowedVersionsAttributeName;
    public static string RequireInstallAttributeName;
    public static string UserInstalledAttributeName;
    private static PackagesConfig();
    public static bool TryGetAttribute(XElement node, string name, String& value);
    public static bool HasAttributeValue(XElement node, string attributeName, string targetValue, XElement& element);
    public static bool BoolAttribute(XElement node, string name, bool defaultValue);
}
internal class NuGet.Packaging.PackagesConfigReader : object {
    private XDocument _doc;
    private IFrameworkNameProvider _frameworkMappings;
    public PackagesConfigReader(XDocument xml);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, XDocument xml);
    public PackagesConfigReader(Stream stream);
    public PackagesConfigReader(Stream stream, bool leaveStreamOpen);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, Stream stream, bool leaveStreamOpen);
    public NuGetVersion GetMinClientVersion();
    public IEnumerable`1<PackageReference> GetPackages();
    public IEnumerable`1<PackageReference> GetPackages(bool allowDuplicatePackageIds);
}
internal class NuGet.Packaging.PackagesConfigReaderException : PackagingException {
    public PackagesConfigReaderException(string message);
    public PackagesConfigReaderException(string message, Exception innerException);
}
internal class NuGet.Packaging.PackagesConfigWriter : object {
    private Stream _stream;
    private string _filePath;
    private bool _disposed;
    private NuGetVersion _minClientVersion;
    private IFrameworkNameProvider _frameworkMappings;
    private XDocument _xDocument;
    public PackagesConfigWriter(string fullPath, bool createNew);
    public PackagesConfigWriter(string fullPath, bool createNew, IFrameworkNameProvider frameworkMappings);
    public PackagesConfigWriter(Stream stream, bool createNew);
    public PackagesConfigWriter(Stream stream, bool createNew, IFrameworkNameProvider frameworkMappings);
    public void WriteMinClientVersion(NuGetVersion version);
    public void AddPackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageReference entry);
    public void UpdatePackageEntry(PackageReference oldEntry, PackageReference newEntry);
    public void UpdateOrAddPackageEntry(XDocument originalConfig, PackageReference newEntry);
    public void RemovePackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageReference entry);
    private XElement CreateXElementForPackageEntry(PackageReference entry);
    private void CreateDefaultXDocument();
    private XElement EnsurePackagesNode();
    private XElement FindMatchingPackageNode(PackageReference entry, XElement packagesNode);
    private XElement ReplacePackageAttributes(XElement existingNode, PackageReference newEntry);
    private void SortPackageNodes(XElement packagesNode);
    private void WriteFile();
    public void WriteFile(string fullPath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class NuGet.Packaging.PackagesConfigWriterException : PackagingException {
    public PackagesConfigWriterException(string message);
    public PackagesConfigWriterException(string message, Exception innerException);
}
internal class NuGet.Packaging.PackageSigningTelemetryEvent : TelemetryEvent {
    public static string EventName;
    public PackageSignType PackageSignType { get; }
    public NuGetOperationStatus Status { get; }
    public string ExtractionId { get; }
    public PackageSignType get_PackageSignType();
    public NuGetOperationStatus get_Status();
    public string get_ExtractionId();
    public void SetResult(PackageSignType packageSignType, NuGetOperationStatus status);
}
internal enum NuGet.Packaging.PackageSignType : Enum {
    public int value__;
    public static PackageSignType Signed;
    public static PackageSignType Unsigned;
}
internal static class NuGet.Packaging.PackagingConstants : object {
    public static string AnyFramework;
    public static string AnyCodeLanguage;
    public static string AgnosticFramework;
    public static string TargetFrameworkPropertyKey;
    public static string ContentFilesDefaultBuildAction;
    public static string PackageVerifyDurationName;
    public static string ManifestExtension;
    public static string SnupkgFormat;
    public static string SymbolsNupkgFormat;
    internal static string PackageEmptyFileName;
    private static PackagingConstants();
}
internal class NuGet.Packaging.PhysicalPackageFile : object {
    private Func`1<Stream> _streamFactory;
    private string _targetPath;
    private FrameworkName _targetFramework;
    private NuGetFramework _nugetFramework;
    private DateTimeOffset _lastWriteTime;
    [CompilerGeneratedAttribute]
private MemoryStream <MemoryStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectivePath>k__BackingField;
    private MemoryStream MemoryStream { get; private set; }
    public string SourcePath { get; public set; }
    public string TargetPath { get; public set; }
    public string Path { get; }
    public string EffectivePath { get; private set; }
    public FrameworkName TargetFramework { get; }
    public NuGetFramework NuGetFramework { get; }
    public DateTimeOffset LastWriteTime { get; }
    public PhysicalPackageFile(MemoryStream stream);
    internal PhysicalPackageFile(Func`1<Stream> streamFactory);
    [CompilerGeneratedAttribute]
private MemoryStream get_MemoryStream();
    [CompilerGeneratedAttribute]
private void set_MemoryStream(MemoryStream value);
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public void set_SourcePath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EffectivePath();
    [CompilerGeneratedAttribute]
private void set_EffectivePath(string value);
    public sealed virtual FrameworkName get_TargetFramework();
    public sealed virtual NuGetFramework get_NuGetFramework();
    public sealed virtual Stream GetStream();
    public sealed virtual DateTimeOffset get_LastWriteTime();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.Packaging.RepositorySignatureInfo : object {
    [CompilerGeneratedAttribute]
private bool <AllRepositorySigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRepositoryCertificateInfo> <RepositoryCertificateInfos>k__BackingField;
    public bool AllRepositorySigned { get; }
    public IEnumerable`1<IRepositoryCertificateInfo> RepositoryCertificateInfos { get; }
    public RepositorySignatureInfo(bool allRepositorySigned, IEnumerable`1<IRepositoryCertificateInfo> repositoryCertificateInfos);
    [CompilerGeneratedAttribute]
public bool get_AllRepositorySigned();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRepositoryCertificateInfo> get_RepositoryCertificateInfos();
}
internal class NuGet.Packaging.RepositorySignatureInfoProvider : object {
    private ConcurrentDictionary`2<string, RepositorySignatureInfo> _dict;
    [CompilerGeneratedAttribute]
private static RepositorySignatureInfoProvider <Instance>k__BackingField;
    public static RepositorySignatureInfoProvider Instance { get; }
    private static RepositorySignatureInfoProvider();
    [CompilerGeneratedAttribute]
public static RepositorySignatureInfoProvider get_Instance();
    public bool TryGetRepositorySignatureInfo(string source, RepositorySignatureInfo& repositorySignatureInfo);
    public void AddOrUpdateRepositorySignatureInfo(string source, RepositorySignatureInfo repositorySignatureInfo);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Rules.AnalysisResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string AssemblyDirectlyUnderLibWarning { get; }
    public static string AssemblyOutsideLibWarning { get; }
    public static string BuildConventionIsViolatedWarning { get; }
    public static string DefaultSpecValueWarning { get; }
    public static string DependenciesGroupsForEachTFMBeginningToFiles { get; }
    public static string DependenciesGroupsForEachTFMBeginningToNuspec { get; }
    public static string DependenciesGroupsForEachTFMEndingToFile { get; }
    public static string DependenciesGroupsForEachTFMEndingToNuspec { get; }
    public static string DependenciesGroupsForEachTFMHasCompatMatch { get; }
    public static string DependenciesGroupsForEachTFMHasNoExactMatch { get; }
    public static string FilePathTooLongWarning { get; }
    public static string IconUrlDeprecationWarning { get; }
    public static string InvalidFrameworkWarning { get; }
    public static string InvalidPlaceholderFileWarning { get; }
    public static string InvalidPrereleaseDependencyWarning { get; }
    public static string InvalidUndottedFrameworkInDependencyGroupsWarning { get; }
    public static string InvalidUndottedFrameworkInFilesWarning { get; }
    public static string InvalidUndottedFrameworkInFrameworkAssemblyGroupsWarning { get; }
    public static string InvalidUndottedFrameworkInReferenceGroupsWarning { get; }
    public static string InvalidUndottedFrameworkWarning { get; }
    public static string LegacyVersionWarning { get; }
    public static string LicenseUrlDeprecationWarning { get; }
    public static string Migrator_AssemblyDirectlyUnderLibWarning { get; }
    public static string Migrator_PackageHasContentFolder { get; }
    public static string Migrator_PackageHasInstallScript { get; }
    public static string Migrator_XdtTransformInPackage { get; }
    public static string MisplacedInitScriptWarning { get; }
    public static string MisplacedTransformFileWarning { get; }
    public static string MissingReadmeInformation { get; }
    public static string NoRefOrLibFolderInPackage { get; }
    public static string PlaceholderFileInPackageWarning { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarning { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat { get; }
    public static string ScriptOutsideToolsWarning { get; }
    public static string UnrecognizedLicenseIdentifier { get; }
    public static string UnrecognizedScriptWarning { get; }
    public static string UnspecifiedDependencyVersionWarning { get; }
    public static string WinRTObsoleteWarning { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_AssemblyDirectlyUnderLibWarning();
    public static string get_AssemblyOutsideLibWarning();
    public static string get_BuildConventionIsViolatedWarning();
    public static string get_DefaultSpecValueWarning();
    public static string get_DependenciesGroupsForEachTFMBeginningToFiles();
    public static string get_DependenciesGroupsForEachTFMBeginningToNuspec();
    public static string get_DependenciesGroupsForEachTFMEndingToFile();
    public static string get_DependenciesGroupsForEachTFMEndingToNuspec();
    public static string get_DependenciesGroupsForEachTFMHasCompatMatch();
    public static string get_DependenciesGroupsForEachTFMHasNoExactMatch();
    public static string get_FilePathTooLongWarning();
    public static string get_IconUrlDeprecationWarning();
    public static string get_InvalidFrameworkWarning();
    public static string get_InvalidPlaceholderFileWarning();
    public static string get_InvalidPrereleaseDependencyWarning();
    public static string get_InvalidUndottedFrameworkInDependencyGroupsWarning();
    public static string get_InvalidUndottedFrameworkInFilesWarning();
    public static string get_InvalidUndottedFrameworkInFrameworkAssemblyGroupsWarning();
    public static string get_InvalidUndottedFrameworkInReferenceGroupsWarning();
    public static string get_InvalidUndottedFrameworkWarning();
    public static string get_LegacyVersionWarning();
    public static string get_LicenseUrlDeprecationWarning();
    public static string get_Migrator_AssemblyDirectlyUnderLibWarning();
    public static string get_Migrator_PackageHasContentFolder();
    public static string get_Migrator_PackageHasInstallScript();
    public static string get_Migrator_XdtTransformInPackage();
    public static string get_MisplacedInitScriptWarning();
    public static string get_MisplacedTransformFileWarning();
    public static string get_MissingReadmeInformation();
    public static string get_NoRefOrLibFolderInPackage();
    public static string get_PlaceholderFileInPackageWarning();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarning();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat();
    public static string get_ScriptOutsideToolsWarning();
    public static string get_UnrecognizedLicenseIdentifier();
    public static string get_UnrecognizedScriptWarning();
    public static string get_UnspecifiedDependencyVersionWarning();
    public static string get_WinRTObsoleteWarning();
}
internal class NuGet.Packaging.Rules.ContentFolderInPackageReferenceProjectRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public ContentFolderInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.DefaultManifestValuesRule : object {
    internal static Uri SampleProjectUrl;
    internal static Uri SampleLicenseUrl;
    internal static Uri SampleIconUrl;
    internal static string SampleTags;
    internal static string SampleReleaseNotes;
    internal static string SampleDescription;
    internal static string SampleManifestDependencyId;
    internal static string SampleManifestDependencyVersion;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public DefaultManifestValuesRule(string messageFormat);
    private static DefaultManifestValuesRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.DefaultManifestValuesRule/<Validate>d__12")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreateIssueFor(string field, string value);
}
internal class NuGet.Packaging.Rules.DependenciesGroupsForEachTFMRule : object {
    private static NuGetFramework Net00;
    public string MessageFormat { get; }
    private string CompatMatchFoundWarningMessageFormat { get; }
    private static DependenciesGroupsForEachTFMRule();
    public sealed virtual string get_MessageFormat();
    private string get_CompatMatchFoundWarningMessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader package);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(HashSet`1<NuGetFramework> compatNotExactMatches, HashSet`1<NuGetFramework> noExactMatchesFromFile, HashSet`1<NuGetFramework> noExactMatchesFromNuspec);
    internal ValueTuple`3<HashSet`1<NuGetFramework>, HashSet`1<NuGetFramework>, HashSet`1<NuGetFramework>> Categorize(IEnumerable`1<string> files, IEnumerable`1<NuGetFramework> tfmsFromNuspec);
    internal ValueTuple`2<string, string> GenerateWarningString(ICollection`1<NuGetFramework> noExactMatchesFromFile, ICollection`1<NuGetFramework> noExactMatchesFromNuspec, ICollection`1<NuGetFramework> compatNotExactMatches);
    private static IEnumerable`1<NuGetFramework> ExtractTFMsFromNuspec(Stream packageNuspecStream);
}
internal static class NuGet.Packaging.Rules.FrameworkNameValidatorUtility : object {
    internal static bool IsValidFrameworkName(NuGetFramework framework);
    internal static bool IsValidFrameworkName(string path);
    internal static bool IsValidCultureName(PackageArchiveReader builder, string name);
}
internal class NuGet.Packaging.Rules.IconUrlDeprecationWarning : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public IconUrlDeprecationWarning(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.IconUrlDeprecationWarning/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.InitScriptNotUnderToolsRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InitScriptNotUnderToolsRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InitScriptNotUnderToolsRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssue(string file);
}
internal class NuGet.Packaging.Rules.InstallScriptInPackageReferenceProjectRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InstallScriptInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.InvalidFrameworkFolderRule : object {
    private static string LibDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidFrameworkFolderRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssue(string target);
}
internal class NuGet.Packaging.Rules.InvalidPlaceholderFileRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidPlaceholderFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InvalidPlaceholderFileRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForPlaceholderFile(string target);
}
internal class NuGet.Packaging.Rules.InvalidPrereleaseDependencyRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidPrereleaseDependencyRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InvalidPrereleaseDependencyRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private bool IsPrereleaseDependency(PackageDependency dependency);
    private PackagingLogMessage CreatePackageIssueForPrereleaseDependency(PackageDependency dependency, NuGetFramework framework);
}
internal class NuGet.Packaging.Rules.InvalidUndottedFrameworkRule : object {
    private static string TargetFramework;
    private static string Metadata;
    private static string Dependencies;
    private static string Group;
    private static string References;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static Char[] CommaArray;
    public string MessageFormat { get; }
    private static InvalidUndottedFrameworkRule();
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal static IEnumerable`1<PackagingLogMessage> Validate(XDocument xml, IEnumerable`1<string> files);
    internal static IEnumerable`1<PackagingLogMessage> ValidateDependencyGroups(XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateReferenceGroups(XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateFrameworkAssemblies(XDocument xml, XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateFiles(IEnumerable`1<string> files);
    private static XDocument LoadXml(Stream stream);
    private static string GetAttributeValue(XElement element, string attributeName);
    internal static bool FrameworkVersionHasDesiredDots(string frameworkString);
}
internal interface NuGet.Packaging.Rules.IPackageRule {
    public string MessageFormat { get; }
    public abstract virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    public abstract virtual string get_MessageFormat();
}
internal class NuGet.Packaging.Rules.LicenseUrlDeprecationWarning : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public LicenseUrlDeprecationWarning(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.LicenseUrlDeprecationWarning/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    private static IEnumerable`1<string> ValidFolders { get; }
    public MisplacedAssemblyOutsideLibRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForAssembliesOutsideLib(string target);
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule/<get_ValidFolders>d__7")]
private static IEnumerable`1<string> get_ValidFolders();
}
internal class NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    private static IEnumerable`1<string> ValidFolders { get; }
    public MisplacedAssemblyUnderLibRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForAssembliesUnderLib(string target);
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule/<get_ValidFolders>d__7")]
private static IEnumerable`1<string> get_ValidFolders();
}
internal class NuGet.Packaging.Rules.MisplacedScriptFileRule : object {
    private static string ScriptExtension;
    private static string ToolsDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MisplacedScriptFileRule(string messageFormat);
    private static MisplacedScriptFileRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedScriptFileRule/<Validate>d__6")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForMisplacedScript(string target);
}
internal class NuGet.Packaging.Rules.MisplacedTransformFileRule : object {
    private static string CodeTransformExtension;
    private static string ConfigTransformExtension;
    private static string ContentDirectory;
    private static string ContentFilesDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MisplacedTransformFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedTransformFileRule/<Validate>d__8")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForMisplacedContent(string path);
}
internal class NuGet.Packaging.Rules.MissingReadmeRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MissingReadmeRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MissingReadmeRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.NoRefOrLibFolderInPackageRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public NoRefOrLibFolderInPackageRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader package);
    internal IEnumerable`1<PackagingLogMessage> Validate(IEnumerable`1<string> files);
    private ValueTuple`2<string, string> GenerateWarningString(String[] possibleFrameworks);
    private static string CreateDirectoriesMessage(String[] possibleFrameworks);
}
internal class NuGet.Packaging.Rules.PathTooLongRule : object {
    private static int _pathLenghtWarningThreshold;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public PathTooLongRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.PathTooLongRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForPathTooLong(string target);
}
internal class NuGet.Packaging.Rules.ReferencesInNuspecMatchRefAssetsRule : object {
    private string _addToRefFormat;
    private string _addToNuspecFormat;
    private string _addToNuspecNoTfmFormat;
    public string MessageFormat { get; }
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal IDictionary`2<string, IEnumerable`1<string>> GetReferencesFromNuspec(Stream nuspecStream);
    internal IEnumerable`1<MissingReference> Compare(IDictionary`2<string, IEnumerable`1<string>> nuspecReferences, IEnumerable`1<string> refFiles);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(IEnumerable`1<MissingReference> missingReferences);
    internal List`1<string> GetAllKeys(IEnumerable`1<IGrouping`2<string, string>> filesByTFM);
}
internal static class NuGet.Packaging.Rules.RuleSet : object {
    private static IPackageRule[] PackageCreationRuleArray;
    private static IPackageRule[] PackageCreationBestPracticeRuleArray;
    private static ReadOnlyCollection`1<IPackageRule> PackageCreationRules;
    private static ReadOnlyCollection`1<IPackageRule> PackagesConfigToPackageReferenceMigrationRules;
    public static IEnumerable`1<IPackageRule> PackageCreationRuleSet { get; }
    public static IEnumerable`1<IPackageRule> PackagesConfigToPackageReferenceMigrationRuleSet { get; }
    private static RuleSet();
    public static IEnumerable`1<IPackageRule> get_PackageCreationRuleSet();
    public static IEnumerable`1<IPackageRule> get_PackagesConfigToPackageReferenceMigrationRuleSet();
}
internal class NuGet.Packaging.Rules.UnrecognizedLicenseIdentifierRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnrecognizedLicenseIdentifierRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private void ValidateAllLicenseLeafs(NuGetLicenseExpression expression, IList`1<PackagingLogMessage> logMessages);
}
internal class NuGet.Packaging.Rules.UnrecognizedScriptFileRule : object {
    private static string ScriptExtension;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnrecognizedScriptFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.UnrecognizedScriptFileRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForUnrecognizedScripts(string target);
}
internal class NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnspecifiedDependencyVersionRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.UpholdBuildConventionRule : object {
    private static ManagedCodeConventions ManagedCodeConventions;
    private static IReadOnlyList`1<string> BuildFolders;
    public string MessageFormat { get; }
    private static UpholdBuildConventionRule();
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal PackagingLogMessage GenerateWarning(ICollection`1<ExpectedFile> expectedFiles);
    internal List`1<ExpectedFile> FindAbsentExpectedFiles(IEnumerable`1<string> files, string packageId);
    private string GetTfm(string file);
    private string GetBuildFolder(string file);
    private bool EndsWithMsbuildFileExtension(string file);
    private bool InsideBuildFolder(string file);
}
internal class NuGet.Packaging.Rules.WinRTNameIsObsoleteRule : object {
    private static String[] Prefixes;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public WinRTNameIsObsoleteRule(string messageFormat);
    private static WinRTNameIsObsoleteRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.WinRTNameIsObsoleteRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreateIssue(string file);
}
internal class NuGet.Packaging.Rules.XdtTransformInPackageReferenceProjectRule : object {
    private static string ConfigTransformExtension;
    private static string InstallXdtExtension;
    private static string UninstallXdtExtension;
    private static string ContentDirectory;
    private static string ContentFilesDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public XdtTransformInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.XdtTransformInPackageReferenceProjectRule/<Validate>d__9")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForTransformFiles(string path);
}
internal class NuGet.Packaging.Sha512HashFunction : object {
    private Byte[] _hash;
    private SHA512 _hashFunc;
    public sealed virtual void Update(Byte[] data, int offset, int count);
    public Byte[] GetHashBytes();
    public sealed virtual string GetHash();
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.Accuracy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Seconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Milliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Microseconds>k__BackingField;
    public Nullable`1<int> Seconds { get; }
    public Nullable`1<int> Milliseconds { get; }
    public Nullable`1<int> Microseconds { get; }
    private Accuracy(Nullable`1<int> seconds, Nullable`1<int> milliseconds, Nullable`1<int> microseconds);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Seconds();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Milliseconds();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Microseconds();
    public static Accuracy Read(Byte[] bytes);
    internal static Accuracy Read(DerSequenceReader reader);
    public Nullable`1<long> GetTotalMicroseconds();
}
internal class NuGet.Packaging.Signing.AlgorithmIdentifier : object {
    [CompilerGeneratedAttribute]
private Oid <Algorithm>k__BackingField;
    public Oid Algorithm { get; }
    internal AlgorithmIdentifier(Oid algorithm);
    [CompilerGeneratedAttribute]
public Oid get_Algorithm();
    public static AlgorithmIdentifier Read(Byte[] bytes);
    internal static AlgorithmIdentifier Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
internal class NuGet.Packaging.Signing.AllowListVerificationProvider : object {
    private IReadOnlyCollection`1<VerificationAllowListEntry> _allowList;
    private string _emptyListErrorMessage;
    private string _noMatchErrorMessage;
    private bool _requireNonEmptyAllowList;
    public AllowListVerificationProvider(IReadOnlyCollection`1<VerificationAllowListEntry> allowList, bool requireNonEmptyAllowList, string emptyListErrorMessage, string noMatchErrorMessage);
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    private PackageVerificationResult VerifyAllowList(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings);
    private bool IsSignatureAllowed(PrimarySignature signature, IReadOnlyCollection`1<VerificationAllowListEntry> allowList);
    private static bool ShouldVerifyOwners(TrustedSignerAllowListEntry entry, IRepositorySignature repoSignature, IReadOnlyList`1& allowedOwners, IReadOnlyList`1& actualOwners);
    private static bool IsSignatureTargeted(VerificationTarget target, Signature signature);
    private static string GetCertificateFingerprint(Signature signature, HashAlgorithmName fingerprintAlgorithm, IDictionary`2<HashAlgorithmName, string> CertificateFingerprintLookUp);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Signing.AttributeUtility : object {
    public static CryptographicAttributeObject CreateCommitmentTypeIndication(SignatureType type);
    public static SignatureType GetSignatureType(CryptographicAttributeObjectCollection signedAttributes);
    public static CryptographicAttributeObject CreateNuGetV3ServiceIndexUrl(Uri v3ServiceIndexUrl);
    public static Uri GetNuGetV3ServiceIndexUrl(CryptographicAttributeObjectCollection signedAttributes);
    public static CryptographicAttributeObject CreateNuGetPackageOwners(IReadOnlyList`1<string> packageOwners);
    public static IReadOnlyList`1<string> GetNuGetPackageOwners(CryptographicAttributeObjectCollection signedAttributes);
    public static SignatureType GetSignatureType(string oid);
    public static string GetSignatureTypeOid(SignatureType signatureType);
    public static CryptographicAttributeObject CreateSigningCertificateV2(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    [ExtensionAttribute]
internal static CryptographicAttributeObject GetAttributeOrDefault(CryptographicAttributeObjectCollection attributes, string oid);
    private static void ThrowInvalidAttributeException(CryptographicAttributeObject attribute);
    [ExtensionAttribute]
private static List`1<AsnEncodedData> ToList(AsnEncodedDataCollection collection);
    private static IEnumerable`1<SignatureType> GetCommitmentTypeIndicationRawValues(CryptographicAttributeObject attribute);
    [ExtensionAttribute]
public static CryptographicAttributeObject GetAttribute(CryptographicAttributeObjectCollection attributes, string oid);
    [ExtensionAttribute]
public static IEnumerable`1<CryptographicAttributeObject> GetAttributes(CryptographicAttributeObjectCollection attributes, string oid);
}
internal class NuGet.Packaging.Signing.AuthorPrimarySignature : PrimarySignature {
    public string FriendlyName { get; }
    public AuthorPrimarySignature(SignedCms signedCms);
    public virtual string get_FriendlyName();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
}
internal class NuGet.Packaging.Signing.AuthorSignPackageRequest : SignPackageRequest {
    public SignatureType SignatureType { get; }
    public AuthorSignPackageRequest(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public AuthorSignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm);
    public virtual SignatureType get_SignatureType();
}
internal class NuGet.Packaging.Signing.BLOB : ValueType {
    public UInt32 cbData;
    public IntPtr pbData;
    public void Dispose();
}
internal class NuGet.Packaging.Signing.CentralDirectoryHeader : object {
    internal static UInt32 SizeInBytesOfFixedLengthFields;
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <VersionMadeBy>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GeneralPurposeBitFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExtraFieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileCommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DiskNumberStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <InternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ExternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RelativeOffsetOfLocalHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtraField>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetFromStart>k__BackingField;
    internal ushort VersionMadeBy { get; private set; }
    internal ushort VersionNeededToExtract { get; private set; }
    internal ushort GeneralPurposeBitFlag { get; private set; }
    internal ushort CompressionMethod { get; private set; }
    internal ushort LastModFileTime { get; private set; }
    internal ushort LastModFileDate { get; private set; }
    internal UInt32 Crc32 { get; private set; }
    internal UInt32 CompressedSize { get; private set; }
    internal UInt32 UncompressedSize { get; private set; }
    internal ushort FileNameLength { get; private set; }
    internal ushort ExtraFieldLength { get; private set; }
    internal ushort FileCommentLength { get; private set; }
    internal ushort DiskNumberStart { get; private set; }
    internal ushort InternalFileAttributes { get; private set; }
    internal UInt32 ExternalFileAttributes { get; private set; }
    internal UInt32 RelativeOffsetOfLocalHeader { get; private set; }
    internal Byte[] FileName { get; private set; }
    internal Byte[] ExtraField { get; private set; }
    internal Byte[] FileComment { get; private set; }
    internal long OffsetFromStart { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_VersionMadeBy();
    [CompilerGeneratedAttribute]
private void set_VersionMadeBy(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_GeneralPurposeBitFlag();
    [CompilerGeneratedAttribute]
private void set_GeneralPurposeBitFlag(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileTime();
    [CompilerGeneratedAttribute]
private void set_LastModFileTime(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileDate();
    [CompilerGeneratedAttribute]
private void set_LastModFileDate(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileNameLength();
    [CompilerGeneratedAttribute]
private void set_FileNameLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_ExtraFieldLength();
    [CompilerGeneratedAttribute]
private void set_ExtraFieldLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_FileCommentLength();
    [CompilerGeneratedAttribute]
private void set_FileCommentLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_DiskNumberStart();
    [CompilerGeneratedAttribute]
private void set_DiskNumberStart(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_InternalFileAttributes();
    [CompilerGeneratedAttribute]
private void set_InternalFileAttributes(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ExternalFileAttributes();
    [CompilerGeneratedAttribute]
private void set_ExternalFileAttributes(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_RelativeOffsetOfLocalHeader();
    [CompilerGeneratedAttribute]
private void set_RelativeOffsetOfLocalHeader(UInt32 value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ExtraField();
    [CompilerGeneratedAttribute]
private void set_ExtraField(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(Byte[] value);
    [CompilerGeneratedAttribute]
internal long get_OffsetFromStart();
    [CompilerGeneratedAttribute]
private void set_OffsetFromStart(long value);
    internal UInt32 GetSizeInBytes();
    internal static bool TryRead(BinaryReader reader, CentralDirectoryHeader& header);
}
internal class NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata : object {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetToLocalFileHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileEntryTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPackageSignatureFile>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ChangeInOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInHeaders>k__BackingField;
    public long Position { get; public set; }
    public long OffsetToLocalFileHeader { get; public set; }
    public long FileEntryTotalSize { get; public set; }
    public bool IsPackageSignatureFile { get; public set; }
    public long HeaderSize { get; public set; }
    public long ChangeInOffset { get; public set; }
    public int IndexInHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    [CompilerGeneratedAttribute]
public long get_OffsetToLocalFileHeader();
    [CompilerGeneratedAttribute]
public void set_OffsetToLocalFileHeader(long value);
    [CompilerGeneratedAttribute]
public long get_FileEntryTotalSize();
    [CompilerGeneratedAttribute]
public void set_FileEntryTotalSize(long value);
    [CompilerGeneratedAttribute]
public bool get_IsPackageSignatureFile();
    [CompilerGeneratedAttribute]
public void set_IsPackageSignatureFile(bool value);
    [CompilerGeneratedAttribute]
public long get_HeaderSize();
    [CompilerGeneratedAttribute]
public void set_HeaderSize(long value);
    [CompilerGeneratedAttribute]
public long get_ChangeInOffset();
    [CompilerGeneratedAttribute]
public void set_ChangeInOffset(long value);
    [CompilerGeneratedAttribute]
public int get_IndexInHeaders();
    [CompilerGeneratedAttribute]
public void set_IndexInHeaders(int value);
}
internal class NuGet.Packaging.Signing.CERT_CONTEXT : ValueType {
    public UInt32 dwCertEncodingType;
    public IntPtr pbCertEncoded;
    public UInt32 cbCertEncoded;
    public IntPtr pCertInfo;
    public IntPtr hCertStore;
}
internal class NuGet.Packaging.Signing.CERT_ID : ValueType {
    internal UInt32 dwIdChoice;
    internal BLOB KeyId;
}
internal static class NuGet.Packaging.Signing.CertificateChainUtility : object {
    internal static X509ChainStatusFlags DefaultObservedStatusFlags;
    public static IX509CertificateChain GetCertificateChain(X509Certificate2 certificate, X509Certificate2Collection extraStore, ILogger logger, CertificateType certificateType);
    public static IX509CertificateChain GetCertificateChain(X509Chain x509Chain);
    private static void GetChainStatusFlags(X509Certificate2 certificate, CertificateType certificateType, X509ChainStatusFlags& errorStatusFlags, X509ChainStatusFlags& warningStatusFlags);
    internal static void SetCertBuildChainPolicy(X509ChainPolicy policy, X509Certificate2Collection additionalCertificates, DateTime verificationTime, CertificateType certificateType);
    internal static bool BuildCertificateChain(IX509Chain chain, X509Certificate2 certificate, X509ChainStatus[]& status);
    internal static bool BuildWithPolicy(IX509Chain chain, X509Certificate2 certificate);
    internal static bool ChainStatusListIncludesStatus(X509ChainStatus[] chainStatuses, X509ChainStatusFlags status, IEnumerable`1& chainStatus);
    internal static bool TryGetStatusAndMessage(X509ChainStatus[] chainStatuses, X509ChainStatusFlags status, IEnumerable`1& statusAndMessages);
    internal static IEnumerable`1<string> GetStatusAndMessagesFromChainStatuses(IEnumerable`1<X509ChainStatus> chainStatuses);
    private static void LogAdditionalContext(IX509Chain chain, ILogger logger);
}
internal class NuGet.Packaging.Signing.CertificateHashAllowListEntry : VerificationAllowListEntry {
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <FingerprintAlgorithm>k__BackingField;
    public string Fingerprint { get; }
    public HashAlgorithmName FingerprintAlgorithm { get; }
    public CertificateHashAllowListEntry(VerificationTarget target, SignaturePlacement placement, string fingerprint, HashAlgorithmName algorithm);
    [CompilerGeneratedAttribute]
public string get_Fingerprint();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_FingerprintAlgorithm();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum NuGet.Packaging.Signing.CertificateType : Enum {
    public int value__;
    public static CertificateType Signature;
    public static CertificateType Timestamp;
}
internal static class NuGet.Packaging.Signing.CertificateUtility : object {
    private static int ChainDepthLimit;
    public static string X509Certificate2ToString(X509Certificate2 cert, HashAlgorithmName fingerprintAlgorithm);
    internal static IReadOnlyList`1<SignatureLog> X509Certificate2ToLogMessages(X509Certificate2 cert, HashAlgorithmName fingerprintAlgorithm, string indentation);
    private static void X509Certificate2ToString(X509Certificate2 cert, StringBuilder certStringBuilder, HashAlgorithmName fingerprintAlgorithm, string indentation);
    public static string X509Certificate2CollectionToString(X509Certificate2Collection certCollection, HashAlgorithmName fingerprintAlgorithm);
    public static string X509ChainToString(X509Chain chain, HashAlgorithmName fingerprintAlgorithm);
    public static bool IsSignatureAlgorithmSupported(X509Certificate2 certificate);
    public static bool IsCertificatePublicKeyValid(X509Certificate2 certificate);
    public static bool HasLifetimeSigningEku(X509Certificate2 certificate);
    public static bool HasExtendedKeyUsage(X509Certificate2 certificate, string ekuOid);
    public static bool IsValidForPurposeFast(X509Certificate2 certificate, string ekuOid);
    public static bool IsCertificateValidityPeriodInTheFuture(X509Certificate2 certificate);
    public static bool IsDateInsideValidityPeriod(X509Certificate2 certificate, DateTimeOffset date);
    public static Byte[] GetHash(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public static string GetHashString(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public static bool IsSelfIssued(X509Certificate2 certificate);
    public static IReadOnlyList`1<Byte[]> GetRawDataForCollection(X509Certificate2Collection certificates);
}
internal class NuGet.Packaging.Signing.ClientPolicyContext : object {
    [CompilerGeneratedAttribute]
private SignatureValidationMode <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedPackageVerifierSettings <VerifierSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<TrustedSignerAllowListEntry> <AllowList>k__BackingField;
    public SignatureValidationMode Policy { get; }
    public SignedPackageVerifierSettings VerifierSettings { get; }
    public IReadOnlyCollection`1<TrustedSignerAllowListEntry> AllowList { get; }
    internal ClientPolicyContext(SignatureValidationMode policy, IReadOnlyCollection`1<TrustedSignerAllowListEntry> allowList);
    [CompilerGeneratedAttribute]
public SignatureValidationMode get_Policy();
    [CompilerGeneratedAttribute]
public SignedPackageVerifierSettings get_VerifierSettings();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<TrustedSignerAllowListEntry> get_AllowList();
    public static ClientPolicyContext GetClientPolicy(ISettings settings, ILogger logger);
}
internal static class NuGet.Packaging.Signing.CmsFactory : object {
    internal static ICms Create(Byte[] cmsBytes);
}
internal enum NuGet.Packaging.Signing.CMSG_CONTROL_TYPE : Enum {
    public UInt32 value__;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_SIGNATURE;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_HASH;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_SIGNER;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_SIGNER;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CRL;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_CRL;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_ATTR_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_ATTR_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_KEY_TRANS_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_KEY_AGREE_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_MAIL_LIST_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_SIGNATURE_EX;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CMS_SIGNER_INFO;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ENABLE_STRONG_SIGNATURE;
}
internal class NuGet.Packaging.Signing.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA : ValueType {
    internal UInt32 cbSize;
    internal UInt32 dwSignerIndex;
    internal CRYPT_INTEGER_BLOB BLOB;
}
internal class NuGet.Packaging.Signing.CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA : ValueType {
    internal UInt32 cbSize;
    internal UInt32 dwSignerIndex;
    internal UInt32 dwUnauthAttrIndex;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.CMSG_ENCODING : Enum {
    public UInt32 value__;
    public static CMSG_ENCODING X509_ASN_ENCODING;
    public static CMSG_ENCODING PKCS_7_ASN_ENCODING;
    public static CMSG_ENCODING Any;
}
internal enum NuGet.Packaging.Signing.CMSG_GETPARAM_TYPE : Enum {
    public UInt32 value__;
    public static CMSG_GETPARAM_TYPE CMSG_TYPE_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CONTENT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_BARE_CONTENT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_INNER_CONTENT_TYPE_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_CERT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_HASH_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_AUTH_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_UNAUTH_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CERT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CERT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CRL_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CRL_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENVELOPE_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_HASH_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_HASH_DATA_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_COMPUTED_HASH_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENCRYPT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENCRYPTED_DIGEST;
    public static CMSG_GETPARAM_TYPE CMSG_ENCODED_SIGNER;
    public static CMSG_GETPARAM_TYPE CMSG_ENCODED_MESSAGE;
    public static CMSG_GETPARAM_TYPE CMSG_VERSION_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ATTR_CERT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ATTR_CERT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_UNPROTECTED_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_CERT_ID_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_SIGNER_INFO_PARAM;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.CMSG_OPENTODECODE_FLAGS : Enum {
    public UInt32 value__;
    public static CMSG_OPENTODECODE_FLAGS None;
    public static CMSG_OPENTODECODE_FLAGS CMSG_DETACHED_FLAG;
    public static CMSG_OPENTODECODE_FLAGS CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
}
internal class NuGet.Packaging.Signing.CMSG_SIGNED_ENCODE_INFO : ValueType {
    internal int cbSize;
    internal int cSigners;
    internal IntPtr rgSigners;
    internal int cCertEncoded;
    internal IntPtr rgCertEncoded;
    internal int cCrlEncoded;
    internal IntPtr rgCrlEncoded;
    internal int cAttrCertEncoded;
    internal IntPtr rgAttrCertEncoded;
}
internal class NuGet.Packaging.Signing.CMSG_SIGNER_ENCODE_INFO : ValueType {
    internal UInt32 cbSize;
    internal IntPtr pCertInfo;
    internal IntPtr hCryptProvOrhNCryptKey;
    internal int dwKeySpec;
    internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    internal IntPtr pvHashAuxInfo;
    internal int cAuthAttr;
    internal IntPtr rgAuthAttr;
    internal int cUnauthAttr;
    internal IntPtr rgUnauthAttr;
    internal CERT_ID SignerId;
    internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    internal IntPtr pvHashEncryptionAuxInfo;
    public void Dispose();
}
internal class NuGet.Packaging.Signing.CMSG_SIGNER_INFO : ValueType {
    internal UInt32 dwVersion;
    internal CRYPTOAPI_BLOB Issuer;
    internal CRYPTOAPI_BLOB SerialNumber;
    internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    internal CRYPTOAPI_BLOB EncryptedHash;
    internal CRYPT_ATTRIBUTES AuthAttrs;
    internal CRYPT_ATTRIBUTES UnauthAttrs;
}
internal class NuGet.Packaging.Signing.CommitmentTypeIndication : object {
    [CompilerGeneratedAttribute]
private Oid <CommitmentTypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CommitmentTypeQualifier> <Qualifiers>k__BackingField;
    public Oid CommitmentTypeId { get; }
    public IReadOnlyList`1<CommitmentTypeQualifier> Qualifiers { get; }
    private CommitmentTypeIndication(Oid commitmentTypeId, IReadOnlyList`1<CommitmentTypeQualifier> qualifiers);
    [CompilerGeneratedAttribute]
public Oid get_CommitmentTypeId();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CommitmentTypeQualifier> get_Qualifiers();
    public static CommitmentTypeIndication Create(Oid commitmentTypeId);
    public static CommitmentTypeIndication Read(Byte[] bytes);
    internal static CommitmentTypeIndication Read(DerSequenceReader reader);
    internal Byte[] Encode();
}
internal class NuGet.Packaging.Signing.CommitmentTypeQualifier : object {
    [CompilerGeneratedAttribute]
private Oid <CommitmentTypeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Qualifier>k__BackingField;
    public Oid CommitmentTypeIdentifier { get; }
    public Byte[] Qualifier { get; }
    private CommitmentTypeQualifier(Oid commitmentTypeIdentifier, Byte[] qualifier);
    [CompilerGeneratedAttribute]
public Oid get_CommitmentTypeIdentifier();
    [CompilerGeneratedAttribute]
public Byte[] get_Qualifier();
    public static CommitmentTypeQualifier Read(Byte[] bytes);
    internal static CommitmentTypeQualifier Read(DerSequenceReader reader);
    internal Byte[] Encode();
}
internal static class NuGet.Packaging.Signing.Crc32 : object {
    private static UInt32[] CrcLookUpTable;
    private static bool CrcLookUptableComputed;
    private static UInt32 Crc32Polynomial;
    private static Crc32();
    [CLSCompliantAttribute("False")]
public static UInt32 CalculateCrc(Byte[] data);
    private static UInt32 UpdateCrc(UInt32 crc, Byte[] buf, int len);
    private static void ComputeCrcLookUpTable();
}
internal class NuGet.Packaging.Signing.CRYPT_ALGORITHM_IDENTIFIER : ValueType {
    public string pszObjId;
    public CRYPT_INTEGER_BLOB Parameters;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTE : ValueType {
    internal IntPtr pszObjId;
    internal UInt32 cValue;
    internal IntPtr rgValue;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTE_STRING : ValueType {
    internal string pszObjId;
    internal UInt32 cValue;
    internal IntPtr rgValue;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTES : ValueType {
    internal UInt32 cAttr;
    internal IntPtr rgAttr;
}
internal class NuGet.Packaging.Signing.CRYPT_INTEGER_BLOB : ValueType {
    internal UInt32 cbData;
    internal IntPtr pbData;
}
internal class NuGet.Packaging.Signing.DefaultX509ChainBuildPolicy : object {
    [CompilerGeneratedAttribute]
private static IX509ChainBuildPolicy <Instance>k__BackingField;
    internal static IX509ChainBuildPolicy Instance { get; }
    private static DefaultX509ChainBuildPolicy();
    [CompilerGeneratedAttribute]
internal static IX509ChainBuildPolicy get_Instance();
    public sealed virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
internal static class NuGet.Packaging.Signing.DerEncoding.DerEncoder : object {
    private static byte ConstructedFlag;
    private static byte ConstructedSequenceTag;
    private static byte ConstructedSetTag;
    private static Byte[][] s_nullTlv;
    private static DerEncoder();
    private static Byte[] EncodeLength(int length);
    internal static Byte[][] SegmentedEncodeBoolean(bool value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(UInt32 value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes, int offset, int count);
    internal static Byte[][] SegmentedEncodeBitString(Byte[][][] childSegments);
    internal static Byte[][] SegmentedEncodeBitString(Byte[] data);
    internal static Byte[][] SegmentedEncodeBitString(int unusedBits, Byte[] data);
    internal static Byte[][] SegmentedEncodeNamedBitList(Byte[] bigEndianBytes, int namedBitsCount);
    internal static Byte[][] SegmentedEncodeOctetString(Byte[] data);
    internal static Byte[][] SegmentedEncodeNull();
    internal static Byte[] EncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeOid(Oid oid);
    internal static Byte[][] SegmentedEncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars, int offset, int count);
    internal static Byte[][] ConstructSegmentedSequence(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSequence(IEnumerable`1<Byte[][]> items);
    internal static Byte[][] ConstructSegmentedContextSpecificValue(int contextId, Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSet(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedPresortedSet(Byte[][][] items);
    internal static bool IsValidPrintableString(Char[] chars);
    internal static bool IsValidPrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeUtcTime(DateTime utcTime);
    internal static Byte[][] SegmentedEncodeGeneralizedTime(DateTime utcTime);
    internal static Byte[] ConstructSequence(Byte[][][] items);
    internal static Byte[] ConstructSequence(IEnumerable`1<Byte[][]> items);
    private static BigInteger ParseOidRid(string oidValue, Int32& startIndex);
    private static int AtoI(char c);
    private static void EncodeRid(List`1<byte> encodedData, BigInteger& rid);
    private static bool IsPrintableStringCharacter(char c);
    private static Byte[] ConcatenateArrays(Byte[][][] segments);
    private static Byte[] ConcatenateArrays(IEnumerable`1<Byte[][]> segments);
}
internal class NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime : object {
    [CompilerGeneratedAttribute]
private DateTime <DateTime>k__BackingField;
    public DateTime DateTime { get; }
    private DerGeneralizedTime(DateTime datetime);
    [CompilerGeneratedAttribute]
public DateTime get_DateTime();
    public static DerGeneralizedTime Read(string decodedTime);
}
internal class NuGet.Packaging.Signing.DerEncoding.DerSequenceReader : object {
    internal static byte ContextSpecificTagFlag;
    internal static byte ConstructedFlag;
    internal static byte ContextSpecificConstructedTag0;
    internal static byte ContextSpecificConstructedTag1;
    internal static byte ContextSpecificConstructedTag2;
    internal static byte ContextSpecificConstructedTag3;
    internal static byte ContextSpecificConstructedTag4;
    internal static byte ConstructedSequence;
    internal static byte TagClassMask;
    internal static byte TagNumberMask;
    internal static DateTimeFormatInfo s_validityDateTimeFormatInfo;
    private Byte[] _data;
    private int _end;
    private int _position;
    [CompilerGeneratedAttribute]
private int <ContentLength>k__BackingField;
    internal int ContentLength { get; private set; }
    internal bool HasData { get; }
    private DerSequenceReader(bool startAtPayload, Byte[] data, int offset, int length);
    internal DerSequenceReader(Byte[] data);
    internal DerSequenceReader(Byte[] data, int offset, int length);
    private DerSequenceReader(DerTag tagToEat, Byte[] data, int offset, int length);
    [CompilerGeneratedAttribute]
internal int get_ContentLength();
    [CompilerGeneratedAttribute]
private void set_ContentLength(int value);
    internal static DerSequenceReader CreateForPayload(Byte[] payload);
    internal bool get_HasData();
    internal byte PeekTag();
    internal bool HasTag(DerTag expectedTag);
    internal bool HasTag(byte expectedTag);
    internal void SkipValue();
    internal void ValidateAndSkipDerValue();
    internal Byte[] ReadNextEncodedValue();
    internal bool ReadBoolean();
    internal Byte[] ReadValue(DerTag tag);
    internal int ReadInteger();
    internal Byte[] ReadIntegerBytes();
    internal Byte[] ReadBitString();
    internal Byte[] ReadOctetString();
    internal string ReadOidAsString();
    internal Oid ReadOid();
    internal string ReadUtf8String();
    private DerSequenceReader ReadCollectionWithTag(DerTag expected);
    internal DerSequenceReader ReadSequence();
    internal DerSequenceReader ReadSet();
    internal string ReadPrintableString();
    internal string ReadIA5String();
    internal DateTime ReadX509Date();
    internal DateTime ReadUtcTime();
    internal DateTime ReadGeneralizedTime();
    internal string ReadBMPString();
    internal void ReadNull();
    private static string TrimTrailingNulls(string value);
    private DateTime ReadTime(DerTag timeTag, string formatString);
    private Byte[] ReadContentAsBytes();
    private void EatTag(DerTag expected);
    private static void CheckTag(DerTag expected, Byte[] data, int position);
    private int EatLength();
    private static int ScanContentLength(Byte[] data, int offset, int end, Int32& bytesConsumed);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Signing.DerEncoding.SR : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Invalid_IA5String();
}
internal class NuGet.Packaging.Signing.DotNetDefaultTrustStoreX509ChainFactory : object {
    public sealed virtual IX509Chain Create();
}
internal class NuGet.Packaging.Signing.EndOfCentralDirectoryRecord : object {
    private static IReadOnlyList`1<byte> Signature;
    [CompilerGeneratedAttribute]
private ushort <NumberOfThisDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfTheDiskWithTheStartOfTheCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CountOfEntriesInCentralDirectoryOnThisDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CountOfEntriesInCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SizeOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OffsetOfStartOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileCommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetFromStart>k__BackingField;
    internal ushort NumberOfThisDisk { get; private set; }
    internal ushort NumberOfTheDiskWithTheStartOfTheCentralDirectory { get; private set; }
    internal ushort CountOfEntriesInCentralDirectoryOnThisDisk { get; private set; }
    internal ushort CountOfEntriesInCentralDirectory { get; private set; }
    internal UInt32 SizeOfCentralDirectory { get; private set; }
    internal UInt32 OffsetOfStartOfCentralDirectory { get; private set; }
    internal ushort FileCommentLength { get; private set; }
    internal Byte[] FileComment { get; private set; }
    internal long OffsetFromStart { get; private set; }
    private static EndOfCentralDirectoryRecord();
    [CompilerGeneratedAttribute]
internal ushort get_NumberOfThisDisk();
    [CompilerGeneratedAttribute]
private void set_NumberOfThisDisk(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_NumberOfTheDiskWithTheStartOfTheCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_NumberOfTheDiskWithTheStartOfTheCentralDirectory(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CountOfEntriesInCentralDirectoryOnThisDisk();
    [CompilerGeneratedAttribute]
private void set_CountOfEntriesInCentralDirectoryOnThisDisk(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CountOfEntriesInCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_CountOfEntriesInCentralDirectory(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_SizeOfCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_SizeOfCentralDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_OffsetOfStartOfCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_OffsetOfStartOfCentralDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileCommentLength();
    [CompilerGeneratedAttribute]
private void set_FileCommentLength(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(Byte[] value);
    [CompilerGeneratedAttribute]
internal long get_OffsetFromStart();
    [CompilerGeneratedAttribute]
private void set_OffsetFromStart(long value);
    internal static EndOfCentralDirectoryRecord Read(BinaryReader reader);
    private static void SeekToEndOfCentralDirectoryRecord(BinaryReader reader);
    private static void ThrowByteSignatureNotFoundException(IReadOnlyList`1<byte> signature);
}
internal static class NuGet.Packaging.Signing.EnvironmentVariableConstants : object {
    internal static string DotNetNuGetSignatureVerification;
}
internal class NuGet.Packaging.Signing.EssCertId : object {
    [CompilerGeneratedAttribute]
private Byte[] <CertificateHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSerial <IssuerSerial>k__BackingField;
    public Byte[] CertificateHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertId(Byte[] hash, IssuerSerial issuerSerial);
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateHash();
    [CompilerGeneratedAttribute]
public IssuerSerial get_IssuerSerial();
    public static EssCertId Read(Byte[] bytes);
    internal static EssCertId Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.EssCertIdV2 : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CertificateHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSerial <IssuerSerial>k__BackingField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] CertificateHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertIdV2(AlgorithmIdentifier hashAlgorithm, Byte[] hash, IssuerSerial issuerSerial);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateHash();
    [CompilerGeneratedAttribute]
public IssuerSerial get_IssuerSerial();
    public static EssCertIdV2 Create(X509Certificate2 certificate, HashAlgorithmName hashAlgorithmName);
    public static EssCertIdV2 Read(Byte[] bytes);
    internal static EssCertIdV2 Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
internal class NuGet.Packaging.Signing.Extension : object {
    [CompilerGeneratedAttribute]
private Oid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Oid Id { get; }
    public bool Critical { get; }
    public Byte[] Value { get; }
    private Extension(Oid id, bool critical, Byte[] value);
    [CompilerGeneratedAttribute]
public Oid get_Id();
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    internal static Extension Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.Extensions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Extension> <ExtensionsList>k__BackingField;
    public IReadOnlyList`1<Extension> ExtensionsList { get; }
    private Extensions(IReadOnlyList`1<Extension> extensions);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Extension> get_ExtensionsList();
    public static Extensions Read(Byte[] bytes);
    internal static Extensions Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.ExtraField : object {
    [CompilerGeneratedAttribute]
private ushort <HeaderId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    internal ushort HeaderId { get; private set; }
    internal ushort DataSize { get; private set; }
    internal Byte[] Data { get; private set; }
    protected ExtraField(ushort headerId, ushort dataSize, Byte[] data);
    [CompilerGeneratedAttribute]
internal ushort get_HeaderId();
    [CompilerGeneratedAttribute]
private void set_HeaderId(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_DataSize();
    [CompilerGeneratedAttribute]
private void set_DataSize(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    internal static bool TryRead(CentralDirectoryHeader header, IReadOnlyList`1& extraFields);
    internal static bool TryRead(LocalFileHeader header, IReadOnlyList`1& extraFields);
    private static bool TryRead(Byte[] extraFieldBytes, bool readUncompressedFileSize, bool readCompressedFileSize, bool readRelativeOffsetOfLocalHeader, bool readDiskNumberStart, IReadOnlyList`1& extraFields);
}
internal class NuGet.Packaging.Signing.GeneralName : object {
    [CompilerGeneratedAttribute]
private X500DistinguishedName <DirectoryName>k__BackingField;
    public X500DistinguishedName DirectoryName { get; }
    private GeneralName(X500DistinguishedName directoryName);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_DirectoryName();
    public static GeneralName Create(X500DistinguishedName distinguishedName);
    public static GeneralName Read(Byte[] bytes);
    internal static GeneralName Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
internal class NuGet.Packaging.Signing.HeapBlockRetainer : object {
    private List`1<SafeLocalAllocHandle> _blocks;
    public IntPtr Alloc(int cbSize);
    public IntPtr Alloc(int howMany, int cbElement);
    public IntPtr AllocAsciiString(string s);
    public IntPtr AllocBytes(Byte[] data);
    public sealed virtual void Dispose();
}
internal interface NuGet.Packaging.Signing.ICms {
    public abstract virtual Byte[] GetPrimarySignatureSignatureValue();
    public abstract virtual Byte[] GetRepositoryCountersignatureSignatureValue();
    public abstract virtual void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    public abstract virtual void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    public abstract virtual void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    public abstract virtual void AddTimestamp(SignedCms timestamp);
    public abstract virtual Byte[] Encode();
}
internal class NuGet.Packaging.Signing.IntegrityVerificationProvider : object {
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.IntegrityVerificationProvider/<VerifyPackageIntegrityAsync>d__1")]
private Task`1<PackageVerificationResult> VerifyPackageIntegrityAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings);
}
internal class NuGet.Packaging.Signing.InvalidSignaturePackageVerificationResult : PackageVerificationResult {
    public InvalidSignaturePackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
}
internal interface NuGet.Packaging.Signing.IPackageSignatureVerifier {
    public abstract virtual Task`1<VerifySignaturesResult> VerifySignaturesAsync(ISignedPackageReader package, SignedPackageVerifierSettings settings, CancellationToken token, Guid telemetryOperationId);
}
internal interface NuGet.Packaging.Signing.IRepositorySignature {
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public abstract virtual Uri get_V3ServiceIndexUrl();
    public abstract virtual IReadOnlyList`1<string> get_PackageOwners();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampRequest {
    public abstract virtual Task`1<IRfc3161TimestampToken> SubmitRequestAsync(Uri timestampUri, TimeSpan timeout);
    public abstract virtual Byte[] GetNonce();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampToken {
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public abstract virtual IRfc3161TimestampTokenInfo get_TokenInfo();
    public abstract virtual SignedCms AsSignedCms();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampTokenInfo {
    public string PolicyId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public Oid HashAlgorithmId { get; }
    public abstract virtual string get_PolicyId();
    public abstract virtual DateTimeOffset get_Timestamp();
    public abstract virtual Nullable`1<long> get_AccuracyInMicroseconds();
    public abstract virtual Oid get_HashAlgorithmId();
    public abstract virtual bool HasMessageHash(Byte[] hash);
    public abstract virtual Byte[] GetNonce();
}
internal interface NuGet.Packaging.Signing.ISignature {
    public SignatureType Type { get; }
    public SignerInfo SignerInfo { get; }
    public abstract virtual SignatureType get_Type();
    public abstract virtual SignerInfo get_SignerInfo();
}
internal interface NuGet.Packaging.Signing.ISignatureProvider {
    public abstract virtual Task`1<PrimarySignature> CreatePrimarySignatureAsync(SignPackageRequest request, SignatureContent signatureContent, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<PrimarySignature> CreateRepositoryCountersignatureAsync(RepositorySignPackageRequest request, PrimarySignature primarySignature, ILogger logger, CancellationToken token);
}
internal interface NuGet.Packaging.Signing.ISignatureVerificationProvider {
    public abstract virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
}
internal interface NuGet.Packaging.Signing.ISignedPackage {
}
internal interface NuGet.Packaging.Signing.ISignedPackageReader {
    public abstract virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public abstract virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public abstract virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public abstract virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public abstract virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    public abstract virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
}
internal interface NuGet.Packaging.Signing.ISignedPackageWriter {
    public abstract virtual Task RemoveSignatureAsync(CancellationToken token);
    public abstract virtual Task AddSignatureAsync(Stream signatureStream, CancellationToken token);
    public abstract virtual Task`1<bool> IsZip64Async(CancellationToken token);
}
internal class NuGet.Packaging.Signing.IssuerSerial : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<GeneralName> <GeneralNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    public IReadOnlyList`1<GeneralName> GeneralNames { get; }
    public Byte[] SerialNumber { get; }
    private IssuerSerial(IReadOnlyList`1<GeneralName> generalNames, Byte[] serialNumber);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<GeneralName> get_GeneralNames();
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    public static IssuerSerial Create(X509Certificate2 certificate);
    public static IssuerSerial Read(Byte[] bytes);
    internal static IssuerSerial Read(DerSequenceReader reader);
    internal Byte[][] Encode();
    private static IReadOnlyList`1<GeneralName> ReadGeneralNames(DerSequenceReader reader);
}
internal interface NuGet.Packaging.Signing.ITimestampProvider {
    public abstract virtual Task`1<PrimarySignature> TimestampSignatureAsync(PrimarySignature primarySignature, TimestampRequest request, ILogger logger, CancellationToken token);
}
internal interface NuGet.Packaging.Signing.ITrustedSignersProvider {
    public abstract virtual IReadOnlyList`1<TrustedSignerItem> GetTrustedSigners();
    public abstract virtual void AddOrUpdateTrustedSigner(TrustedSignerItem trustedSigner);
    public abstract virtual void Remove(IReadOnlyList`1<TrustedSignerItem> trustedSigners);
}
internal interface NuGet.Packaging.Signing.IX509CertificateChain {
}
internal interface NuGet.Packaging.Signing.IX509Chain {
    public ILogMessage AdditionalContext { get; }
    public X509Chain PrivateReference { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public abstract virtual ILogMessage get_AdditionalContext();
    public abstract virtual X509Chain get_PrivateReference();
    public abstract virtual X509ChainElementCollection get_ChainElements();
    public abstract virtual X509ChainPolicy get_ChainPolicy();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual bool Build(X509Certificate2 certificate);
}
internal interface NuGet.Packaging.Signing.IX509ChainBuildPolicy {
    public abstract virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
internal interface NuGet.Packaging.Signing.IX509ChainFactory {
    public abstract virtual IX509Chain Create();
}
internal class NuGet.Packaging.Signing.KeyPairFileReader : object {
    private static Regex NamePattern;
    private StreamReader _reader;
    private bool _disposed;
    public KeyPairFileReader(Stream stream, Encoding encoding);
    private static KeyPairFileReader();
    public Dictionary`2<string, string> ReadSection();
    private static KeyValuePair`2<string, string> GetProperty(string line);
    private static void ThrowInvalidFormat();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal static class NuGet.Packaging.Signing.KeyPairFileUtility : object {
    public static string GetValueOrThrow(Dictionary`2<string, string> values, string key);
}
internal class NuGet.Packaging.Signing.KeyPairFileWriter : object {
    private StreamWriter _writer;
    private bool _disposed;
    public KeyPairFileWriter(Stream stream, Encoding encoding, bool leaveOpen);
    public void WritePair(string key, string value);
    public void WriteSectionBreak();
    private void WriteEOL();
    private static string FormatItem(string key, string value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class NuGet.Packaging.Signing.LocalFileHeader : object {
    internal static UInt32 SizeInBytesOfFixedLengthFields;
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GeneralPurposeBitFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExtraFieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtraField>k__BackingField;
    internal ushort VersionNeededToExtract { get; private set; }
    internal ushort GeneralPurposeBitFlag { get; private set; }
    internal ushort CompressionMethod { get; private set; }
    internal ushort LastModFileTime { get; private set; }
    internal ushort LastModFileDate { get; private set; }
    internal UInt32 Crc32 { get; private set; }
    internal UInt32 CompressedSize { get; private set; }
    internal UInt32 UncompressedSize { get; private set; }
    internal ushort FileNameLength { get; private set; }
    internal ushort ExtraFieldLength { get; private set; }
    internal Byte[] FileName { get; private set; }
    internal Byte[] ExtraField { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_GeneralPurposeBitFlag();
    [CompilerGeneratedAttribute]
private void set_GeneralPurposeBitFlag(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileTime();
    [CompilerGeneratedAttribute]
private void set_LastModFileTime(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileDate();
    [CompilerGeneratedAttribute]
private void set_LastModFileDate(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileNameLength();
    [CompilerGeneratedAttribute]
private void set_FileNameLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_ExtraFieldLength();
    [CompilerGeneratedAttribute]
private void set_ExtraFieldLength(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ExtraField();
    [CompilerGeneratedAttribute]
private void set_ExtraField(Byte[] value);
    internal static bool TryRead(BinaryReader reader, LocalFileHeader& header);
}
internal class NuGet.Packaging.Signing.MessageImprint : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashedMessage>k__BackingField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] HashedMessage { get; }
    private MessageImprint(AlgorithmIdentifier hashAlgorithm, Byte[] hashedMessage);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_HashedMessage();
    public static MessageImprint Read(Byte[] bytes);
    internal static MessageImprint Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.NativeCms : object {
    private SafeCryptMsgHandle _handle;
    private NativeCms(SafeCryptMsgHandle handle);
    internal Byte[] GetPrimarySignatureSignatureValue();
    private Byte[] GetByteArrayAttribute(CMSG_GETPARAM_TYPE param, UInt32 index);
    internal Byte[] GetRepositoryCountersignatureSignatureValue();
    private Nullable`1<RepositoryCounterSignerInfo> GetRepositoryCountersignature(HeapBlockRetainer retainer);
    private static bool IsRepositoryCounterSignerInfo(CMSG_SIGNER_INFO counterSignerInfo);
    private static bool IsRepositoryCounterSignerInfo(CRYPT_ATTRIBUTE_STRING commitmentTypeIndicationAttribute);
    internal static NativeCms Decode(Byte[] input);
    internal void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    internal void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    internal void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    internal void AddTimestamp(SignedCms timestamp);
    private static CRYPT_ATTRIBUTE GetCryptAttributeForData(Byte[] data, string attributeOid, HeapBlockRetainer hb);
    private static CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA CreateUnsignedAddAttribute(CRYPT_ATTRIBUTE attr, HeapBlockRetainer hb);
    internal Byte[] Encode();
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.NativeCmsWrapper : object {
    private NativeCms _nativeCms;
    public NativeCmsWrapper(NativeCms nativeCms);
    public sealed virtual Byte[] GetPrimarySignatureSignatureValue();
    public sealed virtual Byte[] GetRepositoryCountersignatureSignatureValue();
    public sealed virtual void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    public sealed virtual void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    public sealed virtual void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    public sealed virtual void AddTimestamp(SignedCms timestamp);
    public sealed virtual Byte[] Encode();
    public sealed virtual void Dispose();
}
internal static class NuGet.Packaging.Signing.NativeMethods : object {
    internal static UInt32 PKCS_ATTRIBUTE;
    internal static UInt32 PKCS7_SIGNER_INFO;
    internal static int ERROR_MORE_DATA;
    internal static UInt32 CMSG_SIGNED;
    internal static UInt32 CERT_KEY_IDENTIFIER_PROP_ID;
    internal static UInt32 CERT_ID_KEY_IDENTIFIER;
    public static SafeCryptMsgHandle CryptMsgOpenToEncode(CMSG_ENCODING dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, CMSG_SIGNED_ENCODE_INFO& pvMsgEncodeInfo, string pszInnerContentObjID, IntPtr pStreamInfo);
    public static SafeCryptMsgHandle CryptMsgOpenToDecode(CMSG_ENCODING dwMsgEncodingType, CMSG_OPENTODECODE_FLAGS dwFlags, UInt32 dwMsgType, IntPtr hCryptProv, IntPtr pRecipientInfo, IntPtr pStreamInfo);
    public static bool CryptMsgCountersign(SafeCryptMsgHandle hCryptMsg, UInt32 dwIndex, int cCountersigners, CMSG_SIGNER_ENCODE_INFO rgCountersigners);
    public static bool CryptMsgClose(IntPtr hCryptMsg);
    public static bool CryptMsgUpdate(SafeCryptMsgHandle hCryptMsg, Byte[] pbData, UInt32 cbData, bool fFinal);
    public static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, CMSG_GETPARAM_TYPE dwParamType, UInt32 dwIndex, Byte[] pvData, UInt32& pcbData);
    internal static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, CMSG_GETPARAM_TYPE dwParamType, UInt32 dwIndex, IntPtr pvData, UInt32& pcbData);
    internal static bool CryptDecodeObject(CMSG_ENCODING dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, UInt32 dwFlags, IntPtr pvStructInfo, IntPtr pcbStructInfo);
    internal static bool CryptMsgControl(SafeCryptMsgHandle hCryptMsg, UInt32 dwFlags, CMSG_CONTROL_TYPE dwCtrlType, IntPtr pvCtrlPara);
    internal static bool CryptEncodeObjectEx(CMSG_ENCODING dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, UInt32 dwFlags, IntPtr pEncodePara, IntPtr pvEncoded, UInt32& pcbEncoded);
    internal static bool CryptReleaseContext(IntPtr hProv, int dwFlags);
    internal static IntPtr CertDuplicateCertificateContext(IntPtr pCertContext);
    internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    internal static bool CertGetCertificateContextProperty(IntPtr pCertContext, UInt32 dwPropId, IntPtr pvData, UInt32& pcbData);
    internal static int GetHRForWin32Error(int err);
}
internal static class NuGet.Packaging.Signing.NativeUtility : object {
    internal static void SafeFree(IntPtr ptr);
    internal static void ThrowIfFailed(bool result);
    internal static SignedCms NativeSign(CmsSigner cmsSigner, Byte[] data, CngKey privateKey);
    internal static CMSG_SIGNER_ENCODE_INFO CreateSignerInfo(CmsSigner cmsSigner, CngKey privateKey, HeapBlockRetainer hb);
}
internal class NuGet.Packaging.Signing.NuGetPackageOwners : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public IReadOnlyList`1<string> PackageOwners { get; }
    public NuGetPackageOwners(IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackageOwners();
    public static NuGetPackageOwners Read(Byte[] bytes);
    internal static NuGetPackageOwners Read(DerSequenceReader reader);
    public Byte[] Encode();
}
internal class NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl : object {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public NuGetV3ServiceIndexUrl(Uri v3ServiceIndexUrl);
    [CompilerGeneratedAttribute]
public Uri get_V3ServiceIndexUrl();
    public static NuGetV3ServiceIndexUrl Read(Byte[] bytes);
    internal static NuGetV3ServiceIndexUrl Read(DerSequenceReader reader);
    public Byte[] Encode();
}
internal static class NuGet.Packaging.Signing.Oids : object {
    public static string SigningTime;
    public static string Countersignature;
    public static string SignatureTimeStampTokenAttribute;
    public static string Sha1;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string Sha256WithRSAEncryption;
    public static string Sha384WithRSAEncryption;
    public static string Sha512WithRSAEncryption;
    public static string CodeSigningEku;
    public static string Pkcs7Data;
    public static string BaselineTimestampPolicy;
    public static string TimeStampingEku;
    public static string EnhancedKeyUsage;
    public static string TSTInfoContentType;
    public static string LifetimeSigningEku;
    public static string CommitmentTypeIndication;
    public static string CommitmentTypeIdentifierProofOfOrigin;
    public static string CommitmentTypeIdentifierProofOfReceipt;
    public static string SigningCertificate;
    public static string SigningCertificateV2;
    public static string AuthorityKeyIdentifier;
    public static string SubjectKeyIdentifier;
    public static string AnyPolicy;
    public static string IdQtCps;
    public static string IdQtUnotice;
    public static string NuGetV3ServiceIndexUrl;
    public static string NuGetPackageOwners;
}
internal class NuGet.Packaging.Signing.PackageSignatureVerifier : object {
    private List`1<ISignatureVerificationProvider> _verificationProviders;
    public PackageSignatureVerifier(IEnumerable`1<ISignatureVerificationProvider> verificationProviders);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.PackageSignatureVerifier/<VerifySignaturesAsync>d__2")]
public sealed virtual Task`1<VerifySignaturesResult> VerifySignaturesAsync(ISignedPackageReader package, SignedPackageVerifierSettings settings, CancellationToken token, Guid parentId);
    private static bool IsValid(IEnumerable`1<PackageVerificationResult> verificationResults);
}
internal abstract class NuGet.Packaging.Signing.PackageVerificationResult : object {
    [CompilerGeneratedAttribute]
private SignatureVerificationStatus <Trust>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SignatureLog> <Issues>k__BackingField;
    public SignatureVerificationStatus Trust { get; }
    public IEnumerable`1<SignatureLog> Issues { get; }
    public PackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public virtual SignatureVerificationStatus get_Trust();
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<SignatureLog> get_Issues();
    public IEnumerable`1<ILogMessage> GetWarningIssues();
    public IEnumerable`1<ILogMessage> GetErrorIssues();
}
internal class NuGet.Packaging.Signing.PolicyInformation : object {
    [CompilerGeneratedAttribute]
private Oid <PolicyIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyQualifierInfo> <PolicyQualifiers>k__BackingField;
    public Oid PolicyIdentifier { get; }
    public IReadOnlyList`1<PolicyQualifierInfo> PolicyQualifiers { get; }
    private PolicyInformation(Oid policyIdentifier, IReadOnlyList`1<PolicyQualifierInfo> policyQualifiers);
    [CompilerGeneratedAttribute]
public Oid get_PolicyIdentifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyQualifierInfo> get_PolicyQualifiers();
    public static PolicyInformation Read(Byte[] bytes);
    internal static PolicyInformation Read(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyQualifierInfo> ReadPolicyQualifiers(DerSequenceReader reader, bool isAnyPolicy);
}
internal class NuGet.Packaging.Signing.PolicyQualifierInfo : object {
    [CompilerGeneratedAttribute]
private Oid <PolicyQualifierId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Qualifier>k__BackingField;
    public Oid PolicyQualifierId { get; }
    public Byte[] Qualifier { get; }
    private PolicyQualifierInfo(Oid policyQualifierId, Byte[] qualifier);
    [CompilerGeneratedAttribute]
public Oid get_PolicyQualifierId();
    [CompilerGeneratedAttribute]
public Byte[] get_Qualifier();
    public static PolicyQualifierInfo Read(Byte[] bytes);
    internal static PolicyQualifierInfo Read(DerSequenceReader reader);
}
internal abstract class NuGet.Packaging.Signing.PrimarySignature : Signature {
    [CompilerGeneratedAttribute]
private SignedCms <SignedCms>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureContent <SignatureContent>k__BackingField;
    public SignedCms SignedCms { get; }
    public SignatureContent SignatureContent { get; }
    public string FriendlyName { get; }
    protected PrimarySignature(SignedCms signedCms, SignatureType signatureType);
    [CompilerGeneratedAttribute]
public SignedCms get_SignedCms();
    [CompilerGeneratedAttribute]
public SignatureContent get_SignatureContent();
    public virtual string get_FriendlyName();
    public void Save(Stream stream);
    public Byte[] GetBytes();
    public static PrimarySignature Load(SignedCms cms);
    public static PrimarySignature Load(Byte[] data);
    public static PrimarySignature Load(Stream stream);
    public virtual Byte[] GetSignatureValue();
    protected virtual void ThrowForInvalidSignature();
    protected static void ThrowForInvalidPrimarySignature();
    private static void VerifySigningCertificate(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications);
    private static SignerInfo GetSignerInfo(SignedCms signedCms);
    private static SignedCms Decode(Byte[] bytes);
}
internal static class NuGet.Packaging.Signing.PrimarySignatureFactory : object {
    public static PrimarySignature CreateSignature(SignedCms signedCms);
}
internal class NuGet.Packaging.Signing.ReadOnlyBufferedStream : Stream {
    private static int _defaultBufferSize;
    private Byte[] _buffer;
    private bool _leaveOpen;
    private Lazy`1<long> _length;
    private Stream _stream;
    private long _bufferStartPosition;
    private int _bufferFillLength;
    private bool _isDisposed;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public ReadOnlyBufferedStream(Stream stream, bool leaveOpen);
    public ReadOnlyBufferedStream(Stream stream, bool leaveOpen, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private void FillBuffer();
    private bool IsPositionAfterEndOfStream();
    private bool IsPositionInBuffer();
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private long <.ctor>b__29_0();
}
internal class NuGet.Packaging.Signing.RepositoryCountersignature : Signature {
    private PrimarySignature _primarySignature;
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public string FriendlyName { get; }
    private RepositoryCountersignature(PrimarySignature primarySignature, SignerInfo counterSignerInfo, Uri v3ServiceIndexUrl, IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_PackageOwners();
    public virtual string get_FriendlyName();
    public static RepositoryCountersignature GetRepositoryCountersignature(PrimarySignature primarySignature);
    public virtual Byte[] GetSignatureValue();
    protected virtual void ThrowForInvalidSignature();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
    internal bool IsRelated(PrimarySignature primarySignature);
}
internal class NuGet.Packaging.Signing.RepositoryPrimarySignature : PrimarySignature {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public string FriendlyName { get; }
    public RepositoryPrimarySignature(SignedCms signedCms);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_PackageOwners();
    public virtual string get_FriendlyName();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
}
internal static class NuGet.Packaging.Signing.RepositorySignatureInfoUtility : object {
    public static SignedPackageVerifierSettings GetSignedPackageVerifierSettings(RepositorySignatureInfo repoSignatureInfo, SignedPackageVerifierSettings fallbackSettings);
    public static IReadOnlyCollection`1<CertificateHashAllowListEntry> GetRepositoryAllowList(IEnumerable`1<IRepositoryCertificateInfo> repositoryCertificateInfos);
}
internal class NuGet.Packaging.Signing.RepositorySignPackageRequest : SignPackageRequest {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public SignatureType SignatureType { get; }
    public RepositorySignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm, Uri v3ServiceIndexUrl, IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackageOwners();
    public virtual SignatureType get_SignatureType();
}
internal class NuGet.Packaging.Signing.RetriableX509ChainBuildPolicy : object {
    [CompilerGeneratedAttribute]
private IX509ChainBuildPolicy <InnerPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SleepInterval>k__BackingField;
    internal IX509ChainBuildPolicy InnerPolicy { get; }
    internal int RetryCount { get; }
    internal TimeSpan SleepInterval { get; }
    internal RetriableX509ChainBuildPolicy(IX509ChainBuildPolicy innerPolicy, int retryCount, TimeSpan sleepInterval);
    [CompilerGeneratedAttribute]
internal IX509ChainBuildPolicy get_InnerPolicy();
    [CompilerGeneratedAttribute]
internal int get_RetryCount();
    [CompilerGeneratedAttribute]
internal TimeSpan get_SleepInterval();
    public sealed virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampProvider : object {
    private Uri _timestamperUrl;
    private static TimeSpan RequestTimeout;
    public Rfc3161TimestampProvider(Uri timeStampServerUrl);
    private static Rfc3161TimestampProvider();
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.Rfc3161TimestampProvider/<TimestampSignatureAsync>d__3")]
public sealed virtual Task`1<PrimarySignature> TimestampSignatureAsync(PrimarySignature primarySignature, TimestampRequest request, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.Rfc3161TimestampProvider/<GetTimestampAsync>d__4")]
internal Task`1<SignedCms> GetTimestampAsync(TimestampRequest request, ILogger logger, CancellationToken token);
    private static SignedCms EnsureCertificatesInCertificatesCollection(SignedCms timestamp, IReadOnlyList`1<X509Certificate2> chain);
    private static void ValidateTimestampCms(SigningSpecifications spec, SignedCms timestampCms, IRfc3161TimestampToken timestampToken);
    private static void ValidateTimestampResponse(Byte[] nonce, Byte[] messageHash, IRfc3161TimestampToken timestampToken);
    private static string GetNameOrOidString(Oid oid);
    private static Byte[] GenerateNonce();
    internal static void EnsureValidNonce(Byte[] nonce);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequest : AsnEncodedData {
    private DataType _data;
    private DataType Data { get; }
    public int Version { get; }
    public Oid HashAlgorithmId { get; }
    public Oid RequestedPolicyId { get; }
    public bool RequestSignerCertificate { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampRequest(Byte[] encodedRequest);
    public Rfc3161TimestampRequest(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public Rfc3161TimestampRequest(Byte[] messageHash, Oid hashAlgorithmId, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    private DataType get_Data();
    private static Oid OpportunisticOid(string oidValue, OidGroup group);
    public int get_Version();
    public Byte[] GetMessageHash();
    public Oid get_HashAlgorithmId();
    public Oid get_RequestedPolicyId();
    public Byte[] GetNonce();
    public bool get_RequestSignerCertificate();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    public IRfc3161TimestampToken SubmitRequest(Uri timestampUri, TimeSpan timeout);
    private static Byte[] Encode(DataType data);
    private static DataType Decode(Byte[] rawData);
    private static bool ResolveAlgorithm(HashAlgorithmName hashAlgorithm, Int32& expectedSizeInBytes, String& algorithmIdentifier);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequestFactory : object {
    public static IRfc3161TimestampRequest Create(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequestNet472Wrapper : object {
    private Rfc3161TimestampRequest _rfc3161TimestampRequest;
    public Rfc3161TimestampRequestNet472Wrapper(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public sealed virtual Task`1<IRfc3161TimestampToken> SubmitRequestAsync(Uri timestampUri, TimeSpan timeout);
    public sealed virtual Byte[] GetNonce();
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampToken : object {
    private Byte[] _encoded;
    [CompilerGeneratedAttribute]
private IRfc3161TimestampTokenInfo <TokenInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <SignerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <AdditionalCerts>k__BackingField;
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public X509Certificate2 SignerCertificate { get; }
    public X509Certificate2Collection AdditionalCerts { get; }
    internal Rfc3161TimestampToken(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
    [CompilerGeneratedAttribute]
public IRfc3161TimestampTokenInfo get_TokenInfo();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_SignerCertificate();
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_AdditionalCerts();
    public Byte[] GetEncodedValue();
    public SignedCms AsSignedCms();
    public static Rfc3161TimestampToken LoadOnly(Byte[] encodedToken);
    public static Rfc3161TimestampToken LoadAndVerifyData(Byte[] encodedToken, Byte[] data);
    public static Rfc3161TimestampToken LoadAndVerifyHash(Byte[] encodedToken, Byte[] hash);
    private static Rfc3161TimestampToken CryptVerifyTimeStampSignature(Byte[] encodedToken, Byte[] data);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenFactory : object {
    public static IRfc3161TimestampToken Create(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo : AsnEncodedData {
    public static string TimestampTokenInfoId;
    private TstInfo _decoded;
    private TstInfo Decoded { get; }
    public int Version { get; }
    public string PolicyId { get; }
    public Oid HashAlgorithmId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public bool IsOrdering { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampTokenInfo(Byte[] timestampTokenInfo);
    internal Rfc3161TimestampTokenInfo(IntPtr pTsContext);
    private TstInfo get_Decoded();
    public int get_Version();
    public string get_PolicyId();
    public Oid get_HashAlgorithmId();
    public Byte[] GetMessageHash();
    public bool HasMessageHash(Byte[] hash);
    public Byte[] GetSerialNumber();
    public DateTimeOffset get_Timestamp();
    public Nullable`1<long> get_AccuracyInMicroseconds();
    public bool get_IsOrdering();
    public Byte[] GetNonce();
    public Byte[] GetTimestampAuthorityName();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    internal static X509ExtensionCollection ShallowCopy(X509ExtensionCollection existing, bool preserveNull);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal static Byte[] CopyFromNative(CRYPTOAPI_BLOB& blob);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfoFactory : object {
    public static IRfc3161TimestampTokenInfo Create(Byte[] bytes);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfoNet472Wrapper : object {
    private Rfc3161TimestampTokenInfo _rfc3161TimestampTokenInfo;
    public string PolicyId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public Oid HashAlgorithmId { get; }
    public Rfc3161TimestampTokenInfoNet472Wrapper(Byte[] timestampTokenInfo);
    public Rfc3161TimestampTokenInfoNet472Wrapper(Rfc3161TimestampTokenInfo timestampTokenInfo);
    public sealed virtual string get_PolicyId();
    public sealed virtual DateTimeOffset get_Timestamp();
    public sealed virtual Nullable`1<long> get_AccuracyInMicroseconds();
    public sealed virtual Oid get_HashAlgorithmId();
    public sealed virtual bool HasMessageHash(Byte[] hash);
    public sealed virtual Byte[] GetNonce();
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenNet472Wrapper : object {
    private Rfc3161TimestampToken _rfc3161TimestampToken;
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public Rfc3161TimestampTokenNet472Wrapper(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
    public sealed virtual IRfc3161TimestampTokenInfo get_TokenInfo();
    public sealed virtual SignedCms AsSignedCms();
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Signing.Rfc3161TimestampUtils : object {
    internal static bool IsLegalOid(string algorithmIdentifier);
    [ExtensionAttribute]
public static Byte[] GetSignature(SignerInfo signerInfo);
    [ExtensionAttribute]
internal static string ByteArrayToHex(Byte[] bytes);
    [ExtensionAttribute]
internal static Byte[] HexToByteArray(string hexString);
}
internal static class NuGet.Packaging.Signing.Rfc3161TimestampVerificationUtility : object {
    internal static bool ValidateSignerCertificateAgainstTimestamp(X509Certificate2 signerCertificate, Timestamp timestamp);
    internal static bool TryReadTSTInfoFromSignedCms(SignedCms timestampCms, IRfc3161TimestampTokenInfo& tstInfo);
    internal static double GetAccuracyInMilliseconds(IRfc3161TimestampTokenInfo tstInfo);
}
internal static class NuGet.Packaging.Signing.Rfc3161TimestampWin32 : object {
    internal static IntPtr TIMESTAMP_REQUEST;
    internal static IntPtr TIMESTAMP_INFO;
    private static Rfc3161TimestampWin32();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptRetrieveTimeStamp(string wszUrl, CryptRetrieveTimeStampFlags dwRetrievalFlags, int dwTimeout, string pszHashId, CRYPT_TIMESTAMP_PARA& pPara, Byte[] pbData, int cbData, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptVerifyTimeStampSignature(Byte[] pbTSContentInfo, int cbTSContentInfo, Byte[] pbData, int cbData, IntPtr hAdditionalStore, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static bool CryptEncodeObjectEx(CryptEncodingTypes dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, CryptEncodeObjectFlags dwFlags, IntPtr pEncodePara, IntPtr pvEncoded, UInt32& pcbEncoded);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static bool CryptDecodeObjectEx(CryptEncodingTypes dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, int cbEncoded, CryptDecodeObjectFlags dwFlags, IntPtr pDecodePara, IntPtr pvStructInfo, Int32& pcbStructInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertCloseStore(IntPtr pCertContext, int dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void CryptMemFree(IntPtr pv);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static IntPtr LocalFree(IntPtr handle);
}
internal class NuGet.Packaging.Signing.SafeCryptMsgHandle : SafeHandle {
    internal static SafeCryptMsgHandle InvalidHandle { get; }
    public bool IsInvalid { get; }
    internal SafeCryptMsgHandle(IntPtr handle);
    internal SafeCryptMsgHandle(IntPtr handle, bool ownsHandle);
    internal static SafeCryptMsgHandle get_InvalidHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class NuGet.Packaging.Signing.SafeLocalAllocHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeLocalAllocHandle(IntPtr handle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal abstract class NuGet.Packaging.Signing.Signature : object {
    private Lazy`1<IReadOnlyList`1<Timestamp>> _timestamps;
    [CompilerGeneratedAttribute]
private SignatureType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SignerInfo <SignerInfo>k__BackingField;
    private IDictionary`2<HashAlgorithmName, string> _signingCertificateFingerprintLookup;
    public SignatureType Type { get; }
    public IReadOnlyList`1<Timestamp> Timestamps { get; }
    public SignerInfo SignerInfo { get; }
    public string FriendlyName { get; }
    protected Signature(SignerInfo signerInfo, SignatureType type);
    [CompilerGeneratedAttribute]
public sealed virtual SignatureType get_Type();
    public IReadOnlyList`1<Timestamp> get_Timestamps();
    [CompilerGeneratedAttribute]
public sealed virtual SignerInfo get_SignerInfo();
    public abstract virtual Byte[] GetSignatureValue();
    protected abstract virtual void ThrowForInvalidSignature();
    public virtual string get_FriendlyName();
    internal bool TryGetValidTimestamp(SignedPackageVerifierSettings settings, HashAlgorithmName fingerprintAlgorithm, List`1<SignatureLog> issues, SignatureVerificationStatusFlags& verificationFlags, Timestamp& validTimestamp);
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
    public string GetSigningCertificateFingerprint(HashAlgorithmName algorithm);
    private void VerifySigningTimeAttribute(SignerInfo signerInfo);
    private static IReadOnlyList`1<Timestamp> GetTimestamps(SignerInfo signer, string signatureFriendlyName);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Timestamp> <.ctor>b__11_0();
}
internal class NuGet.Packaging.Signing.SignatureContent : object {
    private SigningSpecifications _signingSpecifications;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashValue>k__BackingField;
    public HashAlgorithmName HashAlgorithm { get; }
    public string HashValue { get; }
    public SignatureContent(SigningSpecifications signingSpecifications, HashAlgorithmName hashAlgorithm, string hashValue);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public string get_HashValue();
    private void Save(Stream stream);
    public Byte[] GetBytes();
    public static SignatureContent Load(Byte[] bytes, SigningSpecifications signingSpecifications);
    private static SignatureContent Load(Stream stream, SigningSpecifications signingSpecifications);
    private static void ThrowIfEmpty(Dictionary`2<string, string> properties);
    private static bool TryReadPackageHashProperty(KeyValuePair`2<string, string> property, SigningSpecifications signingSpecifications, HashAlgorithmName& hashAlgorithmName);
    private static void ThrowIfSignatureFormatVersionIsUnsupported(Dictionary`2<string, string> properties, SigningSpecifications signingSpecifications);
}
internal class NuGet.Packaging.Signing.SignatureException : PackagingException {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageVerificationResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <VerifyDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    public IReadOnlyList`1<PackageVerificationResult> Results { get; }
    public PackageIdentity PackageIdentity { get; }
    public TimeSpan VerifyDuration { get; public set; }
    public NuGetLogCode Code { get; }
    public SignatureException(NuGetLogCode code, string message);
    public SignatureException(NuGetLogCode code, string message, Exception innerException);
    public SignatureException(string message);
    public SignatureException(IReadOnlyList`1<PackageVerificationResult> results, PackageIdentity package);
    public SignatureException(NuGetLogCode code, string message, PackageIdentity package);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageVerificationResult> get_Results();
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public TimeSpan get_VerifyDuration();
    [CompilerGeneratedAttribute]
public void set_VerifyDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public NuGetLogCode get_Code();
}
internal class NuGet.Packaging.Signing.SignatureLog : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    public LogLevel Level { get; public set; }
    public string Message { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public string LibraryId { get; public set; }
    private SignatureLog(LogLevel level, NuGetLogCode code, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    public static SignatureLog MinimalLog(string message);
    public static SignatureLog InformationLog(string message);
    public static SignatureLog DetailedLog(string message);
    public static SignatureLog DebugLog(string message);
    public static SignatureLog Issue(bool fatal, NuGetLogCode code, string message);
    public static SignatureLog Error(NuGetLogCode code, string message);
    public sealed virtual bool Equals(SignatureLog other);
    public RestoreLogMessage AsRestoreLogMessage();
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.SignaturePlacement : Enum {
    public int value__;
    public static SignaturePlacement PrimarySignature;
    public static SignaturePlacement Countersignature;
    public static SignaturePlacement Any;
}
internal class NuGet.Packaging.Signing.SignatureTrustAndValidityVerificationProvider : object {
    private HashAlgorithmName _fingerprintAlgorithm;
    private IEnumerable`1<KeyValuePair`2<string, HashAlgorithmName>> _allowUntrustedRootList;
    public SignatureTrustAndValidityVerificationProvider(IEnumerable`1<KeyValuePair`2<string, HashAlgorithmName>> allowUntrustedRootList);
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    private PackageVerificationResult Verify(PrimarySignature signature, SignedPackageVerifierSettings settings);
    private SignatureVerificationSummary GetTimestamp(Signature signature, SignedPackageVerifierSettings verifierSettings, Timestamp& timestamp);
    private SignatureVerificationSummary VerifyValidityAndTrust(Signature signature, SignedPackageVerifierSettings verifierSettings, SignatureVerifySettings settings, X509Certificate2Collection certificateExtraStore);
    private bool IsUntrustedRootAllowed(Signature signature);
    private static bool HasUntrustedRoot(SignatureVerificationSummary summary);
    private static bool IsSignatureExpired(SignatureVerificationSummary summary);
}
internal enum NuGet.Packaging.Signing.SignatureType : Enum {
    public int value__;
    public static SignatureType Unknown;
    public static SignatureType Author;
    public static SignatureType Repository;
}
internal static class NuGet.Packaging.Signing.SignatureUtility : object {
    private static int SHA1HashLength;
    public static IX509CertificateChain GetCertificateChain(PrimarySignature primarySignature);
    public static IX509CertificateChain GetCertificateChain(PrimarySignature primarySignature, RepositoryCountersignature repositoryCountersignature);
    internal static IX509CertificateChain GetCertificateChain(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, string signatureFriendlyName);
    private static IX509CertificateChain GetPrimarySignatureCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, string signatureFriendlyName, bool includeChain);
    public static IX509CertificateChain GetTimestampCertificateChain(PrimarySignature primarySignature);
    public static IX509CertificateChain GetTimestampCertificateChain(PrimarySignature primarySignature, RepositoryCountersignature repositoryCountersignature);
    private static IX509CertificateChain GetRepositoryCountersignatureCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, bool includeChain);
    public static bool HasRepositoryCountersignature(PrimarySignature primarySignature);
    internal static void LogAdditionalContext(IX509Chain chain, List`1<SignatureLog> issues);
    internal static IX509CertificateChain GetTimestampCertificates(SignedCms signedCms, SigningSpecifications signingSpecifications, string signatureFriendlyName);
    private static IX509CertificateChain GetTimestampCertificates(SignedCms signedCms, SigningSpecifications signingSpecifications, string signatureFriendlyName, bool includeChain);
    private static IX509CertificateChain GetCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningCertificateRequirement signingCertificateRequirement, bool isIssuerSerialRequired, Errors errors, SigningSpecifications signingSpecifications, CertificateType certificateType, bool includeChain);
    private static bool IsMatch(X509Certificate2 certificate, EssCertIdV2 essCertIdV2, Errors errors, bool isIssuerSerialRequired);
    private static bool IsMatch(X509Certificate2 certificate, EssCertId essCertId);
    private static bool AreGeneralNamesEqual(IssuerSerial issuerSerial, X509Certificate2 certificate);
    private static bool AreSerialNumbersEqual(IssuerSerial issuerSerial, X509Certificate2 certificate);
    private static IX509CertificateChain GetCertificateChain(X509Certificate2 certificate, X509Certificate2Collection extraStore, CertificateType certificateType, bool includeCertificatesAfterSigningCertificate);
    private static DerSequenceReader CreateDerSequenceReader(CryptographicAttributeObject attribute);
}
internal enum NuGet.Packaging.Signing.SignatureVerificationBehavior : Enum {
    public int value__;
    public static SignatureVerificationBehavior Never;
    public static SignatureVerificationBehavior IfExists;
    public static SignatureVerificationBehavior IfExistsAndIsNecessary;
    public static SignatureVerificationBehavior Always;
}
internal enum NuGet.Packaging.Signing.SignatureVerificationStatus : Enum {
    public int value__;
    public static SignatureVerificationStatus Unknown;
    public static SignatureVerificationStatus Suspect;
    public static SignatureVerificationStatus Disallowed;
    public static SignatureVerificationStatus Valid;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.SignatureVerificationStatusFlags : Enum {
    public int value__;
    public static SignatureVerificationStatusFlags NoErrors;
    public static SignatureVerificationStatusFlags NoSignature;
    public static SignatureVerificationStatusFlags NoCertificate;
    public static SignatureVerificationStatusFlags MultipleSignatures;
    public static SignatureVerificationStatusFlags SignatureCheckFailed;
    public static SignatureVerificationStatusFlags SignatureAlgorithmUnsupported;
    public static SignatureVerificationStatusFlags CertificatePublicKeyInvalid;
    public static SignatureVerificationStatusFlags HasLifetimeSigningEku;
    public static SignatureVerificationStatusFlags CertificateValidityInTheFuture;
    public static SignatureVerificationStatusFlags CertificateExpired;
    public static SignatureVerificationStatusFlags HashAlgorithmUnsupported;
    public static SignatureVerificationStatusFlags MessageImprintUnsupportedAlgorithm;
    public static SignatureVerificationStatusFlags IntegrityCheckFailed;
    public static SignatureVerificationStatusFlags ChainBuildingFailure;
    public static SignatureVerificationStatusFlags UnknownRevocation;
    public static SignatureVerificationStatusFlags CertificateRevoked;
    public static SignatureVerificationStatusFlags UntrustedRoot;
    public static SignatureVerificationStatusFlags GeneralizedTimeOutsideValidity;
    public static SignatureVerificationStatusFlags NoValidTimestamp;
    public static SignatureVerificationStatusFlags MultipleTimestamps;
    public static SignatureVerificationStatusFlags UnknownBuildStatus;
    public static SignatureVerificationStatusFlags Suspect;
    public static SignatureVerificationStatusFlags Illegal;
    public static SignatureVerificationStatusFlags Untrusted;
}
internal class NuGet.Packaging.Signing.SignatureVerificationSummary : object {
    [CompilerGeneratedAttribute]
private SignatureType <SignatureType>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationStatusFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Timestamp <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SignatureLog> <Issues>k__BackingField;
    public SignatureType SignatureType { get; }
    public SignatureVerificationStatus Status { get; }
    public SignatureVerificationStatusFlags Flags { get; }
    public Timestamp Timestamp { get; }
    public Nullable`1<DateTimeOffset> ExpirationTime { get; }
    public IEnumerable`1<SignatureLog> Issues { get; public set; }
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, Timestamp timestamp, Nullable`1<DateTimeOffset> expirationTime, IEnumerable`1<SignatureLog> issues);
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, Timestamp timestamp, IEnumerable`1<SignatureLog> issues);
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
public SignatureVerificationStatus get_Status();
    [CompilerGeneratedAttribute]
public SignatureVerificationStatusFlags get_Flags();
    [CompilerGeneratedAttribute]
public Timestamp get_Timestamp();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SignatureLog> get_Issues();
    [CompilerGeneratedAttribute]
public void set_Issues(IEnumerable`1<SignatureLog> value);
}
internal class NuGet.Packaging.Signing.SignatureVerifySettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowIllegal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUntrustedRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private RevocationMode <RevocationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureVerifySettings <Default>k__BackingField;
    public bool AllowIllegal { get; }
    public bool AllowUntrusted { get; }
    public bool AllowUnknownRevocation { get; }
    public bool ReportUnknownRevocation { get; }
    public bool ReportUntrustedRoot { get; }
    public RevocationMode RevocationMode { get; }
    public static SignatureVerifySettings Default { get; }
    public SignatureVerifySettings(bool allowIllegal, bool allowUntrusted, bool allowUnknownRevocation, bool reportUnknownRevocation, bool reportUntrustedRoot, RevocationMode revocationMode);
    private static SignatureVerifySettings();
    [CompilerGeneratedAttribute]
public bool get_AllowIllegal();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrusted();
    [CompilerGeneratedAttribute]
public bool get_AllowUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUntrustedRoot();
    [CompilerGeneratedAttribute]
public RevocationMode get_RevocationMode();
    [CompilerGeneratedAttribute]
public static SignatureVerifySettings get_Default();
}
internal class NuGet.Packaging.Signing.SignedPackageArchive : PackageArchiveReader {
    private Stream _zipWriteStream;
    public SignedPackageArchive(Stream packageReadStream, Stream packageWriteStream);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchive/<AddSignatureAsync>d__2")]
public sealed virtual Task AddSignatureAsync(Stream signatureStream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchive/<RemoveSignatureAsync>d__3")]
public sealed virtual Task RemoveSignatureAsync(CancellationToken token);
    public sealed virtual Task`1<bool> IsZip64Async(CancellationToken token);
    internal UInt32 GetPackageEntryCount();
    protected virtual void Dispose(bool disposing);
}
internal static class NuGet.Packaging.Signing.SignedPackageArchiveIOUtility : object {
    private static int _bufferSize;
    private static SigningSpecifications _signingSpecification;
    private static int ValidZipDate_YearMin;
    private static int ValidZipDate_YearMax;
    private static SignedPackageArchiveIOUtility();
    public static void ReadAndWriteUntilPosition(BinaryReader reader, BinaryWriter writer, long position);
    public static void ReadAndHashUntilPosition(BinaryReader reader, HashAlgorithm hashAlgorithm, long position);
    public static void HashBytes(HashAlgorithm hashAlgorithm, Byte[] bytes);
    internal static void HashBytes(HashAlgorithm hashAlgorithm, Byte[] bytes, int count);
    internal static void ReadAndHashUntilPosition(BinaryReader reader, Sha512HashFunction hashFunc, long position);
    internal static void HashBytes(Sha512HashFunction hashFunc, Byte[] bytes);
    internal static void HashBytes(Sha512HashFunction hashFunc, Byte[] bytes, int count);
    public static SignedPackageArchiveMetadata ReadSignedArchiveMetadata(BinaryReader reader, bool validateSignatureEntry);
    internal static void RemoveSignature(BinaryReader reader, BinaryWriter writer);
    private static UnsignedPackageArchiveMetadata ReadUnsignedArchiveMetadata(BinaryReader reader);
    private static void UpdateLocalFileHeadersTotalSize(IReadOnlyList`1<CentralDirectoryHeaderMetadata> records, long startOfCentralDirectory);
    private static void AssertSignatureEntryMetadata(BinaryReader reader, SignedPackageArchiveMetadata metadata);
    private static void AssertSignatureEntryCommonHeaderFields(BinaryReader reader, string errorPrefix, string errorSuffix);
    private static void AssertValue(UInt32 expectedValue, UInt32 actualValue, NuGetLogCode errorCode, string errorMessagePrefix, string errorMessageSuffix, string fieldName);
    internal static void WriteSignatureIntoZip(MemoryStream signatureStream, BinaryReader reader, BinaryWriter writer);
    private static long WriteLocalFileHeaderIntoZip(BinaryWriter writer, Byte[] fileData, UInt32 crc32, UInt32 dosDateTime);
    private static long WriteFileIntoZip(BinaryWriter writer, Byte[] fileData);
    private static long WriteCentralDirectoryHeaderIntoZip(BinaryWriter writer, Byte[] fileData, UInt32 crc32, UInt32 dosDateTime, long fileOffset);
    private static void ReadAndWriteUpdatedEndOfCentralDirectoryRecordIntoZip(BinaryReader reader, BinaryWriter writer, sbyte entryCountChange, long sizeOfSignatureCentralDirectoryRecord, long sizeOfSignatureFileHeaderAndData);
    private static bool CurrentStreamPositionMatchesByteSignature(BinaryReader reader, Byte[] byteSignature);
    private static UInt32 DateTimeToDosTime(DateTime dateTime);
}
internal class NuGet.Packaging.Signing.SignedPackageArchiveMetadata : object {
    [CompilerGeneratedAttribute]
private List`1<CentralDirectoryHeaderMetadata> <CentralDirectoryHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOfLocalFileHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SignatureCentralDirectoryHeaderIndex>k__BackingField;
    public List`1<CentralDirectoryHeaderMetadata> CentralDirectoryHeaders { get; public set; }
    public long StartOfLocalFileHeaders { get; public set; }
    public long EndOfCentralDirectory { get; public set; }
    public int SignatureCentralDirectoryHeaderIndex { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<CentralDirectoryHeaderMetadata> get_CentralDirectoryHeaders();
    [CompilerGeneratedAttribute]
public void set_CentralDirectoryHeaders(List`1<CentralDirectoryHeaderMetadata> value);
    [CompilerGeneratedAttribute]
public long get_StartOfLocalFileHeaders();
    [CompilerGeneratedAttribute]
public void set_StartOfLocalFileHeaders(long value);
    [CompilerGeneratedAttribute]
public long get_EndOfCentralDirectory();
    [CompilerGeneratedAttribute]
public void set_EndOfCentralDirectory(long value);
    [CompilerGeneratedAttribute]
public int get_SignatureCentralDirectoryHeaderIndex();
    [CompilerGeneratedAttribute]
public void set_SignatureCentralDirectoryHeaderIndex(int value);
    public CentralDirectoryHeaderMetadata GetPackageSignatureFileCentralDirectoryHeaderMetadata();
}
internal static class NuGet.Packaging.Signing.SignedPackageArchiveUtility : object {
    private static SigningSpecifications _signingSpecification;
    private static SignedPackageArchiveUtility();
    public static bool IsSigned(BinaryReader reader);
    public static Stream OpenPackageSignatureFileStream(BinaryReader reader);
    private static Stream GetPackageSignatureFile(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader);
    private static LocalFileHeader ReadPackageSignatureFileLocalFileHeader(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader);
    internal static bool IsPackageSignatureFileEntry(Byte[] fileName, ushort generalPurposeBitFlag);
    public static bool IsZip64(BinaryReader reader);
    private static bool HasZip64ExtendedInformationExtraField(CentralDirectoryHeader header);
    private static bool HasZip64ExtendedInformationExtraField(LocalFileHeader header);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchiveUtility/<RemoveRepositorySignaturesAsync>d__9")]
public static Task`1<bool> RemoveRepositorySignaturesAsync(Stream input, Stream output, CancellationToken cancellationToken);
    private static Task RemoveRepositoryPrimarySignatureAsync(Stream input, Stream output, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchiveUtility/<RemoveRepositoryCountersignaturesAsync>d__11")]
private static Task`1<bool> RemoveRepositoryCountersignaturesAsync(Stream input, Stream output, SignedCms signedCms, CancellationToken cancellationToken);
    private static bool TryRemoveRepositoryCountersignatures(SignedCms signedCms, SignedCms& updatedSignedCms);
    private static SignedCms Reencode(SignedCms signedCms);
    internal static void SignZip(MemoryStream signatureStream, BinaryReader reader, BinaryWriter writer);
    internal static void UnsignZip(BinaryReader reader, BinaryWriter writer);
    internal static void HashUInt16(HashAlgorithm hashAlgorithm, ushort value);
    internal static void HashUInt32(HashAlgorithm hashAlgorithm, UInt32 value);
    internal static bool VerifySignedPackageIntegrity(BinaryReader reader, HashAlgorithm hashAlgorithm, Byte[] expectedHash);
    private static List`1<CentralDirectoryHeaderMetadata> RemoveSignatureAndOrderByOffset(SignedPackageArchiveMetadata metadata);
    internal static void HashUInt16(Sha512HashFunction hashFunc, ushort value);
    internal static void HashUInt32(Sha512HashFunction hashFunc, UInt32 value);
    internal static string GetPackageContentHash(BinaryReader reader);
    internal static bool IsUtf8(ushort generalPurposeBitFlags);
    private static bool CompareHash(Byte[] expectedHash, Byte[] actualHash);
}
internal class NuGet.Packaging.Signing.SignedPackageVerificationResult : PackageVerificationResult {
    [CompilerGeneratedAttribute]
private PrimarySignature <Signature>k__BackingField;
    public PrimarySignature Signature { get; }
    public SignedPackageVerificationResult(SignatureVerificationStatus trust, PrimarySignature signature, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public PrimarySignature get_Signature();
}
internal class NuGet.Packaging.Signing.SignedPackageVerifierSettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowUnsigned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIllegal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIgnoreTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleTimestamps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNoTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private VerificationTarget <VerificationTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <SignaturePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationBehavior <RepositoryCountersignatureVerificationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private RevocationMode <RevocationMode>k__BackingField;
    public bool AllowUnsigned { get; }
    public bool AllowIllegal { get; }
    public bool AllowUntrusted { get; }
    public bool AllowIgnoreTimestamp { get; }
    public bool AllowMultipleTimestamps { get; }
    public bool AllowNoTimestamp { get; }
    public bool AllowUnknownRevocation { get; }
    public bool ReportUnknownRevocation { get; }
    public VerificationTarget VerificationTarget { get; }
    public SignaturePlacement SignaturePlacement { get; }
    public SignatureVerificationBehavior RepositoryCountersignatureVerificationBehavior { get; }
    public RevocationMode RevocationMode { get; }
    public SignedPackageVerifierSettings(bool allowUnsigned, bool allowIllegal, bool allowUntrusted, bool allowIgnoreTimestamp, bool allowMultipleTimestamps, bool allowNoTimestamp, bool allowUnknownRevocation, bool reportUnknownRevocation, VerificationTarget verificationTarget, SignaturePlacement signaturePlacement, SignatureVerificationBehavior repositoryCountersignatureVerificationBehavior, RevocationMode revocationMode);
    [CompilerGeneratedAttribute]
public bool get_AllowUnsigned();
    [CompilerGeneratedAttribute]
public bool get_AllowIllegal();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrusted();
    [CompilerGeneratedAttribute]
public bool get_AllowIgnoreTimestamp();
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleTimestamps();
    [CompilerGeneratedAttribute]
public bool get_AllowNoTimestamp();
    [CompilerGeneratedAttribute]
public bool get_AllowUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUnknownRevocation();
    [CompilerGeneratedAttribute]
public VerificationTarget get_VerificationTarget();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_SignaturePlacement();
    [CompilerGeneratedAttribute]
public SignatureVerificationBehavior get_RepositoryCountersignatureVerificationBehavior();
    [CompilerGeneratedAttribute]
public RevocationMode get_RevocationMode();
    public static SignedPackageVerifierSettings GetDefault(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetAcceptModeDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetRequireModeDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetVerifyCommandDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
}
internal class NuGet.Packaging.Signing.SigningCertificate : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EssCertId> <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyInformation> <Policies>k__BackingField;
    public IReadOnlyList`1<EssCertId> Certificates { get; }
    public IReadOnlyList`1<PolicyInformation> Policies { get; }
    private SigningCertificate(IReadOnlyList`1<EssCertId> certificates, IReadOnlyList`1<PolicyInformation> policies);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EssCertId> get_Certificates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyInformation> get_Policies();
    public static SigningCertificate Read(Byte[] bytes);
    internal static SigningCertificate Read(DerSequenceReader reader);
    private static List`1<EssCertId> ReadCertificates(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyInformation> ReadPolicies(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.SigningCertificateV2 : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EssCertIdV2> <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyInformation> <Policies>k__BackingField;
    public IReadOnlyList`1<EssCertIdV2> Certificates { get; }
    public IReadOnlyList`1<PolicyInformation> Policies { get; }
    private SigningCertificateV2(IReadOnlyList`1<EssCertIdV2> certificates, IReadOnlyList`1<PolicyInformation> policies);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EssCertIdV2> get_Certificates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyInformation> get_Policies();
    public static SigningCertificateV2 Create(X509Certificate2 certificate, HashAlgorithmName hashAlgorithmName);
    public static SigningCertificateV2 Read(Byte[] bytes);
    internal static SigningCertificateV2 Read(DerSequenceReader reader);
    public Byte[] Encode();
    private static IReadOnlyList`1<EssCertIdV2> ReadCertificates(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyInformation> ReadPolicies(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.SigningOptions : object {
    private Lazy`1<Stream> _inputPackageStream;
    private Lazy`1<Stream> _outputPackageStream;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignatureProvider <SignatureProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public Stream InputPackageStream { get; }
    public Stream OutputPackageStream { get; }
    public bool Overwrite { get; }
    public ISignatureProvider SignatureProvider { get; }
    public ILogger Logger { get; }
    public SigningOptions(Lazy`1<Stream> inputPackageStream, Lazy`1<Stream> outputPackageStream, bool overwrite, ISignatureProvider signatureProvider, ILogger logger);
    public Stream get_InputPackageStream();
    public Stream get_OutputPackageStream();
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public ISignatureProvider get_SignatureProvider();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    public static SigningOptions CreateFromFilePaths(string inputPackageFilePath, string outputPackageFilePath, bool overwrite, ISignatureProvider signatureProvider, ILogger logger);
    public sealed virtual void Dispose();
    private static string NormalizeFilePath(string filePath);
}
internal abstract class NuGet.Packaging.Signing.SigningSpecifications : object {
    public static SigningSpecificationsV1 V1;
    public string Version { get; }
    public string SignaturePath { get; }
    public HashAlgorithmName[] AllowedHashAlgorithms { get; }
    public String[] AllowedHashAlgorithmOids { get; }
    public SignatureAlgorithmName[] AllowedSignatureAlgorithms { get; }
    public String[] AllowedSignatureAlgorithmOids { get; }
    public int RSAPublicKeyMinLength { get; }
    public Encoding Encoding { get; }
    private static SigningSpecifications();
    public abstract virtual string get_Version();
    public abstract virtual string get_SignaturePath();
    public abstract virtual HashAlgorithmName[] get_AllowedHashAlgorithms();
    public abstract virtual String[] get_AllowedHashAlgorithmOids();
    public abstract virtual SignatureAlgorithmName[] get_AllowedSignatureAlgorithms();
    public abstract virtual String[] get_AllowedSignatureAlgorithmOids();
    public abstract virtual int get_RSAPublicKeyMinLength();
    public abstract virtual Encoding get_Encoding();
}
internal class NuGet.Packaging.Signing.SigningSpecificationsV1 : SigningSpecifications {
    private static string _signaturePath;
    private static int _rsaPublicKeyMinLength;
    private static Encoding _encoding;
    private static HashAlgorithmName[] _allowedHashAlgorithms;
    private static String[] _allowedHashAlgorithmOids;
    private static SignatureAlgorithmName[] _allowedSignatureAlgorithms;
    private static String[] _allowedSignatureAlgorithmOids;
    public string Version { get; }
    public string SignaturePath { get; }
    public HashAlgorithmName[] AllowedHashAlgorithms { get; }
    public String[] AllowedHashAlgorithmOids { get; }
    public SignatureAlgorithmName[] AllowedSignatureAlgorithms { get; }
    public String[] AllowedSignatureAlgorithmOids { get; }
    public int RSAPublicKeyMinLength { get; }
    public Encoding Encoding { get; }
    private static SigningSpecificationsV1();
    public virtual string get_Version();
    public virtual string get_SignaturePath();
    public virtual HashAlgorithmName[] get_AllowedHashAlgorithms();
    public virtual String[] get_AllowedHashAlgorithmOids();
    public virtual SignatureAlgorithmName[] get_AllowedSignatureAlgorithms();
    public virtual String[] get_AllowedSignatureAlgorithmOids();
    public virtual int get_RSAPublicKeyMinLength();
    public virtual Encoding get_Encoding();
}
internal static class NuGet.Packaging.Signing.SigningUtility : object {
    public static void Verify(SignPackageRequest request, ILogger logger);
    public static CryptographicAttributeObjectCollection CreateSignedAttributes(SignPackageRequest request, IReadOnlyList`1<X509Certificate2> chainList);
    public static CryptographicAttributeObjectCollection CreateSignedAttributes(RepositorySignPackageRequest request, IReadOnlyList`1<X509Certificate2> chainList);
    public static CmsSigner CreateCmsSigner(SignPackageRequest request, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SigningUtility/<SignAsync>d__4")]
public static Task SignAsync(SigningOptions options, SignPackageRequest signRequest, CancellationToken token);
    private static SignatureContent GenerateSignatureContent(HashAlgorithmName hashAlgorithmName, Byte[] zipArchiveHash);
}
internal abstract class NuGet.Packaging.Signing.SignPackageRequest : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <SignatureHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <TimestampHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <AdditionalCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IX509CertificateChain <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private CngKey <PrivateKey>k__BackingField;
    public HashAlgorithmName SignatureHashAlgorithm { get; }
    public HashAlgorithmName TimestampHashAlgorithm { get; }
    public X509Certificate2 Certificate { get; }
    public X509Certificate2Collection AdditionalCertificates { get; }
    public SignatureType SignatureType { get; }
    internal IX509CertificateChain Chain { get; private set; }
    public CngKey PrivateKey { get; public set; }
    protected SignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_SignatureHashAlgorithm();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_TimestampHashAlgorithm();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_AdditionalCertificates();
    public abstract virtual SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
internal IX509CertificateChain get_Chain();
    [CompilerGeneratedAttribute]
private void set_Chain(IX509CertificateChain value);
    [CompilerGeneratedAttribute]
public CngKey get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(CngKey value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void BuildSigningCertificateChainOnce(ILogger logger);
}
internal class NuGet.Packaging.Signing.Timestamp : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <UpperLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LowerLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <GeneralizedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedCms <SignedCms>k__BackingField;
    [CompilerGeneratedAttribute]
private IRfc3161TimestampTokenInfo <TstInfo>k__BackingField;
    public DateTimeOffset UpperLimit { get; }
    public DateTimeOffset LowerLimit { get; }
    public DateTimeOffset GeneralizedTime { get; }
    public SignedCms SignedCms { get; }
    public SignerInfo SignerInfo { get; }
    internal IRfc3161TimestampTokenInfo TstInfo { get; }
    public Timestamp(SignedCms timestampCms);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_UpperLimit();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LowerLimit();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_GeneralizedTime();
    [CompilerGeneratedAttribute]
public SignedCms get_SignedCms();
    public SignerInfo get_SignerInfo();
    [CompilerGeneratedAttribute]
internal IRfc3161TimestampTokenInfo get_TstInfo();
    internal SignatureVerificationStatusFlags Verify(Signature signature, SignedPackageVerifierSettings settings, HashAlgorithmName fingerprintAlgorithm, List`1<SignatureLog> issues);
}
internal class NuGet.Packaging.Signing.TimestampException : SignatureException {
    public TimestampException(NuGetLogCode code, string message);
    public TimestampException(NuGetLogCode code, string message, Exception innerException);
    public TimestampException(string message);
}
internal class NuGet.Packaging.Signing.TimestampRequest : object {
    [CompilerGeneratedAttribute]
private SigningSpecifications <SigningSpecifications>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <Target>k__BackingField;
    public SigningSpecifications SigningSpecifications { get; }
    public Byte[] HashedMessage { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public SignaturePlacement Target { get; }
    public TimestampRequest(SigningSpecifications signingSpecifications, Byte[] hashedMessage, HashAlgorithmName hashAlgorithm, SignaturePlacement target);
    [CompilerGeneratedAttribute]
public SigningSpecifications get_SigningSpecifications();
    [CompilerGeneratedAttribute]
public Byte[] get_HashedMessage();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_Target();
}
internal class NuGet.Packaging.Signing.TrustedSignerAllowListEntry : CertificateHashAllowListEntry {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrustedRoot>k__BackingField;
    public IReadOnlyList`1<string> Owners { get; }
    public bool AllowUntrustedRoot { get; }
    public TrustedSignerAllowListEntry(VerificationTarget target, SignaturePlacement placement, string fingerprint, HashAlgorithmName algorithm, bool allowUntrustedRoot, IReadOnlyList`1<string> owners);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrustedRoot();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.Packaging.Signing.TrustedSignersProvider : object {
    private ISettings _settings;
    public TrustedSignersProvider(ISettings settings);
    public sealed virtual IReadOnlyList`1<TrustedSignerItem> GetTrustedSigners();
    public sealed virtual void Remove(IReadOnlyList`1<TrustedSignerItem> trustedSigners);
    public sealed virtual void AddOrUpdateTrustedSigner(TrustedSignerItem trustedSigner);
    public static IReadOnlyList`1<TrustedSignerAllowListEntry> GetAllowListEntries(ISettings settings, ILogger logger);
    private static string GetCertLookupKey(CertificateItem certificate);
    private static VerificationTarget GetItemTarget(TrustedSignerItem item, SignaturePlacement& placement);
}
internal class NuGet.Packaging.Signing.TstInfo : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Oid <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageImprint <MessageImprint>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <GenTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Accuracy <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordering>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Tsa>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ExtensionCollection <Extensions>k__BackingField;
    public int Version { get; }
    public Oid Policy { get; }
    public MessageImprint MessageImprint { get; }
    public Byte[] SerialNumber { get; }
    public DateTimeOffset GenTime { get; }
    public Accuracy Accuracy { get; }
    public bool Ordering { get; }
    public Byte[] Nonce { get; }
    public Byte[] Tsa { get; }
    public X509ExtensionCollection Extensions { get; }
    private TstInfo(int version, Oid policy, MessageImprint messageImprint, Byte[] serialNumber, DateTimeOffset genTime, Accuracy accuracy, bool ordering, Byte[] nonce, Byte[] tsa, X509ExtensionCollection extensions);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public Oid get_Policy();
    [CompilerGeneratedAttribute]
public MessageImprint get_MessageImprint();
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_GenTime();
    [CompilerGeneratedAttribute]
public Accuracy get_Accuracy();
    [CompilerGeneratedAttribute]
public bool get_Ordering();
    [CompilerGeneratedAttribute]
public Byte[] get_Nonce();
    [CompilerGeneratedAttribute]
public Byte[] get_Tsa();
    [CompilerGeneratedAttribute]
public X509ExtensionCollection get_Extensions();
    public static TstInfo Read(Byte[] bytes);
    internal static TstInfo Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.UnknownPrimarySignature : PrimarySignature {
    public UnknownPrimarySignature(SignedCms signedCms);
}
internal class NuGet.Packaging.Signing.UnsignedPackageArchiveMetadata : object {
    [CompilerGeneratedAttribute]
private long <EndOfLocalFileHeadersPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOfCentralDirectoryHeadersPosition>k__BackingField;
    internal long EndOfLocalFileHeadersPosition { get; }
    internal long EndOfCentralDirectoryHeadersPosition { get; }
    internal UnsignedPackageArchiveMetadata(long endOfLocalFileHeadersPosition, long endOfCentralDirectoryHeadersPosition);
    [CompilerGeneratedAttribute]
internal long get_EndOfLocalFileHeadersPosition();
    [CompilerGeneratedAttribute]
internal long get_EndOfCentralDirectoryHeadersPosition();
}
internal class NuGet.Packaging.Signing.UnsignedPackageVerificationResult : PackageVerificationResult {
    public UnsignedPackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
}
internal static class NuGet.Packaging.Signing.Utility.MarshalUtility : object {
    internal static T PtrToStructure(IntPtr pointer);
    internal static int SizeOf();
}
internal abstract class NuGet.Packaging.Signing.VerificationAllowListEntry : object {
    [CompilerGeneratedAttribute]
private VerificationTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <Placement>k__BackingField;
    public VerificationTarget Target { get; }
    public SignaturePlacement Placement { get; }
    public VerificationAllowListEntry(VerificationTarget target, SignaturePlacement placement);
    [CompilerGeneratedAttribute]
public VerificationTarget get_Target();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_Placement();
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.VerificationTarget : Enum {
    public int value__;
    public static VerificationTarget None;
    public static VerificationTarget Unknown;
    public static VerificationTarget Author;
    public static VerificationTarget Repository;
    public static VerificationTarget All;
}
internal static class NuGet.Packaging.Signing.VerificationUtility : object {
    public static SignatureVerificationStatus GetSignatureVerificationStatus(SignatureVerificationStatusFlags flags);
    public static bool IsVerificationTarget(SignatureType signatureType, VerificationTarget target);
    internal static SignatureVerificationStatusFlags ValidateSigningCertificate(X509Certificate2 certificate, bool treatIssuesAsErrors, string signatureFriendlyName, List`1<SignatureLog> issues);
    internal static SignatureVerificationStatusFlags ValidateTimestamp(Timestamp timestamp, Signature signature, bool treatIssuesAsErrors, List`1<SignatureLog> issues, SigningSpecifications spec);
}
internal class NuGet.Packaging.Signing.VerifySignaturesResult : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageVerificationResult> <Results>k__BackingField;
    public bool IsValid { get; }
    public bool IsSigned { get; }
    public IReadOnlyList`1<PackageVerificationResult> Results { get; }
    public VerifySignaturesResult(bool isValid, bool isSigned);
    public VerifySignaturesResult(bool isValid, bool isSigned, IEnumerable`1<PackageVerificationResult> results);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public bool get_IsSigned();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageVerificationResult> get_Results();
}
internal class NuGet.Packaging.Signing.X509CertificateChain : List`1<X509Certificate2> {
    private bool _isDisposed;
    public sealed virtual void Dispose();
}
internal static class NuGet.Packaging.Signing.X509ChainBuildPolicyFactory : object {
    private static string DefaultValue;
    internal static string DisabledValue;
    internal static string EnvironmentVariableName;
    internal static char ValueDelimiter;
    private static object LockObject;
    private static IX509ChainBuildPolicy Policy;
    private static X509ChainBuildPolicyFactory();
    internal static IX509ChainBuildPolicy Create(IEnvironmentVariableReader reader);
    internal static IX509ChainBuildPolicy CreateWithoutCaching(IEnvironmentVariableReader reader);
}
internal class NuGet.Packaging.Signing.X509ChainHolder : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private X509Chain <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private IX509Chain <Chain2>k__BackingField;
    public X509Chain Chain { get; }
    internal IX509Chain Chain2 { get; }
    private X509ChainHolder(X509StorePurpose storePurpose);
    [CompilerGeneratedAttribute]
public X509Chain get_Chain();
    [CompilerGeneratedAttribute]
internal IX509Chain get_Chain2();
    internal static X509ChainHolder CreateForCodeSigning();
    internal static X509ChainHolder CreateForTimestamping();
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.X509ChainWrapper : object {
    private X509Chain _chain;
    private Func`2<X509Chain, ILogMessage> _getAdditionalContext;
    [CompilerGeneratedAttribute]
private ILogMessage <AdditionalContext>k__BackingField;
    public ILogMessage AdditionalContext { get; private set; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public X509Chain PrivateReference { get; }
    internal X509ChainWrapper(X509Chain chain);
    internal X509ChainWrapper(X509Chain chain, Func`2<X509Chain, ILogMessage> getAdditionalContext);
    [CompilerGeneratedAttribute]
public sealed virtual ILogMessage get_AdditionalContext();
    [CompilerGeneratedAttribute]
private void set_AdditionalContext(ILogMessage value);
    public sealed virtual X509ChainElementCollection get_ChainElements();
    public sealed virtual X509ChainPolicy get_ChainPolicy();
    public sealed virtual X509ChainStatus[] get_ChainStatus();
    public sealed virtual X509Chain get_PrivateReference();
    public sealed virtual bool Build(X509Certificate2 certificate);
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.X509SignatureProvider : object {
    private static int INVALID_PROVIDER_TYPE_HRESULT;
    private ITimestampProvider _timestampProvider;
    public X509SignatureProvider(ITimestampProvider timestampProvider);
    public sealed virtual Task`1<PrimarySignature> CreatePrimarySignatureAsync(SignPackageRequest request, SignatureContent signatureContent, ILogger logger, CancellationToken token);
    public sealed virtual Task`1<PrimarySignature> CreateRepositoryCountersignatureAsync(RepositorySignPackageRequest request, PrimarySignature primarySignature, ILogger logger, CancellationToken token);
    private static PrimarySignature CreatePrimarySignature(SignPackageRequest request, SignatureContent signatureContent, ILogger logger);
    private static PrimarySignature CreateRepositoryCountersignature(SignPackageRequest request, PrimarySignature primarySignature, ILogger logger);
    private static PrimarySignature CreatePrimarySignature(CmsSigner cmsSigner, Byte[] signingData, CngKey privateKey);
    private static PrimarySignature CreatePrimarySignature(CmsSigner cmsSigner, SignPackageRequest request, Byte[] signingData);
    private static PrimarySignature CreateRepositoryCountersignature(CmsSigner cmsSigner, PrimarySignature primarySignature, CngKey privateKey);
    private static PrimarySignature CreateRepositoryCountersignature(CmsSigner cmsSigner, SignPackageRequest request, PrimarySignature primarySignature);
    private Task`1<PrimarySignature> TimestampPrimarySignatureAsync(SignPackageRequest request, ILogger logger, PrimarySignature signature, CancellationToken token);
    private Task`1<PrimarySignature> TimestampRepositoryCountersignatureAsync(SignPackageRequest request, ILogger logger, PrimarySignature primarySignature, CancellationToken token);
}
internal enum NuGet.Packaging.Signing.X509StorePurpose : Enum {
    public int value__;
    public static X509StorePurpose CodeSigning;
    public static X509StorePurpose Timestamping;
}
internal static class NuGet.Packaging.Signing.X509TrustStore : object {
    private static IX509ChainFactory CodeSigningX509ChainFactory;
    private static IX509ChainFactory TimestampingX509ChainFactory;
    private static object LockObject;
    private static X509TrustStore();
    public static void InitializeForDotNetSdk(ILogger logger);
    internal static IX509ChainFactory GetX509ChainFactory(X509StorePurpose storePurpose, ILogger logger);
    private static IX509ChainFactory GetX509ChainFactory(X509StorePurpose storePurpose, ILogger logger, Func`3<X509StorePurpose, ILogger, IX509ChainFactory> creator);
    private static IX509ChainFactory CreateX509ChainFactoryForDotNetSdk(X509StorePurpose storePurpose, ILogger logger);
    internal static IX509ChainFactory CreateX509ChainFactoryForDotNetSdk(X509StorePurpose storePurpose, ILogger logger, FileInfo fallbackCertificateBundleFile);
    internal static IX509ChainFactory CreateX509ChainFactory(X509StorePurpose storePurpose, ILogger logger);
    internal static void SetCodeSigningX509ChainFactory(IX509ChainFactory chainFactory);
    internal static void SetTimestampingX509ChainFactory(IX509ChainFactory chainFactory);
}
internal class NuGet.Packaging.Signing.Zip64EndOfCentralDirectoryLocator : object {
    internal static UInt32 Signature;
    internal static UInt32 SizeInBytes;
    internal static bool Exists(BinaryReader reader);
}
internal class NuGet.Packaging.Signing.Zip64ExtendedInformationExtraField : ExtraField {
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <OriginalUncompressedFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <SizeOfCompressedData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <OffsetOfLocalHeaderRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <NumberOfDiskOnWhichThisFileStarts>k__BackingField;
    internal Nullable`1<ulong> OriginalUncompressedFileSize { get; private set; }
    internal Nullable`1<ulong> SizeOfCompressedData { get; private set; }
    internal Nullable`1<ulong> OffsetOfLocalHeaderRecord { get; private set; }
    internal Nullable`1<UInt32> NumberOfDiskOnWhichThisFileStarts { get; private set; }
    private Zip64ExtendedInformationExtraField(ushort headerId, ushort dataSize, Byte[] data, Nullable`1<ulong> originalUncompressedFileSize, Nullable`1<ulong> sizeOfCompressedData, Nullable`1<ulong> offsetOfLocalHeaderRecord, Nullable`1<UInt32> numberOfDiskOnWhichThisFileStarts);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_OriginalUncompressedFileSize();
    [CompilerGeneratedAttribute]
private void set_OriginalUncompressedFileSize(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_SizeOfCompressedData();
    [CompilerGeneratedAttribute]
private void set_SizeOfCompressedData(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_OffsetOfLocalHeaderRecord();
    [CompilerGeneratedAttribute]
private void set_OffsetOfLocalHeaderRecord(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<UInt32> get_NumberOfDiskOnWhichThisFileStarts();
    [CompilerGeneratedAttribute]
private void set_NumberOfDiskOnWhichThisFileStarts(Nullable`1<UInt32> value);
    internal static Zip64ExtendedInformationExtraField Read(ushort headerId, ushort dataSize, Byte[] data, bool readUncompressedFileSize, bool readCompressedFileSize, bool readRelativeOffsetOfLocalHeader, bool readDiskNumberStart);
}
internal static class NuGet.Packaging.Signing.ZipConstants : object {
    internal static ushort Mask16Bit;
    internal static UInt32 Mask32Bit;
    private static ZipConstants();
}
[ExtensionAttribute]
internal static class NuGet.Packaging.StreamExtensions : object {
    [ExtensionAttribute]
public static string CopyToFile(Stream inputStream, string fileFullPath);
    private static void CopyTo(Stream inputStream, Stream outputStream);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.StringExtensions : object {
    [ExtensionAttribute]
public static string SafeTrim(string value);
}
internal static class NuGet.Packaging.StringFormatter : object {
    internal static string Log_InstalledPackage(string packageId, string packageVersion, string source, string contentHash, string filePath);
    internal static string ZipFileTimeStampModifiedMessage(string filePath, string originalLastWriteTimeStamp, string updatedLastWriteTimeStamp);
    internal static string ZipFileTimeStampModifiedWarning(string listOfFileTimeStampModifiedMessages);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AnAbsoluteUriIsRequired { get; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string AuthorPrimarySignatureFriendlyName { get; }
    internal static string CertificateChainBuildFailed { get; }
    internal static string CertificateChainValidationFailed { get; }
    internal static string CertUtilityCertificateHash { get; }
    internal static string CertUtilityCertificateHashSha1 { get; }
    internal static string CertUtilityCertificateIssuer { get; }
    internal static string CertUtilityCertificateSubjectName { get; }
    internal static string CertUtilityCertificateValidity { get; }
    internal static string CertUtilityMultipleCertificatesFooter { get; }
    internal static string CertUtilityMultipleCertificatesHeader { get; }
    internal static string ChainBuilding_UsingDefaultTrustStoreForCodeSigning { get; }
    internal static string ChainBuilding_UsingDefaultTrustStoreForTimestamping { get; }
    internal static string ChainBuilding_UsingFallbackCertificateBundle { get; }
    internal static string ChainBuilding_UsingNoCertificateBundle { get; }
    internal static string ChainBuilding_UsingSystemCertificateBundle { get; }
    internal static string CommitmentTypeIndicationAttributeInvalid { get; }
    internal static string CommitmentTypeIndicationAttributeInvalidCombination { get; }
    internal static string ConflictingAllowUntrustedRoot { get; }
    internal static string DefaultError_EmptyAllowList { get; }
    internal static string DefaultError_NoMatchInAllowList { get; }
    internal static string Error_InvalidTargetFramework { get; }
    internal static string Error_LoadingHashFile { get; }
    internal static string Error_MissingNuspecFile { get; }
    internal static string Error_NoClientAllowList { get; }
    internal static string Error_NoMatchingClientCertificate { get; }
    internal static string Error_NoMatchingRepositoryCertificate { get; }
    internal static string Error_NoRepoAllowList { get; }
    internal static string Error_NotOnePrimarySignature { get; }
    internal static string Error_NotOneRepositoryCounterSignature { get; }
    internal static string Error_RepositorySettings_UnsignedPackage { get; }
    internal static string Error_RepositorySignatureMustNotHaveARepositoryCountersignature { get; }
    internal static string Error_RequireMode_UnsignedPackage { get; }
    internal static string ErrorAuthorTargetCannotBeACountersignature { get; }
    internal static string ErrorByteSignatureNotFound { get; }
    internal static string ErrorDuplicatePackages { get; }
    internal static string ErrorInvalidAllowedVersions { get; }
    internal static string ErrorInvalidCertificateChainUnspecifiedReason { get; }
    internal static string ErrorInvalidMinClientVersion { get; }
    internal static string ErrorInvalidPackageArchive { get; }
    internal static string ErrorInvalidPackageVersion { get; }
    internal static string ErrorInvalidPackageVersionForDependency { get; }
    internal static string ErrorManifestFileNotFound { get; }
    internal static string ErrorMultipleTimestamps { get; }
    internal static string ErrorNoTimestamp { get; }
    internal static string ErrorNullOrEmptyPackageId { get; }
    internal static string ErrorPackageNotSigned { get; }
    internal static string ErrorPackageSignatureInvalid { get; }
    internal static string ErrorUnableCheckPackageEntries { get; }
    internal static string ErrorUnableToDeleteFile { get; }
    internal static string ErrorUnsafePackageEntry { get; }
    internal static string ErrorZip64NotSupported { get; }
    internal static string ExactlyOneAttributeRequired { get; }
    internal static string ExactlyOneAttributeValueRequired { get; }
    internal static string ExtractionLog_InformationPrefix { get; }
    internal static string FailedFileTime { get; }
    internal static string FailToLoadPackagesConfig { get; }
    internal static string FailToWritePackagesConfig { get; }
    internal static string FallbackFolderNotFound { get; }
    internal static string HttpOrHttpsIsRequired { get; }
    internal static string InvalidArgument { get; }
    internal static string InvalidArgumentCombination { get; }
    internal static string InvalidAsn1 { get; }
    internal static string InvalidLicenseExppressionVersion_VersionTooHigh { get; }
    internal static string InvalidNuspecElement { get; }
    internal static string InvalidNuspecEntry { get; }
    internal static string InvalidPackageFrameworkFolderName { get; }
    internal static string InvalidPackageNupkg { get; }
    internal static string InvalidPackageSignatureFile { get; }
    internal static string InvalidPackageSignatureFileEntry { get; }
    internal static string InvalidPackageSignatureFileEntryCentralDirectoryHeader { get; }
    internal static string InvalidPackageSignatureFileEntryLocalFileHeader { get; }
    internal static string InvalidPackageTypeVersion { get; }
    internal static string InvalidPrimarySignature { get; }
    internal static string InvalidRepositoryCountersignature { get; }
    internal static string InvalidSignatureContent { get; }
    internal static string InvalidTimestampSignature { get; }
    internal static string InvalidUrl { get; }
    internal static string InvalidX509StorePurpose { get; }
    internal static string Log_InstalledPackage { get; }
    internal static string Message_Path { get; }
    internal static string MinClientVersionAlreadyExist { get; }
    internal static string MissingMetadataNode { get; }
    internal static string MissingPackageTypeName { get; }
    internal static string MissingTargetPlatformVersionsFromDependencyGroups { get; }
    internal static string MissingTargetPlatformVersionsFromFrameworkAssemblyGroups { get; }
    internal static string MissingTargetPlatformVersionsFromFrameworkAssemblyReferences { get; }
    internal static string MissingTargetPlatformVersionsFromIncludedFiles { get; }
    internal static string MissingTargetPlatformVersionsFromReferenceGroups { get; }
    internal static string MultipleAttributesDisallowed { get; }
    internal static string MultipleNuspecFiles { get; }
    internal static string MultiplePackageSignatureFiles { get; }
    internal static string MustContainAbsolutePath { get; }
    internal static string NoPackageSignatureFile { get; }
    internal static string NoRepositoryCountersignature { get; }
    internal static string NuGetLicense_InvalidLicenseExpressionVersion { get; }
    internal static string NuGetLicense_InvalidLicenseType { get; }
    internal static string NuGetLicense_LicenseElementMissingValue { get; }
    internal static string NuGetLicense_LicenseExpressionVersionTooHigh { get; }
    internal static string NuGetLicense_MissingRequiredValue { get; }
    internal static string NuGetLicenseExpression_DeprecatedIdentifier { get; }
    internal static string NuGetLicenseExpression_ExceptionIdentifierIsLicense { get; }
    internal static string NuGetLicenseExpression_IllegalUnlicensedOperator { get; }
    internal static string NuGetLicenseExpression_InvalidCharacters { get; }
    internal static string NuGetLicenseExpression_InvalidExceptionIdentifier { get; }
    internal static string NuGetLicenseExpression_InvalidExpression { get; }
    internal static string NuGetLicenseExpression_InvalidToken { get; }
    internal static string NuGetLicenseExpression_LicenseIdentifierIsException { get; }
    internal static string NuGetLicenseExpression_LicenseInvalidCharacters { get; }
    internal static string NuGetLicenseExpression_MismatchedParentheses { get; }
    internal static string NuGetLicenseExpression_NonStandardIdentifier { get; }
    internal static string NuGetLicenseExpression_UnexpectedIdentifier { get; }
    internal static string NuGetLicenseExpression_UnlicensedPackageWarning { get; }
    internal static string NuGetPackageOwners { get; }
    internal static string NuGetPackageOwnersInvalid { get; }
    internal static string NuGetPackageOwnersInvalidValue { get; }
    internal static string NuGetV3ServiceIndexUrl { get; }
    internal static string NuGetV3ServiceIndexUrlInvalid { get; }
    internal static string NuGetV3ServiceIndexUrlInvalidValue { get; }
    internal static string PackageEntryAlreadyExist { get; }
    internal static string PackageEntryNotExist { get; }
    internal static string PackageMinVersionNotSatisfied { get; }
    internal static string PackageSignatureVerificationLog { get; }
    internal static string PackagesNodeNotExist { get; }
    internal static string PackageStreamShouldBeSeekable { get; }
    internal static string PrimarySignatureFriendlyName { get; }
    internal static string PrimarySignatureHasNoTimestamp { get; }
    internal static string PropertyCannotBeNull { get; }
    internal static string RangeOutOfBoundsForArray { get; }
    internal static string RepositoryCountersignatureFriendlyName { get; }
    internal static string RepositoryCountersignatureHasNoCertificate { get; }
    internal static string RepositoryCountersignatureHasNoTimestamp { get; }
    internal static string RepositoryPrimarySignatureFriendlyName { get; }
    internal static string SignatureContainsInvalidAttribute { get; }
    internal static string SignatureDebug_HashOidFound { get; }
    internal static string SignatureFailureInvalidHashAlgorithmOid { get; }
    internal static string SignatureFriendlyName { get; }
    internal static string SignatureHashAlgorithm { get; }
    internal static string SignaturePackageIntegrityFailure { get; }
    internal static string SignatureType { get; }
    internal static string SignedPackageAlreadySigned { get; }
    internal static string SignedPackageArchiveIOExtraRead { get; }
    internal static string SignedPackageArchiveIOInvalidRead { get; }
    internal static string SignedPackageNotSignedOnRemove { get; }
    internal static string SignedPackageNotSignedOnVerify { get; }
    internal static string SignedPackagePackageAlreadyCountersigned { get; }
    internal static string SignedPackageUnableToAccessSignature { get; }
    internal static string SignError_TimestampCertificateFailsPublicKeyLengthRequirement { get; }
    internal static string SignError_TimestampGeneralizedTimeInvalid { get; }
    internal static string SignError_TimestampIntegrityCheckFailed { get; }
    internal static string SignError_TimestampNoCertificate { get; }
    internal static string SignError_TimestampNotYetValid { get; }
    internal static string SignError_TimestampSignatureValidationFailed { get; }
    internal static string SignFailureCertificateInvalidProviderType { get; }
    internal static string SigningCannotBeDoneInPlace { get; }
    internal static string SigningCertificateAttributeMustNotBePresent { get; }
    internal static string SigningCertificateCertificateNotFound { get; }
    internal static string SigningCertificateInvalid { get; }
    internal static string SigningCertificateV1OrV2AttributeMustBePresent { get; }
    internal static string SigningCertificateV2CertificateNotFound { get; }
    internal static string SigningCertificateV2Invalid { get; }
    internal static string SigningCertificateV2UnsupportedHashAlgorithm { get; }
    internal static string SigningError_CertificateFailsPublicKeyLengthRequirement { get; }
    internal static string SigningError_CertificateHasLifetimeSigningEKU { get; }
    internal static string SigningError_CertificateHasUnsupportedSignatureAlgorithm { get; }
    internal static string SigningError_NotYetValid { get; }
    internal static string SigningWouldRequireZip64 { get; }
    internal static string StreamMustBeReadable { get; }
    internal static string StreamMustBeSeekable { get; }
    internal static string StringCannotBeNullOrEmpty { get; }
    internal static string TimestampCertificateUnsupportedSignatureAlgorithm { get; }
    internal static string TimestampFailureInvalidHttpScheme { get; }
    internal static string TimestampFailureNonceMismatch { get; }
    internal static string TimestampServiceRespondedError { get; }
    internal static string TimestampSignatureUnsupportedDigestAlgorithm { get; }
    internal static string TimestampValue { get; }
    internal static string UnableToAddEntry { get; }
    internal static string UnableToParseClientVersion { get; }
    internal static string UnableToReadPackageHashInformation { get; }
    internal static string UnexpectedPackageSignatureVerificationError { get; }
    internal static string UnrecognizedEnumValue { get; }
    internal static string UnrelatedSignatures { get; }
    internal static string UnsupportedAsn1 { get; }
    internal static string UnsupportedSignatureFormatVersion { get; }
    internal static string UntrustedRoot_WithCertificateBundle { get; }
    internal static string UntrustedRoot_WithoutCertificateBundle { get; }
    internal static string VerificationCertDisplay { get; }
    internal static string VerificationTimestamperCertDisplay { get; }
    internal static string Verify_ErrorNoCertificate { get; }
    internal static string VerifyCertTrustOfflineWhileRevocationModeOffline { get; }
    internal static string VerifyCertTrustOfflineWhileRevocationModeOnline { get; }
    internal static string VerifyChainBuildingIssue { get; }
    internal static string VerifyChainBuildingIssue_UntrustedRoot { get; }
    internal static string VerifyError_CertificateFailsPublicKeyLengthRequirement { get; }
    internal static string VerifyError_CertificateHasLifetimeSigningEKU { get; }
    internal static string VerifyError_CertificateHasUnsupportedSignatureAlgorithm { get; }
    internal static string VerifyError_CertificateNotYetValid { get; }
    internal static string VerifyError_InvalidCertificateChain { get; }
    internal static string VerifyError_SignatureNotTimeValid { get; }
    internal static string VerifyError_SignatureVerificationFailed { get; }
    internal static string VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement { get; }
    internal static string VerifyError_TimestampGeneralizedTimeInvalid { get; }
    internal static string VerifyError_TimestampIntegrityCheckFailed { get; }
    internal static string VerifyError_TimestampInvalid { get; }
    internal static string VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm { get; }
    internal static string VerifyError_TimestampNoCertificate { get; }
    internal static string VerifyError_TimestampNotYetValid { get; }
    internal static string VerifyError_TimestampSignatureUnsupportedDigestAlgorithm { get; }
    internal static string VerifyError_TimestampSignatureValidationFailed { get; }
    internal static string VerifyError_TimestampUnsupportedSignatureAlgorithm { get; }
    internal static string VerifyError_TimestampVerifyChainBuildingIssue { get; }
    internal static string VerifyTimestampChainBuildingIssue_UntrustedRoot { get; }
    internal static string ZipFileLastWriteTimeStampModifiedMessage { get; }
    internal static string ZipFileTimeStampModifiedWarning { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AnAbsoluteUriIsRequired();
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_AuthorPrimarySignatureFriendlyName();
    internal static string get_CertificateChainBuildFailed();
    internal static string get_CertificateChainValidationFailed();
    internal static string get_CertUtilityCertificateHash();
    internal static string get_CertUtilityCertificateHashSha1();
    internal static string get_CertUtilityCertificateIssuer();
    internal static string get_CertUtilityCertificateSubjectName();
    internal static string get_CertUtilityCertificateValidity();
    internal static string get_CertUtilityMultipleCertificatesFooter();
    internal static string get_CertUtilityMultipleCertificatesHeader();
    internal static string get_ChainBuilding_UsingDefaultTrustStoreForCodeSigning();
    internal static string get_ChainBuilding_UsingDefaultTrustStoreForTimestamping();
    internal static string get_ChainBuilding_UsingFallbackCertificateBundle();
    internal static string get_ChainBuilding_UsingNoCertificateBundle();
    internal static string get_ChainBuilding_UsingSystemCertificateBundle();
    internal static string get_CommitmentTypeIndicationAttributeInvalid();
    internal static string get_CommitmentTypeIndicationAttributeInvalidCombination();
    internal static string get_ConflictingAllowUntrustedRoot();
    internal static string get_DefaultError_EmptyAllowList();
    internal static string get_DefaultError_NoMatchInAllowList();
    internal static string get_Error_InvalidTargetFramework();
    internal static string get_Error_LoadingHashFile();
    internal static string get_Error_MissingNuspecFile();
    internal static string get_Error_NoClientAllowList();
    internal static string get_Error_NoMatchingClientCertificate();
    internal static string get_Error_NoMatchingRepositoryCertificate();
    internal static string get_Error_NoRepoAllowList();
    internal static string get_Error_NotOnePrimarySignature();
    internal static string get_Error_NotOneRepositoryCounterSignature();
    internal static string get_Error_RepositorySettings_UnsignedPackage();
    internal static string get_Error_RepositorySignatureMustNotHaveARepositoryCountersignature();
    internal static string get_Error_RequireMode_UnsignedPackage();
    internal static string get_ErrorAuthorTargetCannotBeACountersignature();
    internal static string get_ErrorByteSignatureNotFound();
    internal static string get_ErrorDuplicatePackages();
    internal static string get_ErrorInvalidAllowedVersions();
    internal static string get_ErrorInvalidCertificateChainUnspecifiedReason();
    internal static string get_ErrorInvalidMinClientVersion();
    internal static string get_ErrorInvalidPackageArchive();
    internal static string get_ErrorInvalidPackageVersion();
    internal static string get_ErrorInvalidPackageVersionForDependency();
    internal static string get_ErrorManifestFileNotFound();
    internal static string get_ErrorMultipleTimestamps();
    internal static string get_ErrorNoTimestamp();
    internal static string get_ErrorNullOrEmptyPackageId();
    internal static string get_ErrorPackageNotSigned();
    internal static string get_ErrorPackageSignatureInvalid();
    internal static string get_ErrorUnableCheckPackageEntries();
    internal static string get_ErrorUnableToDeleteFile();
    internal static string get_ErrorUnsafePackageEntry();
    internal static string get_ErrorZip64NotSupported();
    internal static string get_ExactlyOneAttributeRequired();
    internal static string get_ExactlyOneAttributeValueRequired();
    internal static string get_ExtractionLog_InformationPrefix();
    internal static string get_FailedFileTime();
    internal static string get_FailToLoadPackagesConfig();
    internal static string get_FailToWritePackagesConfig();
    internal static string get_FallbackFolderNotFound();
    internal static string get_HttpOrHttpsIsRequired();
    internal static string get_InvalidArgument();
    internal static string get_InvalidArgumentCombination();
    internal static string get_InvalidAsn1();
    internal static string get_InvalidLicenseExppressionVersion_VersionTooHigh();
    internal static string get_InvalidNuspecElement();
    internal static string get_InvalidNuspecEntry();
    internal static string get_InvalidPackageFrameworkFolderName();
    internal static string get_InvalidPackageNupkg();
    internal static string get_InvalidPackageSignatureFile();
    internal static string get_InvalidPackageSignatureFileEntry();
    internal static string get_InvalidPackageSignatureFileEntryCentralDirectoryHeader();
    internal static string get_InvalidPackageSignatureFileEntryLocalFileHeader();
    internal static string get_InvalidPackageTypeVersion();
    internal static string get_InvalidPrimarySignature();
    internal static string get_InvalidRepositoryCountersignature();
    internal static string get_InvalidSignatureContent();
    internal static string get_InvalidTimestampSignature();
    internal static string get_InvalidUrl();
    internal static string get_InvalidX509StorePurpose();
    internal static string get_Log_InstalledPackage();
    internal static string get_Message_Path();
    internal static string get_MinClientVersionAlreadyExist();
    internal static string get_MissingMetadataNode();
    internal static string get_MissingPackageTypeName();
    internal static string get_MissingTargetPlatformVersionsFromDependencyGroups();
    internal static string get_MissingTargetPlatformVersionsFromFrameworkAssemblyGroups();
    internal static string get_MissingTargetPlatformVersionsFromFrameworkAssemblyReferences();
    internal static string get_MissingTargetPlatformVersionsFromIncludedFiles();
    internal static string get_MissingTargetPlatformVersionsFromReferenceGroups();
    internal static string get_MultipleAttributesDisallowed();
    internal static string get_MultipleNuspecFiles();
    internal static string get_MultiplePackageSignatureFiles();
    internal static string get_MustContainAbsolutePath();
    internal static string get_NoPackageSignatureFile();
    internal static string get_NoRepositoryCountersignature();
    internal static string get_NuGetLicense_InvalidLicenseExpressionVersion();
    internal static string get_NuGetLicense_InvalidLicenseType();
    internal static string get_NuGetLicense_LicenseElementMissingValue();
    internal static string get_NuGetLicense_LicenseExpressionVersionTooHigh();
    internal static string get_NuGetLicense_MissingRequiredValue();
    internal static string get_NuGetLicenseExpression_DeprecatedIdentifier();
    internal static string get_NuGetLicenseExpression_ExceptionIdentifierIsLicense();
    internal static string get_NuGetLicenseExpression_IllegalUnlicensedOperator();
    internal static string get_NuGetLicenseExpression_InvalidCharacters();
    internal static string get_NuGetLicenseExpression_InvalidExceptionIdentifier();
    internal static string get_NuGetLicenseExpression_InvalidExpression();
    internal static string get_NuGetLicenseExpression_InvalidToken();
    internal static string get_NuGetLicenseExpression_LicenseIdentifierIsException();
    internal static string get_NuGetLicenseExpression_LicenseInvalidCharacters();
    internal static string get_NuGetLicenseExpression_MismatchedParentheses();
    internal static string get_NuGetLicenseExpression_NonStandardIdentifier();
    internal static string get_NuGetLicenseExpression_UnexpectedIdentifier();
    internal static string get_NuGetLicenseExpression_UnlicensedPackageWarning();
    internal static string get_NuGetPackageOwners();
    internal static string get_NuGetPackageOwnersInvalid();
    internal static string get_NuGetPackageOwnersInvalidValue();
    internal static string get_NuGetV3ServiceIndexUrl();
    internal static string get_NuGetV3ServiceIndexUrlInvalid();
    internal static string get_NuGetV3ServiceIndexUrlInvalidValue();
    internal static string get_PackageEntryAlreadyExist();
    internal static string get_PackageEntryNotExist();
    internal static string get_PackageMinVersionNotSatisfied();
    internal static string get_PackageSignatureVerificationLog();
    internal static string get_PackagesNodeNotExist();
    internal static string get_PackageStreamShouldBeSeekable();
    internal static string get_PrimarySignatureFriendlyName();
    internal static string get_PrimarySignatureHasNoTimestamp();
    internal static string get_PropertyCannotBeNull();
    internal static string get_RangeOutOfBoundsForArray();
    internal static string get_RepositoryCountersignatureFriendlyName();
    internal static string get_RepositoryCountersignatureHasNoCertificate();
    internal static string get_RepositoryCountersignatureHasNoTimestamp();
    internal static string get_RepositoryPrimarySignatureFriendlyName();
    internal static string get_SignatureContainsInvalidAttribute();
    internal static string get_SignatureDebug_HashOidFound();
    internal static string get_SignatureFailureInvalidHashAlgorithmOid();
    internal static string get_SignatureFriendlyName();
    internal static string get_SignatureHashAlgorithm();
    internal static string get_SignaturePackageIntegrityFailure();
    internal static string get_SignatureType();
    internal static string get_SignedPackageAlreadySigned();
    internal static string get_SignedPackageArchiveIOExtraRead();
    internal static string get_SignedPackageArchiveIOInvalidRead();
    internal static string get_SignedPackageNotSignedOnRemove();
    internal static string get_SignedPackageNotSignedOnVerify();
    internal static string get_SignedPackagePackageAlreadyCountersigned();
    internal static string get_SignedPackageUnableToAccessSignature();
    internal static string get_SignError_TimestampCertificateFailsPublicKeyLengthRequirement();
    internal static string get_SignError_TimestampGeneralizedTimeInvalid();
    internal static string get_SignError_TimestampIntegrityCheckFailed();
    internal static string get_SignError_TimestampNoCertificate();
    internal static string get_SignError_TimestampNotYetValid();
    internal static string get_SignError_TimestampSignatureValidationFailed();
    internal static string get_SignFailureCertificateInvalidProviderType();
    internal static string get_SigningCannotBeDoneInPlace();
    internal static string get_SigningCertificateAttributeMustNotBePresent();
    internal static string get_SigningCertificateCertificateNotFound();
    internal static string get_SigningCertificateInvalid();
    internal static string get_SigningCertificateV1OrV2AttributeMustBePresent();
    internal static string get_SigningCertificateV2CertificateNotFound();
    internal static string get_SigningCertificateV2Invalid();
    internal static string get_SigningCertificateV2UnsupportedHashAlgorithm();
    internal static string get_SigningError_CertificateFailsPublicKeyLengthRequirement();
    internal static string get_SigningError_CertificateHasLifetimeSigningEKU();
    internal static string get_SigningError_CertificateHasUnsupportedSignatureAlgorithm();
    internal static string get_SigningError_NotYetValid();
    internal static string get_SigningWouldRequireZip64();
    internal static string get_StreamMustBeReadable();
    internal static string get_StreamMustBeSeekable();
    internal static string get_StringCannotBeNullOrEmpty();
    internal static string get_TimestampCertificateUnsupportedSignatureAlgorithm();
    internal static string get_TimestampFailureInvalidHttpScheme();
    internal static string get_TimestampFailureNonceMismatch();
    internal static string get_TimestampServiceRespondedError();
    internal static string get_TimestampSignatureUnsupportedDigestAlgorithm();
    internal static string get_TimestampValue();
    internal static string get_UnableToAddEntry();
    internal static string get_UnableToParseClientVersion();
    internal static string get_UnableToReadPackageHashInformation();
    internal static string get_UnexpectedPackageSignatureVerificationError();
    internal static string get_UnrecognizedEnumValue();
    internal static string get_UnrelatedSignatures();
    internal static string get_UnsupportedAsn1();
    internal static string get_UnsupportedSignatureFormatVersion();
    internal static string get_UntrustedRoot_WithCertificateBundle();
    internal static string get_UntrustedRoot_WithoutCertificateBundle();
    internal static string get_VerificationCertDisplay();
    internal static string get_VerificationTimestamperCertDisplay();
    internal static string get_Verify_ErrorNoCertificate();
    internal static string get_VerifyCertTrustOfflineWhileRevocationModeOffline();
    internal static string get_VerifyCertTrustOfflineWhileRevocationModeOnline();
    internal static string get_VerifyChainBuildingIssue();
    internal static string get_VerifyChainBuildingIssue_UntrustedRoot();
    internal static string get_VerifyError_CertificateFailsPublicKeyLengthRequirement();
    internal static string get_VerifyError_CertificateHasLifetimeSigningEKU();
    internal static string get_VerifyError_CertificateHasUnsupportedSignatureAlgorithm();
    internal static string get_VerifyError_CertificateNotYetValid();
    internal static string get_VerifyError_InvalidCertificateChain();
    internal static string get_VerifyError_SignatureNotTimeValid();
    internal static string get_VerifyError_SignatureVerificationFailed();
    internal static string get_VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement();
    internal static string get_VerifyError_TimestampGeneralizedTimeInvalid();
    internal static string get_VerifyError_TimestampIntegrityCheckFailed();
    internal static string get_VerifyError_TimestampInvalid();
    internal static string get_VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm();
    internal static string get_VerifyError_TimestampNoCertificate();
    internal static string get_VerifyError_TimestampNotYetValid();
    internal static string get_VerifyError_TimestampSignatureUnsupportedDigestAlgorithm();
    internal static string get_VerifyError_TimestampSignatureValidationFailed();
    internal static string get_VerifyError_TimestampUnsupportedSignatureAlgorithm();
    internal static string get_VerifyError_TimestampVerifyChainBuildingIssue();
    internal static string get_VerifyTimestampChainBuildingIssue_UntrustedRoot();
    internal static string get_ZipFileLastWriteTimeStampModifiedMessage();
    internal static string get_ZipFileTimeStampModifiedWarning();
}
internal static class NuGet.Packaging.TopologicalSortUtility : object {
    public static IReadOnlyList`1<T> SortPackagesByDependencyOrder(IEnumerable`1<T> items, StringComparer comparer, Func`2<T, string> getId, Func`2<T, String[]> getDependencies);
    public static IReadOnlyList`1<PackageDependencyInfo> SortPackagesByDependencyOrder(IEnumerable`1<PackageDependencyInfo> packages);
    private static List`1<ItemDependencyInfo> SortPackagesByDependencyOrder(List`1<ItemDependencyInfo> items, StringComparer comparer);
    private static void UpdateChildCounts(ItemDependencyInfo package);
    private static void CalculateRelationships(ItemDependencyInfo[] packages, Dictionary`2<string, ItemDependencyInfo> lookup);
    private static string GetPackageDependencyInfoId(PackageDependencyInfo info);
    private static String[] GetPackageDependencyInfoDependencies(PackageDependencyInfo info);
}
internal class NuGet.Packaging.UnsafePackageEntryException : PackagingException {
    public UnsafePackageEntryException(string message);
    public virtual ILogMessage AsLogMessage();
}
internal class NuGet.Packaging.VersionFolderPathResolver : object {
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLowerCase>k__BackingField;
    public string RootPath { get; }
    public bool IsLowerCase { get; }
    public VersionFolderPathResolver(string rootPath);
    public VersionFolderPathResolver(string rootPath, bool isLowercase);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public bool get_IsLowerCase();
    public virtual string GetInstallPath(string packageId, NuGetVersion version);
    public string GetVersionListPath(string packageId);
    public string GetPackageFilePath(string packageId, NuGetVersion version);
    public string GetManifestFilePath(string packageId, NuGetVersion version);
    public string GetHashPath(string packageId, NuGetVersion version);
    public string GetHashFileName(string packageId, NuGetVersion version);
    public string GetNupkgMetadataPath(string packageId, NuGetVersion version);
    public virtual string GetVersionListDirectory(string packageId);
    public virtual string GetPackageDirectory(string packageId, NuGetVersion version);
    public virtual string GetPackageFileName(string packageId, NuGetVersion version);
    public string GetPackageDownloadMarkerFileName(string packageId);
    public virtual string GetManifestFileName(string packageId, NuGetVersion version);
    private string Normalize(NuGetVersion version);
    private string Normalize(string packageId);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.XElementExtensions : object {
    [ExtensionAttribute]
public static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(XContainer container, string localName);
    [ExtensionAttribute]
public static XElement Except(XElement source, XElement target);
    private static XElement FindElement(XElement source, XElement targetChild);
    private static int Compare(XElement target, XElement left, XElement right);
    private static int CountMatches(XElement left, XElement right, Func`3<XAttribute, XAttribute, bool> matcher);
    private static bool HasComment(XElement element, XComment comment);
    private static bool HasConflict(XElement source, XElement target);
    private static bool AttributeEquals(XAttribute source, XAttribute target);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Xml.PackageMetadataXmlExtensions : object {
    private static string References;
    private static string Reference;
    private static string Group;
    private static string File;
    private static string TargetFramework;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Dependencies;
    private static string Files;
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns);
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns, bool generateBackwardsCompatible);
    private static XElement GetXElementFromGroupableItemSets(XNamespace ns, IEnumerable`1<TSet> objectSets, Func`2<TSet, bool> isGroupable, Func`2<TSet, string> getGroupIdentifer, Func`2<TSet, IEnumerable`1<TItem>> getItems, Func`3<XNamespace, TItem, XElement> getXElementFromItem, string parentName, string identifierAttributeName);
    private static XElement GetXElementFromFrameworkReference(XNamespace ns, FrameworkReference frameworkReference);
    private static XElement GetXElementFromPackageReference(XNamespace ns, string reference);
    private static XElement GetXElementFromPackageDependency(XNamespace ns, PackageDependency dependency);
    private static XElement GetXElementFromFrameworkAssemblies(XNamespace ns, IEnumerable`1<FrameworkAssemblyReference> references);
    private static XElement GetXElementFromManifestContentFiles(XNamespace ns, IEnumerable`1<ManifestContentFiles> contentFiles);
    private static XElement GetXElementFromManifestContentFile(XNamespace ns, ManifestContentFiles file);
    private static XElement GetXElementFromLicenseMetadata(XNamespace ns, LicenseMetadata metadata);
    private static XElement GetXElementFromManifestRepository(XNamespace ns, RepositoryMetadata repository);
    private static XElement GetXElementFromManifestPackageTypes(XNamespace ns, IEnumerable`1<PackageType> packageTypes);
    private static XElement GetXElementFromManifestPackageType(XNamespace ns, PackageType packageType);
    private static XAttribute GetXAttributeFromNameAndValue(string name, object value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value, Func`2<T, object> process);
    private static void AddElementIfNotEmpty(XElement parent, XNamespace ns, string name, IEnumerable`1<T> value, Func`2<IEnumerable`1<T>, object> process);
}
internal enum NuGet.Packaging.XmlDocFileSaveMode : Enum {
    public int value__;
    public static XmlDocFileSaveMode None;
    public static XmlDocFileSaveMode Skip;
    public static XmlDocFileSaveMode Compress;
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release.")]
internal static class NuGet.Packaging.XmlUtility : object {
    public static XDocument LoadSafe(Stream input);
    public static XDocument LoadSafe(Stream input, bool ignoreWhiteSpace);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.ZipArchiveExtensions : object {
    [ExtensionAttribute]
public static ZipArchiveEntry LookupEntry(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetFiles(ZipArchive zipArchive);
    private static string UnescapePath(string path);
    [ExtensionAttribute]
public static Stream OpenFile(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static string SaveAsFile(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
    [ExtensionAttribute]
public static void UpdateFileTimeFromEntry(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
    internal static void UpdateFileTime(string fileFullPath, DateTime dateTime);
}
internal class NuGet.Packaging.ZipFilePair : object {
    private ZipArchiveEntry _packageEntry;
    private string _fileFullPath;
    public string FileFullPath { get; }
    public ZipArchiveEntry PackageEntry { get; }
    public ZipFilePair(string fileFullPath, ZipArchiveEntry entry);
    public string get_FileFullPath();
    public ZipArchiveEntry get_PackageEntry();
    public bool IsInstalled();
}
[CompilerGeneratedAttribute]
internal class NuGet.ProjectModel.<PrivateImplementationDetails> : object {
    internal static __StaticArrayInitTypeSize=3 F1945CD6C19E56B3C1C78943EF5EC18116907A4CA1EFC40A57D48AB1DB7ADFC5;
}
internal class NuGet.ProjectModel.AssetsLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <TargetGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    public LogLevel Level { get; }
    public NuGetLogCode Code { get; }
    public string Message { get; }
    public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string FilePath { get; public set; }
    public string LibraryId { get; public set; }
    public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public AssetsLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph);
    public AssetsLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_TargetGraphs();
    [CompilerGeneratedAttribute]
public void set_TargetGraphs(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public void set_EndColumnNumber(int value);
    public static IAssetsLogMessage Create(IRestoreLogMessage logMessage);
    public sealed virtual bool Equals(IAssetsLogMessage other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal class NuGet.ProjectModel.BuildAction : ValueType {
    private static ConcurrentDictionary`2<string, BuildAction> _knownBuildActions;
    public static BuildAction None;
    public static BuildAction Compile;
    public static BuildAction Content;
    public static BuildAction EmbeddedResource;
    public static BuildAction ApplicationDefinition;
    public static BuildAction Page;
    public static BuildAction Resource;
    public static BuildAction SplashScreen;
    public static BuildAction DesignData;
    public static BuildAction DesignDataWithDesignTimeCreatableTypes;
    public static BuildAction CodeAnalysisDictionary;
    public static BuildAction AndroidAsset;
    public static BuildAction AndroidResource;
    public static BuildAction BundleResource;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKnown>k__BackingField;
    public string Value { get; }
    public bool IsKnown { get; }
    private BuildAction(string value, bool isKnown);
    private static BuildAction();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsKnown();
    public static BuildAction Parse(string value);
    public virtual string ToString();
    public sealed virtual bool Equals(BuildAction other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BuildAction left, BuildAction right);
    public static bool op_Inequality(BuildAction left, BuildAction right);
    public virtual int GetHashCode();
    private static BuildAction Define(string name);
}
internal class NuGet.ProjectModel.BuildOptions : object {
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    public string OutputName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildOptions other);
    public BuildOptions Clone();
}
internal class NuGet.ProjectModel.CacheFile : object {
    internal static int CurrentVersion;
    [CompilerGeneratedAttribute]
private string <DgSpecHash>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ExpectedPackageFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    public string DgSpecHash { get; }
    public int Version { get; public set; }
    public bool Success { get; public set; }
    public IList`1<string> ExpectedPackageFilePaths { get; public set; }
    [ObsoleteAttribute("File existence checks are a function of time not the cache file content.")]
public bool HasAnyMissingPackageFiles { get; public set; }
    public string ProjectFilePath { get; public set; }
    public IList`1<IAssetsLogMessage> LogMessages { get; public set; }
    public bool IsValid { get; }
    public CacheFile(string dgSpecHash);
    [CompilerGeneratedAttribute]
public string get_DgSpecHash();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ExpectedPackageFilePaths();
    [CompilerGeneratedAttribute]
public void set_ExpectedPackageFilePaths(IList`1<string> value);
    public bool get_HasAnyMissingPackageFiles();
    public void set_HasAnyMissingPackageFiles(bool value);
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(IList`1<IAssetsLogMessage> value);
    public bool get_IsValid();
    public sealed virtual bool Equals(CacheFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class NuGet.ProjectModel.CacheFileFormat : object {
    private static string VersionProperty;
    private static string DGSpecHashProperty;
    private static string SuccessProperty;
    private static string ExpectedPackageFilesProperty;
    private static string ProjectFilePathProperty;
    public static CacheFile Read(Stream stream, ILogger log, string path);
    private static CacheFile Read(TextReader reader, ILogger log, string path);
    public static void Write(string filePath, CacheFile lockFile);
    public static void Write(Stream stream, CacheFile cacheFile);
    private static void Write(TextWriter textWriter, CacheFile cacheFile);
    private static CacheFile ReadCacheFile(JObject cursor);
    private static JObject GetCacheFile(CacheFile cacheFile);
    private static string ReadString(JToken json);
    private static JToken WriteString(string item);
    private static int ReadInt(JToken json);
    private static JToken WriteInt(int item);
    private static bool ReadBool(JToken json);
    private static JToken WriteBool(bool item);
}
internal class NuGet.ProjectModel.CentralTransitiveDependencyGroup : object {
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryDependency> <TransitiveDependencies>k__BackingField;
    public string FrameworkName { get; }
    public IEnumerable`1<LibraryDependency> TransitiveDependencies { get; }
    public CentralTransitiveDependencyGroup(NuGetFramework framework, IEnumerable`1<LibraryDependency> transitiveDependencies);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryDependency> get_TransitiveDependencies();
    public sealed virtual bool Equals(CentralTransitiveDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.ProjectModel.CircularMemoryStream : MemoryStream {
    private Byte[] _buffer;
    [CompilerGeneratedAttribute]
private EventHandler`1<ArraySegment`1<byte>> OnFlush;
    internal CircularMemoryStream(Byte[] buffer);
    [CompilerGeneratedAttribute]
internal void add_OnFlush(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
internal void remove_OnFlush(EventHandler`1<ArraySegment`1<byte>> value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual void Flush();
    private void FlushIfFull();
}
internal class NuGet.ProjectModel.DependencyGraphSpec : object {
    private static bool UseLegacyHashFunction;
    private static string DGSpecFileNameExtension;
    private SortedSet`1<string> _restore;
    private SortedDictionary`2<string, PackageSpec> _projects;
    private static int Version;
    private bool _isReadOnly;
    public IReadOnlyList`1<string> Restore { get; }
    public IReadOnlyList`1<PackageSpec> Projects { get; }
    public DependencyGraphSpec(bool isReadOnly);
    private static DependencyGraphSpec();
    public static string GetDGSpecFileName(string projectName);
    public IReadOnlyList`1<string> get_Restore();
    public IReadOnlyList`1<PackageSpec> get_Projects();
    public PackageSpec GetProjectSpec(string projectUniqueName);
    public IReadOnlyList`1<string> GetParents(string rootUniqueName);
    public DependencyGraphSpec WithProjectClosure(string projectUniqueName);
    public DependencyGraphSpec CreateFromClosure(string projectUniqueName, IReadOnlyList`1<PackageSpec> closure);
    public IReadOnlyList`1<PackageSpec> GetClosure(string rootUniqueName);
    private static IEnumerable`1<string> GetProjectReferenceNames(PackageSpec spec, SortedDictionary`2<string, PackageSpec> projectsByUniqueName);
    public void AddRestore(string projectUniqueName);
    public void AddProject(PackageSpec projectSpec);
    public static DependencyGraphSpec Union(IEnumerable`1<DependencyGraphSpec> dgSpecs);
    public static DependencyGraphSpec Load(string path);
    public void Save(string path);
    public void Save(Stream stream);
    public string GetHash();
    private void Write(IObjectWriter writer, bool hashing, Action`4<PackageSpec, IObjectWriter, bool, IEnvironmentVariableReader> writeAction);
    public static IReadOnlyList`1<PackageSpec> SortPackagesByDependencyOrder(IEnumerable`1<PackageSpec> packages);
    public DependencyGraphSpec WithoutRestores();
    public DependencyGraphSpec WithReplacedSpec(PackageSpec project);
    public DependencyGraphSpec WithPackageSpecs(IEnumerable`1<PackageSpec> packageSpecs);
    public DependencyGraphSpec WithoutTools();
    private static string GetPackageSpecId(PackageSpec spec);
    private static String[] GetPackageSpecDependencyIds(PackageSpec spec);
}
internal class NuGet.ProjectModel.ExternalProjectReference : object {
    private PackageSpec _packageSpec;
    [CompilerGeneratedAttribute]
private string <UniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ExternalProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectJsonPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSpecProjectName>k__BackingField;
    public string UniqueName { get; }
    public PackageSpec PackageSpec { get; }
    public IReadOnlyList`1<string> ExternalProjectReferences { get; }
    public string MSBuildProjectPath { get; }
    public string ProjectJsonPath { get; }
    public string PackageSpecProjectName { get; }
    public string ProjectName { get; }
    public ExternalProjectReference(string uniqueName, PackageSpec packageSpec, string msbuildProjectPath, IEnumerable`1<string> projectReferences);
    public ExternalProjectReference(string uniqueName, string packageSpecProjectName, string packageSpecPath, string msbuildProjectPath, IEnumerable`1<string> projectReferences);
    [CompilerGeneratedAttribute]
public string get_UniqueName();
    public PackageSpec get_PackageSpec();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ExternalProjectReferences();
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectPath();
    [CompilerGeneratedAttribute]
public string get_ProjectJsonPath();
    [CompilerGeneratedAttribute]
public string get_PackageSpecProjectName();
    public string get_ProjectName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ExternalProjectReference other);
    public sealed virtual int CompareTo(ExternalProjectReference other);
}
internal class NuGet.ProjectModel.FileFormatException : Exception {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string Path { get; private set; }
    public int Line { get; private set; }
    public int Column { get; private set; }
    public FileFormatException(string message);
    public FileFormatException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    private FileFormatException WithFilePath(string path);
    private FileFormatException WithLineInfo(JsonReaderException exception);
    private FileFormatException WithLineInfo(int line, int column);
    private FileFormatException WithLineInfo(IJsonLineInfo lineInfo);
    public static FileFormatException Create(Exception exception, JToken value, string path);
    internal static FileFormatException Create(Exception exception, int line, int column, string path);
    internal static FileFormatException Create(Exception exception, string path);
    public static FileFormatException Create(string message, JToken value, string path);
    internal static FileFormatException Create(string message, int line, int column, string path);
    internal static FileFormatException Create(JsonReaderException exception, string path);
    internal static FileFormatException Create(string message, string path);
}
internal class NuGet.ProjectModel.FnvHash64Function : object {
    private ulong _hash;
    public sealed virtual void Update(Byte[] data, int offset, int count);
    public Byte[] GetHashBytes();
    public sealed virtual string GetHash();
    public sealed virtual void Dispose();
}
internal class NuGet.ProjectModel.HashObjectWriter : object {
    private static int DefaultBufferSize;
    private Byte[] _buffer;
    private IHashFunction _hashFunc;
    private bool _isDisposed;
    private bool _isReadOnly;
    private int _nestLevel;
    private CircularMemoryStream _stream;
    private StreamWriter _streamWriter;
    private JsonTextWriter _writer;
    public HashObjectWriter(IHashFunction hashFunc);
    public sealed virtual void Dispose();
    public sealed virtual void WriteObjectStart();
    public sealed virtual void WriteObjectStart(string name);
    public sealed virtual void WriteObjectEnd();
    public sealed virtual void WriteNameValue(string name, int value);
    public sealed virtual void WriteNameValue(string name, bool value);
    public sealed virtual void WriteNameValue(string name, string value);
    public sealed virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public sealed virtual void WriteNonEmptyNameArray(string name, IEnumerable`1<string> values);
    public string GetHash();
    public sealed virtual void WriteArrayStart(string name);
    public sealed virtual void WriteArrayEnd();
    private void OnFlush(object sender, ArraySegment`1<byte> bytes);
    private void ThrowIfReadOnly();
    private void ThrowIfDisposed();
}
internal interface NuGet.ProjectModel.IAssetsLogMessage {
    public LogLevel Level { get; }
    public NuGetLogCode Code { get; }
    public string Message { get; }
    public string ProjectPath { get; }
    public WarningLevel WarningLevel { get; }
    public string FilePath { get; }
    public int StartLineNumber { get; }
    public int StartColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string LibraryId { get; }
    public IReadOnlyList`1<string> TargetGraphs { get; }
    public abstract virtual LogLevel get_Level();
    public abstract virtual NuGetLogCode get_Code();
    public abstract virtual string get_Message();
    public abstract virtual string get_ProjectPath();
    public abstract virtual WarningLevel get_WarningLevel();
    public abstract virtual string get_FilePath();
    public abstract virtual int get_StartLineNumber();
    public abstract virtual int get_StartColumnNumber();
    public abstract virtual int get_EndLineNumber();
    public abstract virtual int get_EndColumnNumber();
    public abstract virtual string get_LibraryId();
    public abstract virtual IReadOnlyList`1<string> get_TargetGraphs();
}
internal interface NuGet.ProjectModel.IExternalProjectReferenceProvider {
    public abstract virtual IReadOnlyList`1<ExternalProjectReference> GetReferences(string entryPointPath);
    public abstract virtual IReadOnlyList`1<ExternalProjectReference> GetEntryPoints();
}
internal class NuGet.ProjectModel.IncludeExcludeFiles : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <IncludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ExcludeFiles>k__BackingField;
    public IReadOnlyList`1<string> Include { get; public set; }
    public IReadOnlyList`1<string> Exclude { get; public set; }
    public IReadOnlyList`1<string> IncludeFiles { get; public set; }
    public IReadOnlyList`1<string> ExcludeFiles { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_IncludeFiles();
    [CompilerGeneratedAttribute]
public void set_IncludeFiles(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ExcludeFiles();
    [CompilerGeneratedAttribute]
public void set_ExcludeFiles(IReadOnlyList`1<string> value);
    public bool HandleIncludeExcludeFiles(JObject jsonObject);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IncludeExcludeFiles other);
    public IncludeExcludeFiles Clone();
    private static bool TryGetStringEnumerableFromJArray(JToken token, IReadOnlyList`1& result);
}
internal interface NuGet.ProjectModel.IUtf8JsonStreamReaderConverter`1 {
    public abstract virtual T Read(Utf8JsonStreamReader& reader);
}
internal static class NuGet.ProjectModel.JsonPackageSpecReader : object {
    private static Char[] DelimitedStringSeparators;
    private static Char[] VersionSeparators;
    private static char VersionSeparator;
    public static string RestoreOptions;
    public static string RestoreSettings;
    public static string HideWarningsAndErrors;
    public static string PackOptions;
    public static string PackageType;
    public static string Files;
    private static Byte[] AuthorsPropertyName;
    private static Byte[] BuildOptionsPropertyName;
    private static Byte[] ContentFilesPropertyName;
    private static Byte[] CopyrightPropertyName;
    private static Byte[] DependenciesPropertyName;
    private static Byte[] DescriptionPropertyName;
    private static Byte[] LanguagePropertyName;
    private static Byte[] PackIncludePropertyName;
    private static Byte[] PackOptionsPropertyName;
    private static Byte[] ScriptsPropertyName;
    private static Byte[] FrameworksPropertyName;
    private static Byte[] RestorePropertyName;
    private static Byte[] RuntimesPropertyName;
    private static Byte[] SupportsPropertyName;
    private static Byte[] TitlePropertyName;
    private static Byte[] VersionPropertyName;
    private static Byte[] OutputNamePropertyName;
    private static Byte[] AutoReferencedPropertyName;
    private static Byte[] ExcludePropertyName;
    private static Byte[] GeneratePathPropertyPropertyName;
    private static Byte[] IncludePropertyName;
    private static Byte[] NoWarnPropertyName;
    private static Byte[] SuppressParentPropertyName;
    private static Byte[] TargetPropertyName;
    private static Byte[] VersionOverridePropertyName;
    private static Byte[] VersionCentrallyManagedPropertyName;
    private static Byte[] AliasesPropertyName;
    private static Byte[] NamePropertyName;
    private static Byte[] PrivateAssetsPropertyName;
    private static Byte[] ExcludeFilesPropertyName;
    private static Byte[] IncludeFilesPropertyName;
    private static Byte[] CentralPackageVersionsManagementEnabledPropertyName;
    private static Byte[] CentralPackageVersionOverrideDisabledPropertyName;
    private static Byte[] CentralPackageTransitivePinningEnabledPropertyName;
    private static Byte[] ConfigFilePathsPropertyName;
    private static Byte[] CrossTargetingPropertyName;
    private static Byte[] FallbackFoldersPropertyName;
    private static Byte[] FilesPropertyName;
    private static Byte[] LegacyPackagesDirectoryPropertyName;
    private static Byte[] OriginalTargetFrameworksPropertyName;
    private static Byte[] OutputPathPropertyName;
    private static Byte[] PackagesConfigPathPropertyName;
    private static Byte[] PackagesPathPropertyName;
    private static Byte[] ProjectJsonPathPropertyName;
    private static Byte[] ProjectNamePropertyName;
    private static Byte[] ProjectPathPropertyName;
    private static Byte[] ProjectStylePropertyName;
    private static Byte[] ProjectUniqueNamePropertyName;
    private static Byte[] RestoreLockPropertiesPropertyName;
    private static Byte[] NuGetLockFilePathPropertyName;
    private static Byte[] RestoreLockedModePropertyName;
    private static Byte[] RestorePackagesWithLockFilePropertyName;
    private static Byte[] RestoreAuditPropertiesPropertyName;
    private static Byte[] EnableAuditPropertyName;
    private static Byte[] AuditLevelPropertyName;
    private static Byte[] AuditModePropertyName;
    private static Byte[] AuditSuppressionsPropertyName;
    private static Byte[] SkipContentFileWritePropertyName;
    private static Byte[] SourcesPropertyName;
    private static Byte[] ValidateRuntimeAssetsPropertyName;
    private static Byte[] WarningPropertiesPropertyName;
    private static Byte[] AllWarningsAsErrorsPropertyName;
    private static Byte[] WarnAsErrorPropertyName;
    private static Byte[] WarnNotAsErrorPropertyName;
    private static Byte[] ExcludeAssetsPropertyName;
    private static Byte[] IncludeAssetsPropertyName;
    private static Byte[] TargetAliasPropertyName;
    private static Byte[] AssetTargetFallbackPropertyName;
    private static Byte[] SecondaryFrameworkPropertyName;
    private static Byte[] CentralPackageVersionsPropertyName;
    private static Byte[] DownloadDependenciesPropertyName;
    private static Byte[] FrameworkAssembliesPropertyName;
    private static Byte[] FrameworkReferencesPropertyName;
    private static Byte[] ImportsPropertyName;
    private static Byte[] RuntimeIdentifierGraphPathPropertyName;
    private static Byte[] WarnPropertyName;
    private static Byte[] IconUrlPropertyName;
    private static Byte[] LicenseUrlPropertyName;
    private static Byte[] OwnersPropertyName;
    private static Byte[] PackageTypePropertyName;
    private static Byte[] ProjectUrlPropertyName;
    private static Byte[] ReleaseNotesPropertyName;
    private static Byte[] RequireLicenseAcceptancePropertyName;
    private static Byte[] SummaryPropertyName;
    private static Byte[] TagsPropertyName;
    private static Byte[] MappingsPropertyName;
    private static Byte[] HashTagImportPropertyName;
    private static Byte[] ProjectReferencesPropertyName;
    private static Byte[] EmptyStringPropertyName;
    private static JsonPackageSpecReader();
    public static PackageSpec GetPackageSpec(string name, string packageSpecPath);
    public static PackageSpec GetPackageSpec(string json, string name, string packageSpecPath);
    public static PackageSpec GetPackageSpec(Stream stream, string name, string packageSpecPath, string snapshotValue);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static PackageSpec GetPackageSpec(JObject json);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static PackageSpec GetPackageSpec(JObject rawPackageSpec, string name, string packageSpecPath, string snapshotValue);
    [ObsoleteAttribute]
internal static PackageSpec GetPackageSpec(JsonTextReader jsonReader, string packageSpecPath);
    internal static PackageSpec GetPackageSpec(Stream stream, string name, string packageSpecPath, string snapshotValue, IEnvironmentVariableReader environmentVariableReader, bool bypassCache);
    [ObsoleteAttribute]
internal static PackageSpec GetPackageSpec(JsonTextReader jsonReader, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    [ObsoleteAttribute]
private static PackageType CreatePackageType(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadBuildOptions(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadCentralPackageVersions(JsonTextReader jsonReader, IDictionary`2<string, CentralPackageVersion> centralPackageVersions, string filePath);
    [ObsoleteAttribute]
private static CompatibilityProfile ReadCompatibilityProfile(JsonTextReader jsonReader, string profileName);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.JsonPackageSpecReader/<ReadCompatibilitySets>d__21")]
[ObsoleteAttribute]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(JsonTextReader jsonReader, string compatibilitySetName);
    [ObsoleteAttribute]
private static void ReadDependencies(JsonTextReader jsonReader, IList`1<LibraryDependency> results, string packageSpecPath, bool isGacOrFrameworkReference);
    [ObsoleteAttribute]
internal static void ReadCentralTransitiveDependencyGroup(JsonTextReader jsonReader, IList`1<LibraryDependency> results, string packageSpecPath);
    [ObsoleteAttribute]
private static void ReadDownloadDependencies(JsonTextReader jsonReader, IList`1<DownloadDependency> downloadDependencies, string packageSpecPath);
    [ObsoleteAttribute]
private static IReadOnlyList`1<string> ReadEnumerableOfString(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadFrameworkReferences(JsonTextReader jsonReader, ISet`1<FrameworkDependency> frameworkReferences, string packageSpecPath);
    [ObsoleteAttribute]
private static void ReadFrameworks(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadImports(PackageSpec packageSpec, JsonTextReader jsonReader, TargetFrameworkInformation targetFrameworkInformation);
    [ObsoleteAttribute]
private static void ReadMappings(JsonTextReader jsonReader, string mappingKey, IDictionary`2<string, IncludeExcludeFiles> mappings);
    [ObsoleteAttribute]
private static void ReadMSBuildMetadata(JsonTextReader jsonReader, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static string ExtractMacro(string value, string userSettingsDirectory, bool useMacros);
    private static void ExtractMacros(List`1<string> paths, string userSettingsDirectory, bool useMacros);
    private static bool ReadNextTokenAsBoolOrFalse(JsonTextReader jsonReader, string filePath);
    [ObsoleteAttribute]
private static void ReadNuGetLogCodes(JsonTextReader jsonReader, HashSet`1<NuGetLogCode> hashCodes);
    private static IList`1<NuGetLogCode> ReadNuGetLogCodesList(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadPackageTypes(PackageSpec packageSpec, JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadPackInclude(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadPackOptions(JsonTextReader jsonReader, PackageSpec packageSpec, Boolean& isMappingsNull);
    [ObsoleteAttribute]
private static bool ReadPackOptionsFiles(PackageSpec packageSpec, JsonTextReader jsonReader, bool wasMappingsRead);
    [ObsoleteAttribute]
private static RuntimeDependencySet ReadRuntimeDependencySet(JsonTextReader jsonReader, string dependencySetName);
    [ObsoleteAttribute]
private static RuntimeDescription ReadRuntimeDescription(JsonTextReader jsonReader, string runtimeName);
    [ObsoleteAttribute]
private static List`1<RuntimeDescription> ReadRuntimes(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadScripts(JsonTextReader jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static String[] ReadStringArray(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static List`1<CompatibilityProfile> ReadSupports(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static LibraryDependencyTarget ReadTarget(JsonTextReader jsonReader, string packageSpecPath, LibraryDependencyTarget targetFlagsValue);
    [ObsoleteAttribute]
private static List`1<ProjectRestoreMetadataFrameworkInfo> ReadTargetFrameworks(JsonTextReader jsonReader);
    [ObsoleteAttribute]
private static void ReadTargetFrameworks(PackageSpec packageSpec, JsonTextReader jsonReader, Int32& frameworkLine, Int32& frameworkColumn);
    [ObsoleteAttribute]
private static void AddTargetFramework(PackageSpec packageSpec, NuGetFramework frameworkName, NuGetFramework secondaryFramework, TargetFrameworkInformation targetFrameworkInformation);
    [ObsoleteAttribute]
private static NuGetFramework GetDualCompatibilityFrameworkIfNeeded(NuGetFramework frameworkName, NuGetFramework secondaryFramework);
    [ObsoleteAttribute]
private static bool ValidateDependencyTarget(LibraryDependencyTarget targetValue);
    private static HashSet`1<string> ReadSuppressedAdvisories(JsonTextReader jsonReader);
    internal static PackageSpec GetPackageSpecUtf8JsonStreamReader(Stream stream, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    internal static PackageSpec GetPackageSpec(Utf8JsonStreamReader& jsonReader, string name, string packageSpecPath, IEnvironmentVariableReader environmentVariableReader, string snapshotValue);
    internal static void ReadCentralTransitiveDependencyGroup(Utf8JsonStreamReader& jsonReader, IList`1& results, string packageSpecPath);
    private static LibraryDependency ReadLibraryDependency(Utf8JsonStreamReader& jsonReader, string packageSpecPath, string libraryName);
    private static void ReadCentralTransitiveDependencyGroupProperties(Utf8JsonStreamReader& jsonReader, LibraryIncludeFlags& dependencyIncludeFlagsValue, LibraryIncludeFlags& dependencyExcludeFlagsValue, LibraryIncludeFlags& suppressParentFlagsValue, String& dependencyVersionValue);
    private static void ReadDependencies(Utf8JsonStreamReader& jsonReader, IList`1<LibraryDependency> results, string packageSpecPath, bool isGacOrFrameworkReference);
    private static PackageType CreatePackageType(Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadBuildOptions(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    private static void ReadCentralPackageVersions(Utf8JsonStreamReader& jsonReader, IDictionary`2<string, CentralPackageVersion> centralPackageVersions, string filePath);
    private static CompatibilityProfile ReadCompatibilityProfile(Utf8JsonStreamReader& jsonReader, string profileName);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.JsonPackageSpecReader/<ReadCompatibilitySets>d__152")]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(IReadOnlyList`1<string> values, string compatibilitySetName);
    private static void ReadDownloadDependencies(Utf8JsonStreamReader& jsonReader, IList`1<DownloadDependency> downloadDependencies, string packageSpecPath);
    private static void ReadFrameworkReferences(Utf8JsonStreamReader& jsonReader, ISet`1<FrameworkDependency> frameworkReferences, string packageSpecPath);
    private static void ReadFrameworks(Utf8JsonStreamReader& reader, PackageSpec packageSpec);
    private static void ReadImports(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader, TargetFrameworkInformation targetFrameworkInformation);
    private static void ReadMappings(Utf8JsonStreamReader& jsonReader, string mappingKey, IDictionary`2<string, IncludeExcludeFiles> mappings);
    private static void ReadMSBuildMetadata(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static void ReadNuGetLogCodes(Utf8JsonStreamReader& jsonReader, HashSet`1<NuGetLogCode> hashCodes);
    private static List`1<NuGetLogCode> ReadNuGetLogCodesList(Utf8JsonStreamReader& jsonReader);
    private static void ReadPackageTypes(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadPackInclude(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    [ObsoleteAttribute]
private static void ReadPackOptions(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec, Boolean& isMappingsNull);
    [ObsoleteAttribute]
private static bool ReadPackOptionsFiles(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader, bool wasMappingsRead);
    private static RuntimeDependencySet ReadRuntimeDependencySet(Utf8JsonStreamReader& jsonReader, string dependencySetName);
    private static RuntimeDescription ReadRuntimeDescription(Utf8JsonStreamReader& jsonReader, string runtimeName);
    private static List`1<RuntimeDescription> ReadRuntimes(Utf8JsonStreamReader& jsonReader);
    [ObsoleteAttribute]
private static void ReadScripts(Utf8JsonStreamReader& jsonReader, PackageSpec packageSpec);
    private static List`1<CompatibilityProfile> ReadSupports(Utf8JsonStreamReader& jsonReader);
    private static LibraryDependencyTarget ReadTarget(Utf8JsonStreamReader& jsonReader, string packageSpecPath, LibraryDependencyTarget targetFlagsValue);
    private static List`1<ProjectRestoreMetadataFrameworkInfo> ReadTargetFrameworks(Utf8JsonStreamReader& jsonReader);
    private static void ReadTargetFrameworks(PackageSpec packageSpec, Utf8JsonStreamReader& jsonReader);
    private static HashSet`1<string> ReadSuppressedAdvisories(Utf8JsonStreamReader& jsonReader);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.JsonTextReaderExtensions : object {
    private static Char[] DelimitedStringDelimiters;
    private static JsonTextReaderExtensions();
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadDelimitedString(JsonTextReader reader);
    [ExtensionAttribute]
internal static bool ReadNextToken(JsonTextReader reader);
    [ExtensionAttribute]
internal static string ReadNextTokenAsString(JsonTextReader reader);
    [ExtensionAttribute]
internal static bool ReadObject(JsonTextReader reader, Action`1<string> onProperty);
    [ExtensionAttribute]
internal static bool ReadObject(JsonTextReader reader, Action`1<string> onProperty, Int32& startObjectLine, Int32& startObjectColumn);
    [ExtensionAttribute]
internal static void ReadProperties(JsonTextReader reader, Action`1<string> onProperty);
    [ExtensionAttribute]
internal static List`1<string> ReadStringArrayAsList(JsonTextReader reader);
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadStringOrArrayOfStringsAsReadOnlyList(JsonTextReader reader);
    [ExtensionAttribute]
internal static IReadOnlyList`1<string> ReadStringArrayAsReadOnlyListFromArrayStart(JsonTextReader reader);
    [ExtensionAttribute]
private static string ReadTokenAsString(JsonTextReader reader);
}
internal static class NuGet.ProjectModel.JsonUtility : object {
    internal static string NUGET_EXPERIMENTAL_USE_NJ_FOR_FILE_PARSING;
    internal static Nullable`1<bool> UseNewtonsoftJson;
    internal static Char[] PathSplitChars;
    internal static JsonLoadSettings DefaultLoadSettings;
    private static JsonUtility();
    internal static JObject LoadJson(TextReader reader);
    internal static T LoadJson(Stream stream, IUtf8JsonStreamReaderConverter`1<T> converter);
    internal static PackageDependency ReadPackageDependency(string property, JToken json);
    internal static bool UseNewtonsoftJsonForParsing(IEnvironmentVariableReader environmentVariableReader, bool bypassCache);
    internal static JProperty WritePackageDependencyWithLegacyString(PackageDependency item);
    internal static void WritePackageDependencyWithLegacyString(JsonWriter writer, PackageDependency item);
    internal static JProperty WritePackageDependency(PackageDependency item);
    internal static void WritePackageDependency(JsonWriter writer, PackageDependency item);
    internal static TItem ReadProperty(JObject jObject, string propertyName);
    internal static IList`1<TItem> ReadObject(JObject jObject, Func`3<string, JToken, TItem> readItem);
    internal static JObject WriteObject(IEnumerable`1<TItem> items, Func`2<TItem, JProperty> writeItem);
    internal static void WriteObject(JsonWriter writer, IEnumerable`1<TItem> items, Action`2<JsonWriter, TItem> writeItem);
    internal static int ReadInt(JToken cursor, string property, int defaultValue);
    internal static JToken WriteString(string item);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.JTokenExtensions : object {
    [ExtensionAttribute]
public static T[] ValueAsArray(JToken jToken);
    [ExtensionAttribute]
public static T[] ValueAsArray(JToken jToken, string name);
    [ExtensionAttribute]
public static T GetValue(JToken token, string name);
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NuGet.ProjectModel.LazyStringSplit : ValueType {
    private string _input;
    private char _delimiter;
    public LazyStringSplit(string input, char delimiter);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    [IteratorStateMachineAttribute("NuGet.ProjectModel.LazyStringSplit/<Select>d__6`1")]
public IEnumerable`1<T> Select(Func`2<string, T> func);
    public string First();
    [NuGet.ProjectModel.NullableContextAttribute("2")]
public string FirstOrDefault();
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.LazyStringSplitExtensions : object {
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[ExtensionAttribute]
public static string FirstOrDefault(LazyStringSplit lazyStringSplit);
}
internal class NuGet.ProjectModel.LockFile : object {
    public static NuGetFramework ToolFramework;
    public static char DirectorySeparatorChar;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectFileDependencyGroup> <ProjectFileDependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileLibrary> <Libraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTarget> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <PackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpec <PackageSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CentralTransitiveDependencyGroup> <CentralTransitiveDependencyGroups>k__BackingField;
    public int Version { get; public set; }
    public string Path { get; public set; }
    public IList`1<ProjectFileDependencyGroup> ProjectFileDependencyGroups { get; public set; }
    public IList`1<LockFileLibrary> Libraries { get; public set; }
    public IList`1<LockFileTarget> Targets { get; public set; }
    public IList`1<LockFileItem> PackageFolders { get; public set; }
    public IList`1<IAssetsLogMessage> LogMessages { get; public set; }
    public PackageSpec PackageSpec { get; public set; }
    public IList`1<CentralTransitiveDependencyGroup> CentralTransitiveDependencyGroups { get; public set; }
    private static LockFile();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectFileDependencyGroup> get_ProjectFileDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_ProjectFileDependencyGroups(IList`1<ProjectFileDependencyGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileLibrary> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<LockFileTarget> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_PackageFolders();
    [CompilerGeneratedAttribute]
public void set_PackageFolders(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(IList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
public PackageSpec get_PackageSpec();
    [CompilerGeneratedAttribute]
public void set_PackageSpec(PackageSpec value);
    [CompilerGeneratedAttribute]
public IList`1<CentralTransitiveDependencyGroup> get_CentralTransitiveDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_CentralTransitiveDependencyGroups(IList`1<CentralTransitiveDependencyGroup> value);
    public bool IsValidForPackageSpec(PackageSpec spec);
    public bool IsValidForPackageSpec(PackageSpec spec, int requestLockFileVersion);
    private bool ValidateDependencies(PackageSpec spec);
    public LockFileTarget GetTarget(NuGetFramework framework, string runtimeIdentifier);
    public LockFileTarget GetTarget(string frameworkAlias, string runtimeIdentifier);
    public LockFileLibrary GetLibrary(string name, NuGetVersion version);
    public sealed virtual bool Equals(LockFile other);
    private bool LogsEqual(IList`1<IAssetsLogMessage> otherLogMessages);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.ProjectModel.LockFileContentFile : LockFileItem {
    public static string BuildActionProperty;
    public static string CodeLanguageProperty;
    public static string PPOutputPathProperty;
    public static string OutputPathProperty;
    public static string CopyToOutputProperty;
    public string OutputPath { get; public set; }
    public string PPOutputPath { get; public set; }
    public BuildAction BuildAction { get; public set; }
    public string CodeLanguage { get; public set; }
    public bool CopyToOutput { get; public set; }
    public LockFileContentFile(string path);
    private static LockFileContentFile();
    public string get_OutputPath();
    public void set_OutputPath(string value);
    public string get_PPOutputPath();
    public void set_PPOutputPath(string value);
    public BuildAction get_BuildAction();
    public void set_BuildAction(BuildAction value);
    public string get_CodeLanguage();
    public void set_CodeLanguage(string value);
    public bool get_CopyToOutput();
    public void set_CopyToOutput(bool value);
}
internal class NuGet.ProjectModel.LockFileDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <ResolvedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <RequestedVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDependencyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageDependency> <Dependencies>k__BackingField;
    public string Id { get; public set; }
    public NuGetVersion ResolvedVersion { get; public set; }
    public VersionRange RequestedVersion { get; public set; }
    public string ContentHash { get; public set; }
    public PackageDependencyType Type { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_ResolvedVersion();
    [CompilerGeneratedAttribute]
public void set_ResolvedVersion(NuGetVersion value);
    [CompilerGeneratedAttribute]
public VersionRange get_RequestedVersion();
    [CompilerGeneratedAttribute]
public void set_RequestedVersion(VersionRange value);
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(string value);
    [CompilerGeneratedAttribute]
public PackageDependencyType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PackageDependencyType value);
    [CompilerGeneratedAttribute]
public IList`1<PackageDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<PackageDependency> value);
    public sealed virtual bool Equals(LockFileDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.ProjectModel.LockFileDependencyIdVersionComparer : object {
    [CompilerGeneratedAttribute]
private static LockFileDependencyIdVersionComparer <Default>k__BackingField;
    public static LockFileDependencyIdVersionComparer Default { get; }
    private static LockFileDependencyIdVersionComparer();
    [CompilerGeneratedAttribute]
public static LockFileDependencyIdVersionComparer get_Default();
    public sealed virtual bool Equals(LockFileDependency x, LockFileDependency y);
    public sealed virtual int GetHashCode(LockFileDependency obj);
}
[ObsoleteAttribute("This is an unused class and will be removed in a future version.")]
internal class NuGet.ProjectModel.LockFileDependencyProvider : object {
    private IDictionary`2<Tuple`2<NuGetFramework, string>, LockFileTargetLibrary> _targetLibraries;
    private IDictionary`2<Tuple`2<string, NuGetVersion>, LockFileLibrary> _libraries;
    public LockFileDependencyProvider(LockFile lockFile);
    public sealed virtual bool SupportsType(LibraryDependencyTarget libraryType);
    public sealed virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
    private IList`1<LibraryDependency> GetDependencies(LockFileTargetLibrary library);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.LockFileExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTarget> GetTargetGraphs(IAssetsLogMessage message, LockFile assetsFile);
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTargetLibrary> GetTargetLibraries(IAssetsLogMessage message, LockFile assetsFile);
    [ExtensionAttribute]
public static LockFileTargetLibrary GetTargetLibrary(LockFileTarget target, string libraryId);
}
internal class NuGet.ProjectModel.LockFileFormat : object {
    public static int Version;
    public static string LockFileName;
    public static string AssetsFileName;
    private static string VersionProperty;
    private static string LibrariesProperty;
    private static string TargetsProperty;
    private static string ProjectFileDependencyGroupsProperty;
    private static string ServicableProperty;
    private static string Sha512Property;
    private static string FilesProperty;
    private static string HasToolsProperty;
    private static string DependenciesProperty;
    private static string FrameworkAssembliesProperty;
    private static string RuntimeProperty;
    private static string CompileProperty;
    private static string NativeProperty;
    private static string BuildProperty;
    private static string BuildMultiTargetingProperty;
    private static string ContentFilesProperty;
    private static string RuntimeTargetsProperty;
    private static string ResourceProperty;
    private static string TypeProperty;
    private static string PathProperty;
    private static string MSBuildProjectProperty;
    private static string FrameworkProperty;
    private static string ToolsProperty;
    private static string PackageFoldersProperty;
    private static string PackageSpecProperty;
    internal static string LogsProperty;
    private static string EmbedProperty;
    private static string FrameworkReferencesProperty;
    private static string CentralTransitiveDependencyGroupsProperty;
    private static LockFileFormat();
    public LockFile Parse(string lockFileContent, string path);
    public LockFile Parse(string lockFileContent, ILogger log, string path);
    public LockFile Read(string filePath);
    public LockFile Read(string filePath, ILogger log);
    public LockFile Read(Stream stream, string path);
    public LockFile Read(Stream stream, ILogger log, string path);
    internal LockFile Read(Stream stream, ILogger log, string path, IEnvironmentVariableReader environmentVariableReader, bool bypassCache);
    [ObsoleteAttribute("This method is deprecated. Use Read(Stream, string) instead.")]
public LockFile Read(TextReader reader, string path);
    [ObsoleteAttribute("This method is deprecated. Use Read(Stream, ILogger, string) instead.")]
public LockFile Read(TextReader reader, ILogger log, string path);
    public void Write(string filePath, LockFile lockFile);
    public void Write(Stream stream, LockFile lockFile);
    public void Write(TextWriter textWriter, LockFile lockFile);
    public string Render(LockFile lockFile);
    private LockFile Utf8JsonRead(Stream stream, ILogger log, string path);
    [ObsoleteAttribute]
private static LockFile ReadLockFile(JObject cursor, string path);
    private static void WriteLockFile(JsonWriter writer, IObjectWriter jsonObjectWriter, LockFile lockFile);
    private static LockFileLibrary ReadLibrary(string property, JToken json);
    private static void WriteLibrary(JsonWriter writer, LockFileLibrary library);
    private static void WriteTarget(JsonWriter writer, LockFileTarget target);
    private static LockFileTarget ReadTarget(string property, JToken json);
    private static void WriteLogMessage(JsonWriter writer, IAssetsLogMessage logMessage, string projectPath);
    private static IAssetsLogMessage ReadLogMessage(JObject json, string projectPath);
    internal static JArray WriteLogMessages(IEnumerable`1<IAssetsLogMessage> logMessages, string projectPath);
    internal static void WriteLogMessages(JsonWriter writer, IEnumerable`1<IAssetsLogMessage> logMessages, string projectPath);
    private static LockFileTargetLibrary ReadTargetLibrary(string property, JToken json);
    private static void WriteTargetLibrary(JsonWriter writer, LockFileTargetLibrary library);
    private static LockFileRuntimeTarget ReadRuntimeTarget(string property, JToken json);
    private static LockFileContentFile ReadContentFile(string property, JToken json);
    private static ProjectFileDependencyGroup ReadProjectFileDependencyGroup(string property, JToken json);
    private static PackageSpec ReadPackageSpec(JObject json);
    private static void WriteProjectFileDependencyGroup(JsonWriter writer, ProjectFileDependencyGroup frameworkInfo);
    private static LockFileItem ReadFileItem(string property, JToken json);
    private static T ReadFileItem(string property, JToken json, Func`2<string, T> factory);
    private static void WriteFileItem(JsonWriter writer, LockFileItem item);
    private static IList`1<TItem> ReadArray(JArray json, Func`2<JToken, TItem> readItem);
    internal static IList`1<IAssetsLogMessage> ReadLogMessageArray(JArray json, string projectPath);
    private static IList`1<string> ReadPathArray(JArray json);
    private static void WritePathArray(JsonWriter writer, string property, IEnumerable`1<string> items);
    internal static void WriteArray(JsonWriter writer, IEnumerable`1<string> values);
    private static bool ReadBool(JToken cursor, string property, bool defaultValue);
    private static string ReadString(JToken json);
    private static SemanticVersion ReadSemanticVersion(JToken json, string property);
    private static string GetPathWithForwardSlashes(string path);
    private static string GetPathWithBackSlashes(string path);
    private static void WriteCentralTransitiveDependencyGroup(IObjectWriter writer, IList`1<CentralTransitiveDependencyGroup> centralTransitiveDependencyGroups);
    [ObsoleteAttribute]
private static List`1<CentralTransitiveDependencyGroup> ReadProjectFileTransitiveDependencyGroup(JObject json, string path);
}
internal class NuGet.ProjectModel.LockFileItem : object {
    public static string AliasesProperty;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string Path { get; }
    public IDictionary`2<string, string> Properties { get; }
    public LockFileItem(string path);
    private static LockFileItem();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    public virtual string ToString();
    public sealed virtual bool Equals(LockFileItem other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LockFileItem op_Implicit(string path);
    protected string GetProperty(string name);
    protected void SetProperty(string name, string value);
}
internal class NuGet.ProjectModel.LockFileLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServiceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTools>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public NuGetVersion Version { get; public set; }
    public bool IsServiceable { get; public set; }
    public string Sha512 { get; public set; }
    public IList`1<string> Files { get; public set; }
    public string Path { get; public set; }
    public string MSBuildProject { get; public set; }
    public bool HasTools { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsServiceable();
    [CompilerGeneratedAttribute]
public void set_IsServiceable(bool value);
    [CompilerGeneratedAttribute]
public string get_Sha512();
    [CompilerGeneratedAttribute]
public void set_Sha512(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProject();
    [CompilerGeneratedAttribute]
public void set_MSBuildProject(string value);
    [CompilerGeneratedAttribute]
public bool get_HasTools();
    [CompilerGeneratedAttribute]
public void set_HasTools(bool value);
    public sealed virtual bool Equals(LockFileLibrary other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public LockFileLibrary Clone();
}
internal class NuGet.ProjectModel.LockFileRuntimeTarget : LockFileItem {
    public static string RidProperty;
    public static string AssetTypeProperty;
    public string Runtime { get; public set; }
    public string AssetType { get; public set; }
    public LockFileRuntimeTarget(string path);
    public LockFileRuntimeTarget(string path, string runtime, string assetType);
    private static LockFileRuntimeTarget();
    public string get_Runtime();
    public void set_Runtime(string value);
    public string get_AssetType();
    public void set_AssetType(string value);
}
internal class NuGet.ProjectModel.LockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTargetLibrary> <Libraries>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public string Name { get; }
    public IList`1<LockFileTargetLibrary> Libraries { get; public set; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<LockFileTargetLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileTargetLibrary> value);
    public sealed virtual bool Equals(LockFileTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
internal class NuGet.ProjectModel.LockFileTargetLibrary : object {
    private static PropertyKey DependenciesKey;
    private static PropertyKey FrameworkAssembliesKey;
    private static PropertyKey FrameworkReferencesKey;
    private static PropertyKey RuntimeAssembliesKey;
    private static PropertyKey ResourceAssembliesKey;
    private static PropertyKey CompileTimeAssembliesKey;
    private static PropertyKey NativeLibrariesKey;
    private static PropertyKey BuildKey;
    private static PropertyKey BuildMultiTargetingKey;
    private static PropertyKey ContentFilesKey;
    private static PropertyKey RuntimeTargetsKey;
    private static PropertyKey ToolsAssembliesKey;
    private static PropertyKey EmbedAssembliesKey;
    private static PropertyKey PackageTypeKey;
    private Dictionary`2<PropertyKey, object> _propertyValues;
    private bool _isFrozen;
    [NuGet.ProjectModel.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NuGet.ProjectModel.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [NuGet.ProjectModel.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [NuGet.ProjectModel.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [NuGet.ProjectModel.NullableAttribute("2")]
public string Name { get; public set; }
    [NuGet.ProjectModel.NullableAttribute("2")]
public string Framework { get; public set; }
    [NuGet.ProjectModel.NullableAttribute("2")]
public NuGetVersion Version { get; public set; }
    [NuGet.ProjectModel.NullableAttribute("2")]
public string Type { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    public IList`1<string> FrameworkAssemblies { get; public set; }
    public IList`1<string> FrameworkReferences { get; public set; }
    public IList`1<LockFileItem> RuntimeAssemblies { get; public set; }
    public IList`1<LockFileItem> ResourceAssemblies { get; public set; }
    public IList`1<LockFileItem> CompileTimeAssemblies { get; public set; }
    public IList`1<LockFileItem> NativeLibraries { get; public set; }
    public IList`1<LockFileItem> Build { get; public set; }
    public IList`1<LockFileItem> BuildMultiTargeting { get; public set; }
    public IList`1<LockFileContentFile> ContentFiles { get; public set; }
    public IList`1<LockFileRuntimeTarget> RuntimeTargets { get; public set; }
    public IList`1<LockFileItem> ToolsAssemblies { get; public set; }
    public IList`1<LockFileItem> EmbedAssemblies { get; public set; }
    public IList`1<PackageType> PackageType { get; public set; }
    private static LockFileTargetLibrary();
    private IList`1<T> GetListProperty(PropertyKey key);
    private void SetListProperty(PropertyKey key, IList`1<T> list);
    public void Freeze();
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Framework();
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Framework(string value);
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Type();
    [NuGet.ProjectModel.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Type(string value);
    public IList`1<PackageDependency> get_Dependencies();
    public void set_Dependencies(IList`1<PackageDependency> value);
    public IList`1<string> get_FrameworkAssemblies();
    public void set_FrameworkAssemblies(IList`1<string> value);
    public IList`1<string> get_FrameworkReferences();
    public void set_FrameworkReferences(IList`1<string> value);
    public IList`1<LockFileItem> get_RuntimeAssemblies();
    public void set_RuntimeAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_ResourceAssemblies();
    public void set_ResourceAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_CompileTimeAssemblies();
    public void set_CompileTimeAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_NativeLibraries();
    public void set_NativeLibraries(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_Build();
    public void set_Build(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_BuildMultiTargeting();
    public void set_BuildMultiTargeting(IList`1<LockFileItem> value);
    public IList`1<LockFileContentFile> get_ContentFiles();
    public void set_ContentFiles(IList`1<LockFileContentFile> value);
    public IList`1<LockFileRuntimeTarget> get_RuntimeTargets();
    public void set_RuntimeTargets(IList`1<LockFileRuntimeTarget> value);
    public IList`1<LockFileItem> get_ToolsAssemblies();
    public void set_ToolsAssemblies(IList`1<LockFileItem> value);
    public IList`1<LockFileItem> get_EmbedAssemblies();
    public void set_EmbedAssemblies(IList`1<LockFileItem> value);
    public IList`1<PackageType> get_PackageType();
    public void set_PackageType(IList`1<PackageType> value);
    [NuGet.ProjectModel.NullableContextAttribute("2")]
public sealed virtual bool Equals(LockFileTargetLibrary other);
    [NuGet.ProjectModel.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private bool <Equals>g__IsListOrderedEqual|78_13(PropertyKey key, Func`2<T, string> accessor, IEqualityComparer`1<T> sequenceComparer, <>c__DisplayClass78_0& );
}
internal static class NuGet.ProjectModel.LockFileUtilities : object {
    public static LockFile GetLockFile(string lockFilePath, ILogger logger);
}
internal class NuGet.ProjectModel.LockFileValidationResult : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InvalidReasons>k__BackingField;
    public bool IsValid { get; }
    public IReadOnlyList`1<string> InvalidReasons { get; }
    public LockFileValidationResult(bool isValid, IReadOnlyList`1<string> invalidReasons);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InvalidReasons();
}
internal static class NuGet.ProjectModel.MacroStringsUtility : object {
    internal static string NUGET_ENABLE_EXPERIMENTAL_MACROS;
    internal static string UserMacro;
    internal static void ApplyMacros(IList`1<string> list, string macroValue, string macroName, StringComparison stringComparison);
    internal static void ExtractMacros(List`1<string> list, string macroValue, string macroName);
    internal static string ApplyMacro(string originalString, string macroValue, string macroName, StringComparison stringComparison);
    internal static string ExtractMacro(string originalString, string macroValue, string macroName);
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
internal class NuGet.ProjectModel.NoAllocNewLineStreamWriter : StreamWriter {
    private string _newLine;
    public string NewLine { get; public set; }
    public NoAllocNewLineStreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public NoAllocNewLineStreamWriter(Stream stream);
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
}
internal enum NuGet.ProjectModel.PackageDependencyType : Enum {
    public int value__;
    public static PackageDependencyType Direct;
    public static PackageDependencyType Transitive;
    public static PackageDependencyType Project;
    public static PackageDependencyType CentralTransitive;
}
internal class NuGet.ProjectModel.PackagesConfigProjectRestoreMetadata : ProjectRestoreMetadata {
    [CompilerGeneratedAttribute]
private string <PackagesConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryPath>k__BackingField;
    public string PackagesConfigPath { get; public set; }
    public string RepositoryPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PackagesConfigPath();
    [CompilerGeneratedAttribute]
public void set_PackagesConfigPath(string value);
    [CompilerGeneratedAttribute]
public string get_RepositoryPath();
    [CompilerGeneratedAttribute]
public void set_RepositoryPath(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PackagesConfigProjectRestoreMetadata obj);
    public virtual ProjectRestoreMetadata Clone();
}
internal class NuGet.ProjectModel.PackagesLockFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackagesLockFileTarget> <Targets>k__BackingField;
    public int Version { get; public set; }
    public string Path { get; public set; }
    public IList`1<PackagesLockFileTarget> Targets { get; public set; }
    public PackagesLockFile(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackagesLockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<PackagesLockFileTarget> value);
    public sealed virtual bool Equals(PackagesLockFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class NuGet.ProjectModel.PackagesLockFileFormat : object {
    public static int Version;
    public static int PackagesLockFileVersion;
    public static string LockFileName;
    private static string VersionProperty;
    private static string ResolvedProperty;
    private static string RequestedProperty;
    private static string ContentHashProperty;
    private static string DependenciesProperty;
    private static string TypeProperty;
    private static PackagesLockFileFormat();
    public static PackagesLockFile Parse(string lockFileContent, string path);
    public static PackagesLockFile Parse(string lockFileContent, ILogger log, string path);
    public static PackagesLockFile Read(string filePath);
    public static PackagesLockFile Read(string filePath, ILogger log);
    public static PackagesLockFile Read(Stream stream, ILogger log, string path);
    public static PackagesLockFile Read(TextReader reader, ILogger log, string path);
    private static PackagesLockFile ReadLockFile(JObject cursor);
    public static string Render(PackagesLockFile lockFile);
    public static void Write(string filePath, PackagesLockFile lockFile);
    public static void Write(Stream stream, PackagesLockFile lockFile);
    public static void Write(TextWriter textWriter, PackagesLockFile lockFile);
    private static JObject WriteLockFile(PackagesLockFile lockFile);
    private static PackagesLockFileTarget ReadDependency(string property, JToken json);
    private static LockFileDependency ReadTargetDependency(string property, JToken json);
    private static JProperty WriteTarget(PackagesLockFileTarget target);
    private static JProperty WriteTargetDependency(LockFileDependency dependency);
}
internal class NuGet.ProjectModel.PackagesLockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileDependency> <Dependencies>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public IList`1<LockFileDependency> Dependencies { get; public set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LockFileDependency> value);
    public string get_Name();
    public sealed virtual bool Equals(PackagesLockFileTarget other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static string GetNameString(NuGetFramework framework, string runtime);
}
internal static class NuGet.ProjectModel.PackagesLockFileUtilities : object {
    public static bool IsNuGetLockFileEnabled(PackageSpec project);
    public static string GetNuGetLockFilePath(PackageSpec project);
    public static string GetNuGetLockFilePath(string baseDirectory, string projectName);
    [ObsoleteAttribute("This method is obsolete. Call IsLockFileValid instead.")]
public static bool IsLockFileStillValid(DependencyGraphSpec dgSpec, PackagesLockFile nuGetLockFile);
    public static LockFileValidationResult IsLockFileValid(DependencyGraphSpec dgSpec, PackagesLockFile nuGetLockFile);
    public static LockFileValidityWithMatchedResults IsLockFileStillValid(PackagesLockFile expected, PackagesLockFile actual);
    private static ValueTuple`2<bool, string> HasDirectPackageDependencyChanged(IEnumerable`1<LibraryDependency> newDependencies, IEnumerable`1<LockFileDependency> lockFileDependencies, NuGetFramework nuGetFramework);
    private static ValueTuple`2<bool, string> HasP2PDependencyChanged(IEnumerable`1<LibraryDependency> newDependencies, IEnumerable`1<ProjectRestoreReference> projectRestoreReferences, LockFileDependency projectDependency, DependencyGraphSpec dgSpec);
    private static ValueTuple`2<bool, string> HasProjectTransitiveDependencyChanged(IDictionary`2<string, CentralPackageVersion> centralPackageVersions, IList`1<LockFileDependency> lockFileCentralTransitiveDependencies, IList`1<LockFileDependency> lockTransitiveDependencies);
}
[DebuggerDisplayAttribute("{Name}")]
internal class NuGet.ProjectModel.PackageSpec : object {
    public static string PackageSpecFileName;
    public static NuGetVersion DefaultVersion;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    private NuGetVersion _version;
    [CompilerGeneratedAttribute]
private bool <IsDefaultVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasVersionSnapshot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildOptions <BuildOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <Scripts>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <PackInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private PackOptions <PackOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TargetFrameworkInformation> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeGraph <RuntimeGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRestoreSettings <RestoreSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRestoreMetadata <RestoreMetadata>k__BackingField;
    public string FilePath { get; public set; }
    public string BaseDirectory { get; }
    public string Name { get; public set; }
    public string Title { get; public set; }
    public NuGetVersion Version { get; public set; }
    [ObsoleteAttribute]
public bool IsDefaultVersion { get; public set; }
    [ObsoleteAttribute]
public bool HasVersionSnapshot { get; public set; }
    [ObsoleteAttribute]
public string Description { get; public set; }
    [ObsoleteAttribute]
public string Summary { get; public set; }
    [ObsoleteAttribute]
public string ReleaseNotes { get; public set; }
    [ObsoleteAttribute]
public String[] Authors { get; public set; }
    [ObsoleteAttribute]
public String[] Owners { get; public set; }
    [ObsoleteAttribute]
public string ProjectUrl { get; public set; }
    [ObsoleteAttribute]
public string IconUrl { get; public set; }
    [ObsoleteAttribute]
public string LicenseUrl { get; public set; }
    [ObsoleteAttribute]
public bool RequireLicenseAcceptance { get; public set; }
    [ObsoleteAttribute]
public string Copyright { get; public set; }
    [ObsoleteAttribute]
public string Language { get; public set; }
    [ObsoleteAttribute]
public BuildOptions BuildOptions { get; public set; }
    [ObsoleteAttribute]
public String[] Tags { get; public set; }
    [ObsoleteAttribute]
public IList`1<string> ContentFiles { get; public set; }
    [ObsoleteAttribute]
public IDictionary`2<string, IEnumerable`1<string>> Scripts { get; private set; }
    [ObsoleteAttribute]
public IDictionary`2<string, string> PackInclude { get; private set; }
    [ObsoleteAttribute]
public PackOptions PackOptions { get; public set; }
    public IList`1<LibraryDependency> Dependencies { get; public set; }
    public IList`1<TargetFrameworkInformation> TargetFrameworks { get; private set; }
    public RuntimeGraph RuntimeGraph { get; public set; }
    public ProjectRestoreSettings RestoreSettings { get; public set; }
    public ProjectRestoreMetadata RestoreMetadata { get; public set; }
    public PackageSpec(IList`1<TargetFrameworkInformation> frameworks);
    internal PackageSpec(IList`1<TargetFrameworkInformation> frameworks, IList`1<LibraryDependency> dependencies, RuntimeGraph runtimeGraph, ProjectRestoreSettings restoreSettings, String[] authors, String[] owners, String[] tags, IList`1<string> contentFiles, IDictionary`2<string, IEnumerable`1<string>> scripts, IDictionary`2<string, string> packInclude, PackOptions packOptions);
    private static PackageSpec();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    public string get_BaseDirectory();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public NuGetVersion get_Version();
    public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsDefaultVersion();
    [CompilerGeneratedAttribute]
public void set_IsDefaultVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasVersionSnapshot();
    [CompilerGeneratedAttribute]
public void set_HasVersionSnapshot(bool value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public String[] get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(String[] value);
    [CompilerGeneratedAttribute]
public string get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(string value);
    [CompilerGeneratedAttribute]
public string get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public BuildOptions get_BuildOptions();
    [CompilerGeneratedAttribute]
public void set_BuildOptions(BuildOptions value);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IEnumerable`1<string>> get_Scripts();
    [CompilerGeneratedAttribute]
private void set_Scripts(IDictionary`2<string, IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_PackInclude();
    [CompilerGeneratedAttribute]
private void set_PackInclude(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public PackOptions get_PackOptions();
    [CompilerGeneratedAttribute]
public void set_PackOptions(PackOptions value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public IList`1<TargetFrameworkInformation> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
private void set_TargetFrameworks(IList`1<TargetFrameworkInformation> value);
    [CompilerGeneratedAttribute]
public RuntimeGraph get_RuntimeGraph();
    [CompilerGeneratedAttribute]
public void set_RuntimeGraph(RuntimeGraph value);
    [CompilerGeneratedAttribute]
public ProjectRestoreSettings get_RestoreSettings();
    [CompilerGeneratedAttribute]
public void set_RestoreSettings(ProjectRestoreSettings value);
    [CompilerGeneratedAttribute]
public ProjectRestoreMetadata get_RestoreMetadata();
    [CompilerGeneratedAttribute]
public void set_RestoreMetadata(ProjectRestoreMetadata value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(PackageSpec other);
    public PackageSpec Clone();
    private IDictionary`2<string, IEnumerable`1<string>> CloneScripts(IDictionary`2<string, IEnumerable`1<string>> toBeCloned);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.PackageSpecExtensions : object {
    [ExtensionAttribute]
public static TargetFrameworkInformation GetTargetFramework(PackageSpec project, NuGetFramework targetFramework);
    [ExtensionAttribute]
public static ProjectRestoreMetadataFrameworkInfo GetRestoreMetadataFramework(PackageSpec project, NuGetFramework targetFramework);
}
internal static class NuGet.ProjectModel.PackageSpecOperations : object {
    public static void AddOrUpdateDependency(PackageSpec spec, PackageDependency dependency);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageIdentity identity);
    public static bool HasPackage(PackageSpec spec, string packageId);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageDependency dependency, IEnumerable`1<NuGetFramework> frameworksToAdd);
    public static void AddOrUpdateDependency(PackageSpec spec, PackageIdentity identity, IEnumerable`1<NuGetFramework> frameworksToAdd);
    public static void RemoveDependency(PackageSpec spec, string packageId);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.PackageSpecOperations/<GetDependencyLists>d__6")]
private static IEnumerable`1<IList`1<LibraryDependency>> GetDependencyLists(PackageSpec spec, IEnumerable`1<NuGetFramework> frameworksToConsider, bool includeGenericDependencies);
    [IteratorStateMachineAttribute("NuGet.ProjectModel.PackageSpecOperations/<GetCentralPackageVersionLists>d__7")]
private static IEnumerable`1<IDictionary`2<string, CentralPackageVersion>> GetCentralPackageVersionLists(PackageSpec spec, IEnumerable`1<NuGetFramework> frameworksToConsider);
    private static List`1<LibraryDependency> GetExistingDependencies(PackageSpec spec, string packageId);
    private static void AddOrUpdateDependencyInDependencyList(PackageSpec spec, IList`1<LibraryDependency> list, string packageId, VersionRange range);
    private static void AddDependency(IList`1<LibraryDependency> list, string packageId, VersionRange range, bool centralPackageVersionsEnabled);
}
internal class NuGet.ProjectModel.PackageSpecReferenceDependencyProvider : object {
    private Dictionary`2<string, ExternalProjectReference> _externalProjectsByPath;
    private Dictionary`2<string, ExternalProjectReference> _externalProjectsByUniqueName;
    private bool _useLegacyAssetTargetFallbackBehavior;
    public PackageSpecReferenceDependencyProvider(IEnumerable`1<ExternalProjectReference> externalProjects, ILogger logger);
    internal PackageSpecReferenceDependencyProvider(IEnumerable`1<ExternalProjectReference> externalProjects, IEnvironmentVariableReader environmentVariableReader);
    public sealed virtual bool SupportsType(LibraryDependencyTarget libraryType);
    public sealed virtual Library GetLibrary(LibraryRange libraryRange, NuGetFramework targetFramework);
    private void AddLibraryProperties(Library library, PackageSpec packageSpec, NuGetFramework targetFramework);
    private List`1<LibraryDependency> GetDependenciesFromSpecRestoreMetadata(PackageSpec packageSpec, NuGetFramework targetFramework);
    private List`1<LibraryDependency> GetDependenciesFromExternalReference(ExternalProjectReference externalReference, PackageSpec packageSpec, NuGetFramework targetFramework);
    internal List`1<LibraryDependency> GetSpecDependencies(PackageSpec packageSpec, NuGetFramework targetFramework);
    private bool IsProject(LibraryDependency dependency);
    private List`1<ExternalProjectReference> GetChildReferences(ExternalProjectReference parent);
}
internal static class NuGet.ProjectModel.PackageSpecUtility : object {
    public static NuGetVersion SpecifySnapshot(string version, string snapshotValue);
    public static bool IsSnapshotVersion(string version);
}
internal class NuGet.ProjectModel.PackageSpecWriter : object {
    public static void Write(PackageSpec packageSpec, IObjectWriter writer);
    internal static void Write(PackageSpec packageSpec, IObjectWriter writer, bool hashing, IEnvironmentVariableReader environmentVariableReader);
    public static void WriteToFile(PackageSpec packageSpec, string filePath);
    private static bool IsMetadataValid(ProjectRestoreMetadata msbuildMetadata);
    private static void SetMSBuildMetadata(IObjectWriter writer, PackageSpec packageSpec, IEnvironmentVariableReader environmentVariableReader);
    private static string ApplyMacro(string value, string userSettingsDirectory, bool useMacros);
    private static void WriteMetadataBooleans(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteNuGetLockFileProperties(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteNuGetAuditProperties(IObjectWriter writer, RestoreAuditProperties auditProperties);
    private static void WriteMetadataTargetFrameworks(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataFiles(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void WriteMetadataSources(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    private static void SetWarningProperties(IObjectWriter writer, ProjectRestoreMetadata msbuildMetadata);
    [ObsoleteAttribute]
private static void SetPackOptions(IObjectWriter writer, PackageSpec packageSpec);
    private static void SetDependencies(IObjectWriter writer, IList`1<LibraryDependency> libraryDependencies);
    internal static void SetDependencies(IObjectWriter writer, string name, IEnumerable`1<LibraryDependency> libraryDependencies);
    internal static void SetCentralTransitveDependencyGroup(IObjectWriter writer, string name, IEnumerable`1<LibraryDependency> libraryDependencies);
    private static void SetImports(IObjectWriter writer, IList`1<NuGetFramework> frameworks);
    private static void SetDownloadDependencies(IObjectWriter writer, IList`1<DownloadDependency> downloadDependencies);
    private static void SetFrameworks(IObjectWriter writer, IList`1<TargetFrameworkInformation> frameworks, bool hashing);
    private static NuGetFramework DeconstructFallbackFrameworks(NuGetFramework nuGetFramework);
    private static void SetFrameworkReferences(IObjectWriter writer, ISet`1<FrameworkDependency> frameworkReferences);
    private static void SetCentralDependencies(IObjectWriter writer, ICollection`1<CentralPackageVersion> centralPackageVersions, bool hashing);
    private static void SetValueIfTrue(IObjectWriter writer, string name, bool value);
    private static void SetValueIfNotNull(IObjectWriter writer, string name, string value);
    private static void SetValue(IObjectWriter writer, string name, string value);
    private static void SetArrayValue(IObjectWriter writer, string name, IEnumerable`1<string> values);
    private static void SetDictionaryValue(IObjectWriter writer, string name, IDictionary`2<string, string> values);
    private static void SetDictionaryValues(IObjectWriter writer, string name, IDictionary`2<string, IEnumerable`1<string>> values);
}
internal class NuGet.ProjectModel.PackOptions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageType> <PackageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeExcludeFiles <IncludeExcludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IncludeExcludeFiles> <Mappings>k__BackingField;
    public IReadOnlyList`1<PackageType> PackageType { get; public set; }
    public IncludeExcludeFiles IncludeExcludeFiles { get; public set; }
    public IDictionary`2<string, IncludeExcludeFiles> Mappings { get; public set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageType> get_PackageType();
    [CompilerGeneratedAttribute]
public void set_PackageType(IReadOnlyList`1<PackageType> value);
    [CompilerGeneratedAttribute]
public IncludeExcludeFiles get_IncludeExcludeFiles();
    [CompilerGeneratedAttribute]
public void set_IncludeExcludeFiles(IncludeExcludeFiles value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IncludeExcludeFiles> get_Mappings();
    [CompilerGeneratedAttribute]
public void set_Mappings(IDictionary`2<string, IncludeExcludeFiles> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackOptions other);
    public PackOptions Clone();
}
internal class NuGet.ProjectModel.ProjectFileDependencyGroup : object {
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Dependencies>k__BackingField;
    public string FrameworkName { get; }
    public IEnumerable`1<string> Dependencies { get; }
    public ProjectFileDependencyGroup(string frameworkName, IEnumerable`1<string> dependencies);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Dependencies();
    public sealed virtual bool Equals(ProjectFileDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.ProjectModel.ProjectLockFile.LockFileDependencyComparerWithoutContentHash : object {
    [CompilerGeneratedAttribute]
private static LockFileDependencyComparerWithoutContentHash <Default>k__BackingField;
    public static LockFileDependencyComparerWithoutContentHash Default { get; }
    private static LockFileDependencyComparerWithoutContentHash();
    [CompilerGeneratedAttribute]
public static LockFileDependencyComparerWithoutContentHash get_Default();
    public sealed virtual bool Equals(LockFileDependency x, LockFileDependency y);
    public sealed virtual int GetHashCode(LockFileDependency obj);
}
internal class NuGet.ProjectModel.ProjectRestoreMetadata : object {
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectJsonPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageSource> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <FallbackFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ConfigFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreMetadataFrameworkInfo> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <OriginalTargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CrossTargeting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyPackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreMetadataFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateRuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipContentFileWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningProperties <ProjectWideWarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreLockProperties <RestoreLockProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageVersionsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageVersionOverrideDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageFloatingVersionsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CentralPackageTransitivePinningEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreAuditProperties <RestoreAuditProperties>k__BackingField;
    public ProjectStyle ProjectStyle { get; public set; }
    public string ProjectPath { get; public set; }
    public string ProjectJsonPath { get; public set; }
    public string OutputPath { get; public set; }
    public string ProjectName { get; public set; }
    public string ProjectUniqueName { get; public set; }
    public IList`1<PackageSource> Sources { get; public set; }
    public string PackagesPath { get; public set; }
    public string CacheFilePath { get; public set; }
    public IList`1<string> FallbackFolders { get; public set; }
    public IList`1<string> ConfigFilePaths { get; public set; }
    public IList`1<ProjectRestoreMetadataFrameworkInfo> TargetFrameworks { get; public set; }
    public IList`1<string> OriginalTargetFrameworks { get; public set; }
    public bool CrossTargeting { get; public set; }
    public bool LegacyPackagesDirectory { get; public set; }
    public IList`1<ProjectRestoreMetadataFile> Files { get; public set; }
    public bool ValidateRuntimeAssets { get; public set; }
    public bool SkipContentFileWrite { get; public set; }
    public WarningProperties ProjectWideWarningProperties { get; public set; }
    public RestoreLockProperties RestoreLockProperties { get; public set; }
    public bool CentralPackageVersionsEnabled { get; public set; }
    public bool CentralPackageVersionOverrideDisabled { get; public set; }
    public bool CentralPackageFloatingVersionsEnabled { get; public set; }
    public bool CentralPackageTransitivePinningEnabled { get; public set; }
    public RestoreAuditProperties RestoreAuditProperties { get; public set; }
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
public void set_ProjectStyle(ProjectStyle value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectJsonPath();
    [CompilerGeneratedAttribute]
public void set_ProjectJsonPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectUniqueName();
    [CompilerGeneratedAttribute]
public void set_ProjectUniqueName(string value);
    [CompilerGeneratedAttribute]
public IList`1<PackageSource> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(IList`1<PackageSource> value);
    [CompilerGeneratedAttribute]
public string get_PackagesPath();
    [CompilerGeneratedAttribute]
public void set_PackagesPath(string value);
    [CompilerGeneratedAttribute]
public string get_CacheFilePath();
    [CompilerGeneratedAttribute]
public void set_CacheFilePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_FallbackFolders();
    [CompilerGeneratedAttribute]
public void set_FallbackFolders(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ConfigFilePaths();
    [CompilerGeneratedAttribute]
public void set_ConfigFilePaths(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreMetadataFrameworkInfo> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<ProjectRestoreMetadataFrameworkInfo> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_OriginalTargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_OriginalTargetFrameworks(IList`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_CrossTargeting();
    [CompilerGeneratedAttribute]
public void set_CrossTargeting(bool value);
    [CompilerGeneratedAttribute]
public bool get_LegacyPackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_LegacyPackagesDirectory(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreMetadataFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<ProjectRestoreMetadataFile> value);
    [CompilerGeneratedAttribute]
public bool get_ValidateRuntimeAssets();
    [CompilerGeneratedAttribute]
public void set_ValidateRuntimeAssets(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipContentFileWrite();
    [CompilerGeneratedAttribute]
public void set_SkipContentFileWrite(bool value);
    [CompilerGeneratedAttribute]
public WarningProperties get_ProjectWideWarningProperties();
    [CompilerGeneratedAttribute]
public void set_ProjectWideWarningProperties(WarningProperties value);
    [CompilerGeneratedAttribute]
public RestoreLockProperties get_RestoreLockProperties();
    [CompilerGeneratedAttribute]
public void set_RestoreLockProperties(RestoreLockProperties value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageVersionsEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageVersionsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageVersionOverrideDisabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageVersionOverrideDisabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageFloatingVersionsEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageFloatingVersionsEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CentralPackageTransitivePinningEnabled();
    [CompilerGeneratedAttribute]
public void set_CentralPackageTransitivePinningEnabled(bool value);
    [CompilerGeneratedAttribute]
public RestoreAuditProperties get_RestoreAuditProperties();
    [CompilerGeneratedAttribute]
public void set_RestoreAuditProperties(RestoreAuditProperties value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectRestoreMetadata other);
    private HashSet`1<string> GetSources(IList`1<PackageSource> sources);
    public virtual ProjectRestoreMetadata Clone();
    protected void FillClone(ProjectRestoreMetadata clone);
}
internal class NuGet.ProjectModel.ProjectRestoreMetadataFile : object {
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AbsolutePath>k__BackingField;
    public string PackagePath { get; }
    public string AbsolutePath { get; }
    public ProjectRestoreMetadataFile(string packagePath, string absolutePath);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public string get_AbsolutePath();
    public sealed virtual bool Equals(ProjectRestoreMetadataFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(ProjectRestoreMetadataFile other);
    public ProjectRestoreMetadataFile Clone();
}
internal class NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo : object {
    [CompilerGeneratedAttribute]
private string <TargetAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectRestoreReference> <ProjectReferences>k__BackingField;
    public string TargetAlias { get; public set; }
    public NuGetFramework FrameworkName { get; public set; }
    public IList`1<ProjectRestoreReference> ProjectReferences { get; public set; }
    public ProjectRestoreMetadataFrameworkInfo(NuGetFramework frameworkName);
    [CompilerGeneratedAttribute]
public string get_TargetAlias();
    [CompilerGeneratedAttribute]
public void set_TargetAlias(string value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectRestoreReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ProjectReferences(IList`1<ProjectRestoreReference> value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectRestoreMetadataFrameworkInfo other);
    public ProjectRestoreMetadataFrameworkInfo Clone();
}
internal class NuGet.ProjectModel.ProjectRestoreReference : object {
    [CompilerGeneratedAttribute]
private string <ProjectUniqueName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <IncludeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <ExcludeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <PrivateAssets>k__BackingField;
    public string ProjectUniqueName { get; public set; }
    public string ProjectPath { get; public set; }
    public LibraryIncludeFlags IncludeAssets { get; public set; }
    public LibraryIncludeFlags ExcludeAssets { get; public set; }
    public LibraryIncludeFlags PrivateAssets { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProjectUniqueName();
    [CompilerGeneratedAttribute]
public void set_ProjectUniqueName(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_IncludeAssets();
    [CompilerGeneratedAttribute]
public void set_IncludeAssets(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_ExcludeAssets();
    [CompilerGeneratedAttribute]
public void set_ExcludeAssets(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_PrivateAssets();
    [CompilerGeneratedAttribute]
public void set_PrivateAssets(LibraryIncludeFlags value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(ProjectRestoreReference other);
    public ProjectRestoreReference Clone();
}
internal class NuGet.ProjectModel.ProjectRestoreSettings : object {
    [CompilerGeneratedAttribute]
private bool <HideWarningsAndErrors>k__BackingField;
    public bool HideWarningsAndErrors { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HideWarningsAndErrors();
    [CompilerGeneratedAttribute]
public void set_HideWarningsAndErrors(bool value);
    public ProjectRestoreSettings Clone();
    public virtual bool Equals(object obj);
    public bool Equals(ProjectRestoreSettings other);
    public virtual int GetHashCode();
}
internal enum NuGet.ProjectModel.ProjectStyle : Enum {
    public ushort value__;
    public static ProjectStyle Unknown;
    public static ProjectStyle ProjectJson;
    public static ProjectStyle PackageReference;
    public static ProjectStyle DotnetCliTool;
    public static ProjectStyle Standalone;
    public static ProjectStyle PackagesConfig;
    public static ProjectStyle DotnetToolReference;
}
[NuGet.ProjectModel.NullableContextAttribute("2")]
[NuGet.ProjectModel.NullableAttribute("0")]
internal class NuGet.ProjectModel.RestoreAuditProperties : object {
    [CompilerGeneratedAttribute]
private string <EnableAudit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuditLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuditMode>k__BackingField;
    [NuGet.ProjectModel.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private HashSet`1<string> <SuppressedAdvisories>k__BackingField;
    public string EnableAudit { get; public set; }
    public string AuditLevel { get; public set; }
    public string AuditMode { get; public set; }
    [NuGet.ProjectModel.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashSet`1<string> SuppressedAdvisories { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EnableAudit();
    [CompilerGeneratedAttribute]
public void set_EnableAudit(string value);
    [CompilerGeneratedAttribute]
public string get_AuditLevel();
    [CompilerGeneratedAttribute]
public void set_AuditLevel(string value);
    [CompilerGeneratedAttribute]
public string get_AuditMode();
    [CompilerGeneratedAttribute]
public void set_AuditMode(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_SuppressedAdvisories();
    [CompilerGeneratedAttribute]
public void set_SuppressedAdvisories(HashSet`1<string> value);
    public bool TryParseEnableAudit(Boolean& result);
    public bool TryParseAuditLevel(PackageVulnerabilitySeverity& result);
    public sealed virtual bool Equals(RestoreAuditProperties other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RestoreAuditProperties x, RestoreAuditProperties y);
    public static bool op_Inequality(RestoreAuditProperties x, RestoreAuditProperties y);
    public virtual int GetHashCode();
    [NuGet.ProjectModel.NullableContextAttribute("1")]
internal RestoreAuditProperties Clone();
}
internal class NuGet.ProjectModel.RestoreLockProperties : object {
    [CompilerGeneratedAttribute]
private string <RestorePackagesWithLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuGetLockFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestoreLockedMode>k__BackingField;
    public string RestorePackagesWithLockFile { get; }
    public string NuGetLockFilePath { get; }
    public bool RestoreLockedMode { get; }
    public RestoreLockProperties(string restorePackagesWithLockFile, string nuGetLockFilePath, bool restoreLockedMode);
    [CompilerGeneratedAttribute]
public string get_RestorePackagesWithLockFile();
    [CompilerGeneratedAttribute]
public string get_NuGetLockFilePath();
    [CompilerGeneratedAttribute]
public bool get_RestoreLockedMode();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RestoreLockProperties other);
    public RestoreLockProperties Clone();
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.StringExtensions : object {
    [NuGet.ProjectModel.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ValueTuple`2<string, string> SplitInTwo(string s, char separator);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.ProjectModel.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string InvalidDependencyTarget { get; }
    internal static string InvalidPackageType { get; }
    internal static string Log_ErrorReadingLockFile { get; }
    internal static string Log_ErrorReadingProjectJson { get; }
    internal static string Log_ErrorReadingProjectJsonWithLocation { get; }
    internal static string Log_InvalidImportFramework { get; }
    internal static string Log_ProblemReadingCacheFile { get; }
    internal static string MissingVersionOnDependency { get; }
    internal static string MissingVersionOnTool { get; }
    internal static string None { get; }
    internal static string PackagesLockFile_CentralPackageVersionRemoved { get; }
    internal static string PackagesLockFile_IncompatibleLockFileVersion { get; }
    internal static string PackagesLockFile_MismatchedTargetFrameworks { get; }
    internal static string PackagesLockFile_NewTargetFramework { get; }
    internal static string PackagesLockFile_PackageReferenceAdded { get; }
    internal static string PackagesLockFile_PackageReferencesHaveChanged { get; }
    internal static string PackagesLockFile_PackageReferenceVersionChanged { get; }
    internal static string PackagesLockFile_ProjectReferenceAdded { get; }
    internal static string PackagesLockFile_ProjectReferenceDependenciesHasChanged { get; }
    internal static string PackagesLockFile_ProjectReferenceHasNoCompatibleTargetFramework { get; }
    internal static string PackagesLockFile_ProjectReferencesHasChange { get; }
    internal static string PackagesLockFile_ProjectTransitiveDependencyChanged { get; }
    internal static string PackagesLockFile_ProjectTransitiveDependencyVersionChanged { get; }
    internal static string PackagesLockFile_RestoreMetadataMissingTfms { get; }
    internal static string PackagesLockFile_RuntimeIdentifiersChanged { get; }
    internal static string PackagesLockFile_UnableToLoadPackagespec { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_InvalidDependencyTarget();
    internal static string get_InvalidPackageType();
    internal static string get_Log_ErrorReadingLockFile();
    internal static string get_Log_ErrorReadingProjectJson();
    internal static string get_Log_ErrorReadingProjectJsonWithLocation();
    internal static string get_Log_InvalidImportFramework();
    internal static string get_Log_ProblemReadingCacheFile();
    internal static string get_MissingVersionOnDependency();
    internal static string get_MissingVersionOnTool();
    internal static string get_None();
    internal static string get_PackagesLockFile_CentralPackageVersionRemoved();
    internal static string get_PackagesLockFile_IncompatibleLockFileVersion();
    internal static string get_PackagesLockFile_MismatchedTargetFrameworks();
    internal static string get_PackagesLockFile_NewTargetFramework();
    internal static string get_PackagesLockFile_PackageReferenceAdded();
    internal static string get_PackagesLockFile_PackageReferencesHaveChanged();
    internal static string get_PackagesLockFile_PackageReferenceVersionChanged();
    internal static string get_PackagesLockFile_ProjectReferenceAdded();
    internal static string get_PackagesLockFile_ProjectReferenceDependenciesHasChanged();
    internal static string get_PackagesLockFile_ProjectReferenceHasNoCompatibleTargetFramework();
    internal static string get_PackagesLockFile_ProjectReferencesHasChange();
    internal static string get_PackagesLockFile_ProjectTransitiveDependencyChanged();
    internal static string get_PackagesLockFile_ProjectTransitiveDependencyVersionChanged();
    internal static string get_PackagesLockFile_RestoreMetadataMissingTfms();
    internal static string get_PackagesLockFile_RuntimeIdentifiersChanged();
    internal static string get_PackagesLockFile_UnableToLoadPackagespec();
}
internal class NuGet.ProjectModel.TargetFrameworkInformation : object {
    [CompilerGeneratedAttribute]
private string <TargetAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssetTargetFallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Warn>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DownloadDependency> <DownloadDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, CentralPackageVersion> <CentralPackageVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<FrameworkDependency> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifierGraphPath>k__BackingField;
    public string TargetAlias { get; public set; }
    public NuGetFramework FrameworkName { get; public set; }
    public IList`1<LibraryDependency> Dependencies { get; public set; }
    public IList`1<NuGetFramework> Imports { get; public set; }
    public bool AssetTargetFallback { get; public set; }
    public bool Warn { get; public set; }
    public IList`1<DownloadDependency> DownloadDependencies { get; }
    public IDictionary`2<string, CentralPackageVersion> CentralPackageVersions { get; }
    public ISet`1<FrameworkDependency> FrameworkReferences { get; }
    public string RuntimeIdentifierGraphPath { get; public set; }
    internal TargetFrameworkInformation(TargetFrameworkInformation cloneFrom);
    [CompilerGeneratedAttribute]
public string get_TargetAlias();
    [CompilerGeneratedAttribute]
public void set_TargetAlias(string value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryDependency> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_Imports();
    [CompilerGeneratedAttribute]
public void set_Imports(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public bool get_AssetTargetFallback();
    [CompilerGeneratedAttribute]
public void set_AssetTargetFallback(bool value);
    [CompilerGeneratedAttribute]
public bool get_Warn();
    [CompilerGeneratedAttribute]
public void set_Warn(bool value);
    [CompilerGeneratedAttribute]
public IList`1<DownloadDependency> get_DownloadDependencies();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, CentralPackageVersion> get_CentralPackageVersions();
    [CompilerGeneratedAttribute]
public ISet`1<FrameworkDependency> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifierGraphPath();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifierGraphPath(string value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TargetFrameworkInformation other);
    public TargetFrameworkInformation Clone();
    [CompilerGeneratedAttribute]
internal static IList`1<T> <.ctor>g__CloneList|38_1(IList`1<T> source, Func`2<T, T> cloneFunc);
}
internal class NuGet.ProjectModel.ToolPathResolver : object {
    private string _packagesDirectory;
    private bool _isLowercase;
    public ToolPathResolver(string packagesDirectory);
    public ToolPathResolver(string packagesDirectory, bool isLowercase);
    public string GetLockFilePath(string toolDirectory);
    public string GetLockFilePath(string packageId, NuGetVersion version, NuGetFramework framework);
    public string GetToolDirectoryPath(string packageId, NuGetVersion version, NuGetFramework framework);
    private string GetPackagesToolsBasePath();
    public string GetBestToolDirectoryPath(string packageId, VersionRange versionRange, NuGetFramework framework);
    private IEnumerable`1<NuGetVersion> GetAvailableToolVersions(string packageId);
}
[ExtensionAttribute]
internal static class NuGet.ProjectModel.Utf8JsonReaderExtensions : object {
    internal static Utf8JsonStreamLockFileConverter LockFileConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileItem> LockFileItemConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileContentFile> LockFileContentFileConverter;
    internal static Utf8JsonStreamLockFileItemConverter`1<LockFileRuntimeTarget> LockFileRuntimeTargetConverter;
    internal static Utf8JsonStreamLockFileTargetLibraryConverter LockFileTargetLibraryConverter;
    internal static Utf8JsonStreamLockFileLibraryConverter LockFileLibraryConverter;
    internal static Utf8JsonStreamLockFileTargetConverter LockFileTargetConverter;
    internal static Utf8JsonStreamProjectFileDependencyGroupConverter ProjectFileDepencencyGroupConverter;
    internal static Utf8JsonStreamIAssetsLogMessageConverter IAssetsLogMessageConverter;
    private static Utf8JsonReaderExtensions();
    [ExtensionAttribute]
internal static string ReadTokenAsString(Utf8JsonReader& reader);
    [ExtensionAttribute]
private static string ReadNumberAsString(Utf8JsonReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamIAssetsLogMessageConverter : object {
    private static Byte[] LevelPropertyName;
    private static Byte[] CodePropertyName;
    private static Byte[] WarningLevelPropertyName;
    private static Byte[] FilePathPropertyName;
    private static Byte[] StartLineNumberPropertyName;
    private static Byte[] StartColumnNumberPropertyName;
    private static Byte[] EndLineNumberPropertyName;
    private static Byte[] EndColumnNumberPropertyName;
    private static Byte[] MessagePropertyName;
    private static Byte[] LibraryIdPropertyName;
    private static Byte[] TargetGraphsPropertyName;
    private static Utf8JsonStreamIAssetsLogMessageConverter();
    public sealed virtual IAssetsLogMessage Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileConverter : object {
    private static Byte[] VersionPropertyName;
    private static Byte[] LibrariesPropertyName;
    private static Byte[] TargetsPropertyName;
    private static Byte[] ProjectFileDependencyGroupsPropertyName;
    private static Byte[] PackageFoldersPropertyName;
    private static Byte[] ProjectPropertyName;
    private static Byte[] CentralTransitiveDependencyGroupsPropertyName;
    private static Byte[] LogsPropertyName;
    private static Utf8JsonStreamLockFileConverter();
    public sealed virtual LockFile Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileItemConverter`1 : object {
    private Func`2<string, T> _lockFileItemCreator;
    public Utf8JsonStreamLockFileItemConverter`1(Func`2<string, T> lockFileItemCreator);
    public sealed virtual T Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileLibraryConverter : object {
    private static Byte[] Sha512PropertyName;
    private static Byte[] TypePropertyName;
    private static Byte[] PathPropertyName;
    private static Byte[] MsbuildProjectPropertyName;
    private static Byte[] ServicablePropertyName;
    private static Byte[] HasToolsPropertyName;
    private static Byte[] FilesPropertyName;
    private static Utf8JsonStreamLockFileLibraryConverter();
    public sealed virtual LockFileLibrary Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileTargetConverter : object {
    public sealed virtual LockFileTarget Read(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamLockFileTargetLibraryConverter : object {
    private static Byte[] TypePropertyName;
    private static Byte[] FrameworkPropertyName;
    private static Byte[] DependenciesPropertyName;
    private static Byte[] FrameworkAssembliesPropertyName;
    private static Byte[] RuntimePropertyName;
    private static Byte[] CompilePropertyName;
    private static Byte[] ResourcePropertyName;
    private static Byte[] NativePropertyName;
    private static Byte[] BuildPropertyName;
    private static Byte[] BuildMultiTargetingPropertyName;
    private static Byte[] ContentFilesPropertyName;
    private static Byte[] RuntimeTargetsPropertyName;
    private static Byte[] ToolsPropertyName;
    private static Byte[] EmbedPropertyName;
    private static Byte[] FrameworkReferencesPropertyName;
    private static Utf8JsonStreamLockFileTargetLibraryConverter();
    public sealed virtual LockFileTargetLibrary Read(Utf8JsonStreamReader& reader);
    private IList`1<PackageDependency> ReadPackageDependencyList(Utf8JsonStreamReader& reader);
}
internal class NuGet.ProjectModel.Utf8JsonStreamProjectFileDependencyGroupConverter : object {
    public sealed virtual ProjectFileDependencyGroup Read(Utf8JsonStreamReader& reader);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.ProjectModel1175159.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.ProjectModel.Utf8JsonStreamReader : ValueType {
    private static Char[] DelimitedStringDelimiters;
    private static Byte[] Utf8Bom;
    private static JsonReaderOptions DefaultJsonReaderOptions;
    private static int BufferSizeDefault;
    private static int MinBufferSize;
    private Utf8JsonReader _reader;
    private Stream _stream;
    private Byte[] _buffer;
    private bool _disposed;
    private System.Buffers1624809.ArrayPool`1<byte> _bufferPool;
    private int _bufferUsed;
    internal bool IsFinalBlock { get; }
    internal JsonTokenType TokenType { get; }
    internal Utf8JsonStreamReader(Stream stream, int bufferSize, System.Buffers1624809.ArrayPool`1<byte> arrayPool);
    private static Utf8JsonStreamReader();
    internal bool get_IsFinalBlock();
    internal JsonTokenType get_TokenType();
    internal bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    internal bool TryGetInt32(Int32& value);
    internal string GetString();
    internal bool GetBoolean();
    internal int GetInt32();
    internal bool Read();
    internal void Skip();
    internal IList`1<T> ReadObjectAsList(IUtf8JsonStreamReaderConverter`1<T> streamReaderConverter);
    internal IList`1<T> ReadListOfObjects(IUtf8JsonStreamReaderConverter`1<T> streamReaderConverter);
    internal string ReadNextTokenAsString();
    internal IList`1<string> ReadStringArrayAsIList(IList`1<string> strings);
    internal IReadOnlyList`1<string> ReadDelimitedString();
    internal bool ReadNextTokenAsBoolOrFalse();
    internal IReadOnlyList`1<string> ReadNextStringOrArrayOfStringsAsReadOnlyList();
    internal IReadOnlyList`1<string> ReadStringArrayAsReadOnlyListFromArrayStart();
    private void GetMoreBytesFromStream();
    private void ReadStreamIntoBuffer(JsonReaderState jsonReaderState);
    public void Dispose();
    private void ThrowExceptionIfDisposed();
}
internal class NuGet.ProjectModel.WarningProperties : object {
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllWarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetLogCode> <WarningsNotAsErrors>k__BackingField;
    public ISet`1<NuGetLogCode> WarningsAsErrors { get; }
    public ISet`1<NuGetLogCode> NoWarn { get; }
    public bool AllWarningsAsErrors { get; public set; }
    public ISet`1<NuGetLogCode> WarningsNotAsErrors { get; }
    [ObsoleteAttribute("Use the constructor with 4 instead.")]
public WarningProperties(ISet`1<NuGetLogCode> warningsAsErrors, ISet`1<NuGetLogCode> noWarn, bool allWarningsAsErrors);
    public WarningProperties(ISet`1<NuGetLogCode> warningsAsErrors, ISet`1<NuGetLogCode> noWarn, bool allWarningsAsErrors, ISet`1<NuGetLogCode> warningsNotAsErrors);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_NoWarn();
    [CompilerGeneratedAttribute]
public bool get_AllWarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_AllWarningsAsErrors(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetLogCode> get_WarningsNotAsErrors();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WarningProperties other);
    public WarningProperties Clone();
    public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, string warningsAsErrors, string noWarn, string warningsNotAsErrors);
    [ObsoleteAttribute]
public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, string warningsAsErrors, string noWarn);
    public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, IEnumerable`1<NuGetLogCode> warningsAsErrors, IEnumerable`1<NuGetLogCode> noWarn, IEnumerable`1<NuGetLogCode> warningsNotAsErrors);
    [ObsoleteAttribute]
public static WarningProperties GetWarningProperties(string treatWarningsAsErrors, IEnumerable`1<NuGetLogCode> warningsAsErrors, IEnumerable`1<NuGetLogCode> noWarn);
}
internal class NuGet.Protocol.AlternatePackageMetadata : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [JsonPropertyAttribute]
public string PackageId { get; internal set; }
    [JsonPropertyAttribute]
public VersionRange Range { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
internal void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
internal void set_Range(VersionRange value);
}
internal class NuGet.Protocol.AmbientAuthenticationState : object {
    internal static int MaxAuthRetries;
    [CompilerGeneratedAttribute]
private bool <IsBlocked>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AuthenticationRetriesCount>k__BackingField;
    public bool IsBlocked { get; private set; }
    public int AuthenticationRetriesCount { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsBlocked();
    [CompilerGeneratedAttribute]
private void set_IsBlocked(bool value);
    [CompilerGeneratedAttribute]
public int get_AuthenticationRetriesCount();
    [CompilerGeneratedAttribute]
private void set_AuthenticationRetriesCount(int value);
    public void Block();
    public void Increment();
}
internal class NuGet.Protocol.AutoCompleteResourceV2Feed : AutoCompleteResource {
    private HttpSource _httpSource;
    private Uri _baseUri;
    public AutoCompleteResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<IdStartsWith>d__3")]
public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<VersionStartsWith>d__4")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<GetResults>d__5")]
private Task`1<IEnumerable`1<string>> GetResults(Uri apiEndpointUri, ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.AutoCompleteResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.AutoCompleteResourceV3 : AutoCompleteResource {
    private RegistrationResourceV3 _regResource;
    private ServiceIndexResourceV3 _serviceIndex;
    private HttpSource _client;
    public AutoCompleteResourceV3(HttpSource client, ServiceIndexResourceV3 serviceIndex, RegistrationResourceV3 regResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3/<IdStartsWith>d__4")]
public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3/<VersionStartsWith>d__5")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.AutoCompleteResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.CachingSourceProvider : object {
    private IPackageSourceProvider _packageSourceProvider;
    private List`1<Lazy`1<INuGetResourceProvider>> _resourceProviders;
    private List`1<SourceRepository> _repositories;
    private ConcurrentDictionary`2<string, SourceRepository> _cachedSources;
    public IPackageSourceProvider PackageSourceProvider { get; }
    public CachingSourceProvider(IPackageSourceProvider packageSourceProvider);
    public sealed virtual IEnumerable`1<SourceRepository> GetRepositories();
    public SourceRepository CreateRepository(string source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public void AddSourceRepository(SourceRepository source);
    public sealed virtual IPackageSourceProvider get_PackageSourceProvider();
}
internal static class NuGet.Protocol.CachingUtility : object {
    public static int BufferSize;
    private static int HashLength;
    public static string ComputeHash(string value, bool addIdentifiableCharacters);
    public static Stream ReadCacheFile(TimeSpan maxAge, string cacheFile);
    public static bool IsFileAlreadyOpen(string filePath);
    public static string RemoveInvalidFileNameChars(string value);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NuGet.Protocol.Converters.PackageVulnerabilityInfoConverter : JsonConverter`1<PackageVulnerabilityInfo> {
    public virtual PackageVulnerabilityInfo ReadJson(JsonReader reader, Type objectType, PackageVulnerabilityInfo existingValue, bool hasExistingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, PackageVulnerabilityInfo value, JsonSerializer serializer);
}
internal class NuGet.Protocol.Converters.V3SearchResultsConverter : JsonConverter {
    private UInt32 _take;
    public bool CanWrite { get; }
    public V3SearchResultsConverter(UInt32 take);
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NuGet.Protocol.Converters.VersionRangeStjConverter : JsonConverter`1<VersionRange> {
    public virtual VersionRange Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, VersionRange value, JsonSerializerOptions options);
}
internal abstract class NuGet.Protocol.Core.Types.AutoCompleteResource : object {
    public abstract virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
internal abstract class NuGet.Protocol.Core.Types.DependencyInfoResource : object {
    public abstract virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> ResolvePackages(string packageId, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
internal abstract class NuGet.Protocol.Core.Types.DownloadResource : object {
    public abstract virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.Core.Types.DownloadResourceResult : object {
    private bool _isDisposed;
    private Stream _stream;
    private PackageReaderBase _packageReader;
    private string _packageSource;
    [CompilerGeneratedAttribute]
private DownloadResourceResultStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SignatureVerified>k__BackingField;
    public DownloadResourceResultStatus Status { get; }
    public bool SignatureVerified { get; public set; }
    public Stream PackageStream { get; }
    public string PackageSource { get; }
    public PackageReaderBase PackageReader { get; }
    public DownloadResourceResult(DownloadResourceResultStatus status);
    public DownloadResourceResult(Stream stream, string source);
    public DownloadResourceResult(Stream stream, PackageReaderBase packageReader, string source);
    public DownloadResourceResult(PackageReaderBase packageReader, string source);
    [CompilerGeneratedAttribute]
public DownloadResourceResultStatus get_Status();
    [CompilerGeneratedAttribute]
public bool get_SignatureVerified();
    [CompilerGeneratedAttribute]
public void set_SignatureVerified(bool value);
    public Stream get_PackageStream();
    public string get_PackageSource();
    public PackageReaderBase get_PackageReader();
    public sealed virtual void Dispose();
}
internal enum NuGet.Protocol.Core.Types.DownloadResourceResultStatus : Enum {
    public int value__;
    public static DownloadResourceResultStatus Available;
    public static DownloadResourceResultStatus AvailableWithoutStream;
    public static DownloadResourceResultStatus NotFound;
    public static DownloadResourceResultStatus Cancelled;
}
internal class NuGet.Protocol.Core.Types.FatalProtocolException : NuGetProtocolException {
    public FatalProtocolException(string message);
    public FatalProtocolException(string message, Exception innerException);
    protected FatalProtocolException(SerializationInfo info, StreamingContext context);
}
internal class NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FrameworkSpecificGroup> <FrameworkReferenceGroups>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public IReadOnlyList`1<PackageDependencyGroup> DependencyGroups { get; }
    public IReadOnlyList`1<FrameworkSpecificGroup> FrameworkReferenceGroups { get; }
    public FindPackageByIdDependencyInfo(PackageIdentity packageIdentity, IEnumerable`1<PackageDependencyGroup> dependencyGroups, IEnumerable`1<FrameworkSpecificGroup> frameworkReferenceGroups);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FrameworkSpecificGroup> get_FrameworkReferenceGroups();
}
internal abstract class NuGet.Protocol.Core.Types.FindPackageByIdResource : object {
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    protected static FindPackageByIdDependencyInfo GetDependencyInfo(NuspecReader reader);
}
internal abstract class NuGet.Protocol.Core.Types.HttpHandlerResource : object {
    public HttpClientHandler ClientHandler { get; }
    public HttpMessageHandler MessageHandler { get; }
    public abstract virtual HttpClientHandler get_ClientHandler();
    public abstract virtual HttpMessageHandler get_MessageHandler();
}
internal class NuGet.Protocol.Core.Types.HttpSourceCacheContext : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootTempFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCacheContext <SourceCacheContext>k__BackingField;
    public TimeSpan MaxAge { get; }
    public bool DirectDownload { get; }
    public string RootTempFolder { get; }
    public SourceCacheContext SourceCacheContext { get; }
    private HttpSourceCacheContext(string rootTempFolder, TimeSpan maxAge, bool directDownload, SourceCacheContext cacheContext);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public string get_RootTempFolder();
    [CompilerGeneratedAttribute]
public SourceCacheContext get_SourceCacheContext();
    public static HttpSourceCacheContext Create(SourceCacheContext cacheContext, int retryCount);
    public static HttpSourceCacheContext Create(SourceCacheContext cacheContext, bool isFirstAttempt);
}
internal interface NuGet.Protocol.Core.Types.ILegacyFeedCapabilityResource {
    public abstract virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
}
internal interface NuGet.Protocol.Core.Types.INuGetResource {
}
[NuGet.Protocol.NullableContextAttribute("1")]
internal interface NuGet.Protocol.Core.Types.INuGetResourceProvider {
    public Type ResourceType { get; }
    public string Name { get; }
    public IEnumerable`1<string> Before { get; }
    public IEnumerable`1<string> After { get; }
    public abstract virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    public abstract virtual Type get_ResourceType();
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<string> get_Before();
    public abstract virtual IEnumerable`1<string> get_After();
}
internal interface NuGet.Protocol.Core.Types.IPackageSearchMetadata {
    public string Authors { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    public string Description { get; }
    public Nullable`1<long> DownloadCount { get; }
    public Uri IconUrl { get; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; }
    public Uri PackageDetailsUrl { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; }
    public bool RequireLicenseAcceptance { get; }
    public string Summary { get; }
    public string Tags { get; }
    public string Title { get; }
    public bool IsListed { get; }
    public bool PrefixReserved { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public abstract virtual string get_Authors();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    public abstract virtual string get_Description();
    public abstract virtual Nullable`1<long> get_DownloadCount();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual PackageIdentity get_Identity();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual Uri get_ReadmeUrl();
    public abstract virtual Uri get_ReportAbuseUrl();
    public abstract virtual Uri get_PackageDetailsUrl();
    public abstract virtual Nullable`1<DateTimeOffset> get_Published();
    public abstract virtual IReadOnlyList`1<string> get_OwnersList();
    public abstract virtual string get_Owners();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual string get_Summary();
    public abstract virtual string get_Tags();
    public abstract virtual string get_Title();
    public abstract virtual bool get_IsListed();
    public abstract virtual bool get_PrefixReserved();
    public abstract virtual LicenseMetadata get_LicenseMetadata();
    public abstract virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    public abstract virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    public abstract virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
}
internal interface NuGet.Protocol.Core.Types.ISourceRepositoryProvider {
    public IPackageSourceProvider PackageSourceProvider { get; }
    public abstract virtual IEnumerable`1<SourceRepository> GetRepositories();
    public abstract virtual SourceRepository CreateRepository(PackageSource source);
    public abstract virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public abstract virtual IPackageSourceProvider get_PackageSourceProvider();
}
internal abstract class NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource : object {
    public abstract virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
}
internal abstract class NuGet.Protocol.Core.Types.ListResource : object {
    public string Source { get; }
    public abstract virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger log, CancellationToken token);
    public abstract virtual string get_Source();
}
internal abstract class NuGet.Protocol.Core.Types.MetadataResource : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<GetVersions>d__0")]
public Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<Exists>d__2")]
public Task`1<bool> Exists(PackageIdentity identity, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<Exists>d__4")]
public Task`1<bool> Exists(string packageId, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.MetadataResource/<GetLatestVersion>d__7")]
public Task`1<NuGetVersion> GetLatestVersion(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
internal abstract class NuGet.Protocol.Core.Types.NuGetProtocolException : Exception {
    public NuGetProtocolException(string message);
    public NuGetProtocolException(string message, Exception innerException);
    protected NuGetProtocolException(SerializationInfo info, StreamingContext context);
}
internal class NuGet.Protocol.Core.Types.NuGetResourceProviderPositions : object {
    public static string First;
    public static string Last;
}
internal static class NuGet.Protocol.Core.Types.NuGetTestMode : object {
    private static string _testModeEnvironmentVariableName;
    public static string NuGetTestClientName;
    [CompilerGeneratedAttribute]
private static bool <Enabled>k__BackingField;
    public static bool Enabled { get; private set; }
    private static NuGetTestMode();
    [CompilerGeneratedAttribute]
public static bool get_Enabled();
    [CompilerGeneratedAttribute]
private static void set_Enabled(bool value);
    private static bool FromEnvironmentVariable();
    public static T InvokeTestFunctionAgainstTestMode(Func`1<T> function, bool testModeEnabled);
}
internal class NuGet.Protocol.Core.Types.NullSourceCacheContext : SourceCacheContext {
    private static SourceCacheContext _instance;
    public static SourceCacheContext Instance { get; }
    public string GeneratedTempFolder { get; }
    public static SourceCacheContext get_Instance();
    public virtual string get_GeneratedTempFolder();
    public virtual SourceCacheContext WithRefreshCacheTrue();
    public virtual SourceCacheContext Clone();
}
internal class NuGet.Protocol.Core.Types.OfflineFeedAddContext : object {
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfSourcePackageIsInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfPackageExistsAndInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfPackageExists>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageExtractionContext <ExtractionContext>k__BackingField;
    public string PackagePath { get; }
    public string Source { get; }
    public ILogger Logger { get; }
    public bool ThrowIfSourcePackageIsInvalid { get; }
    public bool ThrowIfPackageExistsAndInvalid { get; }
    public bool ThrowIfPackageExists { get; }
    public PackageExtractionContext ExtractionContext { get; }
    public OfflineFeedAddContext(string packagePath, string source, ILogger logger, bool throwIfSourcePackageIsInvalid, bool throwIfPackageExistsAndInvalid, bool throwIfPackageExists, PackageExtractionContext extractionContext);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfSourcePackageIsInvalid();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfPackageExistsAndInvalid();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfPackageExists();
    [CompilerGeneratedAttribute]
public PackageExtractionContext get_ExtractionContext();
}
internal static class NuGet.Protocol.Core.Types.OfflineFeedUtility : object {
    public static bool PackageExists(PackageIdentity packageIdentity, string offlineFeed, Boolean& isValidPackage);
    public static string GetPackageDirectory(PackageIdentity packageIdentity, string offlineFeed);
    public static void ThrowIfInvalid(string path);
    public static void ThrowIfInvalidOrNotFound(string path, bool isDirectory, string resourceString);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.OfflineFeedUtility/<AddPackageToSource>d__4")]
public static Task AddPackageToSource(OfflineFeedAddContext offlineFeedAddContext, CancellationToken token);
    private static string GetHash(string nupkgFilePath);
}
internal class NuGet.Protocol.Core.Types.PackageDownloadContext : object {
    [CompilerGeneratedAttribute]
private SourceCacheContext <SourceCacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectDownloadDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceMapping <PackageSourceMapping>k__BackingField;
    public SourceCacheContext SourceCacheContext { get; }
    public bool DirectDownload { get; }
    public string DirectDownloadDirectory { get; }
    public Guid ParentId { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; public set; }
    public PackageSourceMapping PackageSourceMapping { get; }
    public PackageDownloadContext(SourceCacheContext sourceCacheContext);
    public PackageDownloadContext(SourceCacheContext sourceCacheContext, string directDownloadDirectory, bool directDownload);
    public PackageDownloadContext(SourceCacheContext sourceCacheContext, string directDownloadDirectory, bool directDownload, PackageSourceMapping packageSourceMappingConfiguration);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_SourceCacheContext();
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public string get_DirectDownloadDirectory();
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public void set_ClientPolicyContext(ClientPolicyContext value);
    [CompilerGeneratedAttribute]
public PackageSourceMapping get_PackageSourceMapping();
}
internal abstract class NuGet.Protocol.Core.Types.PackageMetadataResource : object {
    public abstract virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public abstract virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.Core.Types.PackageProgressEventArgs : EventArgs {
    private PackageIdentity _identity;
    private PackageSource _source;
    private double _complete;
    public PackageIdentity PackageIdentity { get; }
    public PackageSource PackageSource { get; }
    public double Complete { get; }
    public bool IsComplete { get; }
    public bool HasPackageSource { get; }
    public PackageProgressEventArgs(PackageIdentity identity, PackageSource source, double complete);
    public PackageIdentity get_PackageIdentity();
    public PackageSource get_PackageSource();
    public double get_Complete();
    public bool get_IsComplete();
    public bool get_HasPackageSource();
}
internal class NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder : object {
    private IPackageSearchMetadata _metadata;
    private AsyncLazy`1<IEnumerable`1<VersionInfo>> _lazyVersionsFactory;
    private AsyncLazy`1<PackageDeprecationMetadata> _lazyDeprecationFactory;
    private PackageSearchMetadataBuilder(IPackageSearchMetadata metadata);
    public PackageSearchMetadataBuilder WithVersions(AsyncLazy`1<IEnumerable`1<VersionInfo>> lazyVersionsFactory);
    public PackageSearchMetadataBuilder WithDeprecation(AsyncLazy`1<PackageDeprecationMetadata> lazyDeprecationFactory);
    public IPackageSearchMetadata Build();
    public static PackageSearchMetadataBuilder FromMetadata(IPackageSearchMetadata metadata);
    public static PackageSearchMetadataBuilder FromIdentity(PackageIdentity identity);
}
[ExtensionAttribute]
internal static class NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions : object {
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, IEnumerable`1<VersionInfo> versions);
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, Func`1<Task`1<IEnumerable`1<VersionInfo>>> asyncValueFactory);
    [ExtensionAttribute]
public static IPackageSearchMetadata WithVersions(IPackageSearchMetadata metadata, Func`1<IEnumerable`1<VersionInfo>> valueFactory);
}
internal abstract class NuGet.Protocol.Core.Types.PackageSearchResource : object {
    public abstract virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Core.Types.PackageUpdateResource : object {
    private static string ServiceEndpoint;
    private static string ApiKeyHeader;
    private static string InvalidApiKey;
    private static string TempApiKeyServiceEndpoint;
    private HttpSource _httpSource;
    private string _source;
    private bool _disableBuffering;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    public ISettings Settings { get; public set; }
    public Uri SourceUri { get; }
    public PackageUpdateResource(string source, HttpSource httpSource);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(ISettings value);
    public Uri get_SourceUri();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__14")]
public Task Push(IList`1<string> packagePaths, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__15")]
public Task Push(IList`1<string> packagePaths, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, ILogger log);
    [ObsoleteAttribute("Use Push method which takes multiple package paths.")]
public Task Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__17")]
[ObsoleteAttribute("Consolidating to one PackageUpdateResource.Push method which has all parameters defined.")]
public Task Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Delete>d__18")]
public Task Delete(string packageId, string packageVersion, Func`2<string, string> getApiKey, Func`2<string, bool> confirm, bool noServiceEndpoint, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Delete>d__19")]
public Task Delete(string packageId, string packageVersion, Func`2<string, string> getApiKey, Func`2<string, bool> confirm, bool noServiceEndpoint, bool allowInsecureConnections, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushSymbolsPath>d__20")]
private Task PushSymbolsPath(string packagePath, string symbolSource, string apiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackagePath>d__21")]
private Task PushPackagePath(string packagePath, string source, string symbolSource, string apiKey, Func`2<string, string> getSymbolApiKey, bool noServiceEndpoint, bool skipDuplicate, SymbolPackageUpdateResourceV3 symbolPackageUpdateResource, bool allowInsecureConnections, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageCore>d__22")]
private Task`1<bool> PushPackageCore(string source, string apiKey, string packageToPush, bool noServiceEndpoint, bool skipDuplicate, TimeSpan requestTimeout, bool warnForHttpSources, bool allowInsecureConnections, ILogger log, CancellationToken token);
    private static string GetSourceDisplayName(string source);
    private bool IsFileSource();
    private static string GetSymbolsPath(string packagePath, bool isSnupkg);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageToServer>d__26")]
private Task`1<bool> PushPackageToServer(string source, string apiKey, string pathToPackage, bool noServiceEndpoint, bool skipDuplicate, TimeSpan requestTimeout, bool warnForHttpSources, bool allowInsecureConnections, ILogger logger, CancellationToken token);
    private static Nullable`1<HttpStatusCode> EnsureSuccessStatusCode(HttpResponseMessage response, Nullable`1<HttpStatusCode> codeNotToThrow, ILogger logger);
    private static bool DetectAndLogSkippedErrorOccurrence(Nullable`1<HttpStatusCode> skippedErrorStatusCode, string source, string packageIdentity, string reasonMessage, ILogger logger);
    private static void AdvertiseAvailableOptionToIgnore(HttpStatusCode errorCodeThatOccurred, ILogger logger);
    private Nullable`1<HttpStatusCode> ConvertSkipDuplicateParamToHttpStatusCode(bool skipDuplicate);
    private HttpRequestMessage CreateRequest(Uri serviceEndpointUrl, string pathToPackage, string apiKey, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageToFileSystem>d__32")]
private Task PushPackageToFileSystem(Uri sourceUri, string pathToPackage, bool skipDuplicate, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<DeletePackage>d__33")]
private Task DeletePackage(string source, string apiKey, string packageId, string packageVersion, bool noServiceEndpoint, bool allowInsecureConnections, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<DeletePackageFromServer>d__34")]
private Task DeletePackageFromServer(string source, string apiKey, string packageId, string packageVersion, bool noServiceEndpoint, ILogger logger, CancellationToken token);
    private void DeletePackageFromFileSystem(string source, string packageId, string packageVersion);
    private void ForceDeleteFile(string fullPath);
    public static void ForceDeleteDirectory(string path);
    private Uri GetServiceEndpointUrl(string source, string path, bool noServiceEndpoint);
    private static Uri EnsureTrailingSlash(string value);
    private bool IsV2LocalRepository(string root);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<GetSecureApiKey>d__41")]
private Task`1<string> GetSecureApiKey(PackageIdentity packageIdentity, string apiKey, bool noServiceEndpoint, TimeSpan requestTimeout, ILogger logger, CancellationToken token);
    private bool IsSourceNuGetSymbolServer(string source);
}
internal class NuGet.Protocol.Core.Types.PluginFindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, AsyncLazy`1<SortedDictionary`2<NuGetVersion, PackageInfo>>> _packageInfoCache;
    private PackageSource _packageSource;
    private IPlugin _plugin;
    private IPluginMulticlientUtilities _utilities;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public PluginFindPackageByIdResource(IPlugin plugin, IPluginMulticlientUtilities utilities, PackageSource packageSource);
    public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<GetAllVersionsAsync>d__9")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<GetDependencyInfoAsync>d__10")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<DoesPackageExistAsync>d__11")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<EnsurePackagesAsync>d__12")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<FindPackagesByIdAsync>d__13")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> FindPackagesByIdAsync(string id, CancellationToken cancellationToken);
    private SortedDictionary`2<NuGetVersion, PackageInfo> ParsePackageVersions(IEnumerable`1<string> versions, string id, string baseUri);
    private PackageInfo CreatePackageInfo(string baseUri, string id, string version);
    private void AddOrUpdateLogger(IPlugin plugin, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginFindPackageByIdResource/<SetLogLevelAsync>d__17")]
private Task SetLogLevelAsync(ILogger logger, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Core.Types.PluginResource : object {
    private static string _basicAuthenticationType;
    private ICredentialService _credentialService;
    private PackageSource _packageSource;
    private IReadOnlyList`1<PluginCreationResult> _pluginCreationResults;
    public PluginResource(IEnumerable`1<PluginCreationResult> pluginCreationResults, PackageSource packageSource, ICredentialService credentialService);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResource/<GetPluginAsync>d__5")]
public Task`1<GetPluginResult> GetPluginAsync(OperationClaim requiredClaim, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResource/<SetPackageSourceCredentialsAsync>d__6")]
private Task SetPackageSourceCredentialsAsync(IPlugin plugin, CancellationToken cancellationToken);
    private SetCredentialsRequest CreateRequest();
    private bool TryGetCachedCredentials(Uri uri, bool isProxy, ICredentials& credentials);
}
internal class NuGet.Protocol.Core.Types.PluginResourceProvider : ResourceProvider {
    private IPluginManager _pluginManager;
    public PluginResourceProvider(IPluginManager pluginManager);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PluginResourceProvider/<TryCreate>d__3")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Core.Types.ProviderComparer : object {
    [CompilerGeneratedAttribute]
private static ProviderComparer <Instance>k__BackingField;
    public static ProviderComparer Instance { get; }
    private static ProviderComparer();
    [CompilerGeneratedAttribute]
public static ProviderComparer get_Instance();
    public sealed virtual int Compare(INuGetResourceProvider providerA, INuGetResourceProvider providerB);
}
internal class NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentUri>k__BackingField;
    public PackageIdentity Identity { get; }
    public bool Listed { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; }
    public string ContentUri { get; public set; }
    public RemoteSourceDependencyInfo(PackageIdentity identity, bool listed, IEnumerable`1<PackageDependencyGroup> dependencyGroups, string contentUri);
    [CompilerGeneratedAttribute]
public PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
public string get_ContentUri();
    [CompilerGeneratedAttribute]
public void set_ContentUri(string value);
    public sealed virtual bool Equals(RemoteSourceDependencyInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class NuGet.Protocol.Core.Types.Repository : object {
    private static ProviderFactory _providerFactory;
    [CompilerGeneratedAttribute]
private static RepositoryFactory <Factory>k__BackingField;
    public static RepositoryFactory Factory { get; }
    public static ProviderFactory Provider { get; public set; }
    private static Repository();
    [CompilerGeneratedAttribute]
public static RepositoryFactory get_Factory();
    public static ProviderFactory get_Provider();
    public static void set_Provider(ProviderFactory value);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public static ISourceRepositoryProvider CreateProvider(IEnumerable`1<INuGetResourceProvider> resourceProviders);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public static ISourceRepositoryProvider CreateProvider(IEnumerable`1<INuGetResourceProvider> resourceProviders, string rootPath);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, string sourceUrl);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, string sourceUrl, FeedType type);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, PackageSource source);
    public static SourceRepository CreateSource(IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders, PackageSource source, FeedType type);
    private static IEnumerable`1<Lazy`1<INuGetResourceProvider>> CreateLazy(IEnumerable`1<INuGetResourceProvider> providers);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal abstract class NuGet.Protocol.Core.Types.ResourceProvider : object {
    private Type _resourceType;
    private string _name;
    private IEnumerable`1<string> _after;
    private IEnumerable`1<string> _before;
    public IEnumerable`1<string> After { get; }
    public IEnumerable`1<string> Before { get; }
    public string Name { get; }
    public Type ResourceType { get; }
    public ResourceProvider(Type resourceType);
    public ResourceProvider(Type resourceType, string name);
    public ResourceProvider(Type resourceType, string name, string before);
    public ResourceProvider(Type resourceType, string name, IEnumerable`1<string> before, IEnumerable`1<string> after);
    public virtual IEnumerable`1<string> get_After();
    public virtual IEnumerable`1<string> get_Before();
    public virtual string get_Name();
    public virtual Type get_ResourceType();
    public abstract virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    private static IEnumerable`1<string> ToArray(string s);
}
internal class NuGet.Protocol.Core.Types.RetriableProtocolException : NuGetProtocolException {
    public RetriableProtocolException(string message);
    public RetriableProtocolException(string message, Exception innerException);
    protected RetriableProtocolException(SerializationInfo info, StreamingContext context);
}
internal class NuGet.Protocol.Core.Types.SearchFilter : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SupportedFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDelisted>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SearchFilterType> <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SearchOrderBy> <OrderBy>k__BackingField;
    public IEnumerable`1<string> SupportedFrameworks { get; public set; }
    public bool IncludePrerelease { get; }
    public bool IncludeDelisted { get; public set; }
    public IEnumerable`1<string> PackageTypes { get; public set; }
    public Nullable`1<SearchFilterType> Filter { get; }
    public Nullable`1<SearchOrderBy> OrderBy { get; public set; }
    public SearchFilter(bool includePrerelease);
    public SearchFilter(bool includePrerelease, Nullable`1<SearchFilterType> filter);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
public void set_SupportedFrameworks(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrerelease();
    [CompilerGeneratedAttribute]
public bool get_IncludeDelisted();
    [CompilerGeneratedAttribute]
public void set_IncludeDelisted(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public Nullable`1<SearchFilterType> get_Filter();
    [CompilerGeneratedAttribute]
public Nullable`1<SearchOrderBy> get_OrderBy();
    [CompilerGeneratedAttribute]
public void set_OrderBy(Nullable`1<SearchOrderBy> value);
}
internal enum NuGet.Protocol.Core.Types.SearchFilterType : Enum {
    public int value__;
    public static SearchFilterType IsLatestVersion;
    public static SearchFilterType IsAbsoluteLatestVersion;
}
internal enum NuGet.Protocol.Core.Types.SearchOrderBy : Enum {
    public int value__;
    public static SearchOrderBy Id;
}
internal class NuGet.Protocol.Core.Types.SourceCacheContext : object {
    private string _generatedTempFolder;
    private static TimeSpan DefaultMaxAge;
    [CompilerGeneratedAttribute]
private bool <NoCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RefreshMemoryCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreFailedSources>k__BackingField;
    public bool NoCache { get; public set; }
    public bool DirectDownload { get; public set; }
    public Nullable`1<DateTimeOffset> MaxAge { get; public set; }
    public bool RefreshMemoryCache { get; public set; }
    public Guid SessionId { get; public set; }
    public TimeSpan MaxAgeTimeSpan { get; }
    public string GeneratedTempFolder { get; public set; }
    public bool IgnoreFailedSources { get; public set; }
    private static SourceCacheContext();
    [CompilerGeneratedAttribute]
public bool get_NoCache();
    [CompilerGeneratedAttribute]
public void set_NoCache(bool value);
    [CompilerGeneratedAttribute]
public bool get_DirectDownload();
    [CompilerGeneratedAttribute]
public void set_DirectDownload(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_MaxAge();
    [CompilerGeneratedAttribute]
public void set_MaxAge(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public bool get_RefreshMemoryCache();
    [CompilerGeneratedAttribute]
public void set_RefreshMemoryCache(bool value);
    [CompilerGeneratedAttribute]
public Guid get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(Guid value);
    public TimeSpan get_MaxAgeTimeSpan();
    private TimeSpan GetCacheTime(Nullable`1<DateTimeOffset> maxAge, TimeSpan defaultTime);
    public virtual string get_GeneratedTempFolder();
    public virtual void set_GeneratedTempFolder(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreFailedSources();
    [CompilerGeneratedAttribute]
public void set_IgnoreFailedSources(bool value);
    public virtual SourceCacheContext Clone();
    public virtual SourceCacheContext WithRefreshCacheTrue();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class NuGet.Protocol.Core.Types.SourcePackageDependencyInfo : PackageDependencyInfo {
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceRepository <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DownloadUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageHash>k__BackingField;
    public bool Listed { get; }
    public SourceRepository Source { get; }
    public Uri DownloadUri { get; }
    public string PackageHash { get; }
    public SourcePackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source);
    public SourcePackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source, Uri downloadUri, string packageHash);
    public SourcePackageDependencyInfo(PackageIdentity identity, IEnumerable`1<PackageDependency> dependencies, bool listed, SourceRepository source, Uri downloadUri, string packageHash);
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public SourceRepository get_Source();
    [CompilerGeneratedAttribute]
public Uri get_DownloadUri();
    [CompilerGeneratedAttribute]
public string get_PackageHash();
}
internal class NuGet.Protocol.Core.Types.SourceRepository : object {
    private Dictionary`2<Type, INuGetResourceProvider[]> _providerCache;
    private PackageSource _source;
    [CompilerGeneratedAttribute]
private FeedType <FeedTypeOverride>k__BackingField;
    public FeedType FeedTypeOverride { get; }
    public PackageSource PackageSource { get; }
    public SourceRepository(PackageSource source, IEnumerable`1<INuGetResourceProvider> providers);
    public SourceRepository(PackageSource source, IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers);
    public SourceRepository(PackageSource source, IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers, FeedType feedTypeOverride);
    [CompilerGeneratedAttribute]
public FeedType get_FeedTypeOverride();
    public virtual string ToString();
    public virtual PackageSource get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetFeedType>d__12")]
public virtual Task`1<FeedType> GetFeedType(CancellationToken token);
    public virtual T GetResource();
    public virtual T GetResource(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetResourceAsync>d__15`1")]
public virtual Task`1<T> GetResourceAsync();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.SourceRepository/<GetResourceAsync>d__16`1")]
public virtual Task`1<T> GetResourceAsync(CancellationToken token);
    private static Dictionary`2<Type, INuGetResourceProvider[]> Init(IEnumerable`1<Lazy`1<INuGetResourceProvider>> providers);
    private static INuGetResourceProvider[] Sort(IEnumerable`1<Lazy`1<INuGetResourceProvider>> group);
    private static FeedType GetFeedType(PackageSource source);
}
internal class NuGet.Protocol.Core.Types.SourceRepositoryProvider : object {
    private IPackageSourceProvider _packageSourceProvider;
    private IEnumerable`1<Lazy`1<INuGetResourceProvider>> _resourceProviders;
    private List`1<SourceRepository> _repositories;
    public IPackageSourceProvider PackageSourceProvider { get; }
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public SourceRepositoryProvider(ISettings settings, IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders);
    public SourceRepositoryProvider(IPackageSourceProvider packageSourceProvider, IEnumerable`1<Lazy`1<INuGetResourceProvider>> resourceProviders);
    public sealed virtual IEnumerable`1<SourceRepository> GetRepositories();
    public sealed virtual SourceRepository CreateRepository(PackageSource source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public sealed virtual IPackageSourceProvider get_PackageSourceProvider();
    private void Init();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(object sender, EventArgs e);
}
internal class NuGet.Protocol.Core.Types.SymbolPackageUpdateResourceV3 : object {
    private HttpSource _httpSource;
    private string _source;
    public Uri SourceUri { get; }
    public SymbolPackageUpdateResourceV3(string source, HttpSource httpSource);
    public Uri get_SourceUri();
}
internal static class NuGet.Protocol.Core.Types.UserAgent : object {
    [CompilerGeneratedAttribute]
private static string <UserAgentString>k__BackingField;
    public static string UserAgentString { get; private set; }
    private static UserAgent();
    public static void SetUserAgentString(UserAgentStringBuilder builder);
    [CompilerGeneratedAttribute]
public static string get_UserAgentString();
    [CompilerGeneratedAttribute]
private static void set_UserAgentString(string value);
    public static void SetUserAgent(HttpClient client);
}
internal class NuGet.Protocol.Core.Types.UserAgentStringBuilder : object {
    public static string DefaultNuGetClientName;
    private static string UserAgentWithOSDescriptionAndVisualStudioSKUTemplate;
    private static string UserAgentWithOSDescriptionTemplate;
    private static string UserAgentTemplate;
    private string _clientName;
    private string _vsInfo;
    private string _osInfo;
    [CompilerGeneratedAttribute]
private string <NuGetClientVersion>k__BackingField;
    public string NuGetClientVersion { get; }
    public UserAgentStringBuilder(string clientName);
    private static UserAgentStringBuilder();
    [CompilerGeneratedAttribute]
public string get_NuGetClientVersion();
    public UserAgentStringBuilder WithOSDescription(string osInfo);
    public UserAgentStringBuilder WithVisualStudioSKU(string vsInfo);
    public string Build();
    private string GetOSVersion();
}
internal class NuGet.Protocol.Core.Types.VersionInfo : object {
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSearchMetadata <PackageSearchMetadata>k__BackingField;
    public NuGetVersion Version { get; private set; }
    public Nullable`1<long> DownloadCount { get; private set; }
    public IPackageSearchMetadata PackageSearchMetadata { get; public set; }
    public VersionInfo(NuGetVersion version);
    public VersionInfo(NuGetVersion version, string downloadCount);
    public VersionInfo(NuGetVersion version, Nullable`1<long> downloadCount);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public IPackageSearchMetadata get_PackageSearchMetadata();
    [CompilerGeneratedAttribute]
public void set_PackageSearchMetadata(IPackageSearchMetadata value);
}
internal class NuGet.Protocol.DedicatedAsynchronousProcessingThread : object {
    private Task _processingThread;
    private bool _isDisposed;
    private bool _isClosed;
    private TimeSpan _pollingDelay;
    private ConcurrentQueue`1<Func`1<Task>> _taskQueue;
    public DedicatedAsynchronousProcessingThread(TimeSpan pollingDelay);
    internal void Start();
    internal void Enqueue(Func`1<Task> task);
    [AsyncStateMachineAttribute("NuGet.Protocol.DedicatedAsynchronousProcessingThread/<ProcessAsync>d__8")]
private Task ProcessAsync();
    public sealed virtual void Dispose();
    private void ThrowIfAlreadyStarted();
    private void ThrowIfNotAlreadyStarted();
    private void ThrowIfDisposed();
}
internal class NuGet.Protocol.DependencyInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistrationInfo <RegistrationInfo>k__BackingField;
    public string Id { get; public set; }
    public VersionRange Range { get; public set; }
    public RegistrationInfo RegistrationInfo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(VersionRange value);
    [CompilerGeneratedAttribute]
public RegistrationInfo get_RegistrationInfo();
    [CompilerGeneratedAttribute]
public void set_RegistrationInfo(RegistrationInfo value);
    public virtual string ToString();
}
internal class NuGet.Protocol.DependencyInfoResourceV2Feed : DependencyInfoResource {
    private V2FeedParser _feedParser;
    private FrameworkReducer _frameworkReducer;
    private SourceRepository _source;
    public DependencyInfoResourceV2Feed(V2FeedParser feedParser, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2Feed/<ResolvePackage>d__4")]
public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2Feed/<ResolvePackages>d__5")]
public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private SourcePackageDependencyInfo CreateDependencyInfo(V2FeedPackageInfo packageVersion, NuGetFramework projectFramework);
}
internal class NuGet.Protocol.DependencyInfoResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.DependencyInfoResourceV3 : DependencyInfoResource {
    private HttpSource _client;
    private RegistrationResourceV3 _regResource;
    private SourceRepository _source;
    public DependencyInfoResourceV3(HttpSource client, RegistrationResourceV3 regResource, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<ResolvePackage>d__4")]
public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<ResolvePackages>d__5")]
public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> ResolvePackages(string packageId, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [IteratorStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<GetPackagesFromRegistration>d__7")]
private IEnumerable`1<SourcePackageDependencyInfo> GetPackagesFromRegistration(RegistrationInfo registration, CancellationToken token);
}
internal class NuGet.Protocol.DependencyInfoResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.DownloadResourcePlugin : DownloadResource {
    private IPlugin _plugin;
    private PackageSource _packageSource;
    private IPluginMulticlientUtilities _utilities;
    public DownloadResourcePlugin(IPlugin plugin, IPluginMulticlientUtilities utilities, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePlugin/<GetDownloadResourceResultAsync>d__4")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken cancellationToken);
    private void AddOrUpdateLogger(IPlugin plugin, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePlugin/<SetLogLevelAsync>d__6")]
private Task SetLogLevelAsync(ILogger logger, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.DownloadResourcePluginProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourcePluginProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
    private static void AddOrUpdateGetCredentialsRequestHandler(IPlugin plugin, SourceRepository source, HttpHandlerResource httpHandlerResource);
    private static void AddOrUpdateGetServiceIndexRequestHandler(IPlugin plugin, SourceRepository source);
}
internal class NuGet.Protocol.DownloadResourceV2Feed : DownloadResource {
    private V2FeedParser _feedParser;
    private string _source;
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV2Feed(V2FeedParser feedParser);
    public DownloadResourceV2Feed(V2FeedParser feedParser, string source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV2Feed/<GetDownloadResourceResultAsync>d__4")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.DownloadResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.DownloadResourceV3 : DownloadResource {
    private string _source;
    private RegistrationResourceV3 _regResource;
    private HttpSource _client;
    private string _packageBaseAddressUrl;
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV3(HttpSource client, RegistrationResourceV3 regResource);
    public DownloadResourceV3(string source, HttpSource client, RegistrationResourceV3 regResource);
    [ObsoleteAttribute("Use constructor with source parameter")]
public DownloadResourceV3(HttpSource client, string packageBaseAddress);
    public DownloadResourceV3(string source, HttpSource client, string packageBaseAddress);
    private DownloadResourceV3(HttpSource client);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3/<GetDownloadUrl>d__9")]
private Task`1<Uri> GetDownloadUrl(PackageIdentity identity, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3/<GetDownloadResourceResultAsync>d__10")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.DownloadResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.DownloadTimeoutStream : Stream {
    private string _downloadName;
    private Stream _networkStream;
    private TimeSpan _timeout;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DownloadTimeoutStream(string downloadName, Stream networkStream, TimeSpan timeout);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadTimeoutStream/<ReadAsync>d__8")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class NuGet.Protocol.DownloadTimeoutStreamContent : StreamContent {
    public DownloadTimeoutStreamContent(string downloadName, Stream networkStream, TimeSpan timeout);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.Protocol.EnhancedHttpRetryHelper : object {
    public static int DefaultDelayMilliseconds;
    public static bool DefaultEnabled;
    public static int DefaultRetryCount;
    public static bool DefaultRetry429;
    public static bool DefaultObserveRetryAfter;
    public static string DelayInMillisecondsEnvironmentVariableName;
    public static string IsEnabledEnvironmentVariableName;
    public static string RetryCountEnvironmentVariableName;
    public static string Retry429EnvironmentVariableName;
    public static string ObserveRetryAfterEnvironmentVariableName;
    public static string MaximumRetryAfterDurationEnvironmentVariableName;
    private IEnvironmentVariableReader _environmentVariableReader;
    private Lazy`1<bool> _isEnabled;
    private Lazy`1<int> _retryCount;
    private Lazy`1<int> _delayInMilliseconds;
    private Lazy`1<bool> _retry429;
    private Lazy`1<bool> _observeRetryAfter;
    private Lazy`1<TimeSpan> _maxRetyAfterDelay;
    internal bool IsEnabled { get; }
    internal int RetryCount { get; }
    internal int DelayInMilliseconds { get; }
    internal bool Retry429 { get; }
    internal bool ObserveRetryAfter { get; }
    internal TimeSpan MaxRetryAfterDelay { get; }
    public EnhancedHttpRetryHelper(IEnvironmentVariableReader environmentVariableReader);
    internal bool get_IsEnabled();
    internal int get_RetryCount();
    internal int get_DelayInMilliseconds();
    internal bool get_Retry429();
    internal bool get_ObserveRetryAfter();
    internal TimeSpan get_MaxRetryAfterDelay();
    private static bool GetBoolFromEnvironmentVariable(string variableName, bool defaultValue, IEnvironmentVariableReader environmentVariableReader);
    private static int GetIntFromEnvironmentVariable(string variableName, int defaultValue, IEnvironmentVariableReader environmentVariableReader);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__18_0();
    [CompilerGeneratedAttribute]
private int <.ctor>b__18_1();
    [CompilerGeneratedAttribute]
private int <.ctor>b__18_2();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__18_3();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__18_4();
    [CompilerGeneratedAttribute]
private TimeSpan <.ctor>b__18_5();
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticHttpEvent : ProtocolDiagnosticHttpEventBase {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <EventDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    public DateTime Timestamp { get; }
    public TimeSpan EventDuration { get; }
    public long Bytes { get; }
    public bool IsSuccess { get; }
    internal ProtocolDiagnosticHttpEvent(DateTime timestamp, string source, Uri url, Nullable`1<TimeSpan> headerDuration, TimeSpan eventDuration, long bytes, Nullable`1<int> httpStatusCode, bool isSuccess, bool isRetry, bool isCancelled, bool isLastAttempt);
    internal ProtocolDiagnosticHttpEvent(DateTime timestamp, TimeSpan eventDuration, long bytes, bool isSuccess, ProtocolDiagnosticHttpEventBase eventBase);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public TimeSpan get_EventDuration();
    [CompilerGeneratedAttribute]
public long get_Bytes();
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
}
internal abstract class NuGet.Protocol.Events.ProtocolDiagnosticHttpEventBase : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <HeaderDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <HttpStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public string Source { get; }
    public Uri Url { get; }
    public Nullable`1<TimeSpan> HeaderDuration { get; }
    public Nullable`1<int> HttpStatusCode { get; }
    public bool IsRetry { get; }
    public bool IsCancelled { get; }
    public bool IsLastAttempt { get; }
    protected ProtocolDiagnosticHttpEventBase(ProtocolDiagnosticHttpEventBase other);
    protected ProtocolDiagnosticHttpEventBase(string source, Uri url, Nullable`1<TimeSpan> headerDuration, Nullable`1<int> httpStatusCode, bool isRetry, bool isCancelled, bool isLastAttempt);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_HeaderDuration();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_HttpStatusCode();
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticInProgressHttpEvent : ProtocolDiagnosticHttpEventBase {
    internal ProtocolDiagnosticInProgressHttpEvent(string source, Uri url, Nullable`1<TimeSpan> headerDuration, Nullable`1<int> httpStatusCode, bool isRetry, bool isCancelled, bool isLastAttempt);
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticNupkgCopiedEvent : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    public string Source { get; }
    public long FileSize { get; }
    public ProtocolDiagnosticNupkgCopiedEvent(string source, long fileSize);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public long get_FileSize();
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticResourceEvent : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    public string Source { get; }
    public string ResourceType { get; }
    public string Type { get; }
    public string Method { get; }
    public TimeSpan Duration { get; }
    public ProtocolDiagnosticResourceEvent(string source, string resourceType, string type, string method, TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public string get_ResourceType();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
}
internal static class NuGet.Protocol.Events.ProtocolDiagnostics : object {
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticHttpEventHandler HttpEvent;
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticResourceEventHandler ResourceEvent;
    [CompilerGeneratedAttribute]
private static ProtocolDiagnosticsNupkgCopiedEventHandler NupkgCopiedEvent;
    [CompilerGeneratedAttribute]
public static void add_HttpEvent(ProtocolDiagnosticHttpEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_HttpEvent(ProtocolDiagnosticHttpEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ResourceEvent(ProtocolDiagnosticResourceEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ResourceEvent(ProtocolDiagnosticResourceEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_NupkgCopiedEvent(ProtocolDiagnosticsNupkgCopiedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_NupkgCopiedEvent(ProtocolDiagnosticsNupkgCopiedEventHandler value);
    internal static void RaiseEvent(ProtocolDiagnosticHttpEvent pdEvent);
    internal static void RaiseEvent(ProtocolDiagnosticResourceEvent pdrEvent);
    internal static void RaiseEvent(ProtocolDiagnosticNupkgCopiedEvent ncEvent);
}
internal class NuGet.Protocol.Events.ProtocolDiagnosticsStream : Stream {
    private Stream _baseStream;
    private ProtocolDiagnosticInProgressHttpEvent _inProgressEvent;
    private Stopwatch _stopwatch;
    private long _bytes;
    private Action`1<ProtocolDiagnosticHttpEvent> _diagnosticEvent;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ProtocolDiagnosticsStream(Stream baseStream, ProtocolDiagnosticInProgressHttpEvent inProgressEvent, Stopwatch stopwatch, Action`1<ProtocolDiagnosticHttpEvent> diagnosticEvent);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("NuGet.Protocol.Events.ProtocolDiagnosticsStream/<ReadAsync>d__19")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void RaiseDiagnosticEvent(bool isSuccess);
}
[ExtensionAttribute]
internal static class NuGet.Protocol.Extensions.VersionRangeExtensions : object {
    [ExtensionAttribute]
public static bool DoesRangeSatisfy(VersionRange dependencyRange, NuGetVersion catalogItemLower, NuGetVersion catalogItemUpper);
}
[ExtensionAttribute]
internal static class NuGet.Protocol.FactoryExtensionsV3 : object {
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, string source, FeedType type);
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, string source);
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, PackageSource source);
    [ExtensionAttribute]
public static SourceRepository GetCoreV2(RepositoryFactory factory, PackageSource source);
    [ExtensionAttribute]
public static IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetCoreV3(ProviderFactory factory);
}
internal enum NuGet.Protocol.FeedType : Enum {
    public int value__;
    public static FeedType Undefined;
    public static FeedType HttpV2;
    public static FeedType HttpV3;
    public static FeedType FileSystemV2;
    public static FeedType FileSystemV3;
    public static FeedType FileSystemUnzipped;
    public static FeedType FileSystemPackagesConfig;
    public static FeedType FileSystemUnknown;
}
internal class NuGet.Protocol.FeedTypePackageSource : PackageSource {
    [CompilerGeneratedAttribute]
private FeedType <FeedType>k__BackingField;
    public FeedType FeedType { get; }
    public FeedTypePackageSource(string source, FeedType feedType);
    [CompilerGeneratedAttribute]
public FeedType get_FeedType();
}
internal class NuGet.Protocol.FeedTypeResource : object {
    [CompilerGeneratedAttribute]
private FeedType <FeedType>k__BackingField;
    public FeedType FeedType { get; }
    public FeedTypeResource(FeedType feedType);
    [CompilerGeneratedAttribute]
public FeedType get_FeedType();
}
internal class NuGet.Protocol.FeedTypeResourceProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, FeedTypeResource> _feedTypeCache;
    private object _accessLock;
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.FeedTypeUtility : object {
    public static FeedType GetFeedType(PackageSource packageSource);
}
internal abstract class NuGet.Protocol.FindLocalPackagesResource : object {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public string Root { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
protected void set_Root(string value);
    public virtual bool Exists(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual bool Exists(string packageId, ILogger logger, CancellationToken token);
    public abstract virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public abstract virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public abstract virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public abstract virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.FindLocalPackagesResourcePackagesConfig : FindLocalPackagesResource {
    public FindLocalPackagesResourcePackagesConfig(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.FindLocalPackagesResourceUnzipped : FindLocalPackagesResource {
    private Lazy`1<IReadOnlyList`1<LocalPackageInfo>> _packages;
    private Lazy`1<Dictionary`2<PackageIdentity, LocalPackageInfo>> _index;
    private Lazy`1<Dictionary`2<Uri, LocalPackageInfo>> _pathIndex;
    public FindLocalPackagesResourceUnzipped(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
    public virtual bool Exists(PackageIdentity identity, ILogger logger, CancellationToken token);
    private static Dictionary`2<PackageIdentity, LocalPackageInfo> GetIndex(Lazy`1<IReadOnlyList`1<LocalPackageInfo>> packages);
    private static Dictionary`2<Uri, LocalPackageInfo> GetPathIndex(Lazy`1<IReadOnlyList`1<LocalPackageInfo>> packages);
    private static IReadOnlyList`1<LocalPackageInfo> GetPackagesCore(string root);
    private static PackageReaderBase GetPackage(DirectoryInfo root, string name);
    private static NuspecReader GetNuspec(DirectoryInfo root, string name);
}
internal class NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, FindLocalPackagesResourceUnzipped> _cache;
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider/<TryCreate>d__2")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.FindLocalPackagesResourceV2 : FindLocalPackagesResource {
    public FindLocalPackagesResourceV2(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.FindLocalPackagesResourceV2Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceV2Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.FindLocalPackagesResourceV3 : FindLocalPackagesResource {
    public FindLocalPackagesResourceV3(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.FindLocalPackagesResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.FindPackagesByIdNupkgDownloader : object {
    private NuGet.Protocol1276564.TaskResultCache`2<string, CacheEntry> _cacheEntries;
    private object _nuspecReadersLock;
    private ConcurrentDictionary`2<string, NuspecReader> _nuspecReaders;
    private HttpSource _httpSource;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    public FindPackagesByIdNupkgDownloader(HttpSource httpSource);
    internal FindPackagesByIdNupkgDownloader(HttpSource httpSource, IEnvironmentVariableReader environmentVariableReader);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<GetNuspecReaderFromNupkgAsync>d__7")]
public Task`1<NuspecReader> GetNuspecReaderFromNupkgAsync(PackageIdentity identity, string url, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<CopyNupkgToStreamAsync>d__8")]
public Task`1<bool> CopyNupkgToStreamAsync(PackageIdentity identity, string url, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessNupkgStreamAsync>d__9")]
private Task`1<bool> ProcessNupkgStreamAsync(PackageIdentity identity, string url, Func`2<Stream, Task> processStreamAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessStreamAndGetCacheEntryAsync>d__10")]
private Task`1<CacheEntry> ProcessStreamAndGetCacheEntryAsync(PackageIdentity identity, string url, Func`2<Stream, Task> processStreamAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessHttpSourceResultAsync>d__11`1")]
private Task`1<T> ProcessHttpSourceResultAsync(PackageIdentity identity, string url, Func`2<HttpSourceResult, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessCacheEntryAsync>d__12")]
private Task`1<bool> ProcessCacheEntryAsync(CacheEntry cacheEntry, Func`2<Stream, Task> processStreamAsync, CancellationToken token);
}
internal class NuGet.Protocol.FingerprintsConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal static class NuGet.Protocol.GetDownloadResultUtility : object {
    private static int BufferSize;
    private static string DirectDownloadExtension;
    private static string DirectDownloadPattern;
    [AsyncStateMachineAttribute("NuGet.Protocol.GetDownloadResultUtility/<GetDownloadResultAsync>d__3")]
public static Task`1<DownloadResourceResult> GetDownloadResultAsync(HttpSource client, PackageIdentity identity, Uri uri, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
    public static void CleanUpDirectDownloads(PackageDownloadContext downloadContext);
    [AsyncStateMachineAttribute("NuGet.Protocol.GetDownloadResultUtility/<DirectDownloadAsync>d__5")]
private static Task`1<DownloadResourceResult> DirectDownloadAsync(string source, PackageIdentity packageIdentity, Stream packageStream, PackageDownloadContext downloadContext, CancellationToken token);
}
internal static class NuGet.Protocol.GlobalPackagesFolderUtility : object {
    private static int BufferSize;
    public static DownloadResourceResult GetPackage(PackageIdentity packageIdentity, string globalPackagesFolder);
    private static DownloadResourceResult CreateDownloadResourceResult(string nupkgPath, string installPath);
    [AsyncStateMachineAttribute("NuGet.Protocol.GlobalPackagesFolderUtility/<AddPackageAsync>d__3")]
public static Task`1<DownloadResourceResult> AddPackageAsync(string source, PackageIdentity packageIdentity, Stream packageStream, string globalPackagesFolder, Guid parentId, ClientPolicyContext clientPolicyContext, ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.HttpCacheResult : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public TimeSpan MaxAge { get; }
    public string NewFile { get; }
    public string CacheFile { get; }
    public Stream Stream { get; public set; }
    public HttpCacheResult(TimeSpan maxAge, string newFile, string cacheFule);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public string get_NewFile();
    [CompilerGeneratedAttribute]
public string get_CacheFile();
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
}
internal static class NuGet.Protocol.HttpCacheUtility : object {
    private static int BufferSize;
    public static HttpCacheResult InitializeHttpCacheResult(string httpCacheDirectory, Uri sourceUri, string cacheKey, HttpSourceCacheContext context);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpCacheUtility/<CreateCacheFileAsync>d__2")]
public static Task CreateCacheFileAsync(HttpCacheResult result, HttpResponseMessage response, Action`1<Stream> ensureValidContents, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource : FindPackageByIdResource {
    private static int DefaultMaxRetries;
    private int _maxRetries;
    private HttpSource _httpSource;
    private ConcurrentDictionary`2<string, AsyncLazy`1<SortedDictionary`2<NuGetVersion, PackageInfo>>> _packageInfoCache;
    private IReadOnlyList`1<Uri> _baseUris;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public HttpFileSystemBasedFindPackageByIdResource(IReadOnlyList`1<Uri> baseUris, HttpSource httpSource);
    internal HttpFileSystemBasedFindPackageByIdResource(IReadOnlyList`1<Uri> baseUris, HttpSource httpSource, IEnvironmentVariableReader environmentVariableReader);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetAllVersionsAsync>d__11")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetDependencyInfoAsync>d__12")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<CopyNupkgToStreamAsync>d__13")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetPackageDownloaderAsync>d__14")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<DoesPackageExistAsync>d__15")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<EnsurePackagesAsync>d__16")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<FindPackagesByIdAsync>d__17")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> FindPackagesByIdAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<ConsumeFlatContainerIndexAsync>d__18")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> ConsumeFlatContainerIndexAsync(Stream stream, string id, string baseUri, CancellationToken token);
    private PackageInfo BuildModel(string baseUri, string id, string version);
}
internal class NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
internal class NuGet.Protocol.HttpHandlerResourceV3 : HttpHandlerResource {
    private HttpClientHandler _clientHandler;
    private HttpMessageHandler _messageHandler;
    [CompilerGeneratedAttribute]
private static Lazy`1<ICredentialService> <CredentialService>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`2<Uri, ICredentials> <CredentialsSuccessfullyUsed>k__BackingField;
    public HttpClientHandler ClientHandler { get; }
    public HttpMessageHandler MessageHandler { get; }
    public static Lazy`1<ICredentialService> CredentialService { get; public set; }
    public static Action`2<Uri, ICredentials> CredentialsSuccessfullyUsed { get; public set; }
    public HttpHandlerResourceV3(HttpClientHandler clientHandler, HttpMessageHandler messageHandler);
    public virtual HttpClientHandler get_ClientHandler();
    public virtual HttpMessageHandler get_MessageHandler();
    [CompilerGeneratedAttribute]
public static Lazy`1<ICredentialService> get_CredentialService();
    [CompilerGeneratedAttribute]
public static void set_CredentialService(Lazy`1<ICredentialService> value);
    [CompilerGeneratedAttribute]
public static Action`2<Uri, ICredentials> get_CredentialsSuccessfullyUsed();
    [CompilerGeneratedAttribute]
public static void set_CredentialsSuccessfullyUsed(Action`2<Uri, ICredentials> value);
}
internal class NuGet.Protocol.HttpHandlerResourceV3Provider : ResourceProvider {
    private IProxyCache _proxyCache;
    internal HttpHandlerResourceV3Provider(IProxyCache proxyCache);
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    private HttpHandlerResourceV3 CreateResource(PackageSource packageSource);
}
internal class NuGet.Protocol.HttpRequestMessageConfiguration : object {
    public static HttpRequestMessageConfiguration Default;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PromptOn403>k__BackingField;
    public ILogger Logger { get; }
    public bool PromptOn403 { get; }
    public HttpRequestMessageConfiguration(ILogger logger, bool promptOn403);
    private static HttpRequestMessageConfiguration();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_PromptOn403();
}
[ExtensionAttribute]
internal static class NuGet.Protocol.HttpRequestMessageExtensions : object {
    private static string NuGetConfigurationKey;
    [ExtensionAttribute]
internal static HttpRequestMessage Clone(HttpRequestMessage request);
    [ExtensionAttribute]
public static HttpRequestMessageConfiguration GetOrCreateConfiguration(HttpRequestMessage request);
    [ExtensionAttribute]
public static void SetConfiguration(HttpRequestMessage request, HttpRequestMessageConfiguration configuration);
    [ExtensionAttribute]
private static T GetProperty(HttpRequestMessage request, string key);
}
internal static class NuGet.Protocol.HttpRequestMessageFactory : object {
    public static HttpRequestMessage Create(HttpMethod method, string requestUri, ILogger log);
    public static HttpRequestMessage Create(HttpMethod method, Uri requestUri, ILogger log);
    public static HttpRequestMessage Create(HttpMethod method, string requestUri, HttpRequestMessageConfiguration configuration);
    public static HttpRequestMessage Create(HttpMethod method, Uri requestUri, HttpRequestMessageConfiguration configuration);
}
[ExtensionAttribute]
internal static class NuGet.Protocol.HttpResponseMessageExtensions : object {
    [ExtensionAttribute]
public static void LogServerWarning(HttpResponseMessage response, ILogger log);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.Protocol.HttpRetryHandler : object {
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    internal static string StopwatchPropertyName;
    internal HttpRetryHandler(IEnvironmentVariableReader environmentVariableReader);
    public sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpRetryHandler/<SendAsync>d__5")]
public sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, string source, ILogger log, CancellationToken cancellationToken);
    [NuGet.Protocol.NullableContextAttribute("2")]
private static Nullable`1<TimeSpan> GetRetryAfter(RetryConditionHeaderValue retryAfter);
}
internal class NuGet.Protocol.HttpRetryHandlerRequest : object {
    public static int DefaultMaxTries;
    public static TimeSpan DefaultDownloadTimeout;
    [CompilerGeneratedAttribute]
private HttpClient <HttpClient>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<HttpRequestMessage> <RequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpCompletionOption <CompletionOption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RetryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> <AddHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public HttpClient HttpClient { get; }
    public Func`1<HttpRequestMessage> RequestFactory { get; }
    public HttpCompletionOption CompletionOption { get; public set; }
    public int MaxTries { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public TimeSpan RetryDelay { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> AddHeaders { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpRetryHandlerRequest(HttpClient httpClient, Func`1<HttpRequestMessage> requestFactory);
    private static HttpRetryHandlerRequest();
    [CompilerGeneratedAttribute]
public HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
public Func`1<HttpRequestMessage> get_RequestFactory();
    [CompilerGeneratedAttribute]
public HttpCompletionOption get_CompletionOption();
    [CompilerGeneratedAttribute]
public void set_CompletionOption(HttpCompletionOption value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RetryDelay();
    [CompilerGeneratedAttribute]
public void set_RetryDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> get_AddHeaders();
    [CompilerGeneratedAttribute]
public void set_AddHeaders(IList`1<KeyValuePair`2<string, IEnumerable`1<string>>> value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
internal class NuGet.Protocol.HttpSource : object {
    private Func`1<Task`1<HttpHandlerResource>> _messageHandlerFactory;
    private Uri _sourceUri;
    private HttpClient _httpClient;
    private string _httpCacheDirectory;
    private PackageSource _packageSource;
    private IThrottle _throttle;
    private bool _disposed;
    private SemaphoreSlim _httpClientLock;
    [CompilerGeneratedAttribute]
private IHttpRetryHandler <RetryHandler>k__BackingField;
    public IHttpRetryHandler RetryHandler { get; public set; }
    public string PackageSource { get; }
    public string HttpCacheDirectory { get; public set; }
    public HttpSource(PackageSource packageSource, Func`1<Task`1<HttpHandlerResource>> messageHandlerFactory, IThrottle throttle);
    [CompilerGeneratedAttribute]
public IHttpRetryHandler get_RetryHandler();
    [CompilerGeneratedAttribute]
public void set_RetryHandler(IHttpRetryHandler value);
    public string get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetAsync>d__15`1")]
public virtual Task`1<T> GetAsync(HttpSourceCachedRequest request, Func`2<HttpSourceResult, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    public Task`1<T> ProcessStreamAsync(HttpSourceRequest request, Func`2<Stream, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessHttpStreamAsync>d__17`1")]
internal Task`1<T> ProcessHttpStreamAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessStreamAsync>d__18`1")]
public Task`1<T> ProcessStreamAsync(HttpSourceRequest request, Func`2<Stream, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public Task`1<T> ProcessResponseAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessResponseAsync>d__20`1")]
public Task`1<T> ProcessResponseAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetJObjectAsync>d__21")]
public Task`1<JObject> GetJObjectAsync(HttpSourceRequest request, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetThrottledResponse>d__22")]
private Task`1<ThrottledResponse> GetThrottledResponse(Func`1<HttpRequestMessage> requestFactory, TimeSpan requestTimeout, TimeSpan downloadTimeout, int maxTries, bool isRetry, bool isLastAttempt, Guid sessionId, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<EnsureHttpClientAsync>d__23")]
private Task EnsureHttpClientAsync();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<CreateHttpClientAsync>d__24")]
private Task`1<HttpClient> CreateHttpClientAsync();
    public string get_HttpCacheDirectory();
    public void set_HttpCacheDirectory(string value);
    protected virtual Stream TryReadCacheFile(string uri, TimeSpan maxAge, string cacheFile);
    public static HttpSource Create(SourceRepository source);
    public static HttpSource Create(SourceRepository source, IThrottle throttle);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task`1<ThrottledResponse> <ProcessResponseAsync>g__throttledResponseFactory|20_0(<>c__DisplayClass20_0`1& );
}
internal class NuGet.Protocol.HttpSourceAuthenticationHandler : DelegatingHandler {
    public static int MaxAuthRetries;
    private static SemaphoreSlim _credentialPromptLock;
    private PackageSource _packageSource;
    private HttpClientHandler _clientHandler;
    private ICredentialService _credentialService;
    private SemaphoreSlim _httpClientLock;
    private Dictionary`2<string, AmbientAuthenticationState> _authStates;
    private HttpSourceCredentials _credentials;
    private bool _isDisposed;
    public HttpSourceAuthenticationHandler(PackageSource packageSource, HttpClientHandler clientHandler, ICredentialService credentialService);
    private static HttpSourceAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<SendAsync>d__10")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<AcquireCredentialsAsync>d__11")]
private Task`1<ICredentials> AcquireCredentialsAsync(HttpStatusCode statusCode, Guid credentialsVersion, ILogger log, bool areLastKnownGoodCredentialsTried, CancellationToken cancellationToken);
    private AmbientAuthenticationState GetAuthenticationState();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<PromptForCredentialsAsync>d__13")]
private Task`1<ICredentials> PromptForCredentialsAsync(CredentialRequestType type, string message, AmbientAuthenticationState authState, ILogger log, CancellationToken token);
    private void CredentialsSuccessfullyUsed(Uri uri, ICredentials credentials);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.HttpSourceCachedRequest : object {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MediaTypeWithQualityHeaderValue> <AcceptHeaderValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNotFounds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Stream> <EnsureValidContents>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public string Uri { get; }
    public string CacheKey { get; }
    public HttpSourceCacheContext CacheContext { get; }
    public IList`1<MediaTypeWithQualityHeaderValue> AcceptHeaderValues { get; }
    public bool IgnoreNotFounds { get; public set; }
    public int MaxTries { get; public set; }
    public Action`1<Stream> EnsureValidContents { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpSourceCachedRequest(string uri, string cacheKey, HttpSourceCacheContext cacheContext);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
public HttpSourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public IList`1<MediaTypeWithQualityHeaderValue> get_AcceptHeaderValues();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNotFounds();
    [CompilerGeneratedAttribute]
public void set_IgnoreNotFounds(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public Action`1<Stream> get_EnsureValidContents();
    [CompilerGeneratedAttribute]
public void set_EnsureValidContents(Action`1<Stream> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
internal class NuGet.Protocol.HttpSourceCredentials : CredentialCache {
    private VersionedCredentials modreq(System.Runtime.CompilerServices.IsVolatile) _credentials;
    public ICredentials Credentials { get; public set; }
    public Guid Version { get; }
    public HttpSourceCredentials(ICredentials credentials);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public Guid get_Version();
    private sealed virtual override NetworkCredential System.Net.ICredentials.GetCredential(Uri uri, string authType);
}
internal class NuGet.Protocol.HttpSourceRequest : object {
    public static TimeSpan DefaultRequestTimeout;
    [CompilerGeneratedAttribute]
private Func`1<HttpRequestMessage> <RequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNotFounds>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastAttempt>k__BackingField;
    public Func`1<HttpRequestMessage> RequestFactory { get; }
    public bool IgnoreNotFounds { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public int MaxTries { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public bool IsRetry { get; public set; }
    public bool IsLastAttempt { get; public set; }
    public HttpSourceRequest(string uri, ILogger log);
    public HttpSourceRequest(Uri uri, ILogger log);
    public HttpSourceRequest(Func`1<HttpRequestMessage> requestFactory);
    private static HttpSourceRequest();
    [CompilerGeneratedAttribute]
public Func`1<HttpRequestMessage> get_RequestFactory();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNotFounds();
    [CompilerGeneratedAttribute]
public void set_IgnoreNotFounds(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public void set_IsRetry(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastAttempt();
    [CompilerGeneratedAttribute]
public void set_IsLastAttempt(bool value);
}
internal class NuGet.Protocol.HttpSourceResource : object {
    [CompilerGeneratedAttribute]
private HttpSource <HttpSource>k__BackingField;
    public HttpSource HttpSource { get; }
    public HttpSourceResource(HttpSource httpSource);
    [CompilerGeneratedAttribute]
public HttpSource get_HttpSource();
}
internal class NuGet.Protocol.HttpSourceResourceProvider : ResourceProvider {
    private static int DefaultMaxHttpRequestsPerSource;
    private ConcurrentDictionary`2<PackageSource, HttpSourceResource> _cache;
    [CompilerGeneratedAttribute]
private static IThrottle <Throttle>k__BackingField;
    public static IThrottle Throttle { get; public set; }
    [CompilerGeneratedAttribute]
public static IThrottle get_Throttle();
    [CompilerGeneratedAttribute]
public static void set_Throttle(IThrottle value);
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.HttpSourceResult : object {
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSourceResultStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFile>k__BackingField;
    public Stream Stream { get; private set; }
    public HttpSourceResultStatus Status { get; }
    public string CacheFile { get; }
    public HttpSourceResult(HttpSourceResultStatus status);
    public HttpSourceResult(HttpSourceResultStatus status, string cacheFileName, Stream stream);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
public HttpSourceResultStatus get_Status();
    [CompilerGeneratedAttribute]
public string get_CacheFile();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal enum NuGet.Protocol.HttpSourceResultStatus : Enum {
    public int value__;
    public static HttpSourceResultStatus NotFound;
    public static HttpSourceResultStatus NoContent;
    public static HttpSourceResultStatus OpenedFromDisk;
    public static HttpSourceResultStatus OpenedFromNetwork;
}
internal static class NuGet.Protocol.HttpStreamValidation : object {
    public static void ValidateJObject(string uri, Stream stream);
    public static void ValidateNupkg(string uri, Stream stream);
    public static void ValidateXml(string uri, Stream stream);
}
internal interface NuGet.Protocol.IHttpRetryHandler {
    public abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, ILogger log, CancellationToken cancellationToken);
    public abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, string sourceUri, ILogger log, CancellationToken cancellationToken);
}
internal abstract class NuGet.Protocol.InvalidCacheProtocolException : FatalProtocolException {
    public InvalidCacheProtocolException(string message);
    public InvalidCacheProtocolException(string message, Exception innerException);
    protected InvalidCacheProtocolException(SerializationInfo info, StreamingContext context);
}
internal interface NuGet.Protocol.IThrottle {
    public abstract virtual Task WaitAsync();
    public abstract virtual void Release();
}
internal interface NuGet.Protocol.IV2FeedParser {
    public abstract virtual Task`1<V2FeedPage> GetPackagesPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    public abstract virtual Task`1<V2FeedPage> GetSearchPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
}
internal interface NuGet.Protocol.IVulnerabilityInfoResource {
    [NuGet.Protocol.NullableContextAttribute("1")]
public abstract virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync(SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class NuGet.Protocol.JsonExtensions : object {
    public static int JsonSerializationMaxDepth;
    public static JsonSerializerSettings ObjectSerializationSettings;
    internal static JsonSerializer JsonObjectSerializer;
    internal static JsonSerializerOptions JsonSerializerOptions;
    private static JsonExtensions();
    private static JsonSerializerOptions CreateJsonSerializerOptions();
    [ExtensionAttribute]
public static string ToJson(object obj, Formatting formatting);
    [ExtensionAttribute]
public static T FromJson(string json);
    [ExtensionAttribute]
public static T FromJson(string json, JsonSerializerSettings settings);
    [ExtensionAttribute]
public static object FromJson(string json, Type type);
    [ExtensionAttribute]
public static JToken ToJToken(object obj);
    [ExtensionAttribute]
public static T FromJToken(JToken jtoken);
    [ExtensionAttribute]
public static object FromJToken(JToken jtoken, Type type);
    [ExtensionAttribute]
public static T GetJObjectProperty(JObject jobject, string propertyName);
    [ExtensionAttribute]
public static Nullable`1<bool> GetBoolean(JObject json, string propertyName);
}
internal static class NuGet.Protocol.JsonProperties : object {
    public static string Data;
    public static string SubjectId;
    public static string Type;
    public static string PackageId;
    public static string Version;
    public static string Title;
    public static string Summary;
    public static string Description;
    public static string Authors;
    public static string Owners;
    public static string IconUrl;
    public static string LicenseUrl;
    public static string LicenseExpression;
    public static string LicenseExpressionVersion;
    public static string ProjectUrl;
    public static string ReadmeUrl;
    public static string Tags;
    public static string DownloadCount;
    public static string Created;
    public static string LastEdited;
    public static string Published;
    public static string RequireLicenseAcceptance;
    public static string DependencyGroups;
    public static string LatestVersion;
    public static string TargetFramework;
    public static string Dependencies;
    public static string Range;
    public static string MinimumClientVersion;
    public static string Language;
    public static string PackageContent;
    public static string Versions;
    public static string PrefixReserved;
    public static string Listed;
    public static string Subject;
    public static string Issuer;
    public static string NotBefore;
    public static string NotAfter;
    public static string ContentUrl;
    public static string SigningCertificates;
    public static string AllRepositorySigned;
    public static string Fingerprints;
    public static string Deprecation;
    public static string DeprecationMessage;
    public static string DeprecationReasons;
    public static string AlternatePackage;
    public static string Vulnerabilities;
    public static string AdvisoryUrl;
    public static string Severity;
    public static string Url;
}
internal static class NuGet.Protocol.JsonUtility : object {
    internal static JsonLoadSettings DefaultLoadSettings;
    private static JsonUtility();
    internal static JObject LoadJson(TextReader reader);
    internal static JObject LoadJson(JsonReader jsonReader);
}
internal class NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed : LegacyFeedCapabilityResource {
    private static ConcurrentDictionary`2<string, Task`1<Capabilities>> CachedCapabilities;
    private static string MetadataUriFormat;
    private string _metadataUri;
    private V2FeedParser _feedParser;
    public LegacyFeedCapabilityResourceV2Feed(V2FeedParser feedParser, string baseAddress);
    private static LegacyFeedCapabilityResourceV2Feed();
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<SupportsIsAbsoluteLatestVersionAsync>d__5")]
public virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<SupportsSearchAsync>d__6")]
public virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<GetCachedCapabilitiesAsync>d__7")]
private Task`1<Capabilities> GetCachedCapabilitiesAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<GetCapabilitiesAsync>d__8")]
private Task`1<Capabilities> GetCapabilitiesAsync(string metadataUri, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.LocalAutoCompleteResource : AutoCompleteResource {
    private FindLocalPackagesResource _localResource;
    public LocalAutoCompleteResource(FindLocalPackagesResource localResource);
    public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResource/<GetPackageIdsFromLocalPackageRepository>d__4")]
private Task`1<IEnumerable`1<string>> GetPackageIdsFromLocalPackageRepository(string searchFilter, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResource/<GetPackageVersionsFromLocalPackageRepository>d__5")]
protected Task`1<IEnumerable`1<NuGetVersion>> GetPackageVersionsFromLocalPackageRepository(string packageId, string versionPrefix, bool includePrerelease, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.LocalAutoCompleteResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.LocalDependencyInfoResource : DependencyInfoResource {
    private FindLocalPackagesResource _localResource;
    private SourceRepository _source;
    public LocalDependencyInfoResource(FindLocalPackagesResource localResource, SourceRepository source);
    public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private SourcePackageDependencyInfo CreateDependencyInfo(LocalPackageInfo package, NuGetFramework projectFramework);
}
internal class NuGet.Protocol.LocalDependencyInfoResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalDependencyInfoResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.LocalDownloadResource : DownloadResource {
    private FindLocalPackagesResource _localResource;
    private string _source;
    [ObsoleteAttribute("Use constructor with source parameter")]
public LocalDownloadResource(FindLocalPackagesResource localResource);
    public LocalDownloadResource(string source, FindLocalPackagesResource localResource);
    public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.LocalDownloadResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalDownloadResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.LocalFolderUtility : object {
    private static string NupkgFilter;
    private static LocalFolderUtility();
    public static LocalPackageInfo GetPackage(Uri path, ILogger log);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, ILogger log);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV2>d__5")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static LocalPackageInfo GetPackageV2(string root, string id, NuGetVersion version, ILogger log);
    public static LocalPackageInfo GetPackageV2(string root, string id, NuGetVersion version, ILogger log, CancellationToken cancellationToken);
    public static LocalPackageInfo GetPackageV2(string root, PackageIdentity identity, ILogger log);
    public static LocalPackageInfo GetPackageV2(string root, PackageIdentity identity, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesConfigFolderPackages>d__11")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, ILogger log, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesConfigFolderPackages>d__12")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, string id, ILogger log);
    public static LocalPackageInfo GetPackagesConfigFolderPackage(string root, PackageIdentity identity, ILogger log);
    private static string GetPackagesConfigFolderSearchPattern(string id);
    public static LocalPackageInfo GetPackagesConfigFolderPackage(string root, string id, NuGetVersion version, ILogger log);
    private static LocalPackageInfo GetPackagesConfigFolderPackage(DirectoryInfo dir, ILogger log);
    public static bool IsPossiblePackageMatch(FileInfo file, PackageIdentity identity);
    public static bool IsPossiblePackageMatch(FileInfo file, string id);
    public static PackageIdentity GetIdentityFromNupkgPath(FileInfo file, string id);
    public static NuGetVersion GetVersionFromFileName(string fileName, string id, string extension);
    private static NuGetVersion GetVersionFromIdVersionString(string idVersionString, string id);
    public static LocalPackageInfo GetPackageV3(string root, string id, NuGetVersion version, ILogger log);
    public static LocalPackageInfo GetPackageV3(string root, PackageIdentity identity, ILogger log);
    public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolder>d__25")]
public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, ILogger log, CancellationToken cancellationToken);
    public static FeedType GetLocalFeedType(string root, ILogger log);
    public static DirectoryInfo GetAndVerifyRootDirectory(string root);
    private static FileInfo GetAndVerifyFileInfo(Uri fileUri);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolderChunked>d__29")]
private static IEnumerable`1<List`1<FileInfo>> GetNupkgsFromFlatFolderChunked(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolder>d__31")]
public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV3>d__33")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV3>d__35")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, string id, ILogger log, CancellationToken cancellationToken);
    public static IEnumerable`1<string> ResolvePackageFromPath(string packagePath, bool isSnupkg);
    private static string EnsurePackageExtension(string packagePath, bool isSnupkg);
    public static void EnsurePackageFileExists(string packagePath, IEnumerable`1<string> matchingPackagePaths);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetDistinctPackages>d__39")]
public static IEnumerable`1<LocalPackageInfo> GetDistinctPackages(IEnumerable`1<LocalPackageInfo> packages);
    private static List`1<DirectoryInfo> GetDirectoriesSafe(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    private static List`1<DirectoryInfo> GetDirectoriesSafe(DirectoryInfo root, string filter, SearchOption searchOption, ILogger log, CancellationToken cancellationToken);
    internal static List`1<FileInfo> GetFilesSafe(DirectoryInfo root, string filter, ILogger log, CancellationToken cancellationToken);
    private static IEnumerable`1<LocalPackageInfo> GetPackagesFromNupkgs(IEnumerable`1<FileInfo> files, CancellationToken cancellationToken);
    private static LocalPackageInfo GetPackageFromNupkg(FileInfo nupkgFile);
    private static List`1<FileInfo> GetNupkgsFromDirectory(DirectoryInfo root, ILogger log, CancellationToken cancellationToken);
    private static LocalPackageInfo GetPackageV3(string root, string id, string version, ILogger log);
    private static FileInfo CreateFileInfoIfValidOrNull(string localPath, ILogger log);
    public static void GenerateNupkgMetadataFile(string nupkgPath, string installPath, string hashPath, string nupkgMetadataPath);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<CancellableYieldEnumeration>d__49`1")]
private static IEnumerable`1<T> CancellableYieldEnumeration(IEnumerable`1<T> enumerable, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.LocalMetadataResource : MetadataResource {
    private FindLocalPackagesResource _localResource;
    public LocalMetadataResource(FindLocalPackagesResource localResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalMetadataResource/<GetLatestVersions>d__2")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.LocalMetadataResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalMetadataResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.LocalPackageArchiveDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private string _packageFilePath;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private Lazy`1<FileStream> _sourceStream;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public LocalPackageArchiveDownloader(string source, string packageFilePath, PackageIdentity packageIdentity, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageArchiveDownloader/<CopyNupkgFileToAsync>d__19")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetSourceStream();
    private void ThrowIfDisposed();
}
internal class NuGet.Protocol.LocalPackageFileCache : object {
    private ConcurrentDictionary`2<string, Lazy`1<NuspecReader>> _nuspecCache;
    private ConcurrentDictionary`2<string, Lazy`1<IReadOnlyList`1<string>>> _filesCache;
    private ConcurrentDictionary`2<string, Lazy`1<string>> _sha512Cache;
    private ConcurrentDictionary`2<string, bool> _fileExistsCache;
    private ConcurrentDictionary`2<string, Lazy`1<RuntimeGraph>> _runtimeCache;
    private ConcurrentDictionary`2<string, bool> _metadataFileCache;
    public virtual Lazy`1<NuspecReader> GetOrAddNuspec(string manifestPath, string expandedPath);
    public virtual Lazy`1<IReadOnlyList`1<string>> GetOrAddFiles(string expandedPath);
    public virtual Lazy`1<string> GetOrAddSha512(string sha512Path);
    public virtual bool Sha512Exists(string sha512Path);
    public void UpdateLastAccessTime(string nupkgMetadataPath);
    public virtual Lazy`1<RuntimeGraph> GetOrAddRuntimeGraph(string expandedPath);
    private static IReadOnlyList`1<string> GetFiles(string expandedPath);
    private static bool IsAllowedLibraryFile(string path);
    private static NuspecReader GetNuspec(string manifestPath, string expandedPath);
    private RuntimeGraph GetRuntimeGraph(string expandedPath);
    [CompilerGeneratedAttribute]
private Lazy`1<RuntimeGraph> <GetOrAddRuntimeGraph>b__12_0(string p);
}
internal class NuGet.Protocol.LocalPackageInfo : object {
    private Lazy`1<NuspecReader> _nuspecHelper;
    private Func`1<PackageReaderBase> _getPackageReader;
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTimeUtc>k__BackingField;
    public PackageIdentity Identity { get; }
    public string Path { get; }
    public DateTime LastWriteTimeUtc { get; }
    public NuspecReader Nuspec { get; }
    public bool IsNupkg { get; }
    [ObsoleteAttribute("use other constructor")]
public LocalPackageInfo(PackageIdentity identity, string path, DateTime lastWriteTimeUtc, Lazy`1<NuspecReader> nuspec, Func`1<PackageReaderBase> getPackageReader);
    public LocalPackageInfo(PackageIdentity identity, string path, DateTime lastWriteTimeUtc, Lazy`1<NuspecReader> nuspec, bool useFolder);
    [CompilerGeneratedAttribute]
public virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
public virtual DateTime get_LastWriteTimeUtc();
    public virtual PackageReaderBase GetReader();
    public virtual NuspecReader get_Nuspec();
    public virtual bool get_IsNupkg();
}
internal class NuGet.Protocol.LocalPackageListResource : ListResource {
    private PackageSearchResource _localPackageSearchResource;
    private string _baseAddress;
    public string Source { get; }
    public LocalPackageListResource(PackageSearchResource localPackageSearchResource, string baseAddress);
    public virtual string get_Source();
    public virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.LocalPackageMetadataResource : PackageMetadataResource {
    private FindLocalPackagesResource _localResource;
    public LocalPackageMetadataResource(FindLocalPackagesResource localResource);
    public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private static IPackageSearchMetadata GetPackageMetadata(LocalPackageInfo package);
}
internal class NuGet.Protocol.LocalPackageMetadataResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageMetadataResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.LocalPackageSearchMetadata : object {
    private NuspecReader _nuspec;
    private LocalPackageInfo _package;
    private IReadOnlyList`1<string> _ownersList;
    private static int FiveMegabytes;
    public string Authors { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    public string Description { get; }
    public Nullable`1<long> DownloadCount { get; }
    public Uri IconUrl { get; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; }
    public Uri ProjectUrl { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; }
    public Uri PackageDetailsUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public string Summary { get; }
    public string Tags { get; }
    public string Title { get; }
    public Func`1<PackageReaderBase> PackageReader { get; }
    public bool IsListed { get; }
    public bool PrefixReserved { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public string PackagePath { get; }
    public LocalPackageSearchMetadata(LocalPackageInfo package);
    public sealed virtual string get_Authors();
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    public sealed virtual string get_Description();
    public sealed virtual Nullable`1<long> get_DownloadCount();
    public sealed virtual Uri get_IconUrl();
    public sealed virtual PackageIdentity get_Identity();
    public sealed virtual Uri get_LicenseUrl();
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    public sealed virtual string get_Owners();
    public sealed virtual Uri get_ProjectUrl();
    public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    public sealed virtual Uri get_ReadmeUrl();
    public sealed virtual Uri get_ReportAbuseUrl();
    public sealed virtual Uri get_PackageDetailsUrl();
    public sealed virtual bool get_RequireLicenseAcceptance();
    public sealed virtual string get_Summary();
    public sealed virtual string get_Tags();
    public sealed virtual string get_Title();
    public Func`1<PackageReaderBase> get_PackageReader();
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    private static Uri Convert(string uri);
    public sealed virtual bool get_IsListed();
    public sealed virtual bool get_PrefixReserved();
    public sealed virtual LicenseMetadata get_LicenseMetadata();
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    public string get_PackagePath();
    public string LoadFileAsText(string path);
    private Uri GetIconUri();
    [CompilerGeneratedAttribute]
private PackageReaderBase <get_PackageReader>b__41_0();
}
internal class NuGet.Protocol.LocalPackageSearchResource : PackageSearchResource {
    private FindLocalPackagesResource _localResource;
    public LocalPackageSearchResource(FindLocalPackagesResource localResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResource/<SearchAsync>d__2")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    private static bool ContainsAnyTerm(String[] terms, LocalPackageInfo package);
    private static bool ContainsTerm(string search, string property);
    private IPackageSearchMetadata CreatePackageSearchResult(LocalPackageInfo package, SearchFilter filter, ILogger log, CancellationToken cancellationToken);
    private static List`1<VersionInfo> GetVersions(FindLocalPackagesResource localResource, LocalPackageInfo package, SearchFilter filter, ILogger log, CancellationToken token);
    private static bool IsLocalOrUNC(string currentSource);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResource/<CollapseToHighestVersion>d__8")]
private static IEnumerable`1<LocalPackageInfo> CollapseToHighestVersion(IEnumerable`1<LocalPackageInfo> source);
}
internal class NuGet.Protocol.LocalPackageSearchResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.LocalV2FindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, IReadOnlyList`1<LocalPackageInfo>> _packageInfoCache;
    private string _source;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public LocalV2FindPackageByIdResource(PackageSource packageSource);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV2FindPackageByIdResource/<CopyNupkgToStreamAsync>d__6")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private LocalPackageInfo GetPackageInfo(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private IReadOnlyList`1<LocalPackageInfo> GetPackageInfos(string id, SourceCacheContext cacheContext, ILogger logger);
    private IReadOnlyList`1<LocalPackageInfo> GetPackageInfosCore(string id, ILogger logger);
}
internal class NuGet.Protocol.LocalV2FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV2FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.LocalV3FindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, List`1<NuGetVersion>> _cache;
    private string _source;
    private VersionFolderPathResolver _resolver;
    private LocalPackageFileCache _packageFileCache;
    private Lazy`1<bool> _rootExists;
    private bool _isFallbackFolder;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    public LocalPackageFileCache PackageFileCache { get; public set; }
    public bool IsFallbackFolder { get; public set; }
    public LocalV3FindPackageByIdResource(PackageSource packageSource);
    public LocalPackageFileCache get_PackageFileCache();
    public void set_PackageFileCache(LocalPackageFileCache value);
    public bool get_IsFallbackFolder();
    public void set_IsFallbackFolder(bool value);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV3FindPackageByIdResource/<CopyNupkgToStreamAsync>d__16")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private T ProcessNuspecReader(string id, NuGetVersion version, Func`2<NuspecReader, T> process);
    private bool DoesVersionExist(string id, NuGetVersion version);
    private List`1<NuGetVersion> GetVersions(string id, SourceCacheContext cacheContext, ILogger logger);
    private List`1<NuGetVersion> GetVersionsCore(string id, ILogger logger);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__14_0();
}
internal class NuGet.Protocol.LocalV3FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV3FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.MetadataFieldConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.MetadataReferenceCache : object {
    private Dictionary`2<string, string> _stringCache;
    private Dictionary`2<Type, PropertyInfo[]> _propertyCache;
    private Dictionary`2<string, NuGetVersion> _versionCache;
    private Type _metadataReferenceCacheType;
    private static IDictionary`2<Type, string> CachableTypesMap;
    [CompilerGeneratedAttribute]
private Dictionary`2<Type, MethodInfo> <CachableMethodTypes>k__BackingField;
    internal static IEnumerable`1<Type> CachableTypes { get; }
    internal Dictionary`2<Type, MethodInfo> CachableMethodTypes { get; }
    private static MetadataReferenceCache();
    public string GetString(string s);
    public NuGetVersion GetVersion(string s);
    internal static IEnumerable`1<Type> get_CachableTypes();
    [CompilerGeneratedAttribute]
internal Dictionary`2<Type, MethodInfo> get_CachableMethodTypes();
    public T GetObject(T input);
}
internal class NuGet.Protocol.MetadataResourceV2Feed : MetadataResource {
    private V2FeedParser _feedParser;
    private SourceRepository _source;
    public MetadataResourceV2Feed(V2FeedParser feedParser, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<GetLatestVersions>d__3")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<GetVersions>d__4")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<Exists>d__5")]
public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<Exists>d__6")]
public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.MetadataResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.MetadataResourceV3 : MetadataResource {
    private RegistrationResourceV3 _regResource;
    public MetadataResourceV3(RegistrationResourceV3 regResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<GetLatestVersions>d__2")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<Exists>d__3")]
public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<Exists>d__4")]
public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<GetVersions>d__5")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.MetadataResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.MetadataStringOrArrayConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.Model.CaseInsensitiveDictionary`1 : Dictionary`2<string, TValue> {
}
[NuGet.Protocol.NullableContextAttribute("2")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.Protocol.Model.GetVulnerabilityInfoResult : object {
    [NuGet.Protocol.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> <KnownVulnerabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregateException <Exceptions>k__BackingField;
    [NuGet.Protocol.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> KnownVulnerabilities { get; }
    public AggregateException Exceptions { get; }
    public GetVulnerabilityInfoResult(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities, AggregateException exceptions);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> get_KnownVulnerabilities();
    [CompilerGeneratedAttribute]
public AggregateException get_Exceptions();
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.Protocol.Model.PackageVulnerabilityInfo : object {
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageVulnerabilitySeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Versions>k__BackingField;
    [JsonPropertyNameAttribute("url")]
public Uri Url { get; }
    [JsonPropertyNameAttribute("severity")]
public PackageVulnerabilitySeverity Severity { get; }
    [JsonPropertyNameAttribute("versions")]
public VersionRange Versions { get; }
    [JsonConstructorAttribute]
public PackageVulnerabilityInfo(Uri url, PackageVulnerabilitySeverity severity, VersionRange versions);
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public PackageVulnerabilitySeverity get_Severity();
    [CompilerGeneratedAttribute]
public VersionRange get_Versions();
    [NuGet.Protocol.NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageVulnerabilityInfo other);
    [NuGet.Protocol.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NuGet.Protocol.Model.RegistrationIndex : object {
    [CompilerGeneratedAttribute]
private List`1<RegistrationPage> <Items>k__BackingField;
    [JsonPropertyAttribute("items")]
public List`1<RegistrationPage> Items { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<RegistrationPage> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<RegistrationPage> value);
}
internal class NuGet.Protocol.Model.RegistrationLeafItem : object {
    [CompilerGeneratedAttribute]
private PackageSearchMetadataRegistration <CatalogEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageContent>k__BackingField;
    [JsonPropertyAttribute("catalogEntry")]
public PackageSearchMetadataRegistration CatalogEntry { get; public set; }
    [JsonPropertyAttribute]
public Uri PackageContent { get; public set; }
    [CompilerGeneratedAttribute]
public PackageSearchMetadataRegistration get_CatalogEntry();
    [CompilerGeneratedAttribute]
public void set_CatalogEntry(PackageSearchMetadataRegistration value);
    [CompilerGeneratedAttribute]
public Uri get_PackageContent();
    [CompilerGeneratedAttribute]
public void set_PackageContent(Uri value);
}
internal class NuGet.Protocol.Model.RegistrationPage : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RegistrationLeafItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Lower>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Upper>k__BackingField;
    [JsonPropertyAttribute("@id")]
public string Url { get; public set; }
    [JsonPropertyAttribute("items")]
public List`1<RegistrationLeafItem> Items { get; public set; }
    [JsonPropertyAttribute("lower")]
public string Lower { get; public set; }
    [JsonPropertyAttribute("upper")]
public string Upper { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public List`1<RegistrationLeafItem> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<RegistrationLeafItem> value);
    [CompilerGeneratedAttribute]
public string get_Lower();
    [CompilerGeneratedAttribute]
public void set_Lower(string value);
    [CompilerGeneratedAttribute]
public string get_Upper();
    [CompilerGeneratedAttribute]
public void set_Upper(string value);
}
internal class NuGet.Protocol.Model.V3SearchResults : object {
    [CompilerGeneratedAttribute]
private long <TotalHits>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PackageSearchMetadata> <Data>k__BackingField;
    [JsonPropertyAttribute("totalHits")]
public long TotalHits { get; public set; }
    [JsonPropertyAttribute("data")]
public List`1<PackageSearchMetadata> Data { get; private set; }
    [CompilerGeneratedAttribute]
public long get_TotalHits();
    [CompilerGeneratedAttribute]
public void set_TotalHits(long value);
    [CompilerGeneratedAttribute]
public List`1<PackageSearchMetadata> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(List`1<PackageSearchMetadata> value);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.Protocol.Model.V3VulnerabilityIndexEntry : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Updated>k__BackingField;
    [NuGet.Protocol.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [JsonPropertyNameAttribute("@name")]
public string Name { get; }
    [JsonPropertyNameAttribute("@id")]
public Uri Url { get; }
    [JsonPropertyNameAttribute("@updated")]
public string Updated { get; }
    [NuGet.Protocol.NullableAttribute("2")]
[JsonPropertyNameAttribute("comment")]
public string Comment { get; }
    public V3VulnerabilityIndexEntry(string name, Uri url, string updated, string comment);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public string get_Updated();
    [NuGet.Protocol.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Comment();
}
internal class NuGet.Protocol.NuGetVersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class NuGet.Protocol.NullThrottle : object {
    private static NullThrottle _instance;
    public static NullThrottle Instance { get; }
    private static NullThrottle();
    public static NullThrottle get_Instance();
    public sealed virtual Task WaitAsync();
    public sealed virtual void Release();
}
internal class NuGet.Protocol.ODataServiceDocumentResourceV2 : object {
    private string _baseAddress;
    private DateTime _requestTime;
    public DateTime RequestTime { get; }
    public string BaseAddress { get; }
    public ODataServiceDocumentResourceV2(string baseAddress, DateTime requestTime);
    public virtual DateTime get_RequestTime();
    public string get_BaseAddress();
}
internal class NuGet.Protocol.ODataServiceDocumentResourceV2Provider : ResourceProvider {
    private static TimeSpan _defaultCacheDuration;
    private ConcurrentDictionary`2<string, ODataServiceDocumentCacheInfo> _cache;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCacheDuration>k__BackingField;
    public TimeSpan MaxCacheDuration { get; protected set; }
    private static ODataServiceDocumentResourceV2Provider();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxCacheDuration();
    [CompilerGeneratedAttribute]
protected void set_MaxCacheDuration(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.Protocol.ODataServiceDocumentResourceV2Provider/<TryCreate>d__8")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageDependencyGroupConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static PackageDependency LoadDependency(JToken dependency);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.PackageDeprecationMetadata : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Reasons>k__BackingField;
    [CompilerGeneratedAttribute]
private AlternatePackageMetadata <AlternatePackage>k__BackingField;
    [JsonPropertyAttribute]
public string Message { get; internal set; }
    [JsonPropertyAttribute]
public IEnumerable`1<string> Reasons { get; internal set; }
    [JsonPropertyAttribute]
public AlternatePackageMetadata AlternatePackage { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
internal void set_Message(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Reasons();
    [CompilerGeneratedAttribute]
internal void set_Reasons(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public AlternatePackageMetadata get_AlternatePackage();
    [CompilerGeneratedAttribute]
internal void set_AlternatePackage(AlternatePackageMetadata value);
}
internal class NuGet.Protocol.PackageDetailsUriResourceV3 : object {
    private string _template;
    private PackageDetailsUriResourceV3(string template);
    public static PackageDetailsUriResourceV3 CreateOrNull(string uriTemplate);
    private static bool IsValidUriTemplate(string uriTemplate);
    public Uri GetUri(string id, NuGetVersion version);
}
internal class NuGet.Protocol.PackageDetailsUriResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageDetailsUriResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageInfo : object {
    [CompilerGeneratedAttribute]
private RegistrationInfo <Registration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageContent>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DependencyInfo> <Dependencies>k__BackingField;
    public RegistrationInfo Registration { get; public set; }
    public bool Listed { get; public set; }
    public NuGetVersion Version { get; public set; }
    public Uri PackageContent { get; public set; }
    public IList`1<DependencyInfo> Dependencies { get; private set; }
    [CompilerGeneratedAttribute]
public RegistrationInfo get_Registration();
    [CompilerGeneratedAttribute]
public void set_Registration(RegistrationInfo value);
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public void set_Listed(bool value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Uri get_PackageContent();
    [CompilerGeneratedAttribute]
public void set_PackageContent(Uri value);
    [CompilerGeneratedAttribute]
public IList`1<DependencyInfo> get_Dependencies();
    [CompilerGeneratedAttribute]
private void set_Dependencies(IList`1<DependencyInfo> value);
    public virtual string ToString();
}
internal class NuGet.Protocol.PackageMetadataResourceV2Feed : PackageMetadataResource {
    private HttpSource _httpSource;
    private PackageSource _packageSource;
    private V2FeedParser _feedParser;
    public PackageMetadataResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2Feed/<GetMetadataAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2Feed/<GetMetadataAsync>d__5")]
public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.PackageMetadataResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageMetadataResourceV3 : PackageMetadataResource {
    private RegistrationResourceV3 _regResource;
    private ReportAbuseResourceV3 _reportAbuseResource;
    private PackageDetailsUriResourceV3 _packageDetailsUriResource;
    private HttpSource _client;
    public PackageMetadataResourceV3(HttpSource client, RegistrationResourceV3 regResource, ReportAbuseResourceV3 reportAbuseResource, PackageDetailsUriResourceV3 packageDetailsUriResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__5")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__6")]
public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__7")]
private Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, VersionRange range, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<DeserializeStreamDataAsync>d__8`1")]
private Task`1<T> DeserializeStreamDataAsync(Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<LoadRegistrationIndexAsync>d__9")]
private Task`1<ValueTuple`2<RegistrationIndex, HttpSourceCacheContext>> LoadRegistrationIndexAsync(HttpSource httpSource, Uri registrationUri, string packageId, SourceCacheContext cacheContext, Func`2<HttpSourceResult, Task`1<RegistrationIndex>> processAsync, ILogger log, CancellationToken token);
    private Task`1<RegistrationPage> GetRegistratioIndexPageAsync(HttpSource httpSource, string rangeUri, string packageId, NuGetVersion lower, NuGetVersion upper, HttpSourceCacheContext httpSourceCacheContext, ILogger log, CancellationToken token);
    private void ProcessRegistrationPage(RegistrationPage registrationPage, List`1<PackageSearchMetadataRegistration> results, VersionRange range, bool includePrerelease, bool includeUnlisted, MetadataReferenceCache metadataCache);
}
internal class NuGet.Protocol.PackageMetadataResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageNotFoundProtocolException : InvalidCacheProtocolException {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public PackageNotFoundProtocolException(PackageIdentity package);
    public PackageNotFoundProtocolException(PackageIdentity package, Exception innerException);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    private static string GetMessage(PackageIdentity package);
}
internal class NuGet.Protocol.PackageSearchMetadata : object {
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencySetsInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    private PackageIdentity _packageIdentity;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    private IReadOnlyList`1<string> _ownersList;
    private string _owners;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReadmeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageDetailsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    private string _summaryValue;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    private string _titleValue;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionInfo[] <ParsedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrefixReserved>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseExpressionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListed>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDeprecationMetadata <DeprecationMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageVulnerabilityMetadata> <Vulnerabilities>k__BackingField;
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Authors { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<PackageDependencyGroup> DependencySetsInternal { get; private set; }
    [JsonIgnoreAttribute]
public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    [JsonPropertyAttribute]
public string Description { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<long> DownloadCount { get; private set; }
    [JsonPropertyAttribute]
public Uri IconUrl { get; private set; }
    [JsonIgnoreAttribute]
public PackageIdentity Identity { get; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri LicenseUrl { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataStringOrArrayConverter")]
public IReadOnlyList`1<string> OwnersList { get; private set; }
    public string Owners { get; }
    [JsonPropertyAttribute]
public string PackageId { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri ProjectUrl { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<DateTimeOffset> Published { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri ReadmeUrl { get; private set; }
    [JsonIgnoreAttribute]
public Uri ReportAbuseUrl { get; public set; }
    [JsonIgnoreAttribute]
public Uri PackageDetailsUrl { get; public set; }
    [JsonPropertyAttribute]
[DefaultValueAttribute("False")]
[JsonConverterAttribute("NuGet.Protocol.SafeBoolConverter")]
public bool RequireLicenseAcceptance { get; private set; }
    [JsonPropertyAttribute]
public string Summary { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Tags { get; private set; }
    [JsonPropertyAttribute]
public string Title { get; private set; }
    [JsonPropertyAttribute]
public NuGetVersion Version { get; private set; }
    [JsonPropertyAttribute]
public VersionInfo[] ParsedVersions { get; private set; }
    [JsonPropertyAttribute]
public bool PrefixReserved { get; private set; }
    [JsonPropertyAttribute]
public string LicenseExpression { get; private set; }
    [JsonPropertyAttribute]
public string LicenseExpressionVersion { get; private set; }
    [JsonIgnoreAttribute]
public LicenseMetadata LicenseMetadata { get; }
    [JsonPropertyAttribute]
public bool IsListed { get; private set; }
    [JsonPropertyAttribute]
public PackageDeprecationMetadata DeprecationMetadata { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependencyGroup> get_DependencySetsInternal();
    [CompilerGeneratedAttribute]
private void set_DependencySetsInternal(IEnumerable`1<PackageDependencyGroup> value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
private void set_IconUrl(Uri value);
    public sealed virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
private void set_LicenseUrl(Uri value);
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    private void set_OwnersList(IReadOnlyList`1<string> value);
    public sealed virtual string get_Owners();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
private void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
private void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
private void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReadmeUrl();
    [CompilerGeneratedAttribute]
private void set_ReadmeUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
public void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_PackageDetailsUrl();
    [CompilerGeneratedAttribute]
public void set_PackageDetailsUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
private void set_RequireLicenseAcceptance(bool value);
    public sealed virtual string get_Summary();
    private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(string value);
    public sealed virtual string get_Title();
    private void set_Title(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public VersionInfo[] get_ParsedVersions();
    [CompilerGeneratedAttribute]
private void set_ParsedVersions(VersionInfo[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PrefixReserved();
    [CompilerGeneratedAttribute]
private void set_PrefixReserved(bool value);
    [CompilerGeneratedAttribute]
public string get_LicenseExpression();
    [CompilerGeneratedAttribute]
private void set_LicenseExpression(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseExpressionVersion();
    [CompilerGeneratedAttribute]
private void set_LicenseExpressionVersion(string value);
    public sealed virtual LicenseMetadata get_LicenseMetadata();
    private static IList`1<string> GetNonStandardLicenseIdentifiers(NuGetLicenseExpression expression);
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsListed();
    [CompilerGeneratedAttribute]
private void set_IsListed(bool value);
    [CompilerGeneratedAttribute]
public PackageDeprecationMetadata get_DeprecationMetadata();
    [CompilerGeneratedAttribute]
private void set_DeprecationMetadata(PackageDeprecationMetadata value);
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    [CompilerGeneratedAttribute]
private void set_Vulnerabilities(IEnumerable`1<PackageVulnerabilityMetadata> value);
}
internal class NuGet.Protocol.PackageSearchMetadataRegistration : PackageSearchMetadata {
    [CompilerGeneratedAttribute]
private Uri <CatalogUri>k__BackingField;
    [JsonPropertyAttribute]
public Uri CatalogUri { get; private set; }
    [CompilerGeneratedAttribute]
public Uri get_CatalogUri();
    [CompilerGeneratedAttribute]
private void set_CatalogUri(Uri value);
}
internal class NuGet.Protocol.PackageSearchMetadataV2Feed : object {
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencySets>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    private IReadOnlyList`1<string> _ownersList;
    [CompilerGeneratedAttribute]
private string <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastEdited>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReadmeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageDetailsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    private string _summaryValue;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    private string _titleValue;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageDeprecationMetadata <DeprecationMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageVulnerabilityMetadata> <Vulnerabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListed>k__BackingField;
    public string Authors { get; private set; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; private set; }
    public string Description { get; private set; }
    public Nullable`1<long> DownloadCount { get; private set; }
    public Uri IconUrl { get; private set; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; private set; }
    public IReadOnlyList`1<string> OwnersList { get; }
    public string Owners { get; private set; }
    public string PackageId { get; private set; }
    public Uri ProjectUrl { get; private set; }
    public bool PrefixReserved { get; }
    public Nullable`1<DateTimeOffset> Created { get; private set; }
    public Nullable`1<DateTimeOffset> LastEdited { get; private set; }
    public Nullable`1<DateTimeOffset> Published { get; private set; }
    public Uri ReadmeUrl { get; }
    public Uri ReportAbuseUrl { get; private set; }
    public Uri PackageDetailsUrl { get; private set; }
    public bool RequireLicenseAcceptance { get; private set; }
    public string Summary { get; private set; }
    public string Tags { get; private set; }
    public string Title { get; private set; }
    public LicenseMetadata LicenseMetadata { get; }
    public PackageDeprecationMetadata DeprecationMetadata { get; }
    public NuGetVersion Version { get; private set; }
    public IEnumerable`1<PackageVulnerabilityMetadata> Vulnerabilities { get; }
    public bool IsListed { get; }
    public PackageSearchMetadataV2Feed(V2FeedPackageInfo package);
    public PackageSearchMetadataV2Feed(V2FeedPackageInfo package, MetadataReferenceCache metadataCache);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    [CompilerGeneratedAttribute]
private void set_DependencySets(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
private void set_IconUrl(Uri value);
    public sealed virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
private void set_LicenseUrl(Uri value);
    public sealed virtual IReadOnlyList`1<string> get_OwnersList();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(string value);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
private void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
private void set_ProjectUrl(Uri value);
    public sealed virtual bool get_PrefixReserved();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Created();
    [CompilerGeneratedAttribute]
private void set_Created(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastEdited();
    [CompilerGeneratedAttribute]
private void set_LastEdited(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
private void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReadmeUrl();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
private void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_PackageDetailsUrl();
    [CompilerGeneratedAttribute]
private void set_PackageDetailsUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
private void set_RequireLicenseAcceptance(bool value);
    public sealed virtual string get_Summary();
    private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(string value);
    public sealed virtual string get_Title();
    private void set_Title(string value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public PackageDeprecationMetadata get_DeprecationMetadata();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    private static Uri GetUriSafe(string url);
    public sealed virtual Task`1<PackageDeprecationMetadata> GetDeprecationMetadataAsync();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageVulnerabilityMetadata> get_Vulnerabilities();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsListed();
}
internal class NuGet.Protocol.PackageSearchResourceV2Feed : PackageSearchResource {
    private HttpSource _httpSource;
    private PackageSource _packageSource;
    private V2FeedParser _feedParser;
    public PackageSearchResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV2Feed/<SearchAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.PackageSearchResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageSearchResourceV3 : PackageSearchResource {
    private HttpSource _client;
    private Uri[] _searchEndpoints;
    private RawSearchResourceV3 _rawSearchResource;
    [ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public PackageSearchResourceV3(RawSearchResourceV3 searchResource);
    internal PackageSearchResourceV3(HttpSource client, IEnumerable`1<Uri> searchEndpoints);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<SearchAsync>d__5")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filter, int skip, int take, ILogger log, CancellationToken cancellationToken);
    private static IEnumerable`1<VersionInfo> GetVersions(PackageSearchMetadata metadata, SearchFilter filter);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<SearchPage>d__7`1")]
private Task`1<T> SearchPage(Func`2<Uri, Task`1<T>> getResultAsync, string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<Search>d__8`1")]
private Task`1<T> Search(Func`3<HttpSource, Uri, Task`1<T>> getResultAsync, string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<Search>d__9")]
internal Task`1<IEnumerable`1<PackageSearchMetadata>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<ProcessHttpStreamTakeCountedItemAsync>d__10")]
internal Task`1<IEnumerable`1<PackageSearchMetadata>> ProcessHttpStreamTakeCountedItemAsync(HttpResponseMessage httpInitialResponse, int take, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<ProcessHttpStreamWithoutBufferingAsync>d__11")]
private Task`1<V3SearchResults> ProcessHttpStreamWithoutBufferingAsync(HttpResponseMessage httpInitialResponse, UInt32 take, CancellationToken token);
}
internal class NuGet.Protocol.PackageSearchResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageUpdateResourceV2Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageUpdateResourceV2Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.PackageUpdateResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageUpdateResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.PackageUtilities : object {
    internal static NuspecReader OpenNuspecFromNupkg(string id, Stream nupkgStream, ILogger log);
}
internal class NuGet.Protocol.PackageVulnerabilityMetadata : object {
    [CompilerGeneratedAttribute]
private Uri <AdvisoryUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Severity>k__BackingField;
    [JsonPropertyAttribute]
public Uri AdvisoryUrl { get; internal set; }
    [JsonPropertyAttribute]
public int Severity { get; internal set; }
    [CompilerGeneratedAttribute]
public Uri get_AdvisoryUrl();
    [CompilerGeneratedAttribute]
internal void set_AdvisoryUrl(Uri value);
    [CompilerGeneratedAttribute]
public int get_Severity();
    [CompilerGeneratedAttribute]
internal void set_Severity(int value);
}
internal enum NuGet.Protocol.PackageVulnerabilitySeverity : Enum {
    public int value__;
    public static PackageVulnerabilitySeverity Low;
    public static PackageVulnerabilitySeverity Moderate;
    public static PackageVulnerabilitySeverity High;
    public static PackageVulnerabilitySeverity Critical;
    public static PackageVulnerabilitySeverity Unknown;
}
internal class NuGet.Protocol.PluginFindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PluginFindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken cancellationToken);
    private static void AddOrUpdateGetCredentialsRequestHandler(IPlugin plugin, SourceRepository source, HttpHandlerResource httpHandlerResource);
    private static void AddOrUpdateGetServiceIndexRequestHandler(IPlugin plugin, SourceRepository source);
}
internal class NuGet.Protocol.Plugins.AssemblyLogMessage : PluginLogMessage {
    private string _fileVersion;
    private string _fullName;
    private string _informationalVersion;
    private string _entryAssemblyFullName;
    internal AssemblyLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
internal class NuGet.Protocol.Plugins.AutomaticProgressReporter : object {
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private bool _isDisposed;
    private Message _request;
    private SemaphoreSlim _semaphore;
    private Timer _timer;
    private AutomaticProgressReporter(IConnection connection, Message request, TimeSpan interval, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public static AutomaticProgressReporter Create(IConnection connection, Message request, TimeSpan interval, CancellationToken cancellationToken);
    private void OnTimer(object state);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.AutomaticProgressReporter/<<OnTimer>b__10_0>d")]
[CompilerGeneratedAttribute]
private Task <OnTimer>b__10_0();
}
internal class NuGet.Protocol.Plugins.CloseRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    public CancellationToken CancellationToken { get; }
    public CloseRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Plugins.CommunicationLogMessage : PluginLogMessage {
    private MessageMethod _method;
    private string _requestId;
    private MessageState _state;
    private MessageType _type;
    internal CommunicationLogMessage(DateTimeOffset now, string requestId, MessageMethod method, MessageType type, MessageState state);
    public virtual string ToString();
}
internal class NuGet.Protocol.Plugins.Connection : object {
    private bool _isDisposed;
    private IReceiver _receiver;
    private ISender _sender;
    private IPluginLogger _logger;
    private int _state;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProtocolErrorEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<MessageEventArgs> MessageReceived;
    [CompilerGeneratedAttribute]
private IMessageDispatcher <MessageDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    public ConnectionState State { get; }
    public IMessageDispatcher MessageDispatcher { get; }
    public ConnectionOptions Options { get; }
    public SemanticVersion ProtocolVersion { get; private set; }
    public Connection(IMessageDispatcher dispatcher, ISender sender, IReceiver receiver, ConnectionOptions options);
    internal Connection(IMessageDispatcher dispatcher, ISender sender, IReceiver receiver, ConnectionOptions options, IPluginLogger logger);
    public ConnectionState get_State();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IMessageDispatcher get_MessageDispatcher();
    [CompilerGeneratedAttribute]
public sealed virtual ConnectionOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
private void set_ProtocolVersion(SemanticVersion value);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.Connection/<ConnectAsync>d__27")]
public Task ConnectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.Connection/<SendAsync>d__28")]
public sealed virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    public sealed virtual Task`1<TInbound> SendRequestAndReceiveResponseAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    private void OnMessageReceived(object sender, MessageEventArgs e);
    private void OnFaulted(object sender, ProtocolErrorEventArgs e);
}
internal class NuGet.Protocol.Plugins.ConnectionOptions : object {
    [CompilerGeneratedAttribute]
private TimeSpan <HandshakeTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <MinimumProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    public TimeSpan HandshakeTimeout { get; }
    public SemanticVersion MinimumProtocolVersion { get; }
    public SemanticVersion ProtocolVersion { get; }
    public TimeSpan RequestTimeout { get; private set; }
    public ConnectionOptions(SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion, TimeSpan handshakeTimeout, TimeSpan requestTimeout);
    [CompilerGeneratedAttribute]
public TimeSpan get_HandshakeTimeout();
    [CompilerGeneratedAttribute]
public SemanticVersion get_MinimumProtocolVersion();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
private void set_RequestTimeout(TimeSpan value);
    public void SetRequestTimeout(TimeSpan requestTimeout);
    public static ConnectionOptions CreateDefault(IEnvironmentVariableReader reader);
}
internal enum NuGet.Protocol.Plugins.ConnectionState : Enum {
    public int value__;
    public static ConnectionState FailedToHandshake;
    public static ConnectionState Closing;
    public static ConnectionState Closed;
    public static ConnectionState ReadyToConnect;
    public static ConnectionState Connecting;
    public static ConnectionState Handshaking;
    public static ConnectionState Connected;
}
internal class NuGet.Protocol.Plugins.CopyFilesInPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <DestinationFolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FilesInPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string DestinationFolderPath { get; }
    [JsonRequiredAttribute]
public IEnumerable`1<string> FilesInPackage { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public CopyFilesInPackageRequest(string packageSourceRepository, string packageId, string packageVersion, IEnumerable`1<string> filesInPackage, string destinationFolderPath);
    [CompilerGeneratedAttribute]
public string get_DestinationFolderPath();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FilesInPackage();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
internal class NuGet.Protocol.Plugins.CopyFilesInPackageResponse : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CopiedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public IEnumerable`1<string> CopiedFiles { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public CopyFilesInPackageResponse(MessageResponseCode responseCode, IEnumerable`1<string> copiedFiles);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CopiedFiles();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.CopyNupkgFileRequest : object {
    [CompilerGeneratedAttribute]
private string <DestinationFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string DestinationFilePath { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public CopyNupkgFileRequest(string packageSourceRepository, string packageId, string packageVersion, string destinationFilePath);
    [CompilerGeneratedAttribute]
public string get_DestinationFilePath();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
internal class NuGet.Protocol.Plugins.CopyNupkgFileResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public CopyNupkgFileResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal abstract class NuGet.Protocol.Plugins.EmbeddedSignatureVerifier : object {
    public abstract virtual bool IsValid(string filePath);
    public static EmbeddedSignatureVerifier Create();
}
internal static class NuGet.Protocol.Plugins.EnvironmentVariableConstants : object {
    internal static string EnableLog;
    internal static string LogDirectoryPath;
    internal static string HandshakeTimeout;
    internal static string IdleTimeout;
    internal static string PluginPaths;
    internal static string RequestTimeout;
    internal static string DesktopPluginPaths;
    internal static string CorePluginPaths;
}
internal class NuGet.Protocol.Plugins.EnvironmentVariablesLogMessage : PluginLogMessage {
    private Nullable`1<int> _handshakeTimeout;
    private Nullable`1<int> _idleTimeout;
    private Nullable`1<int> _requestTimeout;
    internal EnvironmentVariablesLogMessage(DateTimeOffset now, IEnvironmentVariableReader environmentVariableReader);
    public virtual string ToString();
    private static Nullable`1<int> Read(IEnvironmentVariableReader reader, string variableName);
}
internal class NuGet.Protocol.Plugins.FallbackEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    public virtual bool IsValid(string filePath);
}
internal class NuGet.Protocol.Plugins.Fault : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonRequiredAttribute]
public string Message { get; }
    [JsonConstructorAttribute]
public Fault(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
internal class NuGet.Protocol.Plugins.FaultedPluginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    public Exception Exception { get; }
    public IPlugin Plugin { get; }
    public FaultedPluginEventArgs(IPlugin plugin, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
}
internal class NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanShowDialog>k__BackingField;
    [JsonRequiredAttribute]
public Uri Uri { get; }
    [JsonRequiredAttribute]
public bool IsRetry { get; }
    [JsonRequiredAttribute]
public bool IsNonInteractive { get; }
    [JsonRequiredAttribute]
public bool CanShowDialog { get; }
    [JsonConstructorAttribute]
public GetAuthenticationCredentialsRequest(Uri uri, bool isRetry, bool isNonInteractive, bool canShowDialog);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
public bool get_IsNonInteractive();
    [CompilerGeneratedAttribute]
public bool get_CanShowDialog();
}
internal class NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <AuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public string Username { get; }
    public string Password { get; }
    public string Message { get; }
    public IList`1<string> AuthenticationTypes { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetAuthenticationCredentialsResponse(string username, string password, string message, IList`1<string> authenticationTypes, MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public IList`1<string> get_AuthenticationTypes();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    public bool IsValid();
}
internal class NuGet.Protocol.Plugins.GetCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public HttpStatusCode StatusCode { get; }
    [JsonConstructorAttribute]
public GetCredentialsRequest(string packageSourceRepository, HttpStatusCode statusCode);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
}
internal class NuGet.Protocol.Plugins.GetCredentialsRequestHandler : object {
    private static string _basicAuthenticationType;
    private ICredentialService _credentialService;
    private bool _isDisposed;
    private IPlugin _plugin;
    private IWebProxy _proxy;
    private ConcurrentDictionary`2<string, SourceRepository> _repositories;
    public CancellationToken CancellationToken { get; }
    public GetCredentialsRequestHandler(IPlugin plugin, IWebProxy proxy, ICredentialService credentialService);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public void AddOrUpdateSourceRepository(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<HandleResponseAsync>d__11")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetCredentialAsync>d__12")]
private Task`1<ICredentials> GetCredentialAsync(PackageSource packageSource, HttpStatusCode statusCode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetPackageSourceCredential>d__13")]
private Task`1<ICredentials> GetPackageSourceCredential(CredentialRequestType requestType, PackageSource packageSource, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetCredentialsRequestHandler/<GetProxyCredentialAsync>d__14")]
private Task`1<ICredentials> GetProxyCredentialAsync(PackageSource packageSource, CancellationToken cancellationToken);
    private static CredentialRequestType GetCredentialRequestType(HttpStatusCode statusCode);
    private PackageSource GetPackageSource(string packageSourceRepository);
}
internal class NuGet.Protocol.Plugins.GetCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AuthenticationTypes>k__BackingField;
    public string Password { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public string Username { get; }
    public IReadOnlyList`1<string> AuthenticationTypes { get; }
    [JsonConstructorAttribute]
public GetCredentialsResponse(MessageResponseCode responseCode, string username, string password, IReadOnlyList`1<string> authenticationTypes);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AuthenticationTypes();
}
internal class NuGet.Protocol.Plugins.GetFilesInPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public GetFilesInPackageRequest(string packageSourceRepository, string packageId, string packageVersion);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
internal class NuGet.Protocol.Plugins.GetFilesInPackageResponse : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public IEnumerable`1<string> Files { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetFilesInPackageResponse(MessageResponseCode responseCode, IEnumerable`1<string> files);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Files();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.GetOperationClaimsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <ServiceIndex>k__BackingField;
    public string PackageSourceRepository { get; }
    public JObject ServiceIndex { get; }
    [JsonConstructorAttribute]
public GetOperationClaimsRequest(string packageSourceRepository, JObject serviceIndex);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public JObject get_ServiceIndex();
}
internal class NuGet.Protocol.Plugins.GetOperationClaimsResponse : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <Claims>k__BackingField;
    [JsonRequiredAttribute]
public IReadOnlyList`1<OperationClaim> Claims { get; }
    [JsonConstructorAttribute]
public GetOperationClaimsResponse(IEnumerable`1<OperationClaim> claims);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_Claims();
}
internal class NuGet.Protocol.Plugins.GetPackageHashRequest : object {
    [CompilerGeneratedAttribute]
private string <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string HashAlgorithm { get; }
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public GetPackageHashRequest(string packageSourceRepository, string packageId, string packageVersion, string hashAlgorithm);
    [CompilerGeneratedAttribute]
public string get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
internal class NuGet.Protocol.Plugins.GetPackageHashResponse : object {
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    public string Hash { get; }
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public GetPackageHashResponse(MessageResponseCode responseCode, string hash);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.GetPackageVersionsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonConstructorAttribute]
public GetPackageVersionsRequest(string packageSourceRepository, string packageId);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
}
internal class NuGet.Protocol.Plugins.GetPackageVersionsResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Versions>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public IEnumerable`1<string> Versions { get; }
    [JsonConstructorAttribute]
public GetPackageVersionsResponse(MessageResponseCode responseCode, IEnumerable`1<string> versions);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Versions();
}
internal class NuGet.Protocol.Plugins.GetServiceIndexRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonConstructorAttribute]
public GetServiceIndexRequest(string packageSourceRepository);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
}
internal class NuGet.Protocol.Plugins.GetServiceIndexRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    private ConcurrentDictionary`2<string, SourceRepository> _repositories;
    public CancellationToken CancellationToken { get; }
    public GetServiceIndexRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    public void AddOrUpdateSourceRepository(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.GetServiceIndexRequestHandler/<HandleResponseAsync>d__8")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Plugins.GetServiceIndexResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <ServiceIndex>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public JObject ServiceIndex { get; }
    [JsonConstructorAttribute]
public GetServiceIndexResponse(MessageResponseCode responseCode, JObject serviceIndex);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public JObject get_ServiceIndex();
}
internal class NuGet.Protocol.Plugins.HandshakeRequest : object {
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <MinimumProtocolVersion>k__BackingField;
    [JsonRequiredAttribute]
public SemanticVersion ProtocolVersion { get; }
    [JsonRequiredAttribute]
public SemanticVersion MinimumProtocolVersion { get; }
    [JsonConstructorAttribute]
public HandshakeRequest(SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion);
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public SemanticVersion get_MinimumProtocolVersion();
}
internal class NuGet.Protocol.Plugins.HandshakeResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ProtocolVersion>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    public SemanticVersion ProtocolVersion { get; }
    [JsonConstructorAttribute]
public HandshakeResponse(MessageResponseCode responseCode, SemanticVersion protocolVersion);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ProtocolVersion();
}
internal interface NuGet.Protocol.Plugins.IConnection {
    public IMessageDispatcher MessageDispatcher { get; }
    public ConnectionOptions Options { get; }
    public SemanticVersion ProtocolVersion { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public abstract virtual IMessageDispatcher get_MessageDispatcher();
    public abstract virtual ConnectionOptions get_Options();
    public abstract virtual SemanticVersion get_ProtocolVersion();
    public abstract virtual void Close();
    public abstract virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    public abstract virtual Task`1<TInbound> SendRequestAndReceiveResponseAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
}
internal interface NuGet.Protocol.Plugins.IIdGenerator {
    public abstract virtual string GenerateUniqueId();
}
internal interface NuGet.Protocol.Plugins.IMessageDispatcher {
    public IRequestHandlers RequestHandlers { get; }
    public abstract virtual IRequestHandlers get_RequestHandlers();
    public abstract virtual void Close();
    public abstract virtual Message CreateMessage(MessageType type, MessageMethod method);
    public abstract virtual Message CreateMessage(MessageType type, MessageMethod method, TPayload payload);
    public abstract virtual Task DispatchCancelAsync(Message request, CancellationToken cancellationToken);
    public abstract virtual Task DispatchFaultAsync(Message request, Fault fault, CancellationToken cancellationToken);
    public abstract virtual Task DispatchProgressAsync(Message request, Progress progress, CancellationToken cancellationToken);
    public abstract virtual Task`1<TInbound> DispatchRequestAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    public abstract virtual Task DispatchResponseAsync(Message request, TOutbound responsePayload, CancellationToken cancellationToken);
    public abstract virtual void SetConnection(IConnection connection);
}
internal class NuGet.Protocol.Plugins.InboundRequestContext : object {
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private bool _isDisposed;
    private IPluginLogger _logger;
    private InboundRequestProcessingHandler _inboundRequestProcessingHandler;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    public string RequestId { get; }
    public InboundRequestContext(IConnection connection, string requestId, CancellationToken cancellationToken);
    internal InboundRequestContext(IConnection connection, string requestId, CancellationToken cancellationToken, InboundRequestProcessingHandler inboundRequestProcessingHandler, IPluginLogger logger);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.InboundRequestContext/<ProcessResponseAsync>d__11")]
private Task ProcessResponseAsync(IRequestHandler requestHandler, Message request, IResponseHandler responseHandler);
    public sealed virtual void Dispose();
    public void BeginFaultAsync(Message request, Exception exception);
    public void BeginResponseAsync(Message request, IRequestHandler requestHandler, IResponseHandler responseHandler);
    public void Cancel();
}
internal class NuGet.Protocol.Plugins.InboundRequestProcessingHandler : object {
    private ISet`1<MessageMethod> _fastProccessingMethods;
    private Lazy`1<DedicatedAsynchronousProcessingThread> _processingThread;
    private bool _isDisposed;
    public InboundRequestProcessingHandler(IEnumerable`1<MessageMethod> fastProcessingMethods);
    internal void Handle(MessageMethod messageMethod, Func`1<Task> task, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
internal class NuGet.Protocol.Plugins.InitializeRequest : object {
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [JsonRequiredAttribute]
public string ClientVersion { get; }
    [JsonRequiredAttribute]
public string Culture { get; }
    [JsonRequiredAttribute]
public TimeSpan RequestTimeout { get; }
    [JsonConstructorAttribute]
public InitializeRequest(string clientVersion, string culture, TimeSpan requestTimeout);
    [CompilerGeneratedAttribute]
public string get_ClientVersion();
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
}
internal class NuGet.Protocol.Plugins.InitializeResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public InitializeResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal interface NuGet.Protocol.Plugins.IPlugin {
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler value);
    public abstract virtual IConnection get_Connection();
    public abstract virtual string get_FilePath();
    public abstract virtual string get_Id();
    public abstract virtual string get_Name();
    public abstract virtual void Close();
}
internal interface NuGet.Protocol.Plugins.IPluginDiscoverer {
    public abstract virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> DiscoverAsync(CancellationToken cancellationToken);
}
internal interface NuGet.Protocol.Plugins.IPluginFactory {
    public abstract virtual Task`1<IPlugin> GetOrCreateAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
}
internal interface NuGet.Protocol.Plugins.IPluginLogger {
    public bool IsEnabled { get; }
    public DateTimeOffset Now { get; }
    public abstract virtual bool get_IsEnabled();
    public abstract virtual DateTimeOffset get_Now();
    public abstract virtual void Write(IPluginLogMessage message);
}
internal interface NuGet.Protocol.Plugins.IPluginLogMessage {
}
internal interface NuGet.Protocol.Plugins.IPluginManager {
    public abstract virtual Task`1<IEnumerable`1<PluginCreationResult>> CreatePluginsAsync(SourceRepository source, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> FindAvailablePluginsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Tuple`2<bool, PluginCreationResult>> TryGetSourceAgnosticPluginAsync(PluginDiscoveryResult pluginDiscoveryResult, OperationClaim requestedOperationClaim, CancellationToken cancellationToken);
}
internal interface NuGet.Protocol.Plugins.IPluginMulticlientUtilities {
    public abstract virtual Task DoOncePerPluginLifetimeAsync(string key, Func`1<Task> taskFunc, CancellationToken cancellationToken);
}
internal interface NuGet.Protocol.Plugins.IPluginProcess {
    public Nullable`1<int> ExitCode { get; }
    public Nullable`1<int> Id { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Exited(EventHandler`1<IPluginProcess> value);
    public abstract virtual Nullable`1<int> get_ExitCode();
    public abstract virtual Nullable`1<int> get_Id();
    public abstract virtual void BeginReadLine();
    public abstract virtual void CancelRead();
    public abstract virtual void Kill();
}
internal interface NuGet.Protocol.Plugins.IReceiver {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public abstract virtual void Close();
    public abstract virtual void Connect();
}
internal interface NuGet.Protocol.Plugins.IRequestHandler {
    public CancellationToken CancellationToken { get; }
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
}
internal interface NuGet.Protocol.Plugins.IRequestHandlers {
    public abstract virtual void AddOrUpdate(MessageMethod method, Func`1<IRequestHandler> addHandlerFunc, Func`2<IRequestHandler, IRequestHandler> updateHandlerFunc);
    public abstract virtual bool TryAdd(MessageMethod method, IRequestHandler handler);
    public abstract virtual bool TryGet(MessageMethod method, IRequestHandler& handler);
    public abstract virtual bool TryRemove(MessageMethod method);
}
internal interface NuGet.Protocol.Plugins.IResponseHandler {
    public abstract virtual Task SendResponseAsync(Message request, TPayload payload, CancellationToken cancellationToken);
}
internal interface NuGet.Protocol.Plugins.ISender {
    public abstract virtual void Close();
    public abstract virtual void Connect();
    public abstract virtual Task SendAsync(Message message, CancellationToken cancellationToken);
}
internal static class NuGet.Protocol.Plugins.JsonSerializationUtilities : object {
    [CompilerGeneratedAttribute]
private static JsonSerializer <Serializer>k__BackingField;
    public static JsonSerializer Serializer { get; }
    private static JsonSerializationUtilities();
    [CompilerGeneratedAttribute]
public static JsonSerializer get_Serializer();
    public static T Deserialize(string json);
    public static JObject FromObject(object value);
    public static void Serialize(JsonWriter writer, object value);
    public static T ToObject(JObject jObject);
}
internal class NuGet.Protocol.Plugins.LineReadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Line>k__BackingField;
    public string Line { get; }
    public LineReadEventArgs(string line);
    [CompilerGeneratedAttribute]
public string get_Line();
}
internal class NuGet.Protocol.Plugins.LogRequest : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonRequiredAttribute]
public LogLevel LogLevel { get; }
    [JsonRequiredAttribute]
public string Message { get; }
    [JsonConstructorAttribute]
public LogRequest(LogLevel logLevel, string message);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public string get_Message();
}
internal class NuGet.Protocol.Plugins.LogRequestHandler : object {
    private ILogger _logger;
    private LogLevel _logLevel;
    public CancellationToken CancellationToken { get; }
    public LogRequestHandler(ILogger logger);
    public sealed virtual CancellationToken get_CancellationToken();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.LogRequestHandler/<HandleResponseAsync>d__5")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    public void SetLogger(ILogger logger);
    public static LogLevel GetLogLevel(ILogger logger);
    private void Log(LogRequest request);
}
internal class NuGet.Protocol.Plugins.LogResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public LogResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.MachineLogMessage : PluginLogMessage {
    private int _logicalProcessorCount;
    internal MachineLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
internal class NuGet.Protocol.Plugins.Message : object {
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private JObject <Payload>k__BackingField;
    [JsonRequiredAttribute]
public string RequestId { get; }
    [JsonRequiredAttribute]
public MessageType Type { get; }
    [JsonRequiredAttribute]
public MessageMethod Method { get; }
    public JObject Payload { get; }
    [JsonConstructorAttribute]
public Message(string requestId, MessageType type, MessageMethod method, JObject payload);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
public MessageType get_Type();
    [CompilerGeneratedAttribute]
public MessageMethod get_Method();
    [CompilerGeneratedAttribute]
public JObject get_Payload();
}
internal class NuGet.Protocol.Plugins.MessageDispatcher : object {
    private IConnection _connection;
    private IIdGenerator _idGenerator;
    private bool _isClosed;
    private bool _isDisposed;
    private ConcurrentDictionary`2<string, InboundRequestContext> _inboundRequestContexts;
    private IPluginLogger _logger;
    private ConcurrentDictionary`2<string, OutboundRequestContext> _outboundRequestContexts;
    private InboundRequestProcessingHandler _inboundRequestProcessingContext;
    [CompilerGeneratedAttribute]
private IRequestHandlers <RequestHandlers>k__BackingField;
    public IRequestHandlers RequestHandlers { get; }
    public MessageDispatcher(IRequestHandlers requestHandlers, IIdGenerator idGenerator);
    internal MessageDispatcher(IRequestHandlers requestHandlers, IIdGenerator idGenerator, InboundRequestProcessingHandler inboundRequestProcessingHandler, IPluginLogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual IRequestHandlers get_RequestHandlers();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual Message CreateMessage(MessageType type, MessageMethod method);
    public sealed virtual Message CreateMessage(MessageType type, MessageMethod method, TPayload payload);
    public sealed virtual Task DispatchCancelAsync(Message request, CancellationToken cancellationToken);
    public sealed virtual Task DispatchFaultAsync(Message request, Fault fault, CancellationToken cancellationToken);
    public sealed virtual Task DispatchProgressAsync(Message request, Progress progress, CancellationToken cancellationToken);
    public sealed virtual Task`1<TInbound> DispatchRequestAsync(MessageMethod method, TOutbound payload, CancellationToken cancellationToken);
    public sealed virtual Task DispatchResponseAsync(Message request, TOutbound responsePayload, CancellationToken cancellationToken);
    public sealed virtual void SetConnection(IConnection connection);
    private sealed virtual override Task NuGet.Protocol.Plugins.IResponseHandler.SendResponseAsync(Message request, TPayload payload, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchAsync>d__24`1")]
private Task DispatchAsync(IConnection connection, MessageType type, Message request, TOutgoing payload, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchCancelAsync>d__25")]
private Task DispatchCancelAsync(IConnection connection, Message request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchFaultAsync>d__26")]
private Task DispatchFaultAsync(IConnection connection, Message request, Fault fault, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchProgressAsync>d__27")]
private Task DispatchProgressAsync(IConnection connection, Message request, Progress progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchWithExistingContextAsync>d__28")]
private Task DispatchWithExistingContextAsync(IConnection connection, Message response, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MessageDispatcher/<DispatchWithNewContextAsync>d__29`2")]
private Task`1<TIncoming> DispatchWithNewContextAsync(IConnection connection, MessageType type, MessageMethod method, TOutgoing payload, CancellationToken cancellationToken);
    private void OnMessageReceived(object sender, MessageEventArgs e);
    private void HandleInboundCancel(Message message);
    private void HandleInboundFault(Message fault);
    private void HandleInboundRequest(Message message);
    private IRequestHandler GetInboundRequestHandler(MessageMethod method);
    private OutboundRequestContext GetOutboundRequestContext(string requestId);
    private void RemoveInboundRequestContext(string requestId);
    private void RemoveOutboundRequestContext(string requestId);
    private InboundRequestContext CreateInboundRequestContext(Message message, CancellationToken cancellationToken);
    private OutboundRequestContext`1<TIncoming> CreateOutboundRequestContext(Message message, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken);
    private static bool GetIsKeepAlive(MessageType type, MessageMethod method);
    private static TimeSpan GetRequestTimeout(IConnection connection, MessageType type, MessageMethod method);
}
internal class NuGet.Protocol.Plugins.MessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Message Message { get; }
    public MessageEventArgs(Message message);
    [CompilerGeneratedAttribute]
public Message get_Message();
}
internal enum NuGet.Protocol.Plugins.MessageMethod : Enum {
    public int value__;
    public static MessageMethod None;
    public static MessageMethod Close;
    public static MessageMethod CopyFilesInPackage;
    public static MessageMethod CopyNupkgFile;
    public static MessageMethod GetCredentials;
    public static MessageMethod GetFilesInPackage;
    public static MessageMethod GetOperationClaims;
    public static MessageMethod GetPackageHash;
    public static MessageMethod GetPackageVersions;
    public static MessageMethod GetServiceIndex;
    public static MessageMethod Handshake;
    public static MessageMethod Initialize;
    public static MessageMethod Log;
    public static MessageMethod MonitorNuGetProcessExit;
    public static MessageMethod PrefetchPackage;
    public static MessageMethod SetCredentials;
    public static MessageMethod SetLogLevel;
    public static MessageMethod GetAuthenticationCredentials;
}
internal enum NuGet.Protocol.Plugins.MessageResponseCode : Enum {
    public int value__;
    public static MessageResponseCode Success;
    public static MessageResponseCode Error;
    public static MessageResponseCode NotFound;
}
internal enum NuGet.Protocol.Plugins.MessageState : Enum {
    public int value__;
    public static MessageState Sending;
    public static MessageState Sent;
    public static MessageState Received;
    public static MessageState Cancelled;
}
internal enum NuGet.Protocol.Plugins.MessageType : Enum {
    public int value__;
    public static MessageType Cancel;
    public static MessageType Fault;
    public static MessageType Progress;
    public static MessageType Request;
    public static MessageType Response;
}
internal static class NuGet.Protocol.Plugins.MessageUtilities : object {
    public static Message Create(string requestId, MessageType type, MessageMethod method);
    public static Message Create(string requestId, MessageType type, MessageMethod method, TPayload payload);
    public static TPayload DeserializePayload(Message message);
}
internal class NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest : object {
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [JsonRequiredAttribute]
public int ProcessId { get; }
    [JsonConstructorAttribute]
public MonitorNuGetProcessExitRequest(int processId);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
}
internal class NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler : object {
    private bool _isDisposed;
    private IPlugin _plugin;
    private ConcurrentDictionary`2<int, Process> _processes;
    public CancellationToken CancellationToken { get; }
    public MonitorNuGetProcessExitRequestHandler(IPlugin plugin);
    public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler/<HandleResponseAsync>d__7")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    private void OnProcessExited(object sender, EventArgs e);
}
internal class NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public MonitorNuGetProcessExitResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.NoOpDisposePlugin : object {
    private IPlugin _plugin;
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    public NoOpDisposePlugin(IPlugin plugin);
    public sealed virtual void add_BeforeClose(EventHandler value);
    public sealed virtual void remove_BeforeClose(EventHandler value);
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual IConnection get_Connection();
    public sealed virtual string get_FilePath();
    public sealed virtual string get_Id();
    public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
}
internal enum NuGet.Protocol.Plugins.OperationClaim : Enum {
    public int value__;
    public static OperationClaim DownloadPackage;
    public static OperationClaim Authentication;
}
internal abstract class NuGet.Protocol.Plugins.OutboundRequestContext : object {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    public CancellationToken CancellationToken { get; protected set; }
    public string RequestId { get; protected set; }
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
protected void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
protected void set_RequestId(string value);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual void HandleCancelResponse();
    public abstract virtual void HandleProgress(Message progress);
    public abstract virtual void HandleResponse(Message response);
    public abstract virtual void HandleFault(Message fault);
}
internal class NuGet.Protocol.Plugins.OutboundRequestContext`1 : OutboundRequestContext {
    private CancellationTokenSource _cancellationTokenSource;
    private IConnection _connection;
    private int _isCancellationRequested;
    private bool _isClosed;
    private bool _isDisposed;
    private bool _isKeepAlive;
    private IPluginLogger _logger;
    private Message _request;
    private TaskCompletionSource`1<TResult> _taskCompletionSource;
    private Nullable`1<TimeSpan> _timeout;
    private Timer _timer;
    public Task`1<TResult> CompletionTask { get; }
    public OutboundRequestContext`1(IConnection connection, Message request, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken);
    internal OutboundRequestContext`1(IConnection connection, Message request, Nullable`1<TimeSpan> timeout, bool isKeepAlive, CancellationToken cancellationToken, IPluginLogger logger);
    public Task`1<TResult> get_CompletionTask();
    public virtual void HandleCancelResponse();
    public virtual void HandleProgress(Message progress);
    public virtual void HandleResponse(Message response);
    public virtual void HandleFault(Message fault);
    protected virtual void Dispose(bool disposing);
    private void Close();
    private void OnTimeout(object state);
    private void TryCancel();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.OutboundRequestContext`1/<<TryCancel>b__22_0>d")]
[CompilerGeneratedAttribute]
private Task <TryCancel>b__22_0();
}
internal class NuGet.Protocol.Plugins.Plugin : object {
    private bool _isClosed;
    private TimeSpan _idleTimeout;
    private Timer _idleTimer;
    private object _idleTimerLock;
    private bool _isDisposed;
    private bool _isOwnProcess;
    private IPluginProcess _process;
    [CompilerGeneratedAttribute]
private EventHandler BeforeClose;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    [CompilerGeneratedAttribute]
private EventHandler`1<PluginEventArgs> Exited;
    [CompilerGeneratedAttribute]
private EventHandler`1<FaultedPluginEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<PluginEventArgs> Idle;
    [CompilerGeneratedAttribute]
private IConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IConnection Connection { get; }
    public string FilePath { get; }
    public string Id { get; }
    public string Name { get; }
    public Plugin(string filePath, IConnection connection, IPluginProcess process, bool isOwnProcess, TimeSpan idleTimeout);
    internal Plugin(string filePath, IConnection connection, IPluginProcess process, bool isOwnProcess, TimeSpan idleTimeout, string id);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforeClose(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Exited(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Exited(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Faulted(EventHandler`1<FaultedPluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Faulted(EventHandler`1<FaultedPluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Idle(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Idle(EventHandler`1<PluginEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IConnection get_Connection();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    internal static string CreateNewId();
    private void FireBeforeClose();
    private void FireClosed();
    private void OnExited(object sender, IPluginProcess pluginProcess);
    private void OnFaulted(object sender, ProtocolErrorEventArgs e);
    private void OnIdleTimer(object state);
    private void OnMessageReceived(object sender, MessageEventArgs e);
}
internal class NuGet.Protocol.Plugins.PluginCacheEntry : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewCacheFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <OperationClaims>k__BackingField;
    internal TimeSpan MaxAge { get; internal set; }
    internal string CacheFileName { get; }
    private string RootFolder { get; }
    private string NewCacheFileName { get; }
    public IReadOnlyList`1<OperationClaim> OperationClaims { get; public set; }
    public PluginCacheEntry(string rootCacheFolder, string pluginFilePath, string requestKey);
    [CompilerGeneratedAttribute]
internal TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
internal void set_MaxAge(TimeSpan value);
    [CompilerGeneratedAttribute]
internal string get_CacheFileName();
    [CompilerGeneratedAttribute]
private string get_RootFolder();
    [CompilerGeneratedAttribute]
private string get_NewCacheFileName();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_OperationClaims();
    [CompilerGeneratedAttribute]
public void set_OperationClaims(IReadOnlyList`1<OperationClaim> value);
    public void LoadFromFile();
    private void ProcessContent(Stream content);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginCacheEntry/<UpdateCacheFileAsync>d__20")]
public Task UpdateCacheFileAsync();
}
internal static class NuGet.Protocol.Plugins.PluginConstants : object {
    public static TimeSpan CloseTimeout;
    public static TimeSpan IdleTimeout;
    public static IEnumerable`1<string> PluginArguments;
    public static TimeSpan ProgressInterval;
    public static TimeSpan RequestTimeout;
    private static PluginConstants();
}
internal class NuGet.Protocol.Plugins.PluginCreationResult : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<OperationClaim> <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    [CompilerGeneratedAttribute]
private IPluginMulticlientUtilities <PluginMulticlientUtilities>k__BackingField;
    public IReadOnlyList`1<OperationClaim> Claims { get; }
    public string Message { get; }
    public Exception Exception { get; }
    public IPlugin Plugin { get; }
    public IPluginMulticlientUtilities PluginMulticlientUtilities { get; }
    public PluginCreationResult(IPlugin plugin, IPluginMulticlientUtilities utilities, IReadOnlyList`1<OperationClaim> claims);
    public PluginCreationResult(string message);
    public PluginCreationResult(string message, Exception exception);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<OperationClaim> get_Claims();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
    [CompilerGeneratedAttribute]
public IPluginMulticlientUtilities get_PluginMulticlientUtilities();
}
internal class NuGet.Protocol.Plugins.PluginDiscoverer : object {
    private bool _isDisposed;
    private List`1<PluginFile> _pluginFiles;
    private string _rawPluginPaths;
    private IEnumerable`1<PluginDiscoveryResult> _results;
    private SemaphoreSlim _semaphore;
    private EmbeddedSignatureVerifier _verifier;
    public PluginDiscoverer(string rawPluginPaths, EmbeddedSignatureVerifier verifier);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginDiscoverer/<DiscoverAsync>d__8")]
public sealed virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> DiscoverAsync(CancellationToken cancellationToken);
    private List`1<PluginFile> GetPluginFiles(CancellationToken cancellationToken);
    private IEnumerable`1<string> GetPluginFilePaths();
}
internal class NuGet.Protocol.Plugins.PluginDiscoveryResult : object {
    [CompilerGeneratedAttribute]
private PluginFile <PluginFile>k__BackingField;
    private string _message;
    public PluginFile PluginFile { get; }
    public string Message { get; }
    public PluginDiscoveryResult(PluginFile pluginFile);
    [CompilerGeneratedAttribute]
public PluginFile get_PluginFile();
    public string get_Message();
}
internal static class NuGet.Protocol.Plugins.PluginDiscoveryUtility : object {
    [CompilerGeneratedAttribute]
private static Lazy`1<string> <InternalPluginDiscoveryRoot>k__BackingField;
    private static string NuGetPluginsDirectory;
    public static Lazy`1<string> InternalPluginDiscoveryRoot { get; public set; }
    private static PluginDiscoveryUtility();
    [CompilerGeneratedAttribute]
public static Lazy`1<string> get_InternalPluginDiscoveryRoot();
    [CompilerGeneratedAttribute]
public static void set_InternalPluginDiscoveryRoot(Lazy`1<string> value);
    public static string GetInternalPlugins();
    public static string GetInternalPluginRelativeToMSBuildDirectory(string msbuildDirectoryPath);
    public static string GetNuGetPluginsDirectoryRelativeToNuGetAssembly(string nugetAssemblyPath);
    public static string GetNuGetHomePluginsPath();
    public static IEnumerable`1<string> GetConventionBasedPlugins(IEnumerable`1<string> directories);
}
internal class NuGet.Protocol.Plugins.PluginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IPlugin <Plugin>k__BackingField;
    public IPlugin Plugin { get; }
    public PluginEventArgs(IPlugin plugin);
    [CompilerGeneratedAttribute]
public IPlugin get_Plugin();
}
internal class NuGet.Protocol.Plugins.PluginException : Exception {
    public PluginException(string message);
    public PluginException(string message, Exception innerException);
    private PluginException(SerializationInfo info, StreamingContext context);
}
internal class NuGet.Protocol.Plugins.PluginFactory : object {
    private bool _isDisposed;
    private IPluginLogger _logger;
    private TimeSpan _pluginIdleTimeout;
    private ConcurrentDictionary`2<string, Lazy`1<Task`1<IPlugin>>> _plugins;
    public PluginFactory(TimeSpan pluginIdleTimeout);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<GetOrCreateAsync>d__6")]
public sealed virtual Task`1<IPlugin> GetOrCreateAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<CreatePluginAsync>d__7")]
private Task`1<IPlugin> CreatePluginAsync(string filePath, IEnumerable`1<string> arguments, IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginFactory/<CreateFromCurrentProcessAsync>d__8")]
public static Task`1<IPlugin> CreateFromCurrentProcessAsync(IRequestHandlers requestHandlers, ConnectionOptions options, CancellationToken sessionCancellationToken);
    private void Dispose(IPlugin plugin);
    private void OnPluginFaulted(object sender, FaultedPluginEventArgs e);
    private void OnPluginExited(object sender, PluginEventArgs e);
    private void OnPluginIdle(object sender, PluginEventArgs e);
    private void OnPluginProcessExited(IPluginProcess pluginProcess, string pluginId);
    private static void SendCloseRequest(IPlugin plugin);
    private void UnregisterEventHandlers(Plugin plugin);
    private static void WriteCommonLogMessages(IPluginLogger logger);
}
internal class NuGet.Protocol.Plugins.PluginFile : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<PluginFileState> <State>k__BackingField;
    public string Path { get; }
    public Lazy`1<PluginFileState> State { get; }
    public PluginFile(string filePath, Lazy`1<PluginFileState> state);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public Lazy`1<PluginFileState> get_State();
    public virtual string ToString();
}
internal enum NuGet.Protocol.Plugins.PluginFileState : Enum {
    public int value__;
    public static PluginFileState Valid;
    public static PluginFileState NotFound;
    public static PluginFileState InvalidFilePath;
    public static PluginFileState InvalidEmbeddedSignature;
}
internal class NuGet.Protocol.Plugins.PluginInstanceLogMessage : PluginLogMessage {
    private string _pluginId;
    private Nullable`1<int> _processId;
    private PluginState _state;
    internal PluginInstanceLogMessage(DateTimeOffset now, string pluginId, PluginState state);
    internal PluginInstanceLogMessage(DateTimeOffset now, string pluginId, PluginState state, Nullable`1<int> processId);
    public virtual string ToString();
}
internal class NuGet.Protocol.Plugins.PluginLogger : object {
    private bool _isDisposed;
    private Lazy`1<StreamWriter> _streamWriter;
    private string _logDirectoryPath;
    private DateTimeOffset _startTime;
    private Stopwatch _stopwatch;
    private object _streamWriterLock;
    [CompilerGeneratedAttribute]
private static PluginLogger <DefaultInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    internal static PluginLogger DefaultInstance { get; }
    public bool IsEnabled { get; }
    public DateTimeOffset Now { get; }
    internal PluginLogger(IEnvironmentVariableReader environmentVariableReader);
    private static PluginLogger();
    [CompilerGeneratedAttribute]
internal static PluginLogger get_DefaultInstance();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEnabled();
    public sealed virtual DateTimeOffset get_Now();
    public sealed virtual void Dispose();
    public sealed virtual void Write(IPluginLogMessage message);
    private StreamWriter CreateStreamWriter(IPluginLogMessage message);
}
internal abstract class NuGet.Protocol.Plugins.PluginLogMessage : object {
    private static StringEnumConverter _enumConverter;
    private DateTime _now;
    protected PluginLogMessage(DateTimeOffset now);
    private static PluginLogMessage();
    protected string ToString(string type, JObject message);
}
internal class NuGet.Protocol.Plugins.PluginManager : object {
    private static Lazy`1<IPluginManager> _lazy;
    private ConnectionOptions _connectionOptions;
    private Lazy`1<IPluginDiscoverer> _discoverer;
    private bool _isDisposed;
    private IPluginFactory _pluginFactory;
    private ConcurrentDictionary`2<PluginRequestKey, Lazy`1<Task`1<IReadOnlyList`1<OperationClaim>>>> _pluginOperationClaims;
    private ConcurrentDictionary`2<string, Lazy`1<IPluginMulticlientUtilities>> _pluginUtilities;
    private string _rawPluginPaths;
    private static Lazy`1<int> _currentProcessId;
    private Lazy`1<string> _pluginsCacheDirectoryPath;
    [CompilerGeneratedAttribute]
private IEnvironmentVariableReader <EnvironmentVariableReader>k__BackingField;
    public static IPluginManager Instance { get; }
    public IEnvironmentVariableReader EnvironmentVariableReader { get; private set; }
    public PluginManager(IEnvironmentVariableReader reader, Lazy`1<IPluginDiscoverer> pluginDiscoverer, Func`2<TimeSpan, IPluginFactory> pluginFactoryCreator, Lazy`1<string> pluginsCacheDirectoryPath);
    private static PluginManager();
    public static IPluginManager get_Instance();
    [CompilerGeneratedAttribute]
public IEnvironmentVariableReader get_EnvironmentVariableReader();
    [CompilerGeneratedAttribute]
private void set_EnvironmentVariableReader(IEnvironmentVariableReader value);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<FindAvailablePluginsAsync>d__19")]
public sealed virtual Task`1<IEnumerable`1<PluginDiscoveryResult>> FindAvailablePluginsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<CreatePluginsAsync>d__20")]
public sealed virtual Task`1<IEnumerable`1<PluginCreationResult>> CreatePluginsAsync(SourceRepository source, CancellationToken cancellationToken);
    public sealed virtual Task`1<Tuple`2<bool, PluginCreationResult>> TryGetSourceAgnosticPluginAsync(PluginDiscoveryResult pluginDiscoveryResult, OperationClaim requestedOperationClaim, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<TryCreatePluginAsync>d__22")]
private Task`1<Tuple`2<bool, PluginCreationResult>> TryCreatePluginAsync(PluginDiscoveryResult result, OperationClaim requestedOperationClaim, PluginRequestKey requestKey, string packageSourceRepository, JObject serviceIndex, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<PerformOneTimePluginInitializationAsync>d__23")]
private Task`1<Lazy`1<IPluginMulticlientUtilities>> PerformOneTimePluginInitializationAsync(IPlugin plugin, CancellationToken cancellationToken);
    private void Initialize(IEnvironmentVariableReader reader, Lazy`1<IPluginDiscoverer> pluginDiscoverer, Func`2<TimeSpan, IPluginFactory> pluginFactoryCreator, Lazy`1<string> pluginsCacheDirectoryPath);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<GetPluginOperationClaimsAsync>d__25")]
private Task`1<IReadOnlyList`1<OperationClaim>> GetPluginOperationClaimsAsync(IPlugin plugin, string packageSourceRepository, JObject serviceIndex, CancellationToken cancellationToken);
    private PluginDiscoverer InitializeDiscoverer();
    private bool IsPluginPossiblyAvailable();
    private void OnPluginClosed(object sender, EventArgs e);
    private static int GetCurrentProcessId();
    private static string GetCurrentCultureName();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginManager/<InitializePluginAsync>d__31")]
private static Task InitializePluginAsync(IPlugin plugin, TimeSpan requestTimeout, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Plugins.PluginMulticlientUtilities : object {
    private ConcurrentDictionary`2<string, Lazy`1<Task>> _actions;
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginMulticlientUtilities/<DoOncePerPluginLifetimeAsync>d__2")]
public sealed virtual Task DoOncePerPluginLifetimeAsync(string key, Func`1<Task> taskFunc, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.Plugins.PluginPackageDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private PackageIdentity _packageIdentity;
    private PluginPackageReader _packageReader;
    private string _packageSourceRepository;
    private IPlugin _plugin;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public PluginPackageDownloader(IPlugin plugin, PackageIdentity packageIdentity, PluginPackageReader packageReader, string packageSourceRepository);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageDownloader/<CopyNupkgFileToAsync>d__16")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageDownloader/<GetPackageHashAsync>d__17")]
public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private void ThrowIfDisposed();
}
internal class NuGet.Protocol.Plugins.PluginPackageReader : PackageReaderBase {
    private ConcurrentDictionary`2<string, Lazy`1<Task`1<FileStreamCreator>>> _fileStreams;
    private IEnumerable`1<string> _files;
    private SemaphoreSlim _getFilesSemaphore;
    private SemaphoreSlim _getNuspecReaderSemaphore;
    private bool _isDisposed;
    private NuspecReader _nuspecReader;
    private PackageIdentity _packageIdentity;
    private string _packageSourceRepository;
    private IPlugin _plugin;
    private Lazy`1<string> _tempDirectoryPath;
    public NuspecReader NuspecReader { get; }
    public PluginPackageReader(IPlugin plugin, PackageIdentity packageIdentity, string packageSourceRepository);
    public virtual Stream GetStream(string path);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetStreamAsync>d__12")]
public virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> GetFiles();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesAsync>d__14")]
public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> GetFiles(string folder);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesAsync>d__16")]
public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<CopyFilesAsync>d__18")]
public virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
    public virtual PackageIdentity GetIdentity();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetIdentityAsync>d__20")]
public virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public virtual NuGetVersion GetMinClientVersion();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetMinClientVersionAsync>d__22")]
public virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetPackageTypesAsync>d__24")]
public virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public virtual Stream GetNuspec();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecAsync>d__26")]
public virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public virtual string GetNuspecFile();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecFileAsync>d__28")]
public virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public virtual NuspecReader get_NuspecReader();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetNuspecReaderAsync>d__31")]
public virtual Task`1<NuspecReader> GetNuspecReaderAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<NuGetFramework> GetSupportedFrameworks();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetSupportedFrameworksAsync>d__33")]
public virtual Task`1<IEnumerable`1<NuGetFramework>> GetSupportedFrameworksAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFrameworkItemsAsync>d__35")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public virtual bool IsServiceable();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<IsServiceableAsync>d__37")]
public virtual Task`1<bool> IsServiceableAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetBuildItemsAsync>d__39")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetItems(string folderName);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetItemsAsync(string folderName, CancellationToken cancellationToken);
    public virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetPackageDependenciesAsync>d__47")]
public virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetReferenceItemsAsync>d__51")]
public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public virtual bool GetDevelopmentDependency();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetDevelopmentDependencyAsync>d__53")]
public virtual Task`1<bool> GetDevelopmentDependencyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<CopyNupkgAsync>d__54")]
public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFileGroupsAsync>d__56")]
private Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFileGroupsAsync(string folder, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetStreamInternalAsync>d__57")]
private Task`1<FileStreamCreator> GetStreamInternalAsync(string pathInPackage);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.PluginPackageReader/<GetFilesInternalAsync>d__58")]
private Task`1<IEnumerable`1<string>> GetFilesInternalAsync(CancellationToken cancellationToken);
    private void CreatePackageDownloadMarkerFile(string nupkgFilePath);
    private static string GetTemporaryDirectoryPath();
    public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    [CompilerGeneratedAttribute]
private Lazy`1<Task`1<FileStreamCreator>> <GetStreamAsync>b__12_0(string p);
}
internal class NuGet.Protocol.Plugins.PluginProcess : object {
    private Nullable`1<int> _exitCode;
    private bool _hasStarted;
    private Nullable`1<int> _id;
    private bool _isDisposed;
    private Process _process;
    private ProcessStartInfo _startInfo;
    [CompilerGeneratedAttribute]
private EventHandler`1<IPluginProcess> Exited;
    [CompilerGeneratedAttribute]
private EventHandler`1<LineReadEventArgs> LineRead;
    public Nullable`1<int> ExitCode { get; }
    internal string FilePath { get; }
    public Nullable`1<int> Id { get; }
    internal StreamWriter StandardInput { get; }
    public PluginProcess(ProcessStartInfo startInfo);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Exited(EventHandler`1<IPluginProcess> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_LineRead(EventHandler`1<LineReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_LineRead(EventHandler`1<LineReadEventArgs> value);
    public sealed virtual Nullable`1<int> get_ExitCode();
    internal string get_FilePath();
    public sealed virtual Nullable`1<int> get_Id();
    internal StreamWriter get_StandardInput();
    public sealed virtual void Dispose();
    public sealed virtual void BeginReadLine();
    public sealed virtual void CancelRead();
    public sealed virtual void Kill();
    public void Start();
    private void OnOutputDataReceived(object sender, DataReceivedEventArgs e);
    private void OnProcessExited(object sender, EventArgs e);
    private void UpdateExitCodeIfNecessary();
    private void UpdateIdIfNecessary();
}
internal enum NuGet.Protocol.Plugins.PluginState : Enum {
    public int value__;
    public static PluginState Started;
    public static PluginState Idle;
    public static PluginState Exited;
    public static PluginState Disposing;
    public static PluginState Disposed;
}
internal class NuGet.Protocol.Plugins.PrefetchPackageRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    [JsonRequiredAttribute]
public string PackageId { get; }
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    [JsonRequiredAttribute]
public string PackageVersion { get; }
    [JsonConstructorAttribute]
public PrefetchPackageRequest(string packageSourceRepository, string packageId, string packageVersion);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
}
internal class NuGet.Protocol.Plugins.PrefetchPackageResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public PrefetchPackageResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.ProcessLogMessage : PluginLogMessage {
    private int _processId;
    private string _processName;
    private DateTime _processStartTime;
    internal ProcessLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
internal class NuGet.Protocol.Plugins.Progress : object {
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Percentage>k__BackingField;
    public Nullable`1<double> Percentage { get; }
    [JsonConstructorAttribute]
public Progress(Nullable`1<double> percentage);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Percentage();
    private static bool IsValidPercentage(Nullable`1<double> percentage);
}
internal static class NuGet.Protocol.Plugins.ProtocolConstants : object {
    public static SemanticVersion CurrentVersion;
    public static SemanticVersion Version100;
    public static TimeSpan HandshakeTimeout;
    public static TimeSpan MaxTimeout;
    public static TimeSpan MinTimeout;
    public static TimeSpan RequestTimeout;
    private static ProtocolConstants();
}
internal class NuGet.Protocol.Plugins.ProtocolErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Exception Exception { get; }
    public Message Message { get; }
    public ProtocolErrorEventArgs(Exception exception);
    public ProtocolErrorEventArgs(Exception exception, Message message);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public Message get_Message();
}
internal class NuGet.Protocol.Plugins.ProtocolException : Exception {
    public ProtocolException(string message);
    public ProtocolException(string message, Exception innerException);
    private ProtocolException(SerializationInfo info, StreamingContext context);
}
internal abstract class NuGet.Protocol.Plugins.Receiver : object {
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProtocolErrorEventArgs> Faulted;
    [CompilerGeneratedAttribute]
private EventHandler`1<MessageEventArgs> MessageReceived;
    protected bool IsClosed { get; private set; }
    protected bool IsDisposed { get; protected set; }
    [CompilerGeneratedAttribute]
protected bool get_IsClosed();
    [CompilerGeneratedAttribute]
private void set_IsClosed(bool value);
    [CompilerGeneratedAttribute]
protected bool get_IsDisposed();
    [CompilerGeneratedAttribute]
protected void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Faulted(EventHandler`1<ProtocolErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public virtual void Close();
    public abstract virtual void Connect();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    protected void FireFaultEvent(Exception exception, Message message);
    protected void FireMessageReceivedEvent(Message message);
    protected void ThrowIfClosed();
    protected void ThrowIfDisposed();
}
internal class NuGet.Protocol.Plugins.RequestHandlers : object {
    private ConcurrentDictionary`2<MessageMethod, IRequestHandler> _handlers;
    public sealed virtual void AddOrUpdate(MessageMethod method, Func`1<IRequestHandler> addHandlerFunc, Func`2<IRequestHandler, IRequestHandler> updateHandlerFunc);
    public sealed virtual bool TryAdd(MessageMethod method, IRequestHandler handler);
    public sealed virtual bool TryGet(MessageMethod method, IRequestHandler& handler);
    public sealed virtual bool TryRemove(MessageMethod method);
}
internal class NuGet.Protocol.Plugins.RequestIdGenerator : object {
    public sealed virtual string GenerateUniqueId();
}
internal class NuGet.Protocol.Plugins.Sender : object {
    private bool _hasConnected;
    private bool _isClosed;
    private bool _isDisposed;
    private object _sendLock;
    private TextWriter _textWriter;
    public Sender(TextWriter writer);
    public sealed virtual void Dispose();
    public sealed virtual void Close();
    public sealed virtual void Connect();
    public sealed virtual Task SendAsync(Message message, CancellationToken cancellationToken);
    private void ThrowIfDisposed();
}
internal class NuGet.Protocol.Plugins.SetCredentialsRequest : object {
    [CompilerGeneratedAttribute]
private string <PackageSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProxyUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [JsonRequiredAttribute]
public string PackageSourceRepository { get; }
    public string Password { get; }
    public string ProxyPassword { get; }
    public string ProxyUsername { get; }
    public string Username { get; }
    public SetCredentialsRequest(string packageSourceRepository, string proxyUsername, string proxyPassword, string username, string password);
    [CompilerGeneratedAttribute]
public string get_PackageSourceRepository();
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public string get_ProxyPassword();
    [CompilerGeneratedAttribute]
public string get_ProxyUsername();
    [CompilerGeneratedAttribute]
public string get_Username();
}
internal class NuGet.Protocol.Plugins.SetCredentialsResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public SetCredentialsResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.SetLogLevelRequest : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [JsonRequiredAttribute]
public LogLevel LogLevel { get; }
    [JsonConstructorAttribute]
public SetLogLevelRequest(LogLevel logLevel);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
}
internal class NuGet.Protocol.Plugins.SetLogLevelResponse : object {
    [CompilerGeneratedAttribute]
private MessageResponseCode <ResponseCode>k__BackingField;
    [JsonRequiredAttribute]
public MessageResponseCode ResponseCode { get; }
    [JsonConstructorAttribute]
public SetLogLevelResponse(MessageResponseCode responseCode);
    [CompilerGeneratedAttribute]
public MessageResponseCode get_ResponseCode();
}
internal class NuGet.Protocol.Plugins.StandardInputReceiver : Receiver {
    private TextReader _reader;
    private CancellationTokenSource _receiveCancellationTokenSource;
    private Task _receiveThread;
    public StandardInputReceiver(TextReader reader);
    protected virtual void Dispose(bool disposing);
    public virtual void Connect();
    private void Receive(object state);
}
internal class NuGet.Protocol.Plugins.StandardOutputReceiver : Receiver {
    private bool _hasConnected;
    private IPluginProcess _process;
    public StandardOutputReceiver(IPluginProcess process);
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual void Connect();
    private void OnLineRead(object sender, LineReadEventArgs e);
}
internal class NuGet.Protocol.Plugins.StopwatchLogMessage : PluginLogMessage {
    private long _frequency;
    internal StopwatchLogMessage(DateTimeOffset now, long frequency);
    public virtual string ToString();
}
internal class NuGet.Protocol.Plugins.SymmetricHandshake : object {
    private IConnection _connection;
    private HandshakeResponse _handshakeFailedResponse;
    private TimeSpan _handshakeTimeout;
    private bool _isDisposed;
    private SemanticVersion _minimumProtocolVersion;
    private HandshakeRequest _outboundHandshakeRequest;
    private SemanticVersion _protocolVersion;
    private TaskCompletionSource`1<int> _responseSentTaskCompletionSource;
    private CancellationTokenSource _timeoutCancellationTokenSource;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public CancellationToken CancellationToken { get; }
    public SymmetricHandshake(IConnection connection, TimeSpan handshakeTimeout, SemanticVersion protocolVersion, SemanticVersion minimumProtocolVersion);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.SymmetricHandshake/<HandshakeAsync>d__14")]
public Task`1<SemanticVersion> HandshakeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Plugins.SymmetricHandshake/<HandleResponseAsync>d__15")]
public sealed virtual Task HandleResponseAsync(IConnection connection, Message request, IResponseHandler responseHandler, CancellationToken cancellationToken);
    private bool IsSupportedVersion(SemanticVersion requestedProtocolVersion);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private bool <HandleResponseAsync>b__15_0(Task task);
}
internal class NuGet.Protocol.Plugins.TaskLogMessage : PluginLogMessage {
    private Nullable`1<int> _currentTaskId;
    private MessageMethod _method;
    private string _requestId;
    private TaskState _state;
    private MessageType _type;
    internal TaskLogMessage(DateTimeOffset now, string requestId, MessageMethod method, MessageType type, TaskState state);
    public virtual string ToString();
}
internal enum NuGet.Protocol.Plugins.TaskState : Enum {
    public int value__;
    public static TaskState Queued;
    public static TaskState Executing;
    public static TaskState Completed;
}
internal class NuGet.Protocol.Plugins.ThreadPoolLogMessage : PluginLogMessage {
    private int _maxCompletionPortThreads;
    private int _maxWorkerThreads;
    private int _minCompletionPortThreads;
    private int _minWorkerThreads;
    internal ThreadPoolLogMessage(DateTimeOffset now);
    public virtual string ToString();
}
internal static class NuGet.Protocol.Plugins.TimeoutUtilities : object {
    public static TimeSpan GetTimeout(string timeoutInSeconds, TimeSpan fallbackTimeout);
    public static bool IsValid(TimeSpan timeout);
}
internal class NuGet.Protocol.Plugins.UnixAndMonoPlatformsEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    public virtual bool IsValid(string filePath);
}
internal class NuGet.Protocol.Plugins.WindowsEmbeddedSignatureVerifier : EmbeddedSignatureVerifier {
    private static int WinVerifyTrust(IntPtr hwnd, Guid pgActionID, WINTRUST_DATA pWVTData);
    public virtual bool IsValid(string filePath);
}
internal static class NuGet.Protocol.ProtocolConstants : object {
    public static string ApiKeyHeader;
    public static string ServerWarningHeader;
    public static string SessionId;
    private static ProtocolConstants();
}
internal class NuGet.Protocol.Providers.OwnerDetailsUriResourceV3Provider : ResourceProvider {
    [NuGet.Protocol.NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NuGet.Protocol.Providers.OwnerDetailsUriResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider : ResourceProvider {
    [NuGet.Protocol.NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NuGet.Protocol.Providers.VulnerabilityInfoResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.ProxyAuthenticationHandler : DelegatingHandler {
    public static int MaxAuthRetries;
    private static string BasicAuthenticationType;
    private static SemaphoreSlim _credentialPromptLock;
    private HttpClientHandler _clientHandler;
    private ICredentialService _credentialService;
    private IProxyCredentialCache _credentialCache;
    private int _authRetries;
    public ProxyAuthenticationHandler(HttpClientHandler clientHandler, ICredentialService credentialService, IProxyCredentialCache credentialCache);
    private static ProxyAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<SendAsync>d__8")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static bool ProxyAuthenticationRequired(Exception ex);
    private static HttpWebResponse ExtractResponse(Exception ex);
    private static bool IsMonoProxyAuthenticationRequiredError(WebException ex);
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<AcquireCredentialsAsync>d__12")]
private Task`1<bool> AcquireCredentialsAsync(Uri requestUri, Guid cacheVersion, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<PromptForProxyCredentialsAsync>d__13")]
private Task`1<NetworkCredential> PromptForProxyCredentialsAsync(Uri proxyAddress, IWebProxy proxy, ILogger log, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
internal class NuGet.Protocol.RawSearchResourceV3 : object {
    private HttpSource _client;
    private Uri[] _searchEndpoints;
    public RawSearchResourceV3(HttpSource client, IEnumerable`1<Uri> searchEndpoints);
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3/<SearchPage>d__3")]
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public virtual Task`1<JObject> SearchPage(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3/<Search>d__4")]
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
public virtual Task`1<IEnumerable`1<JObject>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Use PackageSearchResource instead (via SourceRepository.GetResourceAsync<PackageSearchResource>")]
internal class NuGet.Protocol.RawSearchResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.RegistrationInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageInfo> <Packages>k__BackingField;
    public string Id { get; public set; }
    public bool IncludePrerelease { get; public set; }
    public IList`1<PackageInfo> Packages { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrerelease();
    [CompilerGeneratedAttribute]
public void set_IncludePrerelease(bool value);
    [CompilerGeneratedAttribute]
public IList`1<PackageInfo> get_Packages();
    [CompilerGeneratedAttribute]
private void set_Packages(IList`1<PackageInfo> value);
    public void Add(PackageInfo packageInfo);
    public virtual string ToString();
}
internal class NuGet.Protocol.RegistrationResourceV3 : object {
    private HttpSource _client;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    public Uri BaseUri { get; }
    public RegistrationResourceV3(HttpSource client, Uri baseUrl);
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    public virtual Uri GetUri(string packageId);
    public virtual Uri GetUri(string id, NuGetVersion version);
    public virtual Uri GetUri(PackageIdentity package);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__8")]
public virtual Task`1<JObject> GetPackageMetadata(PackageIdentity identity, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__9")]
public virtual Task`1<IEnumerable`1<JObject>> GetPackageMetadata(string packageId, bool includePrerelease, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__10")]
public virtual Task`1<IEnumerable`1<JObject>> GetPackageMetadata(string packageId, VersionRange range, bool includePrerelease, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<JObject>> GetPackageEntries(string packageId, bool includeUnlisted, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.RegistrationResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.RegistrationUtility : object {
    public static VersionRange CreateVersionRange(string stringToParse);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationUtility/<LoadRanges>d__1")]
public static Task`1<IEnumerable`1<JObject>> LoadRanges(HttpSource httpSource, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
}
internal class NuGet.Protocol.RemotePackageArchiveDownloader : object {
    private SourceCacheContext _cacheContext;
    private string _destinationFilePath;
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private FindPackageByIdResource _resource;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public RemotePackageArchiveDownloader(string source, FindPackageByIdResource resource, PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemotePackageArchiveDownloader/<CopyNupkgFileToAsync>d__20")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetDestinationStream();
    private void ThrowIfDisposed();
}
internal class NuGet.Protocol.RemoteV2FindPackageByIdResource : FindPackageByIdResource {
    private static XName _xnameEntry;
    private static XName _xnameContent;
    private static XName _xnameProperties;
    private static XName _xnameId;
    private static XName _xnameVersion;
    private string _baseUri;
    private HttpSource _httpSource;
    private NuGet.Protocol1276564.TaskResultCache`2<string, List`1<PackageInfo>> _packageVersionsCache;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private V2FeedQueryBuilder _queryBuilder;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    [CompilerGeneratedAttribute]
private PackageSource <PackageSource>k__BackingField;
    public PackageSource PackageSource { get; }
    public RemoteV2FindPackageByIdResource(PackageSource packageSource, HttpSource httpSource);
    private static RemoteV2FindPackageByIdResource();
    [CompilerGeneratedAttribute]
public PackageSource get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetAllVersionsAsync>d__16")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetDependencyInfoAsync>d__17")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<CopyNupkgToStreamAsync>d__18")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetPackageDownloaderAsync>d__19")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<DoesPackageExistAsync>d__20")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetPackageInfoAsync>d__21")]
private Task`1<PackageInfo> GetPackageInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<EnsurePackagesAsync>d__22")]
private Task`1<IEnumerable`1<PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<FindPackagesByIdAsyncCore>d__23")]
private Task`1<List`1<PackageInfo>> FindPackagesByIdAsyncCore(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private static PackageInfo BuildModel(string id, XElement element);
}
internal class NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
internal class NuGet.Protocol.RemoteV3FindPackageByIdResource : FindPackageByIdResource {
    private SemaphoreSlim _dependencyInfoSemaphore;
    private NuGet.Protocol1276564.TaskResultCache`2<string, IEnumerable`1<RemoteSourceDependencyInfo>> _packageVersionsCache;
    private HttpSource _httpSource;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private DependencyInfoResource _dependencyInfoResource;
    private static string ResourceTypeName;
    private static string ThisTypeName;
    [CompilerGeneratedAttribute]
private SourceRepository <SourceRepository>k__BackingField;
    public SourceRepository SourceRepository { get; }
    public RemoteV3FindPackageByIdResource(SourceRepository sourceRepository, HttpSource httpSource);
    [CompilerGeneratedAttribute]
public SourceRepository get_SourceRepository();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetAllVersionsAsync>d__11")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetDependencyInfoAsync>d__12")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<CopyNupkgToStreamAsync>d__13")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetPackageDownloaderAsync>d__14")]
public virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<DoesPackageExistAsync>d__15")]
public virtual Task`1<bool> DoesPackageExistAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetPackageInfoAsync>d__16")]
private Task`1<RemoteSourceDependencyInfo> GetPackageInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<FindPackagesByIdAsyncCore>d__18")]
private Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> FindPackagesByIdAsyncCore(string id, SourceCacheContext sourceCacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<EnsureDependencyProvider>d__19")]
private Task EnsureDependencyProvider(CancellationToken cancellationToken);
}
internal class NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
internal class NuGet.Protocol.ReportAbuseResourceV3 : object {
    private string _uriTemplate;
    public ReportAbuseResourceV3(string uriTemplate);
    public Uri GetReportAbuseUrl(string id, NuGetVersion version);
    private static bool IsValidUriTemplate(string uriTemplate);
}
internal class NuGet.Protocol.ReportAbuseResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.ReportAbuseResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.RepositoryCertificateInfo : object {
    [CompilerGeneratedAttribute]
private Fingerprints <Fingerprints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <NotAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentUrl>k__BackingField;
    [JsonPropertyAttribute]
public Fingerprints Fingerprints { get; private set; }
    [JsonPropertyAttribute]
public string Subject { get; private set; }
    [JsonPropertyAttribute]
public string Issuer { get; private set; }
    [JsonPropertyAttribute]
public DateTimeOffset NotBefore { get; private set; }
    [JsonPropertyAttribute]
public DateTimeOffset NotAfter { get; private set; }
    [JsonPropertyAttribute]
public string ContentUrl { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual Fingerprints get_Fingerprints();
    [CompilerGeneratedAttribute]
private void set_Fingerprints(Fingerprints value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Issuer();
    [CompilerGeneratedAttribute]
private void set_Issuer(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_NotBefore();
    [CompilerGeneratedAttribute]
private void set_NotBefore(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_NotAfter();
    [CompilerGeneratedAttribute]
private void set_NotAfter(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ContentUrl();
    [CompilerGeneratedAttribute]
private void set_ContentUrl(string value);
}
internal class NuGet.Protocol.RepositorySignatureResource : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllRepositorySigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRepositoryCertificateInfo> <RepositoryCertificateInfos>k__BackingField;
    public string Source { get; }
    public bool AllRepositorySigned { get; }
    public IEnumerable`1<IRepositoryCertificateInfo> RepositoryCertificateInfos { get; }
    public RepositorySignatureResource(JObject repoSignInformationContent, SourceRepository source);
    public RepositorySignatureResource(bool allRepositorySigned, IEnumerable`1<IRepositoryCertificateInfo> repositoryCertInfos);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public bool get_AllRepositorySigned();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRepositoryCertificateInfo> get_RepositoryCertificateInfos();
    public void UpdateRepositorySignatureInfo();
}
internal class NuGet.Protocol.RepositorySignatureResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RepositorySignatureResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RepositorySignatureResourceProvider/<GetRepositorySignatureResourceAsync>d__2")]
private Task`1<RepositorySignatureResource> GetRepositorySignatureResourceAsync(SourceRepository source, ServiceIndexEntry serviceEntry, ILogger log, CancellationToken token);
    private static string GenerateCacheKey(ServiceIndexEntry serviceEntry);
}
internal static class NuGet.Protocol.ResolverMetadataClient : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.ResolverMetadataClient/<GetDependencies>d__0")]
public static Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> GetDependencies(HttpSource httpClient, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, ILogger log, CancellationToken token);
    private static RemoteSourceDependencyInfo ProcessPackageVersion(JObject packageObj, NuGetVersion version);
    [AsyncStateMachineAttribute("NuGet.Protocol.ResolverMetadataClient/<GetRegistrationInfo>d__2")]
public static Task`1<RegistrationInfo> GetRegistrationInfo(HttpSource httpClient, Uri registrationUri, string packageId, VersionRange range, SourceCacheContext cacheContext, NuGetFramework projectTargetFramework, ILogger log, CancellationToken token);
    private static NuGetFramework GetFramework(JObject dependencyGroupObj);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.Protocol.Resources.OwnerDetailsUriTemplateResourceV3 : object {
    private string _template;
    private OwnerDetailsUriTemplateResourceV3(string template);
    public static OwnerDetailsUriTemplateResourceV3 CreateOrNull(Uri uriTemplate);
    public Uri GetUri(string owner);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
internal class NuGet.Protocol.Resources.VulnerabilityInfoResourceV3 : object {
    private SourceRepository _sourceRepository;
    internal VulnerabilityInfoResourceV3(SourceRepository sourceRepository);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityFilesAsync>d__2")]
public Task`1<IReadOnlyList`1<V3VulnerabilityIndexEntry>> GetVulnerabilityFilesAsync(SourceCacheContext cacheContext, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityDataAsync>d__3")]
public Task`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> GetVulnerabilityDataAsync(V3VulnerabilityIndexEntry vulnerabilityPage, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<GetVulnerabilityInfoAsync>d__4")]
public sealed virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync(SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private IReadOnlyList`1<V3VulnerabilityIndexEntry> GetValidIndexEntries(IReadOnlyList`1<V3VulnerabilityIndexEntry> indexEntries, List`1& exceptions);
    private static void AddException(Exception exception, List`1& exceptions);
    [AsyncStateMachineAttribute("NuGet.Protocol.Resources.VulnerabilityInfoResourceV3/<<GetVulnerabilityFilesAsync>g__GetIndexUrlAsync|2_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Uri> <GetVulnerabilityFilesAsync>g__GetIndexUrlAsync|2_0(CancellationToken cancellationToken);
    [NuGet.Protocol.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static AggregateException <GetVulnerabilityInfoAsync>g__ToAggregateException|4_0(IEnumerable`1<Exception> exceptions);
}
internal class NuGet.Protocol.SafeBoolConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.SafeUriConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.SemanticVersionConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.SemaphoreSlimThrottle : object {
    private SemaphoreSlim _semaphore;
    public int CurrentCount { get; }
    public SemaphoreSlimThrottle(SemaphoreSlim semaphore);
    public int get_CurrentCount();
    [AsyncStateMachineAttribute("NuGet.Protocol.SemaphoreSlimThrottle/<WaitAsync>d__4")]
public sealed virtual Task WaitAsync();
    public sealed virtual void Release();
    public static SemaphoreSlimThrottle CreateBinarySemaphore();
    public static SemaphoreSlimThrottle CreateSemaphoreThrottle(int initialCount);
}
internal class NuGet.Protocol.ServerWarningLogHandler : DelegatingHandler {
    public ServerWarningLogHandler(HttpClientHandler clientHandler);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServerWarningLogHandler/<SendAsync>d__1")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.ServiceIndexEntry : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ClientVersion>k__BackingField;
    public Uri Uri { get; }
    public string Type { get; }
    public SemanticVersion ClientVersion { get; }
    public ServiceIndexEntry(Uri serviceUri, string serviceType, SemanticVersion clientVersion);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ClientVersion();
}
internal class NuGet.Protocol.ServiceIndexResourceV3 : object {
    private string _json;
    private IDictionary`2<string, List`1<ServiceIndexEntry>> _index;
    private DateTime _requestTime;
    private static IReadOnlyList`1<ServiceIndexEntry> _emptyEntries;
    private static SemanticVersion _defaultVersion;
    public DateTime RequestTime { get; }
    public IReadOnlyList`1<ServiceIndexEntry> Entries { get; }
    public string Json { get; }
    public ServiceIndexResourceV3(JObject index, DateTime requestTime);
    private static ServiceIndexResourceV3();
    public virtual DateTime get_RequestTime();
    public virtual IReadOnlyList`1<ServiceIndexEntry> get_Entries();
    public virtual string get_Json();
    public virtual IReadOnlyList`1<ServiceIndexEntry> GetServiceEntries(String[] orderedTypes);
    public virtual IReadOnlyList`1<ServiceIndexEntry> GetServiceEntries(NuGetVersion clientVersion, String[] orderedTypes);
    private IReadOnlyList`1<ServiceIndexEntry> GetBestVersionMatchForType(NuGetVersion clientVersion, List`1<ServiceIndexEntry> entries);
    public virtual Uri GetServiceEntryUri(String[] orderedTypes);
    public virtual IReadOnlyList`1<Uri> GetServiceEntryUris(String[] orderedTypes);
    public virtual IReadOnlyList`1<Uri> GetServiceEntryUris(NuGetVersion clientVersion, String[] orderedTypes);
    private static IDictionary`2<string, List`1<ServiceIndexEntry>> MakeLookup(JObject index);
    [IteratorStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3/<GetValues>d__19")]
private static IEnumerable`1<string> GetValues(JToken token);
}
internal class NuGet.Protocol.ServiceIndexResourceV3Provider : ResourceProvider {
    private static TimeSpan _defaultCacheDuration;
    private ConcurrentDictionary`2<string, ServiceIndexCacheInfo> _cache;
    private SemaphoreSlim _semaphore;
    private EnhancedHttpRetryHelper _enhancedHttpRetryHelper;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCacheDuration>k__BackingField;
    public TimeSpan MaxCacheDuration { get; protected set; }
    internal ServiceIndexResourceV3Provider(IEnvironmentVariableReader environmentVariableReader);
    private static ServiceIndexResourceV3Provider();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxCacheDuration();
    [CompilerGeneratedAttribute]
protected void set_MaxCacheDuration(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<TryCreate>d__10")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<GetServiceIndexResourceV3>d__11")]
private Task`1<ServiceIndexResourceV3> GetServiceIndexResourceV3(SourceRepository source, DateTime utcNow, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<ConsumeServiceIndexStreamAsync>d__12")]
private Task`1<ServiceIndexResourceV3> ConsumeServiceIndexStreamAsync(Stream stream, DateTime utcNow, CancellationToken token);
}
internal static class NuGet.Protocol.ServiceTypes : object {
    public static string Version200;
    public static string Version300beta;
    public static string Version300rc;
    public static string Version300;
    public static string Version340;
    public static string Version360;
    public static string Versioned;
    public static string Version470;
    public static string Version490;
    public static string Version500;
    public static string Version510;
    internal static string Version670;
    internal static string Version6110;
    public static String[] SearchQueryService;
    public static String[] RegistrationsBaseUrl;
    public static String[] SearchAutocompleteService;
    public static String[] ReportAbuse;
    public static String[] PackageDetailsUriTemplate;
    public static String[] LegacyGallery;
    public static String[] PackagePublish;
    public static String[] PackageBaseAddress;
    public static String[] RepositorySignatures;
    public static String[] SymbolPackagePublish;
    internal static String[] VulnerabilityInfo;
    internal static String[] OwnerDetailsUriTemplate;
    private static ServiceTypes();
}
[ExtensionAttribute]
internal static class NuGet.Protocol.StreamExtensions : object {
    public static int BufferSize;
    private static StreamExtensions();
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<CopyToAsync>d__1")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream stream, Stream destination, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<AsJObjectAsync>d__2")]
[ExtensionAttribute]
internal static Task`1<JObject> AsJObjectAsync(Stream stream, CancellationToken token);
    [ExtensionAttribute]
internal static Task`1<Stream> AsSeekableStreamAsync(Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<AsSeekableStreamAsync>d__4")]
[ExtensionAttribute]
internal static Task`1<Stream> AsSeekableStreamAsync(Stream stream, bool leaveStreamOpen, CancellationToken token);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Protocol.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AddPackage_ExistingPackageInvalid { get; }
    internal static string AddPackage_PackageAlreadyExists { get; }
    internal static string AddPackage_SuccessfullyAdded { get; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string DefaultSymbolServer { get; }
    internal static string DeleteCommandCanceled { get; }
    internal static string DeleteCommandConfirm { get; }
    internal static string DeleteCommandDeletedPackage { get; }
    internal static string DeleteCommandDeletingPackage { get; }
    internal static string DeletePackage_NotFound { get; }
    internal static string Error_DownloadTimeout { get; }
    internal static string Http_CredentialsForForbidden { get; }
    internal static string Http_CredentialsForProxy { get; }
    internal static string Http_CredentialsForUnauthorized { get; }
    internal static string Http_RequestLog { get; }
    internal static string Http_ResponseLog { get; }
    internal static string Http_ResponseLogWithRetryAfter { get; }
    internal static string Http_Timeout { get; }
    internal static string InvalidVersionFolder { get; }
    internal static string LiveFeed { get; }
    internal static string LoadFileFromNupkg_FileNotFound { get; }
    internal static string LoadFileFromNupkg_FileTooLarge { get; }
    internal static string LoadFileFromNupkg_UnknownProblemLoadingTheFile { get; }
    internal static string Log_CanceledNupkgDownload { get; }
    internal static string Log_ErrorDownloading { get; }
    internal static string Log_FailedToDownloadPackage { get; }
    internal static string Log_FailedToFetchV2Feed { get; }
    internal static string Log_FailedToFetchV2FeedHttp { get; }
    internal static string Log_FailedToGetNuspecStream { get; }
    internal static string Log_FailedToParseRepoSignInfor { get; }
    internal static string Log_FailedToReadRepositorySignature { get; }
    internal static string Log_FailedToReadServiceIndex { get; }
    internal static string Log_FailedToRetrievePackage { get; }
    internal static string Log_FailedToVerifyRootDirectory { get; }
    internal static string Log_FailedToVerifyValidFile { get; }
    internal static string Log_FileIsCorrupt { get; }
    internal static string Log_InvalidCacheEntry { get; }
    internal static string Log_InvalidNupkgFromUrl { get; }
    internal static string Log_LocalSourceNotExist { get; }
    internal static string Log_RetryingFindPackagesById { get; }
    internal static string Log_RetryingHttp { get; }
    internal static string Log_RetryingRepositorySignature { get; }
    internal static string Log_RetryingServiceIndex { get; }
    internal static string NoApiKeyFound { get; }
    internal static string NuGetLicense_LicenseExpressionVersionTooHigh { get; }
    internal static string NuGetLicenseExpression_NonStandardIdentifier { get; }
    internal static string NupkgPath_Invalid { get; }
    internal static string NupkgPath_InvalidEx { get; }
    internal static string OneOrMoreUrisMustBeSpecified { get; }
    internal static string PackageNotFound { get; }
    internal static string PackageServerEndpoint_NotSupported { get; }
    internal static string Path_Invalid { get; }
    internal static string Path_Invalid_NotFileNotUnc { get; }
    internal static string Plugin_ConnectionAlreadyStarted { get; }
    internal static string Plugin_ConnectionIsClosed { get; }
    internal static string Plugin_DownloadNotSupportedSinceUnsignedNotAllowed { get; }
    internal static string Plugin_Exception { get; }
    internal static string Plugin_FailedOnCreation { get; }
    internal static string Plugin_FailedOperationForPackage { get; }
    internal static string Plugin_FailureQueryingPackageVersions { get; }
    internal static string Plugin_Fault { get; }
    internal static string Plugin_FileNotFound { get; }
    internal static string Plugin_HandshakeFailed { get; }
    internal static string Plugin_HandshakeRequestHandlerAlreadyExists { get; }
    internal static string Plugin_IdleTimeoutMustBeGreaterThanOrEqualToInfiniteTimeSpan { get; }
    internal static string Plugin_InitializationFailed { get; }
    internal static string Plugin_InvalidEmbeddedSignature { get; }
    internal static string Plugin_InvalidMessageType { get; }
    internal static string Plugin_InvalidPluginFilePath { get; }
    internal static string Plugin_NotConnected { get; }
    internal static string Plugin_PackageDownloadFailed { get; }
    internal static string Plugin_ProblemStartingPlugin { get; }
    internal static string Plugin_ProtocolException { get; }
    internal static string Plugin_ProtocolVersionNotSupportedOnError { get; }
    internal static string Plugin_ProtocolVersionOutOfRange { get; }
    internal static string Plugin_RequestContextDoesNotExist { get; }
    internal static string Plugin_RequestHandlerDoesNotExist { get; }
    internal static string Plugin_TimeoutOutOfRange { get; }
    internal static string Plugin_UnrecognizedEnumValue { get; }
    internal static string Plugin_UnrecognizedOperationClaims { get; }
    internal static string Protocol_BadSource { get; }
    internal static string Protocol_duplicateUri { get; }
    internal static string Protocol_InvalidJsonObject { get; }
    internal static string Protocol_InvalidXml { get; }
    internal static string Protocol_MalformedMetadataError { get; }
    internal static string Protocol_MissingSearchService { get; }
    internal static string Protocol_MissingVersion { get; }
    internal static string Protocol_PackageMetadataError { get; }
    internal static string Protocol_Search_LocalSourceNotFound { get; }
    internal static string Protocol_UnsupportedVersion { get; }
    internal static string PushCommandPackagePushed { get; }
    internal static string PushCommandPushingPackage { get; }
    internal static string PushCommandSkipDuplicateAdvertiseDotnetExe { get; }
    internal static string PushCommandSkipDuplicateAdvertiseNuGetExe { get; }
    internal static string PushCommandSkipDuplicateNotImplemented { get; }
    internal static string RepositoryContentUrlMustBeHttps { get; }
    internal static string RepositorySignaturesResourceMustBeHttps { get; }
    internal static string StringCannotBeNullOrEmpty { get; }
    internal static string UnableToFindFile { get; }
    internal static string UnableToParseFolderV3Version { get; }
    internal static string Vulnerability_TooManyPages { get; }
    internal static string VulnerabilityPage_CouldNotLoad { get; }
    internal static string VulnerabilityPage_HasNoName { get; }
    internal static string VulnerabilityPage_NameHasInvalidCharacters { get; }
    internal static string VulnerabilityPage_NameNotUnique { get; }
    internal static string VulnerabilityPage_NameTooLong { get; }
    internal static string VulnerabilityPage_NoUrl { get; }
    internal static string VulnerabilityPage_UrlNotHttp { get; }
    internal static string Warning_HttpServerUsage { get; }
    internal static string Warning_SymbolServerNotConfigured { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AddPackage_ExistingPackageInvalid();
    internal static string get_AddPackage_PackageAlreadyExists();
    internal static string get_AddPackage_SuccessfullyAdded();
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_DefaultSymbolServer();
    internal static string get_DeleteCommandCanceled();
    internal static string get_DeleteCommandConfirm();
    internal static string get_DeleteCommandDeletedPackage();
    internal static string get_DeleteCommandDeletingPackage();
    internal static string get_DeletePackage_NotFound();
    internal static string get_Error_DownloadTimeout();
    internal static string get_Http_CredentialsForForbidden();
    internal static string get_Http_CredentialsForProxy();
    internal static string get_Http_CredentialsForUnauthorized();
    internal static string get_Http_RequestLog();
    internal static string get_Http_ResponseLog();
    internal static string get_Http_ResponseLogWithRetryAfter();
    internal static string get_Http_Timeout();
    internal static string get_InvalidVersionFolder();
    internal static string get_LiveFeed();
    internal static string get_LoadFileFromNupkg_FileNotFound();
    internal static string get_LoadFileFromNupkg_FileTooLarge();
    internal static string get_LoadFileFromNupkg_UnknownProblemLoadingTheFile();
    internal static string get_Log_CanceledNupkgDownload();
    internal static string get_Log_ErrorDownloading();
    internal static string get_Log_FailedToDownloadPackage();
    internal static string get_Log_FailedToFetchV2Feed();
    internal static string get_Log_FailedToFetchV2FeedHttp();
    internal static string get_Log_FailedToGetNuspecStream();
    internal static string get_Log_FailedToParseRepoSignInfor();
    internal static string get_Log_FailedToReadRepositorySignature();
    internal static string get_Log_FailedToReadServiceIndex();
    internal static string get_Log_FailedToRetrievePackage();
    internal static string get_Log_FailedToVerifyRootDirectory();
    internal static string get_Log_FailedToVerifyValidFile();
    internal static string get_Log_FileIsCorrupt();
    internal static string get_Log_InvalidCacheEntry();
    internal static string get_Log_InvalidNupkgFromUrl();
    internal static string get_Log_LocalSourceNotExist();
    internal static string get_Log_RetryingFindPackagesById();
    internal static string get_Log_RetryingHttp();
    internal static string get_Log_RetryingRepositorySignature();
    internal static string get_Log_RetryingServiceIndex();
    internal static string get_NoApiKeyFound();
    internal static string get_NuGetLicense_LicenseExpressionVersionTooHigh();
    internal static string get_NuGetLicenseExpression_NonStandardIdentifier();
    internal static string get_NupkgPath_Invalid();
    internal static string get_NupkgPath_InvalidEx();
    internal static string get_OneOrMoreUrisMustBeSpecified();
    internal static string get_PackageNotFound();
    internal static string get_PackageServerEndpoint_NotSupported();
    internal static string get_Path_Invalid();
    internal static string get_Path_Invalid_NotFileNotUnc();
    internal static string get_Plugin_ConnectionAlreadyStarted();
    internal static string get_Plugin_ConnectionIsClosed();
    internal static string get_Plugin_DownloadNotSupportedSinceUnsignedNotAllowed();
    internal static string get_Plugin_Exception();
    internal static string get_Plugin_FailedOnCreation();
    internal static string get_Plugin_FailedOperationForPackage();
    internal static string get_Plugin_FailureQueryingPackageVersions();
    internal static string get_Plugin_Fault();
    internal static string get_Plugin_FileNotFound();
    internal static string get_Plugin_HandshakeFailed();
    internal static string get_Plugin_HandshakeRequestHandlerAlreadyExists();
    internal static string get_Plugin_IdleTimeoutMustBeGreaterThanOrEqualToInfiniteTimeSpan();
    internal static string get_Plugin_InitializationFailed();
    internal static string get_Plugin_InvalidEmbeddedSignature();
    internal static string get_Plugin_InvalidMessageType();
    internal static string get_Plugin_InvalidPluginFilePath();
    internal static string get_Plugin_NotConnected();
    internal static string get_Plugin_PackageDownloadFailed();
    internal static string get_Plugin_ProblemStartingPlugin();
    internal static string get_Plugin_ProtocolException();
    internal static string get_Plugin_ProtocolVersionNotSupportedOnError();
    internal static string get_Plugin_ProtocolVersionOutOfRange();
    internal static string get_Plugin_RequestContextDoesNotExist();
    internal static string get_Plugin_RequestHandlerDoesNotExist();
    internal static string get_Plugin_TimeoutOutOfRange();
    internal static string get_Plugin_UnrecognizedEnumValue();
    internal static string get_Plugin_UnrecognizedOperationClaims();
    internal static string get_Protocol_BadSource();
    internal static string get_Protocol_duplicateUri();
    internal static string get_Protocol_InvalidJsonObject();
    internal static string get_Protocol_InvalidXml();
    internal static string get_Protocol_MalformedMetadataError();
    internal static string get_Protocol_MissingSearchService();
    internal static string get_Protocol_MissingVersion();
    internal static string get_Protocol_PackageMetadataError();
    internal static string get_Protocol_Search_LocalSourceNotFound();
    internal static string get_Protocol_UnsupportedVersion();
    internal static string get_PushCommandPackagePushed();
    internal static string get_PushCommandPushingPackage();
    internal static string get_PushCommandSkipDuplicateAdvertiseDotnetExe();
    internal static string get_PushCommandSkipDuplicateAdvertiseNuGetExe();
    internal static string get_PushCommandSkipDuplicateNotImplemented();
    internal static string get_RepositoryContentUrlMustBeHttps();
    internal static string get_RepositorySignaturesResourceMustBeHttps();
    internal static string get_StringCannotBeNullOrEmpty();
    internal static string get_UnableToFindFile();
    internal static string get_UnableToParseFolderV3Version();
    internal static string get_Vulnerability_TooManyPages();
    internal static string get_VulnerabilityPage_CouldNotLoad();
    internal static string get_VulnerabilityPage_HasNoName();
    internal static string get_VulnerabilityPage_NameHasInvalidCharacters();
    internal static string get_VulnerabilityPage_NameNotUnique();
    internal static string get_VulnerabilityPage_NameTooLong();
    internal static string get_VulnerabilityPage_NoUrl();
    internal static string get_VulnerabilityPage_UrlNotHttp();
    internal static string get_Warning_HttpServerUsage();
    internal static string get_Warning_SymbolServerNotConfigured();
}
internal class NuGet.Protocol.StsAuthenticationHandler : DelegatingHandler {
    private static SemaphoreSlim _credentialPromptLock;
    public static string STSEndPointHeader;
    public static string STSRealmHeader;
    public static string STSTokenHeader;
    private Uri _baseUri;
    private TokenStore _tokenStore;
    private Func`3<string, string, string> _tokenFactory;
    public StsAuthenticationHandler(PackageSource packageSource, TokenStore tokenStore);
    public StsAuthenticationHandler(PackageSource packageSource, TokenStore tokenStore, Func`3<string, string, string> tokenFactory);
    private static StsAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.StsAuthenticationHandler/<SendAsync>d__9")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private void PrepareSTSRequest(HttpRequestMessage request);
    public bool TryRetrieveSTSToken(HttpResponseMessage response);
    private static string AcquireSTSToken(string endpoint, string realm);
    private static string GetHeader(HttpResponseMessage response, string header);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.SymbolPackageUpdateResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.SymbolPackageUpdateResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.TimeoutUtility : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.TimeoutUtility/<StartWithTimeout>d__0`1")]
public static Task`1<T> StartWithTimeout(Func`2<CancellationToken, Task`1<T>> getTask, TimeSpan timeout, string timeoutMessage, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.TimeoutUtility/<StartWithTimeout>d__1")]
public static Task StartWithTimeout(Func`2<CancellationToken, Task> getTask, TimeSpan timeout, string timeoutMessage, CancellationToken token);
}
internal class NuGet.Protocol.TokenStore : object {
    private ConcurrentDictionary`2<Uri, string> _tokenCache;
    [CompilerGeneratedAttribute]
private static TokenStore <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Version>k__BackingField;
    public static TokenStore Instance { get; }
    public Guid Version { get; private set; }
    private static TokenStore();
    [CompilerGeneratedAttribute]
public static TokenStore get_Instance();
    [CompilerGeneratedAttribute]
public Guid get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Guid value);
    public string GetToken(Uri sourceUri);
    public void AddToken(Uri sourceUri, string token);
    private void StoreToken(Uri uri, string token);
    private static Uri GetRootUri(Uri uri);
}
internal static class NuGet.Protocol.Trim : object {
    public static void TrimByAllowedVersions(RegistrationInfo registrationInfo, IDictionary`2<string, VersionRange> allowedVersions);
    private static void Execute(RegistrationInfo registrationInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass1(PackageInfo packageInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass1(RegistrationInfo registrationInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass2(PackageInfo packageInfo, Boolean& updated);
    private static void Pass2(RegistrationInfo registrationInfo, Boolean& updated);
    private static bool CheckDependenciesExists(PackageInfo packageInfo);
}
internal static class NuGet.Protocol.Types : object {
    public static Uri PackageSearchResult;
    public static Uri PackageIdentity;
    public static Uri PackageDescription;
    public static Uri PackageLicensing;
    public static Uri PackageDependencies;
    public static Uri DependencyGroup;
    public static Uri Dependency;
    public static Uri Stats;
    private static Types();
}
internal class NuGet.Protocol.V2FeedListResource : ListResource {
    private ILegacyFeedCapabilityResource _feedCapabilities;
    private IV2FeedParser _feedParser;
    private string _baseAddress;
    private static int Take;
    public string Source { get; }
    public V2FeedListResource(IV2FeedParser feedParser, ILegacyFeedCapabilityResource feedCapabilities, string baseAddress);
    public virtual string get_Source();
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedListResource/<ListAsync>d__7")]
public virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger logger, CancellationToken token);
}
internal class NuGet.Protocol.V2FeedListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.V2FeedPackageInfo : PackageIdentity {
    private string _title;
    private string _summary;
    private String[] _authors;
    private string _description;
    private String[] _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    private string _reportAbuseUrl;
    private string _galleryDetailsUrl;
    private string _tags;
    private string _downloadCount;
    private bool _requireLicenseAcceptance;
    private Nullable`1<DateTimeOffset> _created;
    private Nullable`1<DateTimeOffset> _lastEdited;
    private Nullable`1<DateTimeOffset> _published;
    private string _dependencies;
    private string _downloadUrl;
    private string _packageHash;
    private string _packageHashAlgorithm;
    private NuGetVersion _minClientVersion;
    private static string NullString;
    public string Title { get; }
    public string Summary { get; }
    public string Description { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public string IconUrl { get; }
    public string LicenseUrl { get; }
    public string ProjectUrl { get; }
    public string DownloadUrl { get; }
    public string ReportAbuseUrl { get; }
    public string GalleryDetailsUrl { get; }
    public string Tags { get; }
    public string DownloadCount { get; }
    public int DownloadCountAsInt { get; }
    public Nullable`1<DateTimeOffset> Created { get; }
    public Nullable`1<DateTimeOffset> LastEdited { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public bool IsListed { get; }
    public string Dependencies { get; }
    public IReadOnlyList`1<PackageDependencyGroup> DependencySets { get; }
    public bool RequireLicenseAcceptance { get; }
    public string PackageHash { get; }
    public string PackageHashAlgorithm { get; }
    public NuGetVersion MinClientVersion { get; }
    public V2FeedPackageInfo(PackageIdentity identity, string title, string summary, string description, IEnumerable`1<string> authors, IEnumerable`1<string> owners, string iconUrl, string licenseUrl, string projectUrl, string reportAbuseUrl, string galleryDetailsUrl, string tags, Nullable`1<DateTimeOffset> created, Nullable`1<DateTimeOffset> lastEdited, Nullable`1<DateTimeOffset> published, string dependencies, bool requireLicenseAccept, string downloadUrl, string downloadCount, string packageHash, string packageHashAlgorithm, NuGetVersion minClientVersion);
    public string get_Title();
    public string get_Summary();
    public string get_Description();
    public IEnumerable`1<string> get_Authors();
    public IEnumerable`1<string> get_Owners();
    public string get_IconUrl();
    public string get_LicenseUrl();
    public string get_ProjectUrl();
    public string get_DownloadUrl();
    public string get_ReportAbuseUrl();
    public string get_GalleryDetailsUrl();
    public string get_Tags();
    public string get_DownloadCount();
    public int get_DownloadCountAsInt();
    public Nullable`1<DateTimeOffset> get_Created();
    public Nullable`1<DateTimeOffset> get_LastEdited();
    public Nullable`1<DateTimeOffset> get_Published();
    public bool get_IsListed();
    public string get_Dependencies();
    public IReadOnlyList`1<PackageDependencyGroup> get_DependencySets();
    public bool get_RequireLicenseAcceptance();
    public string get_PackageHash();
    public string get_PackageHashAlgorithm();
    public NuGetVersion get_MinClientVersion();
}
internal class NuGet.Protocol.V2FeedPage : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<V2FeedPackageInfo> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextUri>k__BackingField;
    public IReadOnlyList`1<V2FeedPackageInfo> Items { get; }
    public string NextUri { get; }
    public V2FeedPage(List`1<V2FeedPackageInfo> items, string nextUri);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<V2FeedPackageInfo> get_Items();
    [CompilerGeneratedAttribute]
public string get_NextUri();
}
internal class NuGet.Protocol.V2FeedParser : object {
    private static string W3Atom;
    private static string MetadataNS;
    private static string DataServicesNS;
    private static XName _xnameEntry;
    private static XName _xnameTitle;
    private static XName _xnameContent;
    private static XName _xnameLink;
    private static XName _xnameProperties;
    private static XName _xnameId;
    private static XName _xnameVersion;
    private static XName _xnameSummary;
    private static XName _xnameDescription;
    private static XName _xnameIconUrl;
    private static XName _xnameLicenseUrl;
    private static XName _xnameProjectUrl;
    private static XName _xnameTags;
    private static XName _xnameGalleryDetailsUrl;
    private static XName _xnameReportAbuseUrl;
    private static XName _xnameDependencies;
    private static XName _xnameRequireLicenseAcceptance;
    private static XName _xnameDownloadCount;
    private static XName _xnameCreated;
    private static XName _xnameLastEdited;
    private static XName _xnamePublished;
    private static XName _xnameName;
    private static XName _xnameAuthor;
    private static XName _xnamePackageHash;
    private static XName _xnamePackageHashAlgorithm;
    private static XName _xnameMinClientVersion;
    private HttpSource _httpSource;
    private string _baseAddress;
    private V2FeedQueryBuilder _queryBuilder;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Source { get; private set; }
    public V2FeedParser(HttpSource httpSource, string baseAddress);
    public V2FeedParser(HttpSource httpSource, string baseAddress, string source);
    private static V2FeedParser();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetPackage>d__38")]
public Task`1<V2FeedPackageInfo> GetPackage(PackageIdentity package, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<FindPackagesByIdAsync>d__39")]
public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> FindPackagesByIdAsync(string id, bool includeUnlisted, bool includePrerelease, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> FindPackagesByIdAsync(string id, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetPackagesPageAsync>d__41")]
public sealed virtual Task`1<V2FeedPage> GetPackagesPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetSearchPageAsync>d__42")]
public sealed virtual Task`1<V2FeedPage> GetSearchPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<Search>d__43")]
public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<DownloadFromUrl>d__44")]
public Task`1<DownloadResourceResult> DownloadFromUrl(PackageIdentity package, Uri downloadUri, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<DownloadFromIdentity>d__45")]
public Task`1<DownloadResourceResult> DownloadFromIdentity(PackageIdentity package, PackageDownloadContext downloadContext, string globalPackagesFolder, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private IEnumerable`1<V2FeedPackageInfo> ParsePage(XDocument doc, string id, MetadataReferenceCache metadataCache);
    private V2FeedPackageInfo ParsePackage(string id, XElement element, MetadataReferenceCache metadataCache);
    private static string GetString(XElement parent, XName childName);
    private static Nullable`1<DateTimeOffset> GetDate(XElement parent, XName childName);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<QueryV2FeedAsync>d__50")]
public Task`1<V2FeedPage> QueryV2FeedAsync(string relativeUri, string id, int max, bool ignoreNotFounds, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    private string GetCacheKey(string relativeUri, int page);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<LoadXmlAsync>d__52")]
internal Task`1<XDocument> LoadXmlAsync(string uri, string cacheKey, bool ignoreNotFounds, SourceCacheContext sourceCacheContext, ILogger log, CancellationToken token);
    internal static string GetNextUrl(XDocument doc);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<LoadXmlAsync>d__54")]
internal static Task`1<XDocument> LoadXmlAsync(Stream stream, CancellationToken token);
}
internal class NuGet.Protocol.V2FeedQueryBuilder : object {
    private static string IsLatestVersionFilterFlag;
    private static string IsAbsoluteLatestVersionFilterFlag;
    private static string IdProperty;
    private static string SemVerLevel;
    private static string GetSpecificPackageFormat;
    private static string SearchEndpointFormat;
    private static string QueryDelimiter;
    private static string FindPackagesByIdFormat;
    private static string GetPackagesFormat;
    private static string EndpointParenthesis;
    private static string SearchClauseFormat;
    private static string OrFormat;
    private static string AndFormat;
    private static string FilterFormat;
    private static string OrderByFormat;
    private static string SkipFormat;
    private static string TopFormat;
    private static string TagTermFormat;
    private static string FirstParameterFormat;
    private static string ParameterFormat;
    private static string TagsProperty;
    private static String[] _propertiesToSearch;
    private static V2FeedQueryBuilder();
    public string BuildSearchUri(string searchTerm, SearchFilter filters, int skip, int take);
    public string BuildFindPackagesByIdUri(string id);
    public string BuildGetPackageUri(PackageIdentity package);
    public string BuildGetPackagesUri(string searchTerm, SearchFilter filters, Nullable`1<int> skip, Nullable`1<int> take);
    private string BuildTop(Nullable`1<int> top);
    private string BuildSkip(Nullable`1<int> skip);
    private string BuildFilter(string searchTerm, Nullable`1<SearchFilterType> searchFilterType);
    private string BuildOrderBy(Nullable`1<SearchOrderBy> searchOrderBy);
    private string BuildPropertyFilter(Nullable`1<SearchFilterType> searchFilterType);
    private string BuildFieldSearchFilter(string searchTerm);
    private string BuildFieldSearchClause(string term, string property);
    [CompilerGeneratedAttribute]
private string <BuildFieldSearchFilter>b__31_1(string term, string property);
}
internal static class NuGet.Protocol.V2FeedUtilities : object {
    public static IPackageSearchMetadata CreatePackageSearchResult(V2FeedPackageInfo package, MetadataReferenceCache metadataCache, SearchFilter filter, V2FeedParser feedParser, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedUtilities/<GetVersions>d__1")]
private static Task`1<IEnumerable`1<VersionInfo>> GetVersions(V2FeedPackageInfo package, MetadataReferenceCache metadataCache, SearchFilter filter, V2FeedParser feedParser, ILogger log, CancellationToken cancellationToken);
}
internal class NuGet.Protocol.V3FeedListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.V3FeedListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.VersionInfoConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.VersionRangeConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[ExtensionAttribute]
internal static class NuGet.Protocol.VisualStudio.FactoryExtensionsVS : object {
    [ExtensionAttribute]
public static SourceRepository GetVisualStudio(RepositoryFactory factory, string source);
    [ExtensionAttribute]
public static SourceRepository GetVisualStudio(RepositoryFactory factory, PackageSource source);
    [IteratorStateMachineAttribute("NuGet.Protocol.VisualStudio.FactoryExtensionsVS/<GetVisualStudio>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetVisualStudio(ProviderFactory factory);
}
internal class NuGet.Repositories.LocalPackageInfo : object {
    private Lazy`1<NuspecReader> _nuspec;
    private Lazy`1<IReadOnlyList`1<string>> _files;
    private Lazy`1<string> _sha512;
    private Lazy`1<RuntimeGraph> _runtimeGraph;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpandedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManifestPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ZipPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512Path>k__BackingField;
    public string Id { get; }
    public NuGetVersion Version { get; }
    public string ExpandedPath { get; public set; }
    public string ManifestPath { get; }
    public string ZipPath { get; }
    public string Sha512Path { get; }
    public NuspecReader Nuspec { get; }
    public IReadOnlyList`1<string> Files { get; }
    public string Sha512 { get; }
    public RuntimeGraph RuntimeGraph { get; }
    public LocalPackageInfo(string packageId, NuGetVersion version, string path, string manifestPath, string zipPath, string sha512Path, Lazy`1<NuspecReader> nuspec, Lazy`1<IReadOnlyList`1<string>> files, Lazy`1<string> sha512, Lazy`1<RuntimeGraph> runtimeGraph);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public string get_ExpandedPath();
    [CompilerGeneratedAttribute]
public void set_ExpandedPath(string value);
    [CompilerGeneratedAttribute]
public string get_ManifestPath();
    [CompilerGeneratedAttribute]
public string get_ZipPath();
    [CompilerGeneratedAttribute]
public string get_Sha512Path();
    public NuspecReader get_Nuspec();
    public IReadOnlyList`1<string> get_Files();
    public string get_Sha512();
    public RuntimeGraph get_RuntimeGraph();
    public virtual string ToString();
}
internal class NuGet.Repositories.LocalPackageSourceInfo : object {
    [CompilerGeneratedAttribute]
private NuGetv3LocalRepository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalPackageInfo <Package>k__BackingField;
    public NuGetv3LocalRepository Repository { get; }
    public LocalPackageInfo Package { get; }
    public LocalPackageSourceInfo(NuGetv3LocalRepository repository, LocalPackageInfo package);
    [CompilerGeneratedAttribute]
public NuGetv3LocalRepository get_Repository();
    [CompilerGeneratedAttribute]
public LocalPackageInfo get_Package();
}
internal class NuGet.Repositories.NuGetv3LocalRepository : object {
    private ConcurrentDictionary`2<string, LocalPackageInfo> _packageCache;
    private ConcurrentDictionary`2<string, List`1<LocalPackageInfo>> _cache;
    private ConcurrentDictionary`2<string, object> _idLocks;
    private LocalPackageFileCache _packageFileCache;
    private bool _isFallbackFolder;
    private bool _updateLastAccessTime;
    [CompilerGeneratedAttribute]
private VersionFolderPathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryRoot>k__BackingField;
    public VersionFolderPathResolver PathResolver { get; }
    public string RepositoryRoot { get; }
    public NuGetv3LocalRepository(string path);
    public NuGetv3LocalRepository(string path, LocalPackageFileCache packageFileCache, bool isFallbackFolder);
    public NuGetv3LocalRepository(string path, LocalPackageFileCache packageFileCache, bool isFallbackFolder, bool updateLastAccessTime);
    [CompilerGeneratedAttribute]
public VersionFolderPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public string get_RepositoryRoot();
    public bool Exists(string packageId, NuGetVersion version);
    public LocalPackageInfo FindPackage(string packageId, NuGetVersion version);
    public IEnumerable`1<LocalPackageInfo> FindPackagesById(string packageId);
    private List`1<LocalPackageInfo> FindPackagesByIdImpl(string packageId);
    private LocalPackageInfo FindPackageImpl(string packageId, NuGetVersion version);
    private List`1<LocalPackageInfo> GetPackages(string id);
    private LocalPackageInfo GetPackage(string packageId, NuGetVersion version, string path);
    private LocalPackageInfo CreateLocalPackageInfo(string id, NuGetVersion version, string fullVersionDir, string newHashPath, string zipPath);
    public void ClearCacheForIds(IEnumerable`1<string> packageIds);
    private object GetLockObj(string privateId);
    [CompilerGeneratedAttribute]
private List`1<LocalPackageInfo> <FindPackagesByIdImpl>b__18_0(string id);
}
internal static class NuGet.Repositories.NuGetv3LocalRepositoryUtility : object {
    public static LocalPackageSourceInfo GetPackage(IReadOnlyList`1<NuGetv3LocalRepository> repositories, string id, NuGetVersion version);
}
internal class NuGet.RuntimeModel.CompatibilityProfile : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FrameworkRuntimePair> <RestoreContexts>k__BackingField;
    public string Name { get; }
    public IList`1<FrameworkRuntimePair> RestoreContexts { get; }
    public CompatibilityProfile(string name);
    public CompatibilityProfile(string name, IEnumerable`1<FrameworkRuntimePair> restoreContexts);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<FrameworkRuntimePair> get_RestoreContexts();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CompatibilityProfile other);
    public CompatibilityProfile Clone();
}
internal interface NuGet.RuntimeModel.IObjectWriter {
    public abstract virtual void WriteObjectStart();
    public abstract virtual void WriteObjectStart(string name);
    public abstract virtual void WriteObjectEnd();
    public abstract virtual void WriteNameValue(string name, int value);
    public abstract virtual void WriteNameValue(string name, bool value);
    public abstract virtual void WriteNameValue(string name, string value);
    public abstract virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public abstract virtual void WriteNonEmptyNameArray(string name, IEnumerable`1<string> values);
    public abstract virtual void WriteArrayStart(string name);
    public abstract virtual void WriteArrayEnd();
}
internal class NuGet.RuntimeModel.JsonObjectWriter : object {
    private JsonWriter _writer;
    private bool _isDisposed;
    public JsonObjectWriter(JsonWriter writer);
    public sealed virtual void Dispose();
    public sealed virtual void WriteObjectStart();
    public sealed virtual void WriteObjectStart(string name);
    public sealed virtual void WriteArrayStart(string name);
    public sealed virtual void WriteObjectEnd();
    public sealed virtual void WriteArrayEnd();
    public sealed virtual void WriteNameValue(string name, int value);
    public sealed virtual void WriteNameValue(string name, bool value);
    public sealed virtual void WriteNameValue(string name, string value);
    public sealed virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public sealed virtual void WriteNonEmptyNameArray(string name, IEnumerable`1<string> values);
    private void ThrowIfDisposed();
}
internal static class NuGet.RuntimeModel.JsonRuntimeFormat : object {
    public static RuntimeGraph ReadRuntimeGraph(string filePath);
    public static RuntimeGraph ReadRuntimeGraph(Stream stream);
    public static RuntimeGraph ReadRuntimeGraph(TextReader textReader);
    public static void WriteRuntimeGraph(string filePath, RuntimeGraph runtimeGraph);
    public static RuntimeGraph ReadRuntimeGraph(JToken json);
    public static void WriteRuntimeGraph(IObjectWriter writer, RuntimeGraph runtimeGraph);
    private static void WriteRuntimeDescription(IObjectWriter writer, RuntimeDescription data);
    private static void WriteRuntimeDependencySet(IObjectWriter writer, RuntimeDependencySet data);
    private static void WritePackageDependency(IObjectWriter writer, RuntimePackageDependency data);
    private static void WriteCompatibilityProfile(IObjectWriter writer, CompatibilityProfile data);
    private static CompatibilityProfile ReadCompatibilityProfile(KeyValuePair`2<string, JToken> json);
    [IteratorStateMachineAttribute("NuGet.RuntimeModel.JsonRuntimeFormat/<ReadCompatibilitySets>d__11")]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(KeyValuePair`2<string, JToken> property);
    private static RuntimeDescription ReadRuntimeDescription(KeyValuePair`2<string, JToken> json);
    private static RuntimeDependencySet ReadRuntimeDependencySet(KeyValuePair`2<string, JToken> json);
    private static RuntimePackageDependency ReadRuntimePackageDependency(KeyValuePair`2<string, JToken> json);
    private static IEnumerable`1<KeyValuePair`2<string, JToken>> EachProperty(JToken json);
}
internal class NuGet.RuntimeModel.RuntimeDependencySet : object {
    private static IReadOnlyDictionary`2<string, RuntimePackageDependency> EmptyDependencies;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimePackageDependency> <Dependencies>k__BackingField;
    public string Id { get; }
    public IReadOnlyDictionary`2<string, RuntimePackageDependency> Dependencies { get; }
    public RuntimeDependencySet(string id);
    public RuntimeDependencySet(string id, IEnumerable`1<RuntimePackageDependency> dependencies);
    private RuntimeDependencySet(string id, IReadOnlyDictionary`2<string, RuntimePackageDependency> dependencies);
    private static RuntimeDependencySet();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimePackageDependency> get_Dependencies();
    public sealed virtual bool Equals(RuntimeDependencySet other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimeDependencySet Clone();
    public virtual string ToString();
}
internal class NuGet.RuntimeModel.RuntimeDescription : object {
    private static IReadOnlyDictionary`2<string, RuntimeDependencySet> EmptyRuntimeDependencySets;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InheritedRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimeDependencySet> <RuntimeDependencySets>k__BackingField;
    public string RuntimeIdentifier { get; }
    public IReadOnlyList`1<string> InheritedRuntimes { get; }
    public IReadOnlyDictionary`2<string, RuntimeDependencySet> RuntimeDependencySets { get; }
    public RuntimeDescription(string runtimeIdentifier);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<string> inheritedRuntimes);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<RuntimeDependencySet> runtimeDependencySets);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<string> inheritedRuntimes, IEnumerable`1<RuntimeDependencySet> runtimeDependencySets);
    private RuntimeDescription(string runtimeIdentifier, IReadOnlyList`1<string> inheritedRuntimes, IReadOnlyDictionary`2<string, RuntimeDependencySet> runtimeDependencySets);
    private static RuntimeDescription();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InheritedRuntimes();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimeDependencySet> get_RuntimeDependencySets();
    public sealed virtual bool Equals(RuntimeDescription other);
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimeDescription Clone();
    public static RuntimeDescription Merge(RuntimeDescription left, RuntimeDescription right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal class NuGet.RuntimeModel.RuntimeGraph : object {
    private static ReadOnlyDictionary`2<string, RuntimeDescription> EmptyRuntimes;
    private static ReadOnlyDictionary`2<string, CompatibilityProfile> EmptySupports;
    [NuGet.Packaging.NullableAttribute("2")]
private ConcurrentDictionary`2<RuntimeCompatKey, bool> _areCompatible;
    [NuGet.Packaging.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, HashSet`1<string>> _expandCache;
    [NuGet.Packaging.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<RuntimeDependencyKey, List`1<RuntimePackageDependency>> _dependencyCache;
    [NuGet.Packaging.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _packagesWithDependencies;
    public static string RuntimeGraphFileName;
    public static RuntimeGraph Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimeDescription> <Runtimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, CompatibilityProfile> <Supports>k__BackingField;
    public IReadOnlyDictionary`2<string, RuntimeDescription> Runtimes { get; }
    public IReadOnlyDictionary`2<string, CompatibilityProfile> Supports { get; }
    internal bool IsEmpty { get; }
    public RuntimeGraph(IEnumerable`1<RuntimeDescription> runtimes);
    public RuntimeGraph(IEnumerable`1<CompatibilityProfile> supports);
    public RuntimeGraph(IEnumerable`1<RuntimeDescription> runtimes, IEnumerable`1<CompatibilityProfile> supports);
    private RuntimeGraph(IReadOnlyDictionary`2<string, RuntimeDescription> runtimes, IReadOnlyDictionary`2<string, CompatibilityProfile> supports);
    private static RuntimeGraph();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimeDescription> get_Runtimes();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, CompatibilityProfile> get_Supports();
    internal bool get_IsEmpty();
    public RuntimeGraph Clone();
    public static RuntimeGraph Merge(RuntimeGraph left, RuntimeGraph right);
    public IEnumerable`1<string> ExpandRuntime(string runtime);
    private HashSet`1<string> ExpandRuntimeCached(string runtime);
    public bool AreCompatible(string criteria, string provided);
    public IEnumerable`1<RuntimePackageDependency> FindRuntimeDependencies(string runtimeName, string packageId);
    [NuGet.Packaging.NullableContextAttribute("2")]
public sealed virtual bool Equals(RuntimeGraph other);
    [NuGet.Packaging.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static IReadOnlyDictionary`2<string, T> <Clone>g__Clone|21_1(IReadOnlyDictionary`2<string, T> source, Func`2<T, T> cloneFunc);
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExpandRuntimeCached>b__24_0(string r);
    [IteratorStateMachineAttribute("NuGet.RuntimeModel.RuntimeGraph/<<ExpandRuntimeCached>g__ExpandRuntimeInternal|24_1>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExpandRuntimeCached>g__ExpandRuntimeInternal|24_1(string runtime);
    [CompilerGeneratedAttribute]
private bool <AreCompatible>g__AreCompatibleInternal|25_0(RuntimeCompatKey key);
    [CompilerGeneratedAttribute]
internal static List`1<RuntimePackageDependency> <FindRuntimeDependencies>g__FindRuntimeDependenciesInternal|26_1(RuntimeDependencyKey key, RuntimeGraph runtimeGraph);
}
internal class NuGet.RuntimeModel.RuntimePackageDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    public string Id { get; }
    public VersionRange VersionRange { get; }
    public RuntimePackageDependency(string id, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimePackageDependency Clone();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RuntimePackageDependency other);
}
internal static class NuGet.Shared.EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.Commands486115.EncodingUtility : object {
    [NuGet.Commands.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Commands.NullableContextAttribute("2")]
[NuGet.Commands.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Commands486115.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Commands.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Commands.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Commands.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Commands.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Commands486115.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.Commands.NullableContextAttribute("1")]
[NuGet.Commands.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Commands486115.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Commands486115.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Commands.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Commands.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Commands.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.Commands486115.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Common674679.EncodingUtility : object {
    [NuGet.Common.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Common.NullableContextAttribute("2")]
[NuGet.Common.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Common674679.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Common.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Common.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Common.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Common.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Common674679.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Common674679.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Common674679.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Common.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Common.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Common.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
internal static class NuGet.Shared.NuGet.Common674679.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Configuration724319.EncodingUtility : object {
    [NuGet.Configuration.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Configuration.NullableContextAttribute("2")]
[NuGet.Configuration.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Configuration724319.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Configuration.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Configuration724319.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Configuration724319.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Configuration724319.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Configuration.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Configuration.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Configuration.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.Shared.NuGet.Configuration724319.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Credentials795379.EncodingUtility : object {
    [NuGet.Credentials.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Credentials.NullableContextAttribute("2")]
[NuGet.Credentials.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Credentials795379.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Credentials.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Credentials.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Credentials.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Credentials.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Credentials.NullableContextAttribute("1")]
[NuGet.Credentials.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Credentials795379.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.Credentials.NullableContextAttribute("1")]
[NuGet.Credentials.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Credentials795379.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Credentials795379.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Credentials.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Credentials.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Credentials.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.Credentials795379.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.DependencyResolver.Core818074.EncodingUtility : object {
    [NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("2")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.DependencyResolver.Core818074.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.DependencyResolver.Core818074.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.DependencyResolver.Core.NullableContextAttribute("1")]
[NuGet.DependencyResolver.Core.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.DependencyResolver.Core818074.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.DependencyResolver.Core818074.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.DependencyResolver.Core.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.DependencyResolver.Core.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.DependencyResolver.Core.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.DependencyResolver.Core818074.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Frameworks856443.EncodingUtility : object {
    [NuGet.Frameworks.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Frameworks.NullableContextAttribute("2")]
[NuGet.Frameworks.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Frameworks856443.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Frameworks.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Frameworks.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Frameworks.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Frameworks.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Frameworks856443.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Frameworks856443.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Frameworks856443.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Frameworks.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Frameworks.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Frameworks.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal static class NuGet.Shared.NuGet.Frameworks856443.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.LibraryModel904366.EncodingUtility : object {
    [NuGet.LibraryModel.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.LibraryModel.NullableContextAttribute("2")]
[NuGet.LibraryModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.LibraryModel904366.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.LibraryModel.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.LibraryModel904366.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.LibraryModel904366.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.LibraryModel904366.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.LibraryModel.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.LibraryModel.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.LibraryModel.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
internal static class NuGet.Shared.NuGet.LibraryModel904366.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Packaging925837.EncodingUtility : object {
    [NuGet.Packaging.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Packaging.NullableContextAttribute("2")]
[NuGet.Packaging.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Packaging925837.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Packaging.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Packaging.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Packaging.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Packaging.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Packaging925837.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Packaging925837.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Packaging925837.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Packaging.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Packaging.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Packaging.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.Packaging925837.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.ProjectModel1175159.EncodingUtility : object {
    [NuGet.ProjectModel.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.ProjectModel.NullableContextAttribute("2")]
[NuGet.ProjectModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.ProjectModel1175159.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.ProjectModel.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.ProjectModel.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.ProjectModel.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.ProjectModel.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.ProjectModel1175159.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.ProjectModel.NullableContextAttribute("1")]
[NuGet.ProjectModel.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.ProjectModel1175159.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.ProjectModel1175159.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.ProjectModel.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.ProjectModel.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.ProjectModel.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.ProjectModel1175159.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Protocol1276564.EncodingUtility : object {
    [NuGet.Protocol.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Protocol.NullableContextAttribute("2")]
[NuGet.Protocol.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Protocol1276564.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Protocol.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Protocol.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Protocol.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Protocol.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Protocol1276564.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.Protocol.NullableContextAttribute("1")]
[NuGet.Protocol.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Protocol1276564.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Protocol1276564.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Protocol.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Protocol.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Protocol.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.Protocol1276564.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Versioning1599207.EncodingUtility : object {
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Versioning.NullableContextAttribute("2")]
[NuGet.Versioning.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Versioning1599207.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Versioning.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Versioning1599207.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Versioning1599207.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Versioning1599207.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Versioning.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Versioning.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Versioning.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal static class NuGet.Shared.NuGet.Versioning1599207.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.SimplePool`1 : object {
    private object _lockObj;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.StringBuilderPool : object {
    private static int MaxPoolSize;
    private SimplePool`1<StringBuilder> _pool;
    public static StringBuilderPool Shared;
    private static StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.Versioning.FloatRange : object {
    private NuGetVersion _minVersion;
    private NuGetVersionFloatBehavior _floatBehavior;
    [NuGet.Versioning.NullableAttribute("2")]
private string _releasePrefix;
    public bool HasMinVersion { get; }
    public NuGetVersion MinVersion { get; }
    public NuGetVersionFloatBehavior FloatBehavior { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public string OriginalReleasePrefix { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "OriginalReleasePrefix")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "_releasePrefix")]
public bool IncludePrerelease { get; }
    public FloatRange(NuGetVersionFloatBehavior floatBehavior);
    public FloatRange(NuGetVersionFloatBehavior floatBehavior, NuGetVersion minVersion);
    public FloatRange(NuGetVersionFloatBehavior floatBehavior, NuGetVersion minVersion, string releasePrefix);
    public bool get_HasMinVersion();
    public NuGetVersion get_MinVersion();
    public NuGetVersionFloatBehavior get_FloatBehavior();
    [NuGet.Versioning.NullableContextAttribute("2")]
public string get_OriginalReleasePrefix();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "OriginalReleasePrefix")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "_releasePrefix")]
public bool get_IncludePrerelease();
    public bool Satisfies(NuGetVersion version);
    public static FloatRange Parse(string versionString);
    public static bool TryParse(string versionString, FloatRange& range);
    private static int CalculateVersionParts(string line);
    public virtual string ToString();
    public void ToString(StringBuilder sb);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual bool Equals(FloatRange other);
    [NuGet.Versioning.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static int <TryParse>g__IndexOf|18_0(string str, char c);
}
[NuGet.Versioning.NullableContextAttribute("1")]
internal interface NuGet.Versioning.INuGetVersionable {
    public NuGetVersion Version { get; }
    public abstract virtual NuGetVersion get_Version();
}
internal interface NuGet.Versioning.IVersionComparer {
}
internal interface NuGet.Versioning.IVersionRangeComparer {
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.Versioning.NuGetVersion : SemanticVersion {
    [NuGet.Versioning.NullableAttribute("2")]
private string _originalString;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    public Version Version { get; }
    public bool IsLegacyVersion { get; }
    public int Revision { get; }
    public bool IsSemVer2 { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public string OriginalVersion { get; }
    public NuGetVersion(string version);
    public NuGetVersion(NuGetVersion version);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(Version version, string releaseLabel, string metadata);
    public NuGetVersion(int major, int minor, int patch);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, string releaseLabel);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, string releaseLabel, string metadata);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, IEnumerable`1<string> releaseLabels, string metadata);
    public NuGetVersion(int major, int minor, int patch, int revision);
    public NuGetVersion(int major, int minor, int patch, int revision, string releaseLabel, string metadata);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, int revision, IEnumerable`1<string> releaseLabels, string metadata);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(Version version, IEnumerable`1<string> releaseLabels, string metadata, string originalVersion);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public virtual bool get_IsLegacyVersion();
    [CompilerGeneratedAttribute]
public int get_Revision();
    public bool get_IsSemVer2();
    [NuGet.Versioning.NullableContextAttribute("2")]
public string get_OriginalVersion();
    public static NuGetVersion Parse(string value);
    [NuGet.Versioning.NullableContextAttribute("2")]
public static bool TryParse(string value, NuGetVersion& version);
    private static bool TryGetNormalizedVersion(string str, Version& version);
    public static bool TryParseStrict(string value, NuGetVersion& version);
    private static string GetLegacyString(Version version, IEnumerable`1<string> releaseLabels, string metadata);
    [NuGet.Versioning.NullableContextAttribute("2")]
private static IEnumerable`1<string> ParseReleaseLabels(string releaseLabels);
    [CompilerGeneratedAttribute]
internal static int <TryParse>g__IndexOf|26_0(string str, char c);
    [CompilerGeneratedAttribute]
internal static bool <TryGetNormalizedVersion>g__ParseSection|27_0(string str, int start, Int32& end, Int32& versionNumber);
    [CompilerGeneratedAttribute]
internal static bool <TryGetNormalizedVersion>g__IsDigit|27_1(char c);
}
internal enum NuGet.Versioning.NuGetVersionFloatBehavior : Enum {
    public int value__;
    public static NuGetVersionFloatBehavior None;
    public static NuGetVersionFloatBehavior Prerelease;
    public static NuGetVersionFloatBehavior Revision;
    public static NuGetVersionFloatBehavior Patch;
    public static NuGetVersionFloatBehavior Minor;
    public static NuGetVersionFloatBehavior Major;
    public static NuGetVersionFloatBehavior AbsoluteLatest;
    public static NuGetVersionFloatBehavior PrereleaseRevision;
    public static NuGetVersionFloatBehavior PrereleasePatch;
    public static NuGetVersionFloatBehavior PrereleaseMinor;
    public static NuGetVersionFloatBehavior PrereleaseMajor;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Versioning.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string CannotBeNullWhenParameterIsNotNull { get; }
    internal static string InvalidFloatRangeValue { get; }
    internal static string Invalidvalue { get; }
    internal static string TypeNotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_CannotBeNullWhenParameterIsNotNull();
    internal static string get_InvalidFloatRangeValue();
    internal static string get_Invalidvalue();
    internal static string get_TypeNotSupported();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal static class NuGet.Versioning.ResourcesFormatter : object {
    internal static ArgumentException TypeNotSupported(Type type, string paramName);
    internal static ArgumentNullException CannotBeNullWhenParameterIsNull(string parameterThatIsNull, string parameterThisIsNotNull);
}
[NuGet.Versioning.NullableContextAttribute("2")]
[NuGet.Versioning.NullableAttribute("0")]
[TypeConverterAttribute("NuGet.Versioning.SemanticVersionConverter")]
internal class NuGet.Versioning.SemanticVersion : object {
    [NuGet.Versioning.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] _releaseLabels;
    internal string _metadata;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [NuGet.Versioning.NullableAttribute("1")]
internal static String[] EmptyReleaseLabels;
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    [NuGet.Versioning.NullableAttribute("1")]
public IEnumerable`1<string> ReleaseLabels { get; }
    [NuGet.Versioning.NullableAttribute("1")]
public string Release { get; }
    public bool IsPrerelease { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "Metadata")]
public bool HasMetadata { get; }
    public string Metadata { get; }
    [NuGet.Versioning.NullableContextAttribute("1")]
public SemanticVersion(SemanticVersion version);
    public SemanticVersion(int major, int minor, int patch);
    public SemanticVersion(int major, int minor, int patch, string releaseLabel);
    public SemanticVersion(int major, int minor, int patch, string releaseLabel, string metadata);
    public SemanticVersion(int major, int minor, int patch, IEnumerable`1<string> releaseLabels, string metadata);
    protected SemanticVersion(Version version, string releaseLabel, string metadata);
    protected SemanticVersion(int major, int minor, int patch, int revision, string releaseLabel, string metadata);
    protected SemanticVersion(int major, int minor, int patch, int revision, IEnumerable`1<string> releaseLabels, string metadata);
    [NuGet.Versioning.NullableContextAttribute("1")]
protected SemanticVersion(Version version, IEnumerable`1<string> releaseLabels, string metadata);
    private static SemanticVersion();
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
public int get_Patch();
    [NuGet.Versioning.NullableContextAttribute("1")]
public IEnumerable`1<string> get_ReleaseLabels();
    [NuGet.Versioning.NullableContextAttribute("1")]
public string get_Release();
    public virtual bool get_IsPrerelease();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "Metadata")]
public virtual bool get_HasMetadata();
    public virtual string get_Metadata();
    [NuGet.Versioning.NullableContextAttribute("1")]
public virtual string ToNormalizedString();
    [NuGet.Versioning.NullableContextAttribute("1")]
public virtual string ToFullString();
    [NuGet.Versioning.NullableContextAttribute("1")]
public virtual string ToString();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    protected bool TryFormatter(string format, IFormatProvider formatProvider, String& formattedString);
    public virtual int GetHashCode();
    public virtual int CompareTo(object obj);
    public virtual int CompareTo(SemanticVersion other);
    public virtual bool Equals(object obj);
    public virtual bool Equals(SemanticVersion other);
    public virtual bool Equals(SemanticVersion other, VersionComparison versionComparison);
    public virtual int CompareTo(SemanticVersion other, VersionComparison versionComparison);
    public static bool op_Equality(SemanticVersion version1, SemanticVersion version2);
    public static bool op_Inequality(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool op_LessThan(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool op_LessThanOrEqual(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool op_GreaterThan(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool op_GreaterThanOrEqual(SemanticVersion version1, SemanticVersion version2);
    private static int Compare(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static SemanticVersion Parse(string value);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool TryParse(string value, SemanticVersion& version);
    internal static bool IsLetterOrDigitOrDash(char c);
    internal static bool IsDigit(char c);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool IsValid(string s, bool allowLeadingZeros);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool IsValidPart(string s, bool allowLeadingZeros);
    internal static void ParseSections(string value, String& versionString, String[]& releaseLabels, String& buildMetadata);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static Version NormalizeVersionValue(Version version);
    private static String[] ParseReleaseLabels(string releaseLabels);
}
[NuGet.Versioning.NullableContextAttribute("2")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.Versioning.SemanticVersionConverter : TypeConverter {
    [NuGet.Versioning.NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.Versioning.VersionComparer : object {
    private VersionComparison _mode;
    public static IVersionComparer Default;
    public static IVersionComparer Version;
    public static IVersionComparer VersionRelease;
    public static IVersionComparer VersionReleaseMetadata;
    public VersionComparer(VersionComparison versionComparison);
    private static VersionComparer();
    public static IVersionComparer Get(VersionComparison versionComparison);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual bool Equals(SemanticVersion x, SemanticVersion y);
    [NuGet.Versioning.NullableContextAttribute("2")]
public static int Compare(SemanticVersion version1, SemanticVersion version2, VersionComparison versionComparison);
    public sealed virtual int GetHashCode(SemanticVersion version);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual int Compare(SemanticVersion x, SemanticVersion y);
    [NuGet.Versioning.NullableContextAttribute("2")]
private static int CompareLegacyVersion(NuGetVersion legacyX, NuGetVersion legacyY);
    private static int CompareReleaseLabels(String[] version1, String[] version2);
    private static int CompareRelease(string version1, string version2);
    private static String[] GetReleaseLabelsOrNull(SemanticVersion version);
    private static bool AreReleaseLabelsEqual(SemanticVersion x, SemanticVersion y);
    private static int GetRevisionOrZero(SemanticVersion version);
}
internal enum NuGet.Versioning.VersionComparison : Enum {
    public int value__;
    public static VersionComparison Default;
    public static VersionComparison Version;
    public static VersionComparison VersionRelease;
    public static VersionComparison VersionReleaseMetadata;
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Versioning.VersionExtensions : object {
    [ExtensionAttribute]
public static T FindBestMatch(IEnumerable`1<T> items, VersionRange ideal, Func`2<T, NuGetVersion> selector);
    [ExtensionAttribute]
public static INuGetVersionable FindBestMatch(IEnumerable`1<INuGetVersionable> items, VersionRange ideal);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.Versioning.VersionFormatter : object {
    public static VersionFormatter Instance;
    private static VersionFormatter();
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    private static void Format(StringBuilder builder, char c, SemanticVersion version);
    private static void AppendFull(StringBuilder builder, SemanticVersion version);
    internal static void AppendNormalized(StringBuilder builder, SemanticVersion version);
    private static void AppendVersion(StringBuilder builder, SemanticVersion version);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.Versioning.VersionRange : VersionRangeBase {
    [NuGet.Versioning.NullableAttribute("2")]
private FloatRange _floatRange;
    [NuGet.Versioning.NullableAttribute("2")]
private string _originalString;
    public static VersionRange All;
    private static NuGetVersion V0;
    [ObsoleteAttribute("Consider not using this VersionRange. The lack of a proper normalized version means that it is not round trippable in an assets file.")]
public static VersionRange AllFloating;
    public static VersionRange AllStable;
    [ObsoleteAttribute("Consider not using this VersionRange. The lack of a proper normalized version means that it is not round trippable in an assets file.")]
public static VersionRange AllStableFloating;
    public static VersionRange None;
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "Float")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "_floatRange")]
public bool IsFloating { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public NuGetVersion MinVersion { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public NuGetVersion MaxVersion { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool HasLowerBound { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool IsMinInclusive { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasUpperBound { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMaxInclusive { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasLowerAndUpperBounds { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public FloatRange Float { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public string OriginalString { get; }
    public VersionRange(NuGetVersion minVersion);
    public VersionRange(NuGetVersion minVersion, FloatRange floatRange);
    public VersionRange(VersionRange range, FloatRange floatRange);
    [NuGet.Versioning.NullableContextAttribute("2")]
public VersionRange(NuGetVersion minVersion, bool includeMinVersion, NuGetVersion maxVersion, bool includeMaxVersion, FloatRange floatRange, string originalString);
    private static VersionRange();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "Float")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "_floatRange")]
public bool get_IsFloating();
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion get_MinVersion();
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion get_MaxVersion();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_HasLowerBound();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_IsMinInclusive();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasUpperBound();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMaxInclusive();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasLowerAndUpperBounds();
    [NuGet.Versioning.NullableContextAttribute("2")]
public FloatRange get_Float();
    [NuGet.Versioning.NullableContextAttribute("2")]
public string get_OriginalString();
    public virtual string ToString();
    public virtual string ToNormalizedString();
    public virtual string ToLegacyString();
    public virtual string ToLegacyShortString();
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [NuGet.Versioning.NullableContextAttribute("2")]
protected bool TryFormatter(string format, IFormatProvider formatProvider, String& formattedString);
    public string PrettyPrint();
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion FindBestMatch(IEnumerable`1<NuGetVersion> versions);
    public bool IsBetter(NuGetVersion current, NuGetVersion considering);
    public VersionRange ToNonSnapshotRange();
    private static NuGetVersion GetNonSnapshotVersion(NuGetVersion version);
    public virtual string ToShortString();
    [NuGet.Versioning.NullableContextAttribute("2")]
public bool Equals(VersionRange other);
    [NuGet.Versioning.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static VersionRange Parse(string value);
    public static VersionRange Parse(string value, bool allowFloating);
    public static bool TryParse(string value, VersionRange& versionRange);
    public static bool TryParse(string value, bool allowFloating, VersionRange& versionRange);
    public static VersionRange Combine(IEnumerable`1<NuGetVersion> versions);
    public static VersionRange Combine(IEnumerable`1<NuGetVersion> versions, IVersionComparer comparer);
    public static VersionRange Combine(IEnumerable`1<VersionRange> ranges);
    public static VersionRange Combine(IEnumerable`1<VersionRange> ranges, IVersionComparer comparer);
    public static VersionRange CommonSubSet(IEnumerable`1<VersionRange> ranges);
    public static VersionRange CommonSubSet(IEnumerable`1<VersionRange> ranges, IVersionComparer comparer);
    private static bool HasValidRange(VersionRange range);
}
[NuGet.Versioning.NullableContextAttribute("2")]
[NuGet.Versioning.NullableAttribute("0")]
internal abstract class NuGet.Versioning.VersionRangeBase : object {
    private bool _includeMinVersion;
    private bool _includeMaxVersion;
    private NuGetVersion _minVersion;
    private NuGetVersion _maxVersion;
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool HasLowerBound { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasUpperBound { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasLowerAndUpperBounds { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMinInclusive { get; }
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMaxInclusive { get; }
    public NuGetVersion MaxVersion { get; }
    public NuGetVersion MinVersion { get; }
    protected bool HasPrereleaseBounds { get; }
    public VersionRangeBase(NuGetVersion minVersion, bool includeMinVersion, NuGetVersion maxVersion, bool includeMaxVersion);
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_HasLowerBound();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasUpperBound();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasLowerAndUpperBounds();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMinInclusive();
    [NuGet.Versioning1599207.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMaxInclusive();
    public NuGetVersion get_MaxVersion();
    public NuGetVersion get_MinVersion();
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version, VersionComparison versionComparison);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version, IVersionComparer comparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VersionRangeBase other);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Equals(VersionRangeBase other, IVersionRangeComparer comparer);
    public bool Equals(VersionRangeBase other, VersionComparison versionComparison);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Equals(VersionRangeBase other, IVersionComparer versionComparer);
    public bool IsSubSetOrEqualTo(VersionRangeBase possibleSuperSet);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool IsSubSetOrEqualTo(VersionRangeBase possibleSuperSet, IVersionComparer comparer);
    protected bool get_HasPrereleaseBounds();
    private static Nullable`1<bool> IsPrerelease(SemanticVersion version);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.Versioning.VersionRangeComparer : object {
    private IVersionComparer _versionComparer;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <VersionRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <VersionReleaseMetadata>k__BackingField;
    public static IVersionRangeComparer Default { get; }
    internal static IVersionRangeComparer Version { get; }
    public static IVersionRangeComparer VersionRelease { get; }
    internal static IVersionRangeComparer VersionReleaseMetadata { get; }
    public VersionRangeComparer(VersionComparison versionComparison);
    public VersionRangeComparer(IVersionComparer versionComparer);
    private static VersionRangeComparer();
    [CompilerGeneratedAttribute]
public static IVersionRangeComparer get_Default();
    [CompilerGeneratedAttribute]
internal static IVersionRangeComparer get_Version();
    [CompilerGeneratedAttribute]
public static IVersionRangeComparer get_VersionRelease();
    [CompilerGeneratedAttribute]
internal static IVersionRangeComparer get_VersionReleaseMetadata();
    public static IVersionRangeComparer Get(VersionComparison versionComparison);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual bool Equals(VersionRangeBase x, VersionRangeBase y);
    public sealed virtual int GetHashCode(VersionRangeBase obj);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.Versioning.VersionRangeFormatter : object {
    public static VersionRangeFormatter Instance;
    private static VersionRangeFormatter();
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    private static void Format(StringBuilder builder, char c, VersionRange range);
    private static void GetShortString(StringBuilder builder, VersionRange range);
    private static void GetNormalizedString(StringBuilder builder, VersionRange range);
    private static void GetToString(StringBuilder builder, VersionRange range);
    private static void GetLegacyShortString(StringBuilder builder, VersionRangeBase range);
    private static void GetLegacyString(StringBuilder builder, VersionRangeBase range);
    private static void PrettyPrint(StringBuilder builder, VersionRange range, bool useParentheses);
    private static void PrettyPrintBound(StringBuilder builder, NuGetVersion version, bool inclusive, string boundChar);
}
internal static class ODataServiceDocumentUtils : object {
    [AsyncStateMachineAttribute("ODataServiceDocumentUtils/<CreateODataServiceDocumentResourceV2>d__0")]
public static Task`1<ODataServiceDocumentResourceV2> CreateODataServiceDocumentResourceV2(string url, HttpSource client, DateTime utcNow, ILogger log, CancellationToken token);
}
internal class System.Buffers.ArrayBufferWriter`1 : object {
    private static int ArrayMaxLength;
    private static int DefaultInitialBufferSize;
    private T[] _buffer;
    private int _index;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
    private static void ThrowOutOfMemoryException(UInt32 capacity);
}
internal class System.Buffers.ArrayMemoryPool`1 : MemoryPool`1<T> {
    private static int s_maxBufferSize;
    public int MaxBufferSize { get; }
    public sealed virtual int get_MaxBufferSize();
    public sealed virtual IMemoryOwner`1<T> Rent(int minimumBufferSize);
    protected sealed virtual void Dispose(bool disposing);
}
internal class System.Buffers.ArrayPool`1 : object {
    private static int MaxPooledArraySize;
    private NuGet.Packaging925837.SimplePool`1<T[]> _pool;
    public static ArrayPool`1<T> Shared;
    private static ArrayPool`1();
    public T[] Rent(int minimumLength);
    public void Return(T[] array);
}
[EventSourceAttribute]
internal class System.Buffers.ArrayPoolEventSource : EventSource {
    internal static ArrayPoolEventSource Log;
    private static ArrayPoolEventSource();
    [EventAttribute("1")]
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
    [EventAttribute("2")]
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason);
    [EventAttribute("3")]
internal void BufferReturned(int bufferId, int bufferSize, int poolId);
}
internal static class System.Buffers.Binary.BinaryPrimitives : object {
    [CLSCompliantAttribute("False")]
public static sbyte ReverseEndianness(sbyte value);
    public static short ReverseEndianness(short value);
    public static int ReverseEndianness(int value);
    public static long ReverseEndianness(long value);
    public static byte ReverseEndianness(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ReverseEndianness(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ReverseEndianness(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ReverseEndianness(ulong value);
    public static short ReadInt16BigEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32BigEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static short ReadInt16LittleEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32LittleEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static void WriteInt16BigEndian(Span`1<byte> destination, short value);
    public static void WriteInt32BigEndian(Span`1<byte> destination, int value);
    public static void WriteInt64BigEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    public static bool TryWriteInt16BigEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32BigEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64BigEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    public static void WriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static void WriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static void WriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
    public static bool TryWriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
}
[ExtensionAttribute]
internal static class System.Buffers.BuffersExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<SequencePosition> PositionOf(ReadOnlySequence`1& source, T value);
    private static Nullable`1<SequencePosition> PositionOfMultiSegment(ReadOnlySequence`1& source, T value);
    [ExtensionAttribute]
public static void CopyTo(ReadOnlySequence`1& source, Span`1<T> destination);
    private static void CopyToMultiSegment(ReadOnlySequence`1& sequence, Span`1<T> destination);
    [ExtensionAttribute]
public static T[] ToArray(ReadOnlySequence`1& sequence);
    [ExtensionAttribute]
public static void Write(IBufferWriter`1<T> writer, ReadOnlySpan`1<T> value);
    private static void WriteMultiSegment(IBufferWriter`1<T> writer, ReadOnlySpan`1& source, Span`1<T> destination);
}
internal class System.Buffers.DefaultArrayPool`1 : System.Buffers1624809.ArrayPool`1<T> {
    private static int DefaultMaxArrayLength;
    private static int DefaultMaxNumberOfArraysPerBucket;
    private static T[] s_emptyArray;
    private Bucket[] _buckets;
    private int Id { get; }
    internal DefaultArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
internal interface System.Buffers.IBufferWriter`1 {
    public abstract virtual void Advance(int count);
    public abstract virtual Memory`1<T> GetMemory(int sizeHint);
    public abstract virtual Span`1<T> GetSpan(int sizeHint);
}
internal interface System.Buffers.IMemoryOwner`1 {
    public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
internal interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
internal class System.Buffers.MemoryHandle : ValueType {
    private Void* _pointer;
    private GCHandle _handle;
    private IPinnable _pinnable;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
internal abstract class System.Buffers.MemoryManager`1 : object {
    public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal abstract class System.Buffers.MemoryPool`1 : object {
    private static MemoryPool`1<T> s_shared;
    public static MemoryPool`1<T> Shared { get; }
    public int MaxBufferSize { get; }
    private static MemoryPool`1();
    public static MemoryPool`1<T> get_Shared();
    public abstract virtual IMemoryOwner`1<T> Rent(int minBufferSize);
    public abstract virtual int get_MaxBufferSize();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal enum System.Buffers.OperationStatus : Enum {
    public int value__;
    public static OperationStatus Done;
    public static OperationStatus DestinationTooSmall;
    public static OperationStatus NeedMoreData;
    public static OperationStatus InvalidData;
}
internal static class System.Buffers.ReadOnlySequence : object {
    public static int FlagBitMask;
    public static int IndexBitMask;
    public static int SegmentStartMask;
    public static int SegmentEndMask;
    public static int ArrayStartMask;
    public static int ArrayEndMask;
    public static int MemoryManagerStartMask;
    public static int MemoryManagerEndMask;
    public static int StringStartMask;
    public static int StringEndMask;
    public static int SegmentToSequenceStart(int startIndex);
    public static int SegmentToSequenceEnd(int endIndex);
    public static int ArrayToSequenceStart(int startIndex);
    public static int ArrayToSequenceEnd(int endIndex);
    public static int MemoryManagerToSequenceStart(int startIndex);
    public static int MemoryManagerToSequenceEnd(int endIndex);
    public static int StringToSequenceStart(int startIndex);
    public static int StringToSequenceEnd(int endIndex);
}
[System.Memory.IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.Buffers.ReadOnlySequenceDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.Buffers.ReadOnlySequence`1 : ValueType {
    private SequencePosition _sequenceStart;
    private SequencePosition _sequenceEnd;
    public static ReadOnlySequence`1<T> Empty;
    public long Length { get; }
    public bool IsEmpty { get; }
    public bool IsSingleSegment { get; }
    public ReadOnlyMemory`1<T> First { get; }
    public SequencePosition Start { get; }
    public SequencePosition End { get; }
    private ReadOnlySequence`1(object startSegment, int startIndexAndFlags, object endSegment, int endIndexAndFlags);
    public ReadOnlySequence`1(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment, int endIndex);
    public ReadOnlySequence`1(T[] array);
    public ReadOnlySequence`1(T[] array, int start, int length);
    public ReadOnlySequence`1(ReadOnlyMemory`1<T> memory);
    private static ReadOnlySequence`1();
    public long get_Length();
    public bool get_IsEmpty();
    public bool get_IsSingleSegment();
    public ReadOnlyMemory`1<T> get_First();
    public SequencePosition get_Start();
    public SequencePosition get_End();
    public ReadOnlySequence`1<T> Slice(long start, long length);
    public ReadOnlySequence`1<T> Slice(long start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, long length);
    public ReadOnlySequence`1<T> Slice(int start, int length);
    public ReadOnlySequence`1<T> Slice(int start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, int length);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start);
    public ReadOnlySequence`1<T> Slice(long start);
    public virtual string ToString();
    public Enumerator<T> GetEnumerator();
    public SequencePosition GetPosition(long offset);
    public SequencePosition GetPosition(long offset, SequencePosition origin);
    public bool TryGet(SequencePosition& position, ReadOnlyMemory`1& memory, bool advance);
    internal bool TryGetBuffer(SequencePosition& position, ReadOnlyMemory`1& memory, SequencePosition& next);
    private ReadOnlyMemory`1<T> GetFirstBuffer();
    private SequencePosition Seek(SequencePosition& start, SequencePosition& end, long offset, ExceptionArgument argument);
    private static SequencePosition SeekMultiSegment(ReadOnlySequenceSegment`1<T> currentSegment, object endObject, int endIndex, long offset, ExceptionArgument argument);
    private void BoundsCheck(SequencePosition& position);
    private void BoundsCheck(UInt32 sliceStartIndex, object sliceStartObject, UInt32 sliceEndIndex, object sliceEndObject);
    private static SequencePosition GetEndPosition(ReadOnlySequenceSegment`1<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length);
    private SequenceType<T> GetSequenceType();
    private static int GetIndex(SequencePosition& position);
    private ReadOnlySequence`1<T> SliceImpl(SequencePosition& start, SequencePosition& end);
    private long GetLength();
    internal bool TryGetReadOnlySequenceSegment(ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    internal bool TryGetArray(ArraySegment`1& segment);
    internal bool TryGetString(String& text, Int32& start, Int32& length);
    private static bool InRange(UInt32 value, UInt32 start, UInt32 end);
    private static bool InRange(ulong value, ulong start, ulong end);
}
internal class System.Buffers.ReadOnlySequenceDebugView`1 : object {
    private T[] _array;
    private ReadOnlySequenceDebugViewSegments<T> _segments;
    public ReadOnlySequenceDebugViewSegments<T> BufferSegments { get; }
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ReadOnlySequenceDebugView`1(ReadOnlySequence`1<T> sequence);
    public ReadOnlySequenceDebugViewSegments<T> get_BufferSegments();
    public T[] get_Items();
}
internal abstract class System.Buffers.ReadOnlySequenceSegment`1 : object {
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<T> <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequenceSegment`1<T> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RunningIndex>k__BackingField;
    public ReadOnlyMemory`1<T> Memory { get; protected set; }
    public ReadOnlySequenceSegment`1<T> Next { get; protected set; }
    public long RunningIndex { get; protected set; }
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<T> get_Memory();
    [CompilerGeneratedAttribute]
protected void set_Memory(ReadOnlyMemory`1<T> value);
    [CompilerGeneratedAttribute]
public ReadOnlySequenceSegment`1<T> get_Next();
    [CompilerGeneratedAttribute]
protected void set_Next(ReadOnlySequenceSegment`1<T> value);
    [CompilerGeneratedAttribute]
public long get_RunningIndex();
    [CompilerGeneratedAttribute]
protected void set_RunningIndex(long value);
}
[System.Memory.IsReadOnlyAttribute]
internal class System.Buffers.StandardFormat : ValueType {
    public static byte NoPrecision;
    public static byte MaxPrecision;
    private byte _format;
    private byte _precision;
    public char Symbol { get; }
    public byte Precision { get; }
    public bool HasPrecision { get; }
    public bool IsDefault { get; }
    public StandardFormat(char symbol, byte precision);
    public char get_Symbol();
    public byte get_Precision();
    public bool get_HasPrecision();
    public bool get_IsDefault();
    public static StandardFormat op_Implicit(char symbol);
    public static StandardFormat Parse(ReadOnlySpan`1<char> format);
    public static StandardFormat Parse(string format);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(StandardFormat other);
    public virtual string ToString();
    public static bool op_Equality(StandardFormat left, StandardFormat right);
    public static bool op_Inequality(StandardFormat left, StandardFormat right);
}
internal abstract class System.Buffers.System.Buffers1624809.ArrayPool`1 : object {
    private static System.Buffers1624809.ArrayPool`1<T> s_sharedInstance;
    public static System.Buffers1624809.ArrayPool`1<T> Shared { get; }
    private static System.Buffers1624809.ArrayPool`1();
    public static System.Buffers1624809.ArrayPool`1<T> get_Shared();
    private static System.Buffers1624809.ArrayPool`1<T> EnsureSharedCreated();
    public static System.Buffers1624809.ArrayPool`1<T> Create();
    public static System.Buffers1624809.ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
internal static class System.Buffers.Text.Base64 : object {
    private static SByte[] s_decodingMap;
    private static Byte[] s_encodingMap;
    private static byte EncodingPad;
    private static int MaximumEncodeLength;
    private static Base64();
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static int GetMaxDecodedFromUtf8Length(int length);
    public static OperationStatus DecodeFromUtf8InPlace(Span`1<byte> buffer, Int32& bytesWritten);
    private static int Decode(Byte& encodedBytes, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
    public static OperationStatus EncodeToUtf8(ReadOnlySpan`1<byte> bytes, Span`1<byte> utf8, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static int GetMaxEncodedToUtf8Length(int length);
    public static OperationStatus EncodeToUtf8InPlace(Span`1<byte> buffer, int dataLength, Int32& bytesWritten);
    private static int Encode(Byte& threeBytes, Byte& encodingMap);
    private static int EncodeAndPadOne(Byte& twoBytes, Byte& encodingMap);
    private static int EncodeAndPadTwo(Byte& oneByte, Byte& encodingMap);
}
internal static class System.Buffers.Text.FormattingHelpers : object {
    internal static string HexTableLower;
    internal static string HexTableUpper;
    public static char GetSymbolOrDefault(StandardFormat& format, char defaultSymbol);
    public static void FillWithAsciiZeros(Span`1<byte> buffer);
    public static void WriteHexByte(byte value, Span`1<byte> buffer, int startingIndex, HexCasing casing);
    public static void WriteDigits(ulong value, Span`1<byte> buffer);
    public static void WriteDigitsWithGroupSeparator(ulong value, Span`1<byte> buffer);
    public static void WriteDigits(UInt32 value, Span`1<byte> buffer);
    public static void WriteFourDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex);
    public static void WriteTwoDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex);
    public static ulong DivMod(ulong numerator, ulong denominator, UInt64& modulo);
    public static UInt32 DivMod(UInt32 numerator, UInt32 denominator, UInt32& modulo);
    public static int CountDecimalTrailingZeros(UInt32 value, UInt32& valueWithoutTrailingZeros);
    public static int CountDigits(ulong value);
    public static int CountDigits(UInt32 value);
    public static int CountHexDigits(ulong value);
}
internal static class System.Buffers.Text.ParserHelpers : object {
    public static int ByteOverflowLength;
    public static int ByteOverflowLengthHex;
    public static int UInt16OverflowLength;
    public static int UInt16OverflowLengthHex;
    public static int UInt32OverflowLength;
    public static int UInt32OverflowLengthHex;
    public static int UInt64OverflowLength;
    public static int UInt64OverflowLengthHex;
    public static int SByteOverflowLength;
    public static int SByteOverflowLengthHex;
    public static int Int16OverflowLength;
    public static int Int16OverflowLengthHex;
    public static int Int32OverflowLength;
    public static int Int32OverflowLengthHex;
    public static int Int64OverflowLength;
    public static int Int64OverflowLengthHex;
    public static Byte[] s_hexLookup;
    private static ParserHelpers();
    public static bool IsDigit(int i);
}
internal enum System.Buffers.Text.SequenceValidity : Enum {
    public int value__;
    public static SequenceValidity Empty;
    public static SequenceValidity WellFormed;
    public static SequenceValidity Incomplete;
    public static SequenceValidity Invalid;
}
internal static class System.Buffers.Text.Utf8Constants : object {
    public static byte Colon;
    public static byte Comma;
    public static byte Minus;
    public static byte Period;
    public static byte Plus;
    public static byte Slash;
    public static byte Space;
    public static byte Hyphen;
    public static byte Separator;
    public static int GroupSize;
    public static TimeSpan s_nullUtcOffset;
    public static int DateTimeMaxUtcOffsetHours;
    public static int DateTimeNumFractionDigits;
    public static int MaxDateTimeFraction;
    public static ulong BillionMaxUIntValue;
    public static UInt32 Billion;
    private static Utf8Constants();
}
internal static class System.Buffers.Text.Utf8Formatter : object {
    private static byte TimeMarker;
    private static byte UtcMarker;
    private static byte GMT1;
    private static byte GMT2;
    private static byte GMT3;
    private static byte GMT1Lowercase;
    private static byte GMT2Lowercase;
    private static byte GMT3Lowercase;
    private static UInt32[] DayAbbreviations;
    private static UInt32[] DayAbbreviationsLowercase;
    private static UInt32[] MonthAbbreviations;
    private static UInt32[] MonthAbbreviationsLowercase;
    private static byte OpenBrace;
    private static byte CloseBrace;
    private static byte OpenParen;
    private static byte CloseParen;
    private static byte Dash;
    private static Utf8Formatter();
    public static bool TryFormat(bool value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTimeOffset value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTime value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDateTimeG(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeO(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeR(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeL(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(decimal value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDecimalE(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision, byte exponentSymbol);
    private static bool TryFormatDecimalF(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision);
    private static bool TryFormatDecimalG(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(double value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(float value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatFloatingPoint(T value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(Guid value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(byte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(sbyte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ushort value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(short value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(UInt32 value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(int value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(long value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatInt64(long value, ulong mask, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatInt64D(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64Default(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt32Default(int value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt32MultipleDigits(int value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64MultipleDigits(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64MoreThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64LessThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64N(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatUInt64D(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten);
    private static bool TryFormatUInt64Default(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32Default(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32SingleDigit(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32MultipleDigits(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64SingleDigit(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64MultipleDigits(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64LessThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64MoreThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64N(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten);
    private static bool TryFormatUInt64X(ulong value, byte precision, bool useLower, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(TimeSpan value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
}
internal static class System.Buffers.Text.Utf8Parser : object {
    private static UInt32 FlipCase;
    private static UInt32 NoFlipCase;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    private static Utf8Parser();
    public static bool TryParse(ReadOnlySpan`1<byte> source, Boolean& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTime& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseDateTimeOffsetDefault(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed);
    private static bool TryParseDateTimeG(ReadOnlySpan`1<byte> source, DateTime& value, DateTimeOffset& valueAsOffset, Int32& bytesConsumed);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(int year, int month, int day, int hour, int minute, int second, int fraction, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeOffset& value);
    private static bool TryCreateDateTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeKind kind, DateTime& value);
    private static bool TryParseDateTimeOffsetO(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, DateTimeKind& kind);
    private static bool TryParseDateTimeOffsetR(ReadOnlySpan`1<byte> source, UInt32 caseFlipXorMask, DateTimeOffset& dateTimeOffset, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Decimal& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Single& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseNormalAsFloatingPoint(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseAsSpecialFloatingPoint(ReadOnlySpan`1<byte> source, T positiveInfinity, T negativeInfinity, T nan, T& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseGuidN(ReadOnlySpan`1<byte> text, Guid& value, Int32& bytesConsumed);
    private static bool TryParseGuidCore(ReadOnlySpan`1<byte> source, bool ends, char begin, char end, Guid& value, Int32& bytesConsumed);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseSByteD(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16D(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32D(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64D(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    private static bool TryParseSByteN(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16N(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32N(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64N(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseByteD(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16D(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32D(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64D(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteN(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16N(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32N(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64N(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteX(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16X(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32X(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64X(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseNumber(ReadOnlySpan`1<byte> source, NumberBuffer& number, Int32& bytesConsumed, ParseNumberOptions options, Boolean& textUsedExponentNotation);
    private static bool TryParseTimeSpanBigG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    private static bool TryParseTimeSpanC(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseTimeSpanFraction(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryCreateTimeSpan(bool isNegative, UInt32 days, UInt32 hours, UInt32 minutes, UInt32 seconds, UInt32 fraction, TimeSpan& timeSpan);
    private static bool TryParseTimeSpanLittleG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute("1")]
internal interface System.Collections.Generic.IAsyncEnumerable`1 {
    public abstract virtual IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken);
}
internal interface System.Collections.Generic.IAsyncEnumerator`1 {
    [Microsoft.Bcl.AsyncInterfaces.NullableAttribute("1")]
public T Current { get; }
    public abstract virtual ValueTask`1<bool> MoveNextAsync();
    [Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute("1")]
public abstract virtual T get_Current();
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Commands486115.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Common674679.DeconstructionExtensions : object {
    [NuGet.Common.NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Configuration724319.DeconstructionExtensions : object {
    [NuGet.Configuration.NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Credentials795379.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.DependencyResolver.Core818074.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Frameworks856443.DeconstructionExtensions : object {
    [NuGet.Frameworks.NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.LibraryModel904366.DeconstructionExtensions : object {
    [NuGet.LibraryModel.NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Packaging925837.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.ProjectModel1175159.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Protocol1276564.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Versioning1599207.DeconstructionExtensions : object {
    [NuGet.Versioning.NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
internal class System.Collections.Generic.ReferenceEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static ReferenceEqualityComparer <Instance>k__BackingField;
    public static ReferenceEqualityComparer Instance { get; }
    private static ReferenceEqualityComparer();
    [CompilerGeneratedAttribute]
public static ReferenceEqualityComparer get_Instance();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.StackExtensions : object {
    [ExtensionAttribute]
public static bool TryPeek(Stack`1<T> stack, T& result);
    [ExtensionAttribute]
public static bool TryPop(Stack`1<T> stack, T& result);
}
internal static class System.DecimalDecCalc : object {
    private static UInt32 D32DivMod1E9(UInt32 hi32, UInt32& lo32);
    internal static UInt32 DecDivMod1E9(MutableDecimal& value);
    internal static void DecAddInt32(MutableDecimal& value, UInt32 i);
    private static bool D32AddCarry(UInt32& value, UInt32 i);
    internal static void DecMul10(MutableDecimal& value);
    private static void DecShiftLeft(MutableDecimal& value);
    private static void DecAdd(MutableDecimal& value, MutableDecimal d);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    public DynamicDependencyAttribute(string memberSignature);
    public DynamicDependencyAttribute(string memberSignature, Type type);
    public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public Microsoft.Bcl.AsyncInterfaces161313.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public Microsoft.Bcl.AsyncInterfaces161313.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public Microsoft.Bcl.AsyncInterfaces161313.MemberNotNullAttribute(string member);
    public Microsoft.Bcl.AsyncInterfaces161313.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public Microsoft.Bcl.AsyncInterfaces161313.MemberNotNullWhenAttribute(bool returnValue, string member);
    public Microsoft.Bcl.AsyncInterfaces161313.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public Microsoft.Bcl.AsyncInterfaces161313.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.Microsoft.Bcl.AsyncInterfaces161313.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public Microsoft.Bcl.AsyncInterfaces161313.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.Newtonsoft.Json197846.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.Newtonsoft.Json197846.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public Newtonsoft.Json197846.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.Newtonsoft.Json197846.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("10688")]
internal class System.Diagnostics.CodeAnalysis.Newtonsoft.Json197846.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.Newtonsoft.Json197846.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public Newtonsoft.Json197846.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Commands486115.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Commands486115.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Commands486115.MemberNotNullAttribute(string member);
    public NuGet.Commands486115.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Commands486115.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Commands486115.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Commands486115.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Commands486115.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Commands486115.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Common674679.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Common674679.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Common674679.MemberNotNullAttribute(string member);
    public NuGet.Common674679.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Common674679.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Common674679.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.NotNullAttribute : Attribute {
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Common674679.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Common674679.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Common674679.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Configuration724319.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Configuration724319.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Configuration724319.MemberNotNullAttribute(string member);
    public NuGet.Configuration724319.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Configuration724319.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Configuration724319.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.NotNullAttribute : Attribute {
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Configuration724319.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Configuration724319.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration724319.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Credentials795379.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Credentials795379.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Credentials795379.MemberNotNullAttribute(string member);
    public NuGet.Credentials795379.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Credentials795379.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Credentials795379.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Credentials795379.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Credentials795379.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Credentials795379.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.DependencyResolver.Core818074.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.DependencyResolver.Core818074.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.DependencyResolver.Core818074.MemberNotNullAttribute(string member);
    public NuGet.DependencyResolver.Core818074.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.DependencyResolver.Core818074.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.DependencyResolver.Core818074.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.DependencyResolver.Core818074.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.DependencyResolver.Core818074.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.DependencyResolver.Core818074.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Frameworks856443.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Frameworks856443.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Frameworks856443.MemberNotNullAttribute(string member);
    public NuGet.Frameworks856443.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Frameworks856443.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Frameworks856443.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.NotNullAttribute : Attribute {
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Frameworks856443.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Frameworks856443.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks856443.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.LibraryModel904366.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.LibraryModel904366.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.LibraryModel904366.MemberNotNullAttribute(string member);
    public NuGet.LibraryModel904366.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.LibraryModel904366.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.LibraryModel904366.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.NotNullAttribute : Attribute {
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.LibraryModel904366.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.LibraryModel904366.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.LibraryModel904366.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Packaging925837.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Packaging925837.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Packaging925837.MemberNotNullAttribute(string member);
    public NuGet.Packaging925837.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Packaging925837.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Packaging925837.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Packaging925837.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Packaging925837.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging925837.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.ProjectModel1175159.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.ProjectModel1175159.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.ProjectModel1175159.MemberNotNullAttribute(string member);
    public NuGet.ProjectModel1175159.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.ProjectModel1175159.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.ProjectModel1175159.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.ProjectModel1175159.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.ProjectModel1175159.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.ProjectModel1175159.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Protocol1276564.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Protocol1276564.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Protocol1276564.MemberNotNullAttribute(string member);
    public NuGet.Protocol1276564.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Protocol1276564.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Protocol1276564.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Protocol1276564.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Protocol1276564.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Protocol1276564.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Versioning1599207.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Versioning1599207.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Versioning1599207.MemberNotNullAttribute(string member);
    public NuGet.Versioning1599207.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Versioning1599207.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Versioning1599207.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.NotNullAttribute : Attribute {
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Versioning1599207.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Versioning1599207.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1599207.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public System.Text.Encodings.Web1694883.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public System.Text.Encodings.Web1694883.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public System.Text.Encodings.Web1694883.MemberNotNullAttribute(string member);
    public System.Text.Encodings.Web1694883.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public System.Text.Encodings.Web1694883.MemberNotNullWhenAttribute(bool returnValue, string member);
    public System.Text.Encodings.Web1694883.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public System.Text.Encodings.Web1694883.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Encodings.Web1694883.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public System.Text.Encodings.Web1694883.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public System.Text.Json1722049.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public System.Text.Json1722049.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public System.Text.Json1722049.MemberNotNullAttribute(string member);
    public System.Text.Json1722049.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public System.Text.Json1722049.MemberNotNullWhenAttribute(bool returnValue, string member);
    public System.Text.Json1722049.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public System.Text.Json1722049.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.System.Text.Json1722049.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public System.Text.Json1722049.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("108")]
internal class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument length;
    public static ExceptionArgument start;
    public static ExceptionArgument minimumBufferSize;
    public static ExceptionArgument elementIndex;
    public static ExceptionArgument comparable;
    public static ExceptionArgument comparer;
    public static ExceptionArgument destination;
    public static ExceptionArgument offset;
    public static ExceptionArgument startSegment;
    public static ExceptionArgument endSegment;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument endIndex;
    public static ExceptionArgument array;
    public static ExceptionArgument culture;
    public static ExceptionArgument manager;
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal interface System.IAsyncDisposable {
    public abstract virtual ValueTask DisposeAsync();
}
[ExtensionAttribute]
internal static class System.IO.TextWriterExtensions : object {
    [ExtensionAttribute]
public static void WritePartialString(TextWriter writer, string value, int offset, int count);
}
internal static class System.MathF : object {
    public static float PI;
    public static float Abs(float x);
    public static float Acos(float x);
    public static float Cos(float x);
    public static float IEEERemainder(float x, float y);
    public static float Pow(float x, float y);
    public static float Sin(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
}
[CompilerGeneratedAttribute]
internal class System.Memory.<PrivateImplementationDetails> : object {
    internal static __StaticArrayInitTypeSize=64 0953DF544832295E4A5B19928F95C351F25DA86A;
    internal static __StaticArrayInitTypeSize=256 1588174EA926BCCEB6275C029A42C7E3DBA4D523;
    internal static __StaticArrayInitTypeSize=336 2B2055E39CBB1C111FB5C1C05492B3E5AAC607ED;
    internal static __StaticArrayInitTypeSize=256 3CDA7449B0586AB873C75C04BB11D4864F5D7392;
    internal static __StaticArrayInitTypeSize=240 608454F961E288A48E34666C94032BEDEFD399E1;
    internal static __StaticArrayInitTypeSize=48 B8B960BE929E7BAB90AE2CAEF2468C56CD5414C1;
    internal static __StaticArrayInitTypeSize=28 BD20BFA840DDF83194ECD4397DA071ECD4C1C72F;
    internal static __StaticArrayInitTypeSize=15 C3FB1115E83603E7E71244A6F2D43E22B790B5D1;
    internal static __StaticArrayInitTypeSize=48 C4C38BC485A320D4B7D737DB85E705077FA38BEF;
    internal static __StaticArrayInitTypeSize=42 DB5930245CE35BDE5EDC35035275D8DD55E139CF;
    internal static __StaticArrayInitTypeSize=52 DD3AEFEADB1CD615F3017763F1568179FEE640B0;
    internal static __StaticArrayInitTypeSize=52 E92B39D8233061927D9ACDE54665E68E7535635A;
    internal static __StaticArrayInitTypeSize=28 EE0B1C00D481FCA3559F2937C3DD3127C35B2FE3;
}
[System.Memory.IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.Memory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    private static int RemoveFlagsBitMask;
    public static Memory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    internal Memory`1(T[] array, int start);
    public Memory`1(T[] array, int start, int length);
    internal Memory`1(MemoryManager`1<T> manager, int length);
    internal Memory`1(MemoryManager`1<T> manager, int start, int length);
    internal Memory`1(object obj, int start, int length);
    public static Memory`1<T> op_Implicit(T[] array);
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(Memory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
}
internal class System.MemoryDebugView`1 : object {
    private ReadOnlyMemory`1<T> _memory;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public MemoryDebugView`1(Memory`1<T> memory);
    public MemoryDebugView`1(ReadOnlyMemory`1<T> memory);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.MemoryExtensions : object {
    internal static IntPtr StringAdjustment;
    private static MemoryExtensions();
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    private static bool IsTypeComparableAsBytes(NUInt& size);
    [ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    private static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    private static int CompareToOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
    private static IntPtr MeasureStringAdjustment();
}
internal static class System.Microsoft.Extensions.FileSystemGlobbing170051.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string CannotDeclarePathSegment { get; }
    internal static string CannotTestDirectory { get; }
    internal static string CannotTestFile { get; }
    internal static string UnexpectedStringComparisonType { get; }
    private static Microsoft.Extensions.FileSystemGlobbing170051.SR();
    private static bool UsingResourceKeys();
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("1")]
internal static string GetResourceString(string resourceKey);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("1")]
internal static string GetResourceString(string resourceKey, string defaultString);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1, object p2);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("2")]
internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("1")]
internal static string Format(string resourceFormat, Object[] args);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    [Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_CannotDeclarePathSegment();
    internal static string get_CannotTestDirectory();
    internal static string get_CannotTestFile();
    internal static string get_UnexpectedStringComparisonType();
}
internal static class System.Microsoft.Extensions.Primitives183838.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Argument_InvalidOffsetLength { get; }
    internal static string Argument_InvalidOffsetLengthStringSegment { get; }
    internal static string Capacity_CannotChangeAfterWriteStarted { get; }
    internal static string Capacity_NotEnough { get; }
    internal static string Capacity_NotUsedEntirely { get; }
    private static Microsoft.Extensions.Primitives183838.SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Argument_InvalidOffsetLength();
    internal static string get_Argument_InvalidOffsetLengthStringSegment();
    internal static string get_Capacity_CannotChangeAfterWriteStarted();
    internal static string get_Capacity_NotEnough();
    internal static string get_Capacity_NotUsedEntirely();
}
internal class System.MutableDecimal : ValueType {
    public UInt32 Flags;
    public UInt32 High;
    public UInt32 Low;
    public UInt32 Mid;
    private static UInt32 SignMask;
    private static UInt32 ScaleMask;
    private static int ScaleShift;
    public bool IsNegative { get; public set; }
    public int Scale { get; public set; }
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public int get_Scale();
    public void set_Scale(int value);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
    internal static Exception ByDesignWithMessage(string message);
    internal static Exception ActiveIssue(string issue);
}
internal class System.NUInt : ValueType {
    private Void* _value;
    private NUInt(UInt32 value);
    private NUInt(ulong value);
    public static NUInt op_Implicit(UInt32 value);
    public static IntPtr op_Implicit(NUInt value);
    public static NUInt op_Explicit(int value);
    public static Void* op_Explicit(NUInt value);
    public static NUInt op_Multiply(NUInt left, NUInt right);
}
internal static class System.Number : object {
    internal static int DECIMAL_PRECISION;
    private static UInt64[] s_rgval64Power10;
    private static SByte[] s_rgexp64Power10;
    private static UInt64[] s_rgval64Power10By16;
    private static Int16[] s_rgexp64Power10By16;
    private static Number();
    public static void RoundNumber(NumberBuffer& number, int pos);
    internal static bool NumberBufferToDouble(NumberBuffer& number, Double& value);
    public static bool NumberBufferToDecimal(NumberBuffer& number, Decimal& value);
    public static void DecimalToNumber(decimal value, NumberBuffer& number);
    private static UInt32 DigitsToInt(ReadOnlySpan`1<byte> digits, int count);
    private static ulong Mul32x32To64(UInt32 a, UInt32 b);
    private static ulong Mul64Lossy(ulong a, ulong b, Int32& pexp);
    private static int abs(int value);
    private static double NumberToDouble(NumberBuffer& number);
}
[System.Memory.IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.NumberBuffer : ValueType {
    public int Scale;
    public bool IsNegative;
    public static int BufferSize;
    private byte _b0;
    private byte _b1;
    private byte _b2;
    private byte _b3;
    private byte _b4;
    private byte _b5;
    private byte _b6;
    private byte _b7;
    private byte _b8;
    private byte _b9;
    private byte _b10;
    private byte _b11;
    private byte _b12;
    private byte _b13;
    private byte _b14;
    private byte _b15;
    private byte _b16;
    private byte _b17;
    private byte _b18;
    private byte _b19;
    private byte _b20;
    private byte _b21;
    private byte _b22;
    private byte _b23;
    private byte _b24;
    private byte _b25;
    private byte _b26;
    private byte _b27;
    private byte _b28;
    private byte _b29;
    private byte _b30;
    private byte _b31;
    private byte _b32;
    private byte _b33;
    private byte _b34;
    private byte _b35;
    private byte _b36;
    private byte _b37;
    private byte _b38;
    private byte _b39;
    private byte _b40;
    private byte _b41;
    private byte _b42;
    private byte _b43;
    private byte _b44;
    private byte _b45;
    private byte _b46;
    private byte _b47;
    private byte _b48;
    private byte _b49;
    private byte _b50;
    public Span`1<byte> Digits { get; }
    public Byte* UnsafeDigits { get; }
    public int NumDigits { get; }
    public Span`1<byte> get_Digits();
    public Byte* get_UnsafeDigits();
    public int get_NumDigits();
    [ConditionalAttribute("DEBUG")]
public void CheckConsistency();
    public virtual string ToString();
}
internal static class System.Numerics.BitOperations : object {
    private static ReadOnlySpan`1<byte> Log2DeBruijn { get; }
    private static ReadOnlySpan`1<byte> get_Log2DeBruijn();
    public static int Log2(UInt32 value);
    private static int Log2SoftwareFallback(UInt32 value);
}
internal class System.Numerics.ConstantHelper : object {
    public static byte GetByteWithAllBitsSet();
    public static sbyte GetSByteWithAllBitsSet();
    public static ushort GetUInt16WithAllBitsSet();
    public static short GetInt16WithAllBitsSet();
    public static UInt32 GetUInt32WithAllBitsSet();
    public static int GetInt32WithAllBitsSet();
    public static ulong GetUInt64WithAllBitsSet();
    public static long GetInt64WithAllBitsSet();
    public static float GetSingleWithAllBitsSet();
    public static double GetDoubleWithAllBitsSet();
}
internal static class System.Numerics.Hashing.HashHelpers : object {
    public static int Combine(int h1, int h2);
}
internal static class System.Numerics.Hashing.Microsoft.Extensions.Primitives183838.HashHelpers : object {
    public static int Combine(int h1, int h2);
}
internal static class System.Numerics.Hashing.System.Memory1627036.HashHelpers : object {
    public static int RandomSeed;
    private static System.Memory1627036.HashHelpers();
    public static int Combine(int h1, int h2);
}
internal static class System.Numerics.Hashing.System.Numerics.Vectors1679464.HashHelpers : object {
    public static int RandomSeed;
    private static System.Numerics.Vectors1679464.HashHelpers();
    public static int Combine(int h1, int h2);
}
internal class System.Numerics.Register : ValueType {
    internal byte byte_0;
    internal byte byte_1;
    internal byte byte_2;
    internal byte byte_3;
    internal byte byte_4;
    internal byte byte_5;
    internal byte byte_6;
    internal byte byte_7;
    internal byte byte_8;
    internal byte byte_9;
    internal byte byte_10;
    internal byte byte_11;
    internal byte byte_12;
    internal byte byte_13;
    internal byte byte_14;
    internal byte byte_15;
    internal sbyte sbyte_0;
    internal sbyte sbyte_1;
    internal sbyte sbyte_2;
    internal sbyte sbyte_3;
    internal sbyte sbyte_4;
    internal sbyte sbyte_5;
    internal sbyte sbyte_6;
    internal sbyte sbyte_7;
    internal sbyte sbyte_8;
    internal sbyte sbyte_9;
    internal sbyte sbyte_10;
    internal sbyte sbyte_11;
    internal sbyte sbyte_12;
    internal sbyte sbyte_13;
    internal sbyte sbyte_14;
    internal sbyte sbyte_15;
    internal ushort uint16_0;
    internal ushort uint16_1;
    internal ushort uint16_2;
    internal ushort uint16_3;
    internal ushort uint16_4;
    internal ushort uint16_5;
    internal ushort uint16_6;
    internal ushort uint16_7;
    internal short int16_0;
    internal short int16_1;
    internal short int16_2;
    internal short int16_3;
    internal short int16_4;
    internal short int16_5;
    internal short int16_6;
    internal short int16_7;
    internal UInt32 uint32_0;
    internal UInt32 uint32_1;
    internal UInt32 uint32_2;
    internal UInt32 uint32_3;
    internal int int32_0;
    internal int int32_1;
    internal int int32_2;
    internal int int32_3;
    internal ulong uint64_0;
    internal ulong uint64_1;
    internal long int64_0;
    internal long int64_1;
    internal float single_0;
    internal float single_1;
    internal float single_2;
    internal float single_3;
    internal double double_0;
    internal double double_1;
}
[IntrinsicAttribute]
internal static class System.Numerics.Vector : object {
    public static bool IsHardwareAccelerated { get; }
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<byte> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<ushort> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<UInt32> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<sbyte> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<short> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<int> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<float> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<byte> Narrow(Vector`1<ushort> low, Vector`1<ushort> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ushort> Narrow(Vector`1<UInt32> low, Vector`1<UInt32> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> Narrow(Vector`1<ulong> low, Vector`1<ulong> high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<sbyte> Narrow(Vector`1<short> low, Vector`1<short> high);
    [IntrinsicAttribute]
public static Vector`1<short> Narrow(Vector`1<int> low, Vector`1<int> high);
    [IntrinsicAttribute]
public static Vector`1<int> Narrow(Vector`1<long> low, Vector`1<long> high);
    [IntrinsicAttribute]
public static Vector`1<float> Narrow(Vector`1<double> low, Vector`1<double> high);
    [IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<int> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<UInt32> value);
    [IntrinsicAttribute]
public static Vector`1<double> ConvertToDouble(Vector`1<long> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<double> ConvertToDouble(Vector`1<ulong> value);
    [IntrinsicAttribute]
public static Vector`1<int> ConvertToInt32(Vector`1<float> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> ConvertToUInt32(Vector`1<float> value);
    [IntrinsicAttribute]
public static Vector`1<long> ConvertToInt64(Vector`1<double> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ulong> ConvertToUInt64(Vector`1<double> value);
    public static Vector`1<float> ConditionalSelect(Vector`1<int> condition, Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<double> ConditionalSelect(Vector`1<long> condition, Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> Equals(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> Equals(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> Equals(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> Equals(Vector`1<long> left, Vector`1<long> right);
    public static bool EqualsAll(Vector`1<T> left, Vector`1<T> right);
    public static bool EqualsAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> LessThan(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> LessThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> LessThan(Vector`1<long> left, Vector`1<long> right);
    public static bool LessThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> LessThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<long> LessThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool LessThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> GreaterThan(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> GreaterThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThan(Vector`1<double> left, Vector`1<double> right);
    public static Vector`1<long> GreaterThan(Vector`1<long> left, Vector`1<long> right);
    public static bool GreaterThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanAny(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    public static Vector`1<int> GreaterThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    public static Vector`1<long> GreaterThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool GreaterThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    public static Vector`1<T> Abs(Vector`1<T> value);
    public static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    public static T Dot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> SquareRoot(Vector`1<T> value);
    public static Vector`1<T> Add(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Subtract(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, T right);
    public static Vector`1<T> Multiply(T left, Vector`1<T> right);
    public static Vector`1<T> Divide(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Negate(Vector`1<T> value);
    public static Vector`1<T> BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> OnesComplement(Vector`1<T> value);
    public static Vector`1<T> Xor(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> AndNot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<byte> AsVectorByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<sbyte> AsVectorSByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ushort> AsVectorUInt16(Vector`1<T> value);
    public static Vector`1<short> AsVectorInt16(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> AsVectorUInt32(Vector`1<T> value);
    public static Vector`1<int> AsVectorInt32(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ulong> AsVectorUInt64(Vector`1<T> value);
    public static Vector`1<long> AsVectorInt64(Vector`1<T> value);
    public static Vector`1<float> AsVectorSingle(Vector`1<T> value);
    public static Vector`1<double> AsVectorDouble(Vector`1<T> value);
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
internal class System.Numerics.Vector`1 : ValueType {
    private Register register;
    private static int s_count;
    private static Vector`1<T> s_zero;
    private static Vector`1<T> s_one;
    private static Vector`1<T> s_allOnes;
    public static int Count { get; }
    public static Vector`1<T> Zero { get; }
    public static Vector`1<T> One { get; }
    internal static Vector`1<T> AllOnes { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public Vector`1(T value);
    [IntrinsicAttribute]
public Vector`1(T[] values);
    public Vector`1(T[] values, int index);
    internal Vector`1(Void* dataPointer);
    internal Vector`1(Void* dataPointer, int offset);
    private Vector`1(Register& existingRegister);
    private static Vector`1();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static Vector`1<T> get_Zero();
    [IntrinsicAttribute]
public static Vector`1<T> get_One();
    internal static Vector`1<T> get_AllOnes();
    private static int InitializeCount();
    [IntrinsicAttribute]
public void CopyTo(T[] destination);
    [IntrinsicAttribute]
public void CopyTo(T[] destination, int startIndex);
    [IntrinsicAttribute]
public T get_Item(int index);
    public virtual bool Equals(object obj);
    [IntrinsicAttribute]
public sealed virtual bool Equals(Vector`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static Vector`1<T> op_Addition(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Subtraction(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> value, T factor);
    public static Vector`1<T> op_Multiply(T factor, Vector`1<T> value);
    public static Vector`1<T> op_Division(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_UnaryNegation(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_ExclusiveOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_OnesComplement(Vector`1<T> value);
    public static bool op_Equality(Vector`1<T> left, Vector`1<T> right);
    public static bool op_Inequality(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<byte> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<sbyte> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ushort> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<short> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<int> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ulong> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<long> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<float> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<double> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Abs(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static T DotProduct(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> SquareRoot(Vector`1<T> value);
    private static bool ScalarEquals(T left, T right);
    private static bool ScalarLessThan(T left, T right);
    private static bool ScalarGreaterThan(T left, T right);
    private static T ScalarAdd(T left, T right);
    private static T ScalarSubtract(T left, T right);
    private static T ScalarMultiply(T left, T right);
    private static T ScalarDivide(T left, T right);
    private static T GetOneValue();
    private static T GetAllBitsSetValue();
}
[AttributeUsageAttribute("6140")]
internal class System.ObsoleteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string Message { get; }
    public bool IsError { get; }
    public string DiagnosticId { get; public set; }
    public string UrlFormat { get; public set; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [CompilerGeneratedAttribute]
public void set_DiagnosticId(string value);
    [CompilerGeneratedAttribute]
public string get_UrlFormat();
    [CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string SystemTextEncodingUTF7Message;
    internal static string SystemTextEncodingUTF7DiagId;
    internal static string PrincipalPermissionAttributeMessage;
    internal static string PrincipalPermissionAttributeDiagId;
    internal static string CodeAccessSecurityMessage;
    internal static string CodeAccessSecurityDiagId;
    internal static string ConstrainedExecutionRegionMessage;
    internal static string ConstrainedExecutionRegionDiagId;
    internal static string GlobalAssemblyCacheMessage;
    internal static string GlobalAssemblyCacheDiagId;
    internal static string ThreadAbortMessage;
    internal static string ThreadResetAbortMessage;
    internal static string ThreadAbortDiagId;
    internal static string DefaultCryptoAlgorithmsMessage;
    internal static string DefaultCryptoAlgorithmsDiagId;
    internal static string CreatePdbGeneratorMessage;
    internal static string CreatePdbGeneratorDiagId;
    internal static string AuthenticationManagerMessage;
    internal static string AuthenticationManagerDiagId;
    internal static string RemotingApisMessage;
    internal static string RemotingApisDiagId;
    internal static string BinaryFormatterMessage;
    internal static string BinaryFormatterDiagId;
    internal static string CodeBaseMessage;
    internal static string CodeBaseDiagId;
    internal static string EscapeUriStringMessage;
    internal static string EscapeUriStringDiagId;
    internal static string WebRequestMessage;
    internal static string WebRequestDiagId;
    internal static string DisablePrivateReflectionAttributeMessage;
    internal static string DisablePrivateReflectionAttributeDiagId;
    internal static string GetContextInfoMessage;
    internal static string GetContextInfoDiagId;
    internal static string StrongNameKeyPairMessage;
    internal static string StrongNameKeyPairDiagId;
    internal static string ReflectionOnlyLoadingMessage;
    internal static string ReflectionOnlyLoadingDiagId;
    internal static string RuntimeEnvironmentMessage;
    internal static string RuntimeEnvironmentDiagId;
    internal static string JsonSerializerOptionsIgnoreNullValuesMessage;
    internal static string JsonSerializerOptionsIgnoreNullValuesDiagId;
    internal static string DerivedCryptographicTypesMessage;
    internal static string DerivedCryptographicTypesDiagId;
    internal static string RijndaelMessage;
    internal static string RijndaelDiagId;
    internal static string RNGCryptoServiceProviderMessage;
    internal static string RNGCryptoServiceProviderDiagId;
    internal static string AppDomainCreateUnloadMessage;
    internal static string AppDomainCreateUnloadDiagId;
    internal static string SuppressIldasmAttributeMessage;
    internal static string SuppressIldasmAttributeDiagId;
    internal static string X509CertificateImmutableMessage;
    internal static string X509CertificateImmutableDiagId;
    internal static string PublicKeyPropertyMessage;
    internal static string PublicKeyPropertyDiagId;
    internal static string X509CertificatePrivateKeyMessage;
    internal static string X509CertificatePrivateKeyDiagId;
    internal static string ProduceLegacyHmacValuesMessage;
    internal static string ProduceLegacyHmacValuesDiagId;
    internal static string UseManagedSha1Message;
    internal static string UseManagedSha1DiagId;
    internal static string CryptoConfigEncodeOIDMessage;
    internal static string CryptoConfigEncodeOIDDiagId;
    internal static string CorruptedStateRecoveryMessage;
    internal static string CorruptedStateRecoveryDiagId;
    internal static string Rfc2898CryptDeriveKeyMessage;
    internal static string Rfc2898CryptDeriveKeyDiagId;
    internal static string CmsSignerCspParamsCtorMessage;
    internal static string CmsSignerCspParamsCtorDiagId;
    internal static string SignerInfoCounterSigMessage;
    internal static string SignerInfoCounterSigDiagId;
    internal static string RegexCompileToAssemblyMessage;
    internal static string RegexCompileToAssemblyDiagId;
    internal static string AssemblyNameMembersMessage;
    internal static string AssemblyNameMembersDiagId;
    internal static string SystemDataSerializationFormatBinaryMessage;
    internal static string SystemDataSerializationFormatBinaryDiagId;
    internal static string TlsVersion10and11Message;
    internal static string TlsVersion10and11DiagId;
    internal static string EncryptionPolicyMessage;
    internal static string EncryptionPolicyDiagId;
    internal static string Rfc2898OutdatedCtorMessage;
    internal static string Rfc2898OutdatedCtorDiagId;
    internal static string EccXmlExportImportMessage;
    internal static string EccXmlExportImportDiagId;
    internal static string EcDhPublicKeyBlobMessage;
    internal static string EcDhPublicKeyBlobDiagId;
    internal static string AssemblyNameCodeBaseMessage;
    internal static string AssemblyNameCodeBaseDiagId;
    internal static string CryptoStringFactoryMessage;
    internal static string CryptoStringFactoryDiagId;
    internal static string ControlledExecutionRunMessage;
    internal static string ControlledExecutionRunDiagId;
    internal static string XmlSecureResolverMessage;
    internal static string XmlSecureResolverDiagId;
}
internal class System.Pinnable`1 : object {
    public T Data;
}
[System.Memory.IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.ReadOnlyMemory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    internal static int RemoveFlagsBitMask;
    public static ReadOnlyMemory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    internal ReadOnlyMemory`1(object obj, int start, int length);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    private static int CombineHashCodes(int left, int right);
    private static int CombineHashCodes(int h1, int h2, int h3);
    internal object GetObjectStartLength(Int32& start, Int32& length);
}
[System.Memory.IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[System.Memory.IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.ReadOnlySpan`1 : ValueType {
    private Pinnable`1<T> _pinnable;
    private IntPtr _byteOffset;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public static ReadOnlySpan`1<T> Empty { get; }
    [System.Memory.IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    internal Pinnable`1<T> Pinnable { get; }
    internal IntPtr ByteOffset { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    internal ReadOnlySpan`1(Pinnable`1<T> pinnable, IntPtr byteOffset, int length);
    public int get_Length();
    public bool get_IsEmpty();
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public virtual string ToString();
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
internal T& DangerousGetPinnableReference();
    internal Pinnable`1<T> get_Pinnable();
    internal IntPtr get_ByteOffset();
}
[Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute("1")]
[Microsoft.Bcl.AsyncInterfaces.NullableAttribute("0")]
internal class System.Runtime.CompilerServices.AsyncIteratorMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    private object _id;
    internal object ObjectIdForDebugger { get; }
    public static AsyncIteratorMethodBuilder Create();
    public void MoveNext(TStateMachine& stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void Complete();
    internal object get_ObjectIdForDebugger();
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute : StateMachineAttribute {
    [Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute("1")]
public AsyncIteratorStateMachineAttribute(Type stateMachineType);
}
[AttributeUsageAttribute("5148")]
internal class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
}
internal class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask Task { get; }
    public static AsyncValueTaskMethodBuilder Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
internal class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    private AsyncTaskMethodBuilder`1<TResult> _methodBuilder;
    private TResult _result;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask`1<TResult> Task { get; }
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    [SecuritySafeCriticalAttribute]
public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ConfiguredAsyncDisposable : ValueType {
    private IAsyncDisposable _source;
    private bool _continueOnCapturedContext;
    internal ConfiguredAsyncDisposable(IAsyncDisposable source, bool continueOnCapturedContext);
    public ConfiguredValueTaskAwaitable DisposeAsync();
}
[IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1 : ValueType {
    private IAsyncEnumerable`1<T> _enumerable;
    private CancellationToken _cancellationToken;
    private bool _continueOnCapturedContext;
    internal ConfiguredCancelableAsyncEnumerable`1(IAsyncEnumerable`1<T> enumerable, bool continueOnCapturedContext, CancellationToken cancellationToken);
    public ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(bool continueOnCapturedContext);
    public ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(CancellationToken cancellationToken);
    public Enumerator<T> GetAsyncEnumerator();
}
[System.Threading.Tasks.Extensions.IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private ValueTask _value;
    internal ConfiguredValueTaskAwaitable(ValueTask value);
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[System.Threading.Tasks.Extensions.IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private ValueTask`1<TResult> _value;
    internal ConfiguredValueTaskAwaitable`1(ValueTask`1<TResult> value);
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.EnumeratorCancellationAttribute : Attribute {
}
[AttributeUsageAttribute("364")]
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[Microsoft.Extensions.Primitives.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[Microsoft.Bcl.AsyncInterfaces.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[Microsoft.Bcl.AsyncInterfaces.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.Microsoft.Bcl.AsyncInterfaces.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public Microsoft.Bcl.AsyncInterfaces.NullableAttribute(byte );
    public Microsoft.Bcl.AsyncInterfaces.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[Microsoft.Bcl.AsyncInterfaces.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute : Attribute {
    public byte Flag;
    public Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[Microsoft.Bcl.AsyncInterfaces.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.Microsoft.Bcl.AsyncInterfaces.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public Microsoft.Bcl.AsyncInterfaces.RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[Microsoft.Extensions.FileSystemGlobbing.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.Microsoft.Extensions.FileSystemGlobbing.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[Microsoft.Extensions.FileSystemGlobbing.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.Microsoft.Extensions.FileSystemGlobbing.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public Microsoft.Extensions.FileSystemGlobbing.NullableAttribute(byte );
    public Microsoft.Extensions.FileSystemGlobbing.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[Microsoft.Extensions.FileSystemGlobbing.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute : Attribute {
    public byte Flag;
    public Microsoft.Extensions.FileSystemGlobbing.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[Microsoft.Extensions.FileSystemGlobbing.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.Microsoft.Extensions.FileSystemGlobbing.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public Microsoft.Extensions.FileSystemGlobbing.NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[Microsoft.Extensions.Primitives.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.Microsoft.Extensions.Primitives.IsReadOnlyAttribute : Attribute {
}
[AttributeUsageAttribute("27524")]
[System.Runtime.CompilerServices.Unsafe.EmbeddedAttribute]
[CompilerGeneratedAttribute]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] A_0);
}
[CompilerGeneratedAttribute]
[Newtonsoft.Json.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.Newtonsoft.Json.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[Newtonsoft.Json.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.Newtonsoft.Json.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public Newtonsoft.Json.NullableAttribute(byte );
    public Newtonsoft.Json.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[Newtonsoft.Json.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.Newtonsoft.Json.NullableContextAttribute : Attribute {
    public byte Flag;
    public Newtonsoft.Json.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Commands.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Commands.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Commands.NullableAttribute(byte );
    public NuGet.Commands.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Commands.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Commands.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Commands.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Commands.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Commands.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Commands.RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Commands486115.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Commands486115.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Commands486115.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Commands486115.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Commands486115.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Common.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Common.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Common.NullableAttribute(byte );
    public NuGet.Common.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Common.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Common.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Common.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Common.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Common.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Common.RefSafetyRulesAttribute(int );
}
[NuGet.Common.NullableContextAttribute("1")]
[NuGet.Common.NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Common674679.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Common674679.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Common674679.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Common674679.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Common674679.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Configuration.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Configuration.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Configuration.NullableAttribute(byte );
    public NuGet.Configuration.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Configuration.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Configuration.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Configuration.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Configuration.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Configuration.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Configuration.RefSafetyRulesAttribute(int );
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Configuration724319.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Configuration724319.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Configuration724319.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Configuration724319.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Configuration724319.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Credentials.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Credentials.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Credentials.NullableAttribute(byte );
    public NuGet.Credentials.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Credentials.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Credentials.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Credentials.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Credentials.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Credentials.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Credentials.RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Credentials795379.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Credentials795379.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Credentials795379.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Credentials795379.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Credentials795379.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.DependencyResolver.Core.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.DependencyResolver.Core.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.DependencyResolver.Core.NullableAttribute(byte );
    public NuGet.DependencyResolver.Core.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.DependencyResolver.Core.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.DependencyResolver.Core.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.DependencyResolver.Core.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.DependencyResolver.Core.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.DependencyResolver.Core.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.DependencyResolver.Core.RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.DependencyResolver.Core818074.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.DependencyResolver.Core818074.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.DependencyResolver.Core818074.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.DependencyResolver.Core818074.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.DependencyResolver.Core818074.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Frameworks.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Frameworks.NullableAttribute(byte );
    public NuGet.Frameworks.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Frameworks.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Frameworks.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Frameworks.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Frameworks.RefSafetyRulesAttribute(int );
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks856443.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Frameworks856443.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Frameworks856443.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Frameworks856443.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks856443.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.LibraryModel.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.LibraryModel.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.LibraryModel.NullableAttribute(byte );
    public NuGet.LibraryModel.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.LibraryModel.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.LibraryModel.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.LibraryModel.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.LibraryModel.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.LibraryModel.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.LibraryModel.RefSafetyRulesAttribute(int );
}
[NuGet.LibraryModel.NullableContextAttribute("1")]
[NuGet.LibraryModel.NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.LibraryModel904366.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.LibraryModel904366.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.LibraryModel904366.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.LibraryModel904366.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.LibraryModel904366.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Packaging.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Packaging.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Packaging.NullableAttribute(byte );
    public NuGet.Packaging.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Packaging.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Packaging.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Packaging.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Packaging.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Packaging.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Packaging.RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Packaging925837.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Packaging925837.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Packaging925837.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Packaging925837.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Packaging925837.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.ProjectModel.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.ProjectModel.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.ProjectModel.NullableAttribute(byte );
    public NuGet.ProjectModel.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.ProjectModel.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.ProjectModel.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.ProjectModel.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.ProjectModel.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.ProjectModel.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.ProjectModel.RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.ProjectModel1175159.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.ProjectModel1175159.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.ProjectModel1175159.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.ProjectModel1175159.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.ProjectModel1175159.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Protocol.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Protocol.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Protocol.NullableAttribute(byte );
    public NuGet.Protocol.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Protocol.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Protocol.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Protocol.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Protocol.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Protocol.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Protocol.RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Protocol1276564.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Protocol1276564.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Protocol1276564.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Protocol1276564.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Protocol1276564.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Versioning.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Versioning.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Versioning.NullableAttribute(byte );
    public NuGet.Versioning.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Versioning.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Versioning.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Versioning.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Versioning.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Versioning.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Versioning.RefSafetyRulesAttribute(int );
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Versioning1599207.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Versioning1599207.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Versioning1599207.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Versioning1599207.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Versioning1599207.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[Microsoft.Bcl.AsyncInterfaces.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Memory.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.System.Memory.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Memory.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.System.Memory.IsReadOnlyAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.System.Runtime.CompilerServices.Unsafe1690956.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Encodings.Web.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.System.Text.Encodings.Web.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Encodings.Web.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.System.Text.Encodings.Web.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Encodings.Web.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.System.Text.Encodings.Web.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public System.Text.Encodings.Web.NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[System.Text.Encodings.Web.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.System.Text.Encodings.Web.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public System.Text.Encodings.Web.NullableAttribute(byte );
    public System.Text.Encodings.Web.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[System.Text.Encodings.Web.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.System.Text.Encodings.Web.NullableContextAttribute : Attribute {
    public byte Flag;
    public System.Text.Encodings.Web.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[System.Text.Encodings.Web.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.System.Text.Encodings.Web.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public System.Text.Encodings.Web.NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[System.Text.Encodings.Web.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.System.Text.Encodings.Web.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public System.Text.Encodings.Web.RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.System.Text.Json.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.System.Text.Json.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.System.Text.Json.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public System.Text.Json.NullableAttribute(byte );
    public System.Text.Json.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.System.Text.Json.NullableContextAttribute : Attribute {
    public byte Flag;
    public System.Text.Json.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.System.Text.Json.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public System.Text.Json.NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[System.Text.Json.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.System.Text.Json.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public System.Text.Json.RefSafetyRulesAttribute(int );
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[System.Threading.Tasks.Extensions.EmbeddedAttribute]
internal class System.Runtime.CompilerServices.System.Threading.Tasks.Extensions.IsReadOnlyAttribute : Attribute {
}
internal static class System.Runtime.CompilerServices.Unsafe : object {
    [NonVersionableAttribute]
public static T Read(Void* source);
    [NonVersionableAttribute]
public static T ReadUnaligned(Void* source);
    [NonVersionableAttribute]
public static T ReadUnaligned(Byte& source);
    [NonVersionableAttribute]
public static void Write(Void* destination, T value);
    [NonVersionableAttribute]
public static void WriteUnaligned(Void* destination, T value);
    [NonVersionableAttribute]
public static void WriteUnaligned(Byte& destination, T value);
    [NonVersionableAttribute]
public static void Copy(Void* destination, T& source);
    [NonVersionableAttribute]
public static void Copy(T& destination, Void* source);
    [NonVersionableAttribute]
public static Void* AsPointer(T& value);
    [NonVersionableAttribute]
public static void SkipInit(T& value);
    [NonVersionableAttribute]
public static int SizeOf();
    [NonVersionableAttribute]
public static void CopyBlock(Void* destination, Void* source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlock(Byte& destination, Byte& source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlockUnaligned(Void* destination, Void* source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void CopyBlockUnaligned(Byte& destination, Byte& source, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlock(Void* startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlock(Byte& startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlockUnaligned(Void* startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [NonVersionableAttribute]
public static T As(object o);
    [NonVersionableAttribute]
public static T& AsRef(Void* source);
    [NonVersionableAttribute]
public static T& AsRef(T& source);
    [NonVersionableAttribute]
public static TTo& As(TFrom& source);
    [NonVersionableAttribute]
public static T& Unbox(object box);
    [NonVersionableAttribute]
public static T& Add(T& source, int elementOffset);
    [NonVersionableAttribute]
public static Void* Add(Void* source, int elementOffset);
    [NonVersionableAttribute]
public static T& Add(T& source, IntPtr elementOffset);
    public static T& Add(T& source, UIntPtr elementOffset);
    [NonVersionableAttribute]
public static T& AddByteOffset(T& source, IntPtr byteOffset);
    public static T& AddByteOffset(T& source, UIntPtr byteOffset);
    [NonVersionableAttribute]
public static T& Subtract(T& source, int elementOffset);
    [NonVersionableAttribute]
public static Void* Subtract(Void* source, int elementOffset);
    [NonVersionableAttribute]
public static T& Subtract(T& source, IntPtr elementOffset);
    public static T& Subtract(T& source, UIntPtr elementOffset);
    [NonVersionableAttribute]
public static T& SubtractByteOffset(T& source, IntPtr byteOffset);
    public static T& SubtractByteOffset(T& source, UIntPtr byteOffset);
    [NonVersionableAttribute]
public static IntPtr ByteOffset(T& origin, T& target);
    [NonVersionableAttribute]
public static bool AreSame(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsAddressGreaterThan(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsAddressLessThan(T& left, T& right);
    [NonVersionableAttribute]
public static bool IsNullRef(T& source);
    [NonVersionableAttribute]
public static T& NullRef();
}
[System.Threading.Tasks.Extensions.IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    internal static Action`1<object> s_invokeActionDelegate;
    private ValueTask _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter(ValueTask value);
    private static ValueTaskAwaiter();
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[System.Threading.Tasks.Extensions.IsReadOnlyAttribute]
internal class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private ValueTask`1<TResult> _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter`1(ValueTask`1<TResult> value);
    public bool get_IsCompleted();
    [StackTraceHiddenAttribute]
public TResult GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.LibraryImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    public bool SetLastError { get; public set; }
    public LibraryImportAttribute(string libraryName);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public void set_StringMarshalling(StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public void set_StringMarshallingCustomType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public void set_SetLastError(bool value);
}
internal static class System.Runtime.InteropServices.MemoryMarshal : object {
    public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<ToEnumerable>d__3`1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static void Write(Span`1<byte> destination, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    public static T& GetReference(Span`1<T> span);
    public static T& GetReference(ReadOnlySpan`1<T> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
}
internal static class System.Runtime.InteropServices.SequenceMarshal : object {
    public static bool TryGetReadOnlySequenceSegment(ReadOnlySequence`1<T> sequence, ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    public static bool TryGetArray(ReadOnlySequence`1<T> sequence, ArraySegment`1& segment);
    public static bool TryGetReadOnlyMemory(ReadOnlySequence`1<T> sequence, ReadOnlyMemory`1& memory);
    internal static bool TryGetString(ReadOnlySequence`1<char> sequence, String& text, Int32& start, Int32& length);
}
internal enum System.Runtime.InteropServices.StringMarshalling : Enum {
    public int value__;
    public static StringMarshalling Custom;
    public static StringMarshalling Utf8;
    public static StringMarshalling Utf16;
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.System.Text.Encodings.Web1694883.LibraryImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private System.Text.Encodings.Web1694883.StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public System.Text.Encodings.Web1694883.StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    public bool SetLastError { get; public set; }
    public System.Text.Encodings.Web1694883.LibraryImportAttribute(string libraryName);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public System.Text.Encodings.Web1694883.StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public void set_StringMarshalling(System.Text.Encodings.Web1694883.StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public void set_StringMarshallingCustomType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public void set_SetLastError(bool value);
}
internal enum System.Runtime.InteropServices.System.Text.Encodings.Web1694883.StringMarshalling : Enum {
    public int value__;
    public static System.Text.Encodings.Web1694883.StringMarshalling Custom;
    public static System.Text.Encodings.Web1694883.StringMarshalling Utf8;
    public static System.Text.Encodings.Web1694883.StringMarshalling Utf16;
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.System.Text.Json1722049.LibraryImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private System.Text.Json1722049.StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public System.Text.Json1722049.StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    public bool SetLastError { get; public set; }
    public System.Text.Json1722049.LibraryImportAttribute(string libraryName);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public System.Text.Json1722049.StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public void set_StringMarshalling(System.Text.Json1722049.StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public void set_StringMarshallingCustomType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public void set_SetLastError(bool value);
}
internal enum System.Runtime.InteropServices.System.Text.Json1722049.StringMarshalling : Enum {
    public int value__;
    public static System.Text.Json1722049.StringMarshalling Custom;
    public static System.Text.Json1722049.StringMarshalling Utf8;
    public static System.Text.Json1722049.StringMarshalling Utf16;
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[AttributeUsageAttribute("6143")]
internal class System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresPreviewFeaturesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[System.Memory.IsReadOnlyAttribute]
internal class System.SequencePosition : ValueType {
    private object _object;
    private int _integer;
    public SequencePosition(object object, int integer);
    [EditorBrowsableAttribute("1")]
public object GetObject();
    [EditorBrowsableAttribute("1")]
public int GetInteger();
    public sealed virtual bool Equals(SequencePosition other);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
[System.Memory.IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[System.Memory.IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
internal class System.Span`1 : ValueType {
    private Pinnable`1<T> _pinnable;
    private IntPtr _byteOffset;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    public static Span`1<T> Empty { get; }
    public T& Item { get; }
    internal Pinnable`1<T> Pinnable { get; }
    internal IntPtr ByteOffset { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    [CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    internal Span`1(Pinnable`1<T> pinnable, IntPtr byteOffset, int length);
    public int get_Length();
    public bool get_IsEmpty();
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static Span`1<T> get_Empty();
    public Enumerator<T> GetEnumerator();
    internal static Span`1<T> Create(T[] array, int start);
    public T& get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public virtual string ToString();
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
    [EditorBrowsableAttribute("1")]
internal T& DangerousGetPinnableReference();
    internal Pinnable`1<T> get_Pinnable();
    internal IntPtr get_ByteOffset();
}
internal class System.SpanDebugView`1 : object {
    private T[] _array;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SpanDebugView`1(Span`1<T> span);
    public SpanDebugView`1(ReadOnlySpan`1<T> span);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.SpanHelpers : object {
    private static ulong XorPowerOfTwoToHighByte;
    private static ulong XorPowerOfTwoToHighChar;
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    public static int BinarySearch(T& spanStart, int length, TComparable comparable);
    public static int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOf(Byte& searchSpace, byte value, int length);
    public static int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOf(Byte& searchSpace, byte value, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static bool SequenceEqual(Byte& first, Byte& second, NUInt length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    public static int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength);
    private static int LocateLastFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    private static int LocateLastFoundByte(ulong match);
    private static Vector`1<byte> GetVector(byte vectorByte);
    public static int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength);
    public static int IndexOf(Char& searchSpace, char value, int length);
    public static int LastIndexOf(Char& searchSpace, char value, int length);
    private static int LocateFirstFoundChar(Vector`1<ushort> match);
    private static int LocateFirstFoundChar(ulong match);
    private static int LocateLastFoundChar(Vector`1<ushort> match);
    private static int LocateLastFoundChar(ulong match);
    public static int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int IndexOf(T& searchSpace, T value, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, T value, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool SequenceEqual(T& first, T& second, int length);
    public static int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength);
    public static void CopyTo(T& dst, int dstLength, T& src, int srcLength);
    [ExtensionAttribute]
public static IntPtr Add(IntPtr start, int index);
    public static bool IsReferenceOrContainsReferences();
    private static bool IsReferenceOrContainsReferencesCore(Type type);
    public static void ClearLessThanPointerSized(Byte* ptr, UIntPtr byteLength);
    public static void ClearLessThanPointerSized(Byte& b, UIntPtr byteLength);
    public static void ClearPointerSizedWithoutReferences(Byte& b, UIntPtr byteLength);
    public static void ClearPointerSizedWithReferences(IntPtr& ip, UIntPtr pointerSizeLength);
    [ExtensionAttribute]
private static bool LessThanEqual(IntPtr index, UIntPtr length);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string FileNotExists { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_FileNotExists();
}
internal static class System.System.Buffers1624809.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string ArgumentException_BufferNotFromPool { get; }
    private static System.Buffers1624809.SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_ArgumentException_BufferNotFromPool();
}
internal static class System.System.Memory1627036.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string NotSupported_CannotCallEqualsOnSpan { get; }
    internal static string NotSupported_CannotCallGetHashCodeOnSpan { get; }
    internal static string Argument_InvalidTypeWithPointersNotSupported { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string MemoryDisposed { get; }
    internal static string OutstandingReferences { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_GWithPrecisionNotSupported { get; }
    internal static string Argument_CannotParsePrecision { get; }
    internal static string Argument_PrecisionTooLarge { get; }
    internal static string Argument_OverlapAlignmentMismatch { get; }
    internal static string EndPositionNotReached { get; }
    internal static string UnexpectedSegmentType { get; }
    private static System.Memory1627036.SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_NotSupported_CannotCallEqualsOnSpan();
    internal static string get_NotSupported_CannotCallGetHashCodeOnSpan();
    internal static string get_Argument_InvalidTypeWithPointersNotSupported();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_MemoryDisposed();
    internal static string get_OutstandingReferences();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_GWithPrecisionNotSupported();
    internal static string get_Argument_CannotParsePrecision();
    internal static string get_Argument_PrecisionTooLarge();
    internal static string get_Argument_OverlapAlignmentMismatch();
    internal static string get_EndPositionNotReached();
    internal static string get_UnexpectedSegmentType();
}
internal static class System.System.Numerics.Vectors1679464.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string Arg_ArgumentOutOfRangeException { get; }
    internal static string Arg_ElementsInSourceIsGreaterThanDestination { get; }
    internal static string Arg_NullArgumentNullRef { get; }
    internal static string Arg_TypeNotSupported { get; }
    internal static string Arg_InsufficientNumberOfElements { get; }
    private static System.Numerics.Vectors1679464.SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_Arg_ArgumentOutOfRangeException();
    internal static string get_Arg_ElementsInSourceIsGreaterThanDestination();
    internal static string get_Arg_NullArgumentNullRef();
    internal static string get_Arg_TypeNotSupported();
    internal static string get_Arg_InsufficientNumberOfElements();
}
internal static class System.System.Text.Encodings.Web1694883.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string TextEncoderDoesNotImplementMaxOutputCharsPerInputChar { get; }
    private static System.Text.Encodings.Web1694883.SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_TextEncoderDoesNotImplementMaxOutputCharsPerInputChar();
}
internal static class System.System.Text.Json1722049.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal static class System.System.Text.Json1722049.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArrayDepthTooLarge { get; }
    internal static string CallFlushToAvoidDataLoss { get; }
    internal static string CannotReadIncompleteUTF16 { get; }
    internal static string CannotReadInvalidUTF16 { get; }
    internal static string CannotStartObjectArrayAfterPrimitiveOrClose { get; }
    internal static string CannotStartObjectArrayWithoutProperty { get; }
    internal static string CannotTranscodeInvalidUtf8 { get; }
    internal static string CannotDecodeInvalidBase64 { get; }
    internal static string CannotTranscodeInvalidUtf16 { get; }
    internal static string CannotEncodeInvalidUTF16 { get; }
    internal static string CannotEncodeInvalidUTF8 { get; }
    internal static string CannotWritePropertyWithinArray { get; }
    internal static string CannotWritePropertyAfterProperty { get; }
    internal static string CannotWriteValueAfterPrimitiveOrClose { get; }
    internal static string CannotWriteValueWithinObject { get; }
    internal static string DepthTooLarge { get; }
    internal static string DestinationTooShort { get; }
    internal static string EmptyJsonIsInvalid { get; }
    internal static string EndOfCommentNotFound { get; }
    internal static string EndOfStringNotFound { get; }
    internal static string ExpectedEndAfterSingleJson { get; }
    internal static string ExpectedEndOfDigitNotFound { get; }
    internal static string ExpectedFalse { get; }
    internal static string ExpectedJsonTokens { get; }
    internal static string ExpectedOneCompleteToken { get; }
    internal static string ExpectedNextDigitEValueNotFound { get; }
    internal static string ExpectedNull { get; }
    internal static string ExpectedSeparatorAfterPropertyNameNotFound { get; }
    internal static string ExpectedStartOfPropertyNotFound { get; }
    internal static string ExpectedStartOfPropertyOrValueNotFound { get; }
    internal static string ExpectedStartOfValueNotFound { get; }
    internal static string ExpectedTrue { get; }
    internal static string ExpectedValueAfterPropertyNameNotFound { get; }
    internal static string FailedToGetLargerSpan { get; }
    internal static string FoundInvalidCharacter { get; }
    internal static string InvalidCast { get; }
    internal static string InvalidCharacterAfterEscapeWithinString { get; }
    internal static string InvalidCharacterWithinString { get; }
    internal static string InvalidEndOfJsonNonPrimitive { get; }
    internal static string InvalidHexCharacterWithinString { get; }
    internal static string JsonDocumentDoesNotSupportComments { get; }
    internal static string JsonElementHasWrongType { get; }
    internal static string TypeInfoResolverImmutable { get; }
    internal static string TypeInfoImmutable { get; }
    internal static string PropertyInfoImmutable { get; }
    internal static string MaxDepthMustBePositive { get; }
    internal static string CommentHandlingMustBeValid { get; }
    internal static string MismatchedObjectArray { get; }
    internal static string CannotWriteEndAfterProperty { get; }
    internal static string ObjectDepthTooLarge { get; }
    internal static string PropertyNameTooLarge { get; }
    internal static string FormatDecimal { get; }
    internal static string FormatDouble { get; }
    internal static string FormatInt32 { get; }
    internal static string FormatInt64 { get; }
    internal static string FormatSingle { get; }
    internal static string FormatUInt32 { get; }
    internal static string FormatUInt64 { get; }
    internal static string RequiredDigitNotFoundAfterDecimal { get; }
    internal static string RequiredDigitNotFoundAfterSign { get; }
    internal static string RequiredDigitNotFoundEndOfData { get; }
    internal static string SpecialNumberValuesNotSupported { get; }
    internal static string ValueTooLarge { get; }
    internal static string ZeroDepthAtEnd { get; }
    internal static string DeserializeUnableToConvertValue { get; }
    internal static string DeserializeWrongType { get; }
    internal static string SerializationInvalidBufferSize { get; }
    internal static string BufferWriterAdvancedTooFar { get; }
    internal static string InvalidComparison { get; }
    internal static string UnsupportedFormat { get; }
    internal static string ExpectedStartOfPropertyOrValueAfterComment { get; }
    internal static string TrailingCommaNotAllowedBeforeArrayEnd { get; }
    internal static string TrailingCommaNotAllowedBeforeObjectEnd { get; }
    internal static string SerializerOptionsImmutable { get; }
    internal static string StreamNotWritable { get; }
    internal static string CannotWriteCommentWithEmbeddedDelimiter { get; }
    internal static string SerializerPropertyNameConflict { get; }
    internal static string SerializerPropertyNameNull { get; }
    internal static string SerializationDataExtensionPropertyInvalid { get; }
    internal static string SerializationDuplicateTypeAttribute { get; }
    internal static string SerializationNotSupportedType { get; }
    internal static string TypeRequiresAsyncSerialization { get; }
    internal static string InvalidCharacterAtStartOfComment { get; }
    internal static string UnexpectedEndOfDataWhileReadingComment { get; }
    internal static string CannotSkip { get; }
    internal static string NotEnoughData { get; }
    internal static string UnexpectedEndOfLineSeparator { get; }
    internal static string JsonSerializerDoesNotSupportComments { get; }
    internal static string DeserializeNoConstructor { get; }
    internal static string DeserializePolymorphicInterface { get; }
    internal static string SerializationConverterOnAttributeNotCompatible { get; }
    internal static string SerializationConverterOnAttributeInvalid { get; }
    internal static string SerializationConverterRead { get; }
    internal static string SerializationConverterNotCompatible { get; }
    internal static string ResolverTypeNotCompatible { get; }
    internal static string ResolverTypeInfoOptionsNotCompatible { get; }
    internal static string SerializationConverterWrite { get; }
    internal static string NamingPolicyReturnNull { get; }
    internal static string SerializationDuplicateAttribute { get; }
    internal static string SerializeUnableToSerialize { get; }
    internal static string FormatByte { get; }
    internal static string FormatInt16 { get; }
    internal static string FormatSByte { get; }
    internal static string FormatUInt16 { get; }
    internal static string SerializerCycleDetected { get; }
    internal static string InvalidLeadingZeroInNumber { get; }
    internal static string MetadataCannotParsePreservedObjectToImmutable { get; }
    internal static string MetadataDuplicateIdFound { get; }
    internal static string MetadataIdIsNotFirstProperty { get; }
    internal static string MetadataInvalidReferenceToValueType { get; }
    internal static string MetadataInvalidTokenAfterValues { get; }
    internal static string MetadataPreservedArrayFailed { get; }
    internal static string MetadataInvalidPropertyInArrayMetadata { get; }
    internal static string MetadataStandaloneValuesProperty { get; }
    internal static string MetadataReferenceCannotContainOtherProperties { get; }
    internal static string MetadataReferenceNotFound { get; }
    internal static string MetadataValueWasNotString { get; }
    internal static string MetadataInvalidPropertyWithLeadingDollarSign { get; }
    internal static string MetadataUnexpectedProperty { get; }
    internal static string MetadataDuplicateTypeProperty { get; }
    internal static string MultipleMembersBindWithConstructorParameter { get; }
    internal static string ConstructorParamIncompleteBinding { get; }
    internal static string ConstructorMaxOf64Parameters { get; }
    internal static string ObjectWithParameterizedCtorRefMetadataNotSupported { get; }
    internal static string SerializerConverterFactoryReturnsNull { get; }
    internal static string SerializationNotSupportedParentType { get; }
    internal static string ExtensionDataCannotBindToCtorParam { get; }
    internal static string BufferMaximumSizeExceeded { get; }
    internal static string CannotSerializeInvalidType { get; }
    internal static string SerializeTypeInstanceNotSupported { get; }
    internal static string JsonIncludeOnNonPublicInvalid { get; }
    internal static string CannotSerializeInvalidMember { get; }
    internal static string CannotPopulateCollection { get; }
    internal static string ConstructorContainsNullParameterNames { get; }
    internal static string DefaultIgnoreConditionAlreadySpecified { get; }
    internal static string DefaultIgnoreConditionInvalid { get; }
    internal static string DictionaryKeyTypeNotSupported { get; }
    internal static string IgnoreConditionOnValueTypeInvalid { get; }
    internal static string NumberHandlingOnPropertyInvalid { get; }
    internal static string ConverterCanConvertMultipleTypes { get; }
    internal static string MetadataReferenceOfTypeCannotBeAssignedToType { get; }
    internal static string DeserializeUnableToAssignValue { get; }
    internal static string DeserializeUnableToAssignNull { get; }
    internal static string SerializerConverterFactoryReturnsJsonConverterFactory { get; }
    internal static string NodeElementWrongType { get; }
    internal static string NodeElementCannotBeObjectOrArray { get; }
    internal static string NodeAlreadyHasParent { get; }
    internal static string NodeCycleDetected { get; }
    internal static string NodeUnableToConvert { get; }
    internal static string NodeUnableToConvertElement { get; }
    internal static string NodeValueNotAllowed { get; }
    internal static string NodeWrongType { get; }
    internal static string NodeDuplicateKey { get; }
    internal static string SerializerContextOptionsImmutable { get; }
    internal static string ConverterForPropertyMustBeValid { get; }
    internal static string NoMetadataForType { get; }
    internal static string CollectionIsReadOnly { get; }
    internal static string ArrayIndexNegative { get; }
    internal static string ArrayTooSmall { get; }
    internal static string NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty { get; }
    internal static string NoMetadataForTypeProperties { get; }
    internal static string FieldCannotBeVirtual { get; }
    internal static string MissingFSharpCoreMember { get; }
    internal static string FSharpDiscriminatedUnionsNotSupported { get; }
    internal static string NoMetadataForTypeCtorParams { get; }
    internal static string Polymorphism_BaseConverterDoesNotSupportMetadata { get; }
    internal static string Polymorphism_DerivedConverterDoesNotSupportMetadata { get; }
    internal static string Polymorphism_TypeDoesNotSupportPolymorphism { get; }
    internal static string Polymorphism_DerivedTypeIsNotSupported { get; }
    internal static string Polymorphism_DerivedTypeIsAlreadySpecified { get; }
    internal static string Polymorphism_TypeDicriminatorIdIsAlreadySpecified { get; }
    internal static string Polymorphism_InvalidCustomTypeDiscriminatorPropertyName { get; }
    internal static string Polymorphism_ConfigurationDoesNotSpecifyDerivedTypes { get; }
    internal static string Polymorphism_UnrecognizedTypeDiscriminator { get; }
    internal static string Polymorphism_RuntimeTypeNotSupported { get; }
    internal static string Polymorphism_RuntimeTypeDiamondAmbiguity { get; }
    internal static string InvalidJsonTypeInfoOperationForKind { get; }
    internal static string CreateObjectConverterNotCompatible { get; }
    internal static string CombineOneOfResolversIsNull { get; }
    internal static string JsonPropertyInfoBoundToDifferentParent { get; }
    internal static string JsonTypeInfoUsedButTypeInfoResolverNotSet { get; }
    internal static string JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo { get; }
    internal static string JsonPropertyRequiredAndNotDeserializable { get; }
    internal static string JsonPropertyRequiredAndExtensionData { get; }
    internal static string JsonRequiredPropertiesMissing { get; }
    private static System.Text.Json1722049.SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArrayDepthTooLarge();
    internal static string get_CallFlushToAvoidDataLoss();
    internal static string get_CannotReadIncompleteUTF16();
    internal static string get_CannotReadInvalidUTF16();
    internal static string get_CannotStartObjectArrayAfterPrimitiveOrClose();
    internal static string get_CannotStartObjectArrayWithoutProperty();
    internal static string get_CannotTranscodeInvalidUtf8();
    internal static string get_CannotDecodeInvalidBase64();
    internal static string get_CannotTranscodeInvalidUtf16();
    internal static string get_CannotEncodeInvalidUTF16();
    internal static string get_CannotEncodeInvalidUTF8();
    internal static string get_CannotWritePropertyWithinArray();
    internal static string get_CannotWritePropertyAfterProperty();
    internal static string get_CannotWriteValueAfterPrimitiveOrClose();
    internal static string get_CannotWriteValueWithinObject();
    internal static string get_DepthTooLarge();
    internal static string get_DestinationTooShort();
    internal static string get_EmptyJsonIsInvalid();
    internal static string get_EndOfCommentNotFound();
    internal static string get_EndOfStringNotFound();
    internal static string get_ExpectedEndAfterSingleJson();
    internal static string get_ExpectedEndOfDigitNotFound();
    internal static string get_ExpectedFalse();
    internal static string get_ExpectedJsonTokens();
    internal static string get_ExpectedOneCompleteToken();
    internal static string get_ExpectedNextDigitEValueNotFound();
    internal static string get_ExpectedNull();
    internal static string get_ExpectedSeparatorAfterPropertyNameNotFound();
    internal static string get_ExpectedStartOfPropertyNotFound();
    internal static string get_ExpectedStartOfPropertyOrValueNotFound();
    internal static string get_ExpectedStartOfValueNotFound();
    internal static string get_ExpectedTrue();
    internal static string get_ExpectedValueAfterPropertyNameNotFound();
    internal static string get_FailedToGetLargerSpan();
    internal static string get_FoundInvalidCharacter();
    internal static string get_InvalidCast();
    internal static string get_InvalidCharacterAfterEscapeWithinString();
    internal static string get_InvalidCharacterWithinString();
    internal static string get_InvalidEndOfJsonNonPrimitive();
    internal static string get_InvalidHexCharacterWithinString();
    internal static string get_JsonDocumentDoesNotSupportComments();
    internal static string get_JsonElementHasWrongType();
    internal static string get_TypeInfoResolverImmutable();
    internal static string get_TypeInfoImmutable();
    internal static string get_PropertyInfoImmutable();
    internal static string get_MaxDepthMustBePositive();
    internal static string get_CommentHandlingMustBeValid();
    internal static string get_MismatchedObjectArray();
    internal static string get_CannotWriteEndAfterProperty();
    internal static string get_ObjectDepthTooLarge();
    internal static string get_PropertyNameTooLarge();
    internal static string get_FormatDecimal();
    internal static string get_FormatDouble();
    internal static string get_FormatInt32();
    internal static string get_FormatInt64();
    internal static string get_FormatSingle();
    internal static string get_FormatUInt32();
    internal static string get_FormatUInt64();
    internal static string get_RequiredDigitNotFoundAfterDecimal();
    internal static string get_RequiredDigitNotFoundAfterSign();
    internal static string get_RequiredDigitNotFoundEndOfData();
    internal static string get_SpecialNumberValuesNotSupported();
    internal static string get_ValueTooLarge();
    internal static string get_ZeroDepthAtEnd();
    internal static string get_DeserializeUnableToConvertValue();
    internal static string get_DeserializeWrongType();
    internal static string get_SerializationInvalidBufferSize();
    internal static string get_BufferWriterAdvancedTooFar();
    internal static string get_InvalidComparison();
    internal static string get_UnsupportedFormat();
    internal static string get_ExpectedStartOfPropertyOrValueAfterComment();
    internal static string get_TrailingCommaNotAllowedBeforeArrayEnd();
    internal static string get_TrailingCommaNotAllowedBeforeObjectEnd();
    internal static string get_SerializerOptionsImmutable();
    internal static string get_StreamNotWritable();
    internal static string get_CannotWriteCommentWithEmbeddedDelimiter();
    internal static string get_SerializerPropertyNameConflict();
    internal static string get_SerializerPropertyNameNull();
    internal static string get_SerializationDataExtensionPropertyInvalid();
    internal static string get_SerializationDuplicateTypeAttribute();
    internal static string get_SerializationNotSupportedType();
    internal static string get_TypeRequiresAsyncSerialization();
    internal static string get_InvalidCharacterAtStartOfComment();
    internal static string get_UnexpectedEndOfDataWhileReadingComment();
    internal static string get_CannotSkip();
    internal static string get_NotEnoughData();
    internal static string get_UnexpectedEndOfLineSeparator();
    internal static string get_JsonSerializerDoesNotSupportComments();
    internal static string get_DeserializeNoConstructor();
    internal static string get_DeserializePolymorphicInterface();
    internal static string get_SerializationConverterOnAttributeNotCompatible();
    internal static string get_SerializationConverterOnAttributeInvalid();
    internal static string get_SerializationConverterRead();
    internal static string get_SerializationConverterNotCompatible();
    internal static string get_ResolverTypeNotCompatible();
    internal static string get_ResolverTypeInfoOptionsNotCompatible();
    internal static string get_SerializationConverterWrite();
    internal static string get_NamingPolicyReturnNull();
    internal static string get_SerializationDuplicateAttribute();
    internal static string get_SerializeUnableToSerialize();
    internal static string get_FormatByte();
    internal static string get_FormatInt16();
    internal static string get_FormatSByte();
    internal static string get_FormatUInt16();
    internal static string get_SerializerCycleDetected();
    internal static string get_InvalidLeadingZeroInNumber();
    internal static string get_MetadataCannotParsePreservedObjectToImmutable();
    internal static string get_MetadataDuplicateIdFound();
    internal static string get_MetadataIdIsNotFirstProperty();
    internal static string get_MetadataInvalidReferenceToValueType();
    internal static string get_MetadataInvalidTokenAfterValues();
    internal static string get_MetadataPreservedArrayFailed();
    internal static string get_MetadataInvalidPropertyInArrayMetadata();
    internal static string get_MetadataStandaloneValuesProperty();
    internal static string get_MetadataReferenceCannotContainOtherProperties();
    internal static string get_MetadataReferenceNotFound();
    internal static string get_MetadataValueWasNotString();
    internal static string get_MetadataInvalidPropertyWithLeadingDollarSign();
    internal static string get_MetadataUnexpectedProperty();
    internal static string get_MetadataDuplicateTypeProperty();
    internal static string get_MultipleMembersBindWithConstructorParameter();
    internal static string get_ConstructorParamIncompleteBinding();
    internal static string get_ConstructorMaxOf64Parameters();
    internal static string get_ObjectWithParameterizedCtorRefMetadataNotSupported();
    internal static string get_SerializerConverterFactoryReturnsNull();
    internal static string get_SerializationNotSupportedParentType();
    internal static string get_ExtensionDataCannotBindToCtorParam();
    internal static string get_BufferMaximumSizeExceeded();
    internal static string get_CannotSerializeInvalidType();
    internal static string get_SerializeTypeInstanceNotSupported();
    internal static string get_JsonIncludeOnNonPublicInvalid();
    internal static string get_CannotSerializeInvalidMember();
    internal static string get_CannotPopulateCollection();
    internal static string get_ConstructorContainsNullParameterNames();
    internal static string get_DefaultIgnoreConditionAlreadySpecified();
    internal static string get_DefaultIgnoreConditionInvalid();
    internal static string get_DictionaryKeyTypeNotSupported();
    internal static string get_IgnoreConditionOnValueTypeInvalid();
    internal static string get_NumberHandlingOnPropertyInvalid();
    internal static string get_ConverterCanConvertMultipleTypes();
    internal static string get_MetadataReferenceOfTypeCannotBeAssignedToType();
    internal static string get_DeserializeUnableToAssignValue();
    internal static string get_DeserializeUnableToAssignNull();
    internal static string get_SerializerConverterFactoryReturnsJsonConverterFactory();
    internal static string get_NodeElementWrongType();
    internal static string get_NodeElementCannotBeObjectOrArray();
    internal static string get_NodeAlreadyHasParent();
    internal static string get_NodeCycleDetected();
    internal static string get_NodeUnableToConvert();
    internal static string get_NodeUnableToConvertElement();
    internal static string get_NodeValueNotAllowed();
    internal static string get_NodeWrongType();
    internal static string get_NodeDuplicateKey();
    internal static string get_SerializerContextOptionsImmutable();
    internal static string get_ConverterForPropertyMustBeValid();
    internal static string get_NoMetadataForType();
    internal static string get_CollectionIsReadOnly();
    internal static string get_ArrayIndexNegative();
    internal static string get_ArrayTooSmall();
    internal static string get_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty();
    internal static string get_NoMetadataForTypeProperties();
    internal static string get_FieldCannotBeVirtual();
    internal static string get_MissingFSharpCoreMember();
    internal static string get_FSharpDiscriminatedUnionsNotSupported();
    internal static string get_NoMetadataForTypeCtorParams();
    internal static string get_Polymorphism_BaseConverterDoesNotSupportMetadata();
    internal static string get_Polymorphism_DerivedConverterDoesNotSupportMetadata();
    internal static string get_Polymorphism_TypeDoesNotSupportPolymorphism();
    internal static string get_Polymorphism_DerivedTypeIsNotSupported();
    internal static string get_Polymorphism_DerivedTypeIsAlreadySpecified();
    internal static string get_Polymorphism_TypeDicriminatorIdIsAlreadySpecified();
    internal static string get_Polymorphism_InvalidCustomTypeDiscriminatorPropertyName();
    internal static string get_Polymorphism_ConfigurationDoesNotSpecifyDerivedTypes();
    internal static string get_Polymorphism_UnrecognizedTypeDiscriminator();
    internal static string get_Polymorphism_RuntimeTypeNotSupported();
    internal static string get_Polymorphism_RuntimeTypeDiamondAmbiguity();
    internal static string get_InvalidJsonTypeInfoOperationForKind();
    internal static string get_CreateObjectConverterNotCompatible();
    internal static string get_CombineOneOfResolversIsNull();
    internal static string get_JsonPropertyInfoBoundToDifferentParent();
    internal static string get_JsonTypeInfoUsedButTypeInfoResolverNotSet();
    internal static string get_JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo();
    internal static string get_JsonPropertyRequiredAndNotDeserializable();
    internal static string get_JsonPropertyRequiredAndExtensionData();
    internal static string get_JsonRequiredPropertiesMissing();
}
internal enum System.System.Threading.Tasks.Extensions1968549.ExceptionArgument : Enum {
    public int value__;
    public static System.Threading.Tasks.Extensions1968549.ExceptionArgument task;
    public static System.Threading.Tasks.Extensions1968549.ExceptionArgument source;
    public static System.Threading.Tasks.Extensions1968549.ExceptionArgument state;
}
internal static class System.System.Threading.Tasks.Extensions1968549.ThrowHelper : object {
    internal static void ThrowArgumentNullException(System.Threading.Tasks.Extensions1968549.ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException(System.Threading.Tasks.Extensions1968549.ExceptionArgument argument);
    private static ArgumentNullException GetArgumentNullException(System.Threading.Tasks.Extensions1968549.ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(System.Threading.Tasks.Extensions1968549.ExceptionArgument argument);
    private static string GetArgumentName(System.Threading.Tasks.Extensions1968549.ExceptionArgument argument);
}
internal static class System.System.ValueTuple1975400.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string ArgumentException_ValueTupleIncorrectType { get; }
    internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple { get; }
    private static System.ValueTuple1975400.SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_ArgumentException_ValueTupleIncorrectType();
    internal static string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple();
}
[CompilerGeneratedAttribute]
internal class System.Text.Encodings.Web.<PrivateImplementationDetails> : object {
    internal static __StaticArrayInitTypeSize=256 21244F82B210125632917591768F6BF22EB6861F80C6C25A25BD26DFB580EA7B;
    internal static __StaticArrayInitTypeSize=32 4BCD43D478B9229AB7A13406353712C7944B60348C36B4D0E6B789D10F697652;
    internal static __StaticArrayInitTypeSize=8192 7933520BFAF34098049CC893E2B5321C47D8B0A806EF325556FBE7B2D9CB1F50;
}
internal class System.Text.Encodings.Web.AllowedBmpCodePointsBitmap : ValueType {
    private static int BitmapLengthInDWords;
    [FixedBufferAttribute("System.UInt32", "2048")]
private <Bitmap>e__FixedBuffer Bitmap;
    public void AllowChar(char value);
    public void ForbidChar(char value);
    public void ForbidHtmlCharacters();
    public void ForbidUndefinedCharacters();
    [System.Text.Encodings.Web.IsReadOnlyAttribute]
public bool IsCharAllowed(char value);
    [System.Text.Encodings.Web.IsReadOnlyAttribute]
public bool IsCodePointAllowed(UInt32 value);
    private static void _GetIndexAndOffset(UInt32 value, UIntPtr& index, Int32& offset);
}
internal class System.Text.Encodings.Web.AsciiByteMap : ValueType {
    private static int BufferSize;
    [FixedBufferAttribute("System.Byte", "128")]
private <Buffer>e__FixedBuffer Buffer;
    internal void InsertAsciiChar(char key, byte value);
    [System.Text.Encodings.Web.IsReadOnlyAttribute]
internal bool TryLookup(Rune key, Byte& value);
}
internal class System.Text.Encodings.Web.DefaultHtmlEncoder : HtmlEncoder {
    internal static DefaultHtmlEncoder BasicLatinSingleton;
    private OptimizedInboxTextEncoder _innerEncoder;
    public int MaxOutputCharactersPerInputCharacter { get; }
    internal DefaultHtmlEncoder(TextEncoderSettings settings);
    private static DefaultHtmlEncoder();
    public virtual int get_MaxOutputCharactersPerInputCharacter();
    private protected virtual OperationStatus EncodeCore(ReadOnlySpan`1<char> source, Span`1<char> destination, Int32& charsConsumed, Int32& charsWritten, bool isFinalBlock);
    private protected virtual OperationStatus EncodeUtf8Core(ReadOnlySpan`1<byte> utf8Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    private protected virtual int FindFirstCharacterToEncode(ReadOnlySpan`1<char> text);
    public virtual int FindFirstCharacterToEncode(Char* text, int textLength);
    public virtual int FindFirstCharacterToEncodeUtf8(ReadOnlySpan`1<byte> utf8Text);
    public virtual bool TryEncodeUnicodeScalar(int unicodeScalar, Char* buffer, int bufferLength, Int32& numberOfCharactersWritten);
    public virtual bool WillEncode(int unicodeScalar);
}
internal class System.Text.Encodings.Web.DefaultJavaScriptEncoder : JavaScriptEncoder {
    internal static DefaultJavaScriptEncoder BasicLatinSingleton;
    internal static DefaultJavaScriptEncoder UnsafeRelaxedEscapingSingleton;
    private OptimizedInboxTextEncoder _innerEncoder;
    public int MaxOutputCharactersPerInputCharacter { get; }
    internal DefaultJavaScriptEncoder(TextEncoderSettings settings);
    private DefaultJavaScriptEncoder(TextEncoderSettings settings, bool allowMinimalJsonEscaping);
    private static DefaultJavaScriptEncoder();
    public virtual int get_MaxOutputCharactersPerInputCharacter();
    private protected virtual OperationStatus EncodeCore(ReadOnlySpan`1<char> source, Span`1<char> destination, Int32& charsConsumed, Int32& charsWritten, bool isFinalBlock);
    private protected virtual OperationStatus EncodeUtf8Core(ReadOnlySpan`1<byte> utf8Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    private protected virtual int FindFirstCharacterToEncode(ReadOnlySpan`1<char> text);
    public virtual int FindFirstCharacterToEncode(Char* text, int textLength);
    public virtual int FindFirstCharacterToEncodeUtf8(ReadOnlySpan`1<byte> utf8Text);
    public virtual bool TryEncodeUnicodeScalar(int unicodeScalar, Char* buffer, int bufferLength, Int32& numberOfCharactersWritten);
    public virtual bool WillEncode(int unicodeScalar);
}
internal class System.Text.Encodings.Web.DefaultUrlEncoder : UrlEncoder {
    internal static DefaultUrlEncoder BasicLatinSingleton;
    private OptimizedInboxTextEncoder _innerEncoder;
    public int MaxOutputCharactersPerInputCharacter { get; }
    internal DefaultUrlEncoder(TextEncoderSettings settings);
    private static DefaultUrlEncoder();
    public virtual int get_MaxOutputCharactersPerInputCharacter();
    private protected virtual OperationStatus EncodeCore(ReadOnlySpan`1<char> source, Span`1<char> destination, Int32& charsConsumed, Int32& charsWritten, bool isFinalBlock);
    private protected virtual OperationStatus EncodeUtf8Core(ReadOnlySpan`1<byte> utf8Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    private protected virtual int FindFirstCharacterToEncode(ReadOnlySpan`1<char> text);
    public virtual int FindFirstCharacterToEncode(Char* text, int textLength);
    public virtual int FindFirstCharacterToEncodeUtf8(ReadOnlySpan`1<byte> utf8Text);
    public virtual bool TryEncodeUnicodeScalar(int unicodeScalar, Char* buffer, int bufferLength, Int32& numberOfCharactersWritten);
    public virtual bool WillEncode(int unicodeScalar);
}
internal enum System.Text.Encodings.Web.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument value;
    public static ExceptionArgument settings;
    public static ExceptionArgument output;
    public static ExceptionArgument other;
    public static ExceptionArgument allowedRanges;
    public static ExceptionArgument characters;
    public static ExceptionArgument codePoints;
    public static ExceptionArgument range;
    public static ExceptionArgument ranges;
}
[System.Text.Encodings.Web.NullableContextAttribute("1")]
[System.Text.Encodings.Web.NullableAttribute("0")]
internal abstract class System.Text.Encodings.Web.HtmlEncoder : TextEncoder {
    public static HtmlEncoder Default { get; }
    public static HtmlEncoder get_Default();
    public static HtmlEncoder Create(TextEncoderSettings settings);
    public static HtmlEncoder Create(UnicodeRange[] allowedRanges);
}
[System.Text.Encodings.Web.NullableContextAttribute("1")]
[System.Text.Encodings.Web.NullableAttribute("0")]
internal abstract class System.Text.Encodings.Web.JavaScriptEncoder : TextEncoder {
    public static JavaScriptEncoder Default { get; }
    public static JavaScriptEncoder UnsafeRelaxedJsonEscaping { get; }
    public static JavaScriptEncoder get_Default();
    public static JavaScriptEncoder get_UnsafeRelaxedJsonEscaping();
    public static JavaScriptEncoder Create(TextEncoderSettings settings);
    public static JavaScriptEncoder Create(UnicodeRange[] allowedRanges);
}
internal class System.Text.Encodings.Web.OptimizedInboxTextEncoder : object {
    private AllowedAsciiCodePoints _allowedAsciiCodePoints;
    private AsciiPreescapedData _asciiPreescapedData;
    private AllowedBmpCodePointsBitmap _allowedBmpCodePoints;
    private ScalarEscaperBase _scalarEscaper;
    internal OptimizedInboxTextEncoder(ScalarEscaperBase scalarEscaper, AllowedBmpCodePointsBitmap& allowedCodePointsBmp, bool forbidHtmlSensitiveCharacters, ReadOnlySpan`1<char> extraCharactersToEscape);
    [ObsoleteAttribute("FindFirstCharacterToEncode has been deprecated. It should only be used by the TextEncoder adapter.")]
public int FindFirstCharacterToEncode(Char* text, int textLength);
    [ObsoleteAttribute("TryEncodeUnicodeScalar has been deprecated. It should only be used by the TextEncoder adapter.")]
public bool TryEncodeUnicodeScalar(int unicodeScalar, Char* buffer, int bufferLength, Int32& numberOfCharactersWritten);
    public OperationStatus Encode(ReadOnlySpan`1<char> source, Span`1<char> destination, Int32& charsConsumed, Int32& charsWritten, bool isFinalBlock);
    public OperationStatus EncodeUtf8(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public int GetIndexOfFirstByteToEncode(ReadOnlySpan`1<byte> data);
    public int GetIndexOfFirstCharToEncode(ReadOnlySpan`1<char> data);
    public bool IsScalarValueAllowed(Rune value);
    private void _AssertThisNotNull();
}
internal abstract class System.Text.Encodings.Web.ScalarEscaperBase : object {
    internal abstract virtual int EncodeUtf16(Rune value, Span`1<char> destination);
    internal abstract virtual int EncodeUtf8(Rune value, Span`1<byte> destination);
}
internal static class System.Text.Encodings.Web.SpanUtility : object {
    public static bool IsValidIndex(ReadOnlySpan`1<T> span, int index);
    public static bool IsValidIndex(Span`1<T> span, int index);
    public static bool TryWriteBytes(Span`1<byte> span, byte a, byte b, byte c, byte d);
    public static bool TryWriteBytes(Span`1<byte> span, byte a, byte b, byte c, byte d, byte e);
    public static bool TryWriteBytes(Span`1<byte> span, byte a, byte b, byte c, byte d, byte e, byte f);
    public static bool TryWriteChars(Span`1<char> span, char a, char b, char c, char d);
    public static bool TryWriteChars(Span`1<char> span, char a, char b, char c, char d, char e);
    public static bool TryWriteChars(Span`1<char> span, char a, char b, char c, char d, char e, char f);
    public static bool TryWriteUInt64LittleEndian(Span`1<byte> span, int offset, ulong value);
    private static bool AreValidIndexAndLength(int spanRealLength, int requestedOffset, int requestedLength);
}
internal abstract class System.Text.Encodings.Web.TextEncoder : object {
    private static int EncodeStartingOutputBufferSize;
    [EditorBrowsableAttribute("1")]
public int MaxOutputCharactersPerInputCharacter { get; }
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual bool TryEncodeUnicodeScalar(int unicodeScalar, Char* buffer, int bufferLength, Int32& numberOfCharactersWritten);
    private bool TryEncodeUnicodeScalar(UInt32 unicodeScalar, Span`1<char> buffer, Int32& charsWritten);
    private bool TryEncodeUnicodeScalarUtf8(UInt32 unicodeScalar, Span`1<char> utf16ScratchBuffer, Span`1<byte> utf8Destination, Int32& bytesWritten);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public abstract virtual int FindFirstCharacterToEncode(Char* text, int textLength);
    [EditorBrowsableAttribute("1")]
public abstract virtual bool WillEncode(int unicodeScalar);
    public abstract virtual int get_MaxOutputCharactersPerInputCharacter();
    [System.Text.Encodings.Web.NullableContextAttribute("1")]
public virtual string Encode(string value);
    private string EncodeToNewString(ReadOnlySpan`1<char> value, int indexOfFirstCharToEncode);
    [System.Text.Encodings.Web.NullableContextAttribute("1")]
public void Encode(TextWriter output, string value);
    [System.Text.Encodings.Web.NullableContextAttribute("1")]
public virtual void Encode(TextWriter output, string value, int startIndex, int characterCount);
    [System.Text.Encodings.Web.NullableContextAttribute("1")]
public virtual void Encode(TextWriter output, Char[] value, int startIndex, int characterCount);
    public virtual OperationStatus EncodeUtf8(ReadOnlySpan`1<byte> utf8Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    private protected virtual OperationStatus EncodeUtf8Core(ReadOnlySpan`1<byte> utf8Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public virtual OperationStatus Encode(ReadOnlySpan`1<char> source, Span`1<char> destination, Int32& charsConsumed, Int32& charsWritten, bool isFinalBlock);
    private protected virtual OperationStatus EncodeCore(ReadOnlySpan`1<char> source, Span`1<char> destination, Int32& charsConsumed, Int32& charsWritten, bool isFinalBlock);
    private void EncodeCore(TextWriter output, ReadOnlySpan`1<char> value);
    private protected virtual int FindFirstCharacterToEncode(ReadOnlySpan`1<char> text);
    [EditorBrowsableAttribute("1")]
public virtual int FindFirstCharacterToEncodeUtf8(ReadOnlySpan`1<byte> utf8Text);
    internal static bool TryCopyCharacters(string source, Span`1<char> destination, Int32& numberOfCharactersWritten);
    internal static bool TryWriteScalarAsChar(int unicodeScalar, Span`1<char> destination, Int32& numberOfCharactersWritten);
    private static void ValidateRanges(int startIndex, int characterCount, int actualInputLength);
    [System.Text.Encodings.Web1694883.DoesNotReturnAttribute]
private static void ThrowArgumentException_MaxOutputCharsPerInputChar();
}
[System.Text.Encodings.Web.NullableContextAttribute("1")]
[System.Text.Encodings.Web.NullableAttribute("0")]
internal class System.Text.Encodings.Web.TextEncoderSettings : object {
    private AllowedBmpCodePointsBitmap _allowedCodePointsBitmap;
    public TextEncoderSettings(TextEncoderSettings other);
    public TextEncoderSettings(UnicodeRange[] allowedRanges);
    public virtual void AllowCharacter(char character);
    public virtual void AllowCharacters(Char[] characters);
    public virtual void AllowCodePoints(IEnumerable`1<int> codePoints);
    public virtual void AllowRange(UnicodeRange range);
    public virtual void AllowRanges(UnicodeRange[] ranges);
    public virtual void Clear();
    public virtual void ForbidCharacter(char character);
    public virtual void ForbidCharacters(Char[] characters);
    public virtual void ForbidRange(UnicodeRange range);
    public virtual void ForbidRanges(UnicodeRange[] ranges);
    [IteratorStateMachineAttribute("System.Text.Encodings.Web.TextEncoderSettings/<GetAllowedCodePoints>d__14")]
public virtual IEnumerable`1<int> GetAllowedCodePoints();
    internal AllowedBmpCodePointsBitmap& modreq(System.Runtime.InteropServices.InAttribute) GetAllowedCodePointsBitmap();
}
internal static class System.Text.Encodings.Web.ThrowHelper : object {
    [System.Text.Encodings.Web1694883.DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [System.Text.Encodings.Web1694883.DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static string GetArgumentName(ExceptionArgument argument);
}
[System.Text.Encodings.Web.NullableContextAttribute("1")]
[System.Text.Encodings.Web.NullableAttribute("0")]
internal abstract class System.Text.Encodings.Web.UrlEncoder : TextEncoder {
    public static UrlEncoder Default { get; }
    public static UrlEncoder get_Default();
    public static UrlEncoder Create(TextEncoderSettings settings);
    public static UrlEncoder Create(UnicodeRange[] allowedRanges);
}
[CompilerGeneratedAttribute]
internal class System.Text.Json.<PrivateImplementationDetails> : object {
    internal static __StaticArrayInitTypeSize=9 13DEB4F81E4D9ED6197EEFBA2DF8CE10439D53D30FBA199F61461E159C624CED;
    internal static __StaticArrayInitTypeSize=256 21244F82B210125632917591768F6BF22EB6861F80C6C25A25BD26DFB580EA7B;
    internal static long 4A290E521C8FFD514F69D5856AA11C25E90EAF4B5048918F4874D4506A77E2F7;
    internal static __StaticArrayInitTypeSize=52 5857EE4CE98BFABBD62B385C1098507DD0052FF3951043AAD6A1DABD495F18AA;
    internal static int 5AC07401E4F83150BC0552D68E463CFF181D33C5DBEE917B7C8F7AD508FF81C4;
    internal static long 610135388C72AB5255BDEE95D50F660AC9B5890460A4A64B744F83102F0F857A;
    internal static __StaticArrayInitTypeSize=36 7367A65185E4F747AA29364AB199D01646A010A62129A6BA2E35E929D7294D62;
    internal static __StaticArrayInitTypeSize=5 97CCCB1B1197F11C6EDBB0D93975220592EF8FAF618C8770A131E4F7DFE567CC;
    internal static __StaticArrayInitTypeSize=6 98151954F217A510702D236DE168CC35D0AB2F99C4479CC9B07EEEDE7EF73A66;
    internal static __StaticArrayInitTypeSize=3 BCCD0BA7F848775347BA9B64603DDEAC80563D9BFC8FB67AF20A7FB468DF6FD4;
    internal static __StaticArrayInitTypeSize=10 DD8F6C9CBF007866E6C260785EFAAE6C32A8228CE7CE3CDE5F87B28CDFCD2AC3;
    internal static __StaticArrayInitTypeSize=5 DEBC2F07DB78D52D2DEF07B7BC620D7042367501D9439A62BA09B559A98E0957;
    internal static __StaticArrayInitTypeSize=256 EFE627BE173681E4F55F4133AB4C1782E26D1080CB80CDB6BFAAC81416A2714E;
    internal static __StaticArrayInitTypeSize=3 F1945CD6C19E56B3C1C78943EF5EC18116907A4CA1EFC40A57D48AB1DB7ADFC5;
    internal static __StaticArrayInitTypeSize=52 FADB218011E7702BB9575D0C32A685DA10B5C72EB809BD9A955DB1C76E4D8315;
    internal static UInt32 ComputeStringHash(string s);
}
internal static class System.Text.Json.AppContextSwitchHelper : object {
    private static bool s_isSourceGenReflectionFallbackEnabled;
    public static bool IsSourceGenReflectionFallbackEnabled { get; }
    private static AppContextSwitchHelper();
    public static bool get_IsSourceGenReflectionFallbackEnabled();
}
internal class System.Text.Json.Arguments`4 : object {
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
}
internal class System.Text.Json.ArgumentState : object {
    public object Arguments;
    public ValueTuple`5[] FoundProperties;
    public ValueTuple`3[] FoundPropertiesAsync;
    public int FoundPropertyCount;
    public JsonParameterInfo JsonParameterInfo;
    public int ParameterIndex;
    public List`1<ParameterRef> ParameterRefCache;
}
internal class System.Text.Json.BitStack : ValueType {
    private static int AllocationFreeMaxDepth;
    private static int DefaultInitialArraySize;
    private Int32[] _array;
    private ulong _allocationFreeContainer;
    private int _currentDepth;
    public int CurrentDepth { get; }
    public int get_CurrentDepth();
    public void PushTrue();
    public void PushFalse();
    private void PushToArray(bool value);
    public bool Pop();
    private bool PopFromArray();
    private void DoubleArray(int minSize);
    public void SetFirstBit();
    public void ResetFirstBit();
    private static int Div32Rem(int number, Int32& remainder);
}
internal enum System.Text.Json.ConsumeNumberResult : Enum {
    public byte value__;
    public static ConsumeNumberResult Success;
    public static ConsumeNumberResult OperationIncomplete;
    public static ConsumeNumberResult NeedMoreData;
}
internal enum System.Text.Json.ConsumeTokenResult : Enum {
    public byte value__;
    public static ConsumeTokenResult Success;
    public static ConsumeTokenResult NotEnoughDataRollBackState;
    public static ConsumeTokenResult IncompleteNoRollBackNecessary;
}
internal enum System.Text.Json.ConverterStrategy : Enum {
    public byte value__;
    public static ConverterStrategy None;
    public static ConverterStrategy Object;
    public static ConverterStrategy Value;
    public static ConverterStrategy Enumerable;
    public static ConverterStrategy Dictionary;
}
internal enum System.Text.Json.DataType : Enum {
    public int value__;
    public static DataType Boolean;
    public static DataType DateOnly;
    public static DataType DateTime;
    public static DataType DateTimeOffset;
    public static DataType TimeOnly;
    public static DataType TimeSpan;
    public static DataType Base64String;
    public static DataType Guid;
    public static DataType Version;
}
internal enum System.Text.Json.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArrayDepthTooLarge;
    public static ExceptionResource EndOfCommentNotFound;
    public static ExceptionResource EndOfStringNotFound;
    public static ExceptionResource RequiredDigitNotFoundAfterDecimal;
    public static ExceptionResource RequiredDigitNotFoundAfterSign;
    public static ExceptionResource RequiredDigitNotFoundEndOfData;
    public static ExceptionResource ExpectedEndAfterSingleJson;
    public static ExceptionResource ExpectedEndOfDigitNotFound;
    public static ExceptionResource ExpectedFalse;
    public static ExceptionResource ExpectedNextDigitEValueNotFound;
    public static ExceptionResource ExpectedNull;
    public static ExceptionResource ExpectedSeparatorAfterPropertyNameNotFound;
    public static ExceptionResource ExpectedStartOfPropertyNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueAfterComment;
    public static ExceptionResource ExpectedStartOfValueNotFound;
    public static ExceptionResource ExpectedTrue;
    public static ExceptionResource ExpectedValueAfterPropertyNameNotFound;
    public static ExceptionResource FoundInvalidCharacter;
    public static ExceptionResource InvalidCharacterWithinString;
    public static ExceptionResource InvalidCharacterAfterEscapeWithinString;
    public static ExceptionResource InvalidHexCharacterWithinString;
    public static ExceptionResource InvalidEndOfJsonNonPrimitive;
    public static ExceptionResource MismatchedObjectArray;
    public static ExceptionResource ObjectDepthTooLarge;
    public static ExceptionResource ZeroDepthAtEnd;
    public static ExceptionResource DepthTooLarge;
    public static ExceptionResource CannotStartObjectArrayWithoutProperty;
    public static ExceptionResource CannotStartObjectArrayAfterPrimitiveOrClose;
    public static ExceptionResource CannotWriteValueWithinObject;
    public static ExceptionResource CannotWriteValueAfterPrimitiveOrClose;
    public static ExceptionResource CannotWritePropertyWithinArray;
    public static ExceptionResource ExpectedJsonTokens;
    public static ExceptionResource TrailingCommaNotAllowedBeforeArrayEnd;
    public static ExceptionResource TrailingCommaNotAllowedBeforeObjectEnd;
    public static ExceptionResource InvalidCharacterAtStartOfComment;
    public static ExceptionResource UnexpectedEndOfDataWhileReadingComment;
    public static ExceptionResource UnexpectedEndOfLineSeparator;
    public static ExceptionResource ExpectedOneCompleteToken;
    public static ExceptionResource NotEnoughData;
    public static ExceptionResource InvalidLeadingZeroInNumber;
}
internal class System.Text.Json.JsonCamelCaseNamingPolicy : JsonNamingPolicy {
    public virtual string ConvertName(string name);
    private static void FixCasing(Span`1<char> chars);
}
internal enum System.Text.Json.JsonCommentHandling : Enum {
    public byte value__;
    public static JsonCommentHandling Disallow;
    public static JsonCommentHandling Skip;
    public static JsonCommentHandling Allow;
}
internal static class System.Text.Json.JsonConstants : object {
    public static int MaxParameterCount;
    public static string DoubleFormatString;
    public static string SingleFormatString;
    public static byte OpenBrace;
    public static byte CloseBrace;
    public static byte OpenBracket;
    public static byte CloseBracket;
    public static byte Space;
    public static byte CarriageReturn;
    public static byte LineFeed;
    public static byte Tab;
    public static byte ListSeparator;
    public static byte KeyValueSeparator;
    public static byte Quote;
    public static byte BackSlash;
    public static byte Slash;
    public static byte BackSpace;
    public static byte FormFeed;
    public static byte Asterisk;
    public static byte Colon;
    public static byte Period;
    public static byte Plus;
    public static byte Hyphen;
    public static byte UtcOffsetToken;
    public static byte TimePrefix;
    public static byte StartingByteOfNonStandardSeparator;
    public static int SpacesPerIndent;
    public static int RemoveFlagsBitMask;
    public static int StackallocByteThreshold;
    public static int StackallocCharThreshold;
    public static int MaxExpansionFactorWhileEscaping;
    public static int MaxExpansionFactorWhileTranscoding;
    public static long ArrayPoolMaxSizeBeforeUsingNormalAlloc;
    public static int MaxUtf16RawValueLength;
    public static int MaxEscapedTokenSize;
    public static int MaxUnescapedTokenSize;
    public static int MaxBase64ValueTokenSize;
    public static int MaxCharacterTokenSize;
    public static int MaximumFormatBooleanLength;
    public static int MaximumFormatInt64Length;
    public static int MaximumFormatUInt64Length;
    public static int MaximumFormatDoubleLength;
    public static int MaximumFormatSingleLength;
    public static int MaximumFormatDecimalLength;
    public static int MaximumFormatGuidLength;
    public static int MaximumEscapedGuidLength;
    public static int MaximumFormatDateTimeLength;
    public static int MaximumFormatDateTimeOffsetLength;
    public static int MaxDateTimeUtcOffsetHours;
    public static int DateTimeNumFractionDigits;
    public static int MaxDateTimeFraction;
    public static int DateTimeParseNumFractionDigits;
    public static int MaximumDateTimeOffsetParseLength;
    public static int MinimumDateTimeParseLength;
    public static int MaximumEscapedDateTimeOffsetParseLength;
    public static int MaximumLiteralLength;
    public static char HighSurrogateStart;
    public static char HighSurrogateEnd;
    public static char LowSurrogateStart;
    public static char LowSurrogateEnd;
    public static int UnicodePlane01StartValue;
    public static int HighSurrogateStartValue;
    public static int HighSurrogateEndValue;
    public static int LowSurrogateStartValue;
    public static int LowSurrogateEndValue;
    public static int BitShiftBy10;
    public static int UnboxedParameterCountThreshold;
    public static ReadOnlySpan`1<byte> Utf8Bom { get; }
    public static ReadOnlySpan`1<byte> TrueValue { get; }
    public static ReadOnlySpan`1<byte> FalseValue { get; }
    public static ReadOnlySpan`1<byte> NullValue { get; }
    public static ReadOnlySpan`1<byte> NaNValue { get; }
    public static ReadOnlySpan`1<byte> PositiveInfinityValue { get; }
    public static ReadOnlySpan`1<byte> NegativeInfinityValue { get; }
    public static ReadOnlySpan`1<byte> Delimiters { get; }
    public static ReadOnlySpan`1<byte> EscapableChars { get; }
    public static ReadOnlySpan`1<byte> get_Utf8Bom();
    public static ReadOnlySpan`1<byte> get_TrueValue();
    public static ReadOnlySpan`1<byte> get_FalseValue();
    public static ReadOnlySpan`1<byte> get_NullValue();
    public static ReadOnlySpan`1<byte> get_NaNValue();
    public static ReadOnlySpan`1<byte> get_PositiveInfinityValue();
    public static ReadOnlySpan`1<byte> get_NegativeInfinityValue();
    public static ReadOnlySpan`1<byte> get_Delimiters();
    public static ReadOnlySpan`1<byte> get_EscapableChars();
}
internal class System.Text.Json.JsonDocument : object {
    private ReadOnlyMemory`1<byte> _utf8Json;
    private MetadataDb _parsedData;
    private Byte[] _extraRentedArrayPoolBytes;
    private PooledByteBufferWriter _extraPooledByteBufferWriter;
    private ValueTuple`2<int, string> _lastIndexAndString;
    [CompilerGeneratedAttribute]
private bool <IsDisposable>k__BackingField;
    private static JsonDocument s_nullLiteral;
    private static JsonDocument s_trueLiteral;
    private static JsonDocument s_falseLiteral;
    private static int UnseekableStreamInitialRentSize;
    internal bool IsDisposable { get; }
    public JsonElement RootElement { get; }
    private JsonDocument(ReadOnlyMemory`1<byte> utf8Json, MetadataDb parsedData, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter, bool isDisposable);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposable();
    public JsonElement get_RootElement();
    public sealed virtual void Dispose();
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
    internal JsonTokenType GetJsonTokenType(int index);
    internal int GetArrayLength(int index);
    internal JsonElement GetArrayIndexElement(int currentIndex, int arrayIndex);
    internal int GetEndIndex(int index, bool includeEndElement);
    internal ReadOnlyMemory`1<byte> GetRootRawValue();
    internal ReadOnlyMemory`1<byte> GetRawValue(int index, bool includeQuotes);
    private ReadOnlyMemory`1<byte> GetPropertyRawValue(int valueIndex);
    internal string GetString(int index, JsonTokenType expectedType);
    internal bool TextEquals(int index, ReadOnlySpan`1<char> otherText, bool isPropertyName);
    internal bool TextEquals(int index, ReadOnlySpan`1<byte> otherUtf8Text, bool isPropertyName, bool shouldUnescape);
    internal string GetNameOfPropertyValue(int index);
    internal bool TryGetValue(int index, Byte[]& value);
    internal bool TryGetValue(int index, SByte& value);
    internal bool TryGetValue(int index, Byte& value);
    internal bool TryGetValue(int index, Int16& value);
    internal bool TryGetValue(int index, UInt16& value);
    internal bool TryGetValue(int index, Int32& value);
    internal bool TryGetValue(int index, UInt32& value);
    internal bool TryGetValue(int index, Int64& value);
    internal bool TryGetValue(int index, UInt64& value);
    internal bool TryGetValue(int index, Double& value);
    internal bool TryGetValue(int index, Single& value);
    internal bool TryGetValue(int index, Decimal& value);
    internal bool TryGetValue(int index, DateTime& value);
    internal bool TryGetValue(int index, DateTimeOffset& value);
    internal bool TryGetValue(int index, Guid& value);
    internal string GetRawValueAsString(int index);
    internal string GetPropertyRawValueAsString(int valueIndex);
    internal JsonElement CloneElement(int index);
    internal void WriteElementTo(int index, Utf8JsonWriter writer);
    private void WriteComplexElement(int index, Utf8JsonWriter writer);
    private ReadOnlySpan`1<byte> UnescapeString(DbRow& row, ArraySegment`1& rented);
    private static void ClearAndReturn(ArraySegment`1<byte> rented);
    private void WritePropertyName(DbRow& row, Utf8JsonWriter writer);
    private void WriteString(DbRow& row, Utf8JsonWriter writer);
    private static void Parse(ReadOnlySpan`1<byte> utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack);
    private void CheckNotDisposed();
    private static void CheckExpectedType(JsonTokenType expected, JsonTokenType actual);
    private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName);
    public static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonDocumentOptions options);
    public static JsonDocument Parse(ReadOnlySequence`1<byte> utf8Json, JsonDocumentOptions options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonDocument Parse(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseRented(PooledByteBufferWriter utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(ReadOnlySpan`1<byte> utf8Json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(string json, JsonDocumentOptions options);
    [System.Text.Json.NullableContextAttribute("1")]
public static Task`1<JsonDocument> ParseAsync(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ParseAsyncCore>d__66")]
private static Task`1<JsonDocument> ParseAsyncCore(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    public static JsonDocument Parse(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    internal static JsonDocument ParseValue(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonDocument Parse(string json, JsonDocumentOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
public static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonDocument ParseValue(Utf8JsonReader& reader);
    internal static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document, bool shouldThrow, bool useArrayPools);
    private static JsonDocument CreateForLiteral(JsonTokenType tokenType);
    private static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedArrayPoolBytes, PooledByteBufferWriter extraPooledByteBufferWriter);
    private static JsonDocument ParseUnrented(ReadOnlyMemory`1<byte> utf8Json, JsonReaderOptions readerOptions, JsonTokenType tokenType);
    private static ArraySegment`1<byte> ReadToEnd(Stream stream);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ReadToEndAsync>d__77")]
private static Task`1<ArraySegment`1<byte>> ReadToEndAsync(Stream stream, CancellationToken cancellationToken);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<char> propertyName, JsonElement& value);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
    private bool TryGetNamedPropertyValue(int startIndex, int endIndex, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
    [CompilerGeneratedAttribute]
internal static JsonDocument <CreateForLiteral>g__Create|73_0(Byte[] utf8Json, <>c__DisplayClass73_0& );
}
internal class System.Text.Json.JsonDocumentOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [System.Text.Json.IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [System.Text.Json.IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
    internal JsonReaderOptions GetReaderOptions();
}
[System.Text.Json.IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.JsonElement : ValueType {
    private JsonDocument _parent;
    private int _idx;
    [DebuggerBrowsableAttribute("0")]
private JsonTokenType TokenType { get; }
    public JsonValueKind ValueKind { get; }
    public JsonElement Item { get; }
    [System.Text.Json.NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonElement(JsonDocument parent, int idx);
    private JsonTokenType get_TokenType();
    public JsonValueKind get_ValueKind();
    public JsonElement get_Item(int index);
    public int GetArrayLength();
    [System.Text.Json.NullableContextAttribute("1")]
public JsonElement GetProperty(string propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<char> propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<byte> utf8PropertyName);
    [System.Text.Json.NullableContextAttribute("1")]
public bool TryGetProperty(string propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<char> propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<byte> utf8PropertyName, JsonElement& value);
    public bool GetBoolean();
    [System.Text.Json.NullableContextAttribute("2")]
public string GetString();
    [System.Text.Json.NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    [System.Text.Json.NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    public bool TryGetByte(Byte& value);
    public byte GetByte();
    public bool TryGetInt16(Int16& value);
    public short GetInt16();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    public bool TryGetInt32(Int32& value);
    public int GetInt32();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    public bool TryGetInt64(Int64& value);
    public long GetInt64();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    public bool TryGetDouble(Double& value);
    public double GetDouble();
    public bool TryGetSingle(Single& value);
    public float GetSingle();
    public bool TryGetDecimal(Decimal& value);
    public decimal GetDecimal();
    public bool TryGetDateTime(DateTime& value);
    public DateTime GetDateTime();
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    public DateTimeOffset GetDateTimeOffset();
    public bool TryGetGuid(Guid& value);
    public Guid GetGuid();
    internal string GetPropertyName();
    [System.Text.Json.NullableContextAttribute("1")]
public string GetRawText();
    internal ReadOnlyMemory`1<byte> GetRawValue();
    internal string GetPropertyRawText();
    [System.Text.Json.NullableContextAttribute("2")]
public bool ValueEquals(string text);
    public bool ValueEquals(ReadOnlySpan`1<byte> utf8Text);
    public bool ValueEquals(ReadOnlySpan`1<char> text);
    internal bool TextEqualsHelper(ReadOnlySpan`1<byte> utf8Text, bool isPropertyName, bool shouldUnescape);
    internal bool TextEqualsHelper(ReadOnlySpan`1<char> text, bool isPropertyName);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
    public ArrayEnumerator EnumerateArray();
    public ObjectEnumerator EnumerateObject();
    [System.Text.Json.NullableContextAttribute("1")]
public virtual string ToString();
    public JsonElement Clone();
    private void CheckValidInstance();
    private string get_DebuggerDisplay();
    public static JsonElement ParseValue(Utf8JsonReader& reader);
    internal static JsonElement ParseValue(Stream utf8Json, JsonDocumentOptions options);
    internal static JsonElement ParseValue(ReadOnlySpan`1<byte> utf8Json, JsonDocumentOptions options);
    internal static JsonElement ParseValue(string json, JsonDocumentOptions options);
    public static bool TryParseValue(Utf8JsonReader& reader, Nullable`1& element);
    [CompilerGeneratedAttribute]
internal static bool <GetBoolean>g__ThrowJsonElementWrongTypeException|17_0(JsonTokenType actualType);
}
[System.Text.Json.IsReadOnlyAttribute]
internal class System.Text.Json.JsonEncodedText : ValueType {
    internal Byte[] _utf8Value;
    internal string _value;
    public ReadOnlySpan`1<byte> EncodedUtf8Bytes { get; }
    private JsonEncodedText(Byte[] utf8Value);
    public ReadOnlySpan`1<byte> get_EncodedUtf8Bytes();
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonEncodedText Encode(string value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    private static JsonEncodedText TranscodeAndEncode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    private static JsonEncodedText EncodeHelper(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public sealed virtual bool Equals(JsonEncodedText other);
    [System.Text.Json.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [System.Text.Json.NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
internal class System.Text.Json.JsonException : Exception {
    internal string _message;
    [CompilerGeneratedAttribute]
private bool <AppendPathInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BytePositionInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    internal bool AppendPathInformation { get; internal set; }
    public Nullable`1<long> LineNumber { get; internal set; }
    public Nullable`1<long> BytePositionInLine { get; internal set; }
    public string Path { get; internal set; }
    [System.Text.Json.NullableAttribute("1")]
public string Message { get; }
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine, Exception innerException);
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine);
    public JsonException(string message, Exception innerException);
    public JsonException(string message);
    [System.Text.Json.NullableContextAttribute("1")]
protected JsonException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal bool get_AppendPathInformation();
    [CompilerGeneratedAttribute]
internal void set_AppendPathInformation(bool value);
    [System.Text.Json.NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LineNumber();
    [CompilerGeneratedAttribute]
internal void set_LineNumber(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BytePositionInLine();
    [CompilerGeneratedAttribute]
internal void set_BytePositionInLine(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [System.Text.Json.NullableContextAttribute("1")]
public virtual string get_Message();
    internal void SetMessage(string message);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonHelpers : object {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    private static JsonHelpers();
    [ExtensionAttribute]
public static bool TryAdd(Dictionary`2<TKey, TValue> dictionary, TKey& key, TValue& value);
    [ExtensionAttribute]
internal static void StableSortByKey(List`1<T> items, Func`2<T, TKey> keySelector);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> GetSpan(Utf8JsonReader& reader);
    public static bool IsValidUnicodeScalar(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsInRangeInclusive(int value, int lowerBound, int upperBound);
    public static bool IsInRangeInclusive(long value, long lowerBound, long upperBound);
    public static bool IsInRangeInclusive(JsonTokenType value, JsonTokenType lowerBound, JsonTokenType upperBound);
    public static bool IsDigit(byte value);
    [ExtensionAttribute]
public static void ReadWithVerify(Utf8JsonReader& reader);
    public static string Utf8GetString(ReadOnlySpan`1<byte> bytes);
    public static Dictionary`2<TKey, TValue> CreateDictionaryFromCollection(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public static bool IsFinite(double value);
    public static bool IsFinite(float value);
    public static void ValidateInt32MaxArrayLength(UInt32 length);
    [ExtensionAttribute]
public static bool AllBitsEqual(BitArray bitArray, bool value);
    public static bool IsValidDateTimeOffsetParseLength(int length);
    public static bool IsValidUnescapedDateTimeOffsetParseLength(int length);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    private static bool TryParseDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeParseData& parseData);
    private static bool TryGetNextTwoDigits(ReadOnlySpan`1<byte> source, Int32& value);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(DateTimeParseData parseData, DateTimeOffset& value);
    private static bool TryCreateDateTime(DateTimeParseData parseData, DateTimeKind kind, DateTime& value);
    public static Byte[] GetEscapedPropertyNameSection(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public static Byte[] EscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    private static Byte[] GetEscapedPropertyNameSection(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    private static Byte[] GetPropertyNameSection(ReadOnlySpan`1<byte> utf8Value);
    [CompilerGeneratedAttribute]
internal static bool <TryParseDateTimeOffset>g__ParseOffset|21_0(DateTimeParseData& parseData, ReadOnlySpan`1<byte> offsetData);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
internal abstract class System.Text.Json.JsonNamingPolicy : object {
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <CamelCase>k__BackingField;
    public static JsonNamingPolicy CamelCase { get; }
    private static JsonNamingPolicy();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_CamelCase();
    public abstract virtual string ConvertName(string name);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[System.Text.Json.IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.JsonProperty : ValueType {
    [CompilerGeneratedAttribute]
private JsonElement <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <_name>k__BackingField;
    public JsonElement Value { get; }
    [System.Text.Json.NullableAttribute("2")]
private string _name { get; }
    public string Name { get; }
    private string DebuggerDisplay { get; }
    internal JsonProperty(JsonElement value, string name);
    [CompilerGeneratedAttribute]
public JsonElement get_Value();
    [CompilerGeneratedAttribute]
private string get__name();
    public string get_Name();
    [System.Text.Json.NullableContextAttribute("2")]
public bool NameEquals(string text);
    [System.Text.Json.NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<byte> utf8Text);
    [System.Text.Json.NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<char> text);
    internal bool EscapedNameEquals(ReadOnlySpan`1<byte> utf8Text);
    public void WriteTo(Utf8JsonWriter writer);
    public virtual string ToString();
    private string get_DebuggerDisplay();
}
[DefaultMemberAttribute("Item")]
internal class System.Text.Json.JsonPropertyDictionary`1 : object {
    private static int ListToDictionaryThreshold;
    private Dictionary`2<string, T> _propertyDictionary;
    private List`1<KeyValuePair`2<string, T>> _propertyList;
    private StringComparer _stringComparer;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private KeyCollection<T> _keyCollection;
    private ValueCollection<T> _valueCollection;
    public List`1<KeyValuePair`2<string, T>> List { get; }
    public int Count { get; }
    public IList`1<string> Keys { get; }
    public IList`1<T> Values { get; }
    public bool IsReadOnly { get; public set; }
    public T Item { get; public set; }
    public JsonPropertyDictionary`1(bool caseInsensitive);
    public JsonPropertyDictionary`1(bool caseInsensitive, int capacity);
    public List`1<KeyValuePair`2<string, T>> get_List();
    public void Add(string propertyName, T value);
    public void Add(KeyValuePair`2<string, T> property);
    public bool TryAdd(string propertyName, T value);
    public void Clear();
    public bool ContainsKey(string propertyName);
    public int get_Count();
    public bool Remove(string propertyName);
    public bool Contains(KeyValuePair`2<string, T> item);
    public void CopyTo(KeyValuePair`2[] array, int index);
    [IteratorStateMachineAttribute("System.Text.Json.JsonPropertyDictionary`1/<GetEnumerator>d__18")]
public IEnumerator`1<KeyValuePair`2<string, T>> GetEnumerator();
    public IList`1<string> get_Keys();
    public IList`1<T> get_Values();
    public bool TryGetValue(string propertyName, T& value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    public T get_Item(string propertyName);
    public void set_Item(string propertyName, T value);
    public T SetValue(string propertyName, T value, Action assignParent);
    private void AddValue(string propertyName, T value);
    internal bool TryAddValue(string propertyName, T value);
    private void CreateDictionaryIfThresholdMet();
    internal bool ContainsValue(T value);
    public Nullable`1<KeyValuePair`2<string, T>> FindValue(T value);
    private bool ContainsProperty(string propertyName);
    private int FindValueIndex(string propertyName);
    public bool TryGetPropertyValue(string propertyName, T& value);
    public bool TryRemoveProperty(string propertyName, T& existing);
    public IList`1<string> GetKeyCollection();
    public IList`1<T> GetValueCollection();
}
internal class System.Text.Json.JsonReaderException : JsonException {
    public JsonReaderException(string message, long lineNumber, long bytePositionInLine);
    private JsonReaderException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonReaderHelper : object {
    private static ulong XorPowerOfTwoToHighByte;
    public static UTF8Encoding s_utf8Encoding;
    private static JsonReaderHelper();
    public static ValueTuple`2<int, int> CountNewLines(ReadOnlySpan`1<byte> data);
    [ExtensionAttribute]
internal static JsonValueKind ToValueKind(JsonTokenType tokenType);
    public static bool IsTokenTypePrimitive(JsonTokenType tokenType);
    public static bool IsHexDigit(byte nextByte);
    [ExtensionAttribute]
public static int IndexOfQuoteOrAnyControlOrBackSlash(ReadOnlySpan`1<byte> span);
    private static int IndexOfOrLessThan(Byte& searchSpace, byte value0, byte value1, byte lessThan, int length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    public static bool TryGetEscapedDateTime(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryGetEscapedDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    public static bool TryGetEscapedGuid(ReadOnlySpan`1<byte> source, Guid& value);
    public static bool TryGetFloatingPointConstant(ReadOnlySpan`1<byte> span, Single& value);
    public static bool TryGetFloatingPointConstant(ReadOnlySpan`1<byte> span, Double& value);
    public static bool TryGetUnescapedBase64Bytes(ReadOnlySpan`1<byte> utf8Source, Byte[]& bytes);
    public static string GetUnescapedString(ReadOnlySpan`1<byte> utf8Source);
    public static ReadOnlySpan`1<byte> GetUnescapedSpan(ReadOnlySpan`1<byte> utf8Source);
    public static bool UnescapeAndCompare(ReadOnlySpan`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool UnescapeAndCompare(ReadOnlySequence`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool TryDecodeBase64InPlace(Span`1<byte> utf8Unescaped, Byte[]& bytes);
    public static bool TryDecodeBase64(ReadOnlySpan`1<byte> utf8Unescaped, Byte[]& bytes);
    public static string TranscodeHelper(ReadOnlySpan`1<byte> utf8Unescaped);
    public static int TranscodeHelper(ReadOnlySpan`1<byte> utf8Unescaped, Span`1<char> destination);
    public static void ValidateUtf8(ReadOnlySpan`1<byte> utf8Buffer);
    internal static int GetUtf8ByteCount(ReadOnlySpan`1<char> text);
    internal static int GetUtf8FromText(ReadOnlySpan`1<char> text, Span`1<byte> dest);
    internal static string GetTextFromUtf8(ReadOnlySpan`1<byte> utf8Text);
    internal static void Unescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& written);
    internal static void Unescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int idx, Int32& written);
    internal static bool TryUnescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& written);
    private static bool TryUnescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int idx, Int32& written);
    private static bool TryEncodeToUtf8Bytes(UInt32 scalar, Span`1<byte> utf8Destination, Int32& bytesWritten);
}
internal class System.Text.Json.JsonReaderOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [System.Text.Json.IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [System.Text.Json.IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
}
internal class System.Text.Json.JsonReaderState : ValueType {
    internal long _lineNumber;
    internal long _bytePositionInLine;
    internal bool _inObject;
    internal bool _isNotPrimitive;
    internal bool _valueIsEscaped;
    internal bool _trailingCommaBeforeComment;
    internal JsonTokenType _tokenType;
    internal JsonTokenType _previousTokenType;
    internal JsonReaderOptions _readerOptions;
    internal BitStack _bitStack;
    public JsonReaderOptions Options { get; }
    public JsonReaderState(JsonReaderOptions options);
    public JsonReaderOptions get_Options();
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Text.Json.JsonSerializer : object {
    internal static string SerializationUnreferencedCodeMessage;
    internal static string SerializationRequiresDynamicCodeMessage;
    internal static string IdPropertyName;
    internal static string RefPropertyName;
    internal static string TypePropertyName;
    internal static string ValuesPropertyName;
    internal static Byte[] s_idPropertyName;
    internal static Byte[] s_refPropertyName;
    internal static Byte[] s_typePropertyName;
    internal static Byte[] s_valuesPropertyName;
    internal static JsonEncodedText s_metadataId;
    internal static JsonEncodedText s_metadataRef;
    internal static JsonEncodedText s_metadataType;
    internal static JsonEncodedText s_metadataValues;
    private static float FlushThreshold;
    private static JsonSerializer();
    [System.Text.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(JsonDocument document, JsonSerializerOptions options);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(JsonDocument document, Type returnType, JsonSerializerOptions options);
    [ExtensionAttribute]
public static TValue Deserialize(JsonDocument document, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonDocument document, Type returnType, JsonSerializerContext context);
    private static TValue ReadDocument(JsonDocument document, JsonTypeInfo jsonTypeInfo);
    [System.Text.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(JsonElement element, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(JsonElement element, Type returnType, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue Deserialize(JsonElement element, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonElement element, Type returnType, JsonSerializerContext context);
    private static TValue ReadUsingMetadata(JsonElement element, JsonTypeInfo jsonTypeInfo);
    [System.Text.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(JsonNode node, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(JsonNode node, Type returnType, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue Deserialize(JsonNode node, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [ExtensionAttribute]
public static object Deserialize(JsonNode node, Type returnType, JsonSerializerContext context);
    private static TValue ReadNode(JsonNode node, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonDocument SerializeToDocument(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonDocument SerializeToDocument(object value, Type inputType, JsonSerializerOptions options);
    public static JsonDocument SerializeToDocument(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static JsonDocument SerializeToDocument(object value, Type inputType, JsonSerializerContext context);
    private static JsonDocument WriteDocument(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static JsonDocument WriteDocumentAsObject(object value, JsonTypeInfo jsonTypeInfo);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonElement SerializeToElement(TValue value, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonElement SerializeToElement(object value, Type inputType, JsonSerializerOptions options);
    public static JsonElement SerializeToElement(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static JsonElement SerializeToElement(object value, Type inputType, JsonSerializerContext context);
    private static JsonElement WriteElement(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static JsonElement WriteElementAsObject(object value, JsonTypeInfo jsonTypeInfo);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonNode SerializeToNode(TValue value, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonNode SerializeToNode(object value, Type inputType, JsonSerializerOptions options);
    public static JsonNode SerializeToNode(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static JsonNode SerializeToNode(object value, Type inputType, JsonSerializerContext context);
    private static JsonNode WriteNode(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static JsonNode WriteNodeAsObject(object value, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonTypeInfo GetTypeInfo(JsonSerializerOptions options, Type inputType);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonTypeInfo`1<T> GetTypeInfo(JsonSerializerOptions options);
    private static JsonTypeInfo GetTypeInfo(JsonSerializerContext context, Type inputType);
    internal static bool IsValidNumberHandlingValue(JsonNumberHandling handling);
    internal static bool TryReadMetadata(JsonConverter converter, JsonTypeInfo jsonTypeInfo, Utf8JsonReader& reader, ReadStack& state);
    internal static bool IsMetadataPropertyName(ReadOnlySpan`1<byte> propertyName, PolymorphicTypeResolver resolver);
    internal static MetadataPropertyName GetMetadataPropertyName(ReadOnlySpan`1<byte> propertyName, PolymorphicTypeResolver resolver);
    internal static bool TryHandleReferenceFromJsonElement(Utf8JsonReader& reader, ReadStack& state, JsonElement element, Object& referenceValue);
    internal static bool TryHandleReferenceFromJsonNode(Utf8JsonReader& reader, ReadStack& state, JsonNode jsonNode, Object& referenceValue);
    internal static void ValidateMetadataForObjectConverter(JsonConverter converter, Utf8JsonReader& reader, ReadStack& state);
    internal static void ValidateMetadataForArrayConverter(JsonConverter converter, Utf8JsonReader& reader, ReadStack& state);
    internal static T ResolveReferenceId(ReadStack& state);
    internal static JsonPropertyInfo LookupProperty(object obj, ReadOnlySpan`1<byte> unescapedPropertyName, ReadStack& state, JsonSerializerOptions options, Boolean& useExtensionProperty, bool createExtensionProperty);
    internal static ReadOnlySpan`1<byte> GetPropertyName(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    internal static void CreateExtensionDataProperty(object obj, JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options);
    private static TValue ReadCore(Utf8JsonReader& reader, JsonTypeInfo jsonTypeInfo, ReadStack& state);
    private static TValue ReadFromSpan(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo jsonTypeInfo, Nullable`1<int> actualByteCount);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerContext context);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(Stream utf8Json, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(Stream utf8Json, Type returnType, JsonSerializerOptions options);
    public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    public static TValue Deserialize(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerContext context, CancellationToken cancellationToken);
    public static object Deserialize(Stream utf8Json, Type returnType, JsonSerializerContext context);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static IAsyncEnumerable`1<TValue> DeserializeAsyncEnumerable(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static IAsyncEnumerable`1<TValue> DeserializeAsyncEnumerable(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    private static JsonTypeInfo`1<Queue`1<TValue>> CreateQueueTypeInfo(JsonTypeInfo jsonTypeInfo);
    [AsyncIteratorStateMachineAttribute("System.Text.Json.JsonSerializer/<CreateAsyncEnumerableDeserializer>d__75`1")]
private static IAsyncEnumerable`1<TValue> CreateAsyncEnumerableDeserializer(Stream utf8Json, JsonTypeInfo`1<Queue`1<TValue>> queueTypeInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<ReadFromStreamAsync>d__76`1")]
internal static ValueTask`1<TValue> ReadFromStreamAsync(Stream utf8Json, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken);
    internal static TValue ReadFromStream(Stream utf8Json, JsonTypeInfo jsonTypeInfo);
    internal static TValue ContinueDeserialize(ReadBufferState& bufferState, JsonReaderState& jsonReaderState, ReadStack& readStack, JsonTypeInfo jsonTypeInfo);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(string json, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(ReadOnlySpan`1<char> json, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(string json, Type returnType, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(ReadOnlySpan`1<char> json, Type returnType, JsonSerializerOptions options);
    public static TValue Deserialize(string json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [System.Text.Json.NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<char> json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(string json, Type returnType, JsonSerializerContext context);
    public static object Deserialize(ReadOnlySpan`1<char> json, Type returnType, JsonSerializerContext context);
    private static TValue ReadFromSpan(ReadOnlySpan`1<char> json, JsonTypeInfo jsonTypeInfo);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("2")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerContext context);
    private static TValue Read(Utf8JsonReader& reader, JsonTypeInfo jsonTypeInfo);
    private static Utf8JsonReader GetReaderScopedToNextValue(Utf8JsonReader& reader, ReadStack& state);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static Byte[] SerializeToUtf8Bytes(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerOptions options);
    public static Byte[] SerializeToUtf8Bytes(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerContext context);
    private static Byte[] WriteBytes(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static Byte[] WriteBytesAsObject(object value, JsonTypeInfo jsonTypeInfo);
    internal static MetadataPropertyName WriteMetadataForObject(JsonConverter jsonConverter, WriteStack& state, Utf8JsonWriter writer);
    internal static MetadataPropertyName WriteMetadataForCollection(JsonConverter jsonConverter, WriteStack& state, Utf8JsonWriter writer);
    internal static bool TryGetReferenceForValue(object currentValue, WriteStack& state, Utf8JsonWriter writer);
    private static void WriteCore(Utf8JsonWriter writer, TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static void WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonTypeInfo jsonTypeInfo);
    private static bool WriteCore(Utf8JsonWriter writer, TValue& value, JsonTypeInfo jsonTypeInfo, WriteStack& state);
    private static JsonTypeInfo ResolvePolymorphicTypeInfo(TValue& value, JsonTypeInfo jsonTypeInfo, Boolean& isPolymorphicType);
    private static void ValidateInputType(object value, Type inputType);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static Task SerializeAsync(Stream utf8Json, TValue value, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static void Serialize(Stream utf8Json, TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static void Serialize(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options);
    public static Task SerializeAsync(Stream utf8Json, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    public static void Serialize(Stream utf8Json, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerContext context, CancellationToken cancellationToken);
    public static void Serialize(Stream utf8Json, object value, Type inputType, JsonSerializerContext context);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<WriteStreamAsync>d__121`1")]
private static Task WriteStreamAsync(Stream utf8Json, TValue value, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken);
    private static void WriteStream(Stream utf8Json, TValue& value, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static string Serialize(TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static string Serialize(object value, Type inputType, JsonSerializerOptions options);
    public static string Serialize(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static string Serialize(object value, Type inputType, JsonSerializerContext context);
    private static string WriteString(TValue& value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    private static string WriteStringAsObject(object value, JsonTypeInfo jsonTypeInfo);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static void Serialize(Utf8JsonWriter writer, TValue value, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerContext context);
    [CompilerGeneratedAttribute]
internal static string <TryHandleReferenceFromJsonNode>g__ReadAsStringMetadataValue|51_0(JsonNode jsonNode);
}
internal enum System.Text.Json.JsonSerializerDefaults : Enum {
    public int value__;
    public static JsonSerializerDefaults General;
    public static JsonSerializerDefaults Web;
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.JsonSerializerOptions : object {
    private CachingContext _cachingContext;
    private JsonTypeInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lastTypeInfo;
    private JsonTypeInfo _objectTypeInfo;
    internal static int BufferSizeDefault;
    internal static int DefaultMaxDepth;
    private static JsonSerializerOptions s_defaultOptions;
    private IJsonTypeInfoResolver _typeInfoResolver;
    private MemberAccessor _memberAccessorStrategy;
    private JsonNamingPolicy _dictionaryKeyPolicy;
    private JsonNamingPolicy _jsonPropertyNamingPolicy;
    private JsonCommentHandling _readCommentHandling;
    private ReferenceHandler _referenceHandler;
    private JavaScriptEncoder _encoder;
    private ConfigurationList`1<JsonConverter> _converters;
    private JsonIgnoreCondition _defaultIgnoreCondition;
    private JsonNumberHandling _numberHandling;
    private JsonUnknownTypeHandling _unknownTypeHandling;
    private int _defaultBufferSize;
    private int _maxDepth;
    private bool _allowTrailingCommas;
    private bool _ignoreNullValues;
    private bool _ignoreReadOnlyProperties;
    private bool _ignoreReadonlyFields;
    private bool _includeFields;
    private bool _propertyNameCaseInsensitive;
    private bool _writeIndented;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isImmutable;
    [CompilerGeneratedAttribute]
private int <EffectiveMaxDepth>k__BackingField;
    internal ReferenceHandlingStrategy ReferenceHandlingStrategy;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isInitializedForReflectionSerializer;
    private IJsonTypeInfoResolver _effectiveJsonTypeInfoResolver;
    [System.Text.Json.NullableAttribute("1")]
internal JsonTypeInfo ObjectTypeInfo { get; }
    [System.Text.Json.NullableAttribute("1")]
public IList`1<JsonConverter> Converters { get; }
    [System.Text.Json.NullableAttribute("1")]
public static JsonSerializerOptions Default { get; }
    public IJsonTypeInfoResolver TypeInfoResolver { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    public int DefaultBufferSize { get; public set; }
    public JavaScriptEncoder Encoder { get; public set; }
    public JsonNamingPolicy DictionaryKeyPolicy { get; public set; }
    [ObsoleteAttribute("JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.")]
[EditorBrowsableAttribute("1")]
public bool IgnoreNullValues { get; public set; }
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IncludeFields { get; public set; }
    public int MaxDepth { get; public set; }
    internal int EffectiveMaxDepth { get; private set; }
    public JsonNamingPolicy PropertyNamingPolicy { get; public set; }
    public bool PropertyNameCaseInsensitive { get; public set; }
    public JsonCommentHandling ReadCommentHandling { get; public set; }
    public JsonUnknownTypeHandling UnknownTypeHandling { get; public set; }
    public bool WriteIndented { get; public set; }
    public ReferenceHandler ReferenceHandler { get; public set; }
    internal JsonSerializerContext SerializerContext { get; }
    [System.Text.Json.NullableAttribute("1")]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
internal MemberAccessor MemberAccessorStrategy { get; }
    internal bool IsImmutable { get; internal set; }
    internal bool IsInitializedForReflectionSerializer { get; }
    [System.Text.Json.NullableAttribute("1")]
private string DebuggerDisplay { get; }
    [System.Text.Json.NullableContextAttribute("1")]
public JsonSerializerOptions(JsonSerializerOptions options);
    public JsonSerializerOptions(JsonSerializerDefaults defaults);
    [System.Text.Json.NullableContextAttribute("1")]
public JsonTypeInfo GetTypeInfo(Type type);
    internal JsonTypeInfo GetTypeInfoInternal(Type type, bool ensureConfigured, bool resolveIfMutable);
    internal bool TryGetTypeInfoCached(Type type, JsonTypeInfo& typeInfo);
    internal JsonTypeInfo GetTypeInfoForRootType(Type type);
    internal JsonTypeInfo get_ObjectTypeInfo();
    internal void ClearCaches();
    private CachingContext GetCachingContext();
    [System.Text.Json.NullableContextAttribute("1")]
public IList`1<JsonConverter> get_Converters();
    [System.Text.Json.NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("Getting a converter for a type may require reflection which depends on unreferenced code.")]
[RequiresDynamicCodeAttribute("Getting a converter for a type may require reflection which depends on runtime code generation.")]
public JsonConverter GetConverter(Type typeToConvert);
    internal JsonConverter GetConverterInternal(Type typeToConvert);
    internal JsonConverter GetConverterFromList(Type typeToConvert);
    internal JsonConverter ExpandConverterFactory(JsonConverter converter, Type typeToConvert);
    internal static void CheckConverterNullabilityIsSameAsPropertyType(JsonConverter converter, Type propertyType);
    [System.Text.Json.NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonSerializerOptions get_Default();
    private static void TrackOptionsInstance(JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("0")]
public void AddContext();
    public IJsonTypeInfoResolver get_TypeInfoResolver();
    public void set_TypeInfoResolver(IJsonTypeInfoResolver value);
    public bool get_AllowTrailingCommas();
    public void set_AllowTrailingCommas(bool value);
    public int get_DefaultBufferSize();
    public void set_DefaultBufferSize(int value);
    public JavaScriptEncoder get_Encoder();
    public void set_Encoder(JavaScriptEncoder value);
    public JsonNamingPolicy get_DictionaryKeyPolicy();
    public void set_DictionaryKeyPolicy(JsonNamingPolicy value);
    public bool get_IgnoreNullValues();
    public void set_IgnoreNullValues(bool value);
    public JsonIgnoreCondition get_DefaultIgnoreCondition();
    public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    public JsonNumberHandling get_NumberHandling();
    public void set_NumberHandling(JsonNumberHandling value);
    public bool get_IgnoreReadOnlyProperties();
    public void set_IgnoreReadOnlyProperties(bool value);
    public bool get_IgnoreReadOnlyFields();
    public void set_IgnoreReadOnlyFields(bool value);
    public bool get_IncludeFields();
    public void set_IncludeFields(bool value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_EffectiveMaxDepth();
    [CompilerGeneratedAttribute]
private void set_EffectiveMaxDepth(int value);
    public JsonNamingPolicy get_PropertyNamingPolicy();
    public void set_PropertyNamingPolicy(JsonNamingPolicy value);
    public bool get_PropertyNameCaseInsensitive();
    public void set_PropertyNameCaseInsensitive(bool value);
    public JsonCommentHandling get_ReadCommentHandling();
    public void set_ReadCommentHandling(JsonCommentHandling value);
    public JsonUnknownTypeHandling get_UnknownTypeHandling();
    public void set_UnknownTypeHandling(JsonUnknownTypeHandling value);
    public bool get_WriteIndented();
    public void set_WriteIndented(bool value);
    public ReferenceHandler get_ReferenceHandler();
    public void set_ReferenceHandler(ReferenceHandler value);
    internal JsonSerializerContext get_SerializerContext();
    internal MemberAccessor get_MemberAccessorStrategy();
    internal bool get_IsImmutable();
    internal void set_IsImmutable(bool value);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal void InitializeForReflectionSerializer();
    internal bool get_IsInitializedForReflectionSerializer();
    internal void InitializeForMetadataGeneration();
    private JsonTypeInfo GetTypeInfoNoCaching(Type type);
    internal JsonDocumentOptions GetDocumentOptions();
    internal JsonNodeOptions GetNodeOptions();
    internal JsonReaderOptions GetReaderOptions();
    internal JsonWriterOptions GetWriterOptions();
    internal void VerifyMutable();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonSerializerOptions GetOrCreateDefaultOptionsInstance();
    private string get_DebuggerDisplay();
}
internal enum System.Text.Json.JsonTokenType : Enum {
    public byte value__;
    public static JsonTokenType None;
    public static JsonTokenType StartObject;
    public static JsonTokenType EndObject;
    public static JsonTokenType StartArray;
    public static JsonTokenType EndArray;
    public static JsonTokenType PropertyName;
    public static JsonTokenType Comment;
    public static JsonTokenType String;
    public static JsonTokenType Number;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Null;
}
internal enum System.Text.Json.JsonValueKind : Enum {
    public byte value__;
    public static JsonValueKind Undefined;
    public static JsonValueKind Object;
    public static JsonValueKind Array;
    public static JsonValueKind String;
    public static JsonValueKind Number;
    public static JsonValueKind True;
    public static JsonValueKind False;
    public static JsonValueKind Null;
}
internal static class System.Text.Json.JsonWriterHelper : object {
    private static StandardFormat s_dateTimeStandardFormat;
    public static int LastAsciiCharacter;
    private static StandardFormat s_hexStandardFormat;
    private static ReadOnlySpan`1<byte> AllowList { get; }
    private static JsonWriterHelper();
    public static void WriteIndentation(Span`1<byte> buffer, int indent);
    public static void ValidateProperty(ReadOnlySpan`1<byte> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<byte> value);
    public static void ValidateBytes(ReadOnlySpan`1<byte> bytes);
    public static void ValidateDouble(double value);
    public static void ValidateSingle(float value);
    public static void ValidateProperty(ReadOnlySpan`1<char> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndBytes(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public static void ValidatePropertyAndBytes(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> bytes);
    internal static void ValidateNumber(ReadOnlySpan`1<byte> utf8FormattedNumber);
    public static void WriteDateTimeTrimmed(Span`1<byte> buffer, DateTime value, Int32& bytesWritten);
    public static void WriteDateTimeOffsetTrimmed(Span`1<byte> buffer, DateTimeOffset value, Int32& bytesWritten);
    public static void TrimDateTimeOffset(Span`1<byte> buffer, Int32& bytesWritten);
    private static ReadOnlySpan`1<byte> get_AllowList();
    private static bool NeedsEscaping(byte value);
    private static bool NeedsEscapingNoBoundsCheck(char value);
    public static int NeedsEscaping(ReadOnlySpan`1<byte> value, JavaScriptEncoder encoder);
    public static int NeedsEscaping(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static int GetMaxEscapedLength(int textLength, int firstIndexToEscape);
    private static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextBytes(byte value, Span`1<byte> destination, Int32& written);
    private static bool IsAsciiValue(byte value);
    private static bool IsAsciiValue(char value);
    private static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextChars(char value, Span`1<char> destination, Int32& written);
    private static int WriteHex(int value, Span`1<char> destination, int written);
    public static OperationStatus ToUtf8(ReadOnlySpan`1<byte> utf16Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten);
    private static int PtrDiff(Char* a, Char* b);
    private static int PtrDiff(Byte* a, Byte* b);
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
internal class System.Text.Json.JsonWriterOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private int _optionsMask;
    [CompilerGeneratedAttribute]
private JavaScriptEncoder <Encoder>k__BackingField;
    private static int IndentBit;
    private static int SkipValidationBit;
    public JavaScriptEncoder Encoder { get; public set; }
    public bool Indented { get; public set; }
    public int MaxDepth { get; public set; }
    public bool SkipValidation { get; public set; }
    internal bool IndentedOrNotSkipValidation { get; }
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public JavaScriptEncoder get_Encoder();
    [CompilerGeneratedAttribute]
public void set_Encoder(JavaScriptEncoder value);
    public bool get_Indented();
    public void set_Indented(bool value);
    [System.Text.Json.IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public bool get_SkipValidation();
    public void set_SkipValidation(bool value);
    internal bool get_IndentedOrNotSkipValidation();
}
[FlagsAttribute]
internal enum System.Text.Json.MetadataPropertyName : Enum {
    public byte value__;
    public static MetadataPropertyName None;
    public static MetadataPropertyName Values;
    public static MetadataPropertyName Id;
    public static MetadataPropertyName Ref;
    public static MetadataPropertyName Type;
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
[DebuggerDisplayAttribute("JsonArray[{List.Count}]")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonArray/DebugView")]
internal class System.Text.Json.Nodes.JsonArray : JsonNode {
    private Nullable`1<JsonElement> _jsonElement;
    private List`1<JsonNode> _list;
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<JsonNode> List { get; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.IsReadOnly { get; }
    public JsonArray(Nullable`1<JsonNodeOptions> options);
    public JsonArray(JsonNodeOptions options, JsonNode[] items);
    public JsonArray(JsonNode[] items);
    internal JsonArray(JsonElement element, Nullable`1<JsonNodeOptions> options);
    private void InitializeFromArray(JsonNode[] items);
    public static JsonArray Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
    [RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.")]
[RequiresDynamicCodeAttribute("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
public void Add(T value);
    internal List`1<JsonNode> get_List();
    internal JsonNode GetItem(int index);
    internal void SetItem(int index, JsonNode value);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    [System.Text.Json.NullableContextAttribute("1")]
public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    private void CreateNodes();
    public sealed virtual int get_Count();
    public sealed virtual void Add(JsonNode item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JsonNode item);
    public sealed virtual int IndexOf(JsonNode item);
    public sealed virtual void Insert(int index, JsonNode item);
    public sealed virtual bool Remove(JsonNode item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.CopyTo(JsonNode[] array, int index);
    public sealed virtual IEnumerator`1<JsonNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.get_IsReadOnly();
    private static void DetachParent(JsonNode item);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal abstract class System.Text.Json.Nodes.JsonNode : object {
    private JsonNode _parent;
    private Nullable`1<JsonNodeOptions> _options;
    private protected static JsonSerializerOptions s_defaultOptions;
    public Nullable`1<JsonNodeOptions> Options { get; }
    [System.Text.Json.NullableAttribute("2")]
public JsonNode Parent { get; internal set; }
    public JsonNode Root { get; }
    [System.Text.Json.NullableAttribute("2")]
public JsonNode Item { get; public set; }
    [System.Text.Json.NullableAttribute("2")]
public JsonNode Item { get; public set; }
    internal JsonNode(Nullable`1<JsonNodeOptions> options);
    private static JsonNode();
    public Nullable`1<JsonNodeOptions> get_Options();
    public JsonArray AsArray();
    public JsonObject AsObject();
    public JsonValue AsValue();
    [System.Text.Json.NullableContextAttribute("2")]
public JsonNode get_Parent();
    internal void set_Parent(JsonNode value);
    public string GetPath();
    internal abstract virtual void GetPath(List`1<string> path, JsonNode child);
    public JsonNode get_Root();
    public virtual T GetValue();
    [System.Text.Json.NullableContextAttribute("2")]
public sealed virtual JsonNode get_Item(int index);
    [System.Text.Json.NullableContextAttribute("2")]
public sealed virtual void set_Item(int index, JsonNode value);
    public sealed virtual JsonNode get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JsonNode value);
    internal void AssignParent(JsonNode parent);
    public static JsonNode op_Implicit(bool value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<bool> value);
    public static JsonNode op_Implicit(byte value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<byte> value);
    public static JsonNode op_Implicit(char value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<char> value);
    public static JsonNode op_Implicit(DateTime value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<DateTime> value);
    public static JsonNode op_Implicit(DateTimeOffset value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JsonNode op_Implicit(decimal value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<decimal> value);
    public static JsonNode op_Implicit(double value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<double> value);
    public static JsonNode op_Implicit(Guid value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<Guid> value);
    public static JsonNode op_Implicit(short value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<short> value);
    public static JsonNode op_Implicit(int value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<int> value);
    public static JsonNode op_Implicit(long value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(sbyte value);
    [System.Text.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<sbyte> value);
    public static JsonNode op_Implicit(float value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<float> value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(ushort value);
    [System.Text.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(UInt32 value);
    [System.Text.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(ulong value);
    [System.Text.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<ulong> value);
    public static bool op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<bool> op_Explicit(JsonNode value);
    public static byte op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<byte> op_Explicit(JsonNode value);
    public static char op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<char> op_Explicit(JsonNode value);
    public static DateTime op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<DateTime> op_Explicit(JsonNode value);
    public static DateTimeOffset op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<DateTimeOffset> op_Explicit(JsonNode value);
    public static decimal op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<decimal> op_Explicit(JsonNode value);
    public static double op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<double> op_Explicit(JsonNode value);
    public static Guid op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<Guid> op_Explicit(JsonNode value);
    public static short op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<short> op_Explicit(JsonNode value);
    public static int op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<int> op_Explicit(JsonNode value);
    public static long op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<long> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JsonNode value);
    public static float op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static Nullable`1<float> op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static string op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JsonNode value);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonNode Parse(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> nodeOptions);
    public static JsonNode Parse(string json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    [System.Text.Json.NullableContextAttribute("0")]
public static JsonNode Parse(ReadOnlySpan`1<byte> utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    public static JsonNode Parse(Stream utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    public string ToJsonString(JsonSerializerOptions options);
    public virtual string ToString();
    public abstract virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
internal class System.Text.Json.Nodes.JsonNodeOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <PropertyNameCaseInsensitive>k__BackingField;
    public bool PropertyNameCaseInsensitive { get; public set; }
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_PropertyNameCaseInsensitive();
    [CompilerGeneratedAttribute]
public void set_PropertyNameCaseInsensitive(bool value);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[DebuggerDisplayAttribute("JsonObject[{Count}]")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonObject/DebugView")]
internal class System.Text.Json.Nodes.JsonObject : JsonNode {
    private Nullable`1<JsonElement> _jsonElement;
    private JsonPropertyDictionary`1<JsonNode> _dictionary;
    public int Count { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.Keys { get; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<JsonNode> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.IsReadOnly { get; }
    public JsonObject(Nullable`1<JsonNodeOptions> options);
    public JsonObject(IEnumerable`1<KeyValuePair`2<string, JsonNode>> properties, Nullable`1<JsonNodeOptions> options);
    internal JsonObject(JsonElement element, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("2")]
public static JsonObject Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
    public bool TryGetPropertyValue(string propertyName, JsonNode& jsonNode);
    public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
    internal JsonNode GetItem(string propertyName);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    internal void SetItem(string propertyName, JsonNode value);
    private void DetachParent(JsonNode item);
    public sealed virtual void Add(string propertyName, JsonNode value);
    public sealed virtual void Add(KeyValuePair`2<string, JsonNode> property);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(string propertyName);
    public sealed virtual int get_Count();
    public sealed virtual bool Remove(string propertyName);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.Contains(KeyValuePair`2<string, JsonNode> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.CopyTo(KeyValuePair`2[] array, int index);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JsonNode>> GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.Remove(KeyValuePair`2<string, JsonNode> item);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.get_Keys();
    private sealed virtual override ICollection`1<JsonNode> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.get_Values();
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.TryGetValue(string propertyName, JsonNode& jsonNode);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void InitializeIfRequired();
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
internal abstract class System.Text.Json.Nodes.JsonValue : JsonNode {
    internal static string CreateUnreferencedCodeMessage;
    internal static string CreateDynamicCodeMessage;
    private protected JsonValue(Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(bool value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<bool> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(byte value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<byte> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(char value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<char> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(DateTime value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<DateTime> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(DateTimeOffset value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<DateTimeOffset> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(decimal value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<decimal> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(double value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<double> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(Guid value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<Guid> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(short value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<short> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(int value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<int> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(long value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<long> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(sbyte value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<sbyte> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
public static JsonValue Create(float value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<float> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(string value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(ushort value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<ushort> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(UInt32 value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<UInt32> value, Nullable`1<JsonNodeOptions> options);
    [System.Text.Json.NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(ulong value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<ulong> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(JsonElement value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<JsonElement> value, Nullable`1<JsonNodeOptions> options);
    [RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed. Use the overload that takes a JsonTypeInfo, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
public static JsonValue Create(T value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(T value, JsonTypeInfo`1<T> jsonTypeInfo, Nullable`1<JsonNodeOptions> options);
    internal virtual void GetPath(List`1<string> path, JsonNode child);
    public abstract virtual bool TryGetValue(T& value);
    private static void VerifyJsonElementIsNotArrayOrObject(JsonElement& element);
}
[DebuggerDisplayAttribute("{ToJsonString(),nq}")]
[DebuggerTypeProxyAttribute("System.Text.Json.Nodes.JsonValue`1/DebugView")]
internal abstract class System.Text.Json.Nodes.JsonValue`1 : JsonValue {
    public TValue _value;
    public TValue Value { get; }
    public JsonValue`1(TValue value, Nullable`1<JsonNodeOptions> options);
    public TValue get_Value();
    public virtual T GetValue();
    public virtual bool TryGetValue(T& value);
    internal TypeToConvert ConvertJsonElement();
    internal bool TryConvertJsonElement(TypeToConvert& result);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Nodes.JsonValueNotTrimmable`1 : JsonValue`1<TValue> {
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public JsonValueNotTrimmable`1(TValue value, Nullable`1<JsonNodeOptions> options);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
internal class System.Text.Json.Nodes.JsonValueTrimmable`1 : JsonValue`1<TValue> {
    private JsonTypeInfo`1<TValue> _jsonTypeInfo;
    private JsonConverter`1<TValue> _converter;
    public JsonValueTrimmable`1(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo, Nullable`1<JsonNodeOptions> options);
    public JsonValueTrimmable`1(TValue value, JsonConverter`1<TValue> converter, Nullable`1<JsonNodeOptions> options);
    public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
internal enum System.Text.Json.NumericType : Enum {
    public int value__;
    public static NumericType Byte;
    public static NumericType SByte;
    public static NumericType Int16;
    public static NumericType Int32;
    public static NumericType Int64;
    public static NumericType UInt16;
    public static NumericType UInt32;
    public static NumericType UInt64;
    public static NumericType Single;
    public static NumericType Double;
    public static NumericType Decimal;
}
internal enum System.Text.Json.PolymorphicSerializationState : Enum {
    public byte value__;
    public static PolymorphicSerializationState None;
    public static PolymorphicSerializationState PolymorphicReEntryStarted;
    public static PolymorphicSerializationState PolymorphicReEntrySuspended;
    public static PolymorphicSerializationState PolymorphicReEntryNotFound;
}
internal class System.Text.Json.PooledByteBufferWriter : object {
    private Byte[] _rentedBuffer;
    private int _index;
    private static int MinimumBufferSize;
    public ReadOnlyMemory`1<byte> WrittenMemory { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public PooledByteBufferWriter(int initialCapacity);
    public ReadOnlyMemory`1<byte> get_WrittenMemory();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public void ClearAndReturnBuffers();
    private void ClearHelper();
    public sealed virtual void Dispose();
    public void InitializeEmptyInstance(int initialCapacity);
    public static PooledByteBufferWriter CreateEmptyInstanceForCaching();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    internal Task WriteToStreamAsync(Stream destination, CancellationToken cancellationToken);
    internal void WriteToStream(Stream destination);
    private void CheckAndResizeBuffer(int sizeHint);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.ReadStack : ValueType {
    internal static Char[] SpecialCharacters;
    public ReadStackFrame Current;
    private ReadStackFrame[] _stack;
    private int _count;
    private int _continuationCount;
    private List`1<ArgumentState> _ctorArgStateCache;
    public long BytesConsumed;
    public bool ReadAhead;
    public ReferenceResolver ReferenceResolver;
    public bool SupportContinuation;
    public string ReferenceId;
    public object PolymorphicTypeDiscriminator;
    public bool PreserveReferences;
    public bool IsContinuation { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private static ReadStack();
    public bool get_IsContinuation();
    private void EnsurePushCapacity();
    internal void Initialize(JsonTypeInfo jsonTypeInfo, bool supportContinuation);
    public void Push();
    public void Pop(bool success);
    public JsonConverter InitializePolymorphicReEntry(JsonTypeInfo derivedJsonTypeInfo);
    public JsonConverter ResumePolymorphicReEntry();
    public void ExitPolymorphicConverter(bool success);
    public string JsonPath();
    public JsonTypeInfo GetTopJsonTypeInfoWithParameterizedConstructor();
    private void SetConstructorArgumentState();
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
internal static void <JsonPath>g__AppendStackFrame|22_0(StringBuilder sb, ReadStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static int <JsonPath>g__GetCount|22_1(IEnumerable enumerable);
    [CompilerGeneratedAttribute]
internal static void <JsonPath>g__AppendPropertyName|22_2(StringBuilder sb, string propertyName);
    [CompilerGeneratedAttribute]
internal static string <JsonPath>g__GetPropertyName|22_3(ReadStackFrame& frame);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.ReadStackFrame : ValueType {
    public JsonPropertyInfo JsonPropertyInfo;
    public StackFramePropertyState PropertyState;
    public bool UseExtensionProperty;
    public Byte[] JsonPropertyName;
    public string JsonPropertyNameAsString;
    public object DictionaryKey;
    public object ReturnValue;
    public JsonTypeInfo JsonTypeInfo;
    public StackFrameObjectState ObjectState;
    public bool CanContainMetadata;
    public MetadataPropertyName LatestMetadataPropertyName;
    public MetadataPropertyName MetadataPropertyNames;
    public PolymorphicSerializationState PolymorphicSerializationState;
    public JsonTypeInfo PolymorphicJsonTypeInfo;
    public int PropertyIndex;
    public List`1<PropertyRef> PropertyRefCache;
    public int CtorArgumentStateIndex;
    public ArgumentState CtorArgumentState;
    public Nullable`1<JsonNumberHandling> NumberHandling;
    public BitArray RequiredPropertiesSet;
    public JsonTypeInfo BaseJsonTypeInfo { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public JsonTypeInfo get_BaseJsonTypeInfo();
    public void EndConstructorParameter();
    public void EndProperty();
    public void EndElement();
    public bool IsProcessingDictionary();
    public bool IsProcessingEnumerable();
    public void MarkRequiredPropertyAsRead(JsonPropertyInfo propertyInfo);
    internal void InitializeRequiredPropertiesValidationState(JsonTypeInfo typeInfo);
    internal void ValidateAllRequiredPropertiesAreRead(JsonTypeInfo typeInfo);
    private string get_DebuggerDisplay();
}
[ExtensionAttribute]
internal static class System.Text.Json.Reflection.ReflectionExtensions : object {
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    public static string CreateRangeMethodName;
    private static Type s_nullableType;
    private static ReflectionExtensions();
    [ExtensionAttribute]
public static Type GetCompatibleGenericBaseClass(Type type, Type baseType, bool sourceGenType);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
public static Type GetCompatibleGenericInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool IsImmutableDictionaryType(Type type, bool sourceGenType);
    [ExtensionAttribute]
public static bool IsImmutableEnumerableType(Type type, bool sourceGenType);
    [ExtensionAttribute]
public static string GetImmutableDictionaryConstructingTypeName(Type type, bool sourceGenType);
    [ExtensionAttribute]
public static string GetImmutableEnumerableConstructingTypeName(Type type, bool sourceGenType);
    private static bool OpenGenericTypesHaveSamePrefix(Type t1, Type t2);
    private static string GetBaseNameFromGenericType(Type genericType, bool sourceGenType);
    private static string GetBaseNameFromGenericTypeDef(Type genericTypeDef);
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static bool IsKeyValuePair(Type type, Type keyValuePairType);
    [ExtensionAttribute]
public static bool TryGetDeserializationConstructor(Type type, bool useDefaultCtorInAnnotatedStructs, ConstructorInfo& deserializationCtor);
    [ExtensionAttribute]
public static object GetDefaultValue(ParameterInfo parameterInfo);
    [ExtensionAttribute]
public static bool IsNullableOfT(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFromInternal(Type type, Type from);
    [ExtensionAttribute]
public static bool IsInSubtypeRelationshipWith(Type type, Type other);
    private static bool HasJsonConstructorAttribute(ConstructorInfo constructorInfo);
    [ExtensionAttribute]
public static bool HasRequiredMemberAttribute(ICustomAttributeProvider memberInfo);
    [ExtensionAttribute]
public static bool HasSetsRequiredMembersAttribute(ICustomAttributeProvider memberInfo);
    [ExtensionAttribute]
private static bool HasCustomAttributeWithName(ICustomAttributeProvider memberInfo, string fullName, bool inherit);
    [ExtensionAttribute]
public static TAttribute GetUniqueCustomAttribute(MemberInfo memberInfo, bool inherit);
    [ExtensionAttribute]
public static object CreateInstanceNoWrapExceptions(Type type, Type[] parameterTypes, Object[] parameters);
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Text.Json.Serialization.ConfigurationList`1 : object {
    protected List`1<TItem> _list;
    protected bool IsImmutable { get; }
    public TItem Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ConfigurationList`1(IList`1<TItem> source);
    protected abstract virtual bool get_IsImmutable();
    protected abstract virtual void VerifyMutable();
    protected virtual void OnAddingElement(TItem item);
    public sealed virtual TItem get_Item(int index);
    public sealed virtual void set_Item(int index, TItem value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TItem item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual void CopyTo(TItem[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    public sealed virtual int IndexOf(TItem item);
    public sealed virtual void Insert(int index, TItem item);
    public sealed virtual bool Remove(TItem item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Text.Json.Serialization.Converters.ArrayConverter`2 : IEnumerableDefaultConverter`2<TElement[], TElement> {
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal virtual bool get_CanHaveMetadata();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TElement[] array, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.BooleanConverter : JsonConverter`1<bool> {
    public virtual bool Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, bool value, JsonSerializerOptions options);
    internal virtual bool ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, bool value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.ByteArrayConverter : JsonConverter`1<Byte[]> {
    public virtual Byte[] Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Byte[] value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ByteConverter : JsonConverter`1<byte> {
    public virtual byte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, byte value, JsonSerializerOptions options);
    internal virtual byte ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, byte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual byte ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, byte value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.CastingConverter`2 : JsonConverter`1<T> {
    private JsonConverter`1<TSource> _sourceConverter;
    internal Type KeyType { get; }
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    internal ConverterStrategy ConverterStrategy { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal JsonConverter SourceConverterForCastingConverter { get; }
    internal CastingConverter`2(JsonConverter`1<TSource> sourceConverter);
    internal virtual Type get_KeyType();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual ConverterStrategy get_ConverterStrategy();
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal virtual JsonConverter get_SourceConverterForCastingConverter();
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    public virtual T ReadAsPropertyName(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual T ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual T ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling);
    private static T CastOnRead(TSource source);
    private static TSource CastOnWrite(T source);
    [CompilerGeneratedAttribute]
internal static void <CastOnRead>g__HandleFailure|24_0(TSource source);
}
internal class System.Text.Json.Serialization.Converters.CharConverter : JsonConverter`1<char> {
    private static int MaxEscapedCharacterLength;
    public virtual char Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, char value, JsonSerializerOptions options);
    internal virtual char ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, char value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.ConcurrentQueueOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
}
internal class System.Text.Json.Serialization.Converters.ConcurrentStackOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
}
internal class System.Text.Json.Serialization.Converters.DateTimeConverter : JsonConverter`1<DateTime> {
    public virtual DateTime Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options);
    internal virtual DateTime ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.DateTimeOffsetConverter : JsonConverter`1<DateTimeOffset> {
    public virtual DateTimeOffset Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options);
    internal virtual DateTimeOffset ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.DecimalConverter : JsonConverter`1<decimal> {
    public virtual decimal Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options);
    internal virtual decimal ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual decimal ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, decimal value, JsonNumberHandling handling);
}
internal abstract class System.Text.Json.Serialization.Converters.DictionaryDefaultConverter`3 : JsonDictionaryConverter`3<TDictionary, TKey, TValue> {
    internal bool CanHaveMetadata { get; }
    internal virtual bool get_CanHaveMetadata();
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TCollection, TKey, TValue> {
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DoubleConverter : JsonConverter`1<double> {
    public virtual double Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, double value, JsonSerializerOptions options);
    internal virtual double ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, double value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual double ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, double value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.EnumConverter`1 : JsonConverter`1<T> {
    private static TypeCode s_enumTypeCode;
    private static bool s_isSignedEnum;
    private static string ValueSeparator;
    private EnumConverterOptions _converterOptions;
    private JsonNamingPolicy _namingPolicy;
    private ConcurrentDictionary`2<ulong, JsonEncodedText> _nameCacheForWriting;
    private ConcurrentDictionary`2<string, T> _nameCacheForReading;
    private static int NameCacheSizeSoftLimit;
    public EnumConverter`1(EnumConverterOptions converterOptions, JsonSerializerOptions serializerOptions);
    public EnumConverter`1(EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions serializerOptions);
    private static EnumConverter`1();
    public virtual bool CanConvert(Type type);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual T ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    private static bool TryParseEnumCore(string enumString, JsonSerializerOptions options, T& value);
    private T ReadEnumUsingNamingPolicy(string enumString);
    private static ulong ConvertToUInt64(object value);
    private static bool IsValidIdentifier(string value);
    private static string FormatJsonName(string value, JsonNamingPolicy namingPolicy);
    private static String[] SplitFlagsEnum(string value);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.EnumConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type type);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
    internal static JsonConverter Create(Type enumType, EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions options);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private static Type GetEnumConverterType(Type enumType);
}
[FlagsAttribute]
internal enum System.Text.Json.Serialization.Converters.EnumConverterOptions : Enum {
    public int value__;
    public static EnumConverterOptions AllowStrings;
    public static EnumConverterOptions AllowNumbers;
}
internal class System.Text.Json.Serialization.Converters.FSharpListConverter`2 : IEnumerableDefaultConverter`2<TList, TElement> {
    private Func`2<IEnumerable`1<TElement>, TList> _listConstructor;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpMapConverter`3 : DictionaryDefaultConverter`3<TMap, TKey, TValue> {
    private Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, TMap> _mapConstructor;
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal virtual bool get_CanHaveMetadata();
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpOptionConverter`2 : JsonConverter`1<TOption> {
    private JsonConverter`1<TElement> _elementConverter;
    private Func`2<TOption, TElement> _optionValueGetter;
    private Func`2<TElement, TOption> _optionConstructor;
    private ConverterStrategy _converterStrategy;
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpOptionConverter`2(JsonConverter`1<TElement> elementConverter);
    internal virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TOption& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options, WriteStack& state);
    public virtual void Write(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options);
    public virtual TOption Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpSetConverter`2 : IEnumerableDefaultConverter`2<TSet, TElement> {
    private Func`2<IEnumerable`1<TElement>, TSet> _setConstructor;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
internal class System.Text.Json.Serialization.Converters.FSharpTypeConverterFactory : JsonConverterFactory {
    private ObjectConverterFactory _recordConverterFactory;
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:MakeGenericType")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.FSharpValueOptionConverter`2 : JsonConverter`1<TValueOption> {
    private JsonConverter`1<TElement> _elementConverter;
    private StructGetter`2<TValueOption, TElement> _optionValueGetter;
    private Func`2<TElement, TValueOption> _optionConstructor;
    private ConverterStrategy _converterStrategy;
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpValueOptionConverter`2(JsonConverter`1<TElement> elementConverter);
    internal virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TValueOption& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options, WriteStack& state);
    public virtual void Write(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options);
    public virtual TValueOption Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.GuidConverter : JsonConverter`1<Guid> {
    public virtual Guid Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options);
    internal virtual Guid ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.IAsyncEnumerableOfTConverter`2 : JsonCollectionConverter`2<TAsyncEnumerable, TElement> {
    internal bool SupportsCreateObjectDelegate { get; }
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TAsyncEnumerable& value);
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, WriteStack& state);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.ICollectionOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IDictionaryConverter`1 : JsonDictionaryConverter`3<TDictionary, string, object> {
    protected virtual void Add(string key, Object& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, WriteStack& state);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IEnumerableConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    private bool _isDeserializable;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.IEnumerableConverterFactory : JsonConverterFactory {
    private static IDictionaryConverter`1<IDictionary> s_converterForIDictionary;
    private static IEnumerableConverter`1<IEnumerable> s_converterForIEnumerable;
    private static IListConverter`1<IList> s_converterForIList;
    private static IEnumerableConverterFactory();
    public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Converters.IEnumerableDefaultConverter`2 : JsonCollectionConverter`2<TCollection, TElement> {
    internal bool CanHaveMetadata { get; }
    internal virtual bool get_CanHaveMetadata();
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.IEnumerableOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    private bool _isDeserializable;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IListConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IListOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    protected sealed virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool get_CanHaveMetadata();
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected sealed virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableDictionaryOfTKeyTValueConverterWithReflection`3 : ImmutableDictionaryOfTKeyTValueConverter`3<TCollection, TKey, TValue> {
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableEnumerableOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    protected sealed virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal sealed virtual bool get_CanHaveMetadata();
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected sealed virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ImmutableEnumerableOfTConverterWithReflection`2 : ImmutableEnumerableOfTConverter`2<TCollection, TElement> {
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.Int16Converter : JsonConverter`1<short> {
    public virtual short Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, short value, JsonSerializerOptions options);
    internal virtual short ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, short value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual short ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, short value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.Int32Converter : JsonConverter`1<int> {
    public virtual int Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options);
    internal virtual int ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, int value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual int ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, int value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.Int64Converter : JsonConverter`1<long> {
    public virtual long Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options);
    internal virtual long ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, long value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual long ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, long value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.IReadOnlyDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TDictionary, TKey, TValue> {
    private bool _isDeserializable;
    internal bool SupportsCreateObjectDelegate { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal virtual bool get_SupportsCreateObjectDelegate();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
}
internal class System.Text.Json.Serialization.Converters.ISetOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonArrayConverter : JsonConverter`1<JsonArray> {
    public virtual void Write(Utf8JsonWriter writer, JsonArray value, JsonSerializerOptions options);
    public virtual JsonArray Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public static JsonArray ReadList(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> options);
}
internal class System.Text.Json.Serialization.Converters.JsonDocumentConverter : JsonConverter`1<JsonDocument> {
    public virtual JsonDocument Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonDocument value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonElementConverter : JsonConverter`1<JsonElement> {
    public virtual JsonElement Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonElement value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonMetadataServicesConverter`1 : JsonResumableConverter`1<T> {
    private Func`1<JsonConverter`1<T>> _converterCreator;
    private ConverterStrategy _converterStrategy;
    private JsonConverter`1<T> _converter;
    internal JsonConverter`1<T> Converter { get; }
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type KeyType { get; }
    internal Type ElementType { get; }
    internal bool ConstructorIsParameterized { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal bool CanHaveMetadata { get; }
    public JsonMetadataServicesConverter`1(Func`1<JsonConverter`1<T>> converterCreator, ConverterStrategy converterStrategy);
    public JsonMetadataServicesConverter`1(JsonConverter`1<T> converter);
    internal JsonConverter`1<T> get_Converter();
    internal virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_KeyType();
    internal virtual Type get_ElementType();
    internal virtual bool get_ConstructorIsParameterized();
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal virtual bool get_CanHaveMetadata();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonNodeConverter : JsonConverter`1<JsonNode> {
    private static JsonNodeConverter s_nodeConverter;
    private static JsonArrayConverter s_arrayConverter;
    private static JsonObjectConverter s_objectConverter;
    private static JsonValueConverter s_valueConverter;
    public static JsonNodeConverter Instance { get; }
    public static JsonArrayConverter ArrayConverter { get; }
    public static JsonObjectConverter ObjectConverter { get; }
    public static JsonValueConverter ValueConverter { get; }
    public static JsonNodeConverter get_Instance();
    public static JsonArrayConverter get_ArrayConverter();
    public static JsonObjectConverter get_ObjectConverter();
    public static JsonValueConverter get_ValueConverter();
    public virtual void Write(Utf8JsonWriter writer, JsonNode value, JsonSerializerOptions options);
    public virtual JsonNode Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public static JsonNode Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
}
internal class System.Text.Json.Serialization.Converters.JsonNodeConverterFactory : JsonConverterFactory {
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    public virtual bool CanConvert(Type typeToConvert);
}
internal class System.Text.Json.Serialization.Converters.JsonObjectConverter : JsonConverter`1<JsonObject> {
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
    internal virtual void ReadElementAndSetProperty(object obj, string propertyName, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    public virtual void Write(Utf8JsonWriter writer, JsonObject value, JsonSerializerOptions options);
    public virtual JsonObject Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public static JsonObject ReadObject(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> options);
}
internal class System.Text.Json.Serialization.Converters.JsonValueConverter : JsonConverter`1<JsonValue> {
    public virtual void Write(Utf8JsonWriter writer, JsonValue value, JsonSerializerOptions options);
    public virtual JsonValue Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.KeyValuePairConverter`2 : SmallObjectWithParameterizedConstructorConverter`5<KeyValuePair`2<TKey, TValue>, TKey, TValue, object, object> {
    private static ConstructorInfo s_constructorInfo;
    private static KeyValuePairConverter`2();
}
internal class System.Text.Json.Serialization.Converters.LargeObjectWithParameterizedConstructorConverter`1 : ObjectWithParameterizedConstructorConverter`1<T> {
    protected sealed virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    protected sealed virtual object CreateObject(ReadStackFrame& frame);
    protected sealed virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.LargeObjectWithParameterizedConstructorConverterWithReflection`1 : LargeObjectWithParameterizedConstructorConverter`1<T> {
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ListOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.NullableConverter`1 : JsonConverter`1<Nullable`1<T>> {
    [CompilerGeneratedAttribute]
private ConverterStrategy <ConverterStrategy>k__BackingField;
    private JsonConverter`1<T> _elementConverter;
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    public bool HandleNull { get; }
    public NullableConverter`1(JsonConverter`1<T> elementConverter);
    [CompilerGeneratedAttribute]
internal virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Nullable`1& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, Nullable`1<T> value, JsonSerializerOptions options, WriteStack& state);
    public virtual Nullable`1<T> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Nullable`1<T> value, JsonSerializerOptions options);
    internal virtual Nullable`1<T> ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling numberHandling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, Nullable`1<T> value, JsonNumberHandling handling);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.NullableConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    public static JsonConverter CreateValueConverter(Type valueTypeToConvert, JsonConverter valueConverter);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private static Type GetNullableConverterType(Type valueTypeToConvert);
}
internal class System.Text.Json.Serialization.Converters.ObjectConverter : JsonConverter`1<object> {
    internal ConverterStrategy ConverterStrategy { get; }
    internal virtual ConverterStrategy get_ConverterStrategy();
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal virtual object ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.ObjectConverterFactory : JsonConverterFactory {
    private bool _useDefaultConstructorInUnannotatedStructs;
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public ObjectConverterFactory(bool useDefaultConstructorInUnannotatedStructs);
    public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    private static JsonConverter CreateKeyValuePairConverter(Type type);
}
internal class System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1 : JsonObjectConverter`1<T> {
    internal bool CanHaveMetadata { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal virtual bool get_CanHaveMetadata();
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    protected static void ReadPropertyValue(object obj, ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo, bool useExtensionProperty);
    protected static bool ReadAheadPropertyValue(ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo);
}
internal abstract class System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter`1 : ObjectDefaultConverter`1<T> {
    internal bool ConstructorIsParameterized { get; }
    internal sealed virtual bool get_ConstructorIsParameterized();
    internal sealed virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    protected abstract virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
    protected abstract virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    protected abstract virtual object CreateObject(ReadStackFrame& frame);
    private void ReadConstructorArguments(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    private bool ReadConstructorArgumentsWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    private bool HandleConstructorArgumentWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    private static bool HandlePropertyWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo);
    private void BeginRead(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    protected virtual bool TryLookupConstructorParameter(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options, JsonParameterInfo& jsonParameterInfo);
}
internal class System.Text.Json.Serialization.Converters.QueueOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.SByteConverter : JsonConverter`1<sbyte> {
    public virtual sbyte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options);
    internal virtual sbyte ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual sbyte ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, sbyte value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.SingleConverter : JsonConverter`1<float> {
    public virtual float Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, float value, JsonSerializerOptions options);
    internal virtual float ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, float value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual float ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, float value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.SmallObjectWithParameterizedConstructorConverter`5 : ObjectWithParameterizedConstructorConverter`1<T> {
    protected virtual object CreateObject(ReadStackFrame& frame);
    protected virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    private static bool TryRead(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo, TArg& arg);
    protected virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StackOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StackOrQueueConverter`1 : JsonCollectionConverter`2<TCollection, object> {
    protected sealed virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected sealed virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected sealed virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.StackOrQueueConverterWithReflection`1 : StackOrQueueConverter`1<TCollection> {
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StringConverter : JsonConverter`1<string> {
    public virtual string Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options);
    internal virtual string ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, string value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
}
internal class System.Text.Json.Serialization.Converters.TimeSpanConverter : JsonConverter`1<TimeSpan> {
    private static int MinimumTimeSpanFormatLength;
    private static int MaximumTimeSpanFormatLength;
    private static int MaximumEscapedTimeSpanFormatLength;
    public virtual TimeSpan Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.UInt16Converter : JsonConverter`1<ushort> {
    public virtual ushort Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options);
    internal virtual ushort ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual ushort ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ushort value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UInt32Converter : JsonConverter`1<UInt32> {
    public virtual UInt32 Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options);
    internal virtual UInt32 ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual UInt32 ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, UInt32 value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UInt64Converter : JsonConverter`1<ulong> {
    public virtual ulong Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options);
    internal virtual ulong ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual ulong ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ulong value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UnsupportedTypeConverter`1 : JsonConverter`1<T> {
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Converters.UnsupportedTypeConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type type);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.UriConverter : JsonConverter`1<Uri> {
    public virtual Uri Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.VersionConverter : JsonConverter`1<Version> {
    public virtual Version Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Version value, JsonSerializerOptions options);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.IAsyncEnumerableConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    private static Type GetAsyncEnumerableInterface(Type type);
}
[ExtensionAttribute]
internal static class System.Text.Json.Serialization.IEnumerableConverterFactoryHelpers : object {
    internal static string ImmutableConvertersUnreferencedCodeMessage;
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public static MethodInfo GetImmutableEnumerableCreateRangeMethod(Type type, Type elementType);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public static MethodInfo GetImmutableDictionaryCreateRangeMethod(Type type, Type keyType, Type valueType);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static Type GetImmutableEnumerableConstructingType(Type type);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static Type GetImmutableDictionaryConstructingType(Type type);
    [ExtensionAttribute]
public static bool IsNonGenericStackOrQueue(Type type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2057:TypeGetType")]
private static Type GetTypeIfExists(string name);
}
internal class System.Text.Json.Serialization.IgnoreReferenceHandler : ReferenceHandler {
    public virtual ReferenceResolver CreateResolver();
}
internal class System.Text.Json.Serialization.IgnoreReferenceResolver : ReferenceResolver {
    private Stack`1<ReferenceEqualsWrapper> _stackForCycleDetection;
    internal virtual void PopReferenceForCycleDetection();
    internal virtual bool ContainsReferenceForCycleDetection(object value);
    internal virtual void PushReferenceForCycleDetection(object value);
    public virtual void AddReference(string referenceId, object value);
    public virtual string GetReference(object value, Boolean& alreadyExists);
    public virtual object ResolveReference(string referenceId);
}
internal interface System.Text.Json.Serialization.IJsonOnDeserialized {
    public abstract virtual void OnDeserialized();
}
internal interface System.Text.Json.Serialization.IJsonOnDeserializing {
    public abstract virtual void OnDeserializing();
}
internal interface System.Text.Json.Serialization.IJsonOnSerialized {
    public abstract virtual void OnSerialized();
}
internal interface System.Text.Json.Serialization.IJsonOnSerializing {
    public abstract virtual void OnSerializing();
}
internal abstract class System.Text.Json.Serialization.JsonAttribute : Attribute {
}
internal abstract class System.Text.Json.Serialization.JsonCollectionConverter`2 : JsonResumableConverter`1<TCollection> {
    internal bool SupportsCreateObjectDelegate { get; }
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal sealed virtual ConverterStrategy get_ConverterStrategy();
    internal virtual Type get_ElementType();
    protected abstract virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected static JsonConverter`1<TElement> GetElementConverter(JsonTypeInfo elementTypeInfo);
    protected static JsonConverter`1<TElement> GetElementConverter(WriteStack& state);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TCollection& value);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    protected abstract virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
[AttributeUsageAttribute("32")]
internal class System.Text.Json.Serialization.JsonConstructorAttribute : JsonAttribute {
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
internal abstract class System.Text.Json.Serialization.JsonConverter : object {
    [CompilerGeneratedAttribute]
private bool <CanUseDirectReadOrWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBePolymorphic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresReadAhead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInternalConverter>k__BackingField;
    internal bool IsInternalConverterForNumberType;
    [CompilerGeneratedAttribute]
private bool <ConstructorIsParameterized>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ConstructorInfo>k__BackingField;
    internal ConverterStrategy ConverterStrategy { get; }
    internal bool SupportsCreateObjectDelegate { get; }
    internal bool CanUseDirectReadOrWrite { get; internal set; }
    internal bool CanHaveMetadata { get; }
    internal bool CanBePolymorphic { get; internal set; }
    internal bool RequiresReadAhead { get; internal set; }
    internal Type ElementType { get; }
    internal Type KeyType { get; }
    internal bool IsValueType { get; internal set; }
    internal bool IsInternalConverter { get; internal set; }
    [System.Text.Json.NullableAttribute("1")]
internal Type TypeToConvert { get; }
    internal bool ConstructorIsParameterized { get; }
    internal ConstructorInfo ConstructorInfo { get; internal set; }
    [System.Text.Json.NullableContextAttribute("1")]
public abstract virtual bool CanConvert(Type typeToConvert);
    internal abstract virtual ConverterStrategy get_ConverterStrategy();
    internal virtual bool get_SupportsCreateObjectDelegate();
    [CompilerGeneratedAttribute]
internal bool get_CanUseDirectReadOrWrite();
    [CompilerGeneratedAttribute]
internal void set_CanUseDirectReadOrWrite(bool value);
    internal virtual bool get_CanHaveMetadata();
    [CompilerGeneratedAttribute]
internal bool get_CanBePolymorphic();
    [CompilerGeneratedAttribute]
internal void set_CanBePolymorphic(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequiresReadAhead();
    [CompilerGeneratedAttribute]
internal void set_RequiresReadAhead(bool value);
    internal virtual void ReadElementAndSetProperty(object obj, string propertyName, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal virtual JsonTypeInfo CreateReflectionJsonTypeInfo(JsonSerializerOptions options);
    internal virtual JsonTypeInfo CreateCustomJsonTypeInfo(JsonSerializerOptions options);
    internal abstract virtual JsonParameterInfo CreateJsonParameterInfo();
    internal abstract virtual JsonConverter`1<TTarget> CreateCastingConverter();
    internal abstract virtual Type get_ElementType();
    internal abstract virtual Type get_KeyType();
    [CompilerGeneratedAttribute]
internal bool get_IsValueType();
    [CompilerGeneratedAttribute]
internal void set_IsValueType(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsInternalConverter();
    [CompilerGeneratedAttribute]
internal void set_IsInternalConverter(bool value);
    internal abstract virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal static bool ShouldFlush(Utf8JsonWriter writer, WriteStack& state);
    internal abstract virtual Type get_TypeToConvert();
    internal abstract virtual bool OnTryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal abstract virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal abstract virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal abstract virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal abstract virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    [CompilerGeneratedAttribute]
internal virtual bool get_ConstructorIsParameterized();
    [CompilerGeneratedAttribute]
internal ConstructorInfo get_ConstructorInfo();
    [CompilerGeneratedAttribute]
internal void set_ConstructorInfo(ConstructorInfo value);
    internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options);
    internal JsonConverter ResolvePolymorphicConverter(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, ReadStack& state);
    internal JsonConverter ResolvePolymorphicConverter(object value, JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, WriteStack& state);
    internal bool TryHandleSerializedObjectReference(Utf8JsonWriter writer, object value, JsonSerializerOptions options, JsonConverter polymorphicConverter, WriteStack& state);
    internal static bool SingleValueReadWithReadAhead(bool requiresReadAhead, Utf8JsonReader& reader, ReadStack& state);
    internal static bool DoSingleValueReadWithReadAhead(Utf8JsonReader& reader, ReadStack& state);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
internal abstract class System.Text.Json.Serialization.JsonConverter`1 : JsonConverter {
    [CompilerGeneratedAttribute]
private bool <HandleNullOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandleNullOnWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeToConvert>k__BackingField;
    internal ConverterStrategy ConverterStrategy { get; }
    [System.Text.Json.NullableAttribute("2")]
internal JsonConverter SourceConverterForCastingConverter { get; }
    [System.Text.Json.NullableAttribute("2")]
internal Type KeyType { get; }
    [System.Text.Json.NullableAttribute("2")]
internal Type ElementType { get; }
    public bool HandleNull { get; }
    internal bool HandleNullOnRead { get; private set; }
    internal bool HandleNullOnWrite { get; private set; }
    internal Type TypeToConvert { get; }
    internal JsonConverter`1(bool initialize);
    internal sealed virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal T ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal bool WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state);
    private protected void Initialize();
    public virtual bool CanConvert(Type typeToConvert);
    internal virtual ConverterStrategy get_ConverterStrategy();
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal sealed virtual JsonTypeInfo CreateReflectionJsonTypeInfo(JsonSerializerOptions options);
    internal sealed virtual JsonTypeInfo CreateCustomJsonTypeInfo(JsonSerializerOptions options);
    internal sealed virtual JsonParameterInfo CreateJsonParameterInfo();
    internal sealed virtual JsonConverter`1<TTarget> CreateCastingConverter();
    internal virtual JsonConverter get_SourceConverterForCastingConverter();
    internal virtual Type get_KeyType();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    [CompilerGeneratedAttribute]
internal bool get_HandleNullOnRead();
    [CompilerGeneratedAttribute]
private void set_HandleNullOnRead(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HandleNullOnWrite();
    [CompilerGeneratedAttribute]
private void set_HandleNullOnWrite(bool value);
    internal sealed virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    public abstract virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal bool TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal sealed virtual bool OnTryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    private static bool IsNull(T value);
    internal bool TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state);
    internal bool TryWriteDataExtensionProperty(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    [CompilerGeneratedAttribute]
internal sealed virtual Type get_TypeToConvert();
    internal void VerifyRead(JsonTokenType tokenType, int depth, long bytesConsumed, bool isValueConverter, Utf8JsonReader& reader);
    internal void VerifyWrite(int originalDepth, Utf8JsonWriter writer);
    public abstract virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public virtual T ReadAsPropertyName(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal virtual T ReadAsPropertyNameCore(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal sealed virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal virtual T ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling, JsonSerializerOptions options);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[AttributeUsageAttribute("1436")]
internal class System.Text.Json.Serialization.JsonConverterAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    [System.Text.Json.NullableAttribute("2")]
[DynamicallyAccessedMembersAttribute("1")]
public Type ConverterType { get; private set; }
    public JsonConverterAttribute(Type converterType);
    [System.Text.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
private void set_ConverterType(Type value);
    public virtual JsonConverter CreateConverter(Type typeToConvert);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
internal abstract class System.Text.Json.Serialization.JsonConverterFactory : JsonConverter {
    internal ConverterStrategy ConverterStrategy { get; }
    [System.Text.Json.NullableAttribute("2")]
internal Type KeyType { get; }
    [System.Text.Json.NullableAttribute("2")]
internal Type ElementType { get; }
    internal Type TypeToConvert { get; }
    internal sealed virtual ConverterStrategy get_ConverterStrategy();
    public abstract virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    internal virtual JsonParameterInfo CreateJsonParameterInfo();
    internal sealed virtual Type get_KeyType();
    internal sealed virtual Type get_ElementType();
    internal JsonConverter GetConverterInternal(Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool OnTryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual Type get_TypeToConvert();
    internal sealed virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);
    internal sealed virtual JsonConverter`1<TTarget> CreateCastingConverter();
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
internal class System.Text.Json.Serialization.JsonDerivedTypeAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private Type <DerivedType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TypeDiscriminator>k__BackingField;
    public Type DerivedType { get; }
    [System.Text.Json.NullableAttribute("2")]
public object TypeDiscriminator { get; }
    public JsonDerivedTypeAttribute(Type derivedType);
    public JsonDerivedTypeAttribute(Type derivedType, string typeDiscriminator);
    public JsonDerivedTypeAttribute(Type derivedType, int typeDiscriminator);
    [CompilerGeneratedAttribute]
public Type get_DerivedType();
    [System.Text.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_TypeDiscriminator();
}
internal abstract class System.Text.Json.Serialization.JsonDictionaryConverter`1 : JsonResumableConverter`1<TDictionary> {
    internal bool SupportsCreateObjectDelegate { get; }
    internal ConverterStrategy ConverterStrategy { get; }
    internal virtual bool get_SupportsCreateObjectDelegate();
    internal sealed virtual ConverterStrategy get_ConverterStrategy();
    protected internal abstract virtual bool OnWriteResume(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, WriteStack& state);
}
internal abstract class System.Text.Json.Serialization.JsonDictionaryConverter`3 : JsonDictionaryConverter`1<TDictionary> {
    protected JsonConverter`1<TKey> _keyConverter;
    protected JsonConverter`1<TValue> _valueConverter;
    internal Type ElementType { get; }
    internal Type KeyType { get; }
    protected abstract virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    internal virtual Type get_ElementType();
    internal virtual Type get_KeyType();
    protected static JsonConverter`1<T> GetConverter(JsonTypeInfo typeInfo);
    internal sealed virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TDictionary& value);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, WriteStack& state);
    [CompilerGeneratedAttribute]
internal static TKey <OnTryRead>g__ReadDictionaryKey|10_0(JsonConverter`1<TKey> keyConverter, Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
[AttributeUsageAttribute("384")]
internal class System.Text.Json.Serialization.JsonExtensionDataAttribute : JsonAttribute {
}
[AttributeUsageAttribute("384")]
internal class System.Text.Json.Serialization.JsonIgnoreAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonIgnoreCondition <Condition>k__BackingField;
    public JsonIgnoreCondition Condition { get; public set; }
    [CompilerGeneratedAttribute]
public JsonIgnoreCondition get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(JsonIgnoreCondition value);
}
internal enum System.Text.Json.Serialization.JsonIgnoreCondition : Enum {
    public int value__;
    public static JsonIgnoreCondition Never;
    public static JsonIgnoreCondition Always;
    public static JsonIgnoreCondition WhenWritingDefault;
    public static JsonIgnoreCondition WhenWritingNull;
}
[AttributeUsageAttribute("384")]
internal class System.Text.Json.Serialization.JsonIncludeAttribute : JsonAttribute {
}
internal enum System.Text.Json.Serialization.JsonKnownNamingPolicy : Enum {
    public int value__;
    public static JsonKnownNamingPolicy Unspecified;
    public static JsonKnownNamingPolicy CamelCase;
}
[FlagsAttribute]
internal enum System.Text.Json.Serialization.JsonNumberHandling : Enum {
    public int value__;
    public static JsonNumberHandling Strict;
    public static JsonNumberHandling AllowReadingFromString;
    public static JsonNumberHandling WriteAsString;
    public static JsonNumberHandling AllowNamedFloatingPointLiterals;
}
[AttributeUsageAttribute("396")]
internal class System.Text.Json.Serialization.JsonNumberHandlingAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonNumberHandling <Handling>k__BackingField;
    public JsonNumberHandling Handling { get; }
    public JsonNumberHandlingAttribute(JsonNumberHandling handling);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_Handling();
}
internal abstract class System.Text.Json.Serialization.JsonObjectConverter`1 : JsonResumableConverter`1<T> {
    internal ConverterStrategy ConverterStrategy { get; }
    internal Type ElementType { get; }
    internal sealed virtual ConverterStrategy get_ConverterStrategy();
    internal sealed virtual Type get_ElementType();
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
internal class System.Text.Json.Serialization.JsonPolymorphicAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <TypeDiscriminatorPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonUnknownDerivedTypeHandling <UnknownDerivedTypeHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnrecognizedTypeDiscriminators>k__BackingField;
    public string TypeDiscriminatorPropertyName { get; public set; }
    public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; public set; }
    public bool IgnoreUnrecognizedTypeDiscriminators { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TypeDiscriminatorPropertyName();
    [CompilerGeneratedAttribute]
public void set_TypeDiscriminatorPropertyName(string value);
    [CompilerGeneratedAttribute]
public JsonUnknownDerivedTypeHandling get_UnknownDerivedTypeHandling();
    [CompilerGeneratedAttribute]
public void set_UnknownDerivedTypeHandling(JsonUnknownDerivedTypeHandling value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreUnrecognizedTypeDiscriminators();
    [CompilerGeneratedAttribute]
public void set_IgnoreUnrecognizedTypeDiscriminators(bool value);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[AttributeUsageAttribute("384")]
internal class System.Text.Json.Serialization.JsonPropertyNameAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public JsonPropertyNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[AttributeUsageAttribute("384")]
internal class System.Text.Json.Serialization.JsonPropertyOrderAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; }
    public JsonPropertyOrderAttribute(int order);
    [CompilerGeneratedAttribute]
public int get_Order();
}
[AttributeUsageAttribute("384")]
internal class System.Text.Json.Serialization.JsonRequiredAttribute : JsonAttribute {
}
internal abstract class System.Text.Json.Serialization.JsonResumableConverter`1 : JsonConverter`1<T> {
    public bool HandleNull { get; }
    public sealed virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public sealed virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public sealed virtual bool get_HandleNull();
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
[AttributeUsageAttribute("4")]
internal class System.Text.Json.Serialization.JsonSerializableAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <TypeInfoPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSourceGenerationMode <GenerationMode>k__BackingField;
    public string TypeInfoPropertyName { get; public set; }
    public JsonSourceGenerationMode GenerationMode { get; public set; }
    [System.Text.Json.NullableContextAttribute("1")]
public JsonSerializableAttribute(Type type);
    [CompilerGeneratedAttribute]
public string get_TypeInfoPropertyName();
    [CompilerGeneratedAttribute]
public void set_TypeInfoPropertyName(string value);
    [CompilerGeneratedAttribute]
public JsonSourceGenerationMode get_GenerationMode();
    [CompilerGeneratedAttribute]
public void set_GenerationMode(JsonSourceGenerationMode value);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
internal abstract class System.Text.Json.Serialization.JsonSerializerContext : object {
    private Nullable`1<bool> _canUseSerializationLogic;
    private JsonSerializerOptions _options;
    public JsonSerializerOptions Options { get; internal set; }
    internal bool CanUseSerializationLogic { get; }
    [System.Text.Json.NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    [System.Text.Json.NullableContextAttribute("2")]
protected JsonSerializerContext(JsonSerializerOptions options);
    public JsonSerializerOptions get_Options();
    internal void set_Options(JsonSerializerOptions value);
    internal bool get_CanUseSerializationLogic();
    [System.Text.Json.NullableContextAttribute("2")]
protected abstract virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    public abstract virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
[FlagsAttribute]
internal enum System.Text.Json.Serialization.JsonSourceGenerationMode : Enum {
    public int value__;
    public static JsonSourceGenerationMode Default;
    public static JsonSourceGenerationMode Metadata;
    public static JsonSourceGenerationMode Serialization;
}
[AttributeUsageAttribute("4")]
internal class System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonIgnoreCondition <DefaultIgnoreCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreReadOnlyFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreReadOnlyProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeFields>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonKnownNamingPolicy <PropertyNamingPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteIndented>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSourceGenerationMode <GenerationMode>k__BackingField;
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IncludeFields { get; public set; }
    public JsonKnownNamingPolicy PropertyNamingPolicy { get; public set; }
    public bool WriteIndented { get; public set; }
    public JsonSourceGenerationMode GenerationMode { get; public set; }
    [CompilerGeneratedAttribute]
public JsonIgnoreCondition get_DefaultIgnoreCondition();
    [CompilerGeneratedAttribute]
public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreReadOnlyFields();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnlyFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreReadOnlyProperties();
    [CompilerGeneratedAttribute]
public void set_IgnoreReadOnlyProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeFields();
    [CompilerGeneratedAttribute]
public void set_IncludeFields(bool value);
    [CompilerGeneratedAttribute]
public JsonKnownNamingPolicy get_PropertyNamingPolicy();
    [CompilerGeneratedAttribute]
public void set_PropertyNamingPolicy(JsonKnownNamingPolicy value);
    [CompilerGeneratedAttribute]
public bool get_WriteIndented();
    [CompilerGeneratedAttribute]
public void set_WriteIndented(bool value);
    [CompilerGeneratedAttribute]
public JsonSourceGenerationMode get_GenerationMode();
    [CompilerGeneratedAttribute]
public void set_GenerationMode(JsonSourceGenerationMode value);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[RequiresDynamicCodeAttribute("JsonStringEnumConverter cannot be statically analyzed and requires runtime code generation. Consider authoring a custom converter that is not a factory to work around the issue. See https://github.com/dotnet/runtime/issues/73124.")]
internal class System.Text.Json.Serialization.JsonStringEnumConverter : JsonConverterFactory {
    private JsonNamingPolicy _namingPolicy;
    private EnumConverterOptions _converterOptions;
    [System.Text.Json.NullableContextAttribute("2")]
public JsonStringEnumConverter(JsonNamingPolicy namingPolicy, bool allowIntegerValues);
    public sealed virtual bool CanConvert(Type typeToConvert);
    public sealed virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal enum System.Text.Json.Serialization.JsonUnknownDerivedTypeHandling : Enum {
    public int value__;
    public static JsonUnknownDerivedTypeHandling FailSerialization;
    public static JsonUnknownDerivedTypeHandling FallBackToBaseType;
    public static JsonUnknownDerivedTypeHandling FallBackToNearestAncestor;
}
internal enum System.Text.Json.Serialization.JsonUnknownTypeHandling : Enum {
    public int value__;
    public static JsonUnknownTypeHandling JsonElement;
    public static JsonUnknownTypeHandling JsonNode;
}
internal class System.Text.Json.Serialization.Metadata.CustomJsonTypeInfo`1 : JsonTypeInfo`1<T> {
    internal CustomJsonTypeInfo`1(JsonConverter converter, JsonSerializerOptions options);
    internal virtual JsonParameterInfoValues[] GetParameterInfoValues();
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
internal class System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver : object {
    private static Dictionary`2<Type, JsonConverter> s_defaultSimpleConverters;
    private static JsonConverterFactory[] s_defaultFactoryConverters;
    private bool _mutable;
    private ModifierCollection _modifiers;
    private static DefaultJsonTypeInfoResolver s_defaultInstance;
    public IList`1<Action`1<JsonTypeInfo>> Modifiers { get; }
    internal static bool IsDefaultInstanceRooted { get; }
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private DefaultJsonTypeInfoResolver(bool mutable);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonConverterFactory[] GetDefaultFactoryConverters();
    private static Dictionary`2<Type, JsonConverter> GetDefaultSimpleConverters();
    private static JsonConverter GetBuiltInConverter(Type typeToConvert);
    internal static bool TryGetDefaultSimpleConverter(Type typeToConvert, JsonConverter& converter);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static JsonConverter GetCustomConverterForMember(Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static JsonConverter GetConverterForType(Type typeToConvert, JsonSerializerOptions options, bool resolveJsonConverterAttribute);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonConverter GetConverterFromAttribute(JsonConverterAttribute converterAttribute, Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
public virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
private static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options);
    public IList`1<Action`1<JsonTypeInfo>> get_Modifiers();
    internal static bool get_IsDefaultInstanceRooted();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal static DefaultJsonTypeInfoResolver RootDefaultInstance();
    [CompilerGeneratedAttribute]
internal static void <GetDefaultSimpleConverters>g__Add|3_0(JsonConverter converter, <>c__DisplayClass3_0& );
}
internal class System.Text.Json.Serialization.Metadata.DefaultValueHolder : object {
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    public object DefaultValue { get; }
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern")]
private DefaultValueHolder(Type type);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    public bool IsDefaultValue(object value);
    public static DefaultValueHolder CreateHolder(Type type);
}
internal class System.Text.Json.Serialization.Metadata.FSharpCoreReflectionProxy : object {
    public static string FSharpCoreUnreferencedCodeMessage;
    private static FSharpCoreReflectionProxy s_singletonInstance;
    private static string CompilationMappingAttributeTypeName;
    private Type _compilationMappingAttributeType;
    private MethodInfo _sourceConstructFlagsGetter;
    private Type _fsharpOptionType;
    private Type _fsharpValueOptionType;
    private Type _fsharpListType;
    private Type _fsharpSetType;
    private Type _fsharpMapType;
    private MethodInfo _fsharpListCtor;
    private MethodInfo _fsharpSetCtor;
    private MethodInfo _fsharpMapCtor;
    public static FSharpCoreReflectionProxy Instance { get; }
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
private FSharpCoreReflectionProxy(Assembly fsharpCoreAssembly);
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public static bool IsFSharpType(Type type);
    public static FSharpCoreReflectionProxy get_Instance();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public FSharpKind DetectFSharpKind(Type type);
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TFSharpOption, T> CreateFSharpOptionValueGetter();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TElement, TFSharpOption> CreateFSharpOptionSomeConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public StructGetter`2<TFSharpValueOption, TElement> CreateFSharpValueOptionValueGetter();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<TElement, TFSharpOption> CreateFSharpValueOptionSomeConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<TElement>, TFSharpList> CreateFSharpListConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<TElement>, TFSharpSet> CreateFSharpSetConstructor();
    [RequiresUnreferencedCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
[RequiresDynamicCodeAttribute("Uses Reflection to access FSharp.Core components at runtime.")]
public Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, TFSharpMap> CreateFSharpMapConstructor();
    private Attribute GetFSharpCompilationMappingAttribute(Type type);
    private SourceConstructFlags GetSourceConstructFlags(Attribute compilationMappingAttribute);
    private static Assembly GetFSharpCoreAssembly(Type type);
    private static TDelegate CreateDelegate(MethodInfo methodInfo);
    private static TMemberInfo EnsureMemberExists(TMemberInfo memberInfo, string memberName);
}
[System.Text.Json.NullableContextAttribute("1")]
internal interface System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver {
    public abstract virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
}
[System.Text.Json.NullableContextAttribute("2")]
[System.Text.Json.NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
internal class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<TCollection> <ObjectCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <KeyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <ElementInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonNumberHandling <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Utf8JsonWriter, TCollection> <SerializeHandler>k__BackingField;
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<TCollection> ObjectCreator { get; public set; }
    public JsonTypeInfo KeyInfo { get; public set; }
    [System.Text.Json.NullableAttribute("1")]
public JsonTypeInfo ElementInfo { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, TCollection> SerializeHandler { get; public set; }
    [CompilerGeneratedAttribute]
public Func`1<TCollection> get_ObjectCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_ObjectCreator(Func`1<TCollection> value);
    [CompilerGeneratedAttribute]
public JsonTypeInfo get_KeyInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_KeyInfo(JsonTypeInfo value);
    [System.Text.Json.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonTypeInfo get_ElementInfo();
    [System.Text.Json.NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_ElementInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_NumberHandling(JsonNumberHandling value);
    [CompilerGeneratedAttribute]
public Action`2<Utf8JsonWriter, TCollection> get_SerializeHandler();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_SerializeHandler(Action`2<Utf8JsonWriter, TCollection> value);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[System.Text.Json.IsReadOnlyAttribute]
internal class System.Text.Json.Serialization.Metadata.JsonDerivedType : ValueType {
    [CompilerGeneratedAttribute]
private Type <DerivedType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TypeDiscriminator>k__BackingField;
    public Type DerivedType { get; }
    [System.Text.Json.NullableAttribute("2")]
public object TypeDiscriminator { get; }
    public JsonDerivedType(Type derivedType);
    public JsonDerivedType(Type derivedType, int typeDiscriminator);
    public JsonDerivedType(Type derivedType, string typeDiscriminator);
    internal JsonDerivedType(Type derivedType, object typeDiscriminator);
    [CompilerGeneratedAttribute]
public Type get_DerivedType();
    [System.Text.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_TypeDiscriminator();
    internal void Deconstruct(Type& derivedType, Object& typeDiscriminator);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
internal static class System.Text.Json.Serialization.Metadata.JsonMetadataServices : object {
    private static JsonConverter`1<bool> s_booleanConverter;
    private static JsonConverter`1<Byte[]> s_byteArrayConverter;
    private static JsonConverter`1<byte> s_byteConverter;
    private static JsonConverter`1<char> s_charConverter;
    private static JsonConverter`1<DateTime> s_dateTimeConverter;
    private static JsonConverter`1<DateTimeOffset> s_dateTimeOffsetConverter;
    private static JsonConverter`1<decimal> s_decimalConverter;
    private static JsonConverter`1<double> s_doubleConverter;
    private static JsonConverter`1<Guid> s_guidConverter;
    private static JsonConverter`1<short> s_int16Converter;
    private static JsonConverter`1<int> s_int32Converter;
    private static JsonConverter`1<long> s_int64Converter;
    private static JsonConverter`1<JsonArray> s_jsonArrayConverter;
    private static JsonConverter`1<JsonElement> s_jsonElementConverter;
    private static JsonConverter`1<JsonNode> s_jsonNodeConverter;
    private static JsonConverter`1<JsonObject> s_jsonObjectConverter;
    private static JsonConverter`1<JsonValue> s_jsonValueConverter;
    private static JsonConverter`1<JsonDocument> s_jsonDocumentConverter;
    private static JsonConverter`1<object> s_objectConverter;
    private static JsonConverter`1<float> s_singleConverter;
    private static JsonConverter`1<sbyte> s_sbyteConverter;
    private static JsonConverter`1<string> s_stringConverter;
    private static JsonConverter`1<TimeSpan> s_timeSpanConverter;
    private static JsonConverter`1<ushort> s_uint16Converter;
    private static JsonConverter`1<UInt32> s_uint32Converter;
    private static JsonConverter`1<ulong> s_uint64Converter;
    private static JsonConverter`1<Uri> s_uriConverter;
    private static JsonConverter`1<Version> s_versionConverter;
    public static JsonConverter`1<bool> BooleanConverter { get; }
    public static JsonConverter`1<Byte[]> ByteArrayConverter { get; }
    public static JsonConverter`1<byte> ByteConverter { get; }
    public static JsonConverter`1<char> CharConverter { get; }
    public static JsonConverter`1<DateTime> DateTimeConverter { get; }
    public static JsonConverter`1<DateTimeOffset> DateTimeOffsetConverter { get; }
    public static JsonConverter`1<decimal> DecimalConverter { get; }
    public static JsonConverter`1<double> DoubleConverter { get; }
    public static JsonConverter`1<Guid> GuidConverter { get; }
    public static JsonConverter`1<short> Int16Converter { get; }
    public static JsonConverter`1<int> Int32Converter { get; }
    public static JsonConverter`1<long> Int64Converter { get; }
    public static JsonConverter`1<JsonArray> JsonArrayConverter { get; }
    public static JsonConverter`1<JsonElement> JsonElementConverter { get; }
    public static JsonConverter`1<JsonNode> JsonNodeConverter { get; }
    public static JsonConverter`1<JsonObject> JsonObjectConverter { get; }
    public static JsonConverter`1<JsonValue> JsonValueConverter { get; }
    public static JsonConverter`1<JsonDocument> JsonDocumentConverter { get; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<object> ObjectConverter { get; }
    public static JsonConverter`1<float> SingleConverter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<sbyte> SByteConverter { get; }
    public static JsonConverter`1<string> StringConverter { get; }
    public static JsonConverter`1<TimeSpan> TimeSpanConverter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<ushort> UInt16Converter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<UInt32> UInt32Converter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<ulong> UInt64Converter { get; }
    public static JsonConverter`1<Uri> UriConverter { get; }
    public static JsonConverter`1<Version> VersionConverter { get; }
    public static JsonTypeInfo`1<TElement[]> CreateArrayInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TElement[]> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateImmutableDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> createRangeFunc);
    public static JsonTypeInfo`1<TCollection> CreateIDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIReadOnlyDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateImmutableEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Func`2<IEnumerable`1<TElement>, TCollection> createRangeFunc);
    public static JsonTypeInfo`1<TCollection> CreateIListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateISetInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateICollectionInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateConcurrentStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateConcurrentQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIAsyncEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    public static JsonTypeInfo`1<TCollection> CreateQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    private static JsonTypeInfo`1<TCollection> CreateStackOrQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    public static JsonTypeInfo`1<TCollection> CreateIEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonConverter`1<bool> get_BooleanConverter();
    public static JsonConverter`1<Byte[]> get_ByteArrayConverter();
    public static JsonConverter`1<byte> get_ByteConverter();
    public static JsonConverter`1<char> get_CharConverter();
    public static JsonConverter`1<DateTime> get_DateTimeConverter();
    public static JsonConverter`1<DateTimeOffset> get_DateTimeOffsetConverter();
    public static JsonConverter`1<decimal> get_DecimalConverter();
    public static JsonConverter`1<double> get_DoubleConverter();
    public static JsonConverter`1<Guid> get_GuidConverter();
    public static JsonConverter`1<short> get_Int16Converter();
    public static JsonConverter`1<int> get_Int32Converter();
    public static JsonConverter`1<long> get_Int64Converter();
    public static JsonConverter`1<JsonArray> get_JsonArrayConverter();
    public static JsonConverter`1<JsonElement> get_JsonElementConverter();
    public static JsonConverter`1<JsonNode> get_JsonNodeConverter();
    public static JsonConverter`1<JsonObject> get_JsonObjectConverter();
    public static JsonConverter`1<JsonValue> get_JsonValueConverter();
    public static JsonConverter`1<JsonDocument> get_JsonDocumentConverter();
    public static JsonConverter`1<object> get_ObjectConverter();
    public static JsonConverter`1<float> get_SingleConverter();
    public static JsonConverter`1<sbyte> get_SByteConverter();
    public static JsonConverter`1<string> get_StringConverter();
    public static JsonConverter`1<TimeSpan> get_TimeSpanConverter();
    public static JsonConverter`1<ushort> get_UInt16Converter();
    public static JsonConverter`1<UInt32> get_UInt32Converter();
    public static JsonConverter`1<ulong> get_UInt64Converter();
    public static JsonConverter`1<Uri> get_UriConverter();
    public static JsonConverter`1<Version> get_VersionConverter();
    public static JsonConverter`1<T> GetUnsupportedTypeConverter();
    public static JsonConverter`1<T> GetEnumConverter(JsonSerializerOptions options);
    [System.Text.Json.NullableContextAttribute("0")]
public static JsonConverter`1<Nullable`1<T>> GetNullableConverter(JsonTypeInfo`1<T> underlyingTypeInfo);
    [System.Text.Json.NullableContextAttribute("0")]
public static JsonConverter`1<Nullable`1<T>> GetNullableConverter(JsonSerializerOptions options);
    internal static JsonConverter`1<T> GetTypedConverter(JsonConverter converter);
    public static JsonPropertyInfo CreatePropertyInfo(JsonSerializerOptions options, JsonPropertyInfoValues`1<T> propertyInfo);
    public static JsonTypeInfo`1<T> CreateObjectInfo(JsonSerializerOptions options, JsonObjectInfoValues`1<T> objectInfo);
    public static JsonTypeInfo`1<T> CreateValueInfo(JsonSerializerOptions options, JsonConverter converter);
}
[EditorBrowsableAttribute("1")]
internal class System.Text.Json.Serialization.Metadata.JsonObjectInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<T> <ObjectCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Object[], T> <ObjectWithParameterizedConstructorCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<JsonSerializerContext, JsonPropertyInfo[]> <PropertyMetadataInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<JsonParameterInfoValues[]> <ConstructorParameterMetadataInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonNumberHandling <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Utf8JsonWriter, T> <SerializeHandler>k__BackingField;
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<T> ObjectCreator { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Object[], T> ObjectWithParameterizedConstructorCreator { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<JsonSerializerContext, JsonPropertyInfo[]> PropertyMetadataInitializer { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<JsonParameterInfoValues[]> ConstructorParameterMetadataInitializer { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, T> SerializeHandler { get; public set; }
    [CompilerGeneratedAttribute]
public Func`1<T> get_ObjectCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_ObjectCreator(Func`1<T> value);
    [CompilerGeneratedAttribute]
public Func`2<Object[], T> get_ObjectWithParameterizedConstructorCreator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_ObjectWithParameterizedConstructorCreator(Func`2<Object[], T> value);
    [CompilerGeneratedAttribute]
public Func`2<JsonSerializerContext, JsonPropertyInfo[]> get_PropertyMetadataInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_PropertyMetadataInitializer(Func`2<JsonSerializerContext, JsonPropertyInfo[]> value);
    [CompilerGeneratedAttribute]
public Func`1<JsonParameterInfoValues[]> get_ConstructorParameterMetadataInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_ConstructorParameterMetadataInitializer(Func`1<JsonParameterInfoValues[]> value);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_NumberHandling(JsonNumberHandling value);
    [CompilerGeneratedAttribute]
public Action`2<Utf8JsonWriter, T> get_SerializeHandler();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_SerializeHandler(Action`2<Utf8JsonWriter, T> value);
}
internal abstract class System.Text.Json.Serialization.Metadata.JsonParameterInfo : object {
    private JsonTypeInfo _jsonTypeInfo;
    [CompilerGeneratedAttribute]
private JsonConverter <ConverterBase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchingPropertyCanBeNull>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNullTokensOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <NameAsUtf8Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    public JsonParameterInfoValues ClrInfo;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <MatchingProperty>k__BackingField;
    public JsonConverter ConverterBase { get; private set; }
    private protected bool MatchingPropertyCanBeNull { get; private set; }
    public object DefaultValue { get; private protected set; }
    public bool IgnoreNullTokensOnRead { get; private set; }
    public JsonSerializerOptions Options { get; public set; }
    public Byte[] NameAsUtf8Bytes { get; private set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; private set; }
    public JsonTypeInfo JsonTypeInfo { get; public set; }
    public Type PropertyType { get; public set; }
    public bool ShouldDeserialize { get; private set; }
    public JsonPropertyInfo MatchingProperty { get; private set; }
    [CompilerGeneratedAttribute]
public JsonConverter get_ConverterBase();
    [CompilerGeneratedAttribute]
private void set_ConverterBase(JsonConverter value);
    [CompilerGeneratedAttribute]
private protected bool get_MatchingPropertyCanBeNull();
    [CompilerGeneratedAttribute]
private void set_MatchingPropertyCanBeNull(bool value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
private protected void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreNullTokensOnRead();
    [CompilerGeneratedAttribute]
private void set_IgnoreNullTokensOnRead(bool value);
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
public Byte[] get_NameAsUtf8Bytes();
    [CompilerGeneratedAttribute]
private void set_NameAsUtf8Bytes(Byte[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
private void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    public JsonTypeInfo get_JsonTypeInfo();
    public void set_JsonTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    [CompilerGeneratedAttribute]
public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public bool get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
private void set_ShouldDeserialize(bool value);
    [CompilerGeneratedAttribute]
public JsonPropertyInfo get_MatchingProperty();
    [CompilerGeneratedAttribute]
private void set_MatchingProperty(JsonPropertyInfo value);
    public virtual void Initialize(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, JsonSerializerOptions options);
    public static JsonParameterInfo CreateIgnoredParameterPlaceholder(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, bool sourceGenMode);
}
internal class System.Text.Json.Serialization.Metadata.JsonParameterInfo`1 : JsonParameterInfo {
    [CompilerGeneratedAttribute]
private T <TypedDefaultValue>k__BackingField;
    public T TypedDefaultValue { get; private set; }
    [CompilerGeneratedAttribute]
public T get_TypedDefaultValue();
    [CompilerGeneratedAttribute]
private void set_TypedDefaultValue(T value);
    public virtual void Initialize(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, JsonSerializerOptions options);
    private void InitializeDefaultValue(JsonPropertyInfo matchingProperty);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
internal class System.Text.Json.Serialization.Metadata.JsonParameterInfoValues : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    public string Name { get; public set; }
    public Type ParameterType { get; public set; }
    public int Position { get; public set; }
    public bool HasDefaultValue { get; public set; }
    [System.Text.Json.NullableAttribute("2")]
public object DefaultValue { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_ParameterType(Type value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_Position(int value);
    [CompilerGeneratedAttribute]
public bool get_HasDefaultValue();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_HasDefaultValue(bool value);
    [System.Text.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_DefaultValue();
    [System.Text.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_DefaultValue(object value);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
internal class System.Text.Json.Serialization.Metadata.JsonPolymorphismOptions : object {
    private DerivedTypeList _derivedTypes;
    private bool _ignoreUnrecognizedTypeDiscriminators;
    private JsonUnknownDerivedTypeHandling _unknownDerivedTypeHandling;
    private string _typeDiscriminatorPropertyName;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <DeclaringTypeInfo>k__BackingField;
    public IList`1<JsonDerivedType> DerivedTypes { get; }
    public bool IgnoreUnrecognizedTypeDiscriminators { get; public set; }
    public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; public set; }
    public string TypeDiscriminatorPropertyName { get; public set; }
    [System.Text.Json.NullableAttribute("2")]
internal JsonTypeInfo DeclaringTypeInfo { get; internal set; }
    public IList`1<JsonDerivedType> get_DerivedTypes();
    public bool get_IgnoreUnrecognizedTypeDiscriminators();
    public void set_IgnoreUnrecognizedTypeDiscriminators(bool value);
    public JsonUnknownDerivedTypeHandling get_UnknownDerivedTypeHandling();
    public void set_UnknownDerivedTypeHandling(JsonUnknownDerivedTypeHandling value);
    public string get_TypeDiscriminatorPropertyName();
    public void set_TypeDiscriminatorPropertyName(string value);
    private void VerifyMutable();
    [CompilerGeneratedAttribute]
internal JsonTypeInfo get_DeclaringTypeInfo();
    [CompilerGeneratedAttribute]
internal void set_DeclaringTypeInfo(JsonTypeInfo value);
    internal static JsonPolymorphismOptions CreateFromAttributeDeclarations(Type baseType);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal abstract class System.Text.Json.Serialization.Metadata.JsonPropertyInfo : object {
    internal static JsonPropertyInfo s_missingProperty;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <ParentTypeInfo>k__BackingField;
    private JsonTypeInfo _jsonTypeInfo;
    [CompilerGeneratedAttribute]
private ConverterStrategy <ConverterStrategy>k__BackingField;
    private protected JsonConverter _effectiveConverter;
    private JsonConverter _customConverter;
    private protected Func`2<object, object> _untypedGet;
    private protected Action`2<object, object> _untypedSet;
    private bool _isUserSpecifiedSetter;
    private protected Func`3<object, object, bool> _shouldSerialize;
    private bool _isUserSpecifiedShouldSerialize;
    private Nullable`1<JsonIgnoreCondition> _ignoreCondition;
    private ICustomAttributeProvider _attributeProvider;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberTypes <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    private bool _isExtensionDataProperty;
    private bool _isRequired;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isConfigured;
    [CompilerGeneratedAttribute]
private bool <IgnoreNullTokensOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDefaultValuesOnWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsForTypeInfo>k__BackingField;
    private string _name;
    [CompilerGeneratedAttribute]
private Byte[] <NameAsUtf8Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EscapedNameSection>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    private int _order;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SrcGen_HasJsonInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SrcGen_IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <DeclaringTypeNumberHandling>k__BackingField;
    private Nullable`1<JsonNumberHandling> _numberHandling;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <EffectiveNumberHandling>k__BackingField;
    private int _index;
    [System.Text.Json.NullableAttribute("2")]
internal JsonTypeInfo ParentTypeInfo { get; private set; }
    internal ConverterStrategy ConverterStrategy { get; private protected set; }
    internal JsonConverter EffectiveConverter { get; }
    [System.Text.Json.NullableAttribute("2")]
public JsonConverter CustomConverter { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> Get { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> Set { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`3<object, object, bool> ShouldSerialize { get; public set; }
    internal Nullable`1<JsonIgnoreCondition> IgnoreCondition { get; internal set; }
    [System.Text.Json.NullableAttribute("2")]
public ICustomAttributeProvider AttributeProvider { get; public set; }
    [System.Text.Json.NullableAttribute("2")]
internal string MemberName { get; private protected set; }
    internal MemberTypes MemberType { get; private protected set; }
    internal bool IsVirtual { get; private set; }
    public bool IsExtensionData { get; public set; }
    public bool IsRequired { get; public set; }
    public Type PropertyType { get; }
    internal bool IsConfigured { get; }
    internal bool HasGetter { get; }
    internal bool HasSetter { get; }
    internal bool IgnoreNullTokensOnRead { get; private protected set; }
    internal bool IgnoreDefaultValuesOnWrite { get; private protected set; }
    internal bool IgnoreReadOnlyMember { get; }
    internal bool IsForTypeInfo { get; internal set; }
    public string Name { get; public set; }
    internal Byte[] NameAsUtf8Bytes { get; internal set; }
    internal Byte[] EscapedNameSection { get; internal set; }
    public JsonSerializerOptions Options { get; }
    public int Order { get; public set; }
    internal Type DeclaringType { get; }
    internal JsonTypeInfo JsonTypeInfo { get; internal set; }
    internal bool IsIgnored { get; }
    internal bool CanSerialize { get; private set; }
    internal bool CanDeserialize { get; private set; }
    internal bool SrcGen_HasJsonInclude { get; internal set; }
    internal bool SrcGen_IsPublic { get; internal set; }
    internal Nullable`1<JsonNumberHandling> DeclaringTypeNumberHandling { get; internal set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    internal Nullable`1<JsonNumberHandling> EffectiveNumberHandling { get; internal set; }
    internal bool PropertyTypeCanBeNull { get; }
    [System.Text.Json.NullableAttribute("2")]
internal object DefaultValue { get; }
    internal int RequiredPropertyIndex { get; internal set; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonPropertyInfo(Type declaringType, Type propertyType, JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options);
    private static JsonPropertyInfo();
    [CompilerGeneratedAttribute]
internal JsonTypeInfo get_ParentTypeInfo();
    [CompilerGeneratedAttribute]
private void set_ParentTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
internal ConverterStrategy get_ConverterStrategy();
    [CompilerGeneratedAttribute]
private protected void set_ConverterStrategy(ConverterStrategy value);
    internal JsonConverter get_EffectiveConverter();
    [System.Text.Json.NullableContextAttribute("2")]
public JsonConverter get_CustomConverter();
    [System.Text.Json.NullableContextAttribute("2")]
public void set_CustomConverter(JsonConverter value);
    public Func`2<object, object> get_Get();
    public void set_Get(Func`2<object, object> value);
    public Action`2<object, object> get_Set();
    public void set_Set(Action`2<object, object> value);
    private protected abstract virtual void SetGetter(Delegate getter);
    private protected abstract virtual void SetSetter(Delegate setter);
    public Func`3<object, object, bool> get_ShouldSerialize();
    public void set_ShouldSerialize(Func`3<object, object, bool> value);
    private protected abstract virtual void SetShouldSerialize(Delegate predicate);
    internal Nullable`1<JsonIgnoreCondition> get_IgnoreCondition();
    internal void set_IgnoreCondition(Nullable`1<JsonIgnoreCondition> value);
    private protected abstract virtual void ConfigureIgnoreCondition(Nullable`1<JsonIgnoreCondition> ignoreCondition);
    [System.Text.Json.NullableContextAttribute("2")]
public ICustomAttributeProvider get_AttributeProvider();
    [System.Text.Json.NullableContextAttribute("2")]
public void set_AttributeProvider(ICustomAttributeProvider value);
    [CompilerGeneratedAttribute]
internal string get_MemberName();
    [CompilerGeneratedAttribute]
private protected void set_MemberName(string value);
    [CompilerGeneratedAttribute]
internal MemberTypes get_MemberType();
    [CompilerGeneratedAttribute]
private protected void set_MemberType(MemberTypes value);
    [CompilerGeneratedAttribute]
internal bool get_IsVirtual();
    [CompilerGeneratedAttribute]
private void set_IsVirtual(bool value);
    public bool get_IsExtensionData();
    public void set_IsExtensionData(bool value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    internal static JsonPropertyInfo GetPropertyPlaceholder();
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    private protected void VerifyMutable();
    internal bool get_IsConfigured();
    internal void EnsureConfigured();
    internal void Configure();
    private protected abstract virtual void DetermineEffectiveConverter(JsonTypeInfo jsonTypeInfo);
    private protected abstract virtual void DetermineMemberAccessors(MemberInfo memberInfo);
    private void DeterminePoliciesFromMember(MemberInfo memberInfo);
    private void DeterminePropertyNameFromMember(MemberInfo memberInfo);
    private void CacheNameAsUtf8BytesAndEscapedNameSection();
    private void DetermineIgnoreCondition();
    private void DetermineSerializationCapabilities();
    private void DetermineNumberHandlingForTypeInfo();
    private void DetermineNumberHandlingForProperty();
    private bool NumberHandingIsApplicable();
    private void DetermineIsRequired(MemberInfo memberInfo, bool shouldCheckForRequiredKeyword);
    internal abstract virtual bool GetMemberAndWriteJson(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal abstract virtual bool GetMemberAndWriteJsonExtensionData(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal abstract virtual object GetValueAsObject(object obj);
    internal bool get_HasGetter();
    internal bool get_HasSetter();
    internal void InitializeUsingMemberReflection(MemberInfo memberInfo, JsonConverter customConverter, Nullable`1<JsonIgnoreCondition> ignoreCondition, bool shouldCheckForRequiredKeyword);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreNullTokensOnRead();
    [CompilerGeneratedAttribute]
private protected void set_IgnoreNullTokensOnRead(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreDefaultValuesOnWrite();
    [CompilerGeneratedAttribute]
private protected void set_IgnoreDefaultValuesOnWrite(bool value);
    internal bool get_IgnoreReadOnlyMember();
    [CompilerGeneratedAttribute]
internal bool get_IsForTypeInfo();
    [CompilerGeneratedAttribute]
internal void set_IsForTypeInfo(bool value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_NameAsUtf8Bytes();
    [CompilerGeneratedAttribute]
internal void set_NameAsUtf8Bytes(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_EscapedNameSection();
    [CompilerGeneratedAttribute]
internal void set_EscapedNameSection(Byte[] value);
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    public int get_Order();
    public void set_Order(int value);
    internal bool ReadJsonAndAddExtensionProperty(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal abstract virtual bool ReadJsonAndSetMember(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal abstract virtual bool ReadJsonAsObject(ReadStack& state, Utf8JsonReader& reader, Object& value);
    internal bool ReadJsonExtensionDataValue(ReadStack& state, Utf8JsonReader& reader, Object& value);
    internal void EnsureChildOf(JsonTypeInfo parent);
    [CompilerGeneratedAttribute]
internal Type get_DeclaringType();
    internal JsonTypeInfo get_JsonTypeInfo();
    internal void set_JsonTypeInfo(JsonTypeInfo value);
    internal bool get_IsIgnored();
    [CompilerGeneratedAttribute]
internal bool get_CanSerialize();
    [CompilerGeneratedAttribute]
private void set_CanSerialize(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SrcGen_HasJsonInclude();
    [CompilerGeneratedAttribute]
internal void set_SrcGen_HasJsonInclude(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SrcGen_IsPublic();
    [CompilerGeneratedAttribute]
internal void set_SrcGen_IsPublic(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<JsonNumberHandling> get_DeclaringTypeNumberHandling();
    [CompilerGeneratedAttribute]
internal void set_DeclaringTypeNumberHandling(Nullable`1<JsonNumberHandling> value);
    public Nullable`1<JsonNumberHandling> get_NumberHandling();
    public void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<JsonNumberHandling> get_EffectiveNumberHandling();
    [CompilerGeneratedAttribute]
internal void set_EffectiveNumberHandling(Nullable`1<JsonNumberHandling> value);
    internal abstract virtual bool get_PropertyTypeCanBeNull();
    internal abstract virtual object get_DefaultValue();
    internal int get_RequiredPropertyIndex();
    internal void set_RequiredPropertyIndex(int value);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private JsonConverter`1<TValue> <ReadJsonAndAddExtensionProperty>g__GetDictionaryValueConverter|126_0();
}
internal class System.Text.Json.Serialization.Metadata.JsonPropertyInfo`1 : JsonPropertyInfo {
    private Func`2<object, T> _typedGet;
    private Action`2<object, T> _typedSet;
    private Func`3<object, T, bool> _shouldSerializeTyped;
    private JsonConverter`1<T> _typedEffectiveConverter;
    internal Func`2<object, T> Get { get; internal set; }
    internal Action`2<object, T> Set { get; internal set; }
    internal Func`3<object, T, bool> ShouldSerialize { get; internal set; }
    internal object DefaultValue { get; }
    internal bool PropertyTypeCanBeNull { get; }
    internal JsonConverter`1<T> EffectiveConverter { get; }
    internal JsonPropertyInfo`1(Type declaringType, JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options);
    internal JsonPropertyInfo`1(JsonPropertyInfoValues`1<T> propertyInfo, JsonSerializerOptions options);
    internal Func`2<object, T> get_Get();
    internal void set_Get(Func`2<object, T> value);
    internal Action`2<object, T> get_Set();
    internal void set_Set(Action`2<object, T> value);
    private protected virtual void SetGetter(Delegate getter);
    private protected virtual void SetSetter(Delegate setter);
    internal Func`3<object, T, bool> get_ShouldSerialize();
    internal void set_ShouldSerialize(Func`3<object, T, bool> value);
    private protected virtual void SetShouldSerialize(Delegate predicate);
    internal virtual object get_DefaultValue();
    internal virtual bool get_PropertyTypeCanBeNull();
    internal JsonConverter`1<T> get_EffectiveConverter();
    private protected virtual void DetermineMemberAccessors(MemberInfo memberInfo);
    private protected virtual void DetermineEffectiveConverter(JsonTypeInfo jsonTypeInfo);
    internal virtual object GetValueAsObject(object obj);
    internal virtual bool GetMemberAndWriteJson(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal virtual bool GetMemberAndWriteJsonExtensionData(object obj, WriteStack& state, Utf8JsonWriter writer);
    internal virtual bool ReadJsonAndSetMember(object obj, ReadStack& state, Utf8JsonReader& reader);
    internal virtual bool ReadJsonAsObject(ReadStack& state, Utf8JsonReader& reader, Object& value);
    private protected virtual void ConfigureIgnoreCondition(Nullable`1<JsonIgnoreCondition> ignoreCondition);
    private static bool IsDefaultValue(T value);
    [CompilerGeneratedAttribute]
internal static bool <ConfigureIgnoreCondition>g__ShouldSerializeIgnoreConditionNever|31_0(object _, T value);
    [CompilerGeneratedAttribute]
internal static bool <ConfigureIgnoreCondition>g__ShouldSerializeIgnoreConditionAlways|31_1(object _, T value);
    [CompilerGeneratedAttribute]
internal static bool <ConfigureIgnoreCondition>g__ShouldSerializeIgnoreWhenWritingDefault|31_2(object _, T value);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
internal class System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfo <PropertyTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter`1<T> <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, T> <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, T> <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonIgnoreCondition> <IgnoreCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasJsonInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtensionData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JsonPropertyName>k__BackingField;
    public bool IsProperty { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsVirtual { get; public set; }
    public Type DeclaringType { get; public set; }
    public JsonTypeInfo PropertyTypeInfo { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public JsonConverter`1<T> Converter { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, T> Getter { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, T> Setter { get; public set; }
    public Nullable`1<JsonIgnoreCondition> IgnoreCondition { get; public set; }
    public bool HasJsonInclude { get; public set; }
    public bool IsExtensionData { get; public set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    public string PropertyName { get; public set; }
    [System.Text.Json.NullableAttribute("2")]
public string JsonPropertyName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsProperty();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_IsProperty(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsVirtual();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_IsVirtual(bool value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public JsonTypeInfo get_PropertyTypeInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_PropertyTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
public JsonConverter`1<T> get_Converter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_Converter(JsonConverter`1<T> value);
    [CompilerGeneratedAttribute]
public Func`2<object, T> get_Getter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_Getter(Func`2<object, T> value);
    [CompilerGeneratedAttribute]
public Action`2<object, T> get_Setter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_Setter(Action`2<object, T> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonIgnoreCondition> get_IgnoreCondition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_IgnoreCondition(Nullable`1<JsonIgnoreCondition> value);
    [CompilerGeneratedAttribute]
public bool get_HasJsonInclude();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_HasJsonInclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExtensionData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_IsExtensionData(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_PropertyName(string value);
    [System.Text.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_JsonPropertyName();
    [System.Text.Json.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.System.Text.Json1722049.IsExternalInit) set_JsonPropertyName(string value);
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal abstract class System.Text.Json.Serialization.Metadata.JsonTypeInfo : object {
    internal static Type ObjectType;
    private static int PropertyNameKeyLength;
    private static int ParameterNameCountCacheThreshold;
    private static int PropertyNameCountCacheThreshold;
    [CompilerGeneratedAttribute]
private int <ParameterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyDictionary`1<JsonParameterInfo> <ParameterCache>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyDictionary`1<JsonPropertyInfo> <PropertyCache>k__BackingField;
    private ParameterRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _parameterRefsSorted;
    private PropertyRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _propertyRefsSorted;
    internal Func`2<JsonSerializerContext, JsonPropertyInfo[]> PropInitFunc;
    internal Func`1<JsonParameterInfoValues[]> CtorParamInitFunc;
    internal static string MetadataFactoryRequiresUnreferencedCode;
    internal static string JsonObjectTypeName;
    private JsonPropertyInfoList _properties;
    [CompilerGeneratedAttribute]
private int <NumberOfRequiredProperties>k__BackingField;
    private Action`1<object> _onSerializing;
    private Action`1<object> _onSerialized;
    private Action`1<object> _onDeserializing;
    private Action`1<object> _onDeserialized;
    private protected Func`1<object> _createObject;
    [CompilerGeneratedAttribute]
private Func`1<object> <CreateObjectForExtensionDataProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private protected JsonPolymorphismOptions _polymorphismOptions;
    [CompilerGeneratedAttribute]
private object <CreateObjectWithArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AddMethodDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <ExtensionDataProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphicTypeResolver <PolymorphicTypeResolver>k__BackingField;
    private JsonTypeInfo _elementTypeInfo;
    [CompilerGeneratedAttribute]
private bool <CanUseSerializeHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MetadataSerializationNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    private JsonTypeInfo _keyTypeInfo;
    [CompilerGeneratedAttribute]
private Type <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonTypeInfoKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <PropertyInfoForTypeInfo>k__BackingField;
    private DefaultValueHolder _defaultValueHolder;
    private Nullable`1<JsonNumberHandling> _numberHandling;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isConfigured;
    private object _configureLock;
    private ExceptionDispatchInfo _cachedConfigureError;
    internal int ParameterCount { get; private set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal JsonPropertyDictionary`1<JsonParameterInfo> ParameterCache { get; private set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal JsonPropertyDictionary`1<JsonPropertyInfo> PropertyCache { get; private protected set; }
    internal int NumberOfRequiredProperties { get; private set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<object> CreateObject { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Func`1<object> CreateObjectForExtensionDataProperty { get; internal set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnSerializing { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnSerialized { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnDeserializing { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnDeserialized { get; public set; }
    public IList`1<JsonPropertyInfo> Properties { get; }
    [System.Text.Json.NullableAttribute("2")]
public JsonPolymorphismOptions PolymorphismOptions { get; public set; }
    public bool IsReadOnly { get; private set; }
    [System.Text.Json.NullableAttribute("2")]
internal object CreateObjectWithArgs { get; internal set; }
    [System.Text.Json.NullableAttribute("2")]
internal object AddMethodDelegate { get; internal set; }
    [System.Text.Json.NullableAttribute("2")]
internal JsonPropertyInfo ExtensionDataProperty { get; private set; }
    [System.Text.Json.NullableAttribute("2")]
internal PolymorphicTypeResolver PolymorphicTypeResolver { get; private set; }
    internal bool CanUseSerializeHandler { get; private protected set; }
    internal bool MetadataSerializationNotSupported { get; private protected set; }
    [System.Text.Json.NullableAttribute("2")]
internal JsonTypeInfo ElementTypeInfo { get; internal set; }
    [System.Text.Json.NullableAttribute("2")]
internal Type ElementType { get; }
    [System.Text.Json.NullableAttribute("2")]
internal JsonTypeInfo KeyTypeInfo { get; internal set; }
    [System.Text.Json.NullableAttribute("2")]
internal Type KeyType { get; }
    public JsonSerializerOptions Options { get; }
    public Type Type { get; }
    public JsonConverter Converter { get; }
    public JsonTypeInfoKind Kind { get; private set; }
    internal JsonPropertyInfo PropertyInfoForTypeInfo { get; }
    internal DefaultValueHolder DefaultValueHolder { get; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    internal bool IsConfigured { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonTypeInfo(Type type, JsonConverter converter, JsonSerializerOptions options);
    private static JsonTypeInfo();
    [CompilerGeneratedAttribute]
internal int get_ParameterCount();
    [CompilerGeneratedAttribute]
private void set_ParameterCount(int value);
    [CompilerGeneratedAttribute]
internal JsonPropertyDictionary`1<JsonParameterInfo> get_ParameterCache();
    [CompilerGeneratedAttribute]
private void set_ParameterCache(JsonPropertyDictionary`1<JsonParameterInfo> value);
    [CompilerGeneratedAttribute]
internal JsonPropertyDictionary`1<JsonPropertyInfo> get_PropertyCache();
    [CompilerGeneratedAttribute]
private protected void set_PropertyCache(JsonPropertyDictionary`1<JsonPropertyInfo> value);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
internal JsonPropertyInfo CreatePropertyUsingReflection(Type propertyType);
    private protected abstract virtual JsonPropertyInfo CreateJsonPropertyInfo(JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options);
    internal JsonPropertyInfo GetProperty(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame, Byte[]& utf8PropertyName);
    internal JsonParameterInfo GetParameter(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame, Byte[]& utf8PropertyName);
    private static bool IsPropertyRefEqual(PropertyRef& propertyRef, ReadOnlySpan`1<byte> propertyName, ulong key);
    private static bool IsParameterRefEqual(ParameterRef& parameterRef, ReadOnlySpan`1<byte> parameterName, ulong key);
    internal static ulong GetKey(ReadOnlySpan`1<byte> name);
    internal void UpdateSortedPropertyCache(ReadStackFrame& frame);
    internal void UpdateSortedParameterCache(ReadStackFrame& frame);
    [CompilerGeneratedAttribute]
internal int get_NumberOfRequiredProperties();
    [CompilerGeneratedAttribute]
private void set_NumberOfRequiredProperties(int value);
    public Func`1<object> get_CreateObject();
    public void set_CreateObject(Func`1<object> value);
    private protected abstract virtual void SetCreateObject(Delegate createObject);
    [CompilerGeneratedAttribute]
internal Func`1<object> get_CreateObjectForExtensionDataProperty();
    [CompilerGeneratedAttribute]
internal void set_CreateObjectForExtensionDataProperty(Func`1<object> value);
    public Action`1<object> get_OnSerializing();
    public void set_OnSerializing(Action`1<object> value);
    public Action`1<object> get_OnSerialized();
    public void set_OnSerialized(Action`1<object> value);
    public Action`1<object> get_OnDeserializing();
    public void set_OnDeserializing(Action`1<object> value);
    public Action`1<object> get_OnDeserialized();
    public void set_OnDeserialized(Action`1<object> value);
    public IList`1<JsonPropertyInfo> get_Properties();
    [System.Text.Json.NullableContextAttribute("2")]
public JsonPolymorphismOptions get_PolymorphismOptions();
    [System.Text.Json.NullableContextAttribute("2")]
public void set_PolymorphismOptions(JsonPolymorphismOptions value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    public void MakeReadOnly();
    [CompilerGeneratedAttribute]
internal object get_CreateObjectWithArgs();
    [CompilerGeneratedAttribute]
internal void set_CreateObjectWithArgs(object value);
    [CompilerGeneratedAttribute]
internal object get_AddMethodDelegate();
    [CompilerGeneratedAttribute]
internal void set_AddMethodDelegate(object value);
    [CompilerGeneratedAttribute]
internal JsonPropertyInfo get_ExtensionDataProperty();
    [CompilerGeneratedAttribute]
private void set_ExtensionDataProperty(JsonPropertyInfo value);
    [CompilerGeneratedAttribute]
internal PolymorphicTypeResolver get_PolymorphicTypeResolver();
    [CompilerGeneratedAttribute]
private void set_PolymorphicTypeResolver(PolymorphicTypeResolver value);
    [CompilerGeneratedAttribute]
internal bool get_CanUseSerializeHandler();
    [CompilerGeneratedAttribute]
private protected void set_CanUseSerializeHandler(bool value);
    [CompilerGeneratedAttribute]
internal bool get_MetadataSerializationNotSupported();
    [CompilerGeneratedAttribute]
private protected void set_MetadataSerializationNotSupported(bool value);
    internal void ValidateCanBeUsedForMetadataSerialization();
    internal JsonTypeInfo get_ElementTypeInfo();
    internal void set_ElementTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
internal Type get_ElementType();
    internal JsonTypeInfo get_KeyTypeInfo();
    internal void set_KeyTypeInfo(JsonTypeInfo value);
    [CompilerGeneratedAttribute]
internal Type get_KeyType();
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public JsonTypeInfoKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(JsonTypeInfoKind value);
    [CompilerGeneratedAttribute]
internal JsonPropertyInfo get_PropertyInfoForTypeInfo();
    private protected abstract virtual JsonPropertyInfo CreatePropertyInfoForTypeInfo();
    internal DefaultValueHolder get_DefaultValueHolder();
    public Nullable`1<JsonNumberHandling> get_NumberHandling();
    public void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    internal void VerifyMutable();
    internal bool get_IsConfigured();
    internal void EnsureConfigured();
    internal void Configure();
    internal virtual void LateAddProperties();
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonTypeInfo`1<T> CreateJsonTypeInfo(JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options);
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public JsonPropertyInfo CreateJsonPropertyInfo(Type propertyType, string name);
    [System.Text.Json1722049.MemberNotNullAttribute("_properties")]
private void PopulatePropertyList();
    internal abstract virtual JsonParameterInfoValues[] GetParameterInfoValues();
    internal void CacheMember(JsonPropertyInfo jsonPropertyInfo, JsonPropertyDictionary`1<JsonPropertyInfo> propertyCache, Dictionary`2& ignoredMembers);
    internal void InitializePropertyCache();
    internal void InitializeConstructorParameters(JsonParameterInfoValues[] jsonParameters, bool sourceGenMode);
    internal static void ValidateType(Type type);
    internal static bool IsInvalidForSerialization(Type type);
    private static bool IsByRefLike(Type type);
    internal static bool IsValidExtensionDataProperty(Type propertyType);
    internal JsonPropertyDictionary`1<JsonPropertyInfo> CreatePropertyCache(int capacity);
    private static JsonParameterInfo CreateConstructorParameter(JsonParameterInfoValues parameterInfo, JsonPropertyInfo jsonPropertyInfo, bool sourceGenMode, JsonSerializerOptions options);
    private static JsonTypeInfoKind GetTypeInfoKind(Type type, ConverterStrategy converterStrategy);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
private void <EnsureConfigured>g__ConfigureLocked|143_0();
}
internal abstract class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1 : JsonTypeInfo {
    private Action`2<Utf8JsonWriter, T> _serialize;
    private Func`1<T> _typedCreateObject;
    [CompilerGeneratedAttribute]
private JsonConverter`1<T> <EffectiveConverter>k__BackingField;
    [System.Text.Json.NullableAttribute("1")]
internal JsonConverter`1<T> EffectiveConverter { get; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<T> CreateObject { get; public set; }
    [System.Text.Json.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[EditorBrowsableAttribute("1")]
public Action`2<Utf8JsonWriter, T> SerializeHandler { get; private protected set; }
    internal JsonTypeInfo`1(JsonConverter converter, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
internal JsonConverter`1<T> get_EffectiveConverter();
    public Func`1<T> get_CreateObject();
    public void set_CreateObject(Func`1<T> value);
    private protected virtual void SetCreateObject(Delegate createObject);
    private protected void SetCreateObjectIfCompatible(Delegate createObject);
    public Action`2<Utf8JsonWriter, T> get_SerializeHandler();
    private protected void set_SerializeHandler(Action`2<Utf8JsonWriter, T> value);
    private protected virtual JsonPropertyInfo CreatePropertyInfoForTypeInfo();
    private protected virtual JsonPropertyInfo CreateJsonPropertyInfo(JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options);
    private protected void PopulatePolymorphismMetadata();
    private protected void MapInterfaceTypesToCallbacks();
}
internal enum System.Text.Json.Serialization.Metadata.JsonTypeInfoKind : Enum {
    public int value__;
    public static JsonTypeInfoKind None;
    public static JsonTypeInfoKind Object;
    public static JsonTypeInfoKind Enumerable;
    public static JsonTypeInfoKind Dictionary;
}
internal static class System.Text.Json.Serialization.Metadata.JsonTypeInfoResolver : object {
    [System.Text.Json.NullableContextAttribute("1")]
public static IJsonTypeInfoResolver Combine(IJsonTypeInfoResolver[] resolvers);
}
internal abstract class System.Text.Json.Serialization.Metadata.MemberAccessor : object {
    public abstract virtual Func`1<object> CreateConstructor(Type classType);
    public abstract virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public abstract virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public abstract virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public abstract virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public abstract virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    public abstract virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public abstract virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    public abstract virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public abstract virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
}
[System.Text.Json.IsReadOnlyAttribute]
internal class System.Text.Json.Serialization.Metadata.ParameterRef : ValueType {
    public ulong Key;
    public JsonParameterInfo Info;
    public Byte[] NameFromJson;
    public ParameterRef(ulong key, JsonParameterInfo info, Byte[] nameFromJson);
}
internal class System.Text.Json.Serialization.Metadata.PolymorphicTypeResolver : object {
    private JsonTypeInfo _declaringTypeInfo;
    private ConcurrentDictionary`2<Type, DerivedJsonTypeInfo> _typeToDiscriminatorId;
    private Dictionary`2<object, DerivedJsonTypeInfo> _discriminatorIdtoType;
    [CompilerGeneratedAttribute]
private JsonUnknownDerivedTypeHandling <UnknownDerivedTypeHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesTypeDiscriminators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnrecognizedTypeDiscriminators>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeDiscriminatorPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <TypeDiscriminatorPropertyNameUtf8>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonEncodedText> <CustomTypeDiscriminatorPropertyNameJsonEncoded>k__BackingField;
    public Type BaseType { get; }
    public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; }
    public bool UsesTypeDiscriminators { get; }
    public bool IgnoreUnrecognizedTypeDiscriminators { get; }
    public string TypeDiscriminatorPropertyName { get; }
    public Byte[] TypeDiscriminatorPropertyNameUtf8 { get; }
    public Nullable`1<JsonEncodedText> CustomTypeDiscriminatorPropertyNameJsonEncoded { get; }
    public PolymorphicTypeResolver(JsonTypeInfo jsonTypeInfo);
    public Type get_BaseType();
    [CompilerGeneratedAttribute]
public JsonUnknownDerivedTypeHandling get_UnknownDerivedTypeHandling();
    [CompilerGeneratedAttribute]
public bool get_UsesTypeDiscriminators();
    [CompilerGeneratedAttribute]
public bool get_IgnoreUnrecognizedTypeDiscriminators();
    [CompilerGeneratedAttribute]
public string get_TypeDiscriminatorPropertyName();
    [CompilerGeneratedAttribute]
public Byte[] get_TypeDiscriminatorPropertyNameUtf8();
    [CompilerGeneratedAttribute]
public Nullable`1<JsonEncodedText> get_CustomTypeDiscriminatorPropertyNameJsonEncoded();
    public bool TryGetDerivedJsonTypeInfo(Type runtimeType, JsonTypeInfo& jsonTypeInfo, Object& typeDiscriminator);
    public bool TryGetDerivedJsonTypeInfo(object typeDiscriminator, JsonTypeInfo& jsonTypeInfo);
    public static bool IsSupportedPolymorphicBaseType(Type type);
    public static bool IsSupportedDerivedType(Type baseType, Type derivedType);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private DerivedJsonTypeInfo CalculateNearestAncestor(Type type);
}
[System.Text.Json.IsReadOnlyAttribute]
internal class System.Text.Json.Serialization.Metadata.PropertyRef : ValueType {
    public ulong Key;
    public JsonPropertyInfo Info;
    public Byte[] NameFromJson;
    public PropertyRef(ulong key, JsonPropertyInfo info, Byte[] nameFromJson);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Metadata.ReflectionEmitCachingMemberAccessor : MemberAccessor {
    private static ReflectionEmitMemberAccessor s_sourceAccessor;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Cache`1<ValueTuple`3<string, Type, MemberInfo>> s_cache;
    private static ReflectionEmitCachingMemberAccessor();
    public static void Clear();
    public virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    public virtual Func`1<object> CreateConstructor(Type classType);
    public virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    public virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
}
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal class System.Text.Json.Serialization.Metadata.ReflectionEmitMemberAccessor : MemberAccessor {
    public virtual Func`1<object> CreateConstructor(Type type);
    public virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    private static DynamicMethod CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    private static DynamicMethod CreateParameterizedConstructor(ConstructorInfo constructor, Type parameterType1, Type parameterType2, Type parameterType3, Type parameterType4);
    public virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    private static DynamicMethod CreateAddMethodDelegate(Type collectionType);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static DynamicMethod CreateImmutableEnumerableCreateRangeDelegate(Type collectionType, Type elementType, Type enumerableType);
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
private static DynamicMethod CreateImmutableDictionaryCreateRangeDelegate(Type collectionType, Type keyType, Type valueType, Type enumerableType);
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    private static DynamicMethod CreatePropertyGetter(PropertyInfo propertyInfo, Type runtimePropertyType);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    private static DynamicMethod CreatePropertySetter(PropertyInfo propertyInfo, Type runtimePropertyType);
    public virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    private static DynamicMethod CreateFieldGetter(FieldInfo fieldInfo, Type runtimeFieldType);
    public virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
    private static DynamicMethod CreateFieldSetter(FieldInfo fieldInfo, Type runtimeFieldType);
    private static DynamicMethod CreateGetterMethod(string memberName, Type memberType);
    private static DynamicMethod CreateSetterMethod(string memberName, Type memberType);
    private static T CreateDelegate(DynamicMethod method);
}
internal class System.Text.Json.Serialization.Metadata.ReflectionJsonTypeInfo`1 : JsonTypeInfo`1<T> {
    [RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
internal ReflectionJsonTypeInfo`1(JsonConverter converter, JsonSerializerOptions options);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:RequiresUnreferencedCode")]
internal virtual void LateAddProperties();
    private void CacheMember(Type typeToConvert, MemberInfo memberInfo, Boolean& propertyOrderSpecified, Dictionary`2& ignoredMembers, bool shouldCheckForRequiredKeyword);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
private JsonPropertyInfo CreateProperty(Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options, bool shouldCheckForRequiredKeyword);
    private static Nullable`1<JsonNumberHandling> GetNumberHandlingForType(Type type);
    private static bool PropertyIsOverriddenAndIgnored(string currentMemberName, Type currentMemberType, bool currentMemberIsVirtual, Dictionary`2<string, JsonPropertyInfo> ignoredMembers);
    internal virtual JsonParameterInfoValues[] GetParameterInfoValues();
}
internal class System.Text.Json.Serialization.Metadata.ReflectionMemberAccessor : MemberAccessor {
    public virtual Func`1<object> CreateConstructor(Type type);
    public virtual Func`2<Object[], T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    [RequiresUnreferencedCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
[RequiresDynamicCodeAttribute("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
public virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    public virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
}
internal class System.Text.Json.Serialization.Metadata.SourceGenJsonTypeInfo`1 : JsonTypeInfo`1<T> {
    public SourceGenJsonTypeInfo`1(JsonConverter converter, JsonSerializerOptions options);
    public SourceGenJsonTypeInfo`1(JsonSerializerOptions options, JsonObjectInfoValues`1<T> objectInfo);
    public SourceGenJsonTypeInfo`1(JsonSerializerOptions options, JsonCollectionInfoValues`1<T> collectionInfo, Func`1<JsonConverter`1<T>> converterCreator, object createObjectWithArgs, object addFunc);
    private static JsonConverter GetConverter(JsonObjectInfoValues`1<T> objectInfo);
    internal virtual JsonParameterInfoValues[] GetParameterInfoValues();
    internal virtual void LateAddProperties();
}
internal class System.Text.Json.Serialization.PreserveReferenceHandler : ReferenceHandler {
    public virtual ReferenceResolver CreateResolver();
    internal virtual ReferenceResolver CreateResolver(bool writing);
}
internal class System.Text.Json.Serialization.PreserveReferenceResolver : ReferenceResolver {
    private UInt32 _referenceCount;
    private Dictionary`2<string, object> _referenceIdToObjectMap;
    private Dictionary`2<object, string> _objectToReferenceIdMap;
    public PreserveReferenceResolver(bool writing);
    public virtual void AddReference(string referenceId, object value);
    public virtual string GetReference(object value, Boolean& alreadyExists);
    public virtual object ResolveReference(string referenceId);
}
internal class System.Text.Json.Serialization.ReadBufferState : ValueType {
    private Byte[] _buffer;
    private byte _offset;
    private int _count;
    private int _maxCount;
    private bool _isFirstBlock;
    private bool _isFinalBlock;
    public bool IsFinalBlock { get; }
    public ReadOnlySpan`1<byte> Bytes { get; }
    public ReadBufferState(int initialBufferSize);
    public bool get_IsFinalBlock();
    public ReadOnlySpan`1<byte> get_Bytes();
    [System.Text.Json.IsReadOnlyAttribute]
[AsyncStateMachineAttribute("System.Text.Json.Serialization.ReadBufferState/<ReadFromStreamAsync>d__11")]
public ValueTask`1<ReadBufferState> ReadFromStreamAsync(Stream utf8Json, CancellationToken cancellationToken, bool fillBuffer);
    public void ReadFromStream(Stream utf8Json);
    public void AdvanceBuffer(int bytesConsumed);
    private void ProcessReadBytes();
    public sealed virtual void Dispose();
}
internal class System.Text.Json.Serialization.ReferenceEqualsWrapper : ValueType {
    private object _object;
    public ReferenceEqualsWrapper(object obj);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReferenceEqualsWrapper obj);
    public virtual int GetHashCode();
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
internal abstract class System.Text.Json.Serialization.ReferenceHandler : object {
    internal ReferenceHandlingStrategy HandlingStrategy;
    [CompilerGeneratedAttribute]
private static ReferenceHandler <Preserve>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReferenceHandler <IgnoreCycles>k__BackingField;
    public static ReferenceHandler Preserve { get; }
    public static ReferenceHandler IgnoreCycles { get; }
    private static ReferenceHandler();
    [CompilerGeneratedAttribute]
public static ReferenceHandler get_Preserve();
    [CompilerGeneratedAttribute]
public static ReferenceHandler get_IgnoreCycles();
    public abstract virtual ReferenceResolver CreateResolver();
    internal virtual ReferenceResolver CreateResolver(bool writing);
}
internal class System.Text.Json.Serialization.ReferenceHandler`1 : ReferenceHandler {
    [System.Text.Json.NullableContextAttribute("1")]
public virtual ReferenceResolver CreateResolver();
}
internal enum System.Text.Json.Serialization.ReferenceHandlingStrategy : Enum {
    public int value__;
    public static ReferenceHandlingStrategy None;
    public static ReferenceHandlingStrategy Preserve;
    public static ReferenceHandlingStrategy IgnoreCycles;
}
[System.Text.Json.NullableContextAttribute("1")]
[System.Text.Json.NullableAttribute("0")]
internal abstract class System.Text.Json.Serialization.ReferenceResolver : object {
    public abstract virtual void AddReference(string referenceId, object value);
    public abstract virtual string GetReference(object value, Boolean& alreadyExists);
    public abstract virtual object ResolveReference(string referenceId);
    internal virtual void PopReferenceForCycleDetection();
    internal virtual void PushReferenceForCycleDetection(object value);
    internal virtual bool ContainsReferenceForCycleDetection(object value);
}
internal enum System.Text.Json.StackFrameObjectState : Enum {
    public byte value__;
    public static StackFrameObjectState None;
    public static StackFrameObjectState StartToken;
    public static StackFrameObjectState ReadMetadata;
    public static StackFrameObjectState ConstructorArguments;
    public static StackFrameObjectState CreatedObject;
    public static StackFrameObjectState ReadElements;
    public static StackFrameObjectState EndToken;
    public static StackFrameObjectState EndTokenValidation;
}
internal enum System.Text.Json.StackFramePropertyState : Enum {
    public byte value__;
    public static StackFramePropertyState None;
    public static StackFramePropertyState ReadName;
    public static StackFramePropertyState Name;
    public static StackFramePropertyState ReadValue;
    public static StackFramePropertyState ReadValueIsEnd;
    public static StackFramePropertyState TryRead;
}
internal static class System.Text.Json.ThrowHelper : object {
    public static string ExceptionSourceValueToRethrowAsJsonException;
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowOutOfMemoryException_BufferMaximumSizeExceeded(UInt32 capacity);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentNullException(string parameterName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException_MaxDepthMustBePositive(string parameterName);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(string parameterName, string message);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException_CommentEnumMustBeInRange(string parameterName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentOutOfRangeException_ArrayIndexNegative(string paramName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_ArrayTooSmall(string paramName);
    private static ArgumentException GetArgumentException(string message);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException(string message);
    public static InvalidOperationException GetInvalidOperationException_CallFlushFirst(int _buffered);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_DestinationTooShort();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_PropertyNameTooLarge(int tokenLength);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_ValueTooLarge(int tokenLength);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_ValueNotSupported();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NeedLargerSpan();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<byte> propertyName, int currentDepth, int maxDepth);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(int currentDepth, int maxDepth);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(string message);
    private static InvalidOperationException GetInvalidOperationException(string message);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DepthNonZeroOrEmptyJson(int currentDepth);
    private static InvalidOperationException GetInvalidOperationException(int currentDepth);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<char> propertyName, int currentDepth, int maxDepth);
    public static InvalidOperationException GetInvalidOperationException_ExpectedArray(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedObject(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedNumber(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedBoolean(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedString(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedStringComparison(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedComment(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_CannotSkipOnPartial();
    private static InvalidOperationException GetInvalidOperationException(string message, JsonTokenType tokenType);
    private static InvalidOperationException GetInvalidOperationException(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
internal static void ThrowJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(JsonValueKind expectedType, JsonValueKind actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonValueKind actualType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    public static JsonException GetJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    private static bool IsPrintable(byte value);
    internal static string GetPrintableString(byte value);
    private static string GetResourceString(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, string characters);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidCommentValue();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidUTF8(ReadOnlySpan`1<byte> value);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidUTF16(int charAsInt);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ReadInvalidUTF16(int charAsInt);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ReadIncompleteUTF16();
    public static InvalidOperationException GetInvalidOperationException_ReadInvalidUTF8(DecoderFallbackException innerException);
    public static ArgumentException GetArgumentException_ReadInvalidUTF16(EncoderFallbackException innerException);
    public static InvalidOperationException GetInvalidOperationException(string message, Exception innerException);
    public static InvalidOperationException GetInvalidOperationException(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowOutOfMemoryException(UInt32 capacity);
    private static string GetResourceString(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowFormatException();
    public static void ThrowFormatException(NumericType numericType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowFormatException(DataType dataType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExpectedChar(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowObjectDisposedException_Utf8JsonWriter();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowObjectDisposedException_JsonDocument();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_NodeValueNotAllowed(string paramName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_DuplicateKey(string paramName, string propertyName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeAlreadyHasParent();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeCycleDetected();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeElementCannotBeObjectOrArray();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_CollectionIsReadOnly();
    public static NotSupportedException GetNotSupportedException_CollectionIsReadOnly();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_DeserializeWrongType(Type type, object value);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_SerializerDoesNotSupportComments(string paramName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_SerializationNotSupported(Type propertyType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_TypeRequiresAsyncSerialization(Type propertyType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ConstructorMaxOf64Parameters(Type type);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type keyType, JsonConverter converter);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidCastException_DeserializeUnableToAssignValue(Type typeOfValue, Type declaredType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DeserializeUnableToAssignNull(Type declaredType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_SerializationConverterRead(JsonConverter converter);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_SerializationConverterWrite(JsonConverter converter);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_SerializerCycleDetected(int maxDepth);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException(string message);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_CannotSerializeInvalidType(string paramName, Type typeToConvert, Type declaringType, string propertyName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_CannotSerializeInvalidType(Type typeToConvert, Type declaringType, MemberInfo memberInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterNotCompatible(Type converterType, Type type);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ResolverTypeNotCompatible(Type requestedType, Type actualType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ResolverTypeInfoOptionsNotCompatible();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonTypeInfoUsedButTypeInfoResolverNotSet();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(Type classType, MemberInfo memberInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(Type classTypeAttributeIsOn, MemberInfo memberInfo, Type typeToConvert);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerOptionsImmutable(JsonSerializerContext context);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_TypeInfoResolverImmutable();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_TypeInfoImmutable();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_PropertyInfoImmutable();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerPropertyNameConflict(Type type, string propertyName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerPropertyNameNull(JsonPropertyInfo jsonPropertyInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(JsonPropertyInfo jsonPropertyInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonPropertyRequiredAndExtensionData(JsonPropertyInfo jsonPropertyInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_JsonRequiredPropertyMissing(JsonTypeInfo parent, BitArray requiredPropertiesSet);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NamingPolicyReturnNull(JsonNamingPolicy namingPolicy);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsNull(Type converterType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsJsonConverterFactorty(Type converterType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type parentType, string parameterName, string firstMatchName, string secondMatchName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(Type parentType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(string propertyName, JsonPropertyInfo jsonPropertyInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonIncludeOnNonPublicInvalid(string memberName, Type declaringType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_IgnoreConditionOnValueTypeInvalid(string clrPropertyName, Type propertyDeclaringType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(JsonPropertyInfo jsonPropertyInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ConverterCanConvertMultipleTypes(Type runtimePropertyType, JsonConverter jsonConverter);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(ReadOnlySpan`1<byte> propertyName, Utf8JsonReader& reader, ReadStack& state);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(JsonTypeInfoKind kind);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_CreateObjectConverterNotCompatible(Type type);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ReThrowWithPath(ReadStack& state, JsonReaderException ex);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ReThrowWithPath(ReadStack& state, Utf8JsonReader& reader, Exception ex);
    public static void AddJsonExceptionInformation(ReadStack& state, Utf8JsonReader& reader, JsonException ex);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ReThrowWithPath(WriteStack& state, Exception ex);
    public static void AddJsonExceptionInformation(WriteStack& state, JsonException ex);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateAttribute(Type attribute, MemberInfo memberInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType, Type attribute);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(JsonPropertyInfo jsonPropertyInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException(ReadStack& state, Utf8JsonReader& reader, NotSupportedException ex);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException(WriteStack& state, NotSupportedException ex);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DeserializeNoConstructor(Type type, Utf8JsonReader& reader, ReadStack& state);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_CannotPopulateCollection(Type type, Utf8JsonReader& reader, ReadStack& state);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValuesInvalidToken(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceNotFound(string id);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValueWasNotString(JsonTokenType tokenType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValueWasNotString(JsonValueKind valueKind);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataUnexpectedProperty(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataIdIsNotFirstProperty(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataStandaloneValuesProperty(ReadStack& state, ReadOnlySpan`1<byte> propertyName);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(ReadOnlySpan`1<byte> propertyName, ReadStack& state, Utf8JsonReader& reader);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataDuplicateIdFound(string id);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataDuplicateTypeProperty();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidReferenceToValueType(Type propertyType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidPropertyInArrayMetadata(ReadStack& state, Type propertyType, Utf8JsonReader& reader);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataPreservedArrayValuesNotFound(ReadStack& state, Type propertyType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataCannotParsePreservedObjectIntoImmutable(Type propertyType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MetadataReferenceOfTypeCannotBeAssignedToType(string referenceId, Type currentType, Type typeToConvert);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonPropertyInfoIsBoundToDifferentJsonTypeInfo(JsonPropertyInfo propertyInfo);
    [System.Text.Json1722049.DoesNotReturnAttribute]
internal static void ThrowUnexpectedMetadataException(ReadOnlySpan`1<byte> propertyName, Utf8JsonReader& reader, ReadStack& state);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_NoMetadataForType(Type type, IJsonTypeInfoResolver resolver);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ConstructorContainsNullParameterNames(Type declaringType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoMetadataForType(Type type, IJsonTypeInfoResolver resolver);
    public static Exception GetInvalidOperationException_NoMetadataForTypeProperties(IJsonTypeInfoResolver resolver, Type type);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoMetadataForTypeProperties(IJsonTypeInfoResolver resolver, Type type);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NoMetadataForTypeCtorParams(IJsonTypeInfoResolver resolver, Type type);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowMissingMemberException_MissingFSharpCoreMember(string missingFsharpCoreMember);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_BaseConverterDoesNotSupportMetadata(Type derivedType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DerivedConverterDoesNotSupportMetadata(Type derivedType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_RuntimeTypeNotSupported(Type baseType, Type runtimeType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowNotSupportedException_RuntimeTypeDiamondAmbiguity(Type baseType, Type runtimeType, Type derivedType1, Type derivedType2);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_TypeDoesNotSupportPolymorphism(Type baseType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DerivedTypeNotSupported(Type baseType, Type derivedType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DerivedTypeIsAlreadySpecified(Type baseType, Type derivedType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_TypeDicriminatorIdIsAlreadySpecified(Type baseType, object typeDiscriminator);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_InvalidCustomTypeDiscriminatorPropertyName();
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_PolymorphicTypeConfigurationDoesNotSpecifyDerivedTypes(Type baseType);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowJsonException_UnrecognizedTypeDiscriminator(object typeDiscriminator);
    [System.Text.Json1722049.DoesNotReturnAttribute]
public static void ThrowArgumentException_JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo(string parameterName);
}
[System.Text.Json.IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.Utf8JsonReader : ValueType {
    private ReadOnlySpan`1<byte> _buffer;
    private bool _isFinalBlock;
    private bool _isInputSequence;
    private long _lineNumber;
    private long _bytePositionInLine;
    private int _consumed;
    private bool _inObject;
    private bool _isNotPrimitive;
    private JsonTokenType _tokenType;
    private JsonTokenType _previousTokenType;
    private JsonReaderOptions _readerOptions;
    private BitStack _bitStack;
    private long _totalConsumed;
    private bool _isLastSegment;
    private bool _isMultiSegment;
    private bool _trailingCommaBeforeComment;
    private SequencePosition _nextPosition;
    private SequencePosition _currentPosition;
    private ReadOnlySequence`1<byte> _sequence;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<byte> <ValueSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TokenStartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueIsEscaped>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <ValueSequence>k__BackingField;
    private bool IsLastSpan { get; }
    internal ReadOnlySequence`1<byte> OriginalSequence { get; }
    internal ReadOnlySpan`1<byte> OriginalSpan { get; }
    internal int ValueLength { get; }
    public ReadOnlySpan`1<byte> ValueSpan { get; private set; }
    public long BytesConsumed { get; }
    public long TokenStartIndex { get; private set; }
    public int CurrentDepth { get; }
    internal bool IsInArray { get; }
    public JsonTokenType TokenType { get; }
    public bool HasValueSequence { get; private set; }
    public bool ValueIsEscaped { get; private set; }
    public bool IsFinalBlock { get; }
    public ReadOnlySequence`1<byte> ValueSequence { get; private set; }
    public SequencePosition Position { get; }
    public JsonReaderState CurrentState { get; }
    [System.Text.Json.NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [System.Text.Json.NullableAttribute("1")]
private string DebugTokenType { get; }
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, JsonReaderOptions options);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, JsonReaderOptions options);
    private bool get_IsLastSpan();
    internal ReadOnlySequence`1<byte> get_OriginalSequence();
    internal ReadOnlySpan`1<byte> get_OriginalSpan();
    [System.Text.Json.IsReadOnlyAttribute]
internal int get_ValueLength();
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<byte> get_ValueSpan();
    [CompilerGeneratedAttribute]
private void set_ValueSpan(ReadOnlySpan`1<byte> value);
    [System.Text.Json.IsReadOnlyAttribute]
public long get_BytesConsumed();
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TokenStartIndex();
    [CompilerGeneratedAttribute]
private void set_TokenStartIndex(long value);
    [System.Text.Json.IsReadOnlyAttribute]
public int get_CurrentDepth();
    internal bool get_IsInArray();
    [System.Text.Json.IsReadOnlyAttribute]
public JsonTokenType get_TokenType();
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValueSequence();
    [CompilerGeneratedAttribute]
private void set_HasValueSequence(bool value);
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ValueIsEscaped();
    [CompilerGeneratedAttribute]
private void set_ValueIsEscaped(bool value);
    [System.Text.Json.IsReadOnlyAttribute]
public bool get_IsFinalBlock();
    [System.Text.Json.IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_ValueSequence();
    [CompilerGeneratedAttribute]
private void set_ValueSequence(ReadOnlySequence`1<byte> value);
    [System.Text.Json.IsReadOnlyAttribute]
public SequencePosition get_Position();
    [System.Text.Json.IsReadOnlyAttribute]
public JsonReaderState get_CurrentState();
    public bool Read();
    public void Skip();
    private void SkipHelper();
    public bool TrySkip();
    private bool TrySkipHelper();
    [System.Text.Json.IsReadOnlyAttribute]
public bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    [System.Text.Json.IsReadOnlyAttribute]
[System.Text.Json.NullableContextAttribute("2")]
public bool ValueTextEquals(string text);
    [System.Text.Json.IsReadOnlyAttribute]
private bool TextEqualsHelper(ReadOnlySpan`1<byte> otherUtf8Text);
    [System.Text.Json.IsReadOnlyAttribute]
public bool ValueTextEquals(ReadOnlySpan`1<char> text);
    [System.Text.Json.IsReadOnlyAttribute]
private bool CompareToSequence(ReadOnlySpan`1<byte> other);
    [System.Text.Json.IsReadOnlyAttribute]
private bool UnescapeAndCompare(ReadOnlySpan`1<byte> other);
    [System.Text.Json.IsReadOnlyAttribute]
private bool UnescapeSequenceAndCompare(ReadOnlySpan`1<byte> other);
    private static bool IsTokenTypeString(JsonTokenType tokenType);
    [System.Text.Json.IsReadOnlyAttribute]
private bool MatchNotPossible(int charTextLength);
    [System.Text.Json.IsReadOnlyAttribute]
private bool MatchNotPossibleSequence(int charTextLength);
    private void StartObject();
    private void EndObject();
    private void StartArray();
    private void EndArray();
    private void UpdateBitStackOnEndToken();
    private bool ReadSingleSegment();
    private bool HasMoreData();
    private bool HasMoreData(ExceptionResource resource);
    private bool ReadFirstToken(byte first);
    private void SkipWhiteSpace();
    private bool ConsumeValue(byte marker);
    private bool ConsumeLiteral(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteral(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private void ThrowInvalidLiteral(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumber();
    private bool ConsumePropertyName();
    private bool ConsumeString();
    private bool ConsumeStringAndValidate(ReadOnlySpan`1<byte> data, int idx);
    private bool ValidateHexDigits(ReadOnlySpan`1<byte> data, int idx);
    private bool TryGetNumber(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSign(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeZero(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeIntegerDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeSign(ReadOnlySpan`1& data, Int32& i);
    private bool ConsumeNextTokenOrRollback(byte marker);
    private ConsumeTokenResult ConsumeNextToken(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentToken();
    private bool SkipAllComments(Byte& marker);
    private bool SkipAllComments(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkipped(byte marker);
    private bool SkipComment();
    private bool SkipSingleLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private int FindLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private void ThrowOnDangerousLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private bool SkipMultiLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private bool ConsumeComment();
    private bool ConsumeSingleLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private bool ConsumeMultiLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private string get_DebuggerDisplay();
    private string get_DebugTokenType();
    private ReadOnlySpan`1<byte> GetUnescapedSpan();
    private bool ReadMultiSegment();
    private bool ValidateStateAtEndOfData();
    private bool HasMoreDataMultiSegment();
    private bool HasMoreDataMultiSegment(ExceptionResource resource);
    private bool GetNextSpan();
    private bool ReadFirstTokenMultiSegment(byte first);
    private void SkipWhiteSpaceMultiSegment();
    private bool ConsumeValueMultiSegment(byte marker);
    private bool ConsumeLiteralMultiSegment(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteralMultiSegment(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal, Int32& consumed);
    private static int FindMismatch(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private JsonException GetInvalidLiteralMultiSegment(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumberMultiSegment();
    private bool ConsumePropertyNameMultiSegment();
    private bool ConsumeStringMultiSegment();
    private bool ConsumeStringNextSegment();
    private bool ConsumeStringAndValidateMultiSegment(ReadOnlySpan`1<byte> data, int idx);
    private void RollBackState(PartialStateForRollback& state, bool isError);
    private bool TryGetNumberMultiSegment(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeZeroMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeIntegerDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private bool ConsumeNextTokenOrRollbackMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentTokenMultiSegment();
    private bool SkipAllCommentsMultiSegment(Byte& marker);
    private bool SkipAllCommentsMultiSegment(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(byte marker);
    private bool SkipOrConsumeCommentMultiSegmentWithRollback();
    private bool SkipCommentMultiSegment(Int32& tailBytesToIgnore);
    private bool SkipSingleLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& tailBytesToSkip);
    private int FindLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private void ThrowOnDangerousLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private bool SkipMultiLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer);
    private PartialStateForRollback CaptureState();
    [System.Text.Json.NullableContextAttribute("2")]
public string GetString();
    [System.Text.Json.IsReadOnlyAttribute]
public int CopyString(Span`1<byte> utf8Destination);
    [System.Text.Json.IsReadOnlyAttribute]
public int CopyString(Span`1<char> destination);
    [System.Text.Json.IsReadOnlyAttribute]
private bool TryCopyEscapedString(Span`1<byte> destination, Int32& bytesWritten);
    [System.Text.Json.NullableContextAttribute("1")]
public string GetComment();
    public bool GetBoolean();
    [System.Text.Json.NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    public byte GetByte();
    internal byte GetByteWithQuotes();
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    internal sbyte GetSByteWithQuotes();
    public short GetInt16();
    internal short GetInt16WithQuotes();
    public int GetInt32();
    internal int GetInt32WithQuotes();
    public long GetInt64();
    internal long GetInt64WithQuotes();
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    internal ushort GetUInt16WithQuotes();
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    internal UInt32 GetUInt32WithQuotes();
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    internal ulong GetUInt64WithQuotes();
    public float GetSingle();
    internal float GetSingleWithQuotes();
    internal float GetSingleFloatingPointConstant();
    public double GetDouble();
    internal double GetDoubleWithQuotes();
    internal double GetDoubleFloatingPointConstant();
    public decimal GetDecimal();
    internal decimal GetDecimalWithQuotes();
    public DateTime GetDateTime();
    internal DateTime GetDateTimeNoValidation();
    public DateTimeOffset GetDateTimeOffset();
    internal DateTimeOffset GetDateTimeOffsetNoValidation();
    public Guid GetGuid();
    internal Guid GetGuidNoValidation();
    [System.Text.Json.NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    public bool TryGetByte(Byte& value);
    internal static bool TryGetByteCore(Byte& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    internal static bool TryGetSByteCore(SByte& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt16(Int16& value);
    internal static bool TryGetInt16Core(Int16& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt32(Int32& value);
    internal static bool TryGetInt32Core(Int32& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt64(Int64& value);
    internal static bool TryGetInt64Core(Int64& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    internal static bool TryGetUInt16Core(UInt16& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    internal static bool TryGetUInt32Core(UInt32& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    internal static bool TryGetUInt64Core(UInt64& value, ReadOnlySpan`1<byte> span);
    public bool TryGetSingle(Single& value);
    public bool TryGetDouble(Double& value);
    public bool TryGetDecimal(Decimal& value);
    internal static bool TryGetDecimalCore(Decimal& value, ReadOnlySpan`1<byte> span);
    public bool TryGetDateTime(DateTime& value);
    internal bool TryGetDateTimeCore(DateTime& value);
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    internal bool TryGetDateTimeOffsetCore(DateTimeOffset& value);
    public bool TryGetGuid(Guid& value);
    internal bool TryGetGuidCore(Guid& value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.Utf8JsonWriter : object {
    private static int s_newLineLength;
    private static int DefaultGrowthSize;
    private static int InitialGrowthSize;
    private IBufferWriter`1<byte> _output;
    private Stream _stream;
    private ArrayBufferWriter`1<byte> _arrayBufferWriter;
    private Memory`1<byte> _memory;
    private bool _inObject;
    private JsonTokenType _tokenType;
    private BitStack _bitStack;
    private int _currentDepth;
    private JsonWriterOptions _options;
    [CompilerGeneratedAttribute]
private int <BytesPending>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesCommitted>k__BackingField;
    private static Char[] s_singleLineCommentDelimiter;
    public int BytesPending { get; private set; }
    public long BytesCommitted { get; private set; }
    public JsonWriterOptions Options { get; }
    private int Indentation { get; }
    internal JsonTokenType TokenType { get; }
    public int CurrentDepth { get; }
    [System.Text.Json.NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private static ReadOnlySpan`1<byte> SingleLineCommentDelimiterUtf8 { get; }
    [System.Text.Json.NullableContextAttribute("1")]
public Utf8JsonWriter(IBufferWriter`1<byte> bufferWriter, JsonWriterOptions options);
    [System.Text.Json.NullableContextAttribute("1")]
public Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options);
    private static Utf8JsonWriter();
    [CompilerGeneratedAttribute]
public int get_BytesPending();
    [CompilerGeneratedAttribute]
private void set_BytesPending(int value);
    [CompilerGeneratedAttribute]
public long get_BytesCommitted();
    [CompilerGeneratedAttribute]
private void set_BytesCommitted(long value);
    public JsonWriterOptions get_Options();
    private int get_Indentation();
    internal JsonTokenType get_TokenType();
    public int get_CurrentDepth();
    public void Reset();
    [System.Text.Json.NullableContextAttribute("1")]
public void Reset(Stream utf8Json);
    [System.Text.Json.NullableContextAttribute("1")]
public void Reset(IBufferWriter`1<byte> bufferWriter);
    internal void ResetAllStateForCacheReuse();
    internal void Reset(IBufferWriter`1<byte> bufferWriter, JsonWriterOptions options);
    internal static Utf8JsonWriter CreateEmptyInstanceForCaching();
    private void ResetHelper();
    private void CheckNotDisposed();
    public void Flush();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<DisposeAsync>d__41")]
public sealed virtual ValueTask DisposeAsync();
    [System.Text.Json.NullableContextAttribute("1")]
[AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<FlushAsync>d__42")]
public Task FlushAsync(CancellationToken cancellationToken);
    public void WriteStartArray();
    public void WriteStartObject();
    private void WriteStart(byte token);
    private void WriteStartMinimized(byte token);
    private void WriteStartSlow(byte token);
    private void ValidateStart();
    private void WriteStartIndented(byte token);
    public void WriteStartArray(JsonEncodedText propertyName);
    public void WriteStartObject(JsonEncodedText propertyName);
    private void WriteStartHelper(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    public void WriteStartArray(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteStartObject(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStartEscape(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, byte token, int firstEscapeIndexProp);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteStartArray(string propertyName);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteStartObject(string propertyName);
    public void WriteStartArray(ReadOnlySpan`1<char> propertyName);
    public void WriteStartObject(ReadOnlySpan`1<char> propertyName);
    private void WriteStartEscape(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<char> propertyName, byte token, int firstEscapeIndexProp);
    public void WriteEndArray();
    public void WriteEndObject();
    private void WriteEnd(byte token);
    private void WriteEndMinimized(byte token);
    private void WriteEndSlow(byte token);
    private void ValidateEnd(byte token);
    private void WriteEndIndented(byte token);
    private void WriteNewLine(Span`1<byte> output);
    private void UpdateBitStackOnStart(byte token);
    private void Grow(int requiredSize);
    private void FirstCallToGetMemory(int requiredSize);
    private void SetFlagToAddListSeparatorBeforeNextItem();
    private string get_DebuggerDisplay();
    public void WriteBase64String(JsonEncodedText propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(string propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64ByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteString(JsonEncodedText propertyName, DateTime value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    internal void WritePropertyName(DateTime value);
    public void WriteString(JsonEncodedText propertyName, DateTimeOffset value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    internal void WritePropertyName(DateTimeOffset value);
    public void WriteNumber(JsonEncodedText propertyName, decimal value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteNumber(string propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    internal void WritePropertyName(decimal value);
    public void WriteNumber(JsonEncodedText propertyName, double value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteNumber(string propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    internal void WritePropertyName(double value);
    public void WriteNumber(JsonEncodedText propertyName, float value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteNumber(string propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    internal void WritePropertyName(float value);
    internal void WriteNumber(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    public void WriteString(JsonEncodedText propertyName, Guid value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteString(string propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    internal void WritePropertyName(Guid value);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<char> propertyName);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<byte> utf8PropertyName);
    private void ValidateDepth();
    private void ValidateWritingProperty();
    private void ValidateWritingProperty(byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void TranscodeAndWrite(ReadOnlySpan`1<char> escapedPropertyName, Span`1<byte> output);
    public void WriteNull(JsonEncodedText propertyName);
    internal void WriteNullSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WriteLiteralHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteNull(string propertyName);
    public void WriteNull(ReadOnlySpan`1<char> propertyName);
    public void WriteNull(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteBoolean(JsonEncodedText propertyName, bool value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteBoolean(string propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<char> propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<byte> utf8PropertyName, bool value);
    private void WriteLiteralEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralSection(ReadOnlySpan`1<byte> escapedPropertyNameSection, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    internal void WritePropertyName(bool value);
    public void WriteNumber(JsonEncodedText propertyName, long value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteNumber(string propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    public void WriteNumber(JsonEncodedText propertyName, int value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteNumber(string propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, int value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    internal void WritePropertyName(int value);
    internal void WritePropertyName(long value);
    public void WritePropertyName(JsonEncodedText propertyName);
    internal void WritePropertyNameSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WritePropertyNameHelper(ReadOnlySpan`1<byte> utf8PropertyName);
    [System.Text.Json.NullableContextAttribute("1")]
public void WritePropertyName(string propertyName);
    public void WritePropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    public void WritePropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WritePropertyNameUnescaped(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    private void WriteStringPropertyNameSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    public void WriteString(JsonEncodedText propertyName, JsonEncodedText value);
    private void WriteStringHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteString(string propertyName, JsonEncodedText value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteString(string propertyName, string value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    [System.Text.Json.NullableContextAttribute("2")]
public void WriteString(JsonEncodedText propertyName, string value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(string propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(string propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, string value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, string value);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndex);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, ulong value);
    [System.Text.Json.NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, UInt32 value);
    [System.Text.Json.NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, UInt32 value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    internal void WritePropertyName(UInt32 value);
    internal void WritePropertyName(ulong value);
    public void WriteBase64StringValue(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> get_SingleLineCommentDelimiterUtf8();
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteCommentValue(string value);
    public void WriteCommentValue(ReadOnlySpan`1<char> value);
    private void WriteCommentByOptions(ReadOnlySpan`1<char> value);
    private void WriteCommentMinimized(ReadOnlySpan`1<char> value);
    private void WriteCommentIndented(ReadOnlySpan`1<char> value);
    public void WriteCommentValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(DateTime value);
    private void WriteStringValueMinimized(DateTime value);
    private void WriteStringValueIndented(DateTime value);
    public void WriteStringValue(DateTimeOffset value);
    private void WriteStringValueMinimized(DateTimeOffset value);
    private void WriteStringValueIndented(DateTimeOffset value);
    public void WriteNumberValue(decimal value);
    private void WriteNumberValueMinimized(decimal value);
    private void WriteNumberValueIndented(decimal value);
    internal void WriteNumberValueAsString(decimal value);
    public void WriteNumberValue(double value);
    private void WriteNumberValueMinimized(double value);
    private void WriteNumberValueIndented(double value);
    private static bool TryFormatDouble(double value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValueAsString(double value);
    internal void WriteFloatingPointConstant(double value);
    public void WriteNumberValue(float value);
    private void WriteNumberValueMinimized(float value);
    private void WriteNumberValueIndented(float value);
    private static bool TryFormatSingle(float value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValueAsString(float value);
    internal void WriteFloatingPointConstant(float value);
    internal void WriteNumberValue(ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberValueMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteNumberValueIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(Guid value);
    private void WriteStringValueMinimized(Guid value);
    private void WriteStringValueIndented(Guid value);
    private void ValidateWritingValue();
    private void Base64EncodeAndWrite(ReadOnlySpan`1<byte> bytes, Span`1<byte> output, int encodingLength);
    public void WriteNullValue();
    public void WriteBooleanValue(bool value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> utf8Value);
    [System.Text.Json.NullableContextAttribute("1")]
public void WriteRawValue(string json, bool skipInputValidation);
    public void WriteRawValue(ReadOnlySpan`1<char> json, bool skipInputValidation);
    public void WriteRawValue(ReadOnlySpan`1<byte> utf8Json, bool skipInputValidation);
    private void TranscodeAndWriteRawValue(ReadOnlySpan`1<char> json, bool skipInputValidation);
    private void WriteRawValueCore(ReadOnlySpan`1<byte> utf8Json, bool skipInputValidation);
    public void WriteNumberValue(int value);
    public void WriteNumberValue(long value);
    private void WriteNumberValueMinimized(long value);
    private void WriteNumberValueIndented(long value);
    internal void WriteNumberValueAsString(long value);
    public void WriteStringValue(JsonEncodedText value);
    [System.Text.Json.NullableContextAttribute("2")]
public void WriteStringValue(string value);
    public void WriteStringValue(ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<char> value, int firstEscapeIndexVal);
    public void WriteStringValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal);
    internal void WriteNumberValueAsStringUnescaped(ReadOnlySpan`1<byte> utf8Value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(ulong value);
    private void WriteNumberValueMinimized(ulong value);
    private void WriteNumberValueIndented(ulong value);
    internal void WriteNumberValueAsString(ulong value);
}
internal static class System.Text.Json.Utf8JsonWriterCache : object {
    [ThreadStaticAttribute]
private static ThreadLocalState t_threadLocalState;
    public static Utf8JsonWriter RentWriterAndBuffer(JsonSerializerOptions options, PooledByteBufferWriter& bufferWriter);
    public static Utf8JsonWriter RentWriter(JsonSerializerOptions options, PooledByteBufferWriter bufferWriter);
    public static void ReturnWriterAndBuffer(Utf8JsonWriter writer, PooledByteBufferWriter bufferWriter);
    public static void ReturnWriter(Utf8JsonWriter writer);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.WriteStack : ValueType {
    public WriteStackFrame Current;
    private WriteStackFrame[] _stack;
    private int _count;
    private int _continuationCount;
    private byte _indexOffset;
    public CancellationToken CancellationToken;
    public bool SuppressFlush;
    public Task PendingTask;
    public List`1<IAsyncDisposable> CompletedAsyncDisposables;
    public int FlushThreshold;
    public bool IsPolymorphicRootValue;
    public ReferenceResolver ReferenceResolver;
    public bool SupportContinuation;
    public bool SupportAsync;
    public string NewReferenceId;
    public object PolymorphicTypeDiscriminator;
    public int CurrentDepth { get; }
    public WriteStackFrame& Parent { get; }
    public bool IsContinuation { get; }
    public bool CurrentContainsMetadata { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public int get_CurrentDepth();
    public WriteStackFrame& get_Parent();
    public bool get_IsContinuation();
    public bool get_CurrentContainsMetadata();
    private void EnsurePushCapacity();
    internal void Initialize(JsonTypeInfo jsonTypeInfo, bool supportContinuation, bool supportAsync);
    public JsonTypeInfo PeekNestedJsonTypeInfo();
    public void Push();
    public void Pop(bool success);
    public void AddCompletedAsyncDisposable(IAsyncDisposable asyncDisposable);
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<DisposeCompletedAsyncDisposables>d__30")]
public ValueTask DisposeCompletedAsyncDisposables();
    public void DisposePendingDisposablesOnException();
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<DisposePendingDisposablesOnExceptionAsync>d__32")]
public ValueTask DisposePendingDisposablesOnExceptionAsync();
    public string PropertyPath();
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
internal static void <DisposePendingDisposablesOnException>g__DisposeFrame|31_0(IEnumerator collectionEnumerator, Exception& exception);
    [AsyncStateMachineAttribute("System.Text.Json.WriteStack/<<DisposePendingDisposablesOnExceptionAsync>g__DisposeFrame|32_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<Exception> <DisposePendingDisposablesOnExceptionAsync>g__DisposeFrame|32_0(IEnumerator collectionEnumerator, IAsyncDisposable asyncDisposable, Exception exception);
    [CompilerGeneratedAttribute]
internal static void <PropertyPath>g__AppendStackFrame|33_0(StringBuilder sb, WriteStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static void <PropertyPath>g__AppendPropertyName|33_1(StringBuilder sb, string propertyName);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Json.WriteStackFrame : ValueType {
    public IEnumerator CollectionEnumerator;
    public IAsyncDisposable AsyncDisposable;
    public bool AsyncEnumeratorIsPendingCompletion;
    public JsonPropertyInfo JsonPropertyInfo;
    public bool IsWritingExtensionDataProperty;
    public JsonTypeInfo JsonTypeInfo;
    public int OriginalDepth;
    public bool ProcessedStartToken;
    public bool ProcessedEndToken;
    public StackFramePropertyState PropertyState;
    public int EnumeratorIndex;
    public string JsonPropertyNameAsString;
    public MetadataPropertyName MetadataPropertyName;
    public PolymorphicSerializationState PolymorphicSerializationState;
    private JsonPropertyInfo PolymorphicJsonTypeInfo;
    public Nullable`1<JsonNumberHandling> NumberHandling;
    public bool IsPushedReferenceForCycleDetection;
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public void EndCollectionElement();
    public void EndDictionaryEntry();
    public void EndProperty();
    public JsonTypeInfo GetNestedJsonTypeInfo();
    public JsonConverter InitializePolymorphicReEntry(Type runtimeType, JsonSerializerOptions options);
    public JsonConverter InitializePolymorphicReEntry(JsonTypeInfo derivedJsonTypeInfo);
    public JsonConverter ResumePolymorphicReEntry();
    public void ExitPolymorphicConverter(bool success);
    private string get_DebuggerDisplay();
}
[System.Text.Encodings.Web.IsReadOnlyAttribute]
internal class System.Text.Rune : ValueType {
    private static int MaxUtf16CharsPerRune;
    private static char HighSurrogateStart;
    private static char LowSurrogateStart;
    private static int HighSurrogateRange;
    private UInt32 _value;
    public bool IsAscii { get; }
    public bool IsBmp { get; }
    public static Rune ReplacementChar { get; }
    public int Utf16SequenceLength { get; }
    public int Value { get; }
    public Rune(UInt32 value);
    public Rune(int value);
    private Rune(UInt32 scalarValue, bool unused);
    public bool get_IsAscii();
    public bool get_IsBmp();
    public static bool op_Equality(Rune left, Rune right);
    public static bool op_Inequality(Rune left, Rune right);
    public static bool IsControl(Rune value);
    public static Rune get_ReplacementChar();
    public int get_Utf16SequenceLength();
    public int get_Value();
    public static OperationStatus DecodeFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> source, Rune& result, Int32& bytesConsumed);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rune other);
    public virtual int GetHashCode();
    public static bool TryCreate(char ch, Rune& result);
    public static bool TryCreate(char highSurrogate, char lowSurrogate, Rune& result);
    public bool TryEncodeToUtf16(Span`1<char> destination, Int32& charsWritten);
    public bool TryEncodeToUtf8(Span`1<byte> destination, Int32& bytesWritten);
    internal static Rune UnsafeCreate(UInt32 scalarValue);
}
[System.Text.Encodings.Web.IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.System.Text.Encodings.Web1694883.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public System.Text.Encodings.Web1694883.ValueStringBuilder(Span`1<char> initialBuffer);
    public System.Text.Encodings.Web1694883.ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Insert(int index, string s);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
internal static class System.Text.Unicode.UnicodeHelpers : object {
    internal static int UNICODE_LAST_CODEPOINT;
    private static ReadOnlySpan`1<byte> DefinedCharsBitmapSpan { get; }
    internal static ReadOnlySpan`1<byte> GetDefinedBmpCodePointsBitmapLittleEndian();
    internal static void GetUtf16SurrogatePairFromAstralScalarValue(UInt32 scalar, Char& highSurrogate, Char& lowSurrogate);
    internal static int GetUtf8RepresentationForScalarValue(UInt32 scalar);
    internal static bool IsSupplementaryCodePoint(int scalar);
    private static ReadOnlySpan`1<byte> get_DefinedCharsBitmapSpan();
}
internal class System.Text.Unicode.UnicodeRange : object {
    [CompilerGeneratedAttribute]
private int <FirstCodePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int FirstCodePoint { get; private set; }
    public int Length { get; private set; }
    public UnicodeRange(int firstCodePoint, int length);
    [CompilerGeneratedAttribute]
public int get_FirstCodePoint();
    [CompilerGeneratedAttribute]
private void set_FirstCodePoint(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [System.Text.Encodings.Web.NullableContextAttribute("1")]
public static UnicodeRange Create(char firstCharacter, char lastCharacter);
}
[System.Text.Encodings.Web.NullableContextAttribute("1")]
[System.Text.Encodings.Web.NullableAttribute("0")]
internal static class System.Text.Unicode.UnicodeRanges : object {
    private static UnicodeRange _none;
    private static UnicodeRange _all;
    private static UnicodeRange _u0000;
    private static UnicodeRange _u0080;
    private static UnicodeRange _u0100;
    private static UnicodeRange _u0180;
    private static UnicodeRange _u0250;
    private static UnicodeRange _u02B0;
    private static UnicodeRange _u0300;
    private static UnicodeRange _u0370;
    private static UnicodeRange _u0400;
    private static UnicodeRange _u0500;
    private static UnicodeRange _u0530;
    private static UnicodeRange _u0590;
    private static UnicodeRange _u0600;
    private static UnicodeRange _u0700;
    private static UnicodeRange _u0750;
    private static UnicodeRange _u0780;
    private static UnicodeRange _u07C0;
    private static UnicodeRange _u0800;
    private static UnicodeRange _u0840;
    private static UnicodeRange _u0860;
    private static UnicodeRange _u0870;
    private static UnicodeRange _u08A0;
    private static UnicodeRange _u0900;
    private static UnicodeRange _u0980;
    private static UnicodeRange _u0A00;
    private static UnicodeRange _u0A80;
    private static UnicodeRange _u0B00;
    private static UnicodeRange _u0B80;
    private static UnicodeRange _u0C00;
    private static UnicodeRange _u0C80;
    private static UnicodeRange _u0D00;
    private static UnicodeRange _u0D80;
    private static UnicodeRange _u0E00;
    private static UnicodeRange _u0E80;
    private static UnicodeRange _u0F00;
    private static UnicodeRange _u1000;
    private static UnicodeRange _u10A0;
    private static UnicodeRange _u1100;
    private static UnicodeRange _u1200;
    private static UnicodeRange _u1380;
    private static UnicodeRange _u13A0;
    private static UnicodeRange _u1400;
    private static UnicodeRange _u1680;
    private static UnicodeRange _u16A0;
    private static UnicodeRange _u1700;
    private static UnicodeRange _u1720;
    private static UnicodeRange _u1740;
    private static UnicodeRange _u1760;
    private static UnicodeRange _u1780;
    private static UnicodeRange _u1800;
    private static UnicodeRange _u18B0;
    private static UnicodeRange _u1900;
    private static UnicodeRange _u1950;
    private static UnicodeRange _u1980;
    private static UnicodeRange _u19E0;
    private static UnicodeRange _u1A00;
    private static UnicodeRange _u1A20;
    private static UnicodeRange _u1AB0;
    private static UnicodeRange _u1B00;
    private static UnicodeRange _u1B80;
    private static UnicodeRange _u1BC0;
    private static UnicodeRange _u1C00;
    private static UnicodeRange _u1C50;
    private static UnicodeRange _u1C80;
    private static UnicodeRange _u1C90;
    private static UnicodeRange _u1CC0;
    private static UnicodeRange _u1CD0;
    private static UnicodeRange _u1D00;
    private static UnicodeRange _u1D80;
    private static UnicodeRange _u1DC0;
    private static UnicodeRange _u1E00;
    private static UnicodeRange _u1F00;
    private static UnicodeRange _u2000;
    private static UnicodeRange _u2070;
    private static UnicodeRange _u20A0;
    private static UnicodeRange _u20D0;
    private static UnicodeRange _u2100;
    private static UnicodeRange _u2150;
    private static UnicodeRange _u2190;
    private static UnicodeRange _u2200;
    private static UnicodeRange _u2300;
    private static UnicodeRange _u2400;
    private static UnicodeRange _u2440;
    private static UnicodeRange _u2460;
    private static UnicodeRange _u2500;
    private static UnicodeRange _u2580;
    private static UnicodeRange _u25A0;
    private static UnicodeRange _u2600;
    private static UnicodeRange _u2700;
    private static UnicodeRange _u27C0;
    private static UnicodeRange _u27F0;
    private static UnicodeRange _u2800;
    private static UnicodeRange _u2900;
    private static UnicodeRange _u2980;
    private static UnicodeRange _u2A00;
    private static UnicodeRange _u2B00;
    private static UnicodeRange _u2C00;
    private static UnicodeRange _u2C60;
    private static UnicodeRange _u2C80;
    private static UnicodeRange _u2D00;
    private static UnicodeRange _u2D30;
    private static UnicodeRange _u2D80;
    private static UnicodeRange _u2DE0;
    private static UnicodeRange _u2E00;
    private static UnicodeRange _u2E80;
    private static UnicodeRange _u2F00;
    private static UnicodeRange _u2FF0;
    private static UnicodeRange _u3000;
    private static UnicodeRange _u3040;
    private static UnicodeRange _u30A0;
    private static UnicodeRange _u3100;
    private static UnicodeRange _u3130;
    private static UnicodeRange _u3190;
    private static UnicodeRange _u31A0;
    private static UnicodeRange _u31C0;
    private static UnicodeRange _u31F0;
    private static UnicodeRange _u3200;
    private static UnicodeRange _u3300;
    private static UnicodeRange _u3400;
    private static UnicodeRange _u4DC0;
    private static UnicodeRange _u4E00;
    private static UnicodeRange _uA000;
    private static UnicodeRange _uA490;
    private static UnicodeRange _uA4D0;
    private static UnicodeRange _uA500;
    private static UnicodeRange _uA640;
    private static UnicodeRange _uA6A0;
    private static UnicodeRange _uA700;
    private static UnicodeRange _uA720;
    private static UnicodeRange _uA800;
    private static UnicodeRange _uA830;
    private static UnicodeRange _uA840;
    private static UnicodeRange _uA880;
    private static UnicodeRange _uA8E0;
    private static UnicodeRange _uA900;
    private static UnicodeRange _uA930;
    private static UnicodeRange _uA960;
    private static UnicodeRange _uA980;
    private static UnicodeRange _uA9E0;
    private static UnicodeRange _uAA00;
    private static UnicodeRange _uAA60;
    private static UnicodeRange _uAA80;
    private static UnicodeRange _uAAE0;
    private static UnicodeRange _uAB00;
    private static UnicodeRange _uAB30;
    private static UnicodeRange _uAB70;
    private static UnicodeRange _uABC0;
    private static UnicodeRange _uAC00;
    private static UnicodeRange _uD7B0;
    private static UnicodeRange _uF900;
    private static UnicodeRange _uFB00;
    private static UnicodeRange _uFB50;
    private static UnicodeRange _uFE00;
    private static UnicodeRange _uFE10;
    private static UnicodeRange _uFE20;
    private static UnicodeRange _uFE30;
    private static UnicodeRange _uFE50;
    private static UnicodeRange _uFE70;
    private static UnicodeRange _uFF00;
    private static UnicodeRange _uFFF0;
    public static UnicodeRange None { get; }
    public static UnicodeRange All { get; }
    public static UnicodeRange BasicLatin { get; }
    public static UnicodeRange Latin1Supplement { get; }
    public static UnicodeRange LatinExtendedA { get; }
    public static UnicodeRange LatinExtendedB { get; }
    public static UnicodeRange IpaExtensions { get; }
    public static UnicodeRange SpacingModifierLetters { get; }
    public static UnicodeRange CombiningDiacriticalMarks { get; }
    public static UnicodeRange GreekandCoptic { get; }
    public static UnicodeRange Cyrillic { get; }
    public static UnicodeRange CyrillicSupplement { get; }
    public static UnicodeRange Armenian { get; }
    public static UnicodeRange Hebrew { get; }
    public static UnicodeRange Arabic { get; }
    public static UnicodeRange Syriac { get; }
    public static UnicodeRange ArabicSupplement { get; }
    public static UnicodeRange Thaana { get; }
    public static UnicodeRange NKo { get; }
    public static UnicodeRange Samaritan { get; }
    public static UnicodeRange Mandaic { get; }
    public static UnicodeRange SyriacSupplement { get; }
    public static UnicodeRange ArabicExtendedB { get; }
    public static UnicodeRange ArabicExtendedA { get; }
    public static UnicodeRange Devanagari { get; }
    public static UnicodeRange Bengali { get; }
    public static UnicodeRange Gurmukhi { get; }
    public static UnicodeRange Gujarati { get; }
    public static UnicodeRange Oriya { get; }
    public static UnicodeRange Tamil { get; }
    public static UnicodeRange Telugu { get; }
    public static UnicodeRange Kannada { get; }
    public static UnicodeRange Malayalam { get; }
    public static UnicodeRange Sinhala { get; }
    public static UnicodeRange Thai { get; }
    public static UnicodeRange Lao { get; }
    public static UnicodeRange Tibetan { get; }
    public static UnicodeRange Myanmar { get; }
    public static UnicodeRange Georgian { get; }
    public static UnicodeRange HangulJamo { get; }
    public static UnicodeRange Ethiopic { get; }
    public static UnicodeRange EthiopicSupplement { get; }
    public static UnicodeRange Cherokee { get; }
    public static UnicodeRange UnifiedCanadianAboriginalSyllabics { get; }
    public static UnicodeRange Ogham { get; }
    public static UnicodeRange Runic { get; }
    public static UnicodeRange Tagalog { get; }
    public static UnicodeRange Hanunoo { get; }
    public static UnicodeRange Buhid { get; }
    public static UnicodeRange Tagbanwa { get; }
    public static UnicodeRange Khmer { get; }
    public static UnicodeRange Mongolian { get; }
    public static UnicodeRange UnifiedCanadianAboriginalSyllabicsExtended { get; }
    public static UnicodeRange Limbu { get; }
    public static UnicodeRange TaiLe { get; }
    public static UnicodeRange NewTaiLue { get; }
    public static UnicodeRange KhmerSymbols { get; }
    public static UnicodeRange Buginese { get; }
    public static UnicodeRange TaiTham { get; }
    public static UnicodeRange CombiningDiacriticalMarksExtended { get; }
    public static UnicodeRange Balinese { get; }
    public static UnicodeRange Sundanese { get; }
    public static UnicodeRange Batak { get; }
    public static UnicodeRange Lepcha { get; }
    public static UnicodeRange OlChiki { get; }
    public static UnicodeRange CyrillicExtendedC { get; }
    public static UnicodeRange GeorgianExtended { get; }
    public static UnicodeRange SundaneseSupplement { get; }
    public static UnicodeRange VedicExtensions { get; }
    public static UnicodeRange PhoneticExtensions { get; }
    public static UnicodeRange PhoneticExtensionsSupplement { get; }
    public static UnicodeRange CombiningDiacriticalMarksSupplement { get; }
    public static UnicodeRange LatinExtendedAdditional { get; }
    public static UnicodeRange GreekExtended { get; }
    public static UnicodeRange GeneralPunctuation { get; }
    public static UnicodeRange SuperscriptsandSubscripts { get; }
    public static UnicodeRange CurrencySymbols { get; }
    public static UnicodeRange CombiningDiacriticalMarksforSymbols { get; }
    public static UnicodeRange LetterlikeSymbols { get; }
    public static UnicodeRange NumberForms { get; }
    public static UnicodeRange Arrows { get; }
    public static UnicodeRange MathematicalOperators { get; }
    public static UnicodeRange MiscellaneousTechnical { get; }
    public static UnicodeRange ControlPictures { get; }
    public static UnicodeRange OpticalCharacterRecognition { get; }
    public static UnicodeRange EnclosedAlphanumerics { get; }
    public static UnicodeRange BoxDrawing { get; }
    public static UnicodeRange BlockElements { get; }
    public static UnicodeRange GeometricShapes { get; }
    public static UnicodeRange MiscellaneousSymbols { get; }
    public static UnicodeRange Dingbats { get; }
    public static UnicodeRange MiscellaneousMathematicalSymbolsA { get; }
    public static UnicodeRange SupplementalArrowsA { get; }
    public static UnicodeRange BraillePatterns { get; }
    public static UnicodeRange SupplementalArrowsB { get; }
    public static UnicodeRange MiscellaneousMathematicalSymbolsB { get; }
    public static UnicodeRange SupplementalMathematicalOperators { get; }
    public static UnicodeRange MiscellaneousSymbolsandArrows { get; }
    public static UnicodeRange Glagolitic { get; }
    public static UnicodeRange LatinExtendedC { get; }
    public static UnicodeRange Coptic { get; }
    public static UnicodeRange GeorgianSupplement { get; }
    public static UnicodeRange Tifinagh { get; }
    public static UnicodeRange EthiopicExtended { get; }
    public static UnicodeRange CyrillicExtendedA { get; }
    public static UnicodeRange SupplementalPunctuation { get; }
    public static UnicodeRange CjkRadicalsSupplement { get; }
    public static UnicodeRange KangxiRadicals { get; }
    public static UnicodeRange IdeographicDescriptionCharacters { get; }
    public static UnicodeRange CjkSymbolsandPunctuation { get; }
    public static UnicodeRange Hiragana { get; }
    public static UnicodeRange Katakana { get; }
    public static UnicodeRange Bopomofo { get; }
    public static UnicodeRange HangulCompatibilityJamo { get; }
    public static UnicodeRange Kanbun { get; }
    public static UnicodeRange BopomofoExtended { get; }
    public static UnicodeRange CjkStrokes { get; }
    public static UnicodeRange KatakanaPhoneticExtensions { get; }
    public static UnicodeRange EnclosedCjkLettersandMonths { get; }
    public static UnicodeRange CjkCompatibility { get; }
    public static UnicodeRange CjkUnifiedIdeographsExtensionA { get; }
    public static UnicodeRange YijingHexagramSymbols { get; }
    public static UnicodeRange CjkUnifiedIdeographs { get; }
    public static UnicodeRange YiSyllables { get; }
    public static UnicodeRange YiRadicals { get; }
    public static UnicodeRange Lisu { get; }
    public static UnicodeRange Vai { get; }
    public static UnicodeRange CyrillicExtendedB { get; }
    public static UnicodeRange Bamum { get; }
    public static UnicodeRange ModifierToneLetters { get; }
    public static UnicodeRange LatinExtendedD { get; }
    public static UnicodeRange SylotiNagri { get; }
    public static UnicodeRange CommonIndicNumberForms { get; }
    public static UnicodeRange Phagspa { get; }
    public static UnicodeRange Saurashtra { get; }
    public static UnicodeRange DevanagariExtended { get; }
    public static UnicodeRange KayahLi { get; }
    public static UnicodeRange Rejang { get; }
    public static UnicodeRange HangulJamoExtendedA { get; }
    public static UnicodeRange Javanese { get; }
    public static UnicodeRange MyanmarExtendedB { get; }
    public static UnicodeRange Cham { get; }
    public static UnicodeRange MyanmarExtendedA { get; }
    public static UnicodeRange TaiViet { get; }
    public static UnicodeRange MeeteiMayekExtensions { get; }
    public static UnicodeRange EthiopicExtendedA { get; }
    public static UnicodeRange LatinExtendedE { get; }
    public static UnicodeRange CherokeeSupplement { get; }
    public static UnicodeRange MeeteiMayek { get; }
    public static UnicodeRange HangulSyllables { get; }
    public static UnicodeRange HangulJamoExtendedB { get; }
    public static UnicodeRange CjkCompatibilityIdeographs { get; }
    public static UnicodeRange AlphabeticPresentationForms { get; }
    public static UnicodeRange ArabicPresentationFormsA { get; }
    public static UnicodeRange VariationSelectors { get; }
    public static UnicodeRange VerticalForms { get; }
    public static UnicodeRange CombiningHalfMarks { get; }
    public static UnicodeRange CjkCompatibilityForms { get; }
    public static UnicodeRange SmallFormVariants { get; }
    public static UnicodeRange ArabicPresentationFormsB { get; }
    public static UnicodeRange HalfwidthandFullwidthForms { get; }
    public static UnicodeRange Specials { get; }
    public static UnicodeRange get_None();
    public static UnicodeRange get_All();
    private static UnicodeRange CreateEmptyRange(UnicodeRange& range);
    private static UnicodeRange CreateRange(UnicodeRange& range, char first, char last);
    public static UnicodeRange get_BasicLatin();
    public static UnicodeRange get_Latin1Supplement();
    public static UnicodeRange get_LatinExtendedA();
    public static UnicodeRange get_LatinExtendedB();
    public static UnicodeRange get_IpaExtensions();
    public static UnicodeRange get_SpacingModifierLetters();
    public static UnicodeRange get_CombiningDiacriticalMarks();
    public static UnicodeRange get_GreekandCoptic();
    public static UnicodeRange get_Cyrillic();
    public static UnicodeRange get_CyrillicSupplement();
    public static UnicodeRange get_Armenian();
    public static UnicodeRange get_Hebrew();
    public static UnicodeRange get_Arabic();
    public static UnicodeRange get_Syriac();
    public static UnicodeRange get_ArabicSupplement();
    public static UnicodeRange get_Thaana();
    public static UnicodeRange get_NKo();
    public static UnicodeRange get_Samaritan();
    public static UnicodeRange get_Mandaic();
    public static UnicodeRange get_SyriacSupplement();
    public static UnicodeRange get_ArabicExtendedB();
    public static UnicodeRange get_ArabicExtendedA();
    public static UnicodeRange get_Devanagari();
    public static UnicodeRange get_Bengali();
    public static UnicodeRange get_Gurmukhi();
    public static UnicodeRange get_Gujarati();
    public static UnicodeRange get_Oriya();
    public static UnicodeRange get_Tamil();
    public static UnicodeRange get_Telugu();
    public static UnicodeRange get_Kannada();
    public static UnicodeRange get_Malayalam();
    public static UnicodeRange get_Sinhala();
    public static UnicodeRange get_Thai();
    public static UnicodeRange get_Lao();
    public static UnicodeRange get_Tibetan();
    public static UnicodeRange get_Myanmar();
    public static UnicodeRange get_Georgian();
    public static UnicodeRange get_HangulJamo();
    public static UnicodeRange get_Ethiopic();
    public static UnicodeRange get_EthiopicSupplement();
    public static UnicodeRange get_Cherokee();
    public static UnicodeRange get_UnifiedCanadianAboriginalSyllabics();
    public static UnicodeRange get_Ogham();
    public static UnicodeRange get_Runic();
    public static UnicodeRange get_Tagalog();
    public static UnicodeRange get_Hanunoo();
    public static UnicodeRange get_Buhid();
    public static UnicodeRange get_Tagbanwa();
    public static UnicodeRange get_Khmer();
    public static UnicodeRange get_Mongolian();
    public static UnicodeRange get_UnifiedCanadianAboriginalSyllabicsExtended();
    public static UnicodeRange get_Limbu();
    public static UnicodeRange get_TaiLe();
    public static UnicodeRange get_NewTaiLue();
    public static UnicodeRange get_KhmerSymbols();
    public static UnicodeRange get_Buginese();
    public static UnicodeRange get_TaiTham();
    public static UnicodeRange get_CombiningDiacriticalMarksExtended();
    public static UnicodeRange get_Balinese();
    public static UnicodeRange get_Sundanese();
    public static UnicodeRange get_Batak();
    public static UnicodeRange get_Lepcha();
    public static UnicodeRange get_OlChiki();
    public static UnicodeRange get_CyrillicExtendedC();
    public static UnicodeRange get_GeorgianExtended();
    public static UnicodeRange get_SundaneseSupplement();
    public static UnicodeRange get_VedicExtensions();
    public static UnicodeRange get_PhoneticExtensions();
    public static UnicodeRange get_PhoneticExtensionsSupplement();
    public static UnicodeRange get_CombiningDiacriticalMarksSupplement();
    public static UnicodeRange get_LatinExtendedAdditional();
    public static UnicodeRange get_GreekExtended();
    public static UnicodeRange get_GeneralPunctuation();
    public static UnicodeRange get_SuperscriptsandSubscripts();
    public static UnicodeRange get_CurrencySymbols();
    public static UnicodeRange get_CombiningDiacriticalMarksforSymbols();
    public static UnicodeRange get_LetterlikeSymbols();
    public static UnicodeRange get_NumberForms();
    public static UnicodeRange get_Arrows();
    public static UnicodeRange get_MathematicalOperators();
    public static UnicodeRange get_MiscellaneousTechnical();
    public static UnicodeRange get_ControlPictures();
    public static UnicodeRange get_OpticalCharacterRecognition();
    public static UnicodeRange get_EnclosedAlphanumerics();
    public static UnicodeRange get_BoxDrawing();
    public static UnicodeRange get_BlockElements();
    public static UnicodeRange get_GeometricShapes();
    public static UnicodeRange get_MiscellaneousSymbols();
    public static UnicodeRange get_Dingbats();
    public static UnicodeRange get_MiscellaneousMathematicalSymbolsA();
    public static UnicodeRange get_SupplementalArrowsA();
    public static UnicodeRange get_BraillePatterns();
    public static UnicodeRange get_SupplementalArrowsB();
    public static UnicodeRange get_MiscellaneousMathematicalSymbolsB();
    public static UnicodeRange get_SupplementalMathematicalOperators();
    public static UnicodeRange get_MiscellaneousSymbolsandArrows();
    public static UnicodeRange get_Glagolitic();
    public static UnicodeRange get_LatinExtendedC();
    public static UnicodeRange get_Coptic();
    public static UnicodeRange get_GeorgianSupplement();
    public static UnicodeRange get_Tifinagh();
    public static UnicodeRange get_EthiopicExtended();
    public static UnicodeRange get_CyrillicExtendedA();
    public static UnicodeRange get_SupplementalPunctuation();
    public static UnicodeRange get_CjkRadicalsSupplement();
    public static UnicodeRange get_KangxiRadicals();
    public static UnicodeRange get_IdeographicDescriptionCharacters();
    public static UnicodeRange get_CjkSymbolsandPunctuation();
    public static UnicodeRange get_Hiragana();
    public static UnicodeRange get_Katakana();
    public static UnicodeRange get_Bopomofo();
    public static UnicodeRange get_HangulCompatibilityJamo();
    public static UnicodeRange get_Kanbun();
    public static UnicodeRange get_BopomofoExtended();
    public static UnicodeRange get_CjkStrokes();
    public static UnicodeRange get_KatakanaPhoneticExtensions();
    public static UnicodeRange get_EnclosedCjkLettersandMonths();
    public static UnicodeRange get_CjkCompatibility();
    public static UnicodeRange get_CjkUnifiedIdeographsExtensionA();
    public static UnicodeRange get_YijingHexagramSymbols();
    public static UnicodeRange get_CjkUnifiedIdeographs();
    public static UnicodeRange get_YiSyllables();
    public static UnicodeRange get_YiRadicals();
    public static UnicodeRange get_Lisu();
    public static UnicodeRange get_Vai();
    public static UnicodeRange get_CyrillicExtendedB();
    public static UnicodeRange get_Bamum();
    public static UnicodeRange get_ModifierToneLetters();
    public static UnicodeRange get_LatinExtendedD();
    public static UnicodeRange get_SylotiNagri();
    public static UnicodeRange get_CommonIndicNumberForms();
    public static UnicodeRange get_Phagspa();
    public static UnicodeRange get_Saurashtra();
    public static UnicodeRange get_DevanagariExtended();
    public static UnicodeRange get_KayahLi();
    public static UnicodeRange get_Rejang();
    public static UnicodeRange get_HangulJamoExtendedA();
    public static UnicodeRange get_Javanese();
    public static UnicodeRange get_MyanmarExtendedB();
    public static UnicodeRange get_Cham();
    public static UnicodeRange get_MyanmarExtendedA();
    public static UnicodeRange get_TaiViet();
    public static UnicodeRange get_MeeteiMayekExtensions();
    public static UnicodeRange get_EthiopicExtendedA();
    public static UnicodeRange get_LatinExtendedE();
    public static UnicodeRange get_CherokeeSupplement();
    public static UnicodeRange get_MeeteiMayek();
    public static UnicodeRange get_HangulSyllables();
    public static UnicodeRange get_HangulJamoExtendedB();
    public static UnicodeRange get_CjkCompatibilityIdeographs();
    public static UnicodeRange get_AlphabeticPresentationForms();
    public static UnicodeRange get_ArabicPresentationFormsA();
    public static UnicodeRange get_VariationSelectors();
    public static UnicodeRange get_VerticalForms();
    public static UnicodeRange get_CombiningHalfMarks();
    public static UnicodeRange get_CjkCompatibilityForms();
    public static UnicodeRange get_SmallFormVariants();
    public static UnicodeRange get_ArabicPresentationFormsB();
    public static UnicodeRange get_HalfwidthandFullwidthForms();
    public static UnicodeRange get_Specials();
}
internal static class System.Text.UnicodeDebug : object {
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsBmpCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsHighSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsLowSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidScalar(UInt32 scalarValue);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidSupplementaryPlaneScalar(UInt32 scalarValue);
    private static string ToHexString(UInt32 codePoint);
}
internal static class System.Text.UnicodeUtility : object {
    public static UInt32 ReplacementChar;
    public static int GetPlane(UInt32 codePoint);
    public static UInt32 GetScalarFromUtf16SurrogatePair(UInt32 highSurrogateCodePoint, UInt32 lowSurrogateCodePoint);
    public static int GetUtf16SequenceLength(UInt32 value);
    public static void GetUtf16SurrogatesFromSupplementaryPlaneScalar(UInt32 value, Char& highSurrogateCodePoint, Char& lowSurrogateCodePoint);
    public static int GetUtf8SequenceLength(UInt32 value);
    public static bool IsAsciiCodePoint(UInt32 value);
    public static bool IsBmpCodePoint(UInt32 value);
    public static bool IsHighSurrogateCodePoint(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsLowSurrogateCodePoint(UInt32 value);
    public static bool IsSurrogateCodePoint(UInt32 value);
    public static bool IsValidCodePoint(UInt32 codePoint);
    public static bool IsValidUnicodeScalar(UInt32 value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Insert(int index, string s);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
internal interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual void GetResult(short token);
}
internal interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual TResult GetResult(short token);
}
[Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute("1")]
[Microsoft.Bcl.AsyncInterfaces.NullableAttribute("0")]
internal class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1 : ValueType {
    private Action`1<object> _continuation;
    private object _continuationState;
    private ExecutionContext _executionContext;
    private object _capturedContext;
    private bool _completed;
    private TResult _result;
    private ExceptionDispatchInfo _error;
    private short _version;
    [CompilerGeneratedAttribute]
private bool <RunContinuationsAsynchronously>k__BackingField;
    public bool RunContinuationsAsynchronously { get; public set; }
    public short Version { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_RunContinuationsAsynchronously();
    [CompilerGeneratedAttribute]
public void set_RunContinuationsAsynchronously(bool value);
    public void Reset();
    public void SetResult(TResult result);
    public void SetException(Exception error);
    public short get_Version();
    public ValueTaskSourceStatus GetStatus(short token);
    public TResult GetResult(short token);
    [Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute("2")]
public void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    private void ValidateToken(short token);
    private void SignalCompletion();
    private void InvokeContinuation();
}
internal static class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCoreShared : object {
    internal static Action`1<object> s_sentinel;
    private static ManualResetValueTaskSourceCoreShared();
    private static void CompletionSentinel(object _);
}
[FlagsAttribute]
internal enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
}
internal enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Canceled;
}
[Microsoft.Bcl.AsyncInterfaces.NullableContextAttribute("1")]
[Microsoft.Bcl.AsyncInterfaces.NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Threading.Tasks.TaskAsyncEnumerableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredAsyncDisposable ConfigureAwait(IAsyncDisposable source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(IAsyncEnumerable`1<T> source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
}
[System.Threading.Tasks.Extensions.IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
internal class System.Threading.Tasks.ValueTask : ValueType {
    private static Task s_canceledTask;
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    internal object _obj;
    internal short _token;
    internal bool _continueOnCapturedContext;
    internal static Task CompletedTask { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public ValueTask(Task task);
    public ValueTask(IValueTaskSource source, short token);
    private ValueTask(object obj, short token, bool continueOnCapturedContext);
    private static ValueTask();
    [CompilerGeneratedAttribute]
internal static Task get_CompletedTask();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public Task AsTask();
    public ValueTask Preserve();
    private Task GetTaskForValueTaskSource(IValueTaskSource t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    [StackTraceHiddenAttribute]
internal void ThrowIfCompletedUnsuccessfully();
    public ValueTaskAwaiter GetAwaiter();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
}
[System.Threading.Tasks.Extensions.IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
internal class System.Threading.Tasks.ValueTask`1 : ValueType {
    private static Task`1<TResult> s_canceledTask;
    internal object _obj;
    internal TResult _result;
    internal short _token;
    internal bool _continueOnCapturedContext;
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public TResult Result { get; }
    public ValueTask`1(TResult result);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    private ValueTask`1(object obj, TResult result, short token, bool continueOnCapturedContext);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public Task`1<TResult> AsTask();
    public ValueTask`1<TResult> Preserve();
    private Task`1<TResult> GetTaskForValueTaskSource(IValueTaskSource`1<TResult> t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    public TResult get_Result();
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public virtual string ToString();
}
internal static class System.ThrowHelper : object {
    internal static void ThrowArgumentNullException(ExceptionArgument argument);
    private static Exception CreateArgumentNullException(ExceptionArgument argument);
    internal static void ThrowArrayTypeMismatchException();
    private static Exception CreateArrayTypeMismatchException();
    internal static void ThrowArgumentException_InvalidTypeWithPointersNotSupported(Type type);
    private static Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(Type type);
    internal static void ThrowArgumentException_DestinationTooShort();
    private static Exception CreateArgumentException_DestinationTooShort();
    internal static void ThrowIndexOutOfRangeException();
    private static Exception CreateIndexOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException();
    private static Exception CreateArgumentOutOfRangeException();
    internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    private static Exception CreateArgumentOutOfRangeException(ExceptionArgument argument);
    internal static void ThrowArgumentOutOfRangeException_PrecisionTooLarge();
    private static Exception CreateArgumentOutOfRangeException_PrecisionTooLarge();
    internal static void ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
    private static Exception CreateArgumentOutOfRangeException_SymbolDoesNotFit();
    internal static void ThrowInvalidOperationException();
    private static Exception CreateInvalidOperationException();
    internal static void ThrowInvalidOperationException_OutstandingReferences();
    private static Exception CreateInvalidOperationException_OutstandingReferences();
    internal static void ThrowInvalidOperationException_UnexpectedSegmentType();
    private static Exception CreateInvalidOperationException_UnexpectedSegmentType();
    internal static void ThrowInvalidOperationException_EndPositionNotReached();
    private static Exception CreateInvalidOperationException_EndPositionNotReached();
    internal static void ThrowArgumentOutOfRangeException_PositionOutOfRange();
    private static Exception CreateArgumentOutOfRangeException_PositionOutOfRange();
    internal static void ThrowArgumentOutOfRangeException_OffsetOutOfRange();
    private static Exception CreateArgumentOutOfRangeException_OffsetOutOfRange();
    internal static void ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
    private static Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer();
    internal static void ThrowFormatException_BadFormatSpecifier();
    private static Exception CreateFormatException_BadFormatSpecifier();
    internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    private static Exception CreateArgumentException_OverlapAlignmentMismatch();
    internal static void ThrowNotSupportedException();
    private static Exception CreateThrowNotSupportedException();
    public static bool TryFormatThrowFormatException(Int32& bytesWritten);
    public static bool TryParseThrowFormatException(T& value, Int32& bytesConsumed);
    public static void ThrowArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment);
    private static Exception CreateArgumentValidationException(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment);
    public static void ThrowArgumentValidationException(Array array, int start);
    private static Exception CreateArgumentValidationException(Array array, int start);
    public static void ThrowStartOrEndArgumentValidationException(long start);
    private static Exception CreateStartOrEndArgumentValidationException(long start);
}
