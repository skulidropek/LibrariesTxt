internal class NuGet.Client.AnyFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private static AnyFramework <Instance>k__BackingField;
    internal static AnyFramework Instance { get; }
    private static AnyFramework();
    [CompilerGeneratedAttribute]
internal static AnyFramework get_Instance();
}
public class NuGet.Client.ManagedCodeConventions : object {
    private static ContentPropertyDefinition LocaleProperty;
    private static ContentPropertyDefinition AnyProperty;
    private static ContentPropertyDefinition AssemblyProperty;
    private static ContentPropertyDefinition MSBuildProperty;
    private static ContentPropertyDefinition SatelliteAssemblyProperty;
    private static ContentPropertyDefinition CodeLanguageProperty;
    private static Dictionary`2<string, object> NetTFMTable;
    private static Dictionary`2<string, object> DefaultTfmAny;
    private static PatternTable DotnetAnyTable;
    private static PatternTable AnyTable;
    private RuntimeGraph _runtimeGraph;
    private Dictionary`2<string, NuGetFramework> _frameworkCache;
    [CompilerGeneratedAttribute]
private ManagedCodeCriteria <Criteria>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedCodePatterns <Patterns>k__BackingField;
    public ManagedCodeCriteria Criteria { get; }
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> Properties { get; }
    public ManagedCodePatterns Patterns { get; }
    public ManagedCodeConventions(RuntimeGraph runtimeGraph);
    private static ManagedCodeConventions();
    [CompilerGeneratedAttribute]
public ManagedCodeCriteria get_Criteria();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
public ManagedCodePatterns get_Patterns();
    private bool RuntimeIdentifier_CompatibilityTest(object criteria, object available);
    private static object CodeLanguage_Parser(string name, PatternTable table);
    private static object Locale_Parser(string name, PatternTable table);
    private object TargetFrameworkName_Parser(string name, PatternTable table);
    private static NuGetFramework TargetFrameworkName_ParserCore(string name);
    private static object AllowEmptyFolderParser(string s, PatternTable table);
    private static bool TargetFrameworkName_CompatibilityTest(object criteria, object available);
    private static int TargetFrameworkName_NearestCompareTest(object projectFramework, object criteria, object available);
    private static Version NormalizeVersion(Version version);
}
public class NuGet.ContentModel.Asset : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Link>k__BackingField;
    public string Path { get; public set; }
    public string Link { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Link();
    [CompilerGeneratedAttribute]
public void set_Link(string value);
    public virtual string ToString();
}
public class NuGet.ContentModel.ContentItem : object {
    private Dictionary`2<string, object> _properties;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; public set; }
    public Dictionary`2<string, object> Properties { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public Dictionary`2<string, object> get_Properties();
    internal void set_Properties(Dictionary`2<string, object> value);
    public virtual string ToString();
    private Dictionary`2<string, object> CreateDictionary();
}
public class NuGet.ContentModel.ContentItemCollection : object {
    private List`1<Asset> _assets;
    [CompilerGeneratedAttribute]
private bool <HasContract>k__BackingField;
    public bool HasContract { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_HasContract();
    [CompilerGeneratedAttribute]
private void set_HasContract(bool value);
    public void Load(IEnumerable`1<string> paths);
    public IEnumerable`1<ContentItem> FindItems(PatternSet definition);
    [IteratorStateMachineAttribute("NuGet.ContentModel.ContentItemCollection/<FindItemGroups>d__7")]
public IEnumerable`1<ContentItemGroup> FindItemGroups(PatternSet definition);
    public bool HasItemGroup(SelectionCriteria criteria, PatternSet[] definitions);
    public ContentItemGroup FindBestItemGroup(SelectionCriteria criteria, PatternSet[] definitions);
    [IteratorStateMachineAttribute("NuGet.ContentModel.ContentItemCollection/<FindItemsImplementation>d__10")]
private IEnumerable`1<ContentItem> FindItemsImplementation(PatternSet definition, IEnumerable`1<Asset> assets);
    private static bool IsValidAsset(string path);
}
[DebuggerDisplayAttribute("Items: {Items.Count}, Properties: {Properties.Count}")]
public class NuGet.ContentModel.ContentItemGroup : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ContentItem> <Items>k__BackingField;
    public IDictionary`2<string, object> Properties { get; }
    public IList`1<ContentItem> Items { get; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public IList`1<ContentItem> get_Items();
}
public class NuGet.ContentModel.ContentPropertyDefinition : object {
    private static Func`3<object, object, bool> EqualsTest;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <FileExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileExtensionAllowSubFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, PatternTable, object> <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<object, object, bool> <CompatibilityTest>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<object, object, object, int> <CompareTest>k__BackingField;
    public string Name { get; }
    public List`1<string> FileExtensions { get; }
    public bool FileExtensionAllowSubFolders { get; }
    public Func`3<string, PatternTable, object> Parser { get; }
    public Func`3<object, object, bool> CompatibilityTest { get; }
    public Func`4<object, object, object, int> CompareTest { get; }
    public ContentPropertyDefinition(string name);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser);
    public ContentPropertyDefinition(string name, Func`3<object, object, bool> compatibilityTest);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest, Func`4<object, object, object, int> compareTest);
    public ContentPropertyDefinition(string name, IEnumerable`1<string> fileExtensions);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, IEnumerable`1<string> fileExtensions);
    public ContentPropertyDefinition(string name, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest, Func`4<object, object, object, int> compareTest, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    private static ContentPropertyDefinition();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public List`1<string> get_FileExtensions();
    [CompilerGeneratedAttribute]
public bool get_FileExtensionAllowSubFolders();
    [CompilerGeneratedAttribute]
public Func`3<string, PatternTable, object> get_Parser();
    public virtual bool TryLookup(string name, PatternTable table, Object& value);
    private static bool ContainsSlash(string name);
    [CompilerGeneratedAttribute]
public Func`3<object, object, bool> get_CompatibilityTest();
    [CompilerGeneratedAttribute]
public Func`4<object, object, object, int> get_CompareTest();
    public virtual bool IsCriteriaSatisfied(object critieriaValue, object candidateValue);
    public virtual int Compare(object criteriaValue, object candidateValue1, object candidateValue2);
}
public class NuGet.ContentModel.Infrastructure.PatternExpression : object {
    private List`1<Segment> _segments;
    private Dictionary`2<string, object> _defaults;
    private PatternTable _table;
    public PatternExpression(PatternDefinition pattern);
    private void Initialize(string pattern);
    public ContentItem Match(string path, IReadOnlyDictionary`2<string, ContentPropertyDefinition> propertyDefinitions);
}
public class NuGet.ContentModel.PatternDefinition : object {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternTable <Table>k__BackingField;
    public string Pattern { get; }
    public IReadOnlyDictionary`2<string, object> Defaults { get; }
    public PatternTable Table { get; }
    public PatternDefinition(string pattern);
    public PatternDefinition(string pattern, PatternTable table);
    public PatternDefinition(string pattern, PatternTable table, IEnumerable`1<KeyValuePair`2<string, object>> defaults);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Defaults();
    [CompilerGeneratedAttribute]
public PatternTable get_Table();
    public static PatternDefinition op_Implicit(string pattern);
}
public class NuGet.ContentModel.PatternSet : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PatternDefinition> <GroupPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternExpression[] <GroupExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PatternDefinition> <PathPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternExpression[] <PathExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <PropertyDefinitions>k__BackingField;
    public IEnumerable`1<PatternDefinition> GroupPatterns { get; }
    internal PatternExpression[] GroupExpressions { get; }
    public IEnumerable`1<PatternDefinition> PathPatterns { get; }
    internal PatternExpression[] PathExpressions { get; }
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> PropertyDefinitions { get; public set; }
    public PatternSet(IReadOnlyDictionary`2<string, ContentPropertyDefinition> properties, IEnumerable`1<PatternDefinition> groupPatterns, IEnumerable`1<PatternDefinition> pathPatterns);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PatternDefinition> get_GroupPatterns();
    [CompilerGeneratedAttribute]
internal PatternExpression[] get_GroupExpressions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PatternDefinition> get_PathPatterns();
    [CompilerGeneratedAttribute]
internal PatternExpression[] get_PathExpressions();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_PropertyDefinitions();
    [CompilerGeneratedAttribute]
public void set_PropertyDefinitions(IReadOnlyDictionary`2<string, ContentPropertyDefinition> value);
}
public class NuGet.ContentModel.PatternTable : object {
    private Dictionary`2<string, Dictionary`2<string, object>> _table;
    public PatternTable(IEnumerable`1<PatternTableEntry> entries);
    public bool TryLookup(string propertyName, string name, Object& value);
}
public class NuGet.ContentModel.PatternTableEntry : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string PropertyName { get; }
    public string Name { get; }
    public object Value { get; }
    public PatternTableEntry(string propertyName, string name, object value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public class NuGet.ContentModel.SelectionCriteria : object {
    [CompilerGeneratedAttribute]
private IList`1<SelectionCriteriaEntry> <Entries>k__BackingField;
    public IList`1<SelectionCriteriaEntry> Entries { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<SelectionCriteriaEntry> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(IList`1<SelectionCriteriaEntry> value);
}
public class NuGet.ContentModel.SelectionCriteriaBuilder : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionCriteria <Criteria>k__BackingField;
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> Properties { get; }
    public SelectionCriteria Criteria { get; }
    public SelectionCriteriaEntryBuilder Add { get; }
    public SelectionCriteriaBuilder(IReadOnlyDictionary`2<string, ContentPropertyDefinition> properties);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
public virtual SelectionCriteria get_Criteria();
    public virtual SelectionCriteriaEntryBuilder get_Add();
}
public class NuGet.ContentModel.SelectionCriteriaEntry : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public IDictionary`2<string, object> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
}
[DefaultMemberAttribute("Item")]
public class NuGet.ContentModel.SelectionCriteriaEntryBuilder : SelectionCriteriaBuilder {
    [CompilerGeneratedAttribute]
private SelectionCriteriaEntry <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionCriteriaBuilder <Builder>k__BackingField;
    public SelectionCriteriaEntry Entry { get; }
    public SelectionCriteriaBuilder Builder { get; }
    public SelectionCriteriaEntryBuilder Item { get; }
    public SelectionCriteriaEntryBuilder Item { get; }
    public SelectionCriteriaEntryBuilder Add { get; }
    public SelectionCriteria Criteria { get; }
    internal SelectionCriteriaEntryBuilder(SelectionCriteriaBuilder builder, SelectionCriteriaEntry entry);
    [CompilerGeneratedAttribute]
public SelectionCriteriaEntry get_Entry();
    [CompilerGeneratedAttribute]
public SelectionCriteriaBuilder get_Builder();
    public SelectionCriteriaEntryBuilder get_Item(string key, string value);
    public SelectionCriteriaEntryBuilder get_Item(string key, object value);
    public virtual SelectionCriteriaEntryBuilder get_Add();
    public virtual SelectionCriteria get_Criteria();
}
[ExtensionAttribute]
public static class NuGet.Packaging.CollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
internal static class NuGet.Packaging.Core.ContentExtractor : object {
    internal static IEnumerable`1<ContentItemGroup> GetContentForPattern(ContentItemCollection collection, PatternSet pattern);
    internal static IEnumerable`1<NuGetFramework> GetGroupFrameworks(IEnumerable`1<ContentItemGroup> groups);
}
public class NuGet.Packaging.Core.ContentFilesEntry : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Flatten>k__BackingField;
    public string Include { get; }
    public string Exclude { get; }
    public string BuildAction { get; }
    public Nullable`1<bool> CopyToOutput { get; }
    public Nullable`1<bool> Flatten { get; }
    public ContentFilesEntry(string include, string exclude, string buildAction, Nullable`1<bool> copyToOutput, Nullable`1<bool> flatten);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CopyToOutput();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Flatten();
}
public class NuGet.Packaging.Core.ExtractPackageFileDelegate : MulticastDelegate {
    public ExtractPackageFileDelegate(object object, IntPtr method);
    public virtual string Invoke(string sourceFile, string targetPath, Stream fileStream);
    public virtual IAsyncResult BeginInvoke(string sourceFile, string targetPath, Stream fileStream, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class NuGet.Packaging.Core.Fingerprints : object {
    private IDictionary`2<string, string> _keyValuePairs;
    public string Item { get; }
    public Fingerprints(IDictionary`2<string, string> fingerPrints);
    public string get_Item(string key);
    public IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
}
public interface NuGet.Packaging.Core.IAsyncPackageCoreReader {
    public abstract virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
}
public interface NuGet.Packaging.Core.INuspecCoreReader {
    public abstract virtual string GetId();
    public abstract virtual NuGetVersion GetVersion();
    public abstract virtual NuGetVersion GetMinClientVersion();
    public abstract virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public abstract virtual PackageIdentity GetIdentity();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> GetMetadata();
}
public interface NuGet.Packaging.Core.IPackageCoreReader {
    public abstract virtual PackageIdentity GetIdentity();
    public abstract virtual NuGetVersion GetMinClientVersion();
    public abstract virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual Stream GetNuspec();
    public abstract virtual string GetNuspecFile();
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Core.IPackageIdentityComparer {
}
public interface NuGet.Packaging.Core.IRepositoryCertificateInfo {
    public string ContentUrl { get; }
    public Fingerprints Fingerprints { get; }
    public string Issuer { get; }
    public DateTimeOffset NotAfter { get; }
    public DateTimeOffset NotBefore { get; }
    public string Subject { get; }
    public abstract virtual string get_ContentUrl();
    public abstract virtual Fingerprints get_Fingerprints();
    public abstract virtual string get_Issuer();
    public abstract virtual DateTimeOffset get_NotAfter();
    public abstract virtual DateTimeOffset get_NotBefore();
    public abstract virtual string get_Subject();
}
public class NuGet.Packaging.Core.NuspecCoreReader : NuspecCoreReaderBase {
    public NuspecCoreReader(Stream stream);
    public NuspecCoreReader(XDocument xml);
    [IteratorStateMachineAttribute("NuGet.Packaging.Core.NuspecCoreReader/<GetDependencies>d__2")]
public virtual IEnumerable`1<PackageDependency> GetDependencies();
}
public abstract class NuGet.Packaging.Core.NuspecCoreReaderBase : object {
    private XDocument _xml;
    private XElement _metadataNode;
    private Dictionary`2<string, string> _metadataValues;
    protected static string Metadata;
    protected static string Id;
    protected static string Version;
    protected static string MinClientVersion;
    protected static string DevelopmentDependency;
    protected Dictionary`2<string, string> MetadataValues { get; }
    protected XElement MetadataNode { get; }
    public XDocument Xml { get; }
    public NuspecCoreReaderBase(string path);
    public NuspecCoreReaderBase(Stream stream);
    public NuspecCoreReaderBase(Stream stream, bool leaveStreamOpen);
    public NuspecCoreReaderBase(XDocument xml);
    public virtual string GetId();
    public virtual NuGetVersion GetVersion();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual bool IsServiceable();
    public virtual bool GetDevelopmentDependency();
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> GetMetadata();
    public virtual string GetMetadataValue(string name);
    protected Dictionary`2<string, string> get_MetadataValues();
    protected XElement get_MetadataNode();
    public XDocument get_Xml();
    public virtual PackageIdentity GetIdentity();
    private static XDocument LoadXml(Stream stream, bool leaveStreamOpen);
}
public static class NuGet.Packaging.Core.NuspecUtility : object {
    public static string PackageTypes;
    public static string PackageType;
    public static string Name;
    public static string Version;
    public static string Serviceable;
    public static string Repository;
    public static string Type;
    public static string RepositoryUrl;
    public static string RepositoryBranch;
    public static string RepositoryCommit;
    public static string License;
    public static string Group;
    public static string FrameworkReferences;
    public static string FrameworkReference;
    public static string TargetFramework;
    private static NuspecUtility();
    public static IReadOnlyList`1<PackageType> GetPackageTypes(XElement metadataNode, bool useMetadataNamespace);
    public static bool IsServiceable(XElement metadataNode);
    [IteratorStateMachineAttribute("NuGet.Packaging.Core.NuspecUtility/<GetFrameworkReferenceGroups>d__17")]
internal static IEnumerable`1<FrameworkReferenceGroup> GetFrameworkReferenceGroups(XElement metadataNode, IFrameworkNameProvider frameworkProvider, bool useMetadataNamespace);
    private static IEnumerable`1<string> GetFrameworkReferences(IEnumerable`1<XElement> nodes);
    private static string GetAttributeValue(XElement element, string attributeName);
}
public class NuGet.Packaging.Core.PackageDependency : object {
    private VersionRange _versionRange;
    private static List`1<string> EmptyList;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Exclude>k__BackingField;
    public string Id { get; }
    public IReadOnlyList`1<string> Include { get; }
    public IReadOnlyList`1<string> Exclude { get; }
    public VersionRange VersionRange { get; }
    public PackageDependency(string id);
    public PackageDependency(string id, VersionRange versionRange);
    public PackageDependency(string id, VersionRange versionRange, IReadOnlyList`1<string> include, IReadOnlyList`1<string> exclude);
    private static PackageDependency();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Include();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Exclude();
    public VersionRange get_VersionRange();
    public sealed virtual bool Equals(PackageDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageDependencyComparer : object {
    private IVersionRangeComparer _versionRangeComparer;
    public static PackageDependencyComparer Default;
    public PackageDependencyComparer(IVersionRangeComparer versionRangeComparer);
    private static PackageDependencyComparer();
    public sealed virtual bool Equals(PackageDependency x, PackageDependency y);
    public sealed virtual int GetHashCode(PackageDependency obj);
}
public class NuGet.Packaging.Core.PackageDependencyInfo : PackageIdentity {
    private static PackageDependency[] EmptyDependencies;
    private PackageDependency[] _dependencies;
    public IEnumerable`1<PackageDependency> Dependencies { get; }
    public PackageDependencyInfo(string id, NuGetVersion version);
    public PackageDependencyInfo(PackageIdentity identity, IEnumerable`1<PackageDependency> dependencies);
    public PackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies);
    private static PackageDependencyInfo();
    public IEnumerable`1<PackageDependency> get_Dependencies();
    public sealed virtual bool Equals(PackageDependencyInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageDependencyInfoComparer : object {
    private IPackageIdentityComparer _identityComparer;
    private PackageDependencyComparer _dependencyComparer;
    public static PackageDependencyInfoComparer Default { get; }
    public PackageDependencyInfoComparer(IPackageIdentityComparer identityComparer, PackageDependencyComparer dependencyComparer);
    public static PackageDependencyInfoComparer get_Default();
    public sealed virtual bool Equals(PackageDependencyInfo x, PackageDependencyInfo y);
    public sealed virtual int GetHashCode(PackageDependencyInfo obj);
    [CompilerGeneratedAttribute]
private int <GetHashCode>b__7_0(PackageDependency e);
}
public class NuGet.Packaging.Core.PackageIdentity : object {
    private string _id;
    private NuGetVersion _version;
    private static string ToStringFormat;
    public string Id { get; }
    public NuGetVersion Version { get; }
    public bool HasVersion { get; }
    public static PackageIdentityComparer Comparer { get; }
    public PackageIdentity(string id, NuGetVersion version);
    public string get_Id();
    public NuGetVersion get_Version();
    public bool get_HasVersion();
    public sealed virtual bool Equals(PackageIdentity other);
    public virtual bool Equals(PackageIdentity other, VersionComparison versionComparison);
    public sealed virtual int CompareTo(PackageIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PackageIdentityComparer get_Comparer();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageIdentityComparer : object {
    private IVersionComparer _versionComparer;
    public static PackageIdentityComparer Default { get; }
    public PackageIdentityComparer(VersionComparison versionComparison);
    public PackageIdentityComparer(IVersionComparer versionComparer);
    public static PackageIdentityComparer get_Default();
    public sealed virtual bool Equals(PackageIdentity x, PackageIdentity y);
    public sealed virtual int GetHashCode(PackageIdentity obj);
    public sealed virtual int Compare(PackageIdentity x, PackageIdentity y);
}
public class NuGet.Packaging.Core.PackageType : object {
    public static Version EmptyVersion;
    public static PackageType Legacy;
    public static PackageType DotnetCliTool;
    public static PackageType Dependency;
    public static PackageType DotnetTool;
    public static PackageType SymbolsPackage;
    public static PackageType DotnetPlatform;
    public static StringComparer PackageTypeNameComparer;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public PackageType(string name, Version version);
    private static PackageType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public virtual bool Equals(object obj);
    public static bool op_Equality(PackageType a, PackageType b);
    public static bool op_Inequality(PackageType a, PackageType b);
    public sealed virtual bool Equals(PackageType other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(PackageType other);
}
public static class NuGet.Packaging.Core.PackagingCoreConstants : object {
    public static string HashFileExtension;
    public static string NupkgExtension;
    public static string NuspecExtension;
    public static string PackageDownloadMarkerFileExtension;
    public static string NupkgMetadataFileExtension;
    public static string EmptyFolder;
    public static string ForwardSlashEmptyFolder;
    private static PackagingCoreConstants();
}
public class NuGet.Packaging.Core.PackagingException : Exception {
    private IPackLogMessage _logMessage;
    public PackagingException(string message);
    public PackagingException(NuGetLogCode logCode, string message);
    public PackagingException(NuGetLogCode logCode, string message, Exception innerException);
    public PackagingException(string message, Exception innerException);
    public virtual ILogMessage AsLogMessage();
}
public class NuGet.Packaging.Core.RepositoryMetadata : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Commit>k__BackingField;
    public string Type { get; public set; }
    public string Url { get; public set; }
    public string Branch { get; public set; }
    public string Commit { get; public set; }
    public RepositoryMetadata(string type, string url, string branch, string commit);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(string value);
    [CompilerGeneratedAttribute]
public string get_Commit();
    [CompilerGeneratedAttribute]
public void set_Commit(string value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RepositoryMetadata a, RepositoryMetadata b);
    public static bool op_Inequality(RepositoryMetadata a, RepositoryMetadata b);
    public sealed virtual bool Equals(RepositoryMetadata other);
    public virtual int GetHashCode();
}
internal class NuGet.Packaging.EmptyFrameworkFolderFile : PhysicalPackageFile {
    public EmptyFrameworkFolderFile(string directoryPathInPackage);
}
public enum NuGet.Packaging.ExtractionSource : Enum {
    public int value__;
    public static ExtractionSource RestoreCommand;
    public static ExtractionSource DownloadResource;
    public static ExtractionSource NuGetFolderProject;
}
public class NuGet.Packaging.FallbackPackagePathInfo : object {
    [CompilerGeneratedAttribute]
private VersionFolderPathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    public VersionFolderPathResolver PathResolver { get; }
    public string Id { get; }
    public NuGetVersion Version { get; }
    public FallbackPackagePathInfo(string id, NuGetVersion version, VersionFolderPathResolver resolver);
    [CompilerGeneratedAttribute]
public VersionFolderPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
}
public class NuGet.Packaging.FallbackPackagePathResolver : object {
    private List`1<VersionFolderPathResolver> _pathResolvers;
    public FallbackPackagePathResolver(INuGetPathContext pathContext);
    public FallbackPackagePathResolver(string userPackageFolder, IEnumerable`1<string> fallbackPackageFolders);
    public string GetPackageDirectory(string packageId, string version);
    public string GetPackageDirectory(string packageId, NuGetVersion version);
    public FallbackPackagePathInfo GetPackageInfo(string packageId, NuGetVersion version);
}
public class NuGet.Packaging.FrameworkAssemblyReference : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NuGetFramework> <SupportedFrameworks>k__BackingField;
    public string AssemblyName { get; private set; }
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; private set; }
    public FrameworkAssemblyReference(string assemblyName, IEnumerable`1<NuGetFramework> supportedFrameworks);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
private void set_SupportedFrameworks(IEnumerable`1<NuGetFramework> value);
}
public static class NuGet.Packaging.FrameworkNameUtility : object {
    public static FrameworkName ParseFrameworkNameFromFilePath(string filePath, String& effectivePath);
    public static FrameworkName ParseFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
}
public class NuGet.Packaging.FrameworkReference : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public FrameworkReference(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual int Compare(FrameworkReference x, FrameworkReference y);
    public sealed virtual bool Equals(FrameworkReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(FrameworkReference other);
}
public class NuGet.Packaging.FrameworkReferenceGroup : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkReference> <FrameworkReferences>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<FrameworkReference> FrameworkReferences { get; }
    public FrameworkReferenceGroup(NuGetFramework targetFramework, IEnumerable`1<FrameworkReference> frameworkReferences);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public IEnumerable`1<FrameworkReference> get_FrameworkReferences();
    public sealed virtual bool Equals(FrameworkReferenceGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class NuGet.Packaging.FrameworksExtensions : object {
    [ExtensionAttribute]
public static string GetFrameworkString(NuGetFramework self);
}
public class NuGet.Packaging.FrameworkSpecificGroup : object {
    private NuGetFramework _targetFramework;
    private String[] _items;
    [CompilerGeneratedAttribute]
private bool <HasEmptyFolder>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<string> Items { get; }
    public bool HasEmptyFolder { get; }
    public FrameworkSpecificGroup(NuGetFramework targetFramework, IEnumerable`1<string> items);
    public sealed virtual NuGetFramework get_TargetFramework();
    public IEnumerable`1<string> get_Items();
    [CompilerGeneratedAttribute]
public bool get_HasEmptyFolder();
    public sealed virtual bool Equals(FrameworkSpecificGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface NuGet.Packaging.IAsyncPackageContentReader {
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
}
public interface NuGet.Packaging.IHashFunction {
    public abstract virtual string GetHash();
    public abstract virtual void Update(Byte[] data, int offset, int count);
}
public interface NuGet.Packaging.INuspecReader {
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public abstract virtual string GetLanguage();
}
public interface NuGet.Packaging.IPackageContentReader {
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
}
public interface NuGet.Packaging.IPackageDownloader {
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public abstract virtual IAsyncPackageContentReader get_ContentReader();
    public abstract virtual IAsyncPackageCoreReader get_CoreReader();
    public abstract virtual ISignedPackageReader get_SignedPackageReader();
    public abstract virtual string get_Source();
    public abstract virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public abstract virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public abstract virtual void SetThrottle(SemaphoreSlim throttle);
}
public interface NuGet.Packaging.IPackageFile {
    public string Path { get; }
    public string EffectivePath { get; }
    public FrameworkName TargetFramework { get; }
    public DateTimeOffset LastWriteTime { get; }
    public abstract virtual string get_Path();
    public abstract virtual string get_EffectivePath();
    public abstract virtual FrameworkName get_TargetFramework();
    public abstract virtual DateTimeOffset get_LastWriteTime();
    public abstract virtual Stream GetStream();
}
public interface NuGet.Packaging.IPackageMetadata {
    public string Id { get; }
    public NuGetVersion Version { get; }
    public string Title { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public Uri IconUrl { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public bool DevelopmentDependency { get; }
    public string Description { get; }
    public string Summary { get; }
    public string ReleaseNotes { get; }
    public string Language { get; }
    public string Tags { get; }
    public bool Serviceable { get; }
    public string Copyright { get; }
    public string Icon { get; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; }
    public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; }
    public Version MinClientVersion { get; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; }
    public IEnumerable`1<PackageType> PackageTypes { get; }
    public RepositoryMetadata Repository { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; }
    public abstract virtual string get_Id();
    public abstract virtual NuGetVersion get_Version();
    public abstract virtual string get_Title();
    public abstract virtual IEnumerable`1<string> get_Authors();
    public abstract virtual IEnumerable`1<string> get_Owners();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual bool get_DevelopmentDependency();
    public abstract virtual string get_Description();
    public abstract virtual string get_Summary();
    public abstract virtual string get_ReleaseNotes();
    public abstract virtual string get_Language();
    public abstract virtual string get_Tags();
    public abstract virtual bool get_Serviceable();
    public abstract virtual string get_Copyright();
    public abstract virtual string get_Icon();
    public abstract virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    public abstract virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public abstract virtual Version get_MinClientVersion();
    public abstract virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    public abstract virtual IEnumerable`1<PackageType> get_PackageTypes();
    public abstract virtual RepositoryMetadata get_Repository();
    public abstract virtual LicenseMetadata get_LicenseMetadata();
    public abstract virtual IEnumerable`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
}
public interface NuGet.Packaging.IPackageResolver {
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
}
public class NuGet.Packaging.LicenseMetadata : object {
    public static Version EmptyVersion;
    public static Version CurrentVersion;
    public static Uri LicenseFileDeprecationUrl;
    public static string LicenseServiceLinkTemplate;
    [CompilerGeneratedAttribute]
private LicenseType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <LicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <WarningsAndErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public LicenseType Type { get; }
    public string License { get; }
    public NuGetLicenseExpression LicenseExpression { get; }
    public IReadOnlyList`1<string> WarningsAndErrors { get; }
    public Version Version { get; }
    public Uri LicenseUrl { get; }
    public LicenseMetadata(LicenseType type, string license, NuGetLicenseExpression expression, IReadOnlyList`1<string> warningsAndErrors, Version version);
    private static LicenseMetadata();
    [CompilerGeneratedAttribute]
public LicenseType get_Type();
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_LicenseExpression();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_WarningsAndErrors();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public sealed virtual bool Equals(LicenseMetadata other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Uri get_LicenseUrl();
    private string GenerateLicenseServiceLink(string license);
}
public class NuGet.Packaging.Licenses.ExceptionData : object {
    [CompilerGeneratedAttribute]
private string <LicenseExceptionID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecatedLicenseId>k__BackingField;
    public string LicenseExceptionID { get; }
    public bool IsDeprecatedLicenseId { get; }
    public ExceptionData(string licenseID, bool isDeprecatedLicenseId);
    [CompilerGeneratedAttribute]
public string get_LicenseExceptionID();
    [CompilerGeneratedAttribute]
public bool get_IsDeprecatedLicenseId();
}
public class NuGet.Packaging.Licenses.LicenseData : object {
    [CompilerGeneratedAttribute]
private string <LicenseID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOsiApproved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecatedLicenseId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFsfLibre>k__BackingField;
    public string LicenseID { get; }
    public bool IsOsiApproved { get; }
    public bool IsDeprecatedLicenseId { get; }
    public bool IsFsfLibre { get; }
    public LicenseData(string licenseID, bool isOsiApproved, bool isDeprecatedLicenseId, bool isFsfLibre);
    [CompilerGeneratedAttribute]
public string get_LicenseID();
    [CompilerGeneratedAttribute]
public bool get_IsOsiApproved();
    [CompilerGeneratedAttribute]
public bool get_IsDeprecatedLicenseId();
    [CompilerGeneratedAttribute]
public bool get_IsFsfLibre();
}
internal class NuGet.Packaging.Licenses.LicenseExpressionToken : object {
    [CompilerGeneratedAttribute]
private LicenseTokenType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    internal LicenseTokenType TokenType { get; }
    internal string Value { get; }
    internal LicenseExpressionToken(string value, LicenseTokenType tokenType);
    [CompilerGeneratedAttribute]
internal LicenseTokenType get_TokenType();
    [CompilerGeneratedAttribute]
internal string get_Value();
    public virtual string ToString();
}
internal class NuGet.Packaging.Licenses.LicenseExpressionTokenizer : object {
    private string _value;
    internal LicenseExpressionTokenizer(string value);
    internal bool HasValidCharacters();
    [IteratorStateMachineAttribute("NuGet.Packaging.Licenses.LicenseExpressionTokenizer/<Tokenize>d__3")]
internal IEnumerable`1<LicenseExpressionToken> Tokenize();
    private LicenseExpressionToken ParseBracket(char bracket);
    private LicenseExpressionToken ParseTokenType(string token);
}
public enum NuGet.Packaging.Licenses.LicenseExpressionType : Enum {
    public int value__;
    public static LicenseExpressionType License;
    public static LicenseExpressionType Operator;
}
public abstract class NuGet.Packaging.Licenses.LicenseOperator : NuGetLicenseExpression {
    [CompilerGeneratedAttribute]
private LicenseOperatorType <OperatorType>k__BackingField;
    public LicenseOperatorType OperatorType { get; }
    protected LicenseOperator(LicenseOperatorType operatorType);
    [CompilerGeneratedAttribute]
public LicenseOperatorType get_OperatorType();
}
public enum NuGet.Packaging.Licenses.LicenseOperatorType : Enum {
    public int value__;
    public static LicenseOperatorType WithOperator;
    public static LicenseOperatorType LogicalOperator;
}
internal enum NuGet.Packaging.Licenses.LicenseTokenType : Enum {
    public int value__;
    public static LicenseTokenType WITH;
    public static LicenseTokenType AND;
    public static LicenseTokenType OR;
    public static LicenseTokenType OPENING_BRACKET;
    public static LicenseTokenType CLOSING_BRACKET;
    public static LicenseTokenType IDENTIFIER;
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Licenses.LicenseTokenTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsOperator(LicenseTokenType tokenType);
    [ExtensionAttribute]
public static bool IsValidPrecedingToken(LicenseTokenType current, LicenseTokenType precedingToken);
}
public class NuGet.Packaging.Licenses.LogicalOperator : LicenseOperator {
    [CompilerGeneratedAttribute]
private LogicalOperatorType <LogicalOperatorType>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <Right>k__BackingField;
    public LogicalOperatorType LogicalOperatorType { get; }
    public NuGetLicenseExpression Left { get; }
    public NuGetLicenseExpression Right { get; }
    public LogicalOperator(LogicalOperatorType logicalOperatorType, NuGetLicenseExpression left, NuGetLicenseExpression right);
    [CompilerGeneratedAttribute]
public LogicalOperatorType get_LogicalOperatorType();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_Left();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_Right();
    public virtual string ToString();
}
public enum NuGet.Packaging.Licenses.LogicalOperatorType : Enum {
    public int value__;
    public static LogicalOperatorType And;
    public static LogicalOperatorType Or;
}
public class NuGet.Packaging.Licenses.NuGetLicense : NuGetLicenseExpression {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Plus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStandardLicense>k__BackingField;
    internal static string UNLICENSED;
    public string Identifier { get; }
    public bool Plus { get; }
    public bool IsStandardLicense { get; }
    private NuGetLicense(string identifier, bool plus, bool isStandardLicense);
    private static NuGetLicense();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public bool get_Plus();
    [CompilerGeneratedAttribute]
public bool get_IsStandardLicense();
    internal static NuGetLicense ParseIdentifier(string licenseIdentifier, bool allowUnlicensed);
    private static bool HasValidCharacters(string value);
    private static NuGetLicense ProcessLicenseNotInStandardData(string licenseIdentifier, bool plus, bool allowUnlicensed);
    public virtual string ToString();
}
public class NuGet.Packaging.Licenses.NuGetLicenseData : object {
    public static string LicenseListVersion;
    public static IReadOnlyDictionary`2<string, LicenseData> LicenseList;
    public static IReadOnlyDictionary`2<string, ExceptionData> ExceptionList;
    private static NuGetLicenseData();
}
public class NuGet.Packaging.Licenses.NuGetLicenseException : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; }
    private NuGetLicenseException(string identifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    internal static NuGetLicenseException ParseIdentifier(string exceptionIdentifier);
    public virtual string ToString();
}
public abstract class NuGet.Packaging.Licenses.NuGetLicenseExpression : object {
    [CompilerGeneratedAttribute]
private LicenseExpressionType <Type>k__BackingField;
    public LicenseExpressionType Type { get; protected set; }
    [CompilerGeneratedAttribute]
public LicenseExpressionType get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(LicenseExpressionType value);
    public static NuGetLicenseExpression Parse(string expression);
}
[ExtensionAttribute]
public static class NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions : object {
    [ExtensionAttribute]
public static bool HasOnlyStandardIdentifiers(NuGetLicenseExpression expression);
    [ExtensionAttribute]
public static void OnEachLeafNode(NuGetLicenseExpression expression, Action`1<NuGetLicense> licenseProcessor, Action`1<NuGetLicenseException> exceptionProcessor);
    [ExtensionAttribute]
public static bool IsUnlicensed(NuGetLicense license);
    [ExtensionAttribute]
public static bool IsUnlicensed(NuGetLicenseExpression expression);
}
internal static class NuGet.Packaging.Licenses.NuGetLicenseExpressionParser : object {
    internal static NuGetLicenseExpression Parse(string expression);
    private static IEnumerable`1<LicenseExpressionToken> GetTokens(string expression);
    private static void ProcessOperators(Stack`1<LicenseExpressionToken> operatorStack, Stack`1<Tuple`2<bool, object>> operandStack);
    private static Tuple`2<bool, object> PopIfNotEmpty(Stack`1<Tuple`2<bool, object>> operandStack);
}
public class NuGet.Packaging.Licenses.NuGetLicenseExpressionParsingException : Exception {
    public NuGetLicenseExpressionParsingException(string message);
    public NuGetLicenseExpressionParsingException(string message, Exception innerException);
}
public class NuGet.Packaging.Licenses.WithOperator : LicenseOperator {
    [CompilerGeneratedAttribute]
private NuGetLicense <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseException <Exception>k__BackingField;
    public NuGetLicense License { get; private set; }
    public NuGetLicenseException Exception { get; private set; }
    public WithOperator(NuGetLicense license, NuGetLicenseException exception);
    [CompilerGeneratedAttribute]
public NuGetLicense get_License();
    [CompilerGeneratedAttribute]
private void set_License(NuGetLicense value);
    [CompilerGeneratedAttribute]
public NuGetLicenseException get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(NuGetLicenseException value);
    public virtual string ToString();
}
public enum NuGet.Packaging.LicenseType : Enum {
    public int value__;
    public static LicenseType File;
    public static LicenseType Expression;
}
[ObsoleteAttribute("Use NuGet.Protocol.LocalPackageArchiveDownloader")]
public class NuGet.Packaging.LocalPackageArchiveDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private string _packageFilePath;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private Lazy`1<FileStream> _sourceStream;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public LocalPackageArchiveDownloader(string source, string packageFilePath, PackageIdentity packageIdentity, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Packaging.LocalPackageArchiveDownloader/<CopyNupkgFileToAsync>d__19")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetSourceStream();
    private void ThrowIfDisposed();
}
public class NuGet.Packaging.Manifest : object {
    private static string SchemaVersionAttributeName;
    [CompilerGeneratedAttribute]
private ManifestMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFilesNode>k__BackingField;
    public ManifestMetadata Metadata { get; }
    public ICollection`1<ManifestFile> Files { get; }
    public bool HasFilesNode { get; }
    public Manifest(ManifestMetadata metadata);
    public Manifest(ManifestMetadata metadata, ICollection`1<ManifestFile> files);
    [CompilerGeneratedAttribute]
public ManifestMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestFile> get_Files();
    [CompilerGeneratedAttribute]
public bool get_HasFilesNode();
    public void Save(Stream stream);
    public void Save(Stream stream, bool generateBackwardsCompatible);
    public void Save(Stream stream, int minimumManifestVersion);
    public void Save(Stream stream, int minimumManifestVersion, bool generateBackwardsCompatible);
    public static Manifest ReadFrom(Stream stream, bool validateSchema);
    public static Manifest ReadFrom(Stream stream, Func`2<string, string> propertyProvider, bool validateSchema);
    private static string GetSchemaNamespace(XDocument document);
    public static Manifest Create(IPackageMetadata metadata);
    private static void ValidateManifestSchema(XDocument document, string schemaNamespace);
    private static void CheckSchemaVersion(XDocument document);
    private static string GetPackageId(XElement metadataElement);
    private static XElement GetMetadataElement(XDocument document);
    public static void Validate(Manifest manifest);
    private static void ValidateDependencyGroups(IPackageMetadata metadata);
    private static void ValidateDependencyVersion(PackageDependency dependency);
}
public class NuGet.Packaging.ManifestContentFiles : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flatten>k__BackingField;
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public string BuildAction { get; public set; }
    public string CopyToOutput { get; public set; }
    public string Flatten { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(string value);
    [CompilerGeneratedAttribute]
public string get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(string value);
    [CompilerGeneratedAttribute]
public string get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(string value);
}
public class NuGet.Packaging.ManifestFile : object {
    private static Char[] _invalidSourceCharacters;
    internal static Char[] ReferenceFileInvalidCharacters;
    private static Char[] _invalidTargetChars;
    private string _target;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    public string Source { get; public set; }
    public string Target { get; public set; }
    public string Exclude { get; public set; }
    private static ManifestFile();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    public string get_Target();
    public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestFile/<Validate>d__15")]
public IEnumerable`1<string> Validate();
}
public class NuGet.Packaging.ManifestMetadata : object {
    private string _minClientVersionString;
    private IEnumerable`1<string> _authors;
    private IEnumerable`1<string> _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    private IEnumerable`1<PackageDependencyGroup> _dependencyGroups;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    private IEnumerable`1<PackageReferenceSet> _packageAssemblyReferences;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [ManifestVersionAttribute("5")]
public string MinClientVersionString { get; public set; }
    public Version MinClientVersion { get; private set; }
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public string Title { get; public set; }
    public IEnumerable`1<string> Authors { get; public set; }
    public IEnumerable`1<string> Owners { get; public set; }
    public Uri IconUrl { get; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    [ManifestVersionAttribute("2")]
public string ReleaseNotes { get; public set; }
    [ManifestVersionAttribute("2")]
public string Copyright { get; public set; }
    public string Language { get; public set; }
    public string Tags { get; public set; }
    public bool Serviceable { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; public set; }
    public IEnumerable`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; public set; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; public set; }
    [ManifestVersionAttribute("2")]
public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; public set; }
    public IEnumerable`1<PackageType> PackageTypes { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public ManifestMetadata(IPackageMetadata copy);
    public string get_MinClientVersionString();
    public void set_MinClientVersionString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
private void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public sealed virtual IEnumerable`1<string> get_Authors();
    public void set_Authors(IEnumerable`1<string> value);
    public sealed virtual IEnumerable`1<string> get_Owners();
    public void set_Owners(IEnumerable`1<string> value);
    public void SetIconUrl(string iconUrl);
    public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    public void SetLicenseUrl(string licenseUrl);
    public sealed virtual Uri get_LicenseUrl();
    public void SetProjectUrl(string projectUrl);
    public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public void set_DependencyGroups(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferenceGroups(IEnumerable`1<FrameworkReferenceGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferences(IEnumerable`1<FrameworkAssemblyReference> value);
    public sealed virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public void set_PackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> value);
    private static IEnumerable`1<PackageReferenceSet> MergePackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> referenceSets);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IEnumerable`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(IEnumerable`1<PackageType> value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    private static IEnumerable`1<PackageDependencyGroup> MergeDependencyGroups(IEnumerable`1<PackageDependencyGroup> actualDependencyGroups);
    private static PackageDependencyGroup CreatePackageDependencyGroup(PackageDependencyGroup dependencyGroup);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestMetadata/<Validate>d__117")]
public IEnumerable`1<string> Validate();
}
internal static class NuGet.Packaging.ManifestReader : object {
    private static String[] RequiredElements;
    private static ManifestReader();
    public static Manifest ReadManifest(XDocument document);
    private static ManifestMetadata ReadMetadata(XElement xElement);
    private static void ReadMetadataValue(ManifestMetadata manifestMetadata, XElement element, HashSet`1<string> allElements);
    private static IEnumerable`1<FrameworkReferenceGroup> ReadFrameworkReferenceGroups(XElement frameworkReferenceGroupsElement);
    private static LicenseMetadata ReadLicenseMetadata(XElement licenseNode);
    private static List`1<ManifestContentFiles> ReadContentFiles(XElement contentFilesElement);
    private static List`1<PackageReferenceSet> ReadReferenceSets(XElement referencesElement);
    public static List`1<string> ReadReference(XElement referenceElement, bool throwIfEmpty);
    private static List`1<FrameworkAssemblyReference> ReadFrameworkAssemblies(XElement frameworkElement);
    private static List`1<PackageDependencyGroup> ReadDependencyGroups(XElement dependenciesElement);
    private static ISet`1<PackageDependency> ReadDependencies(XElement containerElement);
    private static List`1<ManifestFile> ReadFilesList(XElement xElement);
    private static RepositoryMetadata ReadRepository(XElement element);
}
public static class NuGet.Packaging.ManifestSchemaUtility : object {
    internal static string SchemaVersionV1;
    internal static string SchemaVersionV2;
    internal static string SchemaVersionV3;
    internal static string SchemaVersionV4;
    internal static string SchemaVersionV5;
    internal static string SchemaVersionV6;
    private static String[] VersionToSchemaMappings;
    private static ConcurrentDictionary`2<string, XmlSchemaSet> _manifestSchemaSetCache;
    private static ManifestSchemaUtility();
    public static int GetVersionFromNamespace(string namespace);
    public static string GetSchemaNamespace(int version);
    public static XmlSchemaSet GetManifestSchemaSet(string schemaNamespace);
    public static bool IsKnownSchema(string schemaNamespace);
}
[AttributeUsageAttribute("128")]
internal class NuGet.Packaging.ManifestVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; private set; }
    public ManifestVersionAttribute(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
}
public static class NuGet.Packaging.ManifestVersionUtility : object {
    public static int DefaultVersion;
    public static int SemverVersion;
    public static int TargetFrameworkSupportForDependencyContentsAndToolsVersion;
    public static int TargetFrameworkSupportForReferencesVersion;
    public static int XdtTransformationVersion;
    public static int GetManifestVersion(ManifestMetadata metadata);
    private static int GetMaxVersionFromMetadata(ManifestMetadata metadata);
    private static int GetVersionFromObject(object obj);
    private static int GetVersionFromPropertyInfo(object obj, PropertyInfo property);
    private static int VisitList(IEnumerable list);
    private static Nullable`1<int> GetPropertyVersion(PropertyInfo property);
}
public class NuGet.Packaging.MinClientVersionException : PackagingException {
    public MinClientVersionException(string message);
    public virtual ILogMessage AsLogMessage();
}
public static class NuGet.Packaging.MinClientVersionUtility : object {
    private static NuGetVersion _clientVersion;
    public static void VerifyMinClientVersion(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuGetVersion packageMinClientVersion);
    public static NuGetVersion GetNuGetClientVersion();
}
internal static class NuGet.Packaging.NuGetExtractionFileIO : object {
    private static int _unixPermissions;
    private static Lazy`1<Func`2<string, FileStream>> _createFileMethod;
    private static NuGetExtractionFileIO();
    internal static FileStream CreateFile(string path);
    private static Func`2<string, FileStream> CreateFileMethodSelector();
    private static FileStream DotnetCoreCreateFile(string path);
    private static FileStream MonoPosixCreateFile(string path);
    private static void ApplyUMaskToUnixPermissions();
    private static bool ApplyUMaskToUnixPermissionsFromProcess();
    private static void ApplyUMaskToUnixPermissionsFromLibc();
    private static int PosixCreate(string pathname, int mode);
    private static int PosixChmod(string pathname, int mode);
    private static int PosixUMask(int mask);
}
public class NuGet.Packaging.NupkgMetadataFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    public int Version { get; public set; }
    public string ContentHash { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(string value);
    public sealed virtual bool Equals(NupkgMetadataFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Packaging.NupkgMetadataFileFormat : object {
    public static int Version;
    private static string VersionProperty;
    private static string HashProperty;
    private static JsonLoadSettings DefaultLoadSettings;
    private static NupkgMetadataFileFormat();
    public static NupkgMetadataFile Read(string filePath);
    public static NupkgMetadataFile Read(string filePath, ILogger log);
    public static NupkgMetadataFile Read(Stream stream, ILogger log, string path);
    public static NupkgMetadataFile Read(TextReader reader, ILogger log, string path);
    private static JObject LoadJson(TextReader reader);
    private static NupkgMetadataFile ReadHashFile(JObject cursor);
    internal static int ReadInt(JToken cursor, string property, int defaultValue);
    internal static TItem ReadProperty(JObject jObject, string propertyName);
    public static void Write(string filePath, NupkgMetadataFile hashFile);
    public static void Write(Stream stream, NupkgMetadataFile hashFile);
    public static void Write(TextWriter textWriter, NupkgMetadataFile hashFile);
    private static JObject WriteHashFile(NupkgMetadataFile hashFile);
}
public class NuGet.Packaging.NuspecReader : NuspecCoreReaderBase {
    private static string Dependencies;
    private static string Group;
    private static string TargetFramework;
    private static string Dependency;
    private static string References;
    private static string Reference;
    private static string File;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Language;
    private static string ContentFiles;
    private static string Files;
    private static string BuildAction;
    private static string Flatten;
    private static string CopyToOutput;
    private static string IncludeFlags;
    private static string ExcludeFlags;
    private static string LicenseUrl;
    private static string Repository;
    private static string Icon;
    private static Char[] CommaArray;
    private IFrameworkNameProvider _frameworkProvider;
    private static List`1<string> EmptyList;
    public NuspecReader(string path);
    public NuspecReader(string path, IFrameworkNameProvider frameworkProvider);
    public NuspecReader(Stream stream);
    public NuspecReader(XDocument xml);
    public NuspecReader(Stream stream, IFrameworkNameProvider frameworkProvider, bool leaveStreamOpen);
    public NuspecReader(XDocument xml, IFrameworkNameProvider frameworkProvider);
    private static NuspecReader();
    public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetDependencyGroups>d__30")]
public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups(bool useStrictVersionCheck);
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetReferenceGroups>d__31")]
public IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    [ObsoleteAttribute("GetFrameworkReferenceGroups() is deprecated. Please use GetFrameworkAssemblyGroups() instead.")]
public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkAssemblyGroups();
    public string GetLanguage();
    public string GetLicenseUrl();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetContentFiles>d__36")]
public IEnumerable`1<ContentFilesEntry> GetContentFiles();
    public string GetTitle();
    public string GetAuthors();
    public string GetTags();
    public string GetOwners();
    public string GetDescription();
    public string GetReleaseNotes();
    public string GetSummary();
    public string GetProjectUrl();
    public string GetIconUrl();
    public string GetCopyright();
    public RepositoryMetadata GetRepositoryMetadata();
    public LicenseMetadata GetLicenseMetadata();
    private static IList`1<string> GetNonStandardLicenseIdentifiers(NuGetLicenseExpression expression);
    public bool GetRequireLicenseAcceptance();
    public IEnumerable`1<FrameworkReferenceGroup> GetFrameworkRefGroups();
    public string GetIcon();
    private static Nullable`1<bool> AttributeAsNullableBool(XElement element, string attributeName);
    private static string GetAttributeValue(XElement element, string attributeName);
    private static List`1<string> GetFlags(string flags);
    private HashSet`1<PackageDependency> GetPackageDependencies(IEnumerable`1<XElement> nodes, bool useStrictVersionCheck);
}
public class NuGet.Packaging.PackageArchiveReader : PackageReaderBase {
    private ZipArchive _zipArchive;
    private Encoding _utf8Encoding;
    private SigningSpecifications _signingSpecifications;
    [CompilerGeneratedAttribute]
private Stream <ZipReadStream>k__BackingField;
    protected SigningSpecifications SigningSpecifications { get; }
    protected Stream ZipReadStream { get; protected set; }
    public PackageArchiveReader(Stream stream);
    public PackageArchiveReader(Stream stream, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(ZipArchive zipArchive);
    public PackageArchiveReader(ZipArchive zipArchive, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(string filePath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    protected SigningSpecifications get_SigningSpecifications();
    [CompilerGeneratedAttribute]
protected Stream get_ZipReadStream();
    [CompilerGeneratedAttribute]
protected void set_ZipReadStream(Stream value);
    public virtual IEnumerable`1<string> GetFiles();
    public virtual IEnumerable`1<string> GetFiles(string folder);
    public virtual Stream GetStream(string path);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public string ExtractFile(string packageFile, string targetFilePath, ILogger logger);
    public ZipArchiveEntry GetEntry(string packageFile);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<EnumeratePackageEntries>d__23")]
public IEnumerable`1<ZipFilePair> EnumeratePackageEntries(IEnumerable`1<string> packageFiles, string packageDirectory);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<ValidatePackageEntriesAsync>d__24")]
public Task ValidatePackageEntriesAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<GetPrimarySignatureAsync>d__25")]
public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<ValidateIntegrityAsync>d__27")]
public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithmName, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    protected void ThrowIfZipReadStreamIsNull();
    private string GetContentHashForSignedPackage(CancellationToken token);
}
public class NuGet.Packaging.PackageBuilder : object {
    private static string DefaultContentType;
    private static Uri DefaultUri;
    internal static string ManifestRelationType;
    private bool _includeEmptyDirectories;
    private bool _deterministic;
    private static DateTime ZipFormatMinDate;
    public static int MaxIconFileSize;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSnapshotVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IPackageFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageReferenceSet> <PackageAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    private static Char[] HexValues;
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public bool HasSnapshotVersion { get; public set; }
    public string Title { get; public set; }
    public ISet`1<string> Authors { get; private set; }
    public ISet`1<string> Owners { get; private set; }
    public Uri IconUrl { get; public set; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool Serviceable { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public string OutputName { get; public set; }
    public ISet`1<string> Tags { get; private set; }
    public Dictionary`2<string, string> Properties { get; private set; }
    public string Copyright { get; public set; }
    public Collection`1<PackageDependencyGroup> DependencyGroups { get; private set; }
    public ICollection`1<IPackageFile> Files { get; private set; }
    public Collection`1<FrameworkAssemblyReference> FrameworkReferences { get; private set; }
    public Collection`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; private set; }
    public IList`1<NuGetFramework> TargetFrameworks { get; public set; }
    public ICollection`1<ManifestContentFiles> ContentFiles { get; private set; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public ICollection`1<PackageType> PackageTypes { get; public set; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Owners { get; }
    private string NuGet.Packaging.IPackageMetadata.Tags { get; }
    private IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences { get; }
    private IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.DependencyGroups { get; }
    private IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.FrameworkReferences { get; }
    private IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.ContentFiles { get; }
    private IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.PackageTypes { get; }
    private IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.FrameworkReferenceGroups { get; }
    public Version MinClientVersion { get; public set; }
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic);
    public PackageBuilder(Stream stream, string basePath);
    public PackageBuilder(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public PackageBuilder(bool deterministic);
    private PackageBuilder(bool includeEmptyDirectories, bool deterministic);
    private static PackageBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    [CompilerGeneratedAttribute]
public bool get_HasSnapshotVersion();
    [CompilerGeneratedAttribute]
public void set_HasSnapshotVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public Collection`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
private void set_DependencyGroups(Collection`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public ICollection`1<IPackageFile> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(ICollection`1<IPackageFile> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferences(Collection`1<FrameworkAssemblyReference> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferenceGroups(Collection`1<FrameworkReferenceGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
private void set_ContentFiles(ICollection`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    [CompilerGeneratedAttribute]
public void set_PackageAssemblyReferences(ICollection`1<PackageReferenceSet> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(ICollection`1<PackageType> value);
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Owners();
    private sealed virtual override string NuGet.Packaging.IPackageMetadata.get_Tags();
    private sealed virtual override IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.get_PackageAssemblyReferences();
    private sealed virtual override IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.get_DependencyGroups();
    private sealed virtual override IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.get_FrameworkReferences();
    private sealed virtual override IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.get_ContentFiles();
    private sealed virtual override IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.get_PackageTypes();
    private sealed virtual override IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    public void Save(Stream stream);
    private static Byte[] ReadAllBytes(Stream stream);
    private string CalcPsmdcpName();
    internal static string EncodeHexString(Byte[] sArray);
    private static string CreatorInfo();
    private static int DetermineMinimumSchemaVersion(ICollection`1<IPackageFile> Files, ICollection`1<PackageDependencyGroup> package);
    private static bool RequiresV4TargetFrameworkSchema(ICollection`1<IPackageFile> files);
    private static bool HasContentFilesV2(ICollection`1<IPackageFile> contentFiles);
    private static bool HasIncludeExclude(IEnumerable`1<PackageDependencyGroup> dependencyGroups);
    private static bool HasXdtTransformFile(ICollection`1<IPackageFile> contentFiles);
    private static void ValidateDependencies(SemanticVersion version, IEnumerable`1<PackageDependencyGroup> dependencies);
    public static void ValidateReferenceAssemblies(IEnumerable`1<IPackageFile> files, IEnumerable`1<PackageReferenceSet> packageAssemblyReferences);
    private void ValidateLicenseFile(IEnumerable`1<IPackageFile> files, LicenseMetadata licenseMetadata);
    private void ValidateIconFile(IEnumerable`1<IPackageFile> files, string iconPath);
    private void ReadManifest(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public void Populate(ManifestMetadata manifestMetadata);
    public void PopulateFiles(string basePath, IEnumerable`1<ManifestFile> files);
    private ZipArchiveEntry CreateEntry(ZipArchive package, string entryName, CompressionLevel compressionLevel);
    private ZipArchiveEntry CreatePackageFileEntry(ZipArchive package, string entryName, DateTimeOffset timeOffset, CompressionLevel compressionLevel);
    private void WriteManifest(ZipArchive package, int minimumManifestVersion, string psmdcpPath);
    private HashSet`1<string> WriteFiles(ZipArchive package, HashSet`1<string> filesWithoutExtensions);
    public void AddFiles(string basePath, string source, string destination, string exclude);
    internal static IEnumerable`1<PhysicalPackageFile> ResolveSearchPattern(string basePath, string searchPath, string targetPath, bool includeEmptyDirectories);
    internal static string ResolvePackagePath(string searchDirectory, string searchPattern, string fullPath, string targetPath);
    private static bool IsKnownFolder(string targetPath);
    private static void ExcludeFiles(List`1<PhysicalPackageFile> searchFiles, string basePath, string exclude);
    private void CreatePart(ZipArchive package, string path, Stream sourceStream, DateTimeOffset lastWriteTime);
    internal static string CreatePartEntryName(string path);
    internal static string GetStringForPartUri(string escapedPath);
    private static IEnumerable`1<string> ParseTags(string tags);
    private void WriteOpcManifestRelationship(ZipArchive package, string path, string psmdcpPath);
    private void WriteOpcContentTypes(ZipArchive package, HashSet`1<string> extensions, HashSet`1<string> filesWithoutExtensions);
    private void WriteOpcPackageProperties(ZipArchive package, string psmdcpPath);
    private string GenerateRelationshipId(string path);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.PackageCreation.Resources.NuGetResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotCreateEmptyPackage { get; }
    internal static string DependencyHasInvalidVersion { get; }
    internal static string DuplicateDependenciesDefined { get; }
    internal static string IconCannotOpenFile { get; }
    internal static string IconErrorEmpty { get; }
    internal static string IconMaxFileSizeExceeded { get; }
    internal static string IconMissingRequiredValue { get; }
    internal static string IconNoFileElement { get; }
    internal static string IncompatibleSchema { get; }
    internal static string InvalidPackageId { get; }
    internal static string Manifest_DependenciesHasMixedElements { get; }
    internal static string Manifest_ExcludeContainsInvalidCharacters { get; }
    internal static string Manifest_IdMaxLengthExceeded { get; }
    internal static string Manifest_InvalidMinClientVersion { get; }
    internal static string Manifest_InvalidReference { get; }
    internal static string Manifest_InvalidReferenceFile { get; }
    internal static string Manifest_LicenseFileExtensionIsInvalid { get; }
    internal static string Manifest_LicenseFileIsNotInNupkg { get; }
    internal static string Manifest_LicenseUrlCannotBeUsedWithLicenseMetadata { get; }
    internal static string Manifest_PropertyValueReadFailure { get; }
    internal static string Manifest_ReferencesHasMixedElements { get; }
    internal static string Manifest_ReferencesIsEmpty { get; }
    internal static string Manifest_RequiredElementMissing { get; }
    internal static string Manifest_RequiredMetadataMissing { get; }
    internal static string Manifest_RequireLicenseAcceptanceRequiresLicenseUrl { get; }
    internal static string Manifest_SourceContainsInvalidCharacters { get; }
    internal static string Manifest_TargetContainsInvalidCharacters { get; }
    internal static string Manifest_UriCannotBeEmpty { get; }
    internal static string PackageAuthoring_FileNotFound { get; }
    internal static string UnknownSchemaVersion { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotCreateEmptyPackage();
    internal static string get_DependencyHasInvalidVersion();
    internal static string get_DuplicateDependenciesDefined();
    internal static string get_IconCannotOpenFile();
    internal static string get_IconErrorEmpty();
    internal static string get_IconMaxFileSizeExceeded();
    internal static string get_IconMissingRequiredValue();
    internal static string get_IconNoFileElement();
    internal static string get_IncompatibleSchema();
    internal static string get_InvalidPackageId();
    internal static string get_Manifest_DependenciesHasMixedElements();
    internal static string get_Manifest_ExcludeContainsInvalidCharacters();
    internal static string get_Manifest_IdMaxLengthExceeded();
    internal static string get_Manifest_InvalidMinClientVersion();
    internal static string get_Manifest_InvalidReference();
    internal static string get_Manifest_InvalidReferenceFile();
    internal static string get_Manifest_LicenseFileExtensionIsInvalid();
    internal static string get_Manifest_LicenseFileIsNotInNupkg();
    internal static string get_Manifest_LicenseUrlCannotBeUsedWithLicenseMetadata();
    internal static string get_Manifest_PropertyValueReadFailure();
    internal static string get_Manifest_ReferencesHasMixedElements();
    internal static string get_Manifest_ReferencesIsEmpty();
    internal static string get_Manifest_RequiredElementMissing();
    internal static string get_Manifest_RequiredMetadataMissing();
    internal static string get_Manifest_RequireLicenseAcceptanceRequiresLicenseUrl();
    internal static string get_Manifest_SourceContainsInvalidCharacters();
    internal static string get_Manifest_TargetContainsInvalidCharacters();
    internal static string get_Manifest_UriCannotBeEmpty();
    internal static string get_PackageAuthoring_FileNotFound();
    internal static string get_UnknownSchemaVersion();
}
public class NuGet.Packaging.PackageDependencyGroup : object {
    private NuGetFramework _targetFramework;
    private IEnumerable`1<PackageDependency> _packages;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<PackageDependency> Packages { get; }
    public PackageDependencyGroup(NuGetFramework targetFramework, IEnumerable`1<PackageDependency> packages);
    public sealed virtual NuGetFramework get_TargetFramework();
    public IEnumerable`1<PackageDependency> get_Packages();
    public sealed virtual bool Equals(PackageDependencyGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class NuGet.Packaging.PackageExtraction.PackageExtractionBehavior : object {
    private static string XmlDocFileSaveModeEnvironmentKey;
    private static Nullable`1<XmlDocFileSaveMode> _xmlDocFileSaveMode;
    public static XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public static XmlDocFileSaveMode get_XmlDocFileSaveMode();
    public static void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
}
public class NuGet.Packaging.PackageExtractionContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocFileSaveMode <XmlDocFileSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopySatelliteFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSignatureVerifier <SignedPackageVerifier>k__BackingField;
    public ILogger Logger { get; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; }
    public bool CopySatelliteFiles { get; public set; }
    public IPackageSignatureVerifier SignedPackageVerifier { get; public set; }
    public PackageExtractionContext(PackageSaveMode packageSaveMode, XmlDocFileSaveMode xmlDocFileSaveMode, ClientPolicyContext clientPolicyContext, ILogger logger);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public XmlDocFileSaveMode get_XmlDocFileSaveMode();
    [CompilerGeneratedAttribute]
public void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public bool get_CopySatelliteFiles();
    [CompilerGeneratedAttribute]
public void set_CopySatelliteFiles(bool value);
    [CompilerGeneratedAttribute]
public IPackageSignatureVerifier get_SignedPackageVerifier();
    [CompilerGeneratedAttribute]
public void set_SignedPackageVerifier(IPackageSignatureVerifier value);
}
public class NuGet.Packaging.PackageExtractionResult : object {
    [CompilerGeneratedAttribute]
private bool <Cached>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SignVerifyDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSignType <PackageType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignVerifyStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignVerifyEndTime>k__BackingField;
    public bool Cached { get; }
    public TimeSpan SignVerifyDelay { get; }
    public PackageSignType PackageType { get; }
    public bool Success { get; }
    public TimeSpan Duration { get; public set; }
    public DateTimeOffset SignVerifyStartTime { get; }
    public DateTimeOffset SignVerifyEndTime { get; }
    public PackageExtractionResult(bool cached, TimeSpan signVerifyDelay, PackageSignType packageType, bool success, DateTimeOffset signVerifyStartTime, DateTimeOffset signVerifyEndTime);
    public PackageExtractionResult(bool cached, TimeSpan signVerifyDelay, PackageSignType packageType, bool success, TimeSpan duration);
    [CompilerGeneratedAttribute]
public bool get_Cached();
    [CompilerGeneratedAttribute]
public TimeSpan get_SignVerifyDelay();
    [CompilerGeneratedAttribute]
public PackageSignType get_PackageType();
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignVerifyStartTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignVerifyEndTime();
}
public class NuGet.Packaging.PackageExtractionTelemetryEvent : TelemetryEvent {
    public static string EventName;
    public PackageSaveMode PackageSaveMode { get; }
    public NuGetOperationStatus Status { get; }
    public ExtractionSource ExtractionSource { get; }
    public string PackageId { get; }
    public string PackageVersion { get; }
    public PackageExtractionTelemetryEvent(PackageSaveMode packageSaveMode, NuGetOperationStatus status, ExtractionSource extractionSource, PackageIdentity packageId);
    public PackageSaveMode get_PackageSaveMode();
    public NuGetOperationStatus get_Status();
    public ExtractionSource get_ExtractionSource();
    public string get_PackageId();
    public string get_PackageVersion();
}
public static class NuGet.Packaging.PackageExtractor : object {
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__0")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__1")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, PackageReaderBase packageReader, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__2")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__3")]
public static Task`1<bool> InstallFromSourceAsync(string source, PackageIdentity packageIdentity, Func`2<Stream, Task> copyToAsync, VersionFolderPathResolver versionFolderPathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    private static void DeleteTargetAndTempPaths(string targetPath, string targetTempNupkg);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__5")]
public static Task`1<bool> InstallFromSourceAsync(PackageIdentity packageIdentity, IPackageDownloader packageDownloader, VersionFolderPathResolver versionFolderPathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    private static bool ShouldInclude(string fullName, string hashFileName, string nupkgMetadataFileName);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<CopySatelliteFilesAsync>d__7")]
public static Task`1<IEnumerable`1<string>> CopySatelliteFilesAsync(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<CopySatelliteFilesAsync>d__8")]
private static Task`1<IEnumerable`1<string>> CopySatelliteFilesAsync(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<VerifyPackageSignatureAsync>d__9")]
private static Task VerifyPackageSignatureAsync(string source, Guid parentId, PackageIdentity package, PackageExtractionContext packageExtractionContext, ISignedPackageReader signedPackageReader, CancellationToken token);
    private static void UpdateSignatureLog(string source, PackageIdentity package, ClientPolicyContext policyContext, SignatureLog message);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<LogPackageSignatureVerificationAsync>d__11")]
private static Task LogPackageSignatureVerificationAsync(string source, PackageIdentity package, ILogger logger, VerifySignaturesResult verifyResult);
    private static RepositorySignatureInfo GetRepositorySignatureInfo(string source);
}
public class NuGet.Packaging.PackageFileExtractor : object {
    private HashSet`1<string> _intellisenseXmlFiles;
    private XmlDocFileSaveMode _xmlDocFileSaveMode;
    public PackageFileExtractor(IEnumerable`1<string> packageFiles, XmlDocFileSaveMode xmlDocFileSaveMode);
    private static HashSet`1<string> GatherIntellisenseXmlFiles(IEnumerable`1<string> packageFiles);
    private static string GetBinaryForLanguageSpecificXml(string file);
    public string ExtractPackageFile(string source, string target, Stream stream);
}
public class NuGet.Packaging.PackageFolderReader : PackageReaderBase {
    private DirectoryInfo _root;
    public PackageFolderReader(string folderPath);
    public PackageFolderReader(DirectoryInfo folder);
    public PackageFolderReader(string folderPath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageFolderReader(DirectoryInfo folder, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public virtual string GetNuspecFile();
    public virtual Stream GetStream(string path);
    private FileInfo GetFile(string path);
    public virtual IEnumerable`1<string> GetFiles();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageFolderReader/<GetFiles>d__9")]
public virtual IEnumerable`1<string> GetFiles(string folder);
    private static bool IsFileInRoot(string path);
    private static bool IsNupkg(string path);
    private static string GetRelativePath(DirectoryInfo root, FileInfo file);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    protected virtual void Dispose(bool disposing);
    public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
}
public static class NuGet.Packaging.PackageHelper : object {
    private static String[] ExcludePaths;
    private static Char[] Slashes;
    private static PackageHelper();
    public static bool IsAssembly(string path);
    public static bool IsNuspec(string path);
    public static bool IsManifest(string path);
    public static bool IsRoot(string path);
    public static bool IsPackageFile(string packageFileName, PackageSaveMode packageSaveMode);
    private static bool IsNuGetGeneratedFile(string path);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetSatellitePackageInfoAsync>d__8")]
private static Task`1<SatellitePackageInfo> GetSatellitePackageInfoAsync(IAsyncPackageCoreReader packageReader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetSatelliteFilesAsync>d__9")]
public static Task`1<Tuple`2<string, IEnumerable`1<string>>> GetSatelliteFilesAsync(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetInstalledPackageFilesAsync>d__10")]
public static Task`1<IEnumerable`1<ZipFilePair>> GetInstalledPackageFilesAsync(PackageArchiveReader packageReader, PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetInstalledSatelliteFilesAsync>d__11")]
public static Task`1<Tuple`2<string, IEnumerable`1<ZipFilePair>>> GetInstalledSatelliteFilesAsync(PackageArchiveReader packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
}
public static class NuGet.Packaging.PackageIdValidator : object {
    public static int MaxPackageIdLength;
    private static Regex IdRegex;
    private static PackageIdValidator();
    public static bool IsValidPackageId(string packageId);
    public static void ValidatePackageId(string packageId);
}
public static class NuGet.Packaging.PackagePathHelper : object {
    internal static IEnumerable`1<string> GetFiles(string root, string path, string filter, bool recursive);
    internal static IEnumerable`1<string> GetDirectories(string root, string path);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackagePathHelper/<GetPackageFiles>d__2")]
private static IEnumerable`1<string> GetPackageFiles(string root, string filter);
    private static bool FileNameMatchesPattern(PackageIdentity packageIdentity, string path);
    public static IEnumerable`1<string> GetPackageLookupPaths(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
    public static string GetInstalledPackageFilePath(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
}
public class NuGet.Packaging.PackagePathResolver : object {
    private string _rootDirectory;
    [CompilerGeneratedAttribute]
private bool <UseSideBySidePaths>k__BackingField;
    public bool UseSideBySidePaths { get; }
    protected internal string Root { get; }
    public PackagePathResolver(string rootDirectory, bool useSideBySidePaths);
    [CompilerGeneratedAttribute]
public bool get_UseSideBySidePaths();
    protected internal string get_Root();
    public virtual string GetPackageDirectoryName(PackageIdentity packageIdentity);
    public virtual string GetPackageFileName(PackageIdentity packageIdentity);
    public string GetPackageDownloadMarkerFileName(PackageIdentity packageIdentity);
    public string GetManifestFileName(PackageIdentity packageIdentity);
    public virtual string GetInstallPath(PackageIdentity packageIdentity);
    public virtual string GetInstalledPath(PackageIdentity packageIdentity);
    public virtual string GetInstalledPackageFilePath(PackageIdentity packageIdentity);
    private string GetId(PackageIdentity identity);
    private string GetVersion(PackageIdentity identity);
    private StringBuilder GetPathBase(PackageIdentity packageIdentity);
}
public abstract class NuGet.Packaging.PackageReaderBase : object {
    private NuspecReader _nuspecReader;
    [CompilerGeneratedAttribute]
private IFrameworkNameProvider <FrameworkProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IFrameworkCompatibilityProvider <CompatibilityProvider>k__BackingField;
    protected IFrameworkNameProvider FrameworkProvider { get; protected set; }
    protected IFrameworkCompatibilityProvider CompatibilityProvider { get; protected set; }
    public NuspecReader NuspecReader { get; }
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider);
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    [CompilerGeneratedAttribute]
protected IFrameworkNameProvider get_FrameworkProvider();
    [CompilerGeneratedAttribute]
protected void set_FrameworkProvider(IFrameworkNameProvider value);
    [CompilerGeneratedAttribute]
protected IFrameworkCompatibilityProvider get_CompatibilityProvider();
    [CompilerGeneratedAttribute]
protected void set_CompatibilityProvider(IFrameworkCompatibilityProvider value);
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public virtual PackageIdentity GetIdentity();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual Stream GetNuspec();
    public virtual string GetNuspecFile();
    public virtual NuspecReader get_NuspecReader();
    public virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<NuGetFramework> GetSupportedFrameworks();
    public virtual Task`1<IEnumerable`1<NuGetFramework>> GetSupportedFrameworksAsync(CancellationToken cancellationToken);
    public virtual bool IsServiceable();
    public virtual Task`1<bool> IsServiceableAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetItems(string folderName);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetItemsAsync(string folderName, CancellationToken cancellationToken);
    public virtual bool GetDevelopmentDependency();
    public virtual Task`1<bool> GetDevelopmentDependencyAsync(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReaderBase/<GetFileGroups>d__55")]
protected IEnumerable`1<FrameworkSpecificGroup> GetFileGroups(string folder);
    protected NuGetFramework GetFrameworkFromPath(string path, bool allowSubFolders);
    protected static bool IsAllowedBuildFile(string packageId, string path);
    protected static bool IsReferenceAssembly(string path);
    protected static string GetNuspecFile(IEnumerable`1<string> files);
    protected static void ValidatePackageEntry(string normalizedDestination, string normalizedFilePath, PackageIdentity packageIdentity);
    protected string NormalizeDirectoryPath(string path);
    protected static void ValidatePackageEntries(string normalizedDestination, IEnumerable`1<string> packageFiles, PackageIdentity packageIdentity);
    public virtual Task`1<NuspecReader> GetNuspecReaderAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public abstract virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public abstract virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public abstract virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public abstract virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public abstract virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
}
[ExtensionAttribute]
public static class NuGet.Packaging.PackageReaderExtensions : object {
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageReaderExtensions/<GetPackageFilesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<string>> GetPackageFilesAsync(IAsyncPackageCoreReader packageReader, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageReaderExtensions/<GetSatelliteFilesAsync>d__1")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<string>> GetSatelliteFilesAsync(IAsyncPackageContentReader packageReader, string packageLanguage, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{PackageIdentity} {TargetFramework}")]
public class NuGet.Packaging.PackageReference : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <AllowedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUserInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireReinstallation>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public VersionRange AllowedVersions { get; }
    public bool HasAllowedVersions { get; }
    public NuGetFramework TargetFramework { get; }
    public bool IsDevelopmentDependency { get; }
    public bool IsUserInstalled { get; }
    public bool RequireReinstallation { get; }
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation, VersionRange allowedVersions);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public VersionRange get_AllowedVersions();
    public bool get_HasAllowedVersions();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public bool get_IsDevelopmentDependency();
    [CompilerGeneratedAttribute]
public bool get_IsUserInstalled();
    [CompilerGeneratedAttribute]
public bool get_RequireReinstallation();
    public virtual string ToString();
}
public class NuGet.Packaging.PackageReferenceSet : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    public IReadOnlyCollection`1<string> References { get; }
    public NuGetFramework TargetFramework { get; }
    public PackageReferenceSet(IEnumerable`1<string> references);
    public PackageReferenceSet(string targetFramework, IEnumerable`1<string> references);
    public PackageReferenceSet(NuGetFramework targetFramework, IEnumerable`1<string> references);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_References();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReferenceSet/<Validate>d__9")]
public IEnumerable`1<string> Validate();
}
[FlagsAttribute]
public enum NuGet.Packaging.PackageSaveMode : Enum {
    public int value__;
    public static PackageSaveMode None;
    public static PackageSaveMode Nuspec;
    public static PackageSaveMode Nupkg;
    public static PackageSaveMode Files;
    public static PackageSaveMode Defaultv2;
    public static PackageSaveMode Defaultv3;
}
public static class NuGet.Packaging.PackagesConfig : object {
    public static string PackagesNodeName;
    public static string PackageNodeName;
    public static string IdAttributeName;
    public static string VersionAttributeName;
    public static string TargetFrameworkAttributeName;
    public static string MinClientAttributeName;
    public static string developmentDependencyAttributeName;
    public static string allowedVersionsAttributeName;
    public static string RequireInstallAttributeName;
    public static string UserInstalledAttributeName;
    private static PackagesConfig();
    public static bool TryGetAttribute(XElement node, string name, String& value);
    public static bool HasAttributeValue(XElement node, string attributeName, string targetValue, XElement& element);
    public static bool BoolAttribute(XElement node, string name, bool defaultValue);
}
public class NuGet.Packaging.PackagesConfigReader : object {
    private XDocument _doc;
    private IFrameworkNameProvider _frameworkMappings;
    public PackagesConfigReader(XDocument xml);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, XDocument xml);
    public PackagesConfigReader(Stream stream);
    public PackagesConfigReader(Stream stream, bool leaveStreamOpen);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, Stream stream, bool leaveStreamOpen);
    public NuGetVersion GetMinClientVersion();
    public IEnumerable`1<PackageReference> GetPackages();
    public IEnumerable`1<PackageReference> GetPackages(bool allowDuplicatePackageIds);
}
public class NuGet.Packaging.PackagesConfigReaderException : PackagingException {
    public PackagesConfigReaderException(string message);
    public PackagesConfigReaderException(string message, Exception innerException);
}
public class NuGet.Packaging.PackagesConfigWriter : object {
    private Stream _stream;
    private string _filePath;
    private bool _disposed;
    private NuGetVersion _minClientVersion;
    private IFrameworkNameProvider _frameworkMappings;
    private XDocument _xDocument;
    public PackagesConfigWriter(string fullPath, bool createNew);
    public PackagesConfigWriter(string fullPath, bool createNew, IFrameworkNameProvider frameworkMappings);
    public PackagesConfigWriter(Stream stream, bool createNew);
    public PackagesConfigWriter(Stream stream, bool createNew, IFrameworkNameProvider frameworkMappings);
    public void WriteMinClientVersion(NuGetVersion version);
    public void AddPackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageReference entry);
    public void UpdatePackageEntry(PackageReference oldEntry, PackageReference newEntry);
    public void UpdateOrAddPackageEntry(XDocument originalConfig, PackageReference newEntry);
    public void RemovePackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageReference entry);
    private XElement CreateXElementForPackageEntry(PackageReference entry);
    private void CreateDefaultXDocument();
    private XElement EnsurePackagesNode();
    private XElement FindMatchingPackageNode(PackageReference entry, XElement packagesNode);
    private XElement ReplacePackageAttributes(XElement existingNode, PackageReference newEntry);
    private void SortPackageNodes(XElement packagesNode);
    private void WriteFile();
    public void WriteFile(string fullPath);
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.PackagesConfigWriterException : PackagingException {
    public PackagesConfigWriterException(string message);
    public PackagesConfigWriterException(string message, Exception innerException);
}
public class NuGet.Packaging.PackageSigningTelemetryEvent : TelemetryEvent {
    public static string EventName;
    public PackageSignType PackageSignType { get; }
    public NuGetOperationStatus Status { get; }
    public string ExtractionId { get; }
    public PackageSigningTelemetryEvent(PackageSignType packageSignType, NuGetOperationStatus status);
    public PackageSignType get_PackageSignType();
    public NuGetOperationStatus get_Status();
    public string get_ExtractionId();
}
public enum NuGet.Packaging.PackageSignType : Enum {
    public int value__;
    public static PackageSignType Signed;
    public static PackageSignType Unsigned;
}
public static class NuGet.Packaging.PackagingConstants : object {
    public static string AnyFramework;
    public static string AnyCodeLanguage;
    public static string AgnosticFramework;
    public static string TargetFrameworkPropertyKey;
    public static string ContentFilesDefaultBuildAction;
    public static string PackageVerifyDurationName;
    public static string ManifestExtension;
    public static string SnupkgFormat;
    public static string SymbolsNupkgFormat;
    internal static string PackageEmptyFileName;
    private static PackagingConstants();
}
public class NuGet.Packaging.PhysicalPackageFile : object {
    private Func`1<Stream> _streamFactory;
    private string _targetPath;
    private FrameworkName _targetFramework;
    private DateTimeOffset _lastWriteTime;
    [CompilerGeneratedAttribute]
private MemoryStream <MemoryStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectivePath>k__BackingField;
    private MemoryStream MemoryStream { get; private set; }
    public string SourcePath { get; public set; }
    public string TargetPath { get; public set; }
    public string Path { get; }
    public string EffectivePath { get; private set; }
    public FrameworkName TargetFramework { get; }
    public DateTimeOffset LastWriteTime { get; }
    public PhysicalPackageFile(MemoryStream stream);
    internal PhysicalPackageFile(Func`1<Stream> streamFactory);
    [CompilerGeneratedAttribute]
private MemoryStream get_MemoryStream();
    [CompilerGeneratedAttribute]
private void set_MemoryStream(MemoryStream value);
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public void set_SourcePath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EffectivePath();
    [CompilerGeneratedAttribute]
private void set_EffectivePath(string value);
    public sealed virtual FrameworkName get_TargetFramework();
    public sealed virtual Stream GetStream();
    public sealed virtual DateTimeOffset get_LastWriteTime();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Packaging.RepositorySignatureInfo : object {
    [CompilerGeneratedAttribute]
private bool <AllRepositorySigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRepositoryCertificateInfo> <RepositoryCertificateInfos>k__BackingField;
    public bool AllRepositorySigned { get; }
    public IEnumerable`1<IRepositoryCertificateInfo> RepositoryCertificateInfos { get; }
    public RepositorySignatureInfo(bool allRepositorySigned, IEnumerable`1<IRepositoryCertificateInfo> repositoryCertificateInfos);
    [CompilerGeneratedAttribute]
public bool get_AllRepositorySigned();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRepositoryCertificateInfo> get_RepositoryCertificateInfos();
}
public class NuGet.Packaging.RepositorySignatureInfoProvider : object {
    private ConcurrentDictionary`2<string, RepositorySignatureInfo> _dict;
    [CompilerGeneratedAttribute]
private static RepositorySignatureInfoProvider <Instance>k__BackingField;
    public static RepositorySignatureInfoProvider Instance { get; }
    private static RepositorySignatureInfoProvider();
    [CompilerGeneratedAttribute]
public static RepositorySignatureInfoProvider get_Instance();
    public bool TryGetRepositorySignatureInfo(string source, RepositorySignatureInfo& repositorySignatureInfo);
    public void AddOrUpdateRepositorySignatureInfo(string source, RepositorySignatureInfo repositorySignatureInfo);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class NuGet.Packaging.Rules.AnalysisResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string AssemblyDirectlyUnderLibWarning { get; }
    public static string AssemblyOutsideLibWarning { get; }
    public static string BuildConventionIsViolatedWarning { get; }
    public static string DefaultSpecValueWarning { get; }
    public static string DependenciesGroupsForEachTFMBeginningToFiles { get; }
    public static string DependenciesGroupsForEachTFMBeginningToNuspec { get; }
    public static string DependenciesGroupsForEachTFMEndingToFile { get; }
    public static string DependenciesGroupsForEachTFMEndingToNuspec { get; }
    public static string DependenciesGroupsForEachTFMHasCompatMatch { get; }
    public static string DependenciesGroupsForEachTFMHasNoExactMatch { get; }
    public static string FilePathTooLongWarning { get; }
    public static string IconUrlDeprecationWarning { get; }
    public static string InvalidFrameworkWarning { get; }
    public static string InvalidPlaceholderFileWarning { get; }
    public static string InvalidPrereleaseDependencyWarning { get; }
    public static string LegacyVersionWarning { get; }
    public static string LicenseUrlDeprecationWarning { get; }
    public static string Migrator_AssemblyDirectlyUnderLibWarning { get; }
    public static string Migrator_PackageHasContentFolder { get; }
    public static string Migrator_PackageHasInstallScript { get; }
    public static string Migrator_XdtTransformInPackage { get; }
    public static string MisplacedInitScriptWarning { get; }
    public static string MisplacedTransformFileWarning { get; }
    public static string NoRefOrLibFolderInPackage { get; }
    public static string PlaceholderFileInPackageWarning { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarning { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat { get; }
    public static string ScriptOutsideToolsWarning { get; }
    public static string UnrecognizedLicenseIdentifier { get; }
    public static string UnrecognizedScriptWarning { get; }
    public static string UnspecifiedDependencyVersionWarning { get; }
    public static string WinRTObsoleteWarning { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_AssemblyDirectlyUnderLibWarning();
    public static string get_AssemblyOutsideLibWarning();
    public static string get_BuildConventionIsViolatedWarning();
    public static string get_DefaultSpecValueWarning();
    public static string get_DependenciesGroupsForEachTFMBeginningToFiles();
    public static string get_DependenciesGroupsForEachTFMBeginningToNuspec();
    public static string get_DependenciesGroupsForEachTFMEndingToFile();
    public static string get_DependenciesGroupsForEachTFMEndingToNuspec();
    public static string get_DependenciesGroupsForEachTFMHasCompatMatch();
    public static string get_DependenciesGroupsForEachTFMHasNoExactMatch();
    public static string get_FilePathTooLongWarning();
    public static string get_IconUrlDeprecationWarning();
    public static string get_InvalidFrameworkWarning();
    public static string get_InvalidPlaceholderFileWarning();
    public static string get_InvalidPrereleaseDependencyWarning();
    public static string get_LegacyVersionWarning();
    public static string get_LicenseUrlDeprecationWarning();
    public static string get_Migrator_AssemblyDirectlyUnderLibWarning();
    public static string get_Migrator_PackageHasContentFolder();
    public static string get_Migrator_PackageHasInstallScript();
    public static string get_Migrator_XdtTransformInPackage();
    public static string get_MisplacedInitScriptWarning();
    public static string get_MisplacedTransformFileWarning();
    public static string get_NoRefOrLibFolderInPackage();
    public static string get_PlaceholderFileInPackageWarning();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarning();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat();
    public static string get_ScriptOutsideToolsWarning();
    public static string get_UnrecognizedLicenseIdentifier();
    public static string get_UnrecognizedScriptWarning();
    public static string get_UnspecifiedDependencyVersionWarning();
    public static string get_WinRTObsoleteWarning();
}
internal class NuGet.Packaging.Rules.ContentFolderInPackageReferenceProjectRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public ContentFolderInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
public class NuGet.Packaging.Rules.DefaultManifestValuesRule : object {
    internal static Uri SampleProjectUrl;
    internal static Uri SampleLicenseUrl;
    internal static Uri SampleIconUrl;
    internal static string SampleTags;
    internal static string SampleReleaseNotes;
    internal static string SampleDescription;
    internal static string SampleManifestDependencyId;
    internal static string SampleManifestDependencyVersion;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public DefaultManifestValuesRule(string messageFormat);
    private static DefaultManifestValuesRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.DefaultManifestValuesRule/<Validate>d__12")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreateIssueFor(string field, string value);
}
internal class NuGet.Packaging.Rules.DependenciesGroupsForEachTFMRule : object {
    private static NuGetFramework Net00;
    public string MessageFormat { get; }
    private string CompatMatchFoundWarningMessageFormat { get; }
    private static DependenciesGroupsForEachTFMRule();
    public sealed virtual string get_MessageFormat();
    private string get_CompatMatchFoundWarningMessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader package);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(HashSet`1<NuGetFramework> compatNotExactMatches, HashSet`1<NuGetFramework> noExactMatchesFromFile, HashSet`1<NuGetFramework> noExactMatchesFromNuspec);
    internal ValueTuple`3<HashSet`1<NuGetFramework>, HashSet`1<NuGetFramework>, HashSet`1<NuGetFramework>> Categorize(IEnumerable`1<string> files, IEnumerable`1<NuGetFramework> tfmsFromNuspec);
    internal ValueTuple`2<string, string> GenerateWarningString(ICollection`1<NuGetFramework> noExactMatchesFromFile, ICollection`1<NuGetFramework> noExactMatchesFromNuspec, ICollection`1<NuGetFramework> compatNotExactMatches);
    private static IEnumerable`1<NuGetFramework> ExtractTFMsFromNuspec(Stream packageNuspecStream);
}
internal static class NuGet.Packaging.Rules.FrameworkNameValidatorUtility : object {
    internal static bool IsValidFrameworkName(NuGetFramework framework);
    internal static bool IsValidFrameworkName(string path);
    internal static bool IsValidCultureName(PackageArchiveReader builder, string name);
}
public class NuGet.Packaging.Rules.IconUrlDeprecationWarning : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public IconUrlDeprecationWarning(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.IconUrlDeprecationWarning/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.InitScriptNotUnderToolsRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InitScriptNotUnderToolsRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InitScriptNotUnderToolsRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssue(string file);
}
internal class NuGet.Packaging.Rules.InstallScriptInPackageReferenceProjectRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InstallScriptInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.InvalidFrameworkFolderRule : object {
    private static string LibDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidFrameworkFolderRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssue(string target);
}
internal class NuGet.Packaging.Rules.InvalidPlaceholderFileRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidPlaceholderFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InvalidPlaceholderFileRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForPlaceholderFile(string target);
}
internal class NuGet.Packaging.Rules.InvalidPrereleaseDependencyRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidPrereleaseDependencyRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InvalidPrereleaseDependencyRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private bool IsPrereleaseDependency(PackageDependency dependency);
    private PackagingLogMessage CreatePackageIssueForPrereleaseDependency(string dependency);
}
public interface NuGet.Packaging.Rules.IPackageRule {
    public string MessageFormat { get; }
    public abstract virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    public abstract virtual string get_MessageFormat();
}
public class NuGet.Packaging.Rules.LicenseUrlDeprecationWarning : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public LicenseUrlDeprecationWarning(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.LicenseUrlDeprecationWarning/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    private static IEnumerable`1<string> ValidFolders { get; }
    public MisplacedAssemblyOutsideLibRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForAssembliesOutsideLib(string target);
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule/<get_ValidFolders>d__7")]
private static IEnumerable`1<string> get_ValidFolders();
}
internal class NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    private static IEnumerable`1<string> ValidFolders { get; }
    public MisplacedAssemblyUnderLibRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForAssembliesUnderLib(string target);
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule/<get_ValidFolders>d__7")]
private static IEnumerable`1<string> get_ValidFolders();
}
internal class NuGet.Packaging.Rules.MisplacedScriptFileRule : object {
    private static string ScriptExtension;
    private static string ToolsDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MisplacedScriptFileRule(string messageFormat);
    private static MisplacedScriptFileRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedScriptFileRule/<Validate>d__6")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForMisplacedScript(string target);
}
internal class NuGet.Packaging.Rules.MisplacedTransformFileRule : object {
    private static string CodeTransformExtension;
    private static string ConfigTransformExtension;
    private static string ContentDirectory;
    private static string ContentFilesDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MisplacedTransformFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedTransformFileRule/<Validate>d__8")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForMisplacedContent(string path);
}
internal class NuGet.Packaging.Rules.NoRefOrLibFolderInPackageRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public NoRefOrLibFolderInPackageRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader package);
    internal IEnumerable`1<PackagingLogMessage> Validate(IEnumerable`1<string> files);
    private ValueTuple`2<string, string> GenerateWarningString(String[] possibleFrameworks);
    private static string CreateDirectoriesMessage(String[] possibleFrameworks);
}
public class NuGet.Packaging.Rules.PathTooLongRule : object {
    private static int _pathLenghtWarningThreshold;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public PathTooLongRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.PathTooLongRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForPathTooLong(string target);
}
internal class NuGet.Packaging.Rules.ReferencesInNuspecMatchRefAssetsRule : object {
    private string _addToRefFormat;
    private string _addToNuspecFormat;
    private string _addToNuspecNoTfmFormat;
    public string MessageFormat { get; }
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal IDictionary`2<string, IEnumerable`1<string>> GetReferencesFromNuspec(Stream nuspecStream);
    internal IEnumerable`1<MissingReference> Compare(IDictionary`2<string, IEnumerable`1<string>> nuspecReferences, IEnumerable`1<string> refFiles);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(IEnumerable`1<MissingReference> missingReferences);
    internal List`1<string> GetAllKeys(IEnumerable`1<IGrouping`2<string, string>> filesByTFM);
}
public static class NuGet.Packaging.Rules.RuleSet : object {
    private static ReadOnlyCollection`1<IPackageRule> _packageCreationRules;
    private static ReadOnlyCollection`1<IPackageRule> _packagesConfigToPackageReferenceMigrationRuleSet;
    public static IEnumerable`1<IPackageRule> PackageCreationRuleSet { get; }
    public static IEnumerable`1<IPackageRule> PackagesConfigToPackageReferenceMigrationRuleSet { get; }
    private static RuleSet();
    public static IEnumerable`1<IPackageRule> get_PackageCreationRuleSet();
    public static IEnumerable`1<IPackageRule> get_PackagesConfigToPackageReferenceMigrationRuleSet();
}
internal class NuGet.Packaging.Rules.UnrecognizedLicenseIdentifierRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnrecognizedLicenseIdentifierRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private void ValidateAllLicenseLeafs(NuGetLicenseExpression expression, IList`1<PackagingLogMessage> logMessages);
}
internal class NuGet.Packaging.Rules.UnrecognizedScriptFileRule : object {
    private static string ScriptExtension;
    private static string ToolsDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnrecognizedScriptFileRule(string messageFormat);
    private static UnrecognizedScriptFileRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.UnrecognizedScriptFileRule/<Validate>d__6")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForUnrecognizedScripts(string target);
}
public class NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnspecifiedDependencyVersionRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.UpholdBuildConventionRule : object {
    private static ManagedCodeConventions ManagedCodeConventions;
    private String[] _folders;
    public string MessageFormat { get; }
    private static UpholdBuildConventionRule();
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(IEnumerable`1<ConventionViolator> conventionViolators);
    internal IEnumerable`1<ConventionViolator> IdentifyViolators(IEnumerable`1<string> files, string packageId);
    internal string GetFolderName(string filePath);
    [CompilerGeneratedAttribute]
private string <IdentifyViolators>b__6_0(string t);
}
internal class NuGet.Packaging.Rules.WinRTNameIsObsoleteRule : object {
    private static String[] Prefixes;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public WinRTNameIsObsoleteRule(string messageFormat);
    private static WinRTNameIsObsoleteRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.WinRTNameIsObsoleteRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreateIssue(string file);
}
internal class NuGet.Packaging.Rules.XdtTransformInPackageReferenceProjectRule : object {
    private static string ConfigTransformExtension;
    private static string InstallXdtExtension;
    private static string UninstallXdtExtension;
    private static string ContentDirectory;
    private static string ContentFilesDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public XdtTransformInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.XdtTransformInPackageReferenceProjectRule/<Validate>d__9")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForTransformFiles(string path);
}
public class NuGet.Packaging.Sha512HashFunction : object {
    private Byte[] _hash;
    private SHA512 _hashFunc;
    public sealed virtual void Update(Byte[] data, int offset, int count);
    public Byte[] GetHashBytes();
    public sealed virtual string GetHash();
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.Signing.Accuracy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Seconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Milliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Microseconds>k__BackingField;
    public Nullable`1<int> Seconds { get; }
    public Nullable`1<int> Milliseconds { get; }
    public Nullable`1<int> Microseconds { get; }
    private Accuracy(Nullable`1<int> seconds, Nullable`1<int> milliseconds, Nullable`1<int> microseconds);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Seconds();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Milliseconds();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Microseconds();
    public static Accuracy Read(Byte[] bytes);
    internal static Accuracy Read(DerSequenceReader reader);
    public Nullable`1<long> GetTotalMicroseconds();
}
public class NuGet.Packaging.Signing.AlgorithmIdentifier : object {
    [CompilerGeneratedAttribute]
private Oid <Algorithm>k__BackingField;
    public Oid Algorithm { get; }
    internal AlgorithmIdentifier(Oid algorithm);
    [CompilerGeneratedAttribute]
public Oid get_Algorithm();
    public static AlgorithmIdentifier Read(Byte[] bytes);
    internal static AlgorithmIdentifier Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
public class NuGet.Packaging.Signing.AllowListVerificationProvider : object {
    private IReadOnlyCollection`1<VerificationAllowListEntry> _allowList;
    private string _emptyListErrorMessage;
    private string _noMatchErrorMessage;
    private bool _requireNonEmptyAllowList;
    public AllowListVerificationProvider(IReadOnlyCollection`1<VerificationAllowListEntry> allowList, bool requireNonEmptyAllowList, string emptyListErrorMessage, string noMatchErrorMessage);
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    private PackageVerificationResult VerifyAllowList(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings);
    private bool IsSignatureAllowed(PrimarySignature signature, IReadOnlyCollection`1<VerificationAllowListEntry> allowList);
    private static bool ShouldVerifyOwners(TrustedSignerAllowListEntry entry, IRepositorySignature repoSignature, IReadOnlyList`1& allowedOwners, IReadOnlyList`1& actualOwners);
    private static bool IsSignatureTargeted(VerificationTarget target, Signature signature);
    private static string GetCertificateFingerprint(Signature signature, HashAlgorithmName fingerprintAlgorithm, IDictionary`2<HashAlgorithmName, string> CertificateFingerprintLookUp);
}
[ExtensionAttribute]
public static class NuGet.Packaging.Signing.AttributeUtility : object {
    public static CryptographicAttributeObject CreateCommitmentTypeIndication(SignatureType type);
    public static SignatureType GetSignatureType(CryptographicAttributeObjectCollection signedAttributes);
    public static CryptographicAttributeObject CreateNuGetV3ServiceIndexUrl(Uri v3ServiceIndexUrl);
    public static Uri GetNuGetV3ServiceIndexUrl(CryptographicAttributeObjectCollection signedAttributes);
    public static CryptographicAttributeObject CreateNuGetPackageOwners(IReadOnlyList`1<string> packageOwners);
    public static IReadOnlyList`1<string> GetNuGetPackageOwners(CryptographicAttributeObjectCollection signedAttributes);
    public static SignatureType GetSignatureType(string oid);
    public static string GetSignatureTypeOid(SignatureType signatureType);
    public static CryptographicAttributeObject CreateSigningCertificateV2(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    [ExtensionAttribute]
internal static CryptographicAttributeObject GetAttributeOrDefault(CryptographicAttributeObjectCollection attributes, string oid);
    private static void ThrowInvalidAttributeException(CryptographicAttributeObject attribute);
    [ExtensionAttribute]
private static List`1<AsnEncodedData> ToList(AsnEncodedDataCollection collection);
    private static IEnumerable`1<SignatureType> GetCommitmentTypeIndicationRawValues(CryptographicAttributeObject attribute);
    [ExtensionAttribute]
public static CryptographicAttributeObject GetAttribute(CryptographicAttributeObjectCollection attributes, string oid);
    [ExtensionAttribute]
public static IEnumerable`1<CryptographicAttributeObject> GetAttributes(CryptographicAttributeObjectCollection attributes, string oid);
}
public class NuGet.Packaging.Signing.AuthorPrimarySignature : PrimarySignature {
    public string FriendlyName { get; }
    public AuthorPrimarySignature(SignedCms signedCms);
    public virtual string get_FriendlyName();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
}
public class NuGet.Packaging.Signing.AuthorSignPackageRequest : SignPackageRequest {
    public SignatureType SignatureType { get; }
    public AuthorSignPackageRequest(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public AuthorSignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm);
    public virtual SignatureType get_SignatureType();
}
internal class NuGet.Packaging.Signing.BLOB : ValueType {
    public UInt32 cbData;
    public IntPtr pbData;
    public void Dispose();
}
internal class NuGet.Packaging.Signing.CentralDirectoryHeader : object {
    internal static UInt32 SizeInBytesOfFixedLengthFields;
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <VersionMadeBy>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GeneralPurposeBitFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExtraFieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileCommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DiskNumberStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <InternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ExternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RelativeOffsetOfLocalHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtraField>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetFromStart>k__BackingField;
    internal ushort VersionMadeBy { get; private set; }
    internal ushort VersionNeededToExtract { get; private set; }
    internal ushort GeneralPurposeBitFlag { get; private set; }
    internal ushort CompressionMethod { get; private set; }
    internal ushort LastModFileTime { get; private set; }
    internal ushort LastModFileDate { get; private set; }
    internal UInt32 Crc32 { get; private set; }
    internal UInt32 CompressedSize { get; private set; }
    internal UInt32 UncompressedSize { get; private set; }
    internal ushort FileNameLength { get; private set; }
    internal ushort ExtraFieldLength { get; private set; }
    internal ushort FileCommentLength { get; private set; }
    internal ushort DiskNumberStart { get; private set; }
    internal ushort InternalFileAttributes { get; private set; }
    internal UInt32 ExternalFileAttributes { get; private set; }
    internal UInt32 RelativeOffsetOfLocalHeader { get; private set; }
    internal Byte[] FileName { get; private set; }
    internal Byte[] ExtraField { get; private set; }
    internal Byte[] FileComment { get; private set; }
    internal long OffsetFromStart { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_VersionMadeBy();
    [CompilerGeneratedAttribute]
private void set_VersionMadeBy(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_GeneralPurposeBitFlag();
    [CompilerGeneratedAttribute]
private void set_GeneralPurposeBitFlag(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileTime();
    [CompilerGeneratedAttribute]
private void set_LastModFileTime(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileDate();
    [CompilerGeneratedAttribute]
private void set_LastModFileDate(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileNameLength();
    [CompilerGeneratedAttribute]
private void set_FileNameLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_ExtraFieldLength();
    [CompilerGeneratedAttribute]
private void set_ExtraFieldLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_FileCommentLength();
    [CompilerGeneratedAttribute]
private void set_FileCommentLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_DiskNumberStart();
    [CompilerGeneratedAttribute]
private void set_DiskNumberStart(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_InternalFileAttributes();
    [CompilerGeneratedAttribute]
private void set_InternalFileAttributes(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ExternalFileAttributes();
    [CompilerGeneratedAttribute]
private void set_ExternalFileAttributes(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_RelativeOffsetOfLocalHeader();
    [CompilerGeneratedAttribute]
private void set_RelativeOffsetOfLocalHeader(UInt32 value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ExtraField();
    [CompilerGeneratedAttribute]
private void set_ExtraField(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(Byte[] value);
    [CompilerGeneratedAttribute]
internal long get_OffsetFromStart();
    [CompilerGeneratedAttribute]
private void set_OffsetFromStart(long value);
    internal UInt32 GetSizeInBytes();
    internal static bool TryRead(BinaryReader reader, CentralDirectoryHeader& header);
}
public class NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata : object {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetToLocalFileHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileEntryTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPackageSignatureFile>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ChangeInOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInHeaders>k__BackingField;
    public long Position { get; public set; }
    public long OffsetToLocalFileHeader { get; public set; }
    public long FileEntryTotalSize { get; public set; }
    public bool IsPackageSignatureFile { get; public set; }
    public long HeaderSize { get; public set; }
    public long ChangeInOffset { get; public set; }
    public int IndexInHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    [CompilerGeneratedAttribute]
public long get_OffsetToLocalFileHeader();
    [CompilerGeneratedAttribute]
public void set_OffsetToLocalFileHeader(long value);
    [CompilerGeneratedAttribute]
public long get_FileEntryTotalSize();
    [CompilerGeneratedAttribute]
public void set_FileEntryTotalSize(long value);
    [CompilerGeneratedAttribute]
public bool get_IsPackageSignatureFile();
    [CompilerGeneratedAttribute]
public void set_IsPackageSignatureFile(bool value);
    [CompilerGeneratedAttribute]
public long get_HeaderSize();
    [CompilerGeneratedAttribute]
public void set_HeaderSize(long value);
    [CompilerGeneratedAttribute]
public long get_ChangeInOffset();
    [CompilerGeneratedAttribute]
public void set_ChangeInOffset(long value);
    [CompilerGeneratedAttribute]
public int get_IndexInHeaders();
    [CompilerGeneratedAttribute]
public void set_IndexInHeaders(int value);
}
internal class NuGet.Packaging.Signing.CERT_CONTEXT : ValueType {
    public UInt32 dwCertEncodingType;
    public IntPtr pbCertEncoded;
    public UInt32 cbCertEncoded;
    public IntPtr pCertInfo;
    public IntPtr hCertStore;
}
internal class NuGet.Packaging.Signing.CERT_ID : ValueType {
    internal UInt32 dwIdChoice;
    internal BLOB KeyId;
}
public static class NuGet.Packaging.Signing.CertificateChainUtility : object {
    internal static X509ChainStatusFlags DefaultObservedStatusFlags;
    public static IX509CertificateChain GetCertificateChain(X509Certificate2 certificate, X509Certificate2Collection extraStore, ILogger logger, CertificateType certificateType);
    public static IX509CertificateChain GetCertificateChain(X509Chain x509Chain);
    private static void GetChainStatusFlags(X509Certificate2 certificate, CertificateType certificateType, X509ChainStatusFlags& errorStatusFlags, X509ChainStatusFlags& warningStatusFlags);
    internal static void SetCertBuildChainPolicy(X509ChainPolicy policy, X509Certificate2Collection additionalCertificates, DateTime verificationTime, CertificateType certificateType);
    internal static bool BuildCertificateChain(X509Chain chain, X509Certificate2 certificate, X509ChainStatus[]& status);
    internal static bool ChainStatusListIncludesStatus(X509ChainStatus[] chainStatuses, X509ChainStatusFlags status, IEnumerable`1& chainStatus);
    internal static bool TryGetStatusMessage(X509ChainStatus[] chainStatuses, X509ChainStatusFlags status, IEnumerable`1& messages);
    internal static IEnumerable`1<string> GetMessagesFromChainStatuses(IEnumerable`1<X509ChainStatus> chainStatuses);
}
public class NuGet.Packaging.Signing.CertificateHashAllowListEntry : VerificationAllowListEntry {
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <FingerprintAlgorithm>k__BackingField;
    public string Fingerprint { get; }
    public HashAlgorithmName FingerprintAlgorithm { get; }
    public CertificateHashAllowListEntry(VerificationTarget target, SignaturePlacement placement, string fingerprint, HashAlgorithmName algorithm);
    [CompilerGeneratedAttribute]
public string get_Fingerprint();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_FingerprintAlgorithm();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum NuGet.Packaging.Signing.CertificateType : Enum {
    public int value__;
    public static CertificateType Signature;
    public static CertificateType Timestamp;
}
public static class NuGet.Packaging.Signing.CertificateUtility : object {
    private static int _limit;
    public static string X509Certificate2ToString(X509Certificate2 cert, HashAlgorithmName fingerprintAlgorithm);
    private static void X509Certificate2ToString(X509Certificate2 cert, StringBuilder certStringBuilder, HashAlgorithmName fingerprintAlgorithm, string indentation);
    public static string X509Certificate2CollectionToString(X509Certificate2Collection certCollection, HashAlgorithmName fingerprintAlgorithm);
    public static string X509ChainToString(X509Chain chain, HashAlgorithmName fingerprintAlgorithm);
    public static bool IsSignatureAlgorithmSupported(X509Certificate2 certificate);
    public static bool IsCertificatePublicKeyValid(X509Certificate2 certificate);
    public static bool HasLifetimeSigningEku(X509Certificate2 certificate);
    public static bool HasExtendedKeyUsage(X509Certificate2 certificate, string ekuOid);
    public static bool IsValidForPurposeFast(X509Certificate2 certificate, string ekuOid);
    public static bool IsCertificateValidityPeriodInTheFuture(X509Certificate2 certificate);
    public static bool IsDateInsideValidityPeriod(X509Certificate2 certificate, DateTimeOffset date);
    public static Byte[] GetHash(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public static string GetHashString(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public static bool IsSelfIssued(X509Certificate2 certificate);
    public static IReadOnlyList`1<Byte[]> GetRawDataForCollection(X509Certificate2Collection certificates);
}
public class NuGet.Packaging.Signing.ClientPolicyContext : object {
    [CompilerGeneratedAttribute]
private SignatureValidationMode <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedPackageVerifierSettings <VerifierSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<TrustedSignerAllowListEntry> <AllowList>k__BackingField;
    public SignatureValidationMode Policy { get; }
    public SignedPackageVerifierSettings VerifierSettings { get; }
    public IReadOnlyCollection`1<TrustedSignerAllowListEntry> AllowList { get; }
    internal ClientPolicyContext(SignatureValidationMode policy, IReadOnlyCollection`1<TrustedSignerAllowListEntry> allowList);
    [CompilerGeneratedAttribute]
public SignatureValidationMode get_Policy();
    [CompilerGeneratedAttribute]
public SignedPackageVerifierSettings get_VerifierSettings();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<TrustedSignerAllowListEntry> get_AllowList();
    public static ClientPolicyContext GetClientPolicy(ISettings settings, ILogger logger);
}
internal enum NuGet.Packaging.Signing.CMSG_CONTROL_TYPE : Enum {
    public UInt32 value__;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_SIGNATURE;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_HASH;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_SIGNER;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_SIGNER;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CRL;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_CRL;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_ATTR_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_ATTR_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_KEY_TRANS_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_KEY_AGREE_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_MAIL_LIST_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_SIGNATURE_EX;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CMS_SIGNER_INFO;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ENABLE_STRONG_SIGNATURE;
}
internal class NuGet.Packaging.Signing.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA : ValueType {
    internal UInt32 cbSize;
    internal UInt32 dwSignerIndex;
    internal CRYPT_INTEGER_BLOB BLOB;
}
internal class NuGet.Packaging.Signing.CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA : ValueType {
    internal UInt32 cbSize;
    internal UInt32 dwSignerIndex;
    internal UInt32 dwUnauthAttrIndex;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.CMSG_ENCODING : Enum {
    public UInt32 value__;
    public static CMSG_ENCODING X509_ASN_ENCODING;
    public static CMSG_ENCODING PKCS_7_ASN_ENCODING;
    public static CMSG_ENCODING Any;
}
internal enum NuGet.Packaging.Signing.CMSG_GETPARAM_TYPE : Enum {
    public UInt32 value__;
    public static CMSG_GETPARAM_TYPE CMSG_TYPE_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CONTENT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_BARE_CONTENT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_INNER_CONTENT_TYPE_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_CERT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_HASH_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_AUTH_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_UNAUTH_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CERT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CERT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CRL_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CRL_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENVELOPE_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_HASH_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_HASH_DATA_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_COMPUTED_HASH_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENCRYPT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENCRYPTED_DIGEST;
    public static CMSG_GETPARAM_TYPE CMSG_ENCODED_SIGNER;
    public static CMSG_GETPARAM_TYPE CMSG_ENCODED_MESSAGE;
    public static CMSG_GETPARAM_TYPE CMSG_VERSION_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ATTR_CERT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ATTR_CERT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_UNPROTECTED_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_CERT_ID_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_SIGNER_INFO_PARAM;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.CMSG_OPENTODECODE_FLAGS : Enum {
    public UInt32 value__;
    public static CMSG_OPENTODECODE_FLAGS None;
    public static CMSG_OPENTODECODE_FLAGS CMSG_DETACHED_FLAG;
    public static CMSG_OPENTODECODE_FLAGS CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
}
internal class NuGet.Packaging.Signing.CMSG_SIGNED_ENCODE_INFO : ValueType {
    internal int cbSize;
    internal int cSigners;
    internal IntPtr rgSigners;
    internal int cCertEncoded;
    internal IntPtr rgCertEncoded;
    internal int cCrlEncoded;
    internal IntPtr rgCrlEncoded;
    internal int cAttrCertEncoded;
    internal IntPtr rgAttrCertEncoded;
}
internal class NuGet.Packaging.Signing.CMSG_SIGNER_ENCODE_INFO : ValueType {
    internal UInt32 cbSize;
    internal IntPtr pCertInfo;
    internal IntPtr hCryptProvOrhNCryptKey;
    internal int dwKeySpec;
    internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    internal IntPtr pvHashAuxInfo;
    internal int cAuthAttr;
    internal IntPtr rgAuthAttr;
    internal int cUnauthAttr;
    internal IntPtr rgUnauthAttr;
    internal CERT_ID SignerId;
    internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    internal IntPtr pvHashEncryptionAuxInfo;
    public void Dispose();
}
internal class NuGet.Packaging.Signing.CMSG_SIGNER_INFO : ValueType {
    internal UInt32 dwVersion;
    internal CRYPTOAPI_BLOB Issuer;
    internal CRYPTOAPI_BLOB SerialNumber;
    internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    internal CRYPTOAPI_BLOB EncryptedHash;
    internal CRYPT_ATTRIBUTES AuthAttrs;
    internal CRYPT_ATTRIBUTES UnauthAttrs;
}
public class NuGet.Packaging.Signing.CommitmentTypeIndication : object {
    [CompilerGeneratedAttribute]
private Oid <CommitmentTypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CommitmentTypeQualifier> <Qualifiers>k__BackingField;
    public Oid CommitmentTypeId { get; }
    public IReadOnlyList`1<CommitmentTypeQualifier> Qualifiers { get; }
    private CommitmentTypeIndication(Oid commitmentTypeId, IReadOnlyList`1<CommitmentTypeQualifier> qualifiers);
    [CompilerGeneratedAttribute]
public Oid get_CommitmentTypeId();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CommitmentTypeQualifier> get_Qualifiers();
    public static CommitmentTypeIndication Create(Oid commitmentTypeId);
    public static CommitmentTypeIndication Read(Byte[] bytes);
    internal static CommitmentTypeIndication Read(DerSequenceReader reader);
    internal Byte[] Encode();
}
public class NuGet.Packaging.Signing.CommitmentTypeQualifier : object {
    [CompilerGeneratedAttribute]
private Oid <CommitmentTypeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Qualifier>k__BackingField;
    public Oid CommitmentTypeIdentifier { get; }
    public Byte[] Qualifier { get; }
    private CommitmentTypeQualifier(Oid commitmentTypeIdentifier, Byte[] qualifier);
    [CompilerGeneratedAttribute]
public Oid get_CommitmentTypeIdentifier();
    [CompilerGeneratedAttribute]
public Byte[] get_Qualifier();
    public static CommitmentTypeQualifier Read(Byte[] bytes);
    internal static CommitmentTypeQualifier Read(DerSequenceReader reader);
    internal Byte[] Encode();
}
public static class NuGet.Packaging.Signing.Crc32 : object {
    private static UInt32[] CrcLookUpTable;
    private static bool CrcLookUptableComputed;
    private static UInt32 Crc32Polynomial;
    private static Crc32();
    [CLSCompliantAttribute("False")]
public static UInt32 CalculateCrc(Byte[] data);
    private static UInt32 UpdateCrc(UInt32 crc, Byte[] buf, int len);
    private static void ComputeCrcLookUpTable();
}
internal class NuGet.Packaging.Signing.CRYPT_ALGORITHM_IDENTIFIER : ValueType {
    public string pszObjId;
    public CRYPT_INTEGER_BLOB Parameters;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTE : ValueType {
    internal IntPtr pszObjId;
    internal UInt32 cValue;
    internal IntPtr rgValue;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTE_STRING : ValueType {
    internal string pszObjId;
    internal UInt32 cValue;
    internal IntPtr rgValue;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTES : ValueType {
    internal UInt32 cAttr;
    internal IntPtr rgAttr;
}
internal class NuGet.Packaging.Signing.CRYPT_INTEGER_BLOB : ValueType {
    internal UInt32 cbData;
    internal IntPtr pbData;
}
internal static class NuGet.Packaging.Signing.DerEncoding.DerEncoder : object {
    private static byte ConstructedFlag;
    private static byte ConstructedSequenceTag;
    private static byte ConstructedSetTag;
    private static Byte[][] s_nullTlv;
    private static DerEncoder();
    private static Byte[] EncodeLength(int length);
    internal static Byte[][] SegmentedEncodeBoolean(bool value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(UInt32 value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes, int offset, int count);
    internal static Byte[][] SegmentedEncodeBitString(Byte[][][] childSegments);
    internal static Byte[][] SegmentedEncodeBitString(Byte[] data);
    internal static Byte[][] SegmentedEncodeBitString(int unusedBits, Byte[] data);
    internal static Byte[][] SegmentedEncodeNamedBitList(Byte[] bigEndianBytes, int namedBitsCount);
    internal static Byte[][] SegmentedEncodeOctetString(Byte[] data);
    internal static Byte[][] SegmentedEncodeNull();
    internal static Byte[] EncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeOid(Oid oid);
    internal static Byte[][] SegmentedEncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars, int offset, int count);
    internal static Byte[][] ConstructSegmentedSequence(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSequence(IEnumerable`1<Byte[][]> items);
    internal static Byte[][] ConstructSegmentedContextSpecificValue(int contextId, Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSet(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedPresortedSet(Byte[][][] items);
    internal static bool IsValidPrintableString(Char[] chars);
    internal static bool IsValidPrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeUtcTime(DateTime utcTime);
    internal static Byte[][] SegmentedEncodeGeneralizedTime(DateTime utcTime);
    internal static Byte[] ConstructSequence(Byte[][][] items);
    internal static Byte[] ConstructSequence(IEnumerable`1<Byte[][]> items);
    private static BigInteger ParseOidRid(string oidValue, Int32& startIndex);
    private static int AtoI(char c);
    private static void EncodeRid(List`1<byte> encodedData, BigInteger& rid);
    private static bool IsPrintableStringCharacter(char c);
    private static Byte[] ConcatenateArrays(Byte[][][] segments);
    private static Byte[] ConcatenateArrays(IEnumerable`1<Byte[][]> segments);
}
public class NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime : object {
    [CompilerGeneratedAttribute]
private DateTime <DateTime>k__BackingField;
    public DateTime DateTime { get; }
    private DerGeneralizedTime(DateTime datetime);
    [CompilerGeneratedAttribute]
public DateTime get_DateTime();
    public static DerGeneralizedTime Read(string decodedTime);
}
internal class NuGet.Packaging.Signing.DerEncoding.DerSequenceReader : object {
    internal static byte ContextSpecificTagFlag;
    internal static byte ConstructedFlag;
    internal static byte ContextSpecificConstructedTag0;
    internal static byte ContextSpecificConstructedTag1;
    internal static byte ContextSpecificConstructedTag2;
    internal static byte ContextSpecificConstructedTag3;
    internal static byte ContextSpecificConstructedTag4;
    internal static byte ConstructedSequence;
    internal static byte TagClassMask;
    internal static byte TagNumberMask;
    internal static DateTimeFormatInfo s_validityDateTimeFormatInfo;
    private Byte[] _data;
    private int _end;
    private int _position;
    [CompilerGeneratedAttribute]
private int <ContentLength>k__BackingField;
    internal int ContentLength { get; private set; }
    internal bool HasData { get; }
    private DerSequenceReader(bool startAtPayload, Byte[] data, int offset, int length);
    internal DerSequenceReader(Byte[] data);
    internal DerSequenceReader(Byte[] data, int offset, int length);
    private DerSequenceReader(DerTag tagToEat, Byte[] data, int offset, int length);
    [CompilerGeneratedAttribute]
internal int get_ContentLength();
    [CompilerGeneratedAttribute]
private void set_ContentLength(int value);
    internal static DerSequenceReader CreateForPayload(Byte[] payload);
    internal bool get_HasData();
    internal byte PeekTag();
    internal bool HasTag(DerTag expectedTag);
    internal bool HasTag(byte expectedTag);
    internal void SkipValue();
    internal void ValidateAndSkipDerValue();
    internal Byte[] ReadNextEncodedValue();
    internal bool ReadBoolean();
    internal Byte[] ReadValue(DerTag tag);
    internal int ReadInteger();
    internal Byte[] ReadIntegerBytes();
    internal Byte[] ReadBitString();
    internal Byte[] ReadOctetString();
    internal string ReadOidAsString();
    internal Oid ReadOid();
    internal string ReadUtf8String();
    private DerSequenceReader ReadCollectionWithTag(DerTag expected);
    internal DerSequenceReader ReadSequence();
    internal DerSequenceReader ReadSet();
    internal string ReadPrintableString();
    internal string ReadIA5String();
    internal DateTime ReadX509Date();
    internal DateTime ReadUtcTime();
    internal DateTime ReadGeneralizedTime();
    internal string ReadBMPString();
    internal void ReadNull();
    private static string TrimTrailingNulls(string value);
    private DateTime ReadTime(DerTag timeTag, string formatString);
    private Byte[] ReadContentAsBytes();
    private void EatTag(DerTag expected);
    private static void CheckTag(DerTag expected, Byte[] data, int position);
    private int EatLength();
    private static int ScanContentLength(Byte[] data, int offset, int end, Int32& bytesConsumed);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Signing.DerEncoding.SR : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Invalid_IA5String();
}
internal class NuGet.Packaging.Signing.EndOfCentralDirectoryRecord : object {
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <NumberOfThisDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfTheDiskWithTheStartOfTheCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CountOfEntriesInCentralDirectoryOnThisDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CountOfEntriesInCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SizeOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OffsetOfStartOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileCommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetFromStart>k__BackingField;
    internal ushort NumberOfThisDisk { get; private set; }
    internal ushort NumberOfTheDiskWithTheStartOfTheCentralDirectory { get; private set; }
    internal ushort CountOfEntriesInCentralDirectoryOnThisDisk { get; private set; }
    internal ushort CountOfEntriesInCentralDirectory { get; private set; }
    internal UInt32 SizeOfCentralDirectory { get; private set; }
    internal UInt32 OffsetOfStartOfCentralDirectory { get; private set; }
    internal ushort FileCommentLength { get; private set; }
    internal Byte[] FileComment { get; private set; }
    internal long OffsetFromStart { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_NumberOfThisDisk();
    [CompilerGeneratedAttribute]
private void set_NumberOfThisDisk(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_NumberOfTheDiskWithTheStartOfTheCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_NumberOfTheDiskWithTheStartOfTheCentralDirectory(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CountOfEntriesInCentralDirectoryOnThisDisk();
    [CompilerGeneratedAttribute]
private void set_CountOfEntriesInCentralDirectoryOnThisDisk(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CountOfEntriesInCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_CountOfEntriesInCentralDirectory(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_SizeOfCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_SizeOfCentralDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_OffsetOfStartOfCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_OffsetOfStartOfCentralDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileCommentLength();
    [CompilerGeneratedAttribute]
private void set_FileCommentLength(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(Byte[] value);
    [CompilerGeneratedAttribute]
internal long get_OffsetFromStart();
    [CompilerGeneratedAttribute]
private void set_OffsetFromStart(long value);
    internal static EndOfCentralDirectoryRecord Read(BinaryReader reader);
    private static void SeekToEndOfCentralDirectoryRecord(BinaryReader reader);
    private static void ThrowByteSignatureNotFoundException(Byte[] signature);
}
public class NuGet.Packaging.Signing.EssCertId : object {
    [CompilerGeneratedAttribute]
private Byte[] <CertificateHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSerial <IssuerSerial>k__BackingField;
    public Byte[] CertificateHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertId(Byte[] hash, IssuerSerial issuerSerial);
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateHash();
    [CompilerGeneratedAttribute]
public IssuerSerial get_IssuerSerial();
    public static EssCertId Read(Byte[] bytes);
    internal static EssCertId Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.EssCertIdV2 : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CertificateHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSerial <IssuerSerial>k__BackingField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] CertificateHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertIdV2(AlgorithmIdentifier hashAlgorithm, Byte[] hash, IssuerSerial issuerSerial);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateHash();
    [CompilerGeneratedAttribute]
public IssuerSerial get_IssuerSerial();
    public static EssCertIdV2 Create(X509Certificate2 certificate, HashAlgorithmName hashAlgorithmName);
    public static EssCertIdV2 Read(Byte[] bytes);
    internal static EssCertIdV2 Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
public class NuGet.Packaging.Signing.Extension : object {
    [CompilerGeneratedAttribute]
private Oid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Oid Id { get; }
    public bool Critical { get; }
    public Byte[] Value { get; }
    private Extension(Oid id, bool critical, Byte[] value);
    [CompilerGeneratedAttribute]
public Oid get_Id();
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    internal static Extension Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.Extensions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Extension> <ExtensionsList>k__BackingField;
    public IReadOnlyList`1<Extension> ExtensionsList { get; }
    private Extensions(IReadOnlyList`1<Extension> extensions);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Extension> get_ExtensionsList();
    public static Extensions Read(Byte[] bytes);
    internal static Extensions Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.ExtraField : object {
    [CompilerGeneratedAttribute]
private ushort <HeaderId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    internal ushort HeaderId { get; private set; }
    internal ushort DataSize { get; private set; }
    internal Byte[] Data { get; private set; }
    protected ExtraField(ushort headerId, ushort dataSize, Byte[] data);
    [CompilerGeneratedAttribute]
internal ushort get_HeaderId();
    [CompilerGeneratedAttribute]
private void set_HeaderId(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_DataSize();
    [CompilerGeneratedAttribute]
private void set_DataSize(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    internal static bool TryRead(CentralDirectoryHeader header, IReadOnlyList`1& extraFields);
    internal static bool TryRead(LocalFileHeader header, IReadOnlyList`1& extraFields);
    private static bool TryRead(Byte[] extraFieldBytes, ushort extraFieldLength, bool readUncompressedFileSize, bool readCompressedFileSize, bool readRelativeOffsetOfLocalHeader, bool readDiskNumberStart, IReadOnlyList`1& extraFields);
}
public class NuGet.Packaging.Signing.GeneralName : object {
    [CompilerGeneratedAttribute]
private X500DistinguishedName <DirectoryName>k__BackingField;
    public X500DistinguishedName DirectoryName { get; }
    private GeneralName(X500DistinguishedName directoryName);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_DirectoryName();
    public static GeneralName Create(X500DistinguishedName distinguishedName);
    public static GeneralName Read(Byte[] bytes);
    internal static GeneralName Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
internal class NuGet.Packaging.Signing.HeapBlockRetainer : object {
    private List`1<SafeLocalAllocHandle> _blocks;
    public IntPtr Alloc(int cbSize);
    public IntPtr Alloc(int howMany, int cbElement);
    public IntPtr AllocAsciiString(string s);
    public IntPtr AllocBytes(Byte[] data);
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.Signing.IntegrityVerificationProvider : object {
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.IntegrityVerificationProvider/<VerifyPackageIntegrityAsync>d__1")]
private Task`1<PackageVerificationResult> VerifyPackageIntegrityAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings);
}
public class NuGet.Packaging.Signing.InvalidSignaturePackageVerificationResult : PackageVerificationResult {
    public InvalidSignaturePackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
}
public interface NuGet.Packaging.Signing.IPackageSignatureVerifier {
    public abstract virtual Task`1<VerifySignaturesResult> VerifySignaturesAsync(ISignedPackageReader package, SignedPackageVerifierSettings settings, CancellationToken token, Guid telemetryOperationId);
}
public interface NuGet.Packaging.Signing.IRepositorySignature {
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public abstract virtual Uri get_V3ServiceIndexUrl();
    public abstract virtual IReadOnlyList`1<string> get_PackageOwners();
}
public interface NuGet.Packaging.Signing.ISignature {
    public SignatureType Type { get; }
    public SignerInfo SignerInfo { get; }
    public abstract virtual SignatureType get_Type();
    public abstract virtual SignerInfo get_SignerInfo();
}
public interface NuGet.Packaging.Signing.ISignatureProvider {
    public abstract virtual Task`1<PrimarySignature> CreatePrimarySignatureAsync(SignPackageRequest request, SignatureContent signatureContent, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<PrimarySignature> CreateRepositoryCountersignatureAsync(RepositorySignPackageRequest request, PrimarySignature primarySignature, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ISignatureVerificationProvider {
    public abstract virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ISignedPackage {
}
public interface NuGet.Packaging.Signing.ISignedPackageReader {
    public abstract virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public abstract virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public abstract virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public abstract virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public abstract virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    public abstract virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
}
public interface NuGet.Packaging.Signing.ISignedPackageWriter {
    public abstract virtual Task RemoveSignatureAsync(CancellationToken token);
    public abstract virtual Task AddSignatureAsync(Stream signatureStream, CancellationToken token);
    public abstract virtual Task`1<bool> IsZip64Async(CancellationToken token);
}
public class NuGet.Packaging.Signing.IssuerSerial : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<GeneralName> <GeneralNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    public IReadOnlyList`1<GeneralName> GeneralNames { get; }
    public Byte[] SerialNumber { get; }
    private IssuerSerial(IReadOnlyList`1<GeneralName> generalNames, Byte[] serialNumber);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<GeneralName> get_GeneralNames();
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    public static IssuerSerial Create(X509Certificate2 certificate);
    public static IssuerSerial Read(Byte[] bytes);
    internal static IssuerSerial Read(DerSequenceReader reader);
    internal Byte[][] Encode();
    private static IReadOnlyList`1<GeneralName> ReadGeneralNames(DerSequenceReader reader);
}
public interface NuGet.Packaging.Signing.ITimestampProvider {
    public abstract virtual Task`1<PrimarySignature> TimestampSignatureAsync(PrimarySignature primarySignature, TimestampRequest request, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ITrustedSignersProvider {
    public abstract virtual IReadOnlyList`1<TrustedSignerItem> GetTrustedSigners();
    public abstract virtual void AddOrUpdateTrustedSigner(TrustedSignerItem trustedSigner);
    public abstract virtual void Remove(IReadOnlyList`1<TrustedSignerItem> trustedSigners);
}
public interface NuGet.Packaging.Signing.IX509CertificateChain {
}
public class NuGet.Packaging.Signing.KeyPairFileReader : object {
    private static Regex NamePattern;
    private StreamReader _reader;
    public KeyPairFileReader(Stream stream, Encoding encoding);
    private static KeyPairFileReader();
    public Dictionary`2<string, string> ReadSection();
    private static KeyValuePair`2<string, string> GetProperty(string line);
    private static void ThrowInvalidFormat();
    public sealed virtual void Dispose();
}
public static class NuGet.Packaging.Signing.KeyPairFileUtility : object {
    public static string GetValueOrThrow(Dictionary`2<string, string> values, string key);
}
public class NuGet.Packaging.Signing.KeyPairFileWriter : object {
    private StreamWriter _writer;
    public KeyPairFileWriter(Stream stream, Encoding encoding, bool leaveOpen);
    public void WritePair(string key, string value);
    public void WriteSectionBreak();
    private void WriteEOL();
    private static string FormatItem(string key, string value);
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.LocalFileHeader : object {
    internal static UInt32 SizeInBytesOfFixedLengthFields;
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GeneralPurposeBitFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExtraFieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtraField>k__BackingField;
    internal ushort VersionNeededToExtract { get; private set; }
    internal ushort GeneralPurposeBitFlag { get; private set; }
    internal ushort CompressionMethod { get; private set; }
    internal ushort LastModFileTime { get; private set; }
    internal ushort LastModFileDate { get; private set; }
    internal UInt32 Crc32 { get; private set; }
    internal UInt32 CompressedSize { get; private set; }
    internal UInt32 UncompressedSize { get; private set; }
    internal ushort FileNameLength { get; private set; }
    internal ushort ExtraFieldLength { get; private set; }
    internal Byte[] FileName { get; private set; }
    internal Byte[] ExtraField { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_GeneralPurposeBitFlag();
    [CompilerGeneratedAttribute]
private void set_GeneralPurposeBitFlag(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileTime();
    [CompilerGeneratedAttribute]
private void set_LastModFileTime(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileDate();
    [CompilerGeneratedAttribute]
private void set_LastModFileDate(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileNameLength();
    [CompilerGeneratedAttribute]
private void set_FileNameLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_ExtraFieldLength();
    [CompilerGeneratedAttribute]
private void set_ExtraFieldLength(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ExtraField();
    [CompilerGeneratedAttribute]
private void set_ExtraField(Byte[] value);
    internal static bool TryRead(BinaryReader reader, LocalFileHeader& header);
}
public class NuGet.Packaging.Signing.MessageImprint : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashedMessage>k__BackingField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] HashedMessage { get; }
    private MessageImprint(AlgorithmIdentifier hashAlgorithm, Byte[] hashedMessage);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_HashedMessage();
    public static MessageImprint Read(Byte[] bytes);
    internal static MessageImprint Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.NativeCms : object {
    private SafeCryptMsgHandle _handle;
    private NativeCms(SafeCryptMsgHandle handle);
    internal Byte[] GetPrimarySignatureSignatureValue();
    private Byte[] GetByteArrayAttribute(CMSG_GETPARAM_TYPE param, UInt32 index);
    internal Byte[] GetRepositoryCountersignatureSignatureValue();
    private Nullable`1<RepositoryCounterSignerInfo> GetRepositoryCountersignature(HeapBlockRetainer retainer);
    private static bool IsRepositoryCounterSignerInfo(CMSG_SIGNER_INFO counterSignerInfo);
    private static bool IsRepositoryCounterSignerInfo(CRYPT_ATTRIBUTE_STRING commitmentTypeIndicationAttribute);
    internal static NativeCms Decode(Byte[] input);
    internal void AddCertificates(IEnumerable`1<Byte[]> encodedCertificates);
    internal void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    internal void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    internal void AddTimestamp(SignedCms timestamp);
    private static CRYPT_ATTRIBUTE GetCryptAttributeForData(Byte[] data, string attributeOid, HeapBlockRetainer hb);
    private static CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA CreateUnsignedAddAttribute(CRYPT_ATTRIBUTE attr, HeapBlockRetainer hb);
    internal Byte[] Encode();
    public sealed virtual void Dispose();
}
internal static class NuGet.Packaging.Signing.NativeMethods : object {
    internal static UInt32 PKCS_ATTRIBUTE;
    internal static UInt32 PKCS7_SIGNER_INFO;
    internal static int ERROR_MORE_DATA;
    internal static UInt32 CMSG_SIGNED;
    internal static UInt32 CERT_KEY_IDENTIFIER_PROP_ID;
    internal static UInt32 CERT_ID_KEY_IDENTIFIER;
    public static SafeCryptMsgHandle CryptMsgOpenToEncode(CMSG_ENCODING dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, CMSG_SIGNED_ENCODE_INFO& pvMsgEncodeInfo, string pszInnerContentObjID, IntPtr pStreamInfo);
    public static SafeCryptMsgHandle CryptMsgOpenToDecode(CMSG_ENCODING dwMsgEncodingType, CMSG_OPENTODECODE_FLAGS dwFlags, UInt32 dwMsgType, IntPtr hCryptProv, IntPtr pRecipientInfo, IntPtr pStreamInfo);
    public static bool CryptMsgCountersign(SafeCryptMsgHandle hCryptMsg, UInt32 dwIndex, int cCountersigners, CMSG_SIGNER_ENCODE_INFO rgCountersigners);
    public static bool CryptMsgClose(IntPtr hCryptMsg);
    public static bool CryptMsgUpdate(SafeCryptMsgHandle hCryptMsg, Byte[] pbData, UInt32 cbData, bool fFinal);
    public static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, CMSG_GETPARAM_TYPE dwParamType, UInt32 dwIndex, Byte[] pvData, UInt32& pcbData);
    internal static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, CMSG_GETPARAM_TYPE dwParamType, UInt32 dwIndex, IntPtr pvData, UInt32& pcbData);
    internal static bool CryptDecodeObject(CMSG_ENCODING dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, UInt32 dwFlags, IntPtr pvStructInfo, IntPtr pcbStructInfo);
    internal static bool CryptMsgControl(SafeCryptMsgHandle hCryptMsg, UInt32 dwFlags, CMSG_CONTROL_TYPE dwCtrlType, IntPtr pvCtrlPara);
    internal static bool CryptEncodeObjectEx(CMSG_ENCODING dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, UInt32 dwFlags, IntPtr pEncodePara, IntPtr pvEncoded, UInt32& pcbEncoded);
    internal static bool CryptReleaseContext(IntPtr hProv, int dwFlags);
    internal static IntPtr CertDuplicateCertificateContext(IntPtr pCertContext);
    internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    internal static bool CertGetCertificateContextProperty(IntPtr pCertContext, UInt32 dwPropId, IntPtr pvData, UInt32& pcbData);
    internal static int GetHRForWin32Error(int err);
}
internal static class NuGet.Packaging.Signing.NativeUtility : object {
    internal static void SafeFree(IntPtr ptr);
    internal static void ThrowIfFailed(bool result);
    internal static SignedCms NativeSign(CmsSigner cmsSigner, Byte[] data, CngKey privateKey);
    internal static CMSG_SIGNER_ENCODE_INFO CreateSignerInfo(CmsSigner cmsSigner, CngKey privateKey, HeapBlockRetainer hb);
}
public class NuGet.Packaging.Signing.NuGetPackageOwners : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public IReadOnlyList`1<string> PackageOwners { get; }
    public NuGetPackageOwners(IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackageOwners();
    public static NuGetPackageOwners Read(Byte[] bytes);
    internal static NuGetPackageOwners Read(DerSequenceReader reader);
    public Byte[] Encode();
}
public class NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl : object {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public NuGetV3ServiceIndexUrl(Uri v3ServiceIndexUrl);
    [CompilerGeneratedAttribute]
public Uri get_V3ServiceIndexUrl();
    public static NuGetV3ServiceIndexUrl Read(Byte[] bytes);
    internal static NuGetV3ServiceIndexUrl Read(DerSequenceReader reader);
    public Byte[] Encode();
}
public static class NuGet.Packaging.Signing.Oids : object {
    public static string SigningTime;
    public static string Countersignature;
    public static string SignatureTimeStampTokenAttribute;
    public static string Sha1;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string Sha256WithRSAEncryption;
    public static string Sha384WithRSAEncryption;
    public static string Sha512WithRSAEncryption;
    public static string CodeSigningEku;
    public static string Pkcs7Data;
    public static string BaselineTimestampPolicy;
    public static string TimeStampingEku;
    public static string EnhancedKeyUsage;
    public static string TSTInfoContentType;
    public static string LifetimeSigningEku;
    public static string CommitmentTypeIndication;
    public static string CommitmentTypeIdentifierProofOfOrigin;
    public static string CommitmentTypeIdentifierProofOfReceipt;
    public static string SigningCertificate;
    public static string SigningCertificateV2;
    public static string AuthorityKeyIdentifier;
    public static string SubjectKeyIdentifier;
    public static string AnyPolicy;
    public static string IdQtCps;
    public static string IdQtUnotice;
    public static string NuGetV3ServiceIndexUrl;
    public static string NuGetPackageOwners;
}
public class NuGet.Packaging.Signing.PackageSignatureVerifier : object {
    private List`1<ISignatureVerificationProvider> _verificationProviders;
    public PackageSignatureVerifier(IEnumerable`1<ISignatureVerificationProvider> verificationProviders);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.PackageSignatureVerifier/<VerifySignaturesAsync>d__2")]
public sealed virtual Task`1<VerifySignaturesResult> VerifySignaturesAsync(ISignedPackageReader package, SignedPackageVerifierSettings settings, CancellationToken token, Guid parentId);
    private static bool IsValid(IEnumerable`1<PackageVerificationResult> verificationResults, SignedPackageVerifierSettings settings);
}
public abstract class NuGet.Packaging.Signing.PackageVerificationResult : object {
    [CompilerGeneratedAttribute]
private SignatureVerificationStatus <Trust>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SignatureLog> <Issues>k__BackingField;
    public SignatureVerificationStatus Trust { get; }
    public IEnumerable`1<SignatureLog> Issues { get; }
    public PackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public virtual SignatureVerificationStatus get_Trust();
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<SignatureLog> get_Issues();
    public IEnumerable`1<ILogMessage> GetWarningIssues();
    public IEnumerable`1<ILogMessage> GetErrorIssues();
}
public class NuGet.Packaging.Signing.PolicyInformation : object {
    [CompilerGeneratedAttribute]
private Oid <PolicyIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyQualifierInfo> <PolicyQualifiers>k__BackingField;
    public Oid PolicyIdentifier { get; }
    public IReadOnlyList`1<PolicyQualifierInfo> PolicyQualifiers { get; }
    private PolicyInformation(Oid policyIdentifier, IReadOnlyList`1<PolicyQualifierInfo> policyQualifiers);
    [CompilerGeneratedAttribute]
public Oid get_PolicyIdentifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyQualifierInfo> get_PolicyQualifiers();
    public static PolicyInformation Read(Byte[] bytes);
    internal static PolicyInformation Read(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyQualifierInfo> ReadPolicyQualifiers(DerSequenceReader reader, bool isAnyPolicy);
}
public class NuGet.Packaging.Signing.PolicyQualifierInfo : object {
    [CompilerGeneratedAttribute]
private Oid <PolicyQualifierId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Qualifier>k__BackingField;
    public Oid PolicyQualifierId { get; }
    public Byte[] Qualifier { get; }
    private PolicyQualifierInfo(Oid policyQualifierId, Byte[] qualifier);
    [CompilerGeneratedAttribute]
public Oid get_PolicyQualifierId();
    [CompilerGeneratedAttribute]
public Byte[] get_Qualifier();
    public static PolicyQualifierInfo Read(Byte[] bytes);
    internal static PolicyQualifierInfo Read(DerSequenceReader reader);
}
public abstract class NuGet.Packaging.Signing.PrimarySignature : Signature {
    [CompilerGeneratedAttribute]
private SignedCms <SignedCms>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureContent <SignatureContent>k__BackingField;
    public SignedCms SignedCms { get; }
    public SignatureContent SignatureContent { get; }
    public string FriendlyName { get; }
    protected PrimarySignature(SignedCms signedCms, SignatureType signatureType);
    [CompilerGeneratedAttribute]
public SignedCms get_SignedCms();
    [CompilerGeneratedAttribute]
public SignatureContent get_SignatureContent();
    public virtual string get_FriendlyName();
    public void Save(Stream stream);
    public Byte[] GetBytes();
    public static PrimarySignature Load(SignedCms cms);
    public static PrimarySignature Load(Byte[] data);
    public static PrimarySignature Load(Stream stream);
    public virtual Byte[] GetSignatureValue();
    protected virtual void ThrowForInvalidSignature();
    protected static void ThrowForInvalidPrimarySignature();
    private static void VerifySigningCertificate(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications);
    private static SignerInfo GetSignerInfo(SignedCms signedCms);
    private static SignedCms Decode(Byte[] bytes);
}
public static class NuGet.Packaging.Signing.PrimarySignatureFactory : object {
    public static PrimarySignature CreateSignature(SignedCms signedCms);
}
public class NuGet.Packaging.Signing.ReadOnlyBufferedStream : Stream {
    private static int _defaultBufferSize;
    private Byte[] _buffer;
    private bool _leaveOpen;
    private Lazy`1<long> _length;
    private Stream _stream;
    private long _bufferStartPosition;
    private int _bufferFillLength;
    private bool _isDisposed;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public ReadOnlyBufferedStream(Stream stream, bool leaveOpen);
    public ReadOnlyBufferedStream(Stream stream, bool leaveOpen, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private void FillBuffer();
    private bool IsPositionAfterEndOfStream();
    private bool IsPositionInBuffer();
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private long <.ctor>b__29_0();
}
public class NuGet.Packaging.Signing.RepositoryCountersignature : Signature {
    private PrimarySignature _primarySignature;
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public string FriendlyName { get; }
    private RepositoryCountersignature(PrimarySignature primarySignature, SignerInfo counterSignerInfo, Uri v3ServiceIndexUrl, IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_PackageOwners();
    public virtual string get_FriendlyName();
    public static RepositoryCountersignature GetRepositoryCountersignature(PrimarySignature primarySignature);
    public virtual Byte[] GetSignatureValue();
    protected virtual void ThrowForInvalidSignature();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
    internal bool IsRelated(PrimarySignature primarySignature);
}
public class NuGet.Packaging.Signing.RepositoryPrimarySignature : PrimarySignature {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public string FriendlyName { get; }
    public RepositoryPrimarySignature(SignedCms signedCms);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_PackageOwners();
    public virtual string get_FriendlyName();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
}
public static class NuGet.Packaging.Signing.RepositorySignatureInfoUtility : object {
    public static SignedPackageVerifierSettings GetSignedPackageVerifierSettings(RepositorySignatureInfo repoSignatureInfo, SignedPackageVerifierSettings fallbackSettings);
    public static IReadOnlyCollection`1<CertificateHashAllowListEntry> GetRepositoryAllowList(IEnumerable`1<IRepositoryCertificateInfo> repositoryCertificateInfos);
}
public class NuGet.Packaging.Signing.RepositorySignPackageRequest : SignPackageRequest {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public SignatureType SignatureType { get; }
    public RepositorySignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm, Uri v3ServiceIndexUrl, IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackageOwners();
    public virtual SignatureType get_SignatureType();
}
public class NuGet.Packaging.Signing.Rfc3161TimestampProvider : object {
    private Uri _timestamperUrl;
    private static int _rfc3161RequestTimeoutSeconds;
    public Rfc3161TimestampProvider(Uri timeStampServerUrl);
    public sealed virtual Task`1<PrimarySignature> TimestampSignatureAsync(PrimarySignature primarySignature, TimestampRequest request, ILogger logger, CancellationToken token);
    public SignedCms GetTimestamp(TimestampRequest request, ILogger logger, CancellationToken token);
    private static SignedCms EnsureCertificatesInCertificatesCollection(SignedCms timestampCms, IReadOnlyList`1<X509Certificate2> chain);
    private static void ValidateTimestampCms(SigningSpecifications spec, SignedCms timestampCms, Rfc3161TimestampToken timestampToken);
    private static void ValidateTimestampResponse(Byte[] nonce, Byte[] messageHash, Rfc3161TimestampToken timestampToken);
    private static string GetNameOrOidString(Oid oid);
    private static Byte[] GenerateNonce();
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequest : AsnEncodedData {
    private DataType _data;
    private DataType Data { get; }
    public int Version { get; }
    public Oid HashAlgorithmId { get; }
    public Oid RequestedPolicyId { get; }
    public bool RequestSignerCertificate { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampRequest(Byte[] encodedRequest);
    public Rfc3161TimestampRequest(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public Rfc3161TimestampRequest(Byte[] messageHash, Oid hashAlgorithmId, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    private DataType get_Data();
    private static Oid OpportunisticOid(string oidValue, OidGroup group);
    public int get_Version();
    public Byte[] GetMessageHash();
    public Oid get_HashAlgorithmId();
    public Oid get_RequestedPolicyId();
    public Byte[] GetNonce();
    public bool get_RequestSignerCertificate();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    public Rfc3161TimestampToken SubmitRequest(Uri timestampUri, TimeSpan timeout);
    private static Byte[] Encode(DataType data);
    private static DataType Decode(Byte[] rawData);
    private static bool ResolveAlgorithm(HashAlgorithmName hashAlgorithm, Int32& expectedSizeInBytes, String& algorithmIdentifier);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampToken : object {
    private Byte[] _encoded;
    [CompilerGeneratedAttribute]
private Rfc3161TimestampTokenInfo <TokenInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <SignerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <AdditionalCerts>k__BackingField;
    public Rfc3161TimestampTokenInfo TokenInfo { get; }
    public X509Certificate2 SignerCertificate { get; }
    public X509Certificate2Collection AdditionalCerts { get; }
    internal Rfc3161TimestampToken(Rfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
    [CompilerGeneratedAttribute]
public Rfc3161TimestampTokenInfo get_TokenInfo();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_SignerCertificate();
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_AdditionalCerts();
    public Byte[] GetEncodedValue();
    public SignedCms AsSignedCms();
    public static Rfc3161TimestampToken LoadOnly(Byte[] encodedToken);
    public static Rfc3161TimestampToken LoadAndVerifyData(Byte[] encodedToken, Byte[] data);
    public static Rfc3161TimestampToken LoadAndVerifyHash(Byte[] encodedToken, Byte[] hash);
    private static Rfc3161TimestampToken CryptVerifyTimeStampSignature(Byte[] encodedToken, Byte[] data);
}
public class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo : AsnEncodedData {
    public static string TimestampTokenInfoId;
    private TstInfo _decoded;
    private TstInfo Decoded { get; }
    public int Version { get; }
    public string PolicyId { get; }
    public Oid HashAlgorithmId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public bool IsOrdering { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampTokenInfo(Byte[] timestampTokenInfo);
    internal Rfc3161TimestampTokenInfo(IntPtr pTsContext);
    private TstInfo get_Decoded();
    public int get_Version();
    public string get_PolicyId();
    public Oid get_HashAlgorithmId();
    public Byte[] GetMessageHash();
    public bool HasMessageHash(Byte[] hash);
    public Byte[] GetSerialNumber();
    public DateTimeOffset get_Timestamp();
    public Nullable`1<long> get_AccuracyInMicroseconds();
    public bool get_IsOrdering();
    public Byte[] GetNonce();
    public Byte[] GetTimestampAuthorityName();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    internal static X509ExtensionCollection ShallowCopy(X509ExtensionCollection existing, bool preserveNull);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal static Byte[] CopyFromNative(CRYPTOAPI_BLOB& blob);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Signing.Rfc3161TimestampUtils : object {
    internal static bool IsLegalOid(string algorithmIdentifier);
    [ExtensionAttribute]
public static Byte[] GetSignature(SignerInfo signerInfo);
    [ExtensionAttribute]
internal static string ByteArrayToHex(Byte[] bytes);
    [ExtensionAttribute]
internal static Byte[] HexToByteArray(string hexString);
}
internal static class NuGet.Packaging.Signing.Rfc3161TimestampVerificationUtility : object {
    private static double _millisecondsPerMicrosecond;
    internal static bool ValidateSignerCertificateAgainstTimestamp(X509Certificate2 signerCertificate, Timestamp timestamp);
    internal static bool TryReadTSTInfoFromSignedCms(SignedCms timestampCms, Rfc3161TimestampTokenInfo& tstInfo);
    internal static double GetAccuracyInMilliseconds(Rfc3161TimestampTokenInfo tstInfo);
}
internal static class NuGet.Packaging.Signing.Rfc3161TimestampWin32 : object {
    internal static IntPtr TIMESTAMP_REQUEST;
    internal static IntPtr TIMESTAMP_INFO;
    private static Rfc3161TimestampWin32();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptRetrieveTimeStamp(string wszUrl, CryptRetrieveTimeStampFlags dwRetrievalFlags, int dwTimeout, string pszHashId, CRYPT_TIMESTAMP_PARA& pPara, Byte[] pbData, int cbData, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptVerifyTimeStampSignature(Byte[] pbTSContentInfo, int cbTSContentInfo, Byte[] pbData, int cbData, IntPtr hAdditionalStore, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static bool CryptEncodeObjectEx(CryptEncodingTypes dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, CryptEncodeObjectFlags dwFlags, IntPtr pEncodePara, IntPtr pvEncoded, UInt32& pcbEncoded);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static bool CryptDecodeObjectEx(CryptEncodingTypes dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, int cbEncoded, CryptDecodeObjectFlags dwFlags, IntPtr pDecodePara, IntPtr pvStructInfo, Int32& pcbStructInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertCloseStore(IntPtr pCertContext, int dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void CryptMemFree(IntPtr pv);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static IntPtr LocalFree(IntPtr handle);
}
internal class NuGet.Packaging.Signing.SafeCryptMsgHandle : SafeHandle {
    internal static SafeCryptMsgHandle InvalidHandle { get; }
    public bool IsInvalid { get; }
    internal SafeCryptMsgHandle(IntPtr handle);
    internal SafeCryptMsgHandle(IntPtr handle, bool ownsHandle);
    internal static SafeCryptMsgHandle get_InvalidHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class NuGet.Packaging.Signing.SafeLocalAllocHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeLocalAllocHandle(IntPtr handle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public abstract class NuGet.Packaging.Signing.Signature : object {
    private Lazy`1<IReadOnlyList`1<Timestamp>> _timestamps;
    [CompilerGeneratedAttribute]
private SignatureType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SignerInfo <SignerInfo>k__BackingField;
    private IDictionary`2<HashAlgorithmName, string> _signingCertificateFingerprintLookup;
    public SignatureType Type { get; }
    public IReadOnlyList`1<Timestamp> Timestamps { get; }
    public SignerInfo SignerInfo { get; }
    public string FriendlyName { get; }
    protected Signature(SignerInfo signerInfo, SignatureType type);
    [CompilerGeneratedAttribute]
public sealed virtual SignatureType get_Type();
    public IReadOnlyList`1<Timestamp> get_Timestamps();
    [CompilerGeneratedAttribute]
public sealed virtual SignerInfo get_SignerInfo();
    public abstract virtual Byte[] GetSignatureValue();
    protected abstract virtual void ThrowForInvalidSignature();
    public virtual string get_FriendlyName();
    internal bool TryGetValidTimestamp(SignedPackageVerifierSettings settings, HashAlgorithmName fingerprintAlgorithm, List`1<SignatureLog> issues, SignatureVerificationStatusFlags& verificationFlags, Timestamp& validTimestamp);
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
    public string GetSigningCertificateFingerprint(HashAlgorithmName algorithm);
    private void VerifySigningTimeAttribute(SignerInfo signerInfo);
    private static IReadOnlyList`1<Timestamp> GetTimestamps(SignerInfo signer, string signatureFriendlyName);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Timestamp> <.ctor>b__11_0();
}
public class NuGet.Packaging.Signing.SignatureContent : object {
    private SigningSpecifications _signingSpecifications;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashValue>k__BackingField;
    public HashAlgorithmName HashAlgorithm { get; }
    public string HashValue { get; }
    public SignatureContent(SigningSpecifications signingSpecifications, HashAlgorithmName hashAlgorithm, string hashValue);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public string get_HashValue();
    private void Save(Stream stream);
    public Byte[] GetBytes();
    public static SignatureContent Load(Byte[] bytes, SigningSpecifications signingSpecifications);
    private static SignatureContent Load(Stream stream, SigningSpecifications signingSpecifications);
    private static void ThrowIfEmpty(Dictionary`2<string, string> properties);
    private static bool TryReadPackageHashProperty(KeyValuePair`2<string, string> property, SigningSpecifications signingSpecifications, HashAlgorithmName& hashAlgorithmName);
    private static void ThrowIfSignatureFormatVersionIsUnsupported(Dictionary`2<string, string> properties, SigningSpecifications signingSpecifications);
}
public class NuGet.Packaging.Signing.SignatureException : PackagingException {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageVerificationResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <VerifyDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    public IReadOnlyList`1<PackageVerificationResult> Results { get; }
    public PackageIdentity PackageIdentity { get; }
    public TimeSpan VerifyDuration { get; public set; }
    public NuGetLogCode Code { get; }
    public SignatureException(NuGetLogCode code, string message);
    public SignatureException(NuGetLogCode code, string message, Exception innerException);
    public SignatureException(string message);
    public SignatureException(IReadOnlyList`1<PackageVerificationResult> results, PackageIdentity package);
    public SignatureException(NuGetLogCode code, string message, PackageIdentity package);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageVerificationResult> get_Results();
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public TimeSpan get_VerifyDuration();
    [CompilerGeneratedAttribute]
public void set_VerifyDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public NuGetLogCode get_Code();
}
public class NuGet.Packaging.Signing.SignatureLog : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    public LogLevel Level { get; public set; }
    public string Message { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public string LibraryId { get; public set; }
    private SignatureLog(LogLevel level, NuGetLogCode code, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    public static SignatureLog InformationLog(string message);
    public static SignatureLog DetailedLog(string message);
    public static SignatureLog DebugLog(string message);
    public static SignatureLog Issue(bool fatal, NuGetLogCode code, string message);
    public static SignatureLog Error(NuGetLogCode code, string message);
    public sealed virtual bool Equals(SignatureLog other);
    public RestoreLogMessage AsRestoreLogMessage();
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.SignaturePlacement : Enum {
    public int value__;
    public static SignaturePlacement PrimarySignature;
    public static SignaturePlacement Countersignature;
    public static SignaturePlacement Any;
}
public class NuGet.Packaging.Signing.SignatureTrustAndValidityVerificationProvider : object {
    private HashAlgorithmName _fingerprintAlgorithm;
    private IEnumerable`1<KeyValuePair`2<string, HashAlgorithmName>> _allowUntrustedRootList;
    public SignatureTrustAndValidityVerificationProvider(IEnumerable`1<KeyValuePair`2<string, HashAlgorithmName>> allowUntrustedRootList);
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    private PackageVerificationResult Verify(PrimarySignature signature, SignedPackageVerifierSettings settings);
    private SignatureVerificationSummary GetTimestamp(Signature signature, SignedPackageVerifierSettings verifierSettings, Timestamp& timestamp);
    private SignatureVerificationSummary VerifyValidityAndTrust(Signature signature, SignedPackageVerifierSettings verifierSettings, SignatureVerifySettings settings, X509Certificate2Collection certificateExtraStore);
    private bool IsUntrustedRootAllowed(Signature signature);
    private static bool HasUntrustedRoot(SignatureVerificationSummary summary);
    private static bool IsSignatureExpired(SignatureVerificationSummary summary);
}
public enum NuGet.Packaging.Signing.SignatureType : Enum {
    public int value__;
    public static SignatureType Unknown;
    public static SignatureType Author;
    public static SignatureType Repository;
}
public static class NuGet.Packaging.Signing.SignatureUtility : object {
    public static IX509CertificateChain GetCertificateChain(PrimarySignature primarySignature);
    public static IX509CertificateChain GetCertificateChain(PrimarySignature primarySignature, RepositoryCountersignature repositoryCountersignature);
    internal static IX509CertificateChain GetCertificateChain(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, string signatureFriendlyName);
    private static IX509CertificateChain GetPrimarySignatureCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, string signatureFriendlyName, bool includeChain);
    public static IX509CertificateChain GetTimestampCertificateChain(PrimarySignature primarySignature);
    public static IX509CertificateChain GetTimestampCertificateChain(PrimarySignature primarySignature, RepositoryCountersignature repositoryCountersignature);
    private static IX509CertificateChain GetRepositoryCountersignatureCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, bool includeChain);
    public static bool HasRepositoryCountersignature(PrimarySignature primarySignature);
    internal static IX509CertificateChain GetTimestampCertificates(SignedCms signedCms, SigningSpecifications signingSpecifications, string signatureFriendlyName);
    private static IX509CertificateChain GetTimestampCertificates(SignedCms signedCms, SigningSpecifications signingSpecifications, string signatureFriendlyName, bool includeChain);
    private static IX509CertificateChain GetCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningCertificateRequirement signingCertificateRequirement, bool isIssuerSerialRequired, Errors errors, SigningSpecifications signingSpecifications, bool includeChain);
    private static bool IsMatch(X509Certificate2 certificate, EssCertIdV2 essCertIdV2, Errors errors, bool isIssuerSerialRequired);
    private static bool IsMatch(X509Certificate2 certificate, EssCertId essCertId);
    private static bool AreGeneralNamesEqual(IssuerSerial issuerSerial, X509Certificate2 certificate);
    private static bool AreSerialNumbersEqual(IssuerSerial issuerSerial, X509Certificate2 certificate);
    private static IX509CertificateChain GetCertificateChain(X509Certificate2 certificate, X509Certificate2Collection extraStore, bool includeCertificatesAfterSigningCertificate);
    private static DerSequenceReader CreateDerSequenceReader(CryptographicAttributeObject attribute);
}
public enum NuGet.Packaging.Signing.SignatureVerificationBehavior : Enum {
    public int value__;
    public static SignatureVerificationBehavior Never;
    public static SignatureVerificationBehavior IfExists;
    public static SignatureVerificationBehavior IfExistsAndIsNecessary;
    public static SignatureVerificationBehavior Always;
}
public enum NuGet.Packaging.Signing.SignatureVerificationStatus : Enum {
    public int value__;
    public static SignatureVerificationStatus Unknown;
    public static SignatureVerificationStatus Suspect;
    public static SignatureVerificationStatus Disallowed;
    public static SignatureVerificationStatus Valid;
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.SignatureVerificationStatusFlags : Enum {
    public int value__;
    public static SignatureVerificationStatusFlags NoErrors;
    public static SignatureVerificationStatusFlags NoSignature;
    public static SignatureVerificationStatusFlags NoCertificate;
    public static SignatureVerificationStatusFlags MultipleSignatures;
    public static SignatureVerificationStatusFlags SignatureCheckFailed;
    public static SignatureVerificationStatusFlags SignatureAlgorithmUnsupported;
    public static SignatureVerificationStatusFlags CertificatePublicKeyInvalid;
    public static SignatureVerificationStatusFlags HasLifetimeSigningEku;
    public static SignatureVerificationStatusFlags CertificateValidityInTheFuture;
    public static SignatureVerificationStatusFlags CertificateExpired;
    public static SignatureVerificationStatusFlags HashAlgorithmUnsupported;
    public static SignatureVerificationStatusFlags MessageImprintUnsupportedAlgorithm;
    public static SignatureVerificationStatusFlags IntegrityCheckFailed;
    public static SignatureVerificationStatusFlags ChainBuildingFailure;
    public static SignatureVerificationStatusFlags UnknownRevocation;
    public static SignatureVerificationStatusFlags CertificateRevoked;
    public static SignatureVerificationStatusFlags UntrustedRoot;
    public static SignatureVerificationStatusFlags GeneralizedTimeOutsideValidity;
    public static SignatureVerificationStatusFlags NoValidTimestamp;
    public static SignatureVerificationStatusFlags MultipleTimestamps;
    public static SignatureVerificationStatusFlags Suspect;
    public static SignatureVerificationStatusFlags Illegal;
    public static SignatureVerificationStatusFlags Untrusted;
}
public class NuGet.Packaging.Signing.SignatureVerificationSummary : object {
    [CompilerGeneratedAttribute]
private SignatureType <SignatureType>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationStatusFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Timestamp <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SignatureLog> <Issues>k__BackingField;
    public SignatureType SignatureType { get; }
    public SignatureVerificationStatus Status { get; }
    public SignatureVerificationStatusFlags Flags { get; }
    public Timestamp Timestamp { get; }
    public Nullable`1<DateTimeOffset> ExpirationTime { get; }
    public IEnumerable`1<SignatureLog> Issues { get; public set; }
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, Timestamp timestamp, Nullable`1<DateTimeOffset> expirationTime, IEnumerable`1<SignatureLog> issues);
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, Timestamp timestamp, IEnumerable`1<SignatureLog> issues);
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
public SignatureVerificationStatus get_Status();
    [CompilerGeneratedAttribute]
public SignatureVerificationStatusFlags get_Flags();
    [CompilerGeneratedAttribute]
public Timestamp get_Timestamp();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SignatureLog> get_Issues();
    [CompilerGeneratedAttribute]
public void set_Issues(IEnumerable`1<SignatureLog> value);
}
public class NuGet.Packaging.Signing.SignatureVerifySettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowIllegal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUntrustedRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private RevocationMode <RevocationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureVerifySettings <Default>k__BackingField;
    public bool AllowIllegal { get; }
    public bool AllowUntrusted { get; }
    public bool AllowUnknownRevocation { get; }
    public bool ReportUnknownRevocation { get; }
    public bool ReportUntrustedRoot { get; }
    public RevocationMode RevocationMode { get; }
    public static SignatureVerifySettings Default { get; }
    public SignatureVerifySettings(bool allowIllegal, bool allowUntrusted, bool allowUnknownRevocation, bool reportUnknownRevocation, bool reportUntrustedRoot, RevocationMode revocationMode);
    private static SignatureVerifySettings();
    [CompilerGeneratedAttribute]
public bool get_AllowIllegal();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrusted();
    [CompilerGeneratedAttribute]
public bool get_AllowUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUntrustedRoot();
    [CompilerGeneratedAttribute]
public RevocationMode get_RevocationMode();
    [CompilerGeneratedAttribute]
public static SignatureVerifySettings get_Default();
}
public class NuGet.Packaging.Signing.SignedPackageArchive : PackageArchiveReader {
    private Stream _zipWriteStream;
    public SignedPackageArchive(Stream packageReadStream, Stream packageWriteStream);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchive/<AddSignatureAsync>d__2")]
public sealed virtual Task AddSignatureAsync(Stream signatureStream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchive/<RemoveSignatureAsync>d__3")]
public sealed virtual Task RemoveSignatureAsync(CancellationToken token);
    public sealed virtual Task`1<bool> IsZip64Async(CancellationToken token);
    internal UInt32 GetPackageEntryCount();
    protected virtual void Dispose(bool disposing);
}
public static class NuGet.Packaging.Signing.SignedPackageArchiveIOUtility : object {
    private static int _bufferSize;
    private static SigningSpecifications _signingSpecification;
    private static int ValidZipDate_YearMin;
    private static int ValidZipDate_YearMax;
    private static SignedPackageArchiveIOUtility();
    public static void ReadAndWriteUntilPosition(BinaryReader reader, BinaryWriter writer, long position);
    public static void ReadAndHashUntilPosition(BinaryReader reader, HashAlgorithm hashAlgorithm, long position);
    public static void HashBytes(HashAlgorithm hashAlgorithm, Byte[] bytes);
    internal static void ReadAndHashUntilPosition(BinaryReader reader, Sha512HashFunction hashFunc, long position);
    internal static void HashBytes(Sha512HashFunction hashFunc, Byte[] bytes);
    public static SignedPackageArchiveMetadata ReadSignedArchiveMetadata(BinaryReader reader, bool validateSignatureEntry);
    internal static void RemoveSignature(BinaryReader reader, BinaryWriter writer);
    private static UnsignedPackageArchiveMetadata ReadUnsignedArchiveMetadata(BinaryReader reader);
    private static void UpdateLocalFileHeadersTotalSize(IReadOnlyList`1<CentralDirectoryHeaderMetadata> records, long startOfCentralDirectory);
    private static void AssertSignatureEntryMetadata(BinaryReader reader, SignedPackageArchiveMetadata metadata);
    private static void AssertSignatureEntryCommonHeaderFields(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader, string errorPrefix, string errorSuffix);
    private static void AssertValue(UInt32 expectedValue, UInt32 actualValue, NuGetLogCode errorCode, string errorMessagePrefix, string errorMessageSuffix, string fieldName);
    internal static void WriteSignatureIntoZip(MemoryStream signatureStream, BinaryReader reader, BinaryWriter writer);
    private static long WriteLocalFileHeaderIntoZip(BinaryWriter writer, Byte[] fileData, UInt32 crc32, UInt32 dosDateTime);
    private static long WriteFileIntoZip(BinaryWriter writer, Byte[] fileData);
    private static long WriteCentralDirectoryHeaderIntoZip(BinaryWriter writer, Byte[] fileData, UInt32 crc32, UInt32 dosDateTime, long fileOffset);
    private static void ReadAndWriteUpdatedEndOfCentralDirectoryRecordIntoZip(BinaryReader reader, BinaryWriter writer, sbyte entryCountChange, long sizeOfSignatureCentralDirectoryRecord, long sizeOfSignatureFileHeaderAndData);
    private static bool CurrentStreamPositionMatchesByteSignature(BinaryReader reader, Byte[] byteSignature);
    private static UInt32 DateTimeToDosTime(DateTime dateTime);
}
public class NuGet.Packaging.Signing.SignedPackageArchiveMetadata : object {
    [CompilerGeneratedAttribute]
private List`1<CentralDirectoryHeaderMetadata> <CentralDirectoryHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOfLocalFileHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SignatureCentralDirectoryHeaderIndex>k__BackingField;
    public List`1<CentralDirectoryHeaderMetadata> CentralDirectoryHeaders { get; public set; }
    public long StartOfLocalFileHeaders { get; public set; }
    public long EndOfCentralDirectory { get; public set; }
    public int SignatureCentralDirectoryHeaderIndex { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<CentralDirectoryHeaderMetadata> get_CentralDirectoryHeaders();
    [CompilerGeneratedAttribute]
public void set_CentralDirectoryHeaders(List`1<CentralDirectoryHeaderMetadata> value);
    [CompilerGeneratedAttribute]
public long get_StartOfLocalFileHeaders();
    [CompilerGeneratedAttribute]
public void set_StartOfLocalFileHeaders(long value);
    [CompilerGeneratedAttribute]
public long get_EndOfCentralDirectory();
    [CompilerGeneratedAttribute]
public void set_EndOfCentralDirectory(long value);
    [CompilerGeneratedAttribute]
public int get_SignatureCentralDirectoryHeaderIndex();
    [CompilerGeneratedAttribute]
public void set_SignatureCentralDirectoryHeaderIndex(int value);
    public CentralDirectoryHeaderMetadata GetPackageSignatureFileCentralDirectoryHeaderMetadata();
}
public static class NuGet.Packaging.Signing.SignedPackageArchiveUtility : object {
    private static SigningSpecifications _signingSpecification;
    private static SignedPackageArchiveUtility();
    public static bool IsSigned(BinaryReader reader);
    public static Stream OpenPackageSignatureFileStream(BinaryReader reader);
    private static Stream GetPackageSignatureFile(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader);
    private static LocalFileHeader ReadPackageSignatureFileLocalFileHeader(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader);
    internal static bool IsPackageSignatureFileEntry(Byte[] fileName, ushort generalPurposeBitFlag);
    public static bool IsZip64(BinaryReader reader);
    private static bool HasZip64ExtendedInformationExtraField(CentralDirectoryHeader header);
    private static bool HasZip64ExtendedInformationExtraField(LocalFileHeader header);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchiveUtility/<RemoveRepositorySignaturesAsync>d__9")]
public static Task`1<bool> RemoveRepositorySignaturesAsync(Stream input, Stream output, CancellationToken cancellationToken);
    private static Task RemoveRepositoryPrimarySignatureAsync(Stream input, Stream output, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchiveUtility/<RemoveRepositoryCountersignaturesAsync>d__11")]
private static Task`1<bool> RemoveRepositoryCountersignaturesAsync(Stream input, Stream output, SignedCms signedCms, CancellationToken cancellationToken);
    private static bool TryRemoveRepositoryCountersignatures(SignedCms signedCms, SignedCms& updatedSignedCms);
    private static SignedCms Reencode(SignedCms signedCms);
    internal static void SignZip(MemoryStream signatureStream, BinaryReader reader, BinaryWriter writer);
    internal static void UnsignZip(BinaryReader reader, BinaryWriter writer);
    internal static bool VerifySignedPackageIntegrity(BinaryReader reader, HashAlgorithm hashAlgorithm, Byte[] expectedHash);
    private static List`1<CentralDirectoryHeaderMetadata> RemoveSignatureAndOrderByOffset(SignedPackageArchiveMetadata metadata);
    internal static string GetPackageContentHash(BinaryReader reader);
    internal static bool IsUtf8(ushort generalPurposeBitFlags);
    private static bool CompareHash(Byte[] expectedHash, Byte[] actualHash);
}
public class NuGet.Packaging.Signing.SignedPackageVerificationResult : PackageVerificationResult {
    [CompilerGeneratedAttribute]
private PrimarySignature <Signature>k__BackingField;
    public PrimarySignature Signature { get; }
    public SignedPackageVerificationResult(SignatureVerificationStatus trust, PrimarySignature signature, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public PrimarySignature get_Signature();
}
public class NuGet.Packaging.Signing.SignedPackageVerifierSettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowUnsigned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIllegal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIgnoreTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleTimestamps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNoTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private VerificationTarget <VerificationTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <SignaturePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationBehavior <RepositoryCountersignatureVerificationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private RevocationMode <RevocationMode>k__BackingField;
    public bool AllowUnsigned { get; }
    public bool AllowIllegal { get; }
    public bool AllowUntrusted { get; }
    public bool AllowIgnoreTimestamp { get; }
    public bool AllowMultipleTimestamps { get; }
    public bool AllowNoTimestamp { get; }
    public bool AllowUnknownRevocation { get; }
    public bool ReportUnknownRevocation { get; }
    public VerificationTarget VerificationTarget { get; }
    public SignaturePlacement SignaturePlacement { get; }
    public SignatureVerificationBehavior RepositoryCountersignatureVerificationBehavior { get; }
    public RevocationMode RevocationMode { get; }
    public SignedPackageVerifierSettings(bool allowUnsigned, bool allowIllegal, bool allowUntrusted, bool allowIgnoreTimestamp, bool allowMultipleTimestamps, bool allowNoTimestamp, bool allowUnknownRevocation, bool reportUnknownRevocation, VerificationTarget verificationTarget, SignaturePlacement signaturePlacement, SignatureVerificationBehavior repositoryCountersignatureVerificationBehavior, RevocationMode revocationMode);
    [CompilerGeneratedAttribute]
public bool get_AllowUnsigned();
    [CompilerGeneratedAttribute]
public bool get_AllowIllegal();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrusted();
    [CompilerGeneratedAttribute]
public bool get_AllowIgnoreTimestamp();
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleTimestamps();
    [CompilerGeneratedAttribute]
public bool get_AllowNoTimestamp();
    [CompilerGeneratedAttribute]
public bool get_AllowUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUnknownRevocation();
    [CompilerGeneratedAttribute]
public VerificationTarget get_VerificationTarget();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_SignaturePlacement();
    [CompilerGeneratedAttribute]
public SignatureVerificationBehavior get_RepositoryCountersignatureVerificationBehavior();
    [CompilerGeneratedAttribute]
public RevocationMode get_RevocationMode();
    public static SignedPackageVerifierSettings GetDefault(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetAcceptModeDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetRequireModeDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetVerifyCommandDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
}
public class NuGet.Packaging.Signing.SigningCertificate : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EssCertId> <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyInformation> <Policies>k__BackingField;
    public IReadOnlyList`1<EssCertId> Certificates { get; }
    public IReadOnlyList`1<PolicyInformation> Policies { get; }
    private SigningCertificate(IReadOnlyList`1<EssCertId> certificates, IReadOnlyList`1<PolicyInformation> policies);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EssCertId> get_Certificates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyInformation> get_Policies();
    public static SigningCertificate Read(Byte[] bytes);
    internal static SigningCertificate Read(DerSequenceReader reader);
    private static List`1<EssCertId> ReadCertificates(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyInformation> ReadPolicies(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.SigningCertificateV2 : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EssCertIdV2> <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyInformation> <Policies>k__BackingField;
    public IReadOnlyList`1<EssCertIdV2> Certificates { get; }
    public IReadOnlyList`1<PolicyInformation> Policies { get; }
    private SigningCertificateV2(IReadOnlyList`1<EssCertIdV2> certificates, IReadOnlyList`1<PolicyInformation> policies);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EssCertIdV2> get_Certificates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyInformation> get_Policies();
    public static SigningCertificateV2 Create(X509Certificate2 certificate, HashAlgorithmName hashAlgorithmName);
    public static SigningCertificateV2 Read(Byte[] bytes);
    internal static SigningCertificateV2 Read(DerSequenceReader reader);
    public Byte[] Encode();
    private static IReadOnlyList`1<EssCertIdV2> ReadCertificates(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyInformation> ReadPolicies(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.SigningOptions : object {
    private Lazy`1<Stream> _inputPackageStream;
    private Lazy`1<Stream> _outputPackageStream;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignatureProvider <SignatureProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public Stream InputPackageStream { get; }
    public Stream OutputPackageStream { get; }
    public bool Overwrite { get; }
    public ISignatureProvider SignatureProvider { get; }
    public ILogger Logger { get; }
    public SigningOptions(Lazy`1<Stream> inputPackageStream, Lazy`1<Stream> outputPackageStream, bool overwrite, ISignatureProvider signatureProvider, ILogger logger);
    public Stream get_InputPackageStream();
    public Stream get_OutputPackageStream();
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public ISignatureProvider get_SignatureProvider();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    public static SigningOptions CreateFromFilePaths(string inputPackageFilePath, string outputPackageFilePath, bool overwrite, ISignatureProvider signatureProvider, ILogger logger);
    public sealed virtual void Dispose();
    private static string NormalizeFilePath(string filePath);
}
public abstract class NuGet.Packaging.Signing.SigningSpecifications : object {
    public static SigningSpecificationsV1 V1;
    public string Version { get; }
    public string SignaturePath { get; }
    public HashAlgorithmName[] AllowedHashAlgorithms { get; }
    public String[] AllowedHashAlgorithmOids { get; }
    public SignatureAlgorithmName[] AllowedSignatureAlgorithms { get; }
    public String[] AllowedSignatureAlgorithmOids { get; }
    public int RSAPublicKeyMinLength { get; }
    public Encoding Encoding { get; }
    private static SigningSpecifications();
    public abstract virtual string get_Version();
    public abstract virtual string get_SignaturePath();
    public abstract virtual HashAlgorithmName[] get_AllowedHashAlgorithms();
    public abstract virtual String[] get_AllowedHashAlgorithmOids();
    public abstract virtual SignatureAlgorithmName[] get_AllowedSignatureAlgorithms();
    public abstract virtual String[] get_AllowedSignatureAlgorithmOids();
    public abstract virtual int get_RSAPublicKeyMinLength();
    public abstract virtual Encoding get_Encoding();
}
public class NuGet.Packaging.Signing.SigningSpecificationsV1 : SigningSpecifications {
    private static string _signaturePath;
    private static int _rsaPublicKeyMinLength;
    private static Encoding _encoding;
    private static HashAlgorithmName[] _allowedHashAlgorithms;
    private static String[] _allowedHashAlgorithmOids;
    private static SignatureAlgorithmName[] _allowedSignatureAlgorithms;
    private static String[] _allowedSignatureAlgorithmOids;
    public string Version { get; }
    public string SignaturePath { get; }
    public HashAlgorithmName[] AllowedHashAlgorithms { get; }
    public String[] AllowedHashAlgorithmOids { get; }
    public SignatureAlgorithmName[] AllowedSignatureAlgorithms { get; }
    public String[] AllowedSignatureAlgorithmOids { get; }
    public int RSAPublicKeyMinLength { get; }
    public Encoding Encoding { get; }
    private static SigningSpecificationsV1();
    public virtual string get_Version();
    public virtual string get_SignaturePath();
    public virtual HashAlgorithmName[] get_AllowedHashAlgorithms();
    public virtual String[] get_AllowedHashAlgorithmOids();
    public virtual SignatureAlgorithmName[] get_AllowedSignatureAlgorithms();
    public virtual String[] get_AllowedSignatureAlgorithmOids();
    public virtual int get_RSAPublicKeyMinLength();
    public virtual Encoding get_Encoding();
}
public static class NuGet.Packaging.Signing.SigningUtility : object {
    public static void Verify(SignPackageRequest request, ILogger logger);
    public static CryptographicAttributeObjectCollection CreateSignedAttributes(SignPackageRequest request, IReadOnlyList`1<X509Certificate2> chainList);
    public static CryptographicAttributeObjectCollection CreateSignedAttributes(RepositorySignPackageRequest request, IReadOnlyList`1<X509Certificate2> chainList);
    public static CmsSigner CreateCmsSigner(SignPackageRequest request, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SigningUtility/<SignAsync>d__4")]
public static Task SignAsync(SigningOptions options, SignPackageRequest signRequest, CancellationToken token);
    private static SignatureContent GenerateSignatureContent(HashAlgorithmName hashAlgorithmName, Byte[] zipArchiveHash);
}
public abstract class NuGet.Packaging.Signing.SignPackageRequest : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <SignatureHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <TimestampHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <AdditionalCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IX509CertificateChain <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private CngKey <PrivateKey>k__BackingField;
    public HashAlgorithmName SignatureHashAlgorithm { get; }
    public HashAlgorithmName TimestampHashAlgorithm { get; }
    public X509Certificate2 Certificate { get; }
    public X509Certificate2Collection AdditionalCertificates { get; }
    public SignatureType SignatureType { get; }
    internal IX509CertificateChain Chain { get; private set; }
    public CngKey PrivateKey { get; public set; }
    protected SignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_SignatureHashAlgorithm();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_TimestampHashAlgorithm();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_AdditionalCertificates();
    public abstract virtual SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
internal IX509CertificateChain get_Chain();
    [CompilerGeneratedAttribute]
private void set_Chain(IX509CertificateChain value);
    [CompilerGeneratedAttribute]
public CngKey get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(CngKey value);
    public sealed virtual void Dispose();
    internal void BuildSigningCertificateChainOnce(ILogger logger);
}
public class NuGet.Packaging.Signing.Timestamp : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <UpperLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LowerLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <GeneralizedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedCms <SignedCms>k__BackingField;
    [CompilerGeneratedAttribute]
private Rfc3161TimestampTokenInfo <TstInfo>k__BackingField;
    public DateTimeOffset UpperLimit { get; }
    public DateTimeOffset LowerLimit { get; }
    public DateTimeOffset GeneralizedTime { get; }
    public SignedCms SignedCms { get; }
    public SignerInfo SignerInfo { get; }
    internal Rfc3161TimestampTokenInfo TstInfo { get; }
    public Timestamp(SignedCms timestampCms);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_UpperLimit();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LowerLimit();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_GeneralizedTime();
    [CompilerGeneratedAttribute]
public SignedCms get_SignedCms();
    public SignerInfo get_SignerInfo();
    [CompilerGeneratedAttribute]
internal Rfc3161TimestampTokenInfo get_TstInfo();
    internal SignatureVerificationStatusFlags Verify(Signature signature, SignedPackageVerifierSettings settings, HashAlgorithmName fingerprintAlgorithm, List`1<SignatureLog> issues);
}
public class NuGet.Packaging.Signing.TimestampException : SignatureException {
    public TimestampException(NuGetLogCode code, string message);
    public TimestampException(NuGetLogCode code, string message, Exception innerException);
    public TimestampException(string message);
}
public class NuGet.Packaging.Signing.TimestampRequest : object {
    [CompilerGeneratedAttribute]
private SigningSpecifications <SigningSpecifications>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <Target>k__BackingField;
    public SigningSpecifications SigningSpecifications { get; }
    public Byte[] HashedMessage { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public SignaturePlacement Target { get; }
    public TimestampRequest(SigningSpecifications signingSpecifications, Byte[] hashedMessage, HashAlgorithmName hashAlgorithm, SignaturePlacement target);
    [CompilerGeneratedAttribute]
public SigningSpecifications get_SigningSpecifications();
    [CompilerGeneratedAttribute]
public Byte[] get_HashedMessage();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_Target();
}
public class NuGet.Packaging.Signing.TrustedSignerAllowListEntry : CertificateHashAllowListEntry {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrustedRoot>k__BackingField;
    public IReadOnlyList`1<string> Owners { get; }
    public bool AllowUntrustedRoot { get; }
    public TrustedSignerAllowListEntry(VerificationTarget target, SignaturePlacement placement, string fingerprint, HashAlgorithmName algorithm, bool allowUntrustedRoot, IReadOnlyList`1<string> owners);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrustedRoot();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Packaging.Signing.TrustedSignersProvider : object {
    private ISettings _settings;
    public TrustedSignersProvider(ISettings settings);
    public sealed virtual IReadOnlyList`1<TrustedSignerItem> GetTrustedSigners();
    public sealed virtual void Remove(IReadOnlyList`1<TrustedSignerItem> trustedSigners);
    public sealed virtual void AddOrUpdateTrustedSigner(TrustedSignerItem trustedSigner);
    public static IReadOnlyList`1<TrustedSignerAllowListEntry> GetAllowListEntries(ISettings settings, ILogger logger);
    private static string GetCertLookupKey(CertificateItem certificate);
    private static VerificationTarget GetItemTarget(TrustedSignerItem item, SignaturePlacement& placement);
}
public class NuGet.Packaging.Signing.TstInfo : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Oid <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageImprint <MessageImprint>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <GenTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Accuracy <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordering>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Tsa>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ExtensionCollection <Extensions>k__BackingField;
    public int Version { get; }
    public Oid Policy { get; }
    public MessageImprint MessageImprint { get; }
    public Byte[] SerialNumber { get; }
    public DateTimeOffset GenTime { get; }
    public Accuracy Accuracy { get; }
    public bool Ordering { get; }
    public Byte[] Nonce { get; }
    public Byte[] Tsa { get; }
    public X509ExtensionCollection Extensions { get; }
    private TstInfo(int version, Oid policy, MessageImprint messageImprint, Byte[] serialNumber, DateTimeOffset genTime, Accuracy accuracy, bool ordering, Byte[] nonce, Byte[] tsa, X509ExtensionCollection extensions);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public Oid get_Policy();
    [CompilerGeneratedAttribute]
public MessageImprint get_MessageImprint();
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_GenTime();
    [CompilerGeneratedAttribute]
public Accuracy get_Accuracy();
    [CompilerGeneratedAttribute]
public bool get_Ordering();
    [CompilerGeneratedAttribute]
public Byte[] get_Nonce();
    [CompilerGeneratedAttribute]
public Byte[] get_Tsa();
    [CompilerGeneratedAttribute]
public X509ExtensionCollection get_Extensions();
    public static TstInfo Read(Byte[] bytes);
    internal static TstInfo Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.UnknownPrimarySignature : PrimarySignature {
    public UnknownPrimarySignature(SignedCms signedCms);
}
internal class NuGet.Packaging.Signing.UnsignedPackageArchiveMetadata : object {
    [CompilerGeneratedAttribute]
private long <EndOfLocalFileHeadersPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOfCentralDirectoryHeadersPosition>k__BackingField;
    internal long EndOfLocalFileHeadersPosition { get; }
    internal long EndOfCentralDirectoryHeadersPosition { get; }
    internal UnsignedPackageArchiveMetadata(long endOfLocalFileHeadersPosition, long endOfCentralDirectoryHeadersPosition);
    [CompilerGeneratedAttribute]
internal long get_EndOfLocalFileHeadersPosition();
    [CompilerGeneratedAttribute]
internal long get_EndOfCentralDirectoryHeadersPosition();
}
public class NuGet.Packaging.Signing.UnsignedPackageVerificationResult : PackageVerificationResult {
    public UnsignedPackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
}
public abstract class NuGet.Packaging.Signing.VerificationAllowListEntry : object {
    [CompilerGeneratedAttribute]
private VerificationTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <Placement>k__BackingField;
    public VerificationTarget Target { get; }
    public SignaturePlacement Placement { get; }
    public VerificationAllowListEntry(VerificationTarget target, SignaturePlacement placement);
    [CompilerGeneratedAttribute]
public VerificationTarget get_Target();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_Placement();
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.VerificationTarget : Enum {
    public int value__;
    public static VerificationTarget None;
    public static VerificationTarget Unknown;
    public static VerificationTarget Author;
    public static VerificationTarget Repository;
    public static VerificationTarget All;
}
public static class NuGet.Packaging.Signing.VerificationUtility : object {
    public static SignatureVerificationStatus GetSignatureVerificationStatus(SignatureVerificationStatusFlags flags);
    public static bool IsVerificationTarget(SignatureType signatureType, VerificationTarget target);
    internal static SignatureVerificationStatusFlags ValidateSigningCertificate(X509Certificate2 certificate, bool treatIssuesAsErrors, string signatureFriendlyName, List`1<SignatureLog> issues);
    internal static SignatureVerificationStatusFlags ValidateTimestamp(Timestamp timestamp, Signature signature, bool treatIssuesAsErrors, List`1<SignatureLog> issues, SigningSpecifications spec);
}
public class NuGet.Packaging.Signing.VerifySignaturesResult : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageVerificationResult> <Results>k__BackingField;
    public bool IsValid { get; }
    public bool IsSigned { get; }
    public IReadOnlyList`1<PackageVerificationResult> Results { get; }
    public VerifySignaturesResult(bool isValid, bool isSigned);
    public VerifySignaturesResult(bool isValid, bool isSigned, IEnumerable`1<PackageVerificationResult> results);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public bool get_IsSigned();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageVerificationResult> get_Results();
}
public class NuGet.Packaging.Signing.X509CertificateChain : List`1<X509Certificate2> {
    private bool _isDisposed;
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.Signing.X509ChainHolder : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private X509Chain <Chain>k__BackingField;
    public X509Chain Chain { get; }
    [CompilerGeneratedAttribute]
public X509Chain get_Chain();
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.Signing.X509SignatureProvider : object {
    private static int INVALID_PROVIDER_TYPE_HRESULT;
    private ITimestampProvider _timestampProvider;
    public X509SignatureProvider(ITimestampProvider timestampProvider);
    public sealed virtual Task`1<PrimarySignature> CreatePrimarySignatureAsync(SignPackageRequest request, SignatureContent signatureContent, ILogger logger, CancellationToken token);
    public sealed virtual Task`1<PrimarySignature> CreateRepositoryCountersignatureAsync(RepositorySignPackageRequest request, PrimarySignature primarySignature, ILogger logger, CancellationToken token);
    private static PrimarySignature CreatePrimarySignature(SignPackageRequest request, SignatureContent signatureContent, ILogger logger);
    private static PrimarySignature CreateRepositoryCountersignature(SignPackageRequest request, PrimarySignature primarySignature, ILogger logger);
    private static PrimarySignature CreatePrimarySignature(CmsSigner cmsSigner, Byte[] signingData, CngKey privateKey);
    private static PrimarySignature CreatePrimarySignature(CmsSigner cmsSigner, SignPackageRequest request, Byte[] signingData);
    private static PrimarySignature CreateRepositoryCountersignature(CmsSigner cmsSigner, PrimarySignature primarySignature, CngKey privateKey);
    private static PrimarySignature CreateRepositoryCountersignature(CmsSigner cmsSigner, SignPackageRequest request, PrimarySignature primarySignature);
    private Task`1<PrimarySignature> TimestampPrimarySignatureAsync(SignPackageRequest request, ILogger logger, PrimarySignature signature, CancellationToken token);
    private Task`1<PrimarySignature> TimestampRepositoryCountersignatureAsync(SignPackageRequest request, ILogger logger, PrimarySignature primarySignature, CancellationToken token);
}
internal class NuGet.Packaging.Signing.Zip64EndOfCentralDirectoryLocator : object {
    internal static UInt32 Signature;
    internal static UInt32 SizeInBytes;
    internal static bool Exists(BinaryReader reader);
}
internal class NuGet.Packaging.Signing.Zip64ExtendedInformationExtraField : ExtraField {
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <OriginalUncompressedFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <SizeOfCompressedData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <OffsetOfLocalHeaderRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <NumberOfDiskOnWhichThisFileStarts>k__BackingField;
    internal Nullable`1<ulong> OriginalUncompressedFileSize { get; private set; }
    internal Nullable`1<ulong> SizeOfCompressedData { get; private set; }
    internal Nullable`1<ulong> OffsetOfLocalHeaderRecord { get; private set; }
    internal Nullable`1<UInt32> NumberOfDiskOnWhichThisFileStarts { get; private set; }
    private Zip64ExtendedInformationExtraField(ushort headerId, ushort dataSize, Byte[] data, Nullable`1<ulong> originalUncompressedFileSize, Nullable`1<ulong> sizeOfCompressedData, Nullable`1<ulong> offsetOfLocalHeaderRecord, Nullable`1<UInt32> numberOfDiskOnWhichThisFileStarts);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_OriginalUncompressedFileSize();
    [CompilerGeneratedAttribute]
private void set_OriginalUncompressedFileSize(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_SizeOfCompressedData();
    [CompilerGeneratedAttribute]
private void set_SizeOfCompressedData(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_OffsetOfLocalHeaderRecord();
    [CompilerGeneratedAttribute]
private void set_OffsetOfLocalHeaderRecord(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<UInt32> get_NumberOfDiskOnWhichThisFileStarts();
    [CompilerGeneratedAttribute]
private void set_NumberOfDiskOnWhichThisFileStarts(Nullable`1<UInt32> value);
    internal static Zip64ExtendedInformationExtraField Read(ushort headerId, ushort dataSize, Byte[] data, bool readUncompressedFileSize, bool readCompressedFileSize, bool readRelativeOffsetOfLocalHeader, bool readDiskNumberStart);
}
internal static class NuGet.Packaging.Signing.ZipConstants : object {
    internal static ushort Mask16Bit;
    internal static UInt32 Mask32Bit;
    private static ZipConstants();
}
[ExtensionAttribute]
public static class NuGet.Packaging.StreamExtensions : object {
    [ExtensionAttribute]
public static string CopyToFile(Stream inputStream, string fileFullPath);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.StringExtensions : object {
    [ExtensionAttribute]
public static string SafeTrim(string value);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string AuthorPrimarySignatureFriendlyName { get; }
    internal static string CertificateChainBuildFailed { get; }
    internal static string CertificateChainValidationFailed { get; }
    internal static string CertUtilityCertificateHash { get; }
    internal static string CertUtilityCertificateHashSha1 { get; }
    internal static string CertUtilityCertificateIssuer { get; }
    internal static string CertUtilityCertificateSubjectName { get; }
    internal static string CertUtilityCertificateValidity { get; }
    internal static string CertUtilityMultipleCertificatesFooter { get; }
    internal static string CertUtilityMultipleCertificatesHeader { get; }
    internal static string CommitmentTypeIndicationAttributeInvalid { get; }
    internal static string CommitmentTypeIndicationAttributeInvalidCombination { get; }
    internal static string ConflictingAllowUntrustedRoot { get; }
    internal static string DefaultError_EmptyAllowList { get; }
    internal static string DefaultError_NoMatchInAllowList { get; }
    internal static string Error_InvalidTargetFramework { get; }
    internal static string Error_LoadingHashFile { get; }
    internal static string Error_MissingNuspecFile { get; }
    internal static string Error_NoClientAllowList { get; }
    internal static string Error_NoMatchingClientCertificate { get; }
    internal static string Error_NoMatchingRepositoryCertificate { get; }
    internal static string Error_NoRepoAllowList { get; }
    internal static string Error_NotOnePrimarySignature { get; }
    internal static string Error_NotOneRepositoryCounterSignature { get; }
    internal static string Error_RepositorySettings_UnsignedPackage { get; }
    internal static string Error_RepositorySignatureMustNotHaveARepositoryCountersignature { get; }
    internal static string Error_RequireMode_UnsignedPackage { get; }
    internal static string ErrorAuthorTargetCannotBeACountersignature { get; }
    internal static string ErrorByteSignatureNotFound { get; }
    internal static string ErrorByteSignatureTooBig { get; }
    internal static string ErrorDuplicatePackages { get; }
    internal static string ErrorInvalidAllowedVersions { get; }
    internal static string ErrorInvalidCertificateChainUnspecifiedReason { get; }
    internal static string ErrorInvalidMinClientVersion { get; }
    internal static string ErrorInvalidPackageArchive { get; }
    internal static string ErrorInvalidPackageVersion { get; }
    internal static string ErrorInvalidPackageVersionForDependency { get; }
    internal static string ErrorManifestFileNotFound { get; }
    internal static string ErrorMultipleTimestamps { get; }
    internal static string ErrorNoTimestamp { get; }
    internal static string ErrorNullOrEmptyPackageId { get; }
    internal static string ErrorPackageNotSigned { get; }
    internal static string ErrorPackageSignatureInvalid { get; }
    internal static string ErrorUnableCheckPackageEntries { get; }
    internal static string ErrorUnableToDeleteFile { get; }
    internal static string ErrorUnsafePackageEntry { get; }
    internal static string ErrorZip64NotSupported { get; }
    internal static string ExactlyOneAttributeRequired { get; }
    internal static string ExactlyOneAttributeValueRequired { get; }
    internal static string ExtractionLog_InformationPrefix { get; }
    internal static string FailedFileTime { get; }
    internal static string FailToLoadPackagesConfig { get; }
    internal static string FailToWritePackagesConfig { get; }
    internal static string FallbackFolderNotFound { get; }
    internal static string InvalidArgument { get; }
    internal static string InvalidArgumentCombination { get; }
    internal static string InvalidAsn1 { get; }
    internal static string InvalidLicenseExppressionVersion_VersionTooHigh { get; }
    internal static string InvalidNuspecElement { get; }
    internal static string InvalidNuspecEntry { get; }
    internal static string InvalidPackageFrameworkFolderName { get; }
    internal static string InvalidPackageNupkg { get; }
    internal static string InvalidPackageSignature { get; }
    internal static string InvalidPackageSignatureFile { get; }
    internal static string InvalidPackageSignatureFileEntry { get; }
    internal static string InvalidPackageSignatureFileEntryCentralDirectoryHeader { get; }
    internal static string InvalidPackageSignatureFileEntryLocalFileHeader { get; }
    internal static string InvalidPackageTypeVersion { get; }
    internal static string InvalidPrimarySignature { get; }
    internal static string InvalidRepositoryCountersignature { get; }
    internal static string InvalidSignatureContent { get; }
    internal static string InvalidTimestampSignature { get; }
    internal static string InvalidUrl { get; }
    internal static string Log_InstallingPackage { get; }
    internal static string Message_Path { get; }
    internal static string MinClientVersionAlreadyExist { get; }
    internal static string MissingMetadataNode { get; }
    internal static string MissingPackageTypeName { get; }
    internal static string MultipleAttributesDisallowed { get; }
    internal static string MultipleNuspecFiles { get; }
    internal static string MultiplePackageSignatureFiles { get; }
    internal static string MultiplePackageTypes { get; }
    internal static string MustContainAbsolutePath { get; }
    internal static string NoPackageSignatureFile { get; }
    internal static string NoRepositoryCountersignature { get; }
    internal static string NuGetLicense_InvalidLicenseExpression { get; }
    internal static string NuGetLicense_InvalidLicenseExpressionVersion { get; }
    internal static string NuGetLicense_InvalidLicenseType { get; }
    internal static string NuGetLicense_LicenseElementMissingValue { get; }
    internal static string NuGetLicense_LicenseExpressionVersionTooHigh { get; }
    internal static string NuGetLicense_MissingRequiredValue { get; }
    internal static string NuGetLicenseExpression_DeprecatedIdentifier { get; }
    internal static string NuGetLicenseExpression_ExceptionIdentifierIsLicense { get; }
    internal static string NuGetLicenseExpression_IllegalUnlicensedOperator { get; }
    internal static string NuGetLicenseExpression_InvalidCharacters { get; }
    internal static string NuGetLicenseExpression_InvalidExceptionIdentifier { get; }
    internal static string NuGetLicenseExpression_InvalidExpression { get; }
    internal static string NuGetLicenseExpression_InvalidToken { get; }
    internal static string NuGetLicenseExpression_LicenseIdentifierIsException { get; }
    internal static string NuGetLicenseExpression_LicenseInvalidCharacters { get; }
    internal static string NuGetLicenseExpression_MismatchedParentheses { get; }
    internal static string NuGetLicenseExpression_NonStandardIdentifier { get; }
    internal static string NuGetLicenseExpression_UnexpectedIdentifier { get; }
    internal static string NuGetLicenseExpression_UnlicensedPackageWarning { get; }
    internal static string NuGetPackageOwners { get; }
    internal static string NuGetPackageOwnersInvalid { get; }
    internal static string NuGetPackageOwnersInvalidValue { get; }
    internal static string NuGetV3ServiceIndexUrl { get; }
    internal static string NuGetV3ServiceIndexUrlInvalid { get; }
    internal static string NuGetV3ServiceIndexUrlInvalidValue { get; }
    internal static string PackageEntryAlreadyExist { get; }
    internal static string PackageEntryNotExist { get; }
    internal static string PackageMinVersionNotSatisfied { get; }
    internal static string PackageSignatureVerificationLog { get; }
    internal static string PackagesNodeNotExist { get; }
    internal static string PackageStreamShouldBeSeekable { get; }
    internal static string PrimarySignatureFriendlyName { get; }
    internal static string PrimarySignatureHasNoTimestamp { get; }
    internal static string RangeOutOfBoundsForArray { get; }
    internal static string RepositoryCountersignatureFriendlyName { get; }
    internal static string RepositoryCountersignatureHasNoCertificate { get; }
    internal static string RepositoryCountersignatureHasNoTimestamp { get; }
    internal static string RepositoryPrimarySignatureFriendlyName { get; }
    internal static string SignatureContainsInvalidAttribute { get; }
    internal static string SignatureDebug_HashOidFound { get; }
    internal static string SignatureFailureInvalidHashAlgorithmOid { get; }
    internal static string SignatureFriendlyName { get; }
    internal static string SignatureHashAlgorithm { get; }
    internal static string SignatureInvalidGeneralPurposeBits { get; }
    internal static string SignaturePackageIntegrityFailure { get; }
    internal static string SignatureType { get; }
    internal static string SignedPackageAlreadySigned { get; }
    internal static string SignedPackageArchiveIOExtraRead { get; }
    internal static string SignedPackageArchiveIOInvalidRead { get; }
    internal static string SignedPackageNotSignedOnRemove { get; }
    internal static string SignedPackageNotSignedOnVerify { get; }
    internal static string SignedPackagePackageAlreadyCountersigned { get; }
    internal static string SignedPackageUnableToAccessSignature { get; }
    internal static string SignError_TimestampCertificateFailsPublicKeyLengthRequirement { get; }
    internal static string SignError_TimestampGeneralizedTimeInvalid { get; }
    internal static string SignError_TimestampIntegrityCheckFailed { get; }
    internal static string SignError_TimestampNoCertificate { get; }
    internal static string SignError_TimestampNotYetValid { get; }
    internal static string SignError_TimestampSignatureValidationFailed { get; }
    internal static string SignFailureCertificateInvalidProviderType { get; }
    internal static string SigningCannotBeDoneInPlace { get; }
    internal static string SigningCertificateAttributeMustNotBePresent { get; }
    internal static string SigningCertificateCertificateNotFound { get; }
    internal static string SigningCertificateInvalid { get; }
    internal static string SigningCertificateV1OrV2AttributeMustBePresent { get; }
    internal static string SigningCertificateV2CertificateNotFound { get; }
    internal static string SigningCertificateV2Invalid { get; }
    internal static string SigningCertificateV2NotExactlyOneAttributeValue { get; }
    internal static string SigningCertificateV2UnsupportedHashAlgorithm { get; }
    internal static string SigningError_CertificateFailsPublicKeyLengthRequirement { get; }
    internal static string SigningError_CertificateHasLifetimeSigningEKU { get; }
    internal static string SigningError_CertificateHasUnsupportedSignatureAlgorithm { get; }
    internal static string SigningError_NotYetValid { get; }
    internal static string SigningWouldRequireZip64 { get; }
    internal static string StreamMustBeReadable { get; }
    internal static string StreamMustBeSeekable { get; }
    internal static string StringCannotBeNullOrEmpty { get; }
    internal static string TimestampCertificateInvalid { get; }
    internal static string TimestampCertificateUnsupportedSignatureAlgorithm { get; }
    internal static string TimestampFailureInvalidHttpScheme { get; }
    internal static string TimestampFailureNonceMismatch { get; }
    internal static string TimestampResponseExceptionGeneral { get; }
    internal static string TimestampSignatureUnsupportedDigestAlgorithm { get; }
    internal static string TimestampValue { get; }
    internal static string UnableToAddEntry { get; }
    internal static string UnableToParseClientVersion { get; }
    internal static string UnableToReadPackageHashInformation { get; }
    internal static string UnexpectedPackageSignatureVerificationError { get; }
    internal static string UnrecognizedEnumValue { get; }
    internal static string UnrelatedSignatures { get; }
    internal static string UnsupportedAsn1 { get; }
    internal static string UnsupportedSignatureFormatVersion { get; }
    internal static string VerificationCertDisplay { get; }
    internal static string VerificationTimestamperCertDisplay { get; }
    internal static string Verify_ErrorNoCertificate { get; }
    internal static string VerifyCertTrustOfflineWhileRevocationModeOffline { get; }
    internal static string VerifyCertTrustOfflineWhileRevocationModeOnline { get; }
    internal static string VerifyChainBuildingIssue { get; }
    internal static string VerifyError_CertificateFailsPublicKeyLengthRequirement { get; }
    internal static string VerifyError_CertificateHasLifetimeSigningEKU { get; }
    internal static string VerifyError_CertificateHasUnsupportedSignatureAlgorithm { get; }
    internal static string VerifyError_CertificateNotYetValid { get; }
    internal static string VerifyError_InvalidCertificateChain { get; }
    internal static string VerifyError_SignatureNotTimeValid { get; }
    internal static string VerifyError_SignatureVerificationFailed { get; }
    internal static string VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement { get; }
    internal static string VerifyError_TimestampGeneralizedTimeInvalid { get; }
    internal static string VerifyError_TimestampIntegrityCheckFailed { get; }
    internal static string VerifyError_TimestampInvalid { get; }
    internal static string VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm { get; }
    internal static string VerifyError_TimestampNoCertificate { get; }
    internal static string VerifyError_TimestampNotYetValid { get; }
    internal static string VerifyError_TimestampSignatureUnsupportedDigestAlgorithm { get; }
    internal static string VerifyError_TimestampSignatureValidationFailed { get; }
    internal static string VerifyError_TimestampUnsupportedSignatureAlgorithm { get; }
    internal static string VerifyError_TimestampVerifyChainBuildingIssue { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_AuthorPrimarySignatureFriendlyName();
    internal static string get_CertificateChainBuildFailed();
    internal static string get_CertificateChainValidationFailed();
    internal static string get_CertUtilityCertificateHash();
    internal static string get_CertUtilityCertificateHashSha1();
    internal static string get_CertUtilityCertificateIssuer();
    internal static string get_CertUtilityCertificateSubjectName();
    internal static string get_CertUtilityCertificateValidity();
    internal static string get_CertUtilityMultipleCertificatesFooter();
    internal static string get_CertUtilityMultipleCertificatesHeader();
    internal static string get_CommitmentTypeIndicationAttributeInvalid();
    internal static string get_CommitmentTypeIndicationAttributeInvalidCombination();
    internal static string get_ConflictingAllowUntrustedRoot();
    internal static string get_DefaultError_EmptyAllowList();
    internal static string get_DefaultError_NoMatchInAllowList();
    internal static string get_Error_InvalidTargetFramework();
    internal static string get_Error_LoadingHashFile();
    internal static string get_Error_MissingNuspecFile();
    internal static string get_Error_NoClientAllowList();
    internal static string get_Error_NoMatchingClientCertificate();
    internal static string get_Error_NoMatchingRepositoryCertificate();
    internal static string get_Error_NoRepoAllowList();
    internal static string get_Error_NotOnePrimarySignature();
    internal static string get_Error_NotOneRepositoryCounterSignature();
    internal static string get_Error_RepositorySettings_UnsignedPackage();
    internal static string get_Error_RepositorySignatureMustNotHaveARepositoryCountersignature();
    internal static string get_Error_RequireMode_UnsignedPackage();
    internal static string get_ErrorAuthorTargetCannotBeACountersignature();
    internal static string get_ErrorByteSignatureNotFound();
    internal static string get_ErrorByteSignatureTooBig();
    internal static string get_ErrorDuplicatePackages();
    internal static string get_ErrorInvalidAllowedVersions();
    internal static string get_ErrorInvalidCertificateChainUnspecifiedReason();
    internal static string get_ErrorInvalidMinClientVersion();
    internal static string get_ErrorInvalidPackageArchive();
    internal static string get_ErrorInvalidPackageVersion();
    internal static string get_ErrorInvalidPackageVersionForDependency();
    internal static string get_ErrorManifestFileNotFound();
    internal static string get_ErrorMultipleTimestamps();
    internal static string get_ErrorNoTimestamp();
    internal static string get_ErrorNullOrEmptyPackageId();
    internal static string get_ErrorPackageNotSigned();
    internal static string get_ErrorPackageSignatureInvalid();
    internal static string get_ErrorUnableCheckPackageEntries();
    internal static string get_ErrorUnableToDeleteFile();
    internal static string get_ErrorUnsafePackageEntry();
    internal static string get_ErrorZip64NotSupported();
    internal static string get_ExactlyOneAttributeRequired();
    internal static string get_ExactlyOneAttributeValueRequired();
    internal static string get_ExtractionLog_InformationPrefix();
    internal static string get_FailedFileTime();
    internal static string get_FailToLoadPackagesConfig();
    internal static string get_FailToWritePackagesConfig();
    internal static string get_FallbackFolderNotFound();
    internal static string get_InvalidArgument();
    internal static string get_InvalidArgumentCombination();
    internal static string get_InvalidAsn1();
    internal static string get_InvalidLicenseExppressionVersion_VersionTooHigh();
    internal static string get_InvalidNuspecElement();
    internal static string get_InvalidNuspecEntry();
    internal static string get_InvalidPackageFrameworkFolderName();
    internal static string get_InvalidPackageNupkg();
    internal static string get_InvalidPackageSignature();
    internal static string get_InvalidPackageSignatureFile();
    internal static string get_InvalidPackageSignatureFileEntry();
    internal static string get_InvalidPackageSignatureFileEntryCentralDirectoryHeader();
    internal static string get_InvalidPackageSignatureFileEntryLocalFileHeader();
    internal static string get_InvalidPackageTypeVersion();
    internal static string get_InvalidPrimarySignature();
    internal static string get_InvalidRepositoryCountersignature();
    internal static string get_InvalidSignatureContent();
    internal static string get_InvalidTimestampSignature();
    internal static string get_InvalidUrl();
    internal static string get_Log_InstallingPackage();
    internal static string get_Message_Path();
    internal static string get_MinClientVersionAlreadyExist();
    internal static string get_MissingMetadataNode();
    internal static string get_MissingPackageTypeName();
    internal static string get_MultipleAttributesDisallowed();
    internal static string get_MultipleNuspecFiles();
    internal static string get_MultiplePackageSignatureFiles();
    internal static string get_MultiplePackageTypes();
    internal static string get_MustContainAbsolutePath();
    internal static string get_NoPackageSignatureFile();
    internal static string get_NoRepositoryCountersignature();
    internal static string get_NuGetLicense_InvalidLicenseExpression();
    internal static string get_NuGetLicense_InvalidLicenseExpressionVersion();
    internal static string get_NuGetLicense_InvalidLicenseType();
    internal static string get_NuGetLicense_LicenseElementMissingValue();
    internal static string get_NuGetLicense_LicenseExpressionVersionTooHigh();
    internal static string get_NuGetLicense_MissingRequiredValue();
    internal static string get_NuGetLicenseExpression_DeprecatedIdentifier();
    internal static string get_NuGetLicenseExpression_ExceptionIdentifierIsLicense();
    internal static string get_NuGetLicenseExpression_IllegalUnlicensedOperator();
    internal static string get_NuGetLicenseExpression_InvalidCharacters();
    internal static string get_NuGetLicenseExpression_InvalidExceptionIdentifier();
    internal static string get_NuGetLicenseExpression_InvalidExpression();
    internal static string get_NuGetLicenseExpression_InvalidToken();
    internal static string get_NuGetLicenseExpression_LicenseIdentifierIsException();
    internal static string get_NuGetLicenseExpression_LicenseInvalidCharacters();
    internal static string get_NuGetLicenseExpression_MismatchedParentheses();
    internal static string get_NuGetLicenseExpression_NonStandardIdentifier();
    internal static string get_NuGetLicenseExpression_UnexpectedIdentifier();
    internal static string get_NuGetLicenseExpression_UnlicensedPackageWarning();
    internal static string get_NuGetPackageOwners();
    internal static string get_NuGetPackageOwnersInvalid();
    internal static string get_NuGetPackageOwnersInvalidValue();
    internal static string get_NuGetV3ServiceIndexUrl();
    internal static string get_NuGetV3ServiceIndexUrlInvalid();
    internal static string get_NuGetV3ServiceIndexUrlInvalidValue();
    internal static string get_PackageEntryAlreadyExist();
    internal static string get_PackageEntryNotExist();
    internal static string get_PackageMinVersionNotSatisfied();
    internal static string get_PackageSignatureVerificationLog();
    internal static string get_PackagesNodeNotExist();
    internal static string get_PackageStreamShouldBeSeekable();
    internal static string get_PrimarySignatureFriendlyName();
    internal static string get_PrimarySignatureHasNoTimestamp();
    internal static string get_RangeOutOfBoundsForArray();
    internal static string get_RepositoryCountersignatureFriendlyName();
    internal static string get_RepositoryCountersignatureHasNoCertificate();
    internal static string get_RepositoryCountersignatureHasNoTimestamp();
    internal static string get_RepositoryPrimarySignatureFriendlyName();
    internal static string get_SignatureContainsInvalidAttribute();
    internal static string get_SignatureDebug_HashOidFound();
    internal static string get_SignatureFailureInvalidHashAlgorithmOid();
    internal static string get_SignatureFriendlyName();
    internal static string get_SignatureHashAlgorithm();
    internal static string get_SignatureInvalidGeneralPurposeBits();
    internal static string get_SignaturePackageIntegrityFailure();
    internal static string get_SignatureType();
    internal static string get_SignedPackageAlreadySigned();
    internal static string get_SignedPackageArchiveIOExtraRead();
    internal static string get_SignedPackageArchiveIOInvalidRead();
    internal static string get_SignedPackageNotSignedOnRemove();
    internal static string get_SignedPackageNotSignedOnVerify();
    internal static string get_SignedPackagePackageAlreadyCountersigned();
    internal static string get_SignedPackageUnableToAccessSignature();
    internal static string get_SignError_TimestampCertificateFailsPublicKeyLengthRequirement();
    internal static string get_SignError_TimestampGeneralizedTimeInvalid();
    internal static string get_SignError_TimestampIntegrityCheckFailed();
    internal static string get_SignError_TimestampNoCertificate();
    internal static string get_SignError_TimestampNotYetValid();
    internal static string get_SignError_TimestampSignatureValidationFailed();
    internal static string get_SignFailureCertificateInvalidProviderType();
    internal static string get_SigningCannotBeDoneInPlace();
    internal static string get_SigningCertificateAttributeMustNotBePresent();
    internal static string get_SigningCertificateCertificateNotFound();
    internal static string get_SigningCertificateInvalid();
    internal static string get_SigningCertificateV1OrV2AttributeMustBePresent();
    internal static string get_SigningCertificateV2CertificateNotFound();
    internal static string get_SigningCertificateV2Invalid();
    internal static string get_SigningCertificateV2NotExactlyOneAttributeValue();
    internal static string get_SigningCertificateV2UnsupportedHashAlgorithm();
    internal static string get_SigningError_CertificateFailsPublicKeyLengthRequirement();
    internal static string get_SigningError_CertificateHasLifetimeSigningEKU();
    internal static string get_SigningError_CertificateHasUnsupportedSignatureAlgorithm();
    internal static string get_SigningError_NotYetValid();
    internal static string get_SigningWouldRequireZip64();
    internal static string get_StreamMustBeReadable();
    internal static string get_StreamMustBeSeekable();
    internal static string get_StringCannotBeNullOrEmpty();
    internal static string get_TimestampCertificateInvalid();
    internal static string get_TimestampCertificateUnsupportedSignatureAlgorithm();
    internal static string get_TimestampFailureInvalidHttpScheme();
    internal static string get_TimestampFailureNonceMismatch();
    internal static string get_TimestampResponseExceptionGeneral();
    internal static string get_TimestampSignatureUnsupportedDigestAlgorithm();
    internal static string get_TimestampValue();
    internal static string get_UnableToAddEntry();
    internal static string get_UnableToParseClientVersion();
    internal static string get_UnableToReadPackageHashInformation();
    internal static string get_UnexpectedPackageSignatureVerificationError();
    internal static string get_UnrecognizedEnumValue();
    internal static string get_UnrelatedSignatures();
    internal static string get_UnsupportedAsn1();
    internal static string get_UnsupportedSignatureFormatVersion();
    internal static string get_VerificationCertDisplay();
    internal static string get_VerificationTimestamperCertDisplay();
    internal static string get_Verify_ErrorNoCertificate();
    internal static string get_VerifyCertTrustOfflineWhileRevocationModeOffline();
    internal static string get_VerifyCertTrustOfflineWhileRevocationModeOnline();
    internal static string get_VerifyChainBuildingIssue();
    internal static string get_VerifyError_CertificateFailsPublicKeyLengthRequirement();
    internal static string get_VerifyError_CertificateHasLifetimeSigningEKU();
    internal static string get_VerifyError_CertificateHasUnsupportedSignatureAlgorithm();
    internal static string get_VerifyError_CertificateNotYetValid();
    internal static string get_VerifyError_InvalidCertificateChain();
    internal static string get_VerifyError_SignatureNotTimeValid();
    internal static string get_VerifyError_SignatureVerificationFailed();
    internal static string get_VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement();
    internal static string get_VerifyError_TimestampGeneralizedTimeInvalid();
    internal static string get_VerifyError_TimestampIntegrityCheckFailed();
    internal static string get_VerifyError_TimestampInvalid();
    internal static string get_VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm();
    internal static string get_VerifyError_TimestampNoCertificate();
    internal static string get_VerifyError_TimestampNotYetValid();
    internal static string get_VerifyError_TimestampSignatureUnsupportedDigestAlgorithm();
    internal static string get_VerifyError_TimestampSignatureValidationFailed();
    internal static string get_VerifyError_TimestampUnsupportedSignatureAlgorithm();
    internal static string get_VerifyError_TimestampVerifyChainBuildingIssue();
}
public static class NuGet.Packaging.TopologicalSortUtility : object {
    public static IReadOnlyList`1<T> SortPackagesByDependencyOrder(IEnumerable`1<T> items, StringComparer comparer, Func`2<T, string> getId, Func`2<T, String[]> getDependencies);
    public static IReadOnlyList`1<PackageDependencyInfo> SortPackagesByDependencyOrder(IEnumerable`1<PackageDependencyInfo> packages);
    private static List`1<ItemDependencyInfo> SortPackagesByDependencyOrder(List`1<ItemDependencyInfo> items, StringComparer comparer);
    private static void UpdateChildCounts(ItemDependencyInfo package);
    private static void CalculateRelationships(ItemDependencyInfo[] packages, Dictionary`2<string, ItemDependencyInfo> lookup);
    private static string GetPackageDependencyInfoId(PackageDependencyInfo info);
    private static String[] GetPackageDependencyInfoDependencies(PackageDependencyInfo info);
}
public class NuGet.Packaging.UnsafePackageEntryException : PackagingException {
    public UnsafePackageEntryException(string message);
    public virtual ILogMessage AsLogMessage();
}
public class NuGet.Packaging.VersionFolderPathResolver : object {
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLowerCase>k__BackingField;
    public string RootPath { get; }
    public bool IsLowerCase { get; }
    public VersionFolderPathResolver(string rootPath);
    public VersionFolderPathResolver(string rootPath, bool isLowercase);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public bool get_IsLowerCase();
    public virtual string GetInstallPath(string packageId, NuGetVersion version);
    public string GetVersionListPath(string packageId);
    public string GetPackageFilePath(string packageId, NuGetVersion version);
    public string GetManifestFilePath(string packageId, NuGetVersion version);
    public string GetHashPath(string packageId, NuGetVersion version);
    public string GetHashFileName(string packageId, NuGetVersion version);
    public string GetNupkgMetadataPath(string packageId, NuGetVersion version);
    public virtual string GetVersionListDirectory(string packageId);
    public virtual string GetPackageDirectory(string packageId, NuGetVersion version);
    public virtual string GetPackageFileName(string packageId, NuGetVersion version);
    public string GetPackageDownloadMarkerFileName(string packageId);
    public virtual string GetManifestFileName(string packageId, NuGetVersion version);
    private string Normalize(NuGetVersion version);
    private string Normalize(string packageId);
}
[ExtensionAttribute]
public static class NuGet.Packaging.XElementExtensions : object {
    [ExtensionAttribute]
public static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(XContainer container, string localName);
    [ExtensionAttribute]
public static XElement Except(XElement source, XElement target);
    private static XElement FindElement(XElement source, XElement targetChild);
    private static int Compare(XElement target, XElement left, XElement right);
    private static int CountMatches(XElement left, XElement right, Func`3<XAttribute, XAttribute, bool> matcher);
    private static bool HasComment(XElement element, XComment comment);
    private static bool HasConflict(XElement source, XElement target);
    private static bool AttributeEquals(XAttribute source, XAttribute target);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Xml.PackageMetadataXmlExtensions : object {
    private static string References;
    private static string Reference;
    private static string Group;
    private static string File;
    private static string TargetFramework;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Dependencies;
    private static string Files;
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns);
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns, bool generateBackwardsCompatible);
    private static XElement GetXElementFromGroupableItemSets(XNamespace ns, IEnumerable`1<TSet> objectSets, Func`2<TSet, bool> isGroupable, Func`2<TSet, string> getGroupIdentifer, Func`2<TSet, IEnumerable`1<TItem>> getItems, Func`3<XNamespace, TItem, XElement> getXElementFromItem, string parentName, string identifierAttributeName);
    private static XElement GetXElementFromFrameworkReference(XNamespace ns, FrameworkReference frameworkReference);
    private static XElement GetXElementFromPackageReference(XNamespace ns, string reference);
    private static XElement GetXElementFromPackageDependency(XNamespace ns, PackageDependency dependency);
    private static XElement GetXElementFromFrameworkAssemblies(XNamespace ns, IEnumerable`1<FrameworkAssemblyReference> references);
    private static XElement GetXElementFromManifestContentFiles(XNamespace ns, IEnumerable`1<ManifestContentFiles> contentFiles);
    private static XElement GetXElementFromManifestContentFile(XNamespace ns, ManifestContentFiles file);
    private static XElement GetXElementFromLicenseMetadata(XNamespace ns, LicenseMetadata metadata);
    private static XElement GetXElementFromManifestRepository(XNamespace ns, RepositoryMetadata repository);
    private static XElement GetXElementFromManifestPackageTypes(XNamespace ns, IEnumerable`1<PackageType> packageTypes);
    private static XElement GetXElementFromManifestPackageType(XNamespace ns, PackageType packageType);
    private static XAttribute GetXAttributeFromNameAndValue(string name, object value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value, Func`2<T, object> process);
}
public enum NuGet.Packaging.XmlDocFileSaveMode : Enum {
    public int value__;
    public static XmlDocFileSaveMode None;
    public static XmlDocFileSaveMode Skip;
    public static XmlDocFileSaveMode Compress;
}
public static class NuGet.Packaging.XmlUtility : object {
    public static XDocument LoadSafe(Stream input);
    public static XDocument LoadSafe(Stream input, bool ignoreWhiteSpace);
    private static XmlReaderSettings CreateSafeSettings(bool ignoreWhiteSpace);
}
[ExtensionAttribute]
public static class NuGet.Packaging.ZipArchiveExtensions : object {
    [ExtensionAttribute]
public static ZipArchiveEntry LookupEntry(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetFiles(ZipArchive zipArchive);
    private static string UnescapePath(string path);
    [ExtensionAttribute]
public static Stream OpenFile(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static string SaveAsFile(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
    [ExtensionAttribute]
public static void UpdateFileTimeFromEntry(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
}
public class NuGet.Packaging.ZipFilePair : object {
    private ZipArchiveEntry _packageEntry;
    private string _fileFullPath;
    public string FileFullPath { get; }
    public ZipArchiveEntry PackageEntry { get; }
    public ZipFilePair(string fileFullPath, ZipArchiveEntry entry);
    public string get_FileFullPath();
    public ZipArchiveEntry get_PackageEntry();
    public bool IsInstalled();
}
public class NuGet.RuntimeModel.CompatibilityProfile : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FrameworkRuntimePair> <RestoreContexts>k__BackingField;
    public string Name { get; }
    public IList`1<FrameworkRuntimePair> RestoreContexts { get; }
    public CompatibilityProfile(string name);
    public CompatibilityProfile(string name, IEnumerable`1<FrameworkRuntimePair> restoreContexts);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<FrameworkRuntimePair> get_RestoreContexts();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CompatibilityProfile other);
    public CompatibilityProfile Clone();
}
public interface NuGet.RuntimeModel.IObjectWriter {
    public abstract virtual void WriteObjectStart();
    public abstract virtual void WriteObjectStart(string name);
    public abstract virtual void WriteObjectEnd();
    public abstract virtual void WriteNameValue(string name, int value);
    public abstract virtual void WriteNameValue(string name, bool value);
    public abstract virtual void WriteNameValue(string name, string value);
    public abstract virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public abstract virtual void WriteArrayStart(string name);
    public abstract virtual void WriteArrayEnd();
}
public class NuGet.RuntimeModel.JsonObjectWriter : object {
    private JsonWriter _writer;
    private bool _isDisposed;
    public JsonObjectWriter(JsonWriter writer);
    public sealed virtual void Dispose();
    public sealed virtual void WriteObjectStart();
    public sealed virtual void WriteObjectStart(string name);
    public sealed virtual void WriteArrayStart(string name);
    public sealed virtual void WriteObjectEnd();
    public sealed virtual void WriteArrayEnd();
    public sealed virtual void WriteNameValue(string name, int value);
    public sealed virtual void WriteNameValue(string name, bool value);
    public sealed virtual void WriteNameValue(string name, string value);
    public sealed virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    private void ThrowIfDisposed();
}
public static class NuGet.RuntimeModel.JsonRuntimeFormat : object {
    public static RuntimeGraph ReadRuntimeGraph(string filePath);
    public static RuntimeGraph ReadRuntimeGraph(Stream stream);
    public static RuntimeGraph ReadRuntimeGraph(TextReader textReader);
    public static void WriteRuntimeGraph(string filePath, RuntimeGraph runtimeGraph);
    public static RuntimeGraph ReadRuntimeGraph(JToken json);
    public static void WriteRuntimeGraph(IObjectWriter writer, RuntimeGraph runtimeGraph);
    private static void WriteRuntimeDescription(IObjectWriter writer, RuntimeDescription data);
    private static void WriteRuntimeDependencySet(IObjectWriter writer, RuntimeDependencySet data);
    private static void WritePackageDependency(IObjectWriter writer, RuntimePackageDependency data);
    private static void WriteCompatibilityProfile(IObjectWriter writer, CompatibilityProfile data);
    private static CompatibilityProfile ReadCompatibilityProfile(KeyValuePair`2<string, JToken> json);
    [IteratorStateMachineAttribute("NuGet.RuntimeModel.JsonRuntimeFormat/<ReadCompatibilitySets>d__11")]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(KeyValuePair`2<string, JToken> property);
    private static RuntimeDescription ReadRuntimeDescription(KeyValuePair`2<string, JToken> json);
    private static RuntimeDependencySet ReadRuntimeDependencySet(KeyValuePair`2<string, JToken> json);
    private static RuntimePackageDependency ReadRuntimePackageDependency(KeyValuePair`2<string, JToken> json);
    private static IEnumerable`1<KeyValuePair`2<string, JToken>> EachProperty(JToken json);
}
public class NuGet.RuntimeModel.RuntimeDependencySet : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimePackageDependency> <Dependencies>k__BackingField;
    public string Id { get; }
    public IReadOnlyDictionary`2<string, RuntimePackageDependency> Dependencies { get; }
    public RuntimeDependencySet(string id);
    public RuntimeDependencySet(string id, IEnumerable`1<RuntimePackageDependency> dependencies);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimePackageDependency> get_Dependencies();
    public sealed virtual bool Equals(RuntimeDependencySet other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public RuntimeDependencySet Clone();
    public virtual string ToString();
}
public class NuGet.RuntimeModel.RuntimeDescription : object {
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InheritedRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimeDependencySet> <RuntimeDependencySets>k__BackingField;
    public string RuntimeIdentifier { get; }
    public IReadOnlyList`1<string> InheritedRuntimes { get; }
    public IReadOnlyDictionary`2<string, RuntimeDependencySet> RuntimeDependencySets { get; }
    public RuntimeDescription(string runtimeIdentifier);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<string> inheritedRuntimes);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<RuntimeDependencySet> runtimeDependencySets);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<string> inheritedRuntimes, IEnumerable`1<RuntimeDependencySet> runtimeDependencySets);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InheritedRuntimes();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimeDependencySet> get_RuntimeDependencySets();
    public sealed virtual bool Equals(RuntimeDescription other);
    public RuntimeDescription Clone();
    public static RuntimeDescription Merge(RuntimeDescription left, RuntimeDescription right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NuGet.RuntimeModel.RuntimeGraph : object {
    private ConcurrentDictionary`2<RuntimeCompatKey, bool> _areCompatible;
    private ConcurrentDictionary`2<string, HashSet`1<string>> _expandCache;
    private ConcurrentDictionary`2<RuntimeDependencyKey, List`1<RuntimePackageDependency>> _dependencyCache;
    private HashSet`1<string> _packagesWithDependencies;
    public static string RuntimeGraphFileName;
    public static RuntimeGraph Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimeDescription> <Runtimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, CompatibilityProfile> <Supports>k__BackingField;
    public IReadOnlyDictionary`2<string, RuntimeDescription> Runtimes { get; }
    public IReadOnlyDictionary`2<string, CompatibilityProfile> Supports { get; public set; }
    public RuntimeGraph(IEnumerable`1<RuntimeDescription> runtimes);
    public RuntimeGraph(IEnumerable`1<CompatibilityProfile> supports);
    public RuntimeGraph(IEnumerable`1<RuntimeDescription> runtimes, IEnumerable`1<CompatibilityProfile> supports);
    private RuntimeGraph(Dictionary`2<string, RuntimeDescription> runtimes, Dictionary`2<string, CompatibilityProfile> supports);
    private static RuntimeGraph();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimeDescription> get_Runtimes();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, CompatibilityProfile> get_Supports();
    [CompilerGeneratedAttribute]
public void set_Supports(IReadOnlyDictionary`2<string, CompatibilityProfile> value);
    public RuntimeGraph Clone();
    public static RuntimeGraph Merge(RuntimeGraph left, RuntimeGraph right);
    public IEnumerable`1<string> ExpandRuntime(string runtime);
    private HashSet`1<string> ExpandRuntimeCached(string runtime);
    [IteratorStateMachineAttribute("NuGet.RuntimeModel.RuntimeGraph/<ExpandRuntimeInternal>d__22")]
private IEnumerable`1<string> ExpandRuntimeInternal(string runtime);
    public bool AreCompatible(string criteria, string provided);
    private bool AreCompatibleInternal(RuntimeCompatKey key);
    public IEnumerable`1<RuntimePackageDependency> FindRuntimeDependencies(string runtimeName, string packageId);
    private List`1<RuntimePackageDependency> FindRuntimeDependenciesInternal(RuntimeDependencyKey key);
    public sealed virtual bool Equals(RuntimeGraph other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExpandRuntimeCached>b__21_0(string r);
    [CompilerGeneratedAttribute]
private bool <AreCompatible>b__23_0(RuntimeCompatKey k);
    [CompilerGeneratedAttribute]
private List`1<RuntimePackageDependency> <FindRuntimeDependencies>b__25_2(RuntimeDependencyKey k);
}
public class NuGet.RuntimeModel.RuntimePackageDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    public string Id { get; }
    public VersionRange VersionRange { get; }
    public RuntimePackageDependency(string id, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    public RuntimePackageDependency Clone();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RuntimePackageDependency other);
}
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    internal static bool EqualsWithNullCheck(T self, T other);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private bool _initialized;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(TValue o, IEqualityComparer`1<TValue> comparer);
    internal void AddObject(T o);
    internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
    private void CheckInitialized();
}
