internal class EnumerableAsync`1 : object {
    private SearchFilter _filter;
    private ILogger _logger;
    private string _searchTerm;
    private int _skip;
    private int _take;
    private CancellationToken _token;
    private IV2FeedParser _feedParser;
    private bool _isSearchAvailable;
    private bool _allVersions;
    public EnumerableAsync`1(IV2FeedParser feedParser, string searchTerm, SearchFilter filter, int skip, int take, bool isSearchAvailable, bool allVersions, ILogger logger, CancellationToken token);
    public sealed virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
internal class EnumeratorAsync : object {
    private SearchFilter _filter;
    private ILogger _logger;
    private string _searchTerm;
    private int _skip;
    private int _take;
    private CancellationToken _token;
    private IV2FeedParser _feedParser;
    private bool _isSearchAvailable;
    private bool _allVersions;
    private IEnumerator`1<IPackageSearchMetadata> _currentEnumerator;
    private V2FeedPage _currentPage;
    public IPackageSearchMetadata Current { get; }
    public EnumeratorAsync(IV2FeedParser feedParser, string searchTerm, SearchFilter filter, int skip, int take, bool isSearchAvailable, bool allVersions, ILogger logger, CancellationToken token);
    public sealed virtual IPackageSearchMetadata get_Current();
    [AsyncStateMachineAttribute("EnumeratorAsync/<MoveNextAsync>d__14")]
public sealed virtual Task`1<bool> MoveNextAsync();
    [CompilerGeneratedAttribute]
private IPackageSearchMetadata <MoveNextAsync>b__14_4(V2FeedPackageInfo package);
    [CompilerGeneratedAttribute]
private bool <MoveNextAsync>b__14_5(IPackageSearchMetadata p);
    [CompilerGeneratedAttribute]
private IPackageSearchMetadata <MoveNextAsync>b__14_9(V2FeedPackageInfo package);
    [CompilerGeneratedAttribute]
private bool <MoveNextAsync>b__14_10(IPackageSearchMetadata p);
    [CompilerGeneratedAttribute]
private IPackageSearchMetadata <MoveNextAsync>b__14_15(V2FeedPackageInfo package);
    [CompilerGeneratedAttribute]
private bool <MoveNextAsync>b__14_16(IPackageSearchMetadata p);
    [CompilerGeneratedAttribute]
private IPackageSearchMetadata <MoveNextAsync>b__14_20(V2FeedPackageInfo package);
    [CompilerGeneratedAttribute]
private bool <MoveNextAsync>b__14_21(IPackageSearchMetadata p);
}
public class NuGet.Protocol.AmbientAuthenticationState : object {
    internal static int MaxAuthRetries;
    [CompilerGeneratedAttribute]
private bool <IsBlocked>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AuthenticationRetriesCount>k__BackingField;
    public bool IsBlocked { get; private set; }
    public int AuthenticationRetriesCount { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsBlocked();
    [CompilerGeneratedAttribute]
private void set_IsBlocked(bool value);
    [CompilerGeneratedAttribute]
public int get_AuthenticationRetriesCount();
    [CompilerGeneratedAttribute]
private void set_AuthenticationRetriesCount(int value);
    public void Block();
    public void Increment();
}
public class NuGet.Protocol.AutoCompleteResourceV2Feed : AutoCompleteResource {
    private HttpSource _httpSource;
    private Uri _baseUri;
    public AutoCompleteResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<IdStartsWith>d__3")]
public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<VersionStartsWith>d__4")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2Feed/<GetResults>d__5")]
private Task`1<IEnumerable`1<string>> GetResults(Uri apiEndpointUri, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV3 : AutoCompleteResource {
    private RegistrationResourceV3 _regResource;
    private ServiceIndexResourceV3 _serviceIndex;
    private HttpSource _client;
    public AutoCompleteResourceV3(HttpSource client, ServiceIndexResourceV3 serviceIndex, RegistrationResourceV3 regResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3/<IdStartsWith>d__4")]
public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3/<VersionStartsWith>d__5")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.AutoCompleteResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.AutoCompleteResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.CachingSourceProvider : object {
    private IPackageSourceProvider _packageSourceProvider;
    private List`1<Lazy`1<INuGetResourceProvider>> _resourceProviders;
    private List`1<SourceRepository> _repositories;
    private ConcurrentDictionary`2<string, SourceRepository> _cachedSources;
    public IPackageSourceProvider PackageSourceProvider { get; }
    public CachingSourceProvider(IPackageSourceProvider packageSourceProvider);
    public sealed virtual IEnumerable`1<SourceRepository> GetRepositories();
    public SourceRepository CreateRepository(string source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source);
    public sealed virtual SourceRepository CreateRepository(PackageSource source, FeedType type);
    public sealed virtual IPackageSourceProvider get_PackageSourceProvider();
}
public class NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FrameworkSpecificGroup> <FrameworkReferenceGroups>k__BackingField;
    public IReadOnlyList`1<PackageDependencyGroup> DependencyGroups { get; }
    public IReadOnlyList`1<FrameworkSpecificGroup> FrameworkReferenceGroups { get; }
    public FindPackageByIdDependencyInfo(IEnumerable`1<PackageDependencyGroup> dependencyGroups, IEnumerable`1<FrameworkSpecificGroup> frameworkReferenceGroups);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FrameworkSpecificGroup> get_FrameworkReferenceGroups();
}
public abstract class NuGet.Protocol.Core.Types.FindPackageByIdResource : object {
    public abstract virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<PackageIdentity> GetOriginalIdentityAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    protected static FindPackageByIdDependencyInfo GetDependencyInfo(NuspecReader reader);
}
public class NuGet.Protocol.Core.Types.OfflineFeedAddContext : object {
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfSourcePackageIsInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfPackageExistsAndInvalid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfPackageExists>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expand>k__BackingField;
    public string PackagePath { get; }
    public string Source { get; }
    public ILogger Logger { get; }
    public bool ThrowIfSourcePackageIsInvalid { get; }
    public bool ThrowIfPackageExistsAndInvalid { get; }
    public bool ThrowIfPackageExists { get; }
    public bool Expand { get; }
    public OfflineFeedAddContext(string packagePath, string source, ILogger logger, bool throwIfSourcePackageIsInvalid, bool throwIfPackageExistsAndInvalid, bool throwIfPackageExists, bool expand);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfSourcePackageIsInvalid();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfPackageExistsAndInvalid();
    [CompilerGeneratedAttribute]
public bool get_ThrowIfPackageExists();
    [CompilerGeneratedAttribute]
public bool get_Expand();
}
public static class NuGet.Protocol.Core.Types.OfflineFeedUtility : object {
    public static bool PackageExists(PackageIdentity packageIdentity, string offlineFeed, Boolean& isValidPackage);
    public static string GetPackageDirectory(PackageIdentity packageIdentity, string offlineFeed);
    public static void ThrowIfInvalid(string path);
    public static void ThrowIfInvalidOrNotFound(string path, bool isDirectory, string resourceString);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.OfflineFeedUtility/<AddPackageToSource>d__4")]
public static Task AddPackageToSource(OfflineFeedAddContext offlineFeedAddContext, CancellationToken token);
    private static string GetHash(string nupkgFilePath);
}
public class NuGet.Protocol.Core.Types.PackageUpdateResource : object {
    private static string ServiceEndpoint;
    private HttpSource _httpSource;
    private string _source;
    private bool _disableBuffering;
    public Uri SourceUri { get; }
    public PackageUpdateResource(string source, HttpSource httpSource);
    public Uri get_SourceUri();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Push>d__7")]
public Task Push(string packagePath, string symbolSource, int timeoutInSecond, bool disableBuffering, Func`2<string, string> getApiKey, Func`2<string, string> getSymbolApiKey, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<Delete>d__8")]
public Task Delete(string packageId, string packageVersion, Func`2<string, string> getApiKey, Func`2<string, bool> confirm, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushSymbols>d__9")]
private Task PushSymbols(string packagePath, string source, string apiKey, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    private static string GetSymbolsPath(string packagePath);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackage>d__11")]
private Task PushPackage(string packagePath, string source, string apiKey, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageCore>d__12")]
private Task PushPackageCore(string source, string apiKey, string packageToPush, TimeSpan requestTimeout, ILogger log, CancellationToken token);
    private static string GetSourceDisplayName(string source);
    private static IEnumerable`1<string> GetPackagesToPush(string packagePath);
    private static string EnsurePackageExtension(string packagePath);
    private static void EnsurePackageFileExists(string packagePath, IEnumerable`1<string> packagesToPush);
    private bool IsFileSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageToServer>d__18")]
private Task PushPackageToServer(string source, string apiKey, string pathToPackage, long packageSize, TimeSpan requestTimeout, ILogger logger, CancellationToken token);
    private HttpRequestMessage CreateRequest(Uri serviceEndpointUrl, string pathToPackage, string apiKey, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<PushPackageToFileSystem>d__20")]
private Task PushPackageToFileSystem(Uri sourceUri, string pathToPackage, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<DeletePackage>d__21")]
private Task DeletePackage(string source, string apiKey, string packageId, string packageVersion, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.Core.Types.PackageUpdateResource/<DeletePackageFromServer>d__22")]
private Task DeletePackageFromServer(string source, string apiKey, string packageId, string packageVersion, ILogger logger, CancellationToken token);
    private void DeletePackageFromFileSystem(string source, string packageId, string packageVersion, ILogger logger);
    private void ForceDeleteFile(string fullPath);
    public static void ForceDeleteDirectory(string path);
    private Uri GetServiceEndpointUrl(string source, string path);
    private static Uri EnsureTrailingSlash(string value);
    private bool IsV2LocalRepository(string root);
}
internal class NuGet.Protocol.DependencyInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistrationInfo <RegistrationInfo>k__BackingField;
    public string Id { get; public set; }
    public VersionRange Range { get; public set; }
    public RegistrationInfo RegistrationInfo { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(VersionRange value);
    [CompilerGeneratedAttribute]
public RegistrationInfo get_RegistrationInfo();
    [CompilerGeneratedAttribute]
public void set_RegistrationInfo(RegistrationInfo value);
    public virtual string ToString();
}
public class NuGet.Protocol.DependencyInfoResourceV2Feed : DependencyInfoResource {
    private V2FeedParser _feedParser;
    private FrameworkReducer _frameworkReducer;
    private SourceRepository _source;
    public DependencyInfoResourceV2Feed(V2FeedParser feedParser, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2Feed/<ResolvePackage>d__4")]
public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2Feed/<ResolvePackages>d__5")]
public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, ILogger log, CancellationToken token);
    private SourcePackageDependencyInfo CreateDependencyInfo(V2FeedPackageInfo packageVersion, NuGetFramework projectFramework);
}
public class NuGet.Protocol.DependencyInfoResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DependencyInfoResourceV3 : DependencyInfoResource {
    private HttpSource _client;
    private RegistrationResourceV3 _regResource;
    private SourceRepository _source;
    public DependencyInfoResourceV3(HttpSource client, RegistrationResourceV3 regResource, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<ResolvePackage>d__4")]
public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<ResolvePackages>d__5")]
public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> ResolvePackages(string packageId, ILogger log, CancellationToken token);
    [IteratorStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3/<GetPackagesFromRegistration>d__7")]
private IEnumerable`1<SourcePackageDependencyInfo> GetPackagesFromRegistration(RegistrationInfo registration, CancellationToken token);
}
public class NuGet.Protocol.DependencyInfoResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DependencyInfoResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV2Feed : DownloadResource {
    private V2FeedParser _feedParser;
    public DownloadResourceV2Feed(V2FeedParser feedParser);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV2Feed/<GetDownloadResourceResultAsync>d__2")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV3 : DownloadResource {
    private RegistrationResourceV3 _regResource;
    private HttpSource _client;
    private string _packageBaseAddressUrl;
    public DownloadResourceV3(HttpSource client, RegistrationResourceV3 regResource);
    public DownloadResourceV3(HttpSource client, string packageBaseAddress);
    private DownloadResourceV3(HttpSource client);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3/<GetDownloadUrl>d__6")]
private Task`1<Uri> GetDownloadUrl(PackageIdentity identity, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3/<GetDownloadResourceResultAsync>d__7")]
public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.DownloadResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.DownloadTimeoutStream : Stream {
    private string _downloadName;
    private Stream _networkStream;
    private TimeSpan _timeout;
    [CompilerGeneratedAttribute]
private bool <CanRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanWrite>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DownloadTimeoutStream(string downloadName, Stream networkStream, TimeSpan timeout);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("NuGet.Protocol.DownloadTimeoutStream/<ReadAsync>d__8")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
public virtual bool get_CanRead();
    [CompilerGeneratedAttribute]
public virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public class NuGet.Protocol.DownloadTimeoutStreamContent : StreamContent {
    public DownloadTimeoutStreamContent(string downloadName, Stream networkStream, TimeSpan timeout);
}
[ExtensionAttribute]
public static class NuGet.Protocol.FactoryExtensionsV3 : object {
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, string source, FeedType type);
    [ExtensionAttribute]
public static SourceRepository GetCoreV3(RepositoryFactory factory, string source);
    [ExtensionAttribute]
public static SourceRepository GetCoreV2(RepositoryFactory factory, PackageSource source);
    [IteratorStateMachineAttribute("NuGet.Protocol.FactoryExtensionsV3/<GetCoreV3>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<Lazy`1<INuGetResourceProvider>> GetCoreV3(ProviderFactory factory);
}
public class NuGet.Protocol.FeedTypeResourceProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, FeedTypeResource> _feedTypeCache;
    private object _accessLock;
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.FeedTypeUtility : object {
    public static FeedType GetFeedType(PackageSource packageSource);
}
public abstract class NuGet.Protocol.FindLocalPackagesResource : object {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public string Root { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
protected void set_Root(string value);
    public virtual bool Exists(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual bool Exists(string packageId, ILogger logger, CancellationToken token);
    public abstract virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public abstract virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public abstract virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public abstract virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourcePackagesConfig : FindLocalPackagesResource {
    public FindLocalPackagesResourcePackagesConfig(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceUnzipped : FindLocalPackagesResource {
    private Lazy`1<IReadOnlyList`1<LocalPackageInfo>> _packages;
    private Lazy`1<Dictionary`2<PackageIdentity, LocalPackageInfo>> _index;
    private Lazy`1<Dictionary`2<Uri, LocalPackageInfo>> _pathIndex;
    public FindLocalPackagesResourceUnzipped(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
    public virtual bool Exists(PackageIdentity identity, ILogger logger, CancellationToken token);
    private static Dictionary`2<PackageIdentity, LocalPackageInfo> GetIndex(Lazy`1<IReadOnlyList`1<LocalPackageInfo>> packages);
    private static Dictionary`2<Uri, LocalPackageInfo> GetPathIndex(Lazy`1<IReadOnlyList`1<LocalPackageInfo>> packages);
    private static IReadOnlyList`1<LocalPackageInfo> GetPackagesCore(string root);
    private static PackageReaderBase GetPackage(DirectoryInfo root, string name);
    private static NuspecReader GetNuspec(DirectoryInfo root, string name);
    [CompilerGeneratedAttribute]
private Dictionary`2<PackageIdentity, LocalPackageInfo> <.ctor>b__3_1();
    [CompilerGeneratedAttribute]
private Dictionary`2<Uri, LocalPackageInfo> <.ctor>b__3_2();
}
public class NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, FindLocalPackagesResourceUnzipped> _cache;
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceUnzippedProvider/<TryCreate>d__2")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV2 : FindLocalPackagesResource {
    public FindLocalPackagesResourceV2(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV2Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceV2Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV3 : FindLocalPackagesResource {
    public FindLocalPackagesResourceV3(string root);
    public virtual IEnumerable`1<LocalPackageInfo> FindPackagesById(string id, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(Uri path, ILogger logger, CancellationToken token);
    public virtual LocalPackageInfo GetPackage(PackageIdentity identity, ILogger logger, CancellationToken token);
    public virtual IEnumerable`1<LocalPackageInfo> GetPackages(ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.FindLocalPackagesResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.FindLocalPackagesResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.FindPackagesByIdNupkgDownloader : object {
    private object _cacheEntriesLock;
    private Dictionary`2<string, Task`1<CacheEntry>> _cacheEntries;
    private object _nuspecReadersLock;
    private ConcurrentDictionary`2<string, NuspecReader> _nuspecReaders;
    private HttpSource _httpSource;
    public FindPackagesByIdNupkgDownloader(HttpSource httpSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<GetNuspecReaderFromNupkgAsync>d__6")]
public Task`1<NuspecReader> GetNuspecReaderFromNupkgAsync(PackageIdentity identity, string url, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<CopyNupkgToStreamAsync>d__7")]
public Task`1<bool> CopyNupkgToStreamAsync(PackageIdentity identity, string url, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessNupkgStreamAsync>d__8")]
private Task`1<bool> ProcessNupkgStreamAsync(PackageIdentity identity, string url, Func`2<Stream, Task> processStreamAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessStreamAndGetCacheEntryAsync>d__9")]
private Task`1<CacheEntry> ProcessStreamAndGetCacheEntryAsync(PackageIdentity identity, string url, Func`2<Stream, Task> processStreamAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessHttpSourceResultAsync>d__10`1")]
private Task`1<T> ProcessHttpSourceResultAsync(PackageIdentity identity, string url, Func`2<HttpSourceResult, Task`1<T>> processAsync, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.FindPackagesByIdNupkgDownloader/<ProcessCacheEntryAsync>d__11")]
private Task`1<bool> ProcessCacheEntryAsync(CacheEntry cacheEntry, Func`2<Stream, Task> processStreamAsync, CancellationToken token);
}
public static class NuGet.Protocol.GetDownloadResultUtility : object {
    private static int BufferSize;
    private static string DirectDownloadExtension;
    private static string DirectDownloadPattern;
    [AsyncStateMachineAttribute("NuGet.Protocol.GetDownloadResultUtility/<GetDownloadResultAsync>d__3")]
public static Task`1<DownloadResourceResult> GetDownloadResultAsync(HttpSource client, PackageIdentity identity, Uri uri, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
    public static void CleanUpDirectDownloads(PackageDownloadContext downloadContext);
    [AsyncStateMachineAttribute("NuGet.Protocol.GetDownloadResultUtility/<DirectDownloadAsync>d__5")]
private static Task`1<DownloadResourceResult> DirectDownloadAsync(PackageIdentity packageIdentity, Stream packageStream, PackageDownloadContext downloadContext, CancellationToken token);
}
public static class NuGet.Protocol.GlobalPackagesFolderUtility : object {
    private static int BufferSize;
    public static DownloadResourceResult GetPackage(PackageIdentity packageIdentity, string globalPackagesFolder);
    [AsyncStateMachineAttribute("NuGet.Protocol.GlobalPackagesFolderUtility/<AddPackageAsync>d__2")]
public static Task`1<DownloadResourceResult> AddPackageAsync(PackageIdentity packageIdentity, Stream packageStream, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.HttpCacheResult : object {
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public TimeSpan MaxAge { get; }
    public string NewFile { get; }
    public string CacheFile { get; }
    public Stream Stream { get; public set; }
    public HttpCacheResult(TimeSpan maxAge, string newFile, string cacheFule);
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public string get_NewFile();
    [CompilerGeneratedAttribute]
public string get_CacheFile();
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(Stream value);
}
public static class NuGet.Protocol.HttpCacheUtility : object {
    private static int BufferSize;
    public static HttpCacheResult InitializeHttpCacheResult(string httpCacheDirectory, Uri sourceUri, string cacheKey, HttpSourceCacheContext context);
    private static string ComputeHash(string value);
    private static string RemoveInvalidFileNameChars(string value);
    public static Stream TryReadCacheFile(string uri, TimeSpan maxAge, string cacheFile);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpCacheUtility/<CreateCacheFileAsync>d__5")]
public static Task CreateCacheFileAsync(HttpCacheResult result, HttpResponseMessage response, Action`1<Stream> ensureValidContents, CancellationToken cancellationToken);
    private static bool IsFileAlreadyOpen(string filePath);
}
public class NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource : FindPackageByIdResource {
    private static int MaxRetries;
    private HttpSource _httpSource;
    private ConcurrentDictionary`2<string, Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>>> _packageInfoCache;
    private ConcurrentDictionary`2<PackageIdentity, Task`1<PackageIdentity>> _packageIdentityCache;
    private IReadOnlyList`1<Uri> _baseUris;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    public HttpFileSystemBasedFindPackageByIdResource(IReadOnlyList`1<Uri> baseUris, HttpSource httpSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetAllVersionsAsync>d__7")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetOriginalIdentityAsync>d__8")]
public virtual Task`1<PackageIdentity> GetOriginalIdentityAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<GetDependencyInfoAsync>d__9")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<CopyNupkgToStreamAsync>d__10")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<FindPackagesByIdAsync>d__12")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> FindPackagesByIdAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource/<ConsumeFlatContainerIndexAsync>d__13")]
private Task`1<SortedDictionary`2<NuGetVersion, PackageInfo>> ConsumeFlatContainerIndexAsync(Stream stream, string id, string baseUri);
    private PackageInfo BuildModel(string baseUri, string id, string version);
}
public class NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.HttpHandlerResourceV3 : HttpHandlerResource {
    private HttpClientHandler _clientHandler;
    private HttpMessageHandler _messageHandler;
    [CompilerGeneratedAttribute]
private static ICredentialService <CredentialService>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`2<Uri, ICredentials> <CredentialsSuccessfullyUsed>k__BackingField;
    public HttpClientHandler ClientHandler { get; }
    public HttpMessageHandler MessageHandler { get; }
    public static ICredentialService CredentialService { get; public set; }
    public static Action`2<Uri, ICredentials> CredentialsSuccessfullyUsed { get; public set; }
    public HttpHandlerResourceV3(HttpClientHandler clientHandler, HttpMessageHandler messageHandler);
    public virtual HttpClientHandler get_ClientHandler();
    public virtual HttpMessageHandler get_MessageHandler();
    [CompilerGeneratedAttribute]
public static ICredentialService get_CredentialService();
    [CompilerGeneratedAttribute]
public static void set_CredentialService(ICredentialService value);
    [CompilerGeneratedAttribute]
public static Action`2<Uri, ICredentials> get_CredentialsSuccessfullyUsed();
    [CompilerGeneratedAttribute]
public static void set_CredentialsSuccessfullyUsed(Action`2<Uri, ICredentials> value);
}
public class NuGet.Protocol.HttpHandlerResourceV3Provider : ResourceProvider {
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    private static HttpHandlerResourceV3 CreateResource(PackageSource packageSource);
}
public class NuGet.Protocol.HttpRequestMessageConfiguration : object {
    public static HttpRequestMessageConfiguration Default;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PromptOn403>k__BackingField;
    public ILogger Logger { get; }
    public bool PromptOn403 { get; }
    public HttpRequestMessageConfiguration(ILogger logger, bool promptOn403);
    private static HttpRequestMessageConfiguration();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_PromptOn403();
}
[ExtensionAttribute]
public static class NuGet.Protocol.HttpRequestMessageExtensions : object {
    private static string NuGetConfigurationKey;
    private static HttpRequestMessageExtensions();
    [ExtensionAttribute]
internal static HttpRequestMessage Clone(HttpRequestMessage request);
    [ExtensionAttribute]
public static HttpRequestMessageConfiguration GetOrCreateConfiguration(HttpRequestMessage request);
    [ExtensionAttribute]
public static void SetConfiguration(HttpRequestMessage request, HttpRequestMessageConfiguration configuration);
    [ExtensionAttribute]
private static T GetProperty(HttpRequestMessage request, string key);
}
public static class NuGet.Protocol.HttpRequestMessageFactory : object {
    public static HttpRequestMessage Create(HttpMethod method, string requestUri, ILogger log);
    public static HttpRequestMessage Create(HttpMethod method, Uri requestUri, ILogger log);
    public static HttpRequestMessage Create(HttpMethod method, string requestUri, HttpRequestMessageConfiguration configuration);
    public static HttpRequestMessage Create(HttpMethod method, Uri requestUri, HttpRequestMessageConfiguration configuration);
}
public class NuGet.Protocol.HttpRetryHandler : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpRetryHandler/<SendAsync>d__0")]
public sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.HttpRetryHandlerRequest : object {
    public static int DefaultMaxTries;
    public static TimeSpan DefaultDownloadTimeout;
    [CompilerGeneratedAttribute]
private HttpClient <HttpClient>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<HttpRequestMessage> <RequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpCompletionOption <CompletionOption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RetryDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    public HttpClient HttpClient { get; }
    public Func`1<HttpRequestMessage> RequestFactory { get; }
    public HttpCompletionOption CompletionOption { get; public set; }
    public int MaxTries { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public TimeSpan RetryDelay { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public HttpRetryHandlerRequest(HttpClient httpClient, Func`1<HttpRequestMessage> requestFactory);
    private static HttpRetryHandlerRequest();
    [CompilerGeneratedAttribute]
public HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
public Func`1<HttpRequestMessage> get_RequestFactory();
    [CompilerGeneratedAttribute]
public HttpCompletionOption get_CompletionOption();
    [CompilerGeneratedAttribute]
public void set_CompletionOption(HttpCompletionOption value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RetryDelay();
    [CompilerGeneratedAttribute]
public void set_RetryDelay(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
}
public class NuGet.Protocol.HttpSource : object {
    private Func`1<Task`1<HttpHandlerResource>> _messageHandlerFactory;
    private Uri _sourceUri;
    private HttpClient _httpClient;
    private string _httpCacheDirectory;
    private PackageSource _packageSource;
    private IThrottle _throttle;
    private SemaphoreSlim _httpClientLock;
    [CompilerGeneratedAttribute]
private IHttpRetryHandler <RetryHandler>k__BackingField;
    public IHttpRetryHandler RetryHandler { get; public set; }
    public string HttpCacheDirectory { get; public set; }
    public HttpSource(PackageSource packageSource, Func`1<Task`1<HttpHandlerResource>> messageHandlerFactory, IThrottle throttle);
    [CompilerGeneratedAttribute]
public IHttpRetryHandler get_RetryHandler();
    [CompilerGeneratedAttribute]
public void set_RetryHandler(IHttpRetryHandler value);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetAsync>d__12`1")]
public Task`1<T> GetAsync(HttpSourceCachedRequest request, Func`2<HttpSourceResult, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessStreamAsync>d__13`1")]
public Task`1<T> ProcessStreamAsync(HttpSourceRequest request, Func`2<Stream, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<ProcessResponseAsync>d__14`1")]
public Task`1<T> ProcessResponseAsync(HttpSourceRequest request, Func`2<HttpResponseMessage, Task`1<T>> processAsync, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetJObjectAsync>d__15")]
public Task`1<JObject> GetJObjectAsync(HttpSourceRequest request, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<GetThrottledResponse>d__16")]
private Task`1<ThrottledResponse> GetThrottledResponse(Func`1<HttpRequestMessage> requestFactory, TimeSpan requestTimeout, TimeSpan downloadTimeout, int maxTries, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<EnsureHttpClientAsync>d__17")]
private Task EnsureHttpClientAsync();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSource/<CreateHttpClientAsync>d__18")]
private Task`1<HttpClient> CreateHttpClientAsync();
    public string get_HttpCacheDirectory();
    public void set_HttpCacheDirectory(string value);
    protected virtual Stream TryReadCacheFile(string uri, TimeSpan maxAge, string cacheFile);
    public static HttpSource Create(SourceRepository source);
    public static HttpSource Create(SourceRepository source, IThrottle throttle);
    public sealed virtual void Dispose();
}
public class NuGet.Protocol.HttpSourceAuthenticationHandler : DelegatingHandler {
    public static int MaxAuthRetries;
    private static SemaphoreSlim _credentialPromptLock;
    private PackageSource _packageSource;
    private HttpClientHandler _clientHandler;
    private ICredentialService _credentialService;
    private SemaphoreSlim _httpClientLock;
    private Dictionary`2<string, AmbientAuthenticationState> _authStates;
    private HttpSourceCredentials _credentials;
    public HttpSourceAuthenticationHandler(PackageSource packageSource, HttpClientHandler clientHandler, ICredentialService credentialService);
    private static HttpSourceAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<SendAsync>d__9")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<AcquireCredentialsAsync>d__10")]
private Task`1<ICredentials> AcquireCredentialsAsync(HttpStatusCode statusCode, Guid credentialsVersion, ILogger log, CancellationToken cancellationToken);
    private AmbientAuthenticationState GetAuthenticationState();
    [AsyncStateMachineAttribute("NuGet.Protocol.HttpSourceAuthenticationHandler/<PromptForCredentialsAsync>d__12")]
private Task`1<ICredentials> PromptForCredentialsAsync(CredentialRequestType type, string message, AmbientAuthenticationState authState, ILogger log, CancellationToken token);
    private void CredentialsSuccessfullyUsed(Uri uri, ICredentials credentials);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.HttpSourceCachedRequest : object {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MediaTypeWithQualityHeaderValue> <AcceptHeaderValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNotFounds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Stream> <EnsureValidContents>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    public string Uri { get; }
    public string CacheKey { get; }
    public HttpSourceCacheContext CacheContext { get; }
    public IList`1<MediaTypeWithQualityHeaderValue> AcceptHeaderValues { get; }
    public bool IgnoreNotFounds { get; public set; }
    public int MaxTries { get; public set; }
    public Action`1<Stream> EnsureValidContents { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public HttpSourceCachedRequest(string uri, string cacheKey, HttpSourceCacheContext cacheContext);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
public HttpSourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public IList`1<MediaTypeWithQualityHeaderValue> get_AcceptHeaderValues();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNotFounds();
    [CompilerGeneratedAttribute]
public void set_IgnoreNotFounds(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public Action`1<Stream> get_EnsureValidContents();
    [CompilerGeneratedAttribute]
public void set_EnsureValidContents(Action`1<Stream> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
}
public class NuGet.Protocol.HttpSourceCredentials : CredentialCache {
    private VersionedCredentials modreq(System.Runtime.CompilerServices.IsVolatile) _credentials;
    public ICredentials Credentials { get; public set; }
    public Guid Version { get; }
    public HttpSourceCredentials(ICredentials credentials);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public Guid get_Version();
    private sealed virtual override NetworkCredential System.Net.ICredentials.GetCredential(Uri uri, string authType);
}
public class NuGet.Protocol.HttpSourceRequest : object {
    public static TimeSpan DefaultRequestTimeout;
    [CompilerGeneratedAttribute]
private Func`1<HttpRequestMessage> <RequestFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNotFounds>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadTimeout>k__BackingField;
    public Func`1<HttpRequestMessage> RequestFactory { get; }
    public bool IgnoreNotFounds { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    public int MaxTries { get; public set; }
    public TimeSpan DownloadTimeout { get; public set; }
    public HttpSourceRequest(string uri, ILogger log);
    public HttpSourceRequest(Uri uri, ILogger log);
    public HttpSourceRequest(Func`1<HttpRequestMessage> requestFactory);
    private static HttpSourceRequest();
    [CompilerGeneratedAttribute]
public Func`1<HttpRequestMessage> get_RequestFactory();
    [CompilerGeneratedAttribute]
public bool get_IgnoreNotFounds();
    [CompilerGeneratedAttribute]
public void set_IgnoreNotFounds(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_MaxTries();
    [CompilerGeneratedAttribute]
public void set_MaxTries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DownloadTimeout();
    [CompilerGeneratedAttribute]
public void set_DownloadTimeout(TimeSpan value);
}
public class NuGet.Protocol.HttpSourceResource : object {
    [CompilerGeneratedAttribute]
private HttpSource <HttpSource>k__BackingField;
    public HttpSource HttpSource { get; }
    public HttpSourceResource(HttpSource httpSource);
    [CompilerGeneratedAttribute]
public HttpSource get_HttpSource();
}
public class NuGet.Protocol.HttpSourceResourceProvider : ResourceProvider {
    private ConcurrentDictionary`2<PackageSource, HttpSourceResource> _cache;
    [CompilerGeneratedAttribute]
private static IThrottle <Throttle>k__BackingField;
    public static IThrottle Throttle { get; public set; }
    [CompilerGeneratedAttribute]
public static IThrottle get_Throttle();
    [CompilerGeneratedAttribute]
public static void set_Throttle(IThrottle value);
    public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.HttpSourceResult : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpSourceResultStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFile>k__BackingField;
    public Stream Stream { get; private set; }
    public HttpSourceResultStatus Status { get; }
    public string CacheFile { get; }
    public HttpSourceResult(HttpSourceResultStatus status);
    public HttpSourceResult(HttpSourceResultStatus status, string cacheFileName, Stream stream);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
public HttpSourceResultStatus get_Status();
    [CompilerGeneratedAttribute]
public string get_CacheFile();
    public sealed virtual void Dispose();
}
public enum NuGet.Protocol.HttpSourceResultStatus : Enum {
    public int value__;
    public static HttpSourceResultStatus NotFound;
    public static HttpSourceResultStatus NoContent;
    public static HttpSourceResultStatus OpenedFromDisk;
    public static HttpSourceResultStatus OpenedFromNetwork;
}
public static class NuGet.Protocol.HttpStreamValidation : object {
    public static void ValidateJObject(string uri, Stream stream);
    public static void ValidateNupkg(string uri, Stream stream);
    public static void ValidateXml(string uri, Stream stream);
}
public interface NuGet.Protocol.IHttpRetryHandler {
    public abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRetryHandlerRequest request, ILogger log, CancellationToken cancellationToken);
}
public interface NuGet.Protocol.IThrottle {
    public abstract virtual Task WaitAsync();
    public abstract virtual void Release();
}
public interface NuGet.Protocol.IV2FeedParser {
    public abstract virtual Task`1<V2FeedPage> GetPackagesPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    public abstract virtual Task`1<V2FeedPage> GetSearchPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
}
[ExtensionAttribute]
public static class NuGet.Protocol.JsonExtensions : object {
    public static int JsonSerializationMaxDepth;
    public static JsonSerializerSettings ObjectSerializationSettings;
    private static JsonSerializer JsonObjectSerializer;
    private static JsonExtensions();
    [ExtensionAttribute]
public static string ToJson(object obj, Formatting formatting);
    [ExtensionAttribute]
public static T FromJson(string json);
    [ExtensionAttribute]
public static T FromJson(string json, JsonSerializerSettings settings);
    [ExtensionAttribute]
public static object FromJson(string json, Type type);
    [ExtensionAttribute]
public static JToken ToJToken(object obj);
    [ExtensionAttribute]
public static T FromJToken(JToken jtoken);
    [ExtensionAttribute]
public static object FromJToken(JToken jtoken, Type type);
    [ExtensionAttribute]
public static T GetJObjectProperty(JObject jobject, string propertyName);
    [ExtensionAttribute]
public static Nullable`1<bool> GetBoolean(JObject json, string propertyName);
}
public static class NuGet.Protocol.JsonProperties : object {
    public static string Data;
    public static string SubjectId;
    public static string Type;
    public static string PackageId;
    public static string Version;
    public static string Title;
    public static string Summary;
    public static string Description;
    public static string Authors;
    public static string Owners;
    public static string IconUrl;
    public static string LicenseUrl;
    public static string ProjectUrl;
    public static string Tags;
    public static string DownloadCount;
    public static string Published;
    public static string RequireLicenseAcceptance;
    public static string DependencyGroups;
    public static string LatestVersion;
    public static string TargetFramework;
    public static string Dependencies;
    public static string Range;
    public static string MinimumClientVersion;
    public static string Language;
    public static string PackageContent;
    public static string Versions;
}
public class NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed : LegacyFeedCapabilityResource {
    private static ConcurrentDictionary`2<string, Task`1<Capabilities>> CachedCapabilities;
    private static string EdmNS;
    private static string MetadataUriFormat;
    private static XName _xnameEntityType;
    private static XName _xnameProperty;
    private string _metadataUri;
    private V2FeedParser _feedParser;
    public LegacyFeedCapabilityResourceV2Feed(V2FeedParser feedParser, string baseAddress);
    private static LegacyFeedCapabilityResourceV2Feed();
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<SupportsIsAbsoluteLatestVersionAsync>d__8")]
public virtual Task`1<bool> SupportsIsAbsoluteLatestVersionAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<SupportsSearchAsync>d__9")]
public virtual Task`1<bool> SupportsSearchAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<GetCachedCapabilitiesAsync>d__10")]
private Task`1<Capabilities> GetCachedCapabilitiesAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed/<GetCapabilitiesAsync>d__11")]
private Task`1<Capabilities> GetCapabilitiesAsync(string metadataUri, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalAutoCompleteResource : AutoCompleteResource {
    private FindLocalPackagesResource _localResource;
    public LocalAutoCompleteResource(FindLocalPackagesResource localResource);
    public virtual Task`1<IEnumerable`1<string>> IdStartsWith(string packageIdPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> VersionStartsWith(string packageId, string versionPrefix, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResource/<GetPackageIdsFromLocalPackageRepository>d__4")]
private Task`1<IEnumerable`1<string>> GetPackageIdsFromLocalPackageRepository(string searchFilter, bool includePrerelease, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResource/<GetPackageVersionsFromLocalPackageRepository>d__5")]
protected Task`1<IEnumerable`1<NuGetVersion>> GetPackageVersionsFromLocalPackageRepository(string packageId, string versionPrefix, bool includePrerelease, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalAutoCompleteResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalAutoCompleteResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalDependencyInfoResource : DependencyInfoResource {
    private FindLocalPackagesResource _localResource;
    private SourceRepository _source;
    public LocalDependencyInfoResource(FindLocalPackagesResource localResource, SourceRepository source);
    public virtual Task`1<SourcePackageDependencyInfo> ResolvePackage(PackageIdentity package, NuGetFramework projectFramework, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<SourcePackageDependencyInfo>> ResolvePackages(string packageId, NuGetFramework projectFramework, ILogger log, CancellationToken token);
    private SourcePackageDependencyInfo CreateDependencyInfo(LocalPackageInfo package, NuGetFramework projectFramework);
}
public class NuGet.Protocol.LocalDependencyInfoResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalDependencyInfoResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalDownloadResource : DownloadResource {
    private FindLocalPackagesResource _localResource;
    public LocalDownloadResource(FindLocalPackagesResource localResource);
    public virtual Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(PackageIdentity identity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.LocalDownloadResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalDownloadResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public static class NuGet.Protocol.LocalFolderUtility : object {
    private static string NupkgFilter;
    private static LocalFolderUtility();
    public static LocalPackageInfo GetPackage(Uri path, ILogger log);
    public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV2>d__3")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV2(string root, string id, ILogger log);
    public static LocalPackageInfo GetPackageV2(string root, string id, NuGetVersion version, ILogger log);
    public static LocalPackageInfo GetPackageV2(string root, PackageIdentity identity, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesConfigFolderPackages>d__6")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesConfigFolderPackages>d__7")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesConfigFolderPackages(string root, string id, ILogger log);
    public static LocalPackageInfo GetPackagesConfigFolderPackage(string root, PackageIdentity identity, ILogger log);
    private static string GetPackagesConfigFolderSearchPattern(string id);
    public static LocalPackageInfo GetPackagesConfigFolderPackage(string root, string id, NuGetVersion version, ILogger log);
    private static LocalPackageInfo GetPackagesConfigFolderPackage(DirectoryInfo dir, ILogger log);
    public static bool IsPossiblePackageMatch(FileInfo file, PackageIdentity identity);
    public static bool IsPossiblePackageMatch(FileInfo file, string id);
    public static PackageIdentity GetIdentityFromNupkgPath(FileInfo file, string id);
    public static NuGetVersion GetVersionFromFileName(string fileName, string id, string extension);
    private static NuGetVersion GetVersionFromIdVersionString(string idVersionString, string id);
    public static LocalPackageInfo GetPackageV3(string root, string id, NuGetVersion version, ILogger log);
    public static LocalPackageInfo GetPackageV3(string root, PackageIdentity identity, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolder>d__19")]
public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, ILogger log);
    public static FeedType GetLocalFeedType(string root, ILogger log);
    public static DirectoryInfo GetAndVerifyRootDirectory(string root);
    private static FileInfo GetAndVerifyFileInfo(Uri fileUri);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolderChunked>d__23")]
private static IEnumerable`1<FileInfo[]> GetNupkgsFromFlatFolderChunked(DirectoryInfo root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetNupkgsFromFlatFolder>d__24")]
public static IEnumerable`1<FileInfo> GetNupkgsFromFlatFolder(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV3>d__25")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetPackagesV3>d__26")]
public static IEnumerable`1<LocalPackageInfo> GetPackagesV3(string root, string id, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalFolderUtility/<GetDistinctPackages>d__27")]
public static IEnumerable`1<LocalPackageInfo> GetDistinctPackages(IEnumerable`1<LocalPackageInfo> packages);
    private static DirectoryInfo[] GetDirectoriesSafe(DirectoryInfo root, ILogger log);
    private static DirectoryInfo[] GetDirectoriesSafe(DirectoryInfo root, string filter, SearchOption searchOption, ILogger log);
    private static FileInfo[] GetFilesSafe(DirectoryInfo root, string filter, ILogger log);
    private static IEnumerable`1<LocalPackageInfo> GetPackagesFromNupkgs(IEnumerable`1<FileInfo> files);
    private static LocalPackageInfo GetPackageFromNupkg(FileInfo nupkgFile);
    private static FileInfo[] GetNupkgsFromDirectory(DirectoryInfo root, ILogger log);
    private static LocalPackageInfo GetPackageV3(string root, string id, string version, ILogger log);
    private static FileInfo CreateFileInfoIfValidOrNull(string localPath, ILogger log);
}
public class NuGet.Protocol.LocalMetadataResource : MetadataResource {
    private FindLocalPackagesResource _localResource;
    public LocalMetadataResource(FindLocalPackagesResource localResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalMetadataResource/<GetLatestVersions>d__2")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, ILogger log, CancellationToken token);
    public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.LocalMetadataResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalMetadataResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageInfo : object {
    private Lazy`1<NuspecReader> _nuspecHelper;
    private Func`1<PackageReaderBase> _getPackageReader;
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTimeUtc>k__BackingField;
    public PackageIdentity Identity { get; }
    public string Path { get; }
    public DateTime LastWriteTimeUtc { get; }
    public NuspecReader Nuspec { get; }
    public bool IsNupkg { get; }
    public LocalPackageInfo(PackageIdentity identity, string path, DateTime lastWriteTimeUtc, Lazy`1<NuspecReader> nuspec, Func`1<PackageReaderBase> getPackageReader);
    [CompilerGeneratedAttribute]
public virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public virtual string get_Path();
    [CompilerGeneratedAttribute]
public virtual DateTime get_LastWriteTimeUtc();
    public virtual PackageReaderBase GetReader();
    public virtual NuspecReader get_Nuspec();
    public virtual bool get_IsNupkg();
}
public class NuGet.Protocol.LocalPackageListResource : ListResource {
    private PackageSearchResource _localPackageSearchResource;
    private string _baseAddress;
    public string Source { get; }
    public LocalPackageListResource(PackageSearchResource localPackageSearchResource, string baseAddress);
    public virtual string get_Source();
    public virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageMetadataResource : PackageMetadataResource {
    private FindLocalPackagesResource _localResource;
    public LocalPackageMetadataResource(FindLocalPackagesResource localResource);
    public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, ILogger log, CancellationToken token);
    private static IPackageSearchMetadata GetPackageMetadata(LocalPackageInfo package);
}
public class NuGet.Protocol.LocalPackageMetadataResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageMetadataResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalPackageSearchMetadata : object {
    private NuspecReader _nuspec;
    private LocalPackageInfo _package;
    public string Authors { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    public string Description { get; }
    public Nullable`1<long> DownloadCount { get; }
    public Uri IconUrl { get; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; }
    public string Owners { get; }
    public Uri ProjectUrl { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public Uri ReportAbuseUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public string Summary { get; }
    public string Tags { get; }
    public string Title { get; }
    public bool IsListed { get; }
    public LocalPackageSearchMetadata(LocalPackageInfo package);
    public sealed virtual string get_Authors();
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    public sealed virtual string get_Description();
    public sealed virtual Nullable`1<long> get_DownloadCount();
    public sealed virtual Uri get_IconUrl();
    public sealed virtual PackageIdentity get_Identity();
    public sealed virtual Uri get_LicenseUrl();
    public sealed virtual string get_Owners();
    public sealed virtual Uri get_ProjectUrl();
    public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    public sealed virtual Uri get_ReportAbuseUrl();
    public sealed virtual bool get_RequireLicenseAcceptance();
    public sealed virtual string get_Summary();
    public sealed virtual string get_Tags();
    public sealed virtual string get_Title();
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    private static Uri Convert(string uri);
    public sealed virtual bool get_IsListed();
}
public class NuGet.Protocol.LocalPackageSearchResource : PackageSearchResource {
    private FindLocalPackagesResource _localResource;
    public LocalPackageSearchResource(FindLocalPackagesResource localResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResource/<SearchAsync>d__2")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    private static bool ContainsAnyTerm(String[] terms, LocalPackageInfo package);
    private static bool ContainsTerm(string search, string property);
    private IPackageSearchMetadata CreatePackageSearchResult(LocalPackageInfo package, SearchFilter filter, ILogger log, CancellationToken cancellationToken);
    private static List`1<VersionInfo> GetVersions(FindLocalPackagesResource localResource, LocalPackageInfo package, SearchFilter filter, ILogger log, CancellationToken token);
    private static bool IsLocalOrUNC(string currentSource);
    [IteratorStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResource/<CollapseToHighestVersion>d__8")]
private static IEnumerable`1<LocalPackageInfo> CollapseToHighestVersion(IEnumerable`1<LocalPackageInfo> source);
}
public class NuGet.Protocol.LocalPackageSearchResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalPackageSearchResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalRepositories.LocalPackageListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalV2FindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, IReadOnlyList`1<LocalPackageInfo>> _packageInfoCache;
    private string _source;
    public LocalV2FindPackageByIdResource(PackageSource packageSource);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    public virtual Task`1<PackageIdentity> GetOriginalIdentityAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV2FindPackageByIdResource/<CopyNupkgToStreamAsync>d__5")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    private LocalPackageInfo GetPackageInfo(string id, NuGetVersion version, ILogger logger);
    private IReadOnlyList`1<LocalPackageInfo> GetPackageInfos(string id, ILogger logger);
    private IReadOnlyList`1<LocalPackageInfo> GetPackageInfosCore(string id, ILogger logger);
}
public class NuGet.Protocol.LocalV2FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV2FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.LocalV3FindPackageByIdResource : FindPackageByIdResource {
    private ConcurrentDictionary`2<string, List`1<NuGetVersion>> _cache;
    private ConcurrentDictionary`2<PackageIdentity, PackageIdentity> _packageIdentityCache;
    private string _source;
    private VersionFolderPathResolver _resolver;
    public LocalV3FindPackageByIdResource(PackageSource source);
    public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV3FindPackageByIdResource/<CopyNupkgToStreamAsync>d__6")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    public virtual Task`1<PackageIdentity> GetOriginalIdentityAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    private T ProcessNuspecReader(string id, NuGetVersion version, Func`2<NuspecReader, T> process);
    private NuGetVersion GetVersion(string id, NuGetVersion version, ILogger logger);
    private List`1<NuGetVersion> GetVersions(string id, ILogger logger);
    private List`1<NuGetVersion> GetVersionsCore(string id, ILogger logger);
    [CompilerGeneratedAttribute]
private PackageIdentity <GetOriginalIdentityAsync>b__7_0(PackageIdentity inputIdentity);
    [CompilerGeneratedAttribute]
private FindPackageByIdDependencyInfo <GetDependencyInfoAsync>b__8_0(NuspecReader nuspecReader);
}
public class NuGet.Protocol.LocalV3FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.LocalV3FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.MetadataFieldConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.MetadataResourceV2Feed : MetadataResource {
    private V2FeedParser _feedParser;
    private SourceRepository _source;
    public MetadataResourceV2Feed(V2FeedParser feedParser, SourceRepository source);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<GetLatestVersions>d__3")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<GetVersions>d__4")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<Exists>d__5")]
public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2Feed/<Exists>d__6")]
public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV3 : MetadataResource {
    private RegistrationResourceV3 _regResource;
    private HttpSource _client;
    public MetadataResourceV3(HttpSource client, RegistrationResourceV3 regResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<GetLatestVersions>d__3")]
public virtual Task`1<IEnumerable`1<KeyValuePair`2<string, NuGetVersion>>> GetLatestVersions(IEnumerable`1<string> packageIds, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<Exists>d__4")]
public virtual Task`1<bool> Exists(PackageIdentity identity, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<Exists>d__5")]
public virtual Task`1<bool> Exists(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3/<GetVersions>d__6")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetVersions(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.MetadataResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.MetadataResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.NuGetVersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class NuGet.Protocol.NullThrottle : object {
    private static Task _completedTask;
    private static NullThrottle _instance;
    public static NullThrottle Instance { get; }
    private static NullThrottle();
    public static NullThrottle get_Instance();
    public sealed virtual Task WaitAsync();
    public sealed virtual void Release();
}
public class NuGet.Protocol.ODataServiceDocumentResourceV2 : object {
    private string _baseAddress;
    private DateTime _requestTime;
    public DateTime RequestTime { get; }
    public string BaseAddress { get; }
    public ODataServiceDocumentResourceV2(string baseAddress, DateTime requestTime);
    public virtual DateTime get_RequestTime();
    public string get_BaseAddress();
}
public class NuGet.Protocol.ODataServiceDocumentResourceV2Provider : ResourceProvider {
    private static TimeSpan _defaultCacheDuration;
    protected ConcurrentDictionary`2<string, ODataServiceDocumentCacheInfo> _cache;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCacheDuration>k__BackingField;
    public TimeSpan MaxCacheDuration { get; protected set; }
    private static ODataServiceDocumentResourceV2Provider();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxCacheDuration();
    [CompilerGeneratedAttribute]
protected void set_MaxCacheDuration(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.Protocol.ODataServiceDocumentResourceV2Provider/<TryCreate>d__8")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageDependencyGroupConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static PackageDependency LoadDependency(JToken dependency);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NuGet.Protocol.PackageInfo : object {
    [CompilerGeneratedAttribute]
private RegistrationInfo <Registration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Listed>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PackageContent>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DependencyInfo> <Dependencies>k__BackingField;
    public RegistrationInfo Registration { get; public set; }
    public bool Listed { get; public set; }
    public NuGetVersion Version { get; public set; }
    public Uri PackageContent { get; public set; }
    public IList`1<DependencyInfo> Dependencies { get; private set; }
    [CompilerGeneratedAttribute]
public RegistrationInfo get_Registration();
    [CompilerGeneratedAttribute]
public void set_Registration(RegistrationInfo value);
    [CompilerGeneratedAttribute]
public bool get_Listed();
    [CompilerGeneratedAttribute]
public void set_Listed(bool value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Uri get_PackageContent();
    [CompilerGeneratedAttribute]
public void set_PackageContent(Uri value);
    [CompilerGeneratedAttribute]
public IList`1<DependencyInfo> get_Dependencies();
    [CompilerGeneratedAttribute]
private void set_Dependencies(IList`1<DependencyInfo> value);
    public virtual string ToString();
}
public class NuGet.Protocol.PackageMetadataResourceV2Feed : PackageMetadataResource {
    private HttpSource _httpSource;
    private PackageSource _packageSource;
    private V2FeedParser _feedParser;
    public PackageMetadataResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2Feed/<GetMetadataAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2Feed/<GetMetadataAsync>d__5")]
public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.PackageMetadataResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageMetadataResourceV3 : PackageMetadataResource {
    private RegistrationResourceV3 _regResource;
    private ReportAbuseResourceV3 _reportAbuseResource;
    private HttpSource _client;
    public PackageMetadataResourceV3(HttpSource client, RegistrationResourceV3 regResource, ReportAbuseResourceV3 reportAbuseResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> GetMetadataAsync(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3/<GetMetadataAsync>d__5")]
public virtual Task`1<IPackageSearchMetadata> GetMetadataAsync(PackageIdentity package, ILogger log, CancellationToken token);
    private IPackageSearchMetadata ParseMetadata(JObject metadata);
}
public class NuGet.Protocol.PackageMetadataResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageMetadataResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageSearchMetadata : object {
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencySetsInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    private string _summaryValue;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    private string _titleValue;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionInfo[] <ParsedVersions>k__BackingField;
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Authors { get; private set; }
    [JsonPropertyAttribute]
public IEnumerable`1<PackageDependencyGroup> DependencySetsInternal { get; private set; }
    [JsonIgnoreAttribute]
public IEnumerable`1<PackageDependencyGroup> DependencySets { get; }
    [JsonPropertyAttribute]
public string Description { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<long> DownloadCount { get; private set; }
    [JsonPropertyAttribute]
public Uri IconUrl { get; private set; }
    [JsonIgnoreAttribute]
public PackageIdentity Identity { get; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri LicenseUrl { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Owners { get; private set; }
    [JsonPropertyAttribute]
public string PackageId { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.SafeUriConverter")]
public Uri ProjectUrl { get; private set; }
    [JsonPropertyAttribute]
public Nullable`1<DateTimeOffset> Published { get; private set; }
    [JsonIgnoreAttribute]
public Uri ReportAbuseUrl { get; public set; }
    [JsonPropertyAttribute]
[DefaultValueAttribute("False")]
[JsonConverterAttribute("NuGet.Protocol.SafeBoolConverter")]
public bool RequireLicenseAcceptance { get; private set; }
    [JsonPropertyAttribute]
public string Summary { get; private set; }
    [JsonPropertyAttribute]
[JsonConverterAttribute("NuGet.Protocol.MetadataFieldConverter")]
public string Tags { get; private set; }
    [JsonPropertyAttribute]
public string Title { get; private set; }
    [JsonPropertyAttribute]
public NuGetVersion Version { get; private set; }
    [JsonPropertyAttribute]
public VersionInfo[] ParsedVersions { get; private set; }
    public bool IsListed { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependencyGroup> get_DependencySetsInternal();
    [CompilerGeneratedAttribute]
private void set_DependencySetsInternal(IEnumerable`1<PackageDependencyGroup> value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
private void set_IconUrl(Uri value);
    public sealed virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
private void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(string value);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
private void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
private void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
private void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
public void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
private void set_RequireLicenseAcceptance(bool value);
    public sealed virtual string get_Summary();
    private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(string value);
    public sealed virtual string get_Title();
    private void set_Title(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public VersionInfo[] get_ParsedVersions();
    [CompilerGeneratedAttribute]
private void set_ParsedVersions(VersionInfo[] value);
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    public sealed virtual bool get_IsListed();
}
public class NuGet.Protocol.PackageSearchMetadataV2Feed : object {
    [CompilerGeneratedAttribute]
private string <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependencyGroup> <DependencySets>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <DownloadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Published>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ReportAbuseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    private string _summaryValue;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    private string _titleValue;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<VersionInfo[]> <OnDemandParsedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListed>k__BackingField;
    public string Authors { get; private set; }
    public IEnumerable`1<PackageDependencyGroup> DependencySets { get; private set; }
    public string Description { get; private set; }
    public Nullable`1<long> DownloadCount { get; private set; }
    public Uri IconUrl { get; private set; }
    public PackageIdentity Identity { get; }
    public Uri LicenseUrl { get; private set; }
    public string Owners { get; private set; }
    public string PackageId { get; private set; }
    public Uri ProjectUrl { get; private set; }
    public Nullable`1<DateTimeOffset> Published { get; private set; }
    public Uri ReportAbuseUrl { get; private set; }
    public bool RequireLicenseAcceptance { get; private set; }
    public string Summary { get; private set; }
    public string Tags { get; private set; }
    public string Title { get; private set; }
    public NuGetVersion Version { get; private set; }
    public Lazy`1<VersionInfo[]> OnDemandParsedVersions { get; private set; }
    public bool IsListed { get; }
    public PackageSearchMetadataV2Feed(V2FeedPackageInfo package);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencySets();
    [CompilerGeneratedAttribute]
private void set_DependencySets(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_DownloadCount();
    [CompilerGeneratedAttribute]
private void set_DownloadCount(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
private void set_IconUrl(Uri value);
    public sealed virtual PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
private void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(string value);
    [CompilerGeneratedAttribute]
public string get_PackageId();
    [CompilerGeneratedAttribute]
private void set_PackageId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
private void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_Published();
    [CompilerGeneratedAttribute]
private void set_Published(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ReportAbuseUrl();
    [CompilerGeneratedAttribute]
private void set_ReportAbuseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
private void set_RequireLicenseAcceptance(bool value);
    public sealed virtual string get_Summary();
    private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(string value);
    public sealed virtual string get_Title();
    private void set_Title(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Lazy`1<VersionInfo[]> get_OnDemandParsedVersions();
    [CompilerGeneratedAttribute]
private void set_OnDemandParsedVersions(Lazy`1<VersionInfo[]> value);
    public sealed virtual Task`1<IEnumerable`1<VersionInfo>> GetVersionsAsync();
    private static Uri GetUriSafe(string url);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsListed();
}
public class NuGet.Protocol.PackageSearchResourceV2Feed : PackageSearchResource {
    private HttpSource _httpSource;
    private PackageSource _packageSource;
    private V2FeedParser _feedParser;
    public PackageSearchResourceV2Feed(HttpSourceResource httpSourceResource, string baseAddress, PackageSource packageSource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV2Feed/<SearchAsync>d__4")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.PackageSearchResourceV2FeedProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV2FeedProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageSearchResourceV3 : PackageSearchResource {
    private RawSearchResourceV3 _rawSearchResource;
    private PackageMetadataResource _metadataResource;
    public PackageSearchResourceV3(RawSearchResourceV3 searchResource, PackageMetadataResource metadataResource);
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3/<SearchAsync>d__3")]
public virtual Task`1<IEnumerable`1<IPackageSearchMetadata>> SearchAsync(string searchTerm, SearchFilter filter, int skip, int take, ILogger log, CancellationToken cancellationToken);
    private static IEnumerable`1<VersionInfo> GetVersions(PackageSearchMetadata metadata, SearchFilter filter);
}
public class NuGet.Protocol.PackageSearchResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageSearchResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageUpdateResourceV2Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageUpdateResourceV2Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.PackageUpdateResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.PackageUpdateResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.PackageUtilities : object {
    internal static NuspecReader OpenNuspecFromNupkg(string id, Stream nupkgStream, ILogger log);
}
public class NuGet.Protocol.ProxyAuthenticationHandler : DelegatingHandler {
    public static int MaxAuthRetries;
    private static string BasicAuthenticationType;
    private static SemaphoreSlim _credentialPromptLock;
    private HttpClientHandler _clientHandler;
    private ICredentialService _credentialService;
    private IProxyCredentialCache _credentialCache;
    private int _authRetries;
    public ProxyAuthenticationHandler(HttpClientHandler clientHandler, ICredentialService credentialService, IProxyCredentialCache credentialCache);
    private static ProxyAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<SendAsync>d__8")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static bool ProxyAuthenticationRequired(Exception ex);
    private static HttpWebResponse ExtractResponse(Exception ex);
    private static bool IsMonoProxyAuthenticationRequiredError(WebException ex);
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<AcquireCredentialsAsync>d__12")]
private Task`1<bool> AcquireCredentialsAsync(Uri requestUri, Guid cacheVersion, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.ProxyAuthenticationHandler/<PromptForProxyCredentialsAsync>d__13")]
private Task`1<NetworkCredential> PromptForProxyCredentialsAsync(Uri proxyAddress, IWebProxy proxy, ILogger log, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.RawSearchResourceV3 : object {
    private HttpSource _client;
    private Uri[] _searchEndpoints;
    public RawSearchResourceV3(HttpSource client, IEnumerable`1<Uri> searchEndpoints);
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3/<SearchPage>d__3")]
public virtual Task`1<JObject> SearchPage(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3/<Search>d__4")]
public virtual Task`1<IEnumerable`1<JObject>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.RawSearchResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RawSearchResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal class NuGet.Protocol.RegistrationInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageInfo> <Packages>k__BackingField;
    public string Id { get; public set; }
    public bool IncludePrerelease { get; public set; }
    public IList`1<PackageInfo> Packages { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrerelease();
    [CompilerGeneratedAttribute]
public void set_IncludePrerelease(bool value);
    [CompilerGeneratedAttribute]
public IList`1<PackageInfo> get_Packages();
    [CompilerGeneratedAttribute]
private void set_Packages(IList`1<PackageInfo> value);
    public void Add(PackageInfo packageInfo);
    public virtual string ToString();
}
public class NuGet.Protocol.RegistrationResourceV3 : object {
    private HttpSource _client;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    public Uri BaseUri { get; }
    public RegistrationResourceV3(HttpSource client, Uri baseUrl);
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    public virtual Uri GetUri(string packageId);
    public virtual Uri GetUri(string id, NuGetVersion version);
    public virtual Uri GetUri(PackageIdentity package);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__8")]
public virtual Task`1<JObject> GetPackageMetadata(PackageIdentity identity, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__9")]
public virtual Task`1<IEnumerable`1<JObject>> GetPackageMetadata(string packageId, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3/<GetPackageMetadata>d__10")]
public virtual Task`1<IEnumerable`1<JObject>> GetPackageMetadata(string packageId, VersionRange range, bool includePrerelease, bool includeUnlisted, ILogger log, CancellationToken token);
    public virtual Task`1<IEnumerable`1<JObject>> GetPackageEntries(string packageId, bool includeUnlisted, ILogger log, CancellationToken token);
}
public class NuGet.Protocol.RegistrationResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RegistrationResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.RemoteV2FindPackageByIdResource : FindPackageByIdResource {
    private static XName _xnameEntry;
    private static XName _xnameContent;
    private static XName _xnameLink;
    private static XName _xnameProperties;
    private static XName _xnameId;
    private static XName _xnameVersion;
    private static XName _xnamePublish;
    private static DateTime _unlistedPublishedTime;
    private string _baseUri;
    private HttpSource _httpSource;
    private Dictionary`2<string, Task`1<IEnumerable`1<PackageInfo>>> _packageVersionsCache;
    private ConcurrentDictionary`2<PackageIdentity, Task`1<PackageIdentity>> _packageIdentityCache;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    [CompilerGeneratedAttribute]
private PackageSource <PackageSource>k__BackingField;
    public PackageSource PackageSource { get; }
    public RemoteV2FindPackageByIdResource(PackageSource packageSource, HttpSource httpSource);
    private static RemoteV2FindPackageByIdResource();
    [CompilerGeneratedAttribute]
public PackageSource get_PackageSource();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetAllVersionsAsync>d__17")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetOriginalIdentityAsync>d__18")]
public virtual Task`1<PackageIdentity> GetOriginalIdentityAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetDependencyInfoAsync>d__19")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<CopyNupkgToStreamAsync>d__20")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<GetPackageInfoAsync>d__21")]
private Task`1<PackageInfo> GetPackageInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<PackageInfo>> EnsurePackagesAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResource/<FindPackagesByIdAsyncCore>d__23")]
private Task`1<IEnumerable`1<PackageInfo>> FindPackagesByIdAsyncCore(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private static PackageInfo BuildModel(string id, XElement element);
}
public class NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.RemoteV3FindPackageByIdResource : FindPackageByIdResource {
    private SemaphoreSlim _dependencyInfoSemaphore;
    private Dictionary`2<string, Task`1<IEnumerable`1<RemoteSourceDependencyInfo>>> _packageVersionsCache;
    private HttpSource _httpSource;
    private FindPackagesByIdNupkgDownloader _nupkgDownloader;
    private DependencyInfoResource _dependencyInfoResource;
    [CompilerGeneratedAttribute]
private SourceRepository <SourceRepository>k__BackingField;
    public SourceRepository SourceRepository { get; }
    public RemoteV3FindPackageByIdResource(SourceRepository sourceRepository, HttpSource httpSource);
    [CompilerGeneratedAttribute]
public SourceRepository get_SourceRepository();
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetAllVersionsAsync>d__9")]
public virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetOriginalIdentityAsync>d__10")]
public virtual Task`1<PackageIdentity> GetOriginalIdentityAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetDependencyInfoAsync>d__11")]
public virtual Task`1<FindPackageByIdDependencyInfo> GetDependencyInfoAsync(string id, NuGetVersion version, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<CopyNupkgToStreamAsync>d__12")]
public virtual Task`1<bool> CopyNupkgToStreamAsync(string id, NuGetVersion version, Stream destination, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<GetPackageInfoAsync>d__13")]
private Task`1<RemoteSourceDependencyInfo> GetPackageInfoAsync(string id, NuGetVersion version, ILogger logger, CancellationToken cancellationToken);
    private Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> EnsurePackagesAsync(string id, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<FindPackagesByIdAsyncCore>d__15")]
private Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> FindPackagesByIdAsyncCore(string id, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResource/<EnsureDependencyProvider>d__16")]
private Task EnsureDependencyProvider(CancellationToken cancellationToken);
}
public class NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.RemoteV3FindPackageByIdResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository sourceRepository, CancellationToken token);
}
public class NuGet.Protocol.ReportAbuseResourceV3 : object {
    private string _uriTemplate;
    public ReportAbuseResourceV3(string uriTemplate);
    public Uri GetReportAbuseUrl(string id, NuGetVersion version);
    private static bool IsValidUriTemplate(string uriTemplate);
}
public class NuGet.Protocol.ReportAbuseResourceV3Provider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.ReportAbuseResourceV3Provider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
internal static class NuGet.Protocol.ResolverMetadataClient : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.ResolverMetadataClient/<GetDependencies>d__0")]
public static Task`1<IEnumerable`1<RemoteSourceDependencyInfo>> GetDependencies(HttpSource httpClient, Uri registrationUri, VersionRange range, ILogger log, CancellationToken token);
    private static RemoteSourceDependencyInfo ProcessPackageVersion(JObject packageObj, NuGetVersion version);
    [AsyncStateMachineAttribute("NuGet.Protocol.ResolverMetadataClient/<GetRegistrationInfo>d__2")]
public static Task`1<RegistrationInfo> GetRegistrationInfo(HttpSource httpClient, Uri registrationUri, VersionRange range, NuGetFramework projectTargetFramework, ILogger log, CancellationToken token);
    private static NuGetFramework GetFramework(JObject dependencyGroupObj);
}
public class NuGet.Protocol.SafeBoolConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.SafeUriConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NuGet.Protocol.SemaphoreSlimThrottle : object {
    private SemaphoreSlim _semaphore;
    public SemaphoreSlimThrottle(SemaphoreSlim semaphore);
    [AsyncStateMachineAttribute("NuGet.Protocol.SemaphoreSlimThrottle/<WaitAsync>d__2")]
public sealed virtual Task WaitAsync();
    public sealed virtual void Release();
    public static SemaphoreSlimThrottle CreateBinarySemaphore();
}
public class NuGet.Protocol.ServerWarningLogHandler : DelegatingHandler {
    public ServerWarningLogHandler(HttpClientHandler clientHandler);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServerWarningLogHandler/<SendAsync>d__1")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class NuGet.Protocol.ServiceIndexEntry : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticVersion <ClientVersion>k__BackingField;
    public Uri Uri { get; }
    public string Type { get; }
    public SemanticVersion ClientVersion { get; }
    public ServiceIndexEntry(Uri serviceUri, string serviceType, SemanticVersion clientVersion);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public SemanticVersion get_ClientVersion();
}
public class NuGet.Protocol.ServiceIndexResourceV3 : object {
    private IDictionary`2<string, List`1<ServiceIndexEntry>> _index;
    private DateTime _requestTime;
    private static IReadOnlyList`1<ServiceIndexEntry> _emptyEntries;
    private static IReadOnlyList`1<Uri> _emptyUris;
    private static SemanticVersion _defaultVersion;
    public DateTime RequestTime { get; }
    public IReadOnlyList`1<ServiceIndexEntry> Entries { get; }
    public ServiceIndexResourceV3(JObject index, DateTime requestTime);
    private static ServiceIndexResourceV3();
    public virtual DateTime get_RequestTime();
    public virtual IReadOnlyList`1<ServiceIndexEntry> get_Entries();
    public virtual IReadOnlyList`1<ServiceIndexEntry> GetServiceEntries(String[] orderedTypes);
    public virtual IReadOnlyList`1<ServiceIndexEntry> GetServiceEntries(NuGetVersion clientVersion, String[] orderedTypes);
    private IReadOnlyList`1<ServiceIndexEntry> GetBestVersionMatchForType(NuGetVersion clientVersion, List`1<ServiceIndexEntry> entries);
    public virtual Uri GetServiceEntryUri(String[] orderedTypes);
    public virtual IReadOnlyList`1<Uri> GetServiceEntryUris(String[] orderedTypes);
    public virtual IReadOnlyList`1<Uri> GetServiceEntryUris(NuGetVersion clientVersion, String[] orderedTypes);
    private static IDictionary`2<string, List`1<ServiceIndexEntry>> MakeLookup(JObject index);
    [IteratorStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3/<GetValues>d__17")]
private static IEnumerable`1<string> GetValues(JToken token);
}
public class NuGet.Protocol.ServiceIndexResourceV3Provider : ResourceProvider {
    private static TimeSpan _defaultCacheDuration;
    protected ConcurrentDictionary`2<string, ServiceIndexCacheInfo> _cache;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxCacheDuration>k__BackingField;
    public TimeSpan MaxCacheDuration { get; protected set; }
    private static ServiceIndexResourceV3Provider();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxCacheDuration();
    [CompilerGeneratedAttribute]
protected void set_MaxCacheDuration(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<TryCreate>d__8")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<GetServiceIndexResourceV3>d__9")]
private Task`1<ServiceIndexResourceV3> GetServiceIndexResourceV3(SourceRepository source, DateTime utcNow, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.ServiceIndexResourceV3Provider/<ConsumeServiceIndexStreamAsync>d__10")]
private Task`1<ServiceIndexResourceV3> ConsumeServiceIndexStreamAsync(Stream stream, DateTime utcNow);
}
public static class NuGet.Protocol.ServiceTypes : object {
    public static string Version200;
    public static string Version300beta;
    public static string Version300;
    public static string Version340;
    public static string Versioned;
    public static String[] SearchQueryService;
    public static String[] RegistrationsBaseUrl;
    public static String[] SearchAutocompleteService;
    public static String[] ReportAbuse;
    public static String[] LegacyGallery;
    public static String[] PackagePublish;
    public static String[] PackageBaseAddress;
    private static ServiceTypes();
}
[ExtensionAttribute]
public static class NuGet.Protocol.StreamExtensions : object {
    public static int BufferSize;
    private static StreamExtensions();
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<CopyToAsync>d__1")]
[ExtensionAttribute]
public static Task CopyToAsync(Stream stream, Stream destination, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<AsJObjectAsync>d__2")]
[ExtensionAttribute]
internal static Task`1<JObject> AsJObjectAsync(Stream stream);
    [ExtensionAttribute]
internal static Task`1<Stream> AsSeekableStreamAsync(Stream stream);
    [AsyncStateMachineAttribute("NuGet.Protocol.StreamExtensions/<AsSeekableStreamAsync>d__4")]
[ExtensionAttribute]
internal static Task`1<Stream> AsSeekableStreamAsync(Stream stream, bool leaveStreamOpen);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class NuGet.Protocol.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string ActionExecutor_RollingBack { get; }
    public static string ActionResolver_UnsupportedAction { get; }
    public static string ActionResolver_UnsupportedDependencyBehavior { get; }
    public static string AddPackage_ExistingPackageInvalid { get; }
    public static string AddPackage_PackageAlreadyExists { get; }
    public static string AddPackage_SuccessfullyAdded { get; }
    public static string Argument_Cannot_Be_Null_Or_Empty { get; }
    public static string ArgumentCannotBeNullOrEmpty { get; }
    public static string DefaultSymbolServer { get; }
    public static string DeleteCommandCanceled { get; }
    public static string DeleteCommandConfirm { get; }
    public static string DeleteCommandDeletedPackage { get; }
    public static string DeleteCommandDeletingPackage { get; }
    public static string DeletePackage_NotFound { get; }
    public static string DownloadActionHandler_InvalidDownloadUrl { get; }
    public static string DownloadActionHandler_NoDownloadUrl { get; }
    public static string Error_DownloadTimeout { get; }
    public static string Http_CredentialsForForbidden { get; }
    public static string Http_CredentialsForProxy { get; }
    public static string Http_CredentialsForUnauthorized { get; }
    public static string Http_RequestLog { get; }
    public static string Http_ResponseLog { get; }
    public static string Http_Timeout { get; }
    public static string InvalidVersionFolder { get; }
    public static string LiveFeed { get; }
    public static string Log_CanceledNupkgDownload { get; }
    public static string Log_ErrorDownloading { get; }
    public static string Log_FailedToDownloadPackage { get; }
    public static string Log_FailedToFetchV2Feed { get; }
    public static string Log_FailedToGetNupkgStream { get; }
    public static string Log_FailedToGetNuspecStream { get; }
    public static string Log_FailedToReadServiceIndex { get; }
    public static string Log_FailedToRetrievePackage { get; }
    public static string Log_FailedToVerifyRootDirectory { get; }
    public static string Log_FailedToVerifyValidFile { get; }
    public static string Log_FileIsCorrupt { get; }
    public static string Log_InvalidCacheEntry { get; }
    public static string Log_InvalidNupkgFromUrl { get; }
    public static string Log_RetryingFindPackagesById { get; }
    public static string Log_RetryingHttp { get; }
    public static string Log_RetryingServiceIndex { get; }
    public static string NoApiKeyFound { get; }
    public static string NuGetRepository_CannotCreateAggregateRepo { get; }
    public static string NuGetServiceProvider_ServiceNotSupported { get; }
    public static string NupkgPath_Invalid { get; }
    public static string NupkgPath_InvalidEx { get; }
    public static string OneOrMoreUrisMustBeSpecified { get; }
    public static string PackageActionDescriptionWrapper_UnrecognizedAction { get; }
    public static string PackageServerEndpoint_NotSupported { get; }
    public static string Path_Invalid { get; }
    public static string Path_Invalid_NotFileNotUnc { get; }
    public static string ProjectInstallationTarget_ProjectIsNotTargetted { get; }
    public static string Protocol_BadSource { get; }
    public static string Protocol_duplicateUri { get; }
    public static string Protocol_FlatContainerIndexVersionsNotArray { get; }
    public static string Protocol_IndexMissingResourcesNode { get; }
    public static string Protocol_InvalidJsonObject { get; }
    public static string Protocol_InvalidServiceIndex { get; }
    public static string Protocol_InvalidXml { get; }
    public static string Protocol_MalformedMetadataError { get; }
    public static string Protocol_MissingRegistrationBase { get; }
    public static string Protocol_MissingSearchService { get; }
    public static string Protocol_MissingVersion { get; }
    public static string Protocol_PackageMetadataError { get; }
    public static string Protocol_Search_LocalSourceNotFound { get; }
    public static string Protocol_UnsupportedVersion { get; }
    public static string PushCommandPackagePushed { get; }
    public static string PushCommandPushingPackage { get; }
    public static string RequiredFeatureUnsupportedException_DefaultMessageWithFeature { get; }
    public static string RequiredFeatureUnsupportedException_DefaultMessageWithoutFeature { get; }
    public static string UnableToFindFile { get; }
    public static string UnableToParseFolderV3Version { get; }
    public static string Warning_SymbolServerNotConfigured { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_ActionExecutor_RollingBack();
    public static string get_ActionResolver_UnsupportedAction();
    public static string get_ActionResolver_UnsupportedDependencyBehavior();
    public static string get_AddPackage_ExistingPackageInvalid();
    public static string get_AddPackage_PackageAlreadyExists();
    public static string get_AddPackage_SuccessfullyAdded();
    public static string get_Argument_Cannot_Be_Null_Or_Empty();
    public static string get_ArgumentCannotBeNullOrEmpty();
    public static string get_DefaultSymbolServer();
    public static string get_DeleteCommandCanceled();
    public static string get_DeleteCommandConfirm();
    public static string get_DeleteCommandDeletedPackage();
    public static string get_DeleteCommandDeletingPackage();
    public static string get_DeletePackage_NotFound();
    public static string get_DownloadActionHandler_InvalidDownloadUrl();
    public static string get_DownloadActionHandler_NoDownloadUrl();
    public static string get_Error_DownloadTimeout();
    public static string get_Http_CredentialsForForbidden();
    public static string get_Http_CredentialsForProxy();
    public static string get_Http_CredentialsForUnauthorized();
    public static string get_Http_RequestLog();
    public static string get_Http_ResponseLog();
    public static string get_Http_Timeout();
    public static string get_InvalidVersionFolder();
    public static string get_LiveFeed();
    public static string get_Log_CanceledNupkgDownload();
    public static string get_Log_ErrorDownloading();
    public static string get_Log_FailedToDownloadPackage();
    public static string get_Log_FailedToFetchV2Feed();
    public static string get_Log_FailedToGetNupkgStream();
    public static string get_Log_FailedToGetNuspecStream();
    public static string get_Log_FailedToReadServiceIndex();
    public static string get_Log_FailedToRetrievePackage();
    public static string get_Log_FailedToVerifyRootDirectory();
    public static string get_Log_FailedToVerifyValidFile();
    public static string get_Log_FileIsCorrupt();
    public static string get_Log_InvalidCacheEntry();
    public static string get_Log_InvalidNupkgFromUrl();
    public static string get_Log_RetryingFindPackagesById();
    public static string get_Log_RetryingHttp();
    public static string get_Log_RetryingServiceIndex();
    public static string get_NoApiKeyFound();
    public static string get_NuGetRepository_CannotCreateAggregateRepo();
    public static string get_NuGetServiceProvider_ServiceNotSupported();
    public static string get_NupkgPath_Invalid();
    public static string get_NupkgPath_InvalidEx();
    public static string get_OneOrMoreUrisMustBeSpecified();
    public static string get_PackageActionDescriptionWrapper_UnrecognizedAction();
    public static string get_PackageServerEndpoint_NotSupported();
    public static string get_Path_Invalid();
    public static string get_Path_Invalid_NotFileNotUnc();
    public static string get_ProjectInstallationTarget_ProjectIsNotTargetted();
    public static string get_Protocol_BadSource();
    public static string get_Protocol_duplicateUri();
    public static string get_Protocol_FlatContainerIndexVersionsNotArray();
    public static string get_Protocol_IndexMissingResourcesNode();
    public static string get_Protocol_InvalidJsonObject();
    public static string get_Protocol_InvalidServiceIndex();
    public static string get_Protocol_InvalidXml();
    public static string get_Protocol_MalformedMetadataError();
    public static string get_Protocol_MissingRegistrationBase();
    public static string get_Protocol_MissingSearchService();
    public static string get_Protocol_MissingVersion();
    public static string get_Protocol_PackageMetadataError();
    public static string get_Protocol_Search_LocalSourceNotFound();
    public static string get_Protocol_UnsupportedVersion();
    public static string get_PushCommandPackagePushed();
    public static string get_PushCommandPushingPackage();
    public static string get_RequiredFeatureUnsupportedException_DefaultMessageWithFeature();
    public static string get_RequiredFeatureUnsupportedException_DefaultMessageWithoutFeature();
    public static string get_UnableToFindFile();
    public static string get_UnableToParseFolderV3Version();
    public static string get_Warning_SymbolServerNotConfigured();
}
public class NuGet.Protocol.StsAuthenticationHandler : DelegatingHandler {
    private static SemaphoreSlim _credentialPromptLock;
    public static string STSEndPointHeader;
    public static string STSRealmHeader;
    public static string STSTokenHeader;
    private Uri _baseUri;
    private TokenStore _tokenStore;
    private Func`3<string, string, string> _tokenFactory;
    public StsAuthenticationHandler(PackageSource packageSource, TokenStore tokenStore);
    public StsAuthenticationHandler(PackageSource packageSource, TokenStore tokenStore, Func`3<string, string, string> tokenFactory);
    private static StsAuthenticationHandler();
    [AsyncStateMachineAttribute("NuGet.Protocol.StsAuthenticationHandler/<SendAsync>d__9")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private void PrepareSTSRequest(HttpRequestMessage request);
    public bool TryRetrieveSTSToken(HttpResponseMessage response);
    private static string AcquireSTSToken(string endpoint, string realm);
    private static string GetHeader(HttpResponseMessage response, string header);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public static class NuGet.Protocol.TimeoutUtility : object {
    [AsyncStateMachineAttribute("NuGet.Protocol.TimeoutUtility/<StartWithTimeout>d__0`1")]
public static Task`1<T> StartWithTimeout(Func`2<CancellationToken, Task`1<T>> getTask, TimeSpan timeout, string timeoutMessage, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.TimeoutUtility/<StartWithTimeout>d__1")]
public static Task StartWithTimeout(Func`2<CancellationToken, Task> getTask, TimeSpan timeout, string timeoutMessage, CancellationToken token);
}
public class NuGet.Protocol.TokenStore : object {
    private ConcurrentDictionary`2<Uri, string> _tokenCache;
    [CompilerGeneratedAttribute]
private static TokenStore <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Version>k__BackingField;
    public static TokenStore Instance { get; }
    public Guid Version { get; private set; }
    private static TokenStore();
    [CompilerGeneratedAttribute]
public static TokenStore get_Instance();
    [CompilerGeneratedAttribute]
public Guid get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Guid value);
    public string GetToken(Uri sourceUri);
    public void AddToken(Uri sourceUri, string token);
    private void StoreToken(Uri uri, string token);
    private static Uri GetRootUri(Uri uri);
}
internal static class NuGet.Protocol.Trim : object {
    public static void TrimByAllowedVersions(RegistrationInfo registrationInfo, IDictionary`2<string, VersionRange> allowedVersions);
    private static void Execute(RegistrationInfo registrationInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass1(PackageInfo packageInfo, string id, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass1(RegistrationInfo registrationInfo, KeyValuePair`2<string, VersionRange> allowedVersion);
    private static void Pass2(PackageInfo packageInfo, string id, Boolean& updated);
    private static void Pass2(RegistrationInfo registrationInfo, Boolean& updated);
    private static bool CheckDependenciesExists(PackageInfo packageInfo);
}
internal static class NuGet.Protocol.Types : object {
    public static Uri PackageSearchResult;
    public static Uri PackageIdentity;
    public static Uri PackageDescription;
    public static Uri PackageLicensing;
    public static Uri PackageDependencies;
    public static Uri DependencyGroup;
    public static Uri Dependency;
    public static Uri Stats;
    private static Types();
}
internal static class NuGet.Protocol.Utils : object {
    public static VersionRange CreateVersionRange(string stringToParse);
    [AsyncStateMachineAttribute("NuGet.Protocol.Utils/<LoadRanges>d__1")]
public static Task`1<IEnumerable`1<JObject>> LoadRanges(HttpSource httpSource, Uri registrationUri, VersionRange range, ILogger log, CancellationToken token);
    private static bool IsItemRangeRequired(VersionRange dependencyRange, NuGetVersion catalogItemLower, NuGetVersion catalogItemUpper);
}
public class NuGet.Protocol.V2FeedListResource : ListResource {
    private ILegacyFeedCapabilityResource _feedCapabilities;
    private IV2FeedParser _feedParser;
    private string _baseAddress;
    private static int Take;
    public string Source { get; }
    public V2FeedListResource(IV2FeedParser feedParser, ILegacyFeedCapabilityResource feedCapabilities, string baseAddress);
    public virtual string get_Source();
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedListResource/<ListAsync>d__7")]
public virtual Task`1<IEnumerableAsync`1<IPackageSearchMetadata>> ListAsync(string searchTerm, bool prerelease, bool allVersions, bool includeDelisted, ILogger logger, CancellationToken token);
}
public class NuGet.Protocol.V2FeedListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.V2FeedPackageInfo : PackageIdentity {
    private string _title;
    private string _summary;
    private String[] _authors;
    private string _description;
    private String[] _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    private string _reportAbuseUrl;
    private string _tags;
    private string _downloadCount;
    private bool _requireLicenseAcceptance;
    private Nullable`1<DateTimeOffset> _published;
    private string _dependencies;
    private string _downloadUrl;
    private string _packageHash;
    private string _packageHashAlgorithm;
    private NuGetVersion _minClientVersion;
    private static string NullString;
    public string Title { get; }
    public string Summary { get; }
    public string Description { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public string IconUrl { get; }
    public string LicenseUrl { get; }
    public string ProjectUrl { get; }
    public string DownloadUrl { get; }
    public string ReportAbuseUrl { get; }
    public string Tags { get; }
    public string DownloadCount { get; }
    public int DownloadCountAsInt { get; }
    public Nullable`1<DateTimeOffset> Published { get; }
    public bool IsListed { get; }
    public string Dependencies { get; }
    public IReadOnlyList`1<PackageDependencyGroup> DependencySets { get; }
    public bool RequireLicenseAcceptance { get; }
    public string PackageHash { get; }
    public string PackageHashAlgorithm { get; }
    public NuGetVersion MinClientVersion { get; }
    public V2FeedPackageInfo(PackageIdentity identity, string title, string summary, string description, IEnumerable`1<string> authors, IEnumerable`1<string> owners, string iconUrl, string licenseUrl, string projectUrl, string reportAbuseUrl, string tags, Nullable`1<DateTimeOffset> published, string dependencies, bool requireLicenseAccept, string downloadUrl, string downloadCount, string packageHash, string packageHashAlgorithm, NuGetVersion minClientVersion);
    public string get_Title();
    public string get_Summary();
    public string get_Description();
    public IEnumerable`1<string> get_Authors();
    public IEnumerable`1<string> get_Owners();
    public string get_IconUrl();
    public string get_LicenseUrl();
    public string get_ProjectUrl();
    public string get_DownloadUrl();
    public string get_ReportAbuseUrl();
    public string get_Tags();
    public string get_DownloadCount();
    public int get_DownloadCountAsInt();
    public Nullable`1<DateTimeOffset> get_Published();
    public bool get_IsListed();
    public string get_Dependencies();
    public IReadOnlyList`1<PackageDependencyGroup> get_DependencySets();
    public bool get_RequireLicenseAcceptance();
    public string get_PackageHash();
    public string get_PackageHashAlgorithm();
    public NuGetVersion get_MinClientVersion();
}
public class NuGet.Protocol.V2FeedPage : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<V2FeedPackageInfo> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextUri>k__BackingField;
    public IReadOnlyList`1<V2FeedPackageInfo> Items { get; }
    public string NextUri { get; }
    public V2FeedPage(List`1<V2FeedPackageInfo> items, string nextUri);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<V2FeedPackageInfo> get_Items();
    [CompilerGeneratedAttribute]
public string get_NextUri();
}
public class NuGet.Protocol.V2FeedParser : object {
    private static string W3Atom;
    private static string MetadataNS;
    private static string DataServicesNS;
    private static XName _xnameEntry;
    private static XName _xnameTitle;
    private static XName _xnameContent;
    private static XName _xnameLink;
    private static XName _xnameProperties;
    private static XName _xnameId;
    private static XName _xnameVersion;
    private static XName _xnameSummary;
    private static XName _xnameDescription;
    private static XName _xnameIconUrl;
    private static XName _xnameLicenseUrl;
    private static XName _xnameProjectUrl;
    private static XName _xnameTags;
    private static XName _xnameReportAbuseUrl;
    private static XName _xnameDependencies;
    private static XName _xnameRequireLicenseAcceptance;
    private static XName _xnameDownloadCount;
    private static XName _xnamePublished;
    private static XName _xnameName;
    private static XName _xnameAuthor;
    private static XName _xnamePackageHash;
    private static XName _xnamePackageHashAlgorithm;
    private static XName _xnameMinClientVersion;
    private HttpSource _httpSource;
    private string _baseAddress;
    private V2FeedQueryBuilder _queryBuilder;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Source { get; private set; }
    public V2FeedParser(HttpSource httpSource, string baseAddress);
    public V2FeedParser(HttpSource httpSource, string baseAddress, string source);
    private static V2FeedParser();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(string value);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetPackage>d__35")]
public Task`1<V2FeedPackageInfo> GetPackage(PackageIdentity package, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<FindPackagesByIdAsync>d__36")]
public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> FindPackagesByIdAsync(string id, bool includeUnlisted, bool includePrerelease, ILogger log, CancellationToken token);
    public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> FindPackagesByIdAsync(string id, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetPackagesPageAsync>d__38")]
public sealed virtual Task`1<V2FeedPage> GetPackagesPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<GetSearchPageAsync>d__39")]
public sealed virtual Task`1<V2FeedPage> GetSearchPageAsync(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<Search>d__40")]
public Task`1<IReadOnlyList`1<V2FeedPackageInfo>> Search(string searchTerm, SearchFilter filters, int skip, int take, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<DownloadFromUrl>d__41")]
public Task`1<DownloadResourceResult> DownloadFromUrl(PackageIdentity package, Uri downloadUri, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<DownloadFromIdentity>d__42")]
public Task`1<DownloadResourceResult> DownloadFromIdentity(PackageIdentity package, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger log, CancellationToken token);
    private IEnumerable`1<V2FeedPackageInfo> ParsePage(XDocument doc, string id);
    private V2FeedPackageInfo ParsePackage(string id, XElement element);
    private static string GetValue(XElement parent, XName childName);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<QueryV2FeedAsync>d__46")]
public Task`1<V2FeedPage> QueryV2FeedAsync(string relativeUri, string id, int max, bool ignoreNotFounds, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<LoadXmlAsync>d__47")]
internal Task`1<XDocument> LoadXmlAsync(string uri, bool ignoreNotFounds, ILogger log, CancellationToken token);
    internal static string GetNextUrl(XDocument doc);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedParser/<LoadXmlAsync>d__49")]
internal static Task`1<XDocument> LoadXmlAsync(Stream stream);
}
public class NuGet.Protocol.V2FeedQueryBuilder : object {
    private static string IsLatestVersionFilterFlag;
    private static string IsAbsoluteLatestVersionFilterFlag;
    private static string IdProperty;
    private static string SemVerLevel;
    private static string GetSpecificPackageFormat;
    private static string SearchEndpointFormat;
    private static string QueryDelimiter;
    private static string FindPackagesByIdFormat;
    private static string GetPackagesFormat;
    private static string EndpointParenthesis;
    private static string SearchClauseFormat;
    private static string OrFormat;
    private static string AndFormat;
    private static string FilterFormat;
    private static string OrderByFormat;
    private static string SkipFormat;
    private static string TopFormat;
    private static string TagTermFormat;
    private static string FirstParameterFormat;
    private static string ParameterFormat;
    private static string TagsProperty;
    private static String[] _propertiesToSearch;
    private static V2FeedQueryBuilder();
    public string BuildSearchUri(string searchTerm, SearchFilter filters, int skip, int take);
    public string BuildFindPackagesByIdUri(string id);
    public string BuildGetPackageUri(PackageIdentity package);
    public string BuildGetPackagesUri(string searchTerm, SearchFilter filters, Nullable`1<int> skip, Nullable`1<int> take);
    private string BuildTop(Nullable`1<int> top);
    private string BuildSkip(Nullable`1<int> skip);
    private string BuildFilter(string searchTerm, Nullable`1<SearchFilterType> searchFilterType);
    private string BuildOrderBy(Nullable`1<SearchOrderBy> searchOrderBy);
    private string BuildPropertyFilter(Nullable`1<SearchFilterType> searchFilterType);
    private string BuildFieldSearchFilter(string searchTerm);
    private string BuildFieldSearchClause(string term, string property);
    [CompilerGeneratedAttribute]
private string <BuildFieldSearchFilter>b__31_1(string term, string property);
}
public class NuGet.Protocol.V2FeedUtilities : object {
    public static IPackageSearchMetadata CreatePackageSearchResult(V2FeedPackageInfo package, SearchFilter filter, V2FeedParser feedParser, ILogger log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Protocol.V2FeedUtilities/<GetVersions>d__1")]
private static Task`1<IEnumerable`1<VersionInfo>> GetVersions(V2FeedPackageInfo package, SearchFilter filter, V2FeedParser feedParser, ILogger log, CancellationToken cancellationToken);
}
public class NuGet.Protocol.V3FeedListResourceProvider : ResourceProvider {
    [AsyncStateMachineAttribute("NuGet.Protocol.V3FeedListResourceProvider/<TryCreate>d__1")]
public virtual Task`1<Tuple`2<bool, INuGetResource>> TryCreate(SourceRepository source, CancellationToken token);
}
public class NuGet.Protocol.VersionInfoConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    internal static bool EqualsWithNullCheck(T self, T other);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private bool _initialized;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    internal void AddInt32(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(TValue o, IEqualityComparer`1<TValue> comparer);
    internal void AddObject(object o);
    internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(Object[] objects);
    private void CheckInitialized();
}
internal static class ODataServiceDocumentUtils : object {
    [AsyncStateMachineAttribute("ODataServiceDocumentUtils/<CreateODataServiceDocumentResourceV2>d__0")]
public static Task`1<ODataServiceDocumentResourceV2> CreateODataServiceDocumentResourceV2(string url, HttpSource client, DateTime utcNow, ILogger log, CancellationToken token);
}
