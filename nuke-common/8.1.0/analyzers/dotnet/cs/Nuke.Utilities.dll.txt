[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Nuke.Common.ArgumentParser : object {
    private String[] _arguments;
    public IReadOnlyList`1<string> Arguments { get; }
    public ArgumentParser(string arguments);
    public ArgumentParser(IEnumerable`1<string> arguments);
    public static bool IsArgument(string value);
    public static string GetArgumentMemberName(string name);
    public static string GetParameterDashedName(string name);
    private static String[] Parse(string arguments);
    public IReadOnlyList`1<string> get_Arguments();
    public bool HasArgument(string argumentName);
    [CanBeNullAttribute]
public object GetNamedArgument(string argumentName, Type destinationType, Nullable`1<char> separator);
    [CanBeNullAttribute]
public object GetPositionalArgument(int position, Type destinationType, Nullable`1<char> separator);
    [CanBeNullAttribute]
public object GetAllPositionalArguments(Type destinationType, Nullable`1<char> separator);
    private int GetArgumentIndex(string argumentName);
    [CanBeNullAttribute]
private object ConvertArgument(string argumentName, String[] values, Type destinationType, Nullable`1<char> separator);
    [CanBeNullAttribute]
private object ConvertValues(string argumentName, IReadOnlyCollection`1<string> values, Type destinationType);
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.Assert : object {
    [ContractAnnotationAttribute("=> halt")]
public static void Fail(string message, Exception exception);
    [ContractAnnotationAttribute("condition: false => halt")]
public static void True(bool condition, string message, string argumentExpression);
    [ContractAnnotationAttribute("condition: true => halt")]
public static void False(bool condition, string message, string argumentExpression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("obj: null => halt; => notnull")]
public static T NotNull(T obj, string message, string argumentExpression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("obj: null => halt; => notnull")]
public static Nullable`1<T> NotNull(Nullable`1<T> obj, string message, string argumentExpression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("str: null => halt")]
public static string NotNullOrEmpty(string str, string message, string argumentExpression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("str: null => halt")]
public static string NotNullOrWhiteSpace(string str, string message, string argumentExpression);
    [ContractAnnotationAttribute("collection: null => halt")]
public static void NotEmpty(IReadOnlyCollection`1<T> collection, string message, string argumentExpression);
    [ContractAnnotationAttribute("collection: null => halt")]
public static void Empty(IReadOnlyCollection`1<T> collection, string message, string argumentExpression);
    [ContractAnnotationAttribute("collection: null => halt")]
public static void Count(IReadOnlyCollection`1<T> collection, int length, string message, string argumentExpression);
    [ContractAnnotationAttribute("collection: null => halt")]
public static void HasSingleItem(IReadOnlyCollection`1<T> collection, string message, string argumentExpression);
    [ContractAnnotationAttribute("path: null => stop")]
public static void FileExists(string path, string message, string argumentExpression);
    [ContractAnnotationAttribute("path: null => stop")]
public static void DirectoryExists(string path, string message, string argumentExpression);
}
internal static class Nuke.Common.AsyncHelper : object {
    private static TaskFactory s_taskFactory;
    private static AsyncHelper();
    public static TResult RunSync(Func`1<Task`1<TResult>> func);
    public static void RunSync(Func`1<Task> func);
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.EnvironmentInfo : object {
    internal static ArgumentParser ArgumentParser;
    private static string s_pathVariableName;
    private static char s_pathVariableSeparator;
    public static IReadOnlyCollection`1<string> CommandLineArguments { get; }
    public static string NewLine { get; }
    public static string MachineName { get; }
    public static AbsolutePath WorkingDirectory { get; public set; }
    public static bool IsArm64 { get; }
    public static bool Is64Bit { get; }
    public static bool Is32Bit { get; }
    public static bool IsUnix { get; }
    public static bool IsWin { get; }
    public static bool IsLinux { get; }
    public static bool IsOsx { get; }
    public static bool IsWsl { get; }
    public static FrameworkName Framework { get; }
    public static PlatformFamily Platform { get; }
    public static IReadOnlyDictionary`2<string, string> Variables { get; }
    public static IReadOnlyCollection`1<string> Paths { get; }
    private static EnvironmentInfo();
    public static IReadOnlyCollection`1<string> get_CommandLineArguments();
    [PureAttribute]
public static bool HasArgument(string name);
    [PureAttribute]
public static bool HasArgument(Expression`1<Func`1<T>> expression);
    [PureAttribute]
[CanBeNullAttribute]
public static T GetNamedArgument(string parameterName, Nullable`1<char> separator);
    [PureAttribute]
[CanBeNullAttribute]
public static T GetNamedArgument(Expression`1<Func`1<T>> expression, Nullable`1<char> separator);
    [PureAttribute]
[CanBeNullAttribute]
public static T GetNamedArgument(Expression`1<Func`1<object>> expression, Nullable`1<char> separator);
    [PureAttribute]
[CanBeNullAttribute]
public static T GetPositionalArgument(int position, Nullable`1<char> separator);
    [PureAttribute]
[CanBeNullAttribute]
public static T[] GetAllPositionalArguments(Nullable`1<char> separator);
    public static string get_NewLine();
    public static string get_MachineName();
    public static AbsolutePath get_WorkingDirectory();
    public static void set_WorkingDirectory(AbsolutePath value);
    [ExtensionAttribute]
public static IDisposable SwitchWorkingDirectory(AbsolutePath path);
    public static bool get_IsArm64();
    public static bool get_Is64Bit();
    public static bool get_Is32Bit();
    public static bool get_IsUnix();
    public static bool get_IsWin();
    public static bool get_IsLinux();
    public static bool get_IsOsx();
    public static bool get_IsWsl();
    public static FrameworkName get_Framework();
    public static PlatformFamily get_Platform();
    [CanBeNullAttribute]
public static AbsolutePath SpecialFolder(SpecialFolders folder);
    public static IReadOnlyDictionary`2<string, string> get_Variables();
    public static IReadOnlyCollection`1<string> get_Paths();
    public static bool HasVariable(string name, bool allowEmpty);
    [CanBeNullAttribute]
public static string GetVariable(string name);
    [CanBeNullAttribute]
public static T GetVariable(string name, Nullable`1<char> separator);
    public static void SetVariable(string name, string value);
    public static void SetVariable(string name, T value);
    public static void RemoveVariable(string name);
    public static string ExpandVariables(string value);
    [CompilerGeneratedAttribute]
internal static string <ExpandVariables>g__ExpandUnixEnvironmentVariables|51_0(<>c__DisplayClass51_0& );
}
[PublicAPIAttribute]
[TypeConverterAttribute("Nuke.Common.IO.AbsolutePath/TypeConverter")]
[DebuggerDisplayAttribute("{_path}")]
public class Nuke.Common.IO.AbsolutePath : object {
    public static string DoubleQuote;
    public static string DoubleQuoteIfNeeded;
    public static string SingleQuote;
    public static string SingleQuoteIfNeeded;
    public static string NoQuotes;
    private string _path;
    private AbsolutePath Nuke.Common.IO.IAbsolutePathHolder.Path { get; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    public string Extension { get; }
    [CanBeNullAttribute]
public AbsolutePath Parent { get; }
    private AbsolutePath(string path);
    public static AbsolutePath Create(string path);
    private sealed virtual override AbsolutePath Nuke.Common.IO.IAbsolutePathHolder.get_Path();
    [ContractAnnotationAttribute("null => null")]
public static AbsolutePath op_Implicit(string path);
    public static string op_Implicit(AbsolutePath path);
    public string get_Name();
    public string get_NameWithoutExtension();
    public string get_Extension();
    public AbsolutePath get_Parent();
    public static AbsolutePath op_Division(AbsolutePath left, string right);
    public static AbsolutePath op_Addition(AbsolutePath left, string right);
    public static bool op_Equality(AbsolutePath a, AbsolutePath b);
    public static bool op_Inequality(AbsolutePath a, AbsolutePath b);
    protected bool Equals(AbsolutePath other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class Nuke.Common.IO.AbsolutePathExtensions : object {
    public static Encoding DefaultEncoding;
    public static Nullable`1<PlatformFamily> DefaultLineBreakType;
    public static bool DefaultEofLineBreak;
    private static AbsolutePathExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<AbsolutePath> GetFiles(AbsolutePath path, string pattern, int depth, FileAttributes attributes);
    [IteratorStateMachineAttribute("Nuke.Common.IO.AbsolutePathExtensions/<GetDirectories>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<AbsolutePath> GetDirectories(AbsolutePath path, string pattern, int depth, FileAttributes attributes);
    [ExtensionAttribute]
public static AbsolutePath CreateDirectory(AbsolutePath path);
    [ExtensionAttribute]
public static AbsolutePath CreateOrCleanDirectory(AbsolutePath path);
    [ExtensionAttribute]
public static AbsolutePath TouchFile(AbsolutePath path, Nullable`1<DateTime> time, bool createDirectories);
    [ExtensionAttribute]
public static void DeleteFile(AbsolutePath path);
    [ExtensionAttribute]
public static void DeleteDirectory(AbsolutePath path);
    [ExtensionAttribute]
public static void DeleteFiles(IEnumerable`1<AbsolutePath> paths);
    [ExtensionAttribute]
public static void DeleteDirectories(IEnumerable`1<AbsolutePath> paths);
    [ExtensionAttribute]
[PureAttribute]
public static bool Exists(AbsolutePath path, string expression);
    [ExtensionAttribute]
[PureAttribute]
public static bool FileExists(AbsolutePath path);
    [ExtensionAttribute]
[PureAttribute]
public static bool DirectoryExists(AbsolutePath path);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsFile(AbsolutePath path, string pattern, SearchOption options);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsDirectory(AbsolutePath path, string pattern, SearchOption options);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static AbsolutePath Existing(AbsolutePath path, string expression);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static AbsolutePath ExistingFile(AbsolutePath path);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static AbsolutePath ExistingDirectory(AbsolutePath path);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<AbsolutePath> WhereFileExists(IEnumerable`1<AbsolutePath> paths);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<AbsolutePath> WhereDirectoryExists(IEnumerable`1<AbsolutePath> paths);
    [ExtensionAttribute]
public static bool HasExtension(AbsolutePath path, string extension, String[] alternativeExtensions);
    [ExtensionAttribute]
public static AbsolutePath WithExtension(AbsolutePath path, string extension);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static AbsolutePath FindParent(AbsolutePath path, Func`2<AbsolutePath, bool> predicate);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static AbsolutePath FindParentOrSelf(AbsolutePath path, Func`2<AbsolutePath, bool> predicate);
    [ExtensionAttribute]
[PureAttribute]
public static string GetFileHash(AbsolutePath path);
    [ExtensionAttribute]
[PureAttribute]
public static string GetDirectoryHash(AbsolutePath path, Func`2<AbsolutePath, bool> includeFile);
    [ExtensionAttribute]
[PureAttribute]
public static string GetFileSetHash(IEnumerable`1<AbsolutePath> paths, string baseDirectory);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; => notnull")]
public static FileInfo ToFileInfo(AbsolutePath path);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; => notnull")]
public static DirectoryInfo ToDirectoryInfo(AbsolutePath path);
    [ExtensionAttribute]
public static AbsolutePath Rename(AbsolutePath source, string newName, ExistsPolicy policy);
    [ExtensionAttribute]
public static AbsolutePath Rename(AbsolutePath source, Func`2<AbsolutePath, string> newName, ExistsPolicy policy);
    [ExtensionAttribute]
public static AbsolutePath RenameWithoutExtension(AbsolutePath source, string newName, ExistsPolicy policy);
    [ExtensionAttribute]
public static AbsolutePath RenameWithoutExtension(AbsolutePath source, Func`2<AbsolutePath, string> newName, ExistsPolicy policy);
    [ExtensionAttribute]
public static AbsolutePath MoveToDirectory(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, bool createDirectories);
    [ExtensionAttribute]
public static AbsolutePath CopyToDirectory(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, Func`2<AbsolutePath, bool> excludeDirectory, Func`2<AbsolutePath, bool> excludeFile, bool createDirectories);
    [ExtensionAttribute]
public static AbsolutePath Move(AbsolutePath source, Func`2<AbsolutePath, AbsolutePath> newPath, ExistsPolicy policy, bool createDirectories);
    [ExtensionAttribute]
public static AbsolutePath Move(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, bool createDirectories, bool deleteRemainingFiles);
    [ExtensionAttribute]
public static AbsolutePath Copy(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, Func`2<AbsolutePath, bool> excludeDirectory, Func`2<AbsolutePath, bool> excludeFile, bool createDirectories);
    [ExtensionAttribute]
private static AbsolutePath MoveFile(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, bool createDirectories);
    [ExtensionAttribute]
private static AbsolutePath CopyFile(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, bool createDirectories);
    private static AbsolutePath HandleFile(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, bool createDirectories, Action action);
    [ExtensionAttribute]
private static AbsolutePath MoveDirectory(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, bool createDirectories, bool deleteRemainingFiles);
    [ExtensionAttribute]
private static AbsolutePath CopyDirectory(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, Func`2<AbsolutePath, bool> excludeDirectory, Func`2<AbsolutePath, bool> excludeFile, bool createDirectories);
    private static AbsolutePath HandleDirectory(AbsolutePath source, AbsolutePath target, ExistsPolicy policy, bool createDirectories, Action action);
    [ExtensionAttribute]
public static AbsolutePath AppendAllLines(AbsolutePath path, IEnumerable`1<string> lines, Encoding encoding);
    [ExtensionAttribute]
public static AbsolutePath AppendAllLines(AbsolutePath path, String[] lines, Encoding encoding);
    [ExtensionAttribute]
public static AbsolutePath AppendAllText(AbsolutePath path, string content, Encoding encoding);
    [ExtensionAttribute]
public static AbsolutePath WriteAllLines(AbsolutePath path, IEnumerable`1<string> lines, Encoding encoding, Nullable`1<PlatformFamily> platformFamily, Nullable`1<bool> eofLineBreak);
    [ExtensionAttribute]
public static AbsolutePath WriteAllLines(AbsolutePath path, String[] lines, Encoding encoding, Nullable`1<PlatformFamily> platformFamily, Nullable`1<bool> eofLineBreak);
    [ExtensionAttribute]
public static AbsolutePath WriteAllText(AbsolutePath path, string content, Encoding encoding, Nullable`1<bool> eofLineBreak);
    [ExtensionAttribute]
public static AbsolutePath WriteAllBytes(AbsolutePath path, Byte[] bytes);
    [ExtensionAttribute]
public static string ReadAllText(AbsolutePath path, Encoding encoding);
    [ExtensionAttribute]
public static String[] ReadAllLines(AbsolutePath path, Encoding encoding);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(AbsolutePath path);
    [ExtensionAttribute]
public static AbsolutePath UpdateText(AbsolutePath path, Func`2<string, string> update, Encoding encoding);
    [CompilerGeneratedAttribute]
internal static bool <HandleFile>g__Permitted|39_0(<>c__DisplayClass39_0& );
}
[FlagsAttribute]
public enum Nuke.Common.IO.ExistsPolicy : Enum {
    public int value__;
    public static ExistsPolicy DirectoryFail;
    public static ExistsPolicy DirectoryMerge;
    public static ExistsPolicy FileFail;
    public static ExistsPolicy FileSkip;
    public static ExistsPolicy FileOverwrite;
    public static ExistsPolicy FileOverwriteIfNewer;
    public static ExistsPolicy Fail;
    public static ExistsPolicy MergeAndSkip;
    public static ExistsPolicy MergeAndOverwrite;
    public static ExistsPolicy MergeAndOverwriteIfNewer;
}
public interface Nuke.Common.IO.IAbsolutePathHolder {
    public AbsolutePath Path { get; }
    public abstract virtual AbsolutePath get_Path();
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class Nuke.Common.IO.PathConstruction : object {
    internal static char WinSeparator;
    internal static char UncSeparator;
    internal static char UnixSeparator;
    internal static Char[] AllSeparators;
    private static PathConstruction();
    [PureAttribute]
public static WinRelativePath GetWinRelativePath(string basePath, string destinationPath);
    [PureAttribute]
public static UnixRelativePath GetUnixRelativePath(string basePath, string destinationPath);
    [ExtensionAttribute]
public static RelativePath GetRelativePathTo(AbsolutePath basePath, string destinationPath);
    [ExtensionAttribute]
public static WinRelativePath GetWinRelativePathTo(AbsolutePath basePath, string destinationPath);
    [ExtensionAttribute]
public static UnixRelativePath GetUnixRelativePathTo(AbsolutePath basePath, string destinationPath);
    [ExtensionAttribute]
public static WinRelativePath ToWinRelativePath(RelativePath path);
    [ExtensionAttribute]
public static UnixRelativePath ToUnixRelativePath(RelativePath path);
    [ExtensionAttribute]
public static bool Contains(AbsolutePath basePath, string destinationPath);
    [PureAttribute]
[CodeTemplateAttribute("PathConstruction.GetRelativePath($expr{'Nuke.Common.IO.AbsolutePath', true}$, $args$)")]
[CodeTemplateAttribute("GetRelativePath($expr{'Nuke.Common.IO.AbsolutePath', true}$, $args$)")]
public static string GetRelativePath(string basePath, string destinationPath);
    [PureAttribute]
[CodeTemplateAttribute("PathConstruction.IsDescendantPath($expr{'Nuke.Common.IO.AbsolutePath', true}$, $args$)")]
[CodeTemplateAttribute("IsDescendantPath($expr{'Nuke.Common.IO.AbsolutePath', true}$, $args$)")]
public static bool IsDescendantPath(string basePath, string destinationPath);
    private static bool IsSameDirectory(string pathPart);
    private static bool IsUpwardsDirectory(string pathPart);
    internal static bool IsWinRoot(string root);
    internal static bool IsUnixRoot(string root);
    internal static bool IsUncRoot(string root);
    private static string GetHeadPart(string str, int count);
    internal static bool HasUnixRoot(string path);
    internal static bool HasUncRoot(string path);
    internal static bool HasWinRoot(string path);
    public static bool HasPathRoot(string path);
    [CanBeNullAttribute]
public static string GetPathRoot(string path);
    public static string Combine(string left, string right, Nullable`1<char> separator);
    public static string NormalizePath(string path, Nullable`1<char> separator);
    private static char GetSeparator(string path);
    private static void AssertSeparatorChoice(string path, Nullable`1<char> separator);
    [ContractAnnotationAttribute("null => null; notnull => notnull")]
private static string Trim(string path);
}
[PublicAPIAttribute]
[DebuggerDisplayAttribute("{_path}")]
public class Nuke.Common.IO.RelativePath : object {
    private string _path;
    private Nullable`1<char> _separator;
    protected RelativePath(string path, Nullable`1<char> separator);
    public static RelativePath op_Explicit(string path);
    public static string op_Implicit(RelativePath path);
    public static RelativePath op_Division(RelativePath left, string right);
    public static RelativePath op_Addition(RelativePath left, string right);
    public virtual string ToString();
}
[PublicAPIAttribute]
public class Nuke.Common.IO.UnixRelativePath : RelativePath {
    protected UnixRelativePath(string path, Nullable`1<char> separator);
    public static UnixRelativePath op_Explicit(string path);
}
[PublicAPIAttribute]
public class Nuke.Common.IO.WinRelativePath : RelativePath {
    protected WinRelativePath(string path, Nullable`1<char> separator);
    public static WinRelativePath op_Explicit(string path);
}
public enum Nuke.Common.PlatformFamily : Enum {
    public int value__;
    public static PlatformFamily Unknown;
    public static PlatformFamily Windows;
    public static PlatformFamily Linux;
    public static PlatformFamily OSX;
}
[PublicAPIAttribute]
public enum Nuke.Common.SpecialFolders : Enum {
    public int value__;
    public static SpecialFolders ProgramFiles;
    public static SpecialFolders ProgramFilesX86;
    public static SpecialFolders LocalApplicationData;
    public static SpecialFolders ApplicationData;
    public static SpecialFolders CommonApplicationData;
    public static SpecialFolders Windows;
    public static SpecialFolders System;
    public static SpecialFolders UserProfile;
}
[ExtensionAttribute]
public static class Nuke.Common.Utilities.AssemblyExtensions : object {
    [ExtensionAttribute]
public static string GetInformationalText(Assembly assembly);
    [ExtensionAttribute]
public static string GetVersionText(Assembly assembly);
    [ExtensionAttribute]
private static string GetAssemblyInformationalVersion(Assembly assembly);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class Nuke.Common.Utilities.Collections.ArrayExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(T[] items, T& t0);
    [ExtensionAttribute]
public static void Deconstruct(T[] items, T& t0, T& t1);
    [ExtensionAttribute]
public static void Deconstruct(T[] items, T& t0, T& t1, T& t2);
    [ExtensionAttribute]
public static void Deconstruct(T[] items, T& t0, T& t1, T& t2, T& t3);
    [ExtensionAttribute]
public static void Deconstruct(T[] items, T& t0, T& t1, T& t2, T& t3, T& t4);
    [ExtensionAttribute]
public static void Deconstruct(T[] items, T& t0, T& t1, T& t2, T& t3, T& t4, T& t5);
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerStepThroughAttribute]
[DebuggerNonUserCodeAttribute]
public static class Nuke.Common.Utilities.Collections.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TDictionary AddDictionary(TDictionary dictionary, IDictionary`2<TKey, TValue> otherDictionary);
    [ExtensionAttribute]
public static TDictionary AddDictionary(TDictionary dictionary, IReadOnlyDictionary`2<TKey, TValue> otherDictionary);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> AddPair(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static IDictionary`2<TKey, string> AddPair(IDictionary`2<TKey, string> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> AddPairWhenKeyNotNull(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> AddPairWhenValueNotNull(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<TKey, TValue> AsReadOnly(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<T1, T2> tuple, T1& key, T2& value);
    [ExtensionAttribute]
[CanBeNullAttribute]
internal static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> SetKeyValue(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToGeneric(IDictionary dictionary, IEqualityComparer`1<TKey> equalityComparer);
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.Utilities.Collections.EnumerableExtensions : object {
    private static Random s_randomNumberGenerator;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> AsEnumerable(object obj);
    [IteratorStateMachineAttribute("Nuke.Common.Utilities.Collections.EnumerableExtensions/<Concat>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Concat(T obj, IEnumerable`1<T> enumerable);
    [IteratorStateMachineAttribute("Nuke.Common.Utilities.Collections.EnumerableExtensions/<Concat>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> enumerable, T[] others);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> Distinct(IEnumerable`1<TSource> enumerable, Func`2<TSource, TValue> selector);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumerable, Action`1<T> action);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumerable, Action`2<T, int> action);
    [IteratorStateMachineAttribute("Nuke.Common.Utilities.Collections.EnumerableExtensions/<ForEachLazy>d__9`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> ForEachLazy(IEnumerable`1<T> enumerable, Action`1<T> action);
    [ExtensionAttribute]
public static T Random(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static ICollection`1<T> Randomize(ICollection`1<T> collection);
    [ExtensionAttribute]
public static bool SequenceStartsWith(IEnumerable`1<T> enumerable, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T SingleOrDefaultOrError(IEnumerable`1<T> enumerable, Func`2<T, bool> predicate, string message);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T SingleOrDefaultOrError(IEnumerable`1<T> enumerable, string message);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T SingleOrError(IEnumerable`1<T> enumerable, Func`2<T, bool> predicate, string message);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T SingleOrError(IEnumerable`1<T> enumerable, string message);
    [ExtensionAttribute]
public static IEnumerable`1<T> TakeUntil(IEnumerable`1<T> enumerable, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static IEnumerable`1<T> SkipUntil(IEnumerable`1<T> enumerable, Func`2<T, bool> condition);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<T> enumerable, Func`2<T, TKey> keySelector, Func`2<T, TValue> valueSelector, IEqualityComparer`1<TKey> comparer, Func`3<ArgumentException, TKey, Exception> exceptionFactory);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionarySafe(IEnumerable`1<T> enumerable, Func`2<T, TKey> keySelector, Func`2<T, TValue> valueSelector, string duplicationMessage);
    [ExtensionAttribute]
public static IEnumerable`1<T> ToEmptyIfNull(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static T[] ToEmptyIfNull(T[] array);
    [ExtensionAttribute]
public static IList`1<T> ToEmptyIfNull(IList`1<T> list);
    [ExtensionAttribute]
public static LookupTable`2<TKey, TValue> ToLookupTable(IEnumerable`1<TItem> enumerable, Func`2<TItem, TKey> keySelector, Func`2<TItem, TValue> valueSelector);
    [ExtensionAttribute]
public static IEnumerable`1<T> TSort(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> dependencies, bool throwOnCycle);
    private static void Visit(T item, HashSet`1<T> visited, List`1<T> sorted, Func`2<T, IEnumerable`1<T>> dependencies, bool throwOnCycle);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNot(IEnumerable`1<T> enumerable, Func`2<T, bool> condition);
    [IteratorStateMachineAttribute("Nuke.Common.Utilities.Collections.EnumerableExtensions/<DescendantsAndSelf>d__30`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> DescendantsAndSelf(T obj, Func`2<T, T> selector, Func`2<T, bool> traverse);
    [IteratorStateMachineAttribute("Nuke.Common.Utilities.Collections.EnumerableExtensions/<Descendants>d__31`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Descendants(T obj, Func`2<T, T> selector, Func`2<T, bool> traverse);
    [IteratorStateMachineAttribute("Nuke.Common.Utilities.Collections.EnumerableExtensions/<DescendantsAndSelf>d__32`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> DescendantsAndSelf(T obj, Func`2<T, IEnumerable`1<T>> selector, Func`2<T, bool> traverse);
    [IteratorStateMachineAttribute("Nuke.Common.Utilities.Collections.EnumerableExtensions/<Descendants>d__33`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Descendants(T obj, Func`2<T, IEnumerable`1<T>> selector, Func`2<T, bool> traverse);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<TKey, TValue> ToPropertyDictionary(T obj, Func`2<PropertyInfo, TKey> keySelector, Func`2<object, TValue> valueSelector);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class Nuke.Common.Utilities.Collections.LookupExtensions : object {
    [ExtensionAttribute]
public static LookupTable`2<TKey, TValue> ToLookupTable(ILookup`2<TKey, TValue> lookup, IEqualityComparer`1<TKey> comparer);
}
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class Nuke.Common.Utilities.Collections.LookupTable`2 : object {
    private Dictionary`2<TKey, List`1<TValue>> _dictionary;
    private ILookup`2<TKey, TValue> Lookup { get; }
    public int Count { get; }
    public IEnumerable`1<TValue> Item { get; }
    public LookupTable`2(IEqualityComparer`1<TKey> comparer);
    public LookupTable`2(ILookup`2<TKey, TValue> lookupTable, IEqualityComparer`1<TKey> comparer);
    public LookupTable`2(Dictionary`2<TKey, List`1<TValue>> dictionary);
    private ILookup`2<TKey, TValue> get_Lookup();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TValue> get_Item(TKey key);
    public void Add(TKey key, TValue value);
    public void AddRange(TKey key, IEnumerable`1<TValue> values);
    public void Remove(TKey key);
    public void Remove(TKey key, TValue value);
    public void Clear();
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Contains(TKey key);
    public ILookup`2<TKey, TValue> AsReadOnly();
}
public class Nuke.Common.Utilities.DelegateDisposable : object {
    [CanBeNullAttribute]
private Action _cleanup;
    private DelegateDisposable(Action cleanup);
    public static IDisposable CreateBracket(Action setup, Action cleanup);
    public static IDisposable CreateBracket(Func`1<T> setup, Action`1<T> cleanup);
    public static IDisposable SetAndRestore(Expression`1<Func`1<T>> memberProvider, T value);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Nuke.Common.Utilities.DisposableExtensions : object {
    [ExtensionAttribute]
public static IDisposable CombineWith(IDisposable disposable, Action setup, Action cleanup);
    [ExtensionAttribute]
public static IDisposable CombineWith(IDisposable disposable, IDisposable otherDisposable);
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.Utilities.ExceptionExtensions : object {
    [ExtensionAttribute]
public static Exception Unwrap(Exception exception);
}
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.Utilities.Lazy : object {
    public static Lazy`1<T> Create(Func`1<T> provider);
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.Utilities.ObjectExtensions : object {
    [ExtensionAttribute]
public static TOutput Apply(TInput input, Func`2<TInput, TOutput> transform);
    [ExtensionAttribute]
public static T Clone(T obj);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class Nuke.Common.Utilities.ReflectionUtility : object {
    public static BindingFlags All;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static T Convert(string value);
    [CanBeNullAttribute]
public static object Convert(object value, Type destinationType);
    [CanBeNullAttribute]
public static object Convert(string value, Type destinationType, Nullable`1<char> separator);
    [CanBeNullAttribute]
public static object Convert(IReadOnlyCollection`1<string> values, Type destinationType);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static object GetDefaultValue(Type type);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static Type GetNullableType(Type type);
    [ExtensionAttribute]
public static bool IsCollectionLike(Type type);
    [ExtensionAttribute]
public static T[] GetEnumValues(Type type);
    [ExtensionAttribute]
public static bool HasCustomAttribute(MemberInfo member);
    [ExtensionAttribute]
public static bool HasCustomAttribute(ParameterInfo parameter);
    [ExtensionAttribute]
public static Type GetMemberType(MemberInfo member);
    [ExtensionAttribute]
public static Type GetScalarType(Type type);
    [ExtensionAttribute]
public static bool IsPublic(MemberInfo member);
    [ExtensionAttribute]
public static bool IsFamily(MemberInfo member);
    [ExtensionAttribute]
public static bool IsAssembly(MemberInfo member);
    [ExtensionAttribute]
public static bool IsStatic(MemberInfo member);
    [ExtensionAttribute]
public static bool IsExtensionParameter(ParameterInfo parameter);
    [ExtensionAttribute]
public static bool IsExplicit(MemberInfo member);
    [ExtensionAttribute]
public static string GetPossibleExplicitName(MemberInfo member);
    [ExtensionAttribute]
public static MemberInfo GetImplementedOrInterfaceMember(MemberInfo member, Type classType);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetAllMembers(Type buildType, Func`2<MemberInfo, bool> filter, BindingFlags bindingFlags, bool allowAmbiguity, bool filterQuasiOverridden);
    [ExtensionAttribute]
public static string GetDisplayName(Type type);
    [ExtensionAttribute]
public static string GetDisplayName(MemberInfo member);
    [ExtensionAttribute]
public static string GetDisplayShortName(Type type);
    [ExtensionAttribute]
public static string GetDisplayShortName(MemberInfo member);
    [ExtensionAttribute]
internal static string GetDisplayShortName(Type type, IList`1<string> tupleNames);
    [ExtensionAttribute]
public static string GetDisplayText(ParameterInfo parameter);
    [ExtensionAttribute]
public static string GetDisplayText(MemberInfo member);
    [ExtensionAttribute]
public static IEnumerable`1<object> GetArguments(MethodCallExpression methodCall);
    public static MemberInfo GetMemberInfo(Expression`1<Func`1<T>> expression);
    [ExtensionAttribute]
public static MemberInfo GetMemberInfo(LambdaExpression expression);
    [ExtensionAttribute]
public static object GetTarget(LambdaExpression expression);
    [ExtensionAttribute]
public static T CreateInstance(Type type, Object[] args);
    [ExtensionAttribute]
public static T GetValue(MemberInfo member, object obj, Object[] args);
    [ExtensionAttribute]
public static object GetValue(MemberInfo member, object obj, Object[] args);
    [ExtensionAttribute]
public static TResult GetValueNonVirtual(MemberInfo member, object obj, Object[] arguments);
    [ExtensionAttribute]
public static void SetValue(MemberInfo member, object instance, object value);
    [ExtensionAttribute]
public static object InvokeMember(Type type, string memberName, object target, Nullable`1<BindingFlags> bindingFlags, Object[] args);
    [ExtensionAttribute]
public static T InvokeMember(Type type, string memberName, object target, Nullable`1<BindingFlags> bindingFlags, Object[] args);
    [ExtensionAttribute]
public static void DynamicInvokeUnwrap(Delegate delegate, Object[] args);
    [ExtensionAttribute]
public static T DynamicInvokeUnwrap(Delegate delegate, Object[] args);
}
public static class Nuke.Common.Utilities.ResourceUtility : object {
    public static string GetResourceAllText(string postfix);
    public static String[] GetResourceAllLines(string postfix);
    public static Stream GetResource(string postfix);
    public static Stream GetResource(Type typeForNamespace, string postfix);
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.Utilities.StringExtensions : object {
    private static String[] KnownWords;
    private static Regex s_unicodeRegex;
    private static StringExtensions();
    [ExtensionAttribute]
[PureAttribute]
public static string Capitalize(string text);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => halt")]
public static bool IsNullOrEmpty(string str);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => halt")]
public static bool IsNullOrWhiteSpace(string str);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static string ToNullIfEmpty(string str);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static string ToNullIfWhiteSpace(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string EscapeBraces(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string GetMD5Hash(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string GetSHA256Hash(string str);
    [ExtensionAttribute]
public static string GetHMACSHA256Hash(string str, string key);
    [ExtensionAttribute]
public static string GetHMACSHA1Hash(string str, string key);
    [ExtensionAttribute]
[PureAttribute]
public static string Indent(string text, int count);
    [ExtensionAttribute]
[PureAttribute]
public static int IndexOfRegex(string text, string expression);
    [ExtensionAttribute]
[PureAttribute]
public static string Join(IEnumerable`1<string> enumerable, string separator);
    [ExtensionAttribute]
[PureAttribute]
public static string Join(IEnumerable`1<string> enumerable, char separator);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinSpace(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinDash(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinUnderscore(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinAmpersand(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinSemicolon(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinSlash(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinBackslash(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinDot(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinComma(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinCommaSpace(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinCommaOr(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinCommaAnd(IEnumerable`1<string> values);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinNewLine(IEnumerable`1<string> values, Nullable`1<PlatformFamily> platformFamily);
    [ExtensionAttribute]
[PureAttribute]
public static string JoinParagraph(IEnumerable`1<string> values, Nullable`1<PlatformFamily> platformFamily);
    [ExtensionAttribute]
[PureAttribute]
public static string Prepend(string str, string prependText);
    [ExtensionAttribute]
[PureAttribute]
public static string Append(string str, string appendText);
    [ExtensionAttribute]
[PureAttribute]
public static string DoubleQuoteIfNeeded(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string DoubleQuoteIfNeeded(string str, Nullable`1[] disallowed);
    [ExtensionAttribute]
[PureAttribute]
public static string DoubleQuote(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string SingleQuoteIfNeeded(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string SingleQuoteIfNeeded(string str, Nullable`1[] disallowed);
    [ExtensionAttribute]
[PureAttribute]
public static string SingleQuote(string str);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDoubleQuoted(string str);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSingleQuoted(string str);
    [ExtensionAttribute]
[PureAttribute]
private static bool Contains(string str, Nullable`1[] chars);
    [ExtensionAttribute]
[PureAttribute]
public static string Repeat(char ch, int count);
    [ExtensionAttribute]
[PureAttribute]
public static string ReplaceRegex(string str, string pattern, MatchEvaluator matchEvaluator, RegexOptions options);
    [ExtensionAttribute]
[PureAttribute]
public static string ReplaceUnicode(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string ReplaceKnownWords(string str);
    [IteratorStateMachineAttribute("Nuke.Common.Utilities.StringExtensions/<Split>d__45")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<string> Split(string str, Func`3<char, int, bool> predicate, bool includeSplitCharacter);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<string> SplitCamelHumps(string str, String[] exclusions);
    [ExtensionAttribute]
[PureAttribute]
public static String[] SplitLineBreaks(string str, StringSplitOptions options);
    [ExtensionAttribute]
[PureAttribute]
public static String[] SplitParagraphs(string str, StringSplitOptions options);
    [ExtensionAttribute]
[PureAttribute]
public static String[] SplitSpace(string str);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<string> SplitCamelHumpsWithKnownWords(string str);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsOrdinalIgnoreCase(string str, string other);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsAnyOrdinalIgnoreCase(IEnumerable`1<string> str, String[] others);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualsOrdinalIgnoreCase(string str, string other);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsAnyOrdinalIgnoreCase(string str, String[] others);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsAnyOrdinalIgnoreCase(string str, IEnumerable`1<string> others);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualsAnyOrdinalIgnoreCase(string str, String[] others);
    [ExtensionAttribute]
[PureAttribute]
public static bool EqualsAnyOrdinalIgnoreCase(string str, IEnumerable`1<string> others);
    [ExtensionAttribute]
[PureAttribute]
public static bool StartsWithOrdinalIgnoreCase(string str, string other);
    [ExtensionAttribute]
[PureAttribute]
public static bool EndsWithOrdinalIgnoreCase(string str, string other);
    [ExtensionAttribute]
[PureAttribute]
public static bool StartsWithAny(string str, String[] others);
    [ExtensionAttribute]
[PureAttribute]
public static bool StartsWithAny(string str, IEnumerable`1<string> others);
    [ExtensionAttribute]
[PureAttribute]
public static bool StartsWithAnyOrdinalIgnoreCase(string str, String[] others);
    [ExtensionAttribute]
[PureAttribute]
public static bool StartsWithAnyOrdinalIgnoreCase(string str, IEnumerable`1<string> others);
    [ExtensionAttribute]
[PureAttribute]
public static bool EndsWithAny(string str, String[] others);
    [ExtensionAttribute]
[PureAttribute]
public static bool EndsWithAny(string str, IEnumerable`1<string> others);
    [ExtensionAttribute]
[PureAttribute]
public static bool EndsWithAnyOrdinalIgnoreCase(string str, String[] others);
    [ExtensionAttribute]
[PureAttribute]
public static bool EndsWithAnyOrdinalIgnoreCase(string str, IEnumerable`1<string> others);
    [ExtensionAttribute]
[PureAttribute]
public static string TrimToOne(string str, string trim);
    [ExtensionAttribute]
[PureAttribute]
public static string TrimWhitespaces(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string TrimEnd(string str, string trim);
    [ExtensionAttribute]
[PureAttribute]
public static string TrimStart(string str, string trim);
    [ExtensionAttribute]
[PureAttribute]
public static string TrimMatchingDoubleQuotes(string str);
    [ExtensionAttribute]
[PureAttribute]
public static string TrimMatchingSingleQuotes(string str);
    [ExtensionAttribute]
[PureAttribute]
internal static string TrimMatchingQuotes(string str, char quote);
    [ExtensionAttribute]
public static string Truncate(string str, int maxChars);
}
internal class Nuke.Common.Utilities.StronglyConnectedComponent`1 : object {
    private LinkedList`1<Vertex`1<T>> _list;
    public int Count { get; }
    public bool IsCycle { get; }
    public void Add(Vertex`1<T> vertex);
    public int get_Count();
    public bool get_IsCycle();
    public sealed virtual IEnumerator`1<Vertex`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Nuke.Common.Utilities.StronglyConnectedComponentFinder`1 : object {
    private StronglyConnectedComponentList`1<T> _stronglyConnectedComponents;
    private Stack`1<Vertex`1<T>> _stack;
    private int _index;
    public StronglyConnectedComponentList`1<T> DetectCycle(IEnumerable`1<Vertex`1<T>> graph);
    private void StrongConnect(Vertex`1<T> v);
}
internal class Nuke.Common.Utilities.StronglyConnectedComponentList`1 : object {
    private LinkedList`1<StronglyConnectedComponent`1<T>> _collection;
    public int Count { get; }
    public void Add(StronglyConnectedComponent`1<T> scc);
    public int get_Count();
    public sealed virtual IEnumerator`1<StronglyConnectedComponent`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<StronglyConnectedComponent`1<T>> IndependentComponents();
    public IEnumerable`1<StronglyConnectedComponent`1<T>> Cycles();
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.Utilities.TaskExtensions : object {
    [ExtensionAttribute]
public static void WaitAll(IEnumerable`1<Task> tasks);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> WaitAll(IEnumerable`1<Task`1<T>> tasks);
}
[ExtensionAttribute]
[PublicAPIAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerStepThroughAttribute]
public static class Nuke.Common.Utilities.UrlExtensions : object {
    [ExtensionAttribute]
public static Uri WithUtmValues(Uri uri, string medium, string source, string campaign, string content);
}
internal class Nuke.Common.Utilities.Vertex`1 : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LowLink>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Vertex`1<T>> <Dependencies>k__BackingField;
    internal int Index { get; internal set; }
    internal int LowLink { get; internal set; }
    public T Value { get; }
    public ICollection`1<Vertex`1<T>> Dependencies { get; }
    public Vertex`1(T value);
    public Vertex`1(IEnumerable`1<Vertex`1<T>> dependencies);
    public Vertex`1(T value, IEnumerable`1<Vertex`1<T>> dependencies);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
internal int get_LowLink();
    [CompilerGeneratedAttribute]
internal void set_LowLink(int value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public ICollection`1<Vertex`1<T>> get_Dependencies();
}
[ExtensionAttribute]
public static class Nuke.Common.Utilities.XElementExtensions : object {
    [ExtensionAttribute]
public static string GetAttributeValue(XElement element, string name);
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class Nuke.Common.Utilities.XmlExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static string ToXml(T obj, SaveOptions options);
    [ExtensionAttribute]
[PureAttribute]
public static T GetXml(string content, LoadOptions options);
    [ExtensionAttribute]
public static AbsolutePath WriteXml(AbsolutePath path, XDocument obj, SaveOptions options);
    [ExtensionAttribute]
public static AbsolutePath WriteXml(AbsolutePath path, T obj, SaveOptions options);
    [ExtensionAttribute]
[PureAttribute]
public static XDocument ReadXml(AbsolutePath path, LoadOptions options);
    [ExtensionAttribute]
[PureAttribute]
public static T ReadXml(AbsolutePath path, LoadOptions options);
    [ExtensionAttribute]
public static AbsolutePath UpdateXml(AbsolutePath path, Action`1<T> update, LoadOptions loadOptions, SaveOptions saveOptions);
    [ExtensionAttribute]
public static AbsolutePath UpdateXml(AbsolutePath path, Action`1<XDocument> update, LoadOptions loadOptions, SaveOptions saveOptions);
}
[ExtensionAttribute]
public static class Nuke.Common.Utilities.XNodeExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> XPathSelectElementValues(XNode node, string query, ValueTuple`2[] namespaces);
    [ExtensionAttribute]
public static IEnumerable`1<string> XPathSelectAttributeValues(XNode node, string query, ValueTuple`2[] namespaces);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> XPathSelectElements(XNode node, string query, ValueTuple`2[] namespaces);
    [ExtensionAttribute]
public static IEnumerable`1<XAttribute> XPathSelectAttributes(XNode node, string query, ValueTuple`2[] namespaces);
    [ExtensionAttribute]
private static IEnumerable`1<T> XPathSelect(XNode node, string query, ValueTuple`2[] namespaces);
}
[PublicAPIAttribute]
[AttributeUsageAttribute("1")]
public class System.Diagnostics.CodeAnalysis.ExcludeAssemblyFromCodeCoverageAttribute : Attribute {
}
[PublicAPIAttribute]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
