[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[PublicAPIAttribute]
public static class Nuke.CodeGeneration.CodeGenerator : object {
    public static string SpecificationFilePattern;
    public static void GenerateCodeFromDirectory(AbsolutePath specificationDirectory, Func`2<Tool, string> outputFileProvider, Func`2<Tool, string> namespaceProvider, Func`2<Tool, string> sourceFileProvider);
    public static void GenerateCode(AbsolutePath specificationFile, Func`2<Tool, string> outputFileProvider, Func`2<Tool, string> namespaceProvider, Func`2<Tool, string> sourceFileProvider);
    public static void GenerateCode(Tool tool, string outputFile);
    private static void ApplyRuntimeInformation(Tool tool, string specificationFile, Func`2<Tool, string> sourceFileProvider, Func`2<Tool, string> namespaceProvider);
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Generators.DataClassExtensionGenerator : object {
    public static void Run(DataClass dataClass, ToolWriter toolWriter);
    private static void WriteMethods(DataClassWriter writer, Property property);
    private static void WriteBooleanExtensions(DataClassWriter writer, Property property);
    private static void WriteListExtensions(DataClassWriter writer, Property property);
    private static void WriteDictionaryExtensions(DataClassWriter writer, Property property);
    private static void WriteDictionaryDelegateExtensions(DataClassWriter writer, Property property, Property delegateProperty);
    private static void WriteLookupExtensions(DataClassWriter writer, Property property);
    [ExtensionAttribute]
private static DataClassWriter WriteMethod(DataClassWriter writer, string name, Property property, string modification);
    [ExtensionAttribute]
private static DataClassWriter WriteMethod(DataClassWriter writer, string name, string additionalParameter, String[] modifications);
    [ExtensionAttribute]
private static DataClassWriter WriteMethod(DataClassWriter writer, string name, string modification);
    [ExtensionAttribute]
private static DataClassWriter WriteMethod(DataClassWriter writer, string name, String[] modifications);
    [ExtensionAttribute]
private static DataClassWriter WriteMethod(DataClassWriter writer, string name, IEnumerable`1<string> additionalParameters, String[] modifications);
    [CompilerGeneratedAttribute]
internal static string <WriteDictionaryDelegateExtensions>g__GetModification|5_0(string newValue, <>c__DisplayClass5_0& );
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Generators.DataClassGenerator : object {
    public static void Run(DataClass dataClass, ToolWriter toolWriter);
    private static void CheckMissingValue(Property property);
    private static void CheckMissingSecret(Property property);
    [ExtensionAttribute]
private static DataClassWriter WriteProcessToolPath(DataClassWriter writer);
    [ExtensionAttribute]
private static DataClassWriter WriteProcessLogger(DataClassWriter writer);
    [ExtensionAttribute]
private static DataClassWriter WriteProcessExitHandler(DataClassWriter writer);
    private static void WritePropertyDeclaration(DataClassWriter writer, Property property);
    private static string GetJsonSerializationAttribute(Property property);
    private static string GetJsonIgnoreAttribute(Property property);
    private static string GetPropertyInitialization(Property property);
    private static string GetPublicPropertyImplementation(Property property);
    private static string GetPublicPropertyType(Property property);
    [ExtensionAttribute]
private static DataClassWriter WriteConfigureArguments(DataClassWriter writer);
    private static string GetArgumentAddition(Property property);
}
public static class Nuke.CodeGeneration.Generators.EnumerationGenerator : object {
    public static void Run(Enumeration enumeration, ToolWriter toolWriter);
    [CompilerGeneratedAttribute]
internal static string <Run>g__GetIdentifier|0_0(string value);
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Generators.ModelExtensions : object {
    [ExtensionAttribute]
public static bool IsValueType(Property property);
    [ExtensionAttribute]
public static string GetNullableType(Property property);
    [ExtensionAttribute]
public static string GetCrefTag(Property property);
    [ExtensionAttribute]
public static string GetListValueType(Property property);
    [ExtensionAttribute]
public static ValueTuple`2<string, string> GetDictionaryKeyValueTypes(Property property);
    [ExtensionAttribute]
public static ValueTuple`2<string, string> GetLookupTableKeyValueTypes(Property property);
    [ExtensionAttribute]
public static string GetKeyComparer(Property property);
    private static String[] GetGenerics(Property property);
    [ExtensionAttribute]
public static bool IsList(Property property);
    [ExtensionAttribute]
public static bool IsDictionary(Property property);
    [ExtensionAttribute]
public static bool IsLookupTable(Property property);
    [ExtensionAttribute]
public static bool IsBoolean(Property property);
    [ExtensionAttribute]
public static bool IsString(Property property);
    [ExtensionAttribute]
public static bool HasCustomListType(Property property);
    [ExtensionAttribute]
public static string GetClassName(Tool tool);
    [ExtensionAttribute]
public static string GetTaskMethodName(Task task);
    [ExtensionAttribute]
public static string GetReturnType(Task task);
    [ExtensionAttribute]
public static bool HasReturnValue(Task task);
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Generators.StringExtensions : object {
    private static String[] s_reservedWords;
    private static StringExtensions();
    [ExtensionAttribute]
public static string ToInstance(string text);
    [ExtensionAttribute]
public static string EscapeParameter(string parameterName);
    [ExtensionAttribute]
public static string EscapeProperty(string propertyName);
    [ExtensionAttribute]
public static string Paragraph(string text);
    [ExtensionAttribute]
public static string Emphasize(string text);
    [ExtensionAttribute]
public static string ToSingular(string name);
    [ExtensionAttribute]
public static string ToPlural(string name);
    [ExtensionAttribute]
public static string DoubleQuote(string text);
    [ExtensionAttribute]
public static string DoubleQuoteInterpolated(string text);
    [ExtensionAttribute]
public static string SingleQuote(Nullable`1<char> text);
    [ExtensionAttribute]
public static string ToSeeCref(string reference);
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Generators.TaskGenerator : object {
    public static void Run(Tool tool, ToolWriter toolWriter);
    [ExtensionAttribute]
private static void WriteGenericTask(ToolWriter writer);
    [ExtensionAttribute]
private static TaskWriter WriteToolSettingsTask(TaskWriter writer);
    [ExtensionAttribute]
private static TaskWriter WriteConfiguratorTask(TaskWriter writer);
    [ExtensionAttribute]
private static TaskWriter WriteCombinatorialConfiguratorTask(TaskWriter writer);
    private static string GetProcessStart(Task task);
    private static string GetProcessAssertion(Task task);
    [ExtensionAttribute]
private static ToolWriter WriteToolPath(ToolWriter writer);
    [ExtensionAttribute]
private static ToolWriter WriteToolLogger(ToolWriter writer);
    [ExtensionAttribute]
private static ToolWriter WriteToolExitHandler(ToolWriter writer);
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Generators.ToolGenerator : object {
    public static void Run(Tool tool, StreamWriter streamWriter);
    [ExtensionAttribute]
private static ToolWriter WriteAll(ToolWriter w);
    [ExtensionAttribute]
private static ToolWriter WriteAlias(ToolWriter writer);
    [ExtensionAttribute]
private static ToolWriter WriteDataClasses(ToolWriter writer);
    [ExtensionAttribute]
private static ToolWriter WriteEnumerations(ToolWriter writer);
    private static IEnumerable`1<string> GetNamespaceImports(Tool tool);
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Generators.WriterExtensions : object {
    [ExtensionAttribute]
public static T WriteObsoleteAttributeWhenObsolete(T writerWrapper, IDeprecatable deprecatable);
    [ExtensionAttribute]
public static T WriteSummary(T writerWrapper, Tool tool);
    [ExtensionAttribute]
public static T WriteSummary(T writerWrapper, Task task);
    [ExtensionAttribute]
public static T WriteRemarks(T writerWrapper, Task task);
    [IteratorStateMachineAttribute("Nuke.CodeGeneration.Generators.WriterExtensions/<GetArgumentsList>d__4")]
private static IEnumerable`1<string> GetArgumentsList(SettingsClass settingsClass);
    [ExtensionAttribute]
public static T WriteSummary(T writerWrapper, Property property);
    [ExtensionAttribute]
public static T WriteSummary(T writerWrapper, DataClass dataClass);
    [ExtensionAttribute]
public static T WriteSummary(T writerWrapper, Enumeration enumeration);
    [ExtensionAttribute]
public static T WriteSummaryExtension(T writerWrapper, string actionText, Property property, Property alternativeProperty);
    private static string GetUsedWithinText(Tool tool);
    private static string GetOfficialUrlText(string url);
    [ExtensionAttribute]
public static T WriteSummary(T writerWrapper, String[] lines);
    [CompilerGeneratedAttribute]
internal static string <GetArgumentsList>g__GetArgument|4_1(Property property);
}
[UsedImplicitlyAttribute("2", "3")]
public class Nuke.CodeGeneration.Model.DataClass : object {
    [CompilerGeneratedAttribute]
private Tool <Tool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseClass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtensionMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitDataClass>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Property> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeprecationMessage>k__BackingField;
    [JsonIgnoreAttribute]
public Tool Tool { get; public set; }
    [JsonIgnoreAttribute]
public bool IsToolSettingsClass { get; }
    [NotNullAttribute]
[JsonIgnoreAttribute]
public IDeprecatable Parent { get; }
    [JsonPropertyAttribute]
[RegularExpressionAttribute("^[0-9A-Z][A-Za-z0-9]*$")]
[DescriptionAttribute("Name of the data class.")]
public string Name { get; public set; }
    [DescriptionAttribute("The base class to inherit from.")]
public string BaseClass { get; public set; }
    [DescriptionAttribute("Enables generation of extension methods for modification.")]
public bool ExtensionMethods { get; public set; }
    [DescriptionAttribute("Omits generation of the data class.")]
public bool OmitDataClass { get; public set; }
    [DescriptionAttribute("Properties of the data class.")]
public List`1<Property> Properties { get; public set; }
    [DescriptionAttribute("Obsolete message. DataClass is marked as obsolete when specified.")]
public string DeprecationMessage { get; public set; }
    [CompilerGeneratedAttribute]
public Tool get_Tool();
    [CompilerGeneratedAttribute]
public void set_Tool(Tool value);
    public virtual bool get_IsToolSettingsClass();
    public virtual IDeprecatable get_Parent();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_BaseClass();
    [CompilerGeneratedAttribute]
public void set_BaseClass(string value);
    [CompilerGeneratedAttribute]
public bool get_ExtensionMethods();
    [CompilerGeneratedAttribute]
public void set_ExtensionMethods(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitDataClass();
    [CompilerGeneratedAttribute]
public void set_OmitDataClass(bool value);
    [CompilerGeneratedAttribute]
public List`1<Property> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(List`1<Property> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationMessage();
    [CompilerGeneratedAttribute]
public void set_DeprecationMessage(string value);
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Model.DeprecatableExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsDeprecated(IDeprecatable deprecatable);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static string GetDeprecationMessage(IDeprecatable deprecatable);
}
[UsedImplicitlyAttribute("2", "3")]
public class Nuke.CodeGeneration.Model.Enumeration : object {
    [CompilerGeneratedAttribute]
private Tool <Tool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeprecationMessage>k__BackingField;
    [JsonIgnoreAttribute]
public Tool Tool { get; public set; }
    [NotNullAttribute]
[JsonIgnoreAttribute]
public IDeprecatable Parent { get; }
    [JsonPropertyAttribute]
[RegularExpressionAttribute("^[0-9A-Z][A-Za-z0-9]*$")]
[DescriptionAttribute("Name of the enumeration.")]
public string Name { get; public set; }
    [JsonPropertyAttribute]
[DescriptionAttribute("The enumeration values.")]
public List`1<string> Values { get; public set; }
    [DescriptionAttribute("Obsolete message. Enumeration is marked as obsolete when specified.")]
public string DeprecationMessage { get; public set; }
    [CompilerGeneratedAttribute]
public Tool get_Tool();
    [CompilerGeneratedAttribute]
public void set_Tool(Tool value);
    public sealed virtual IDeprecatable get_Parent();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Values();
    [CompilerGeneratedAttribute]
public void set_Values(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationMessage();
    [CompilerGeneratedAttribute]
public void set_DeprecationMessage(string value);
}
public interface Nuke.CodeGeneration.Model.IDeprecatable {
    [CanBeNullAttribute]
public string DeprecationMessage { get; }
    [CanBeNullAttribute]
public IDeprecatable Parent { get; }
    public abstract virtual string get_DeprecationMessage();
    public abstract virtual IDeprecatable get_Parent();
}
[UsedImplicitlyAttribute("2", "3")]
public class Nuke.CodeGeneration.Model.Property : object {
    private DataClass _dataClass;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Json>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CustomImpl>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <DisallowedCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QuoteMultiple>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Secret>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CustomValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateOverload>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Property> <Delegates>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeprecationMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyDelegates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTailArgument>k__BackingField;
    [JsonIgnoreAttribute]
public DataClass DataClass { get; public set; }
    [JsonIgnoreAttribute]
[NotNullAttribute]
public IDeprecatable Parent { get; }
    [JsonPropertyAttribute]
[RegularExpressionAttribute("^[0-9A-Z][A-Za-z0-9]*$")]
[DescriptionAttribute("Name of the property.")]
public string Name { get; public set; }
    [JsonPropertyAttribute]
[DescriptionAttribute("Type of the property. I.e., bool, int, string, List<int>, Dictionary<string, object>, Lookup<string, int.>")]
public string Type { get; public set; }
    [DescriptionAttribute("Name used when serializing to JSON.")]
public string Json { get; public set; }
    [DescriptionAttribute("Argument formatting for the property. '{value}' is replaced by the value of the property.")]
public string Format { get; public set; }
    [DescriptionAttribute("Item formatting for dictionaries. '{key}' and '{value}' are replaced accordingly.")]
public string ItemFormat { get; public set; }
    [DescriptionAttribute("Omits argument parsing.")]
public bool NoArgument { get; public set; }
    [DescriptionAttribute("Custom implementation of the property.")]
public bool CustomImpl { get; public set; }
    [DescriptionAttribute("Separator used for items of collection types.")]
public Nullable`1<char> Separator { get; public set; }
    [DescriptionAttribute("Character that must be double-quoted.")]
public Nullable`1<char> DisallowedCharacter { get; public set; }
    [DescriptionAttribute("Specifies if list items should be double quoted.")]
public bool QuoteMultiple { get; public set; }
    [DescriptionAttribute("Default value that will be used if no value is given.")]
public string Default { get; public set; }
    [DescriptionAttribute("Specifies that the value is secret and should be hidden in output.")]
public Nullable`1<bool> Secret { get; public set; }
    [DescriptionAttribute("Custom implementation of value presentation.")]
public bool CustomValue { get; public set; }
    [DescriptionAttribute("Specifies that an overload for the property should be created.")]
public bool CreateOverload { get; public set; }
    [DescriptionAttribute("Help text for the property.")]
public string Help { get; public set; }
    [DescriptionAttribute("Dictionary delegates for named properties.")]
public List`1<Property> Delegates { get; public set; }
    [DescriptionAttribute("Obsolete message. Property is marked as obsolete when specified.")]
public string DeprecationMessage { get; public set; }
    public bool OnlyDelegates { get; public set; }
    public bool IsTailArgument { get; public set; }
    public DataClass get_DataClass();
    public void set_DataClass(DataClass value);
    public sealed virtual IDeprecatable get_Parent();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Json();
    [CompilerGeneratedAttribute]
public void set_Json(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public string get_ItemFormat();
    [CompilerGeneratedAttribute]
public void set_ItemFormat(string value);
    [CompilerGeneratedAttribute]
public bool get_NoArgument();
    [CompilerGeneratedAttribute]
public void set_NoArgument(bool value);
    [CompilerGeneratedAttribute]
public bool get_CustomImpl();
    [CompilerGeneratedAttribute]
public void set_CustomImpl(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_DisallowedCharacter();
    [CompilerGeneratedAttribute]
public void set_DisallowedCharacter(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public bool get_QuoteMultiple();
    [CompilerGeneratedAttribute]
public void set_QuoteMultiple(bool value);
    [CompilerGeneratedAttribute]
public string get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Secret();
    [CompilerGeneratedAttribute]
public void set_Secret(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_CustomValue();
    [CompilerGeneratedAttribute]
public void set_CustomValue(bool value);
    [CompilerGeneratedAttribute]
public bool get_CreateOverload();
    [CompilerGeneratedAttribute]
public void set_CreateOverload(bool value);
    [CompilerGeneratedAttribute]
public string get_Help();
    [CompilerGeneratedAttribute]
public void set_Help(string value);
    [CompilerGeneratedAttribute]
public List`1<Property> get_Delegates();
    [CompilerGeneratedAttribute]
public void set_Delegates(List`1<Property> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationMessage();
    [CompilerGeneratedAttribute]
public void set_DeprecationMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_OnlyDelegates();
    [CompilerGeneratedAttribute]
public void set_OnlyDelegates(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsTailArgument();
    [CompilerGeneratedAttribute]
public void set_IsTailArgument(bool value);
}
internal static class Nuke.CodeGeneration.Model.RegexPatterns : object {
    public static string Name;
}
[UsedImplicitlyAttribute]
public class Nuke.CodeGeneration.Model.SettingsClass : DataClass {
    [CompilerGeneratedAttribute]
private Task <Task>k__BackingField;
    public bool IsToolSettingsClass { get; }
    [JsonIgnoreAttribute]
public Task Task { get; public set; }
    [NotNullAttribute]
[JsonIgnoreAttribute]
public IDeprecatable Parent { get; }
    [JsonPropertyAttribute]
public string Name { get; }
    public virtual bool get_IsToolSettingsClass();
    [CompilerGeneratedAttribute]
public Task get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(Task value);
    public virtual IDeprecatable get_Parent();
    public virtual string get_Name();
}
[UsedImplicitlyAttribute("2", "3")]
public class Nuke.CodeGeneration.Model.Task : object {
    [CompilerGeneratedAttribute]
private Tool <Tool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Postfix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitCommonProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <CommonPropertySets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PostProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogLevelParsing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CustomStart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CustomAssertion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefiniteArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfficialUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsClass <SettingsClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeprecationMessage>k__BackingField;
    [JsonIgnoreAttribute]
public Tool Tool { get; public set; }
    [NotNullAttribute]
[JsonIgnoreAttribute]
public IDeprecatable Parent { get; }
    [CanBeNullAttribute]
[DescriptionAttribute("Help or introduction text to for the tool. Supports 'a-href', 'c', 'em', 'b', 'ul', 'li' and 'para' tags for better formatting.")]
public string Help { get; public set; }
    [CanBeNullAttribute]
[DescriptionAttribute("Postfix for the task alias.")]
[RegularExpressionAttribute("^[0-9A-Z][A-Za-z0-9]*$")]
public string Postfix { get; public set; }
    [CanBeNullAttribute]
[DescriptionAttribute("Return type of the task.")]
public string ReturnType { get; public set; }
    [DescriptionAttribute("Skips appending of common task properties.")]
public bool OmitCommonProperties { get; public set; }
    [DescriptionAttribute("Appends the properties of the named property sets.")]
public List`1<string> CommonPropertySets { get; public set; }
    [DescriptionAttribute("Generates a pre-process hook")]
public bool PreProcess { get; public set; }
    [DescriptionAttribute("Generates a post-process hook")]
public bool PostProcess { get; public set; }
    [DescriptionAttribute("Enables log level parsing")]
public bool LogLevelParsing { get; public set; }
    [DescriptionAttribute("Custom start implementation.")]
public bool CustomStart { get; public set; }
    [DescriptionAttribute("Custom process assertion implementation.")]
public bool CustomAssertion { get; public set; }
    [DescriptionAttribute("Argument that will always be printed independently of any set property.")]
public string DefiniteArgument { get; public set; }
    [CanBeNullAttribute]
[DescriptionAttribute("Url of the task. If not specified, the tool url will be used.")]
public string OfficialUrl { get; public set; }
    [DescriptionAttribute("The settings of the task.")]
public SettingsClass SettingsClass { get; public set; }
    [DescriptionAttribute("Obsolete message. Task is marked as obsolete when specified.")]
public string DeprecationMessage { get; public set; }
    [CompilerGeneratedAttribute]
public Tool get_Tool();
    [CompilerGeneratedAttribute]
public void set_Tool(Tool value);
    public sealed virtual IDeprecatable get_Parent();
    [CompilerGeneratedAttribute]
public string get_Help();
    [CompilerGeneratedAttribute]
public void set_Help(string value);
    [CompilerGeneratedAttribute]
public string get_Postfix();
    [CompilerGeneratedAttribute]
public void set_Postfix(string value);
    [CompilerGeneratedAttribute]
public string get_ReturnType();
    [CompilerGeneratedAttribute]
public void set_ReturnType(string value);
    [CompilerGeneratedAttribute]
public bool get_OmitCommonProperties();
    [CompilerGeneratedAttribute]
public void set_OmitCommonProperties(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_CommonPropertySets();
    [CompilerGeneratedAttribute]
public void set_CommonPropertySets(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_PreProcess();
    [CompilerGeneratedAttribute]
public void set_PreProcess(bool value);
    [CompilerGeneratedAttribute]
public bool get_PostProcess();
    [CompilerGeneratedAttribute]
public void set_PostProcess(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogLevelParsing();
    [CompilerGeneratedAttribute]
public void set_LogLevelParsing(bool value);
    [CompilerGeneratedAttribute]
public bool get_CustomStart();
    [CompilerGeneratedAttribute]
public void set_CustomStart(bool value);
    [CompilerGeneratedAttribute]
public bool get_CustomAssertion();
    [CompilerGeneratedAttribute]
public void set_CustomAssertion(bool value);
    [CompilerGeneratedAttribute]
public string get_DefiniteArgument();
    [CompilerGeneratedAttribute]
public void set_DefiniteArgument(string value);
    [CompilerGeneratedAttribute]
public string get_OfficialUrl();
    [CompilerGeneratedAttribute]
public void set_OfficialUrl(string value);
    [CompilerGeneratedAttribute]
public SettingsClass get_SettingsClass();
    [CompilerGeneratedAttribute]
public void set_SettingsClass(SettingsClass value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationMessage();
    [CompilerGeneratedAttribute]
public void set_DeprecationMessage(string value);
}
[UsedImplicitlyAttribute("2", "3")]
[DebuggerDisplayAttribute("{SpecificationFile}")]
public class Nuke.CodeGeneration.Model.Tool : object {
    [CompilerGeneratedAttribute]
private string <SpecificationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfficialUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeprecationMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuGetPackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NpmPackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AptGetPackageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageExecutable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PathExecutable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CustomExecutable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CustomLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CustomExitHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Task> <Tasks>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Property> <CommonTaskProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<Property>> <CommonTaskPropertySets>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DataClass> <DataClasses>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Enumeration> <Enumerations>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Metadata>k__BackingField;
    [JsonPropertyAttribute("$schema")]
public string Schema { get; }
    [JsonIgnoreAttribute]
public string SpecificationFile { get; public set; }
    [JsonIgnoreAttribute]
public string DefaultOutputFile { get; }
    [JsonIgnoreAttribute]
public string DefaultOutputFileName { get; }
    [JsonIgnoreAttribute]
public string SourceFile { get; public set; }
    [JsonIgnoreAttribute]
public string Namespace { get; public set; }
    [CanBeNullAttribute]
[JsonIgnoreAttribute]
public IDeprecatable Parent { get; }
    [DescriptionAttribute("Contains all references on which this definition is based on. Allows checking for updates.")]
public List`1<string> References { get; public set; }
    public List`1<string> Imports { get; public set; }
    [JsonPropertyAttribute]
[RegularExpressionAttribute("^[0-9A-Z][A-Za-z0-9]*$")]
[DescriptionAttribute("Name of the Tool.")]
public string Name { get; public set; }
    [UrlAttribute]
[JsonPropertyAttribute]
[DescriptionAttribute("Url to the official website.")]
public string OfficialUrl { get; public set; }
    [DescriptionAttribute("Obsolete message. Tool is marked as obsolete when specified.")]
public string DeprecationMessage { get; public set; }
    [DescriptionAttribute("Help or introduction text to for the tool. Supports 'a-href', 'c', 'em', 'b', 'ul', 'li' and 'para' tags for better formatting.")]
public string Help { get; public set; }
    [JsonPropertyAttribute]
[DescriptionAttribute("ID for the NuGet package.")]
public string NuGetPackageId { get; public set; }
    [DescriptionAttribute("ID for the NPM package.")]
public string NpmPackageId { get; public set; }
    [JsonPropertyAttribute]
[DescriptionAttribute("ID for the AptGet package.")]
public string AptGetPackageId { get; public set; }
    [DescriptionAttribute("Exact name of the main executable found in the './tools' folder. Case-sensitive.")]
public string PackageExecutable { get; public set; }
    [DescriptionAttribute("Exact name of the executable that can be found via 'where' or 'which'.")]
public string PathExecutable { get; public set; }
    [DescriptionAttribute("Defines that locating the executable is implemented customly.")]
public bool CustomExecutable { get; public set; }
    [DescriptionAttribute("Enables custom logger.")]
public bool CustomLogger { get; public set; }
    [DescriptionAttribute("Enables custom exit handler.")]
public bool CustomExitHandler { get; public set; }
    [DescriptionAttribute("Help or introduction text to for the tool. Can contain HTML tags for better formatting.")]
public List`1<Task> Tasks { get; public set; }
    [DescriptionAttribute("Common properties for all tasks.")]
public List`1<Property> CommonTaskProperties { get; public set; }
    [DescriptionAttribute("Named common property sets which can be used by tasks.")]
public Dictionary`2<string, List`1<Property>> CommonTaskPropertySets { get; public set; }
    [DescriptionAttribute("Common used data classes.")]
public List`1<DataClass> DataClasses { get; public set; }
    [DescriptionAttribute("Used enumerations.")]
public List`1<Enumeration> Enumerations { get; public set; }
    [CanBeNullAttribute]
[DescriptionAttribute("Can be used to store additional information about the tool.")]
[JsonPropertyAttribute("_metadata")]
public Dictionary`2<string, object> Metadata { get; public set; }
    public string get_Schema();
    [CompilerGeneratedAttribute]
public string get_SpecificationFile();
    [CompilerGeneratedAttribute]
public void set_SpecificationFile(string value);
    public string get_DefaultOutputFile();
    public string get_DefaultOutputFileName();
    [CompilerGeneratedAttribute]
public string get_SourceFile();
    [CompilerGeneratedAttribute]
public void set_SourceFile(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    public sealed virtual IDeprecatable get_Parent();
    [CompilerGeneratedAttribute]
public List`1<string> get_References();
    [CompilerGeneratedAttribute]
public void set_References(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Imports();
    [CompilerGeneratedAttribute]
public void set_Imports(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_OfficialUrl();
    [CompilerGeneratedAttribute]
public void set_OfficialUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeprecationMessage();
    [CompilerGeneratedAttribute]
public void set_DeprecationMessage(string value);
    [CompilerGeneratedAttribute]
public string get_Help();
    [CompilerGeneratedAttribute]
public void set_Help(string value);
    [CompilerGeneratedAttribute]
public string get_NuGetPackageId();
    [CompilerGeneratedAttribute]
public void set_NuGetPackageId(string value);
    [CompilerGeneratedAttribute]
public string get_NpmPackageId();
    [CompilerGeneratedAttribute]
public void set_NpmPackageId(string value);
    [CompilerGeneratedAttribute]
public string get_AptGetPackageId();
    [CompilerGeneratedAttribute]
public void set_AptGetPackageId(string value);
    [CompilerGeneratedAttribute]
public string get_PackageExecutable();
    [CompilerGeneratedAttribute]
public void set_PackageExecutable(string value);
    [CompilerGeneratedAttribute]
public string get_PathExecutable();
    [CompilerGeneratedAttribute]
public void set_PathExecutable(string value);
    [CompilerGeneratedAttribute]
public bool get_CustomExecutable();
    [CompilerGeneratedAttribute]
public void set_CustomExecutable(bool value);
    [CompilerGeneratedAttribute]
public bool get_CustomLogger();
    [CompilerGeneratedAttribute]
public void set_CustomLogger(bool value);
    [CompilerGeneratedAttribute]
public bool get_CustomExitHandler();
    [CompilerGeneratedAttribute]
public void set_CustomExitHandler(bool value);
    [CompilerGeneratedAttribute]
public List`1<Task> get_Tasks();
    [CompilerGeneratedAttribute]
public void set_Tasks(List`1<Task> value);
    [CompilerGeneratedAttribute]
public List`1<Property> get_CommonTaskProperties();
    [CompilerGeneratedAttribute]
public void set_CommonTaskProperties(List`1<Property> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<Property>> get_CommonTaskPropertySets();
    [CompilerGeneratedAttribute]
public void set_CommonTaskPropertySets(Dictionary`2<string, List`1<Property>> value);
    [CompilerGeneratedAttribute]
public List`1<DataClass> get_DataClasses();
    [CompilerGeneratedAttribute]
public void set_DataClasses(List`1<DataClass> value);
    [CompilerGeneratedAttribute]
public List`1<Enumeration> get_Enumerations();
    [CompilerGeneratedAttribute]
public void set_Enumerations(List`1<Enumeration> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(Dictionary`2<string, object> value);
}
[PublicAPIAttribute]
public static class Nuke.CodeGeneration.ReferenceUpdater : object {
    private static HttpClient s_client;
    private static ReferenceUpdater();
    public static void UpdateReferences(string specificationsDirectory, string referencesDirectory);
    public static void UpdateReferences(IEnumerable`1<string> specificationFiles, string referencesDirectory);
    [AsyncStateMachineAttribute("Nuke.CodeGeneration.ReferenceUpdater/<Update>d__3")]
private static Task Update(string reference, Tool tool, string referencesDirectory);
    [AsyncStateMachineAttribute("Nuke.CodeGeneration.ReferenceUpdater/<GetReferenceContent>d__4")]
private static Task`1<string> GetReferenceContent(string reference);
}
public static class Nuke.CodeGeneration.ToolSerializer : object {
    public static Tool Load(string file);
    public static void Save(Tool tool, AbsolutePath file);
}
public class Nuke.CodeGeneration.Writers.DataClassWriter : object {
    [CompilerGeneratedAttribute]
private DataClass <DataClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IWriter <Writer>k__BackingField;
    public DataClass DataClass { get; }
    public IWriter Writer { get; }
    public DataClassWriter(DataClass dataClass, ToolWriter writer);
    [CompilerGeneratedAttribute]
public DataClass get_DataClass();
    [CompilerGeneratedAttribute]
public sealed virtual IWriter get_Writer();
}
public interface Nuke.CodeGeneration.Writers.IWriter {
    public abstract virtual void WriteLine(string text);
    public abstract virtual void WriteBlock(Action action);
}
public interface Nuke.CodeGeneration.Writers.IWriterWrapper {
    public IWriter Writer { get; }
    public abstract virtual IWriter get_Writer();
}
public class Nuke.CodeGeneration.Writers.TaskWriter : object {
    [CompilerGeneratedAttribute]
private Task <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private IWriter <Writer>k__BackingField;
    public Task Task { get; }
    public IWriter Writer { get; }
    public TaskWriter(Task task, ToolWriter toolWriter);
    [CompilerGeneratedAttribute]
public Task get_Task();
    [CompilerGeneratedAttribute]
public sealed virtual IWriter get_Writer();
}
public class Nuke.CodeGeneration.Writers.ToolWriter : object {
    private StreamWriter _streamWriter;
    private int _indention;
    [CompilerGeneratedAttribute]
private Tool <Tool>k__BackingField;
    public Tool Tool { get; }
    public IWriter Writer { get; }
    public ToolWriter(Tool tool, StreamWriter streamWriter);
    [CompilerGeneratedAttribute]
public Tool get_Tool();
    public sealed virtual IWriter get_Writer();
    public sealed virtual void Dispose();
    private sealed virtual override void Nuke.CodeGeneration.Writers.IWriter.WriteLine(string text);
    private sealed virtual override void Nuke.CodeGeneration.Writers.IWriter.WriteBlock(Action action);
}
[ExtensionAttribute]
public static class Nuke.CodeGeneration.Writers.WriterExtensions : object {
    [ExtensionAttribute]
public static TWrapper ForEach(TWrapper writerWrapper, IEnumerable`1<TItem> enumerable, Action`2<TWrapper, TItem> action);
    [ExtensionAttribute]
public static TWrapper ForEach(TWrapper writerWrapper, IEnumerable`1<TItem> enumerable, Action`1<TItem> action);
    [ExtensionAttribute]
public static TWrapper ForEach(TWrapper writerWrapper, IEnumerable`1<TItem> enumerable, Action`2<TItem, bool> action);
    [ExtensionAttribute]
public static T WriteLine(T writerWrapper, string text);
    [ExtensionAttribute]
public static T ForEachWriteLine(T writerWrapper, IEnumerable`1<string> texts);
    [ExtensionAttribute]
public static T WriteLineIfTrue(T writerWrapper, bool condition, string text);
    [ExtensionAttribute]
public static T WriteBlock(T writerWrapper, Action`1<T> action);
    [ExtensionAttribute]
public static T When(T writerWrapper, bool condition, Action`1<T> action);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
