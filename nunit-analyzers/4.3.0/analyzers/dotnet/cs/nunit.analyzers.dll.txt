[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NUnit.Analyzers.BaseAssertionAnalyzer : DiagnosticAnalyzer {
    public virtual void Initialize(AnalysisContext context);
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    protected virtual void AnalyzeAssertInvocation(Version nunitVersion, OperationAnalysisContext context, IInvocationOperation assertOperation);
    protected virtual bool IsAssert(bool hasClassicAssert, IInvocationOperation invocationOperation);
    private void AnalyzeInvocation(Version nunitVersion, OperationAnalysisContext context);
    private void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
}
public abstract class NUnit.Analyzers.ClassicAssertionAnalyzer : BaseAssertionAnalyzer {
    [NullableContextAttribute("1")]
protected virtual bool IsAssert(bool hasClassicAssert, IInvocationOperation invocationOperation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.AreEqualClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.AreNotEqualClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.AreNotSameClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.AreSameClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ClassicModelAssertUsage.ClassicModelAssertUsageAnalyzer : ClassicAssertionAnalyzer {
    private static DiagnosticDescriptor isTrueDescriptor;
    private static DiagnosticDescriptor trueDescriptor;
    private static DiagnosticDescriptor isFalseDescriptor;
    private static DiagnosticDescriptor falseDescriptor;
    private static DiagnosticDescriptor areEqualDescriptor;
    private static DiagnosticDescriptor areNotEqualDescriptor;
    private static DiagnosticDescriptor areSameDescriptor;
    private static DiagnosticDescriptor isNullDescriptor;
    private static DiagnosticDescriptor nullDescriptor;
    private static DiagnosticDescriptor isNotNullDescriptor;
    private static DiagnosticDescriptor notNullDescriptor;
    private static DiagnosticDescriptor greaterDescriptor;
    private static DiagnosticDescriptor greaterOrEqualDescriptor;
    private static DiagnosticDescriptor lessDescriptor;
    private static DiagnosticDescriptor lessOrEqualDescriptor;
    private static DiagnosticDescriptor areNotSameDescriptor;
    private static DiagnosticDescriptor zeroDescriptor;
    private static DiagnosticDescriptor notZeroDescriptor;
    private static DiagnosticDescriptor isNaNDescriptor;
    private static DiagnosticDescriptor isEmptyDescriptor;
    private static DiagnosticDescriptor isNotEmptyDescriptor;
    private static DiagnosticDescriptor containsDescriptor;
    private static DiagnosticDescriptor isInstanceOfDescriptor;
    private static DiagnosticDescriptor isNotInstanceOfDescriptor;
    private static ImmutableDictionary`2<string, DiagnosticDescriptor> NameToDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ClassicModelAssertUsageAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NUnit.Analyzers.ClassicModelAssertUsage.ClassicModelAssertUsageCodeFix : CodeFixProvider {
    internal static string TransformToConstraintModelDescription;
    [CompilerGeneratedAttribute]
private int <MinimumNumberOfParameters>k__BackingField;
    protected int MinimumNumberOfParameters { get; }
    protected string Title { get; }
    [CompilerGeneratedAttribute]
protected virtual int get_MinimumNumberOfParameters();
    protected virtual string get_Title();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.ClassicModelAssertUsage.ClassicModelAssertUsageCodeFix/<RegisterCodeFixesAsync>d__7")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments, TypeArgumentListSyntax typeArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ClassicModelAssertUsage.ClassicModelUsageAnalyzerConstants : object {
    internal static string IsTrueTitle;
    internal static string IsTrueMessage;
    internal static string IsTrueDescription;
    internal static string TrueTitle;
    internal static string TrueMessage;
    internal static string TrueDescription;
    internal static string IsFalseTitle;
    internal static string IsFalseMessage;
    internal static string IsFalseDescription;
    internal static string FalseTitle;
    internal static string FalseMessage;
    internal static string FalseDescription;
    internal static string AreEqualTitle;
    internal static string AreEqualMessage;
    internal static string AreEqualDescription;
    internal static string AreNotEqualTitle;
    internal static string AreNotEqualMessage;
    internal static string AreNotEqualDescription;
    internal static string AreSameTitle;
    internal static string AreSameMessage;
    internal static string AreSameDescription;
    internal static string IsNullTitle;
    internal static string IsNullMessage;
    internal static string IsNullDescription;
    internal static string NullTitle;
    internal static string NullMessage;
    internal static string NullDescription;
    internal static string IsNotNullTitle;
    internal static string IsNotNullMessage;
    internal static string IsNotNullDescription;
    internal static string NotNullTitle;
    internal static string NotNullMessage;
    internal static string NotNullDescription;
    internal static string GreaterTitle;
    internal static string GreaterMessage;
    internal static string GreaterDescription;
    internal static string GreaterOrEqualTitle;
    internal static string GreaterOrEqualMessage;
    internal static string GreaterOrEqualDescription;
    internal static string LessTitle;
    internal static string LessMessage;
    internal static string LessDescription;
    internal static string LessOrEqualTitle;
    internal static string LessOrEqualMessage;
    internal static string LessOrEqualDescription;
    internal static string AreNotSameTitle;
    internal static string AreNotSameMessage;
    internal static string AreNotSameDescription;
    internal static string ZeroTitle;
    internal static string ZeroMessage;
    internal static string ZeroDescription;
    internal static string NotZeroTitle;
    internal static string NotZeroMessage;
    internal static string NotZeroDescription;
    internal static string IsNaNTitle;
    internal static string IsNaNMessage;
    internal static string IsNaNDescription;
    internal static string IsEmptyTitle;
    internal static string IsEmptyMessage;
    internal static string IsEmptyDescription;
    internal static string IsNotEmptyTitle;
    internal static string IsNotEmptyMessage;
    internal static string IsNotEmptyDescription;
    internal static string ContainsTitle;
    internal static string ContainsMessage;
    internal static string ContainsDescription;
    internal static string IsInstanceOfTitle;
    internal static string IsInstanceOfMessage;
    internal static string IsInstanceOfDescription;
    internal static string IsNotInstanceOfTitle;
    internal static string IsNotInstanceOfMessage;
    internal static string IsNotInstanceOfDescription;
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.ContainsClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.GreaterClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.GreaterOrEqualClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsEmptyClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsFalseAndFalseClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsInstanceOfClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments, TypeArgumentListSyntax typeArguments);
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsNaNClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsNotEmptyClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsNotInstanceOfClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments, TypeArgumentListSyntax typeArguments);
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsNotNullAndNotNullClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsNullAndNullClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsTrueAndTrueClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.IsTrueAndTrueClassicModelAssertUsageCondensedCodeFix : ClassicModelAssertUsageCodeFix {
    public static string Suffix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumNumberOfParameters>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected int MinimumNumberOfParameters { get; }
    protected string Title { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual int get_MinimumNumberOfParameters();
    protected virtual string get_Title();
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.LessClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.LessOrEqualClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.NotZeroClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ClassicModelAssertUsage.ZeroClassicModelAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.CollectionAssertUsage.CollectionAssertUsageAnalyzer : BaseAssertionAnalyzer {
    internal static ImmutableDictionary`2<string, string> OneCollectionParameterAsserts;
    internal static ImmutableDictionary`2<string, string> TwoCollectionParameterAsserts;
    internal static ImmutableDictionary`2<string, string> CollectionAndItemParameterAsserts;
    private static DiagnosticDescriptor collectionAssertDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CollectionAssertUsageAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool IsAssert(bool hasClassicAssert, IInvocationOperation invocationOperation);
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class NUnit.Analyzers.CollectionAssertUsage.CollectionAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    internal static ImmutableDictionary`2<string, Constraints> CollectionAssertToParameterlessConstraints;
    internal static ImmutableDictionary`2<string, Constraints> CollectionAssertToOneSwappedParameterConstraints;
    internal static ImmutableDictionary`2<string, Constraints> CollectionAssertToOneUnswappedParameterConstraints;
    internal static ImmutableDictionary`2<string, string> CollectionAssertToFirstParameterName;
    internal static ImmutableDictionary`2<string, string> CollectionAssertToSecondParameterName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CollectionAssertUsageCodeFix();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
    private static ValueTuple`2<ArgumentSyntax, ArgumentSyntax> GetActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NUnit.Analyzers.CollectionAssertUsage.CollectionAssertUsageConstants : object {
    internal static string CollectionAssertTitle;
    internal static string CollectionAssertMessage;
    internal static string CollectionAssertDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ComparableTypes.ComparableOnObjectConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ComparableTypes.ComparableTypesAnalyzer : BaseAssertionAnalyzer {
    private static ImmutableHashSet`1<string> SupportedConstraints;
    private static DiagnosticDescriptor comparableTypesDescriptor;
    private static DiagnosticDescriptor comparableOnObjectDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ComparableTypesAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static bool CanCompare(ITypeSymbol actualType, ITypeSymbol expectedType, Compilation compilation);
    private static bool IsIComparable(ITypeSymbol typeSymbol, ITypeSymbol comparableTypeArguments);
    private static bool IsIComparable(ITypeSymbol typeSymbol);
    private static bool HasCustomComparer(ConstraintExpressionPart constraintPartExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ComparableTypes.ComparableTypesConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ConstActualValueUsage.ConstActualValueUsageAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ConstActualValueUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool IsAssert(bool hasClassicAssert, IInvocationOperation invocationOperation);
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static IOperation GetExpectedOperation(IInvocationOperation assertOperation);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeAssertInvocation>g__IsStringEmpty|4_0(IOperation operation);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeAssertInvocation>g__Report|4_1(IOperation operation, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ConstActualValueUsage.ConstActualValueUsageAnalyzerConstants : object {
    public static string Title;
    public static string Message;
    public static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ConstActualValueUsage.ConstActualValueUsageCodeFix : CodeFixProvider {
    internal static string SwapArgumentsDescription;
    private static String[] SupportedClassicAsserts;
    private static String[] SupportedStringAsserts;
    private static String[] SupportedIsConstraints;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static ConstActualValueUsageCodeFix();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.ConstActualValueUsage.ConstActualValueUsageCodeFix/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool TryFindArguments(SemanticModel semanticModel, InvocationExpressionSyntax invocationSyntax, ExpressionSyntax& expectedArgument, ExpressionSyntax& actualArgument);
    private static bool IsSupportedClassicAssert(IMethodSymbol methodSymbol);
    private static bool IsSupportedIsConstraint(InvocationExpressionSyntax& invocationExpression, MemberAccessExpressionSyntax& memberAccessExpression);
    private static bool IsSupportedStringAssert(IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.Constants.AnalyzerIdentifiers : object {
    internal static string TestCaseParameterTypeMismatchUsage;
    internal static string TestCaseSourceStringUsage;
    internal static string TestCaseNotEnoughArgumentsUsage;
    internal static string TestCaseTooManyArgumentsUsage;
    internal static string TestMethodExpectedResultTypeMismatchUsage;
    internal static string TestMethodSpecifiedExpectedResultForVoidUsage;
    internal static string TestMethodNoExpectedResultButNonVoidReturnType;
    internal static string ParallelScopeSelfNoEffectOnAssemblyUsage;
    internal static string ParallelScopeChildrenOnNonParameterizedTestMethodUsage;
    internal static string ParallelScopeFixturesOnTestMethodUsage;
    internal static string TestCaseSourceIsMissing;
    internal static string TestMethodAsyncNoExpectedResultAndVoidReturnTypeUsage;
    internal static string TestMethodAsyncNoExpectedResultAndNonTaskReturnTypeUsage;
    internal static string TestMethodAsyncExpectedResultAndNonGenricTaskReturnTypeUsage;
    internal static string TestCaseSourceSourceTypeNotIEnumerable;
    internal static string TestCaseSourceSourceTypeNoDefaultConstructor;
    internal static string TestCaseSourceSourceIsNotStatic;
    internal static string TestCaseSourceMismatchInNumberOfParameters;
    internal static string TestCaseSourceDoesNotReturnIEnumerable;
    internal static string TestCaseSourceSuppliesParametersToFieldOrProperty;
    internal static string ValueSourceStringUsage;
    internal static string ValueSourceIsNotStatic;
    internal static string ValueSourceMethodExpectParameters;
    internal static string ValueSourceDoesNotReturnIEnumerable;
    internal static string ValueSourceIsMissing;
    internal static string TestMethodIsNotPublic;
    internal static string SimpleTestMethodHasParameters;
    internal static string NonTestMethodIsPublic;
    internal static string TestCaseSourceMismatchInNumberOfTestMethodParameters;
    internal static string TestCaseSourceMismatchWithTestMethodParameterType;
    internal static string ValuesParameterTypeMismatchUsage;
    internal static string FieldIsNotDisposedInTearDown;
    internal static string TestContextWriteIsObsolete;
    internal static string FalseUsage;
    internal static string IsFalseUsage;
    internal static string IsTrueUsage;
    internal static string TrueUsage;
    internal static string AreEqualUsage;
    internal static string AreNotEqualUsage;
    internal static string ConstActualValueUsage;
    internal static string IgnoreCaseUsage;
    internal static string SameActualExpectedValue;
    internal static string EqualConstraintUsage;
    internal static string StringContainsConstraintUsage;
    internal static string StringStartsWithConstraintUsage;
    internal static string StringEndsWithConstraintUsage;
    internal static string CollectionContainsConstraintUsage;
    internal static string AreSameUsage;
    internal static string NullUsage;
    internal static string IsNullUsage;
    internal static string NotNullUsage;
    internal static string IsNotNullUsage;
    internal static string SameAsIncompatibleTypes;
    internal static string EqualToIncompatibleTypes;
    internal static string MissingProperty;
    internal static string NullConstraintUsage;
    internal static string StringConstraintWrongActualType;
    internal static string ContainsConstraintWrongActualType;
    internal static string SomeItemsIncompatibleTypes;
    internal static string GreaterUsage;
    internal static string GreaterOrEqualUsage;
    internal static string LessUsage;
    internal static string LessOrEqualUsage;
    internal static string AreNotSameUsage;
    internal static string ZeroUsage;
    internal static string NotZeroUsage;
    internal static string IsNaNUsage;
    internal static string IsEmptyUsage;
    internal static string IsNotEmptyUsage;
    internal static string ContainsUsage;
    internal static string IsInstanceOfUsage;
    internal static string IsNotInstanceOfUsage;
    internal static string SameAsOnValueTypes;
    internal static string ComparableTypes;
    internal static string ComparableOnObject;
    internal static string ComparisonConstraintUsage;
    internal static string DelegateRequired;
    internal static string UseAssertMultiple;
    internal static string UsePropertyConstraint;
    internal static string WithinIncompatibleTypes;
    internal static string StringAssertUsage;
    internal static string CollectionAssertUsage;
    internal static string UpdateStringFormatToInterpolatableString;
    internal static string DereferencePossibleNullReference;
    internal static string NonNullableFieldOrPropertyIsUninitialized;
    internal static string AvoidUninstantiatedInternalClasses;
    internal static string TypesThatOwnDisposableFieldsShouldBeDisposable;
    internal static string SimplifyValues;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.Constants.AnalyzerPropertyKeys : object {
    internal static string ModelName;
    internal static string ArgsIsArray;
    internal static string MinimumNumberOfArguments;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.Constants.Categories : object {
    internal static string Structure;
    internal static string Assertion;
    internal static string Suppression;
    internal static string Style;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NUnit.Analyzers.Constants.NUnitFrameworkConstants : object {
    public static string NameOfIs;
    public static string NameOfIsFalse;
    public static string NameOfIsTrue;
    public static string NameOfIsEqualTo;
    public static string NameOfIsEquivalentTo;
    public static string NameOfIsSubsetOf;
    public static string NameOfIsSupersetOf;
    public static string NameOfIsNot;
    public static string NameOfIsSameAs;
    public static string NameOfIsSamePath;
    public static string NameOfIsNull;
    public static string NameOfIsGreaterThan;
    public static string NameOfIsGreaterThanOrEqualTo;
    public static string NameOfIsLessThan;
    public static string NameOfIsLessThanOrEqualTo;
    public static string NameOfIsPositive;
    public static string NameOfIsZero;
    public static string NameOfIsNaN;
    public static string NameOfIsEmpty;
    public static string NameOfIsInstanceOf;
    public static string NameOfIsAll;
    public static string NameOfIsUnique;
    public static string NameOfIsOrdered;
    public static string NameOfContains;
    public static string NameOfContainsItem;
    public static string NameOfDoes;
    public static string NameOfDoesNot;
    public static string NameOfDoesContain;
    public static string NameOfDoesStartWith;
    public static string NameOfDoesEndWith;
    public static string NameOfDoesMatch;
    public static string NameOfHas;
    public static string NameOfHasProperty;
    public static string NameOfHasCount;
    public static string NameOfHasLength;
    public static string NameOfHasMessage;
    public static string NameOfHasInnerException;
    public static string NameOfHasNo;
    public static string NameOfHasMember;
    public static string NameOfMultiple;
    public static string NameOfMultipleAsync;
    public static string NameOfOut;
    public static string NameOfWrite;
    public static string NameOfWriteLine;
    public static string NameOfThrows;
    public static string NameOfThrowsArgumentException;
    public static string NameOfThrowsArgumentNullException;
    public static string NameOfThrowsInvalidOperationException;
    public static string NameOfThrowsTargetInvocationException;
    public static string NameOfAssert;
    public static string NameOfAssume;
    public static string NameOfAssertPass;
    public static string NameOfAssertFail;
    public static string NameOfAssertWarn;
    public static string NameOfAssertIgnore;
    public static string NameOfAssertInconclusive;
    public static string NameOfAssertIsTrue;
    public static string NameOfAssertTrue;
    public static string NameOfAssertIsFalse;
    public static string NameOfAssertFalse;
    public static string NameOfAssertAreEqual;
    public static string NameOfAssertAreNotEqual;
    public static string NameOfAssertAreSame;
    public static string NameOfAssertAreNotSame;
    public static string NameOfAssertNull;
    public static string NameOfAssertIsNull;
    public static string NameOfAssertNotNull;
    public static string NameOfAssertIsNotNull;
    public static string NameOfAssertThat;
    public static string NameOfAssertGreater;
    public static string NameOfAssertGreaterOrEqual;
    public static string NameOfAssertLess;
    public static string NameOfAssertLessOrEqual;
    public static string NameOfAssertZero;
    public static string NameOfAssertNotZero;
    public static string NameOfAssertIsNaN;
    public static string NameOfAssertIsEmpty;
    public static string NameOfAssertIsNotEmpty;
    public static string NameOfAssertContains;
    public static string NameOfAssertIsInstanceOf;
    public static string NameOfAssertIsNotInstanceOf;
    public static string NameOfAssertCatch;
    public static string NameOfAssertCatchAsync;
    public static string NameOfAssertThrows;
    public static string NameOfAssertThrowsAsync;
    public static string NameOfStringAssert;
    public static string NameOfStringAssertContains;
    public static string NameOfStringAssertDoesNotContain;
    public static string NameOfStringAssertStartsWith;
    public static string NameOfStringAssertDoesNotStartWith;
    public static string NameOfStringAssertEndsWith;
    public static string NameOfStringAssertDoesNotEndWith;
    public static string NameOfStringAssertAreEqualIgnoringCase;
    public static string NameOfStringAssertAreNotEqualIgnoringCase;
    public static string NameOfStringAssertIsMatch;
    public static string NameOfStringAssertDoesNotMatch;
    public static string NameOfCollectionAssert;
    public static string NameOfCollectionAssertAllItemsAreInstancesOfType;
    public static string NameOfCollectionAssertAllItemsAreNotNull;
    public static string NameOfCollectionAssertAllItemsAreUnique;
    public static string NameOfCollectionAssertAreEqual;
    public static string NameOfCollectionAssertAreEquivalent;
    public static string NameOfCollectionAssertAreNotEqual;
    public static string NameOfCollectionAssertAreNotEquivalent;
    public static string NameOfCollectionAssertContains;
    public static string NameOfCollectionAssertDoesNotContain;
    public static string NameOfCollectionAssertIsNotSubsetOf;
    public static string NameOfCollectionAssertIsSubsetOf;
    public static string NameOfCollectionAssertIsNotSupersetOf;
    public static string NameOfCollectionAssertIsSupersetOf;
    public static string NameOfCollectionAssertIsEmpty;
    public static string NameOfCollectionAssertIsNotEmpty;
    public static string NameOfCollectionAssertIsOrdered;
    public static string FullNameOfTypeIs;
    public static string FullNameOfTypeTestCaseAttribute;
    public static string FullNameOfTypeTestCaseSourceAttribute;
    public static string FullNameOfTypeTestAttribute;
    public static string FullNameOfTypeParallelizableAttribute;
    public static string FullNameOfTypeITestBuilder;
    public static string FullNameOfTypeISimpleTestBuilder;
    public static string FullNameOfTypeValuesAttribute;
    public static string FullNameOfTypeValueSourceAttribute;
    public static string FullNameOfTypeIParameterDataSource;
    public static string FullNameOfTypeTestCaseData;
    public static string FullNameOfTypeTestCaseParameters;
    public static string FullNameOfTypeOneTimeSetUpAttribute;
    public static string FullNameOfTypeOneTimeTearDownAttribute;
    public static string FullNameOfTypeSetUpAttribute;
    public static string FullNameOfTypeTearDownAttribute;
    public static string FullNameOfFixtureLifeCycleAttribute;
    public static string FullNameOfLifeCycle;
    public static string FullNameOfCancelAfterAttribute;
    public static string FullNameOfCancellationToken;
    public static string FullNameOfTypeTestContext;
    public static string NameOfConstraint;
    public static string FullNameOfSameAsConstraint;
    public static string FullNameOfSomeItemsConstraint;
    public static string FullNameOfEqualToConstraint;
    public static string FullNameOfEndsWithConstraint;
    public static string FullNameOfRegexConstraint;
    public static string FullNameOfEmptyStringConstraint;
    public static string FullNameOfSamePathConstraint;
    public static string FullNameOfSamePathOrUnderConstraint;
    public static string FullNameOfStartsWithConstraint;
    public static string FullNameOfSubPathConstraint;
    public static string FullNameOfSubstringConstraint;
    public static string FullNameOfContainsConstraint;
    public static string FullNameOfActualValueDelegate;
    public static string FullNameOfDelayedConstraint;
    public static string FullNameOfTestDelegate;
    public static string FullNameOfThrows;
    public static string NameOfTestCaseAttribute;
    public static string NameOfTestCaseSourceAttribute;
    public static string NameOfTestAttribute;
    public static string NameOfParallelizableAttribute;
    public static string NameOfValuesAttribute;
    public static string NameOfValueSourceAttribute;
    public static string NameOfOneTimeSetUpAttribute;
    public static string NameOfOneTimeTearDownAttribute;
    public static string NameOfSetUpAttribute;
    public static string NameOfTearDownAttribute;
    public static string NameOfCancelAfterAttribute;
    public static string NameOfExpectedResult;
    public static string NameOfActualParameter;
    public static string NameOfADoubleParameter;
    public static string NameOfAnObjectParameter;
    public static string NameOfArg1Parameter;
    public static string NameOfArg2Parameter;
    public static string NameOfArgsParameter;
    public static string NameOfAStringParameter;
    public static string NameOfCollectionParameter;
    public static string NameOfComparerParameter;
    public static string NameOfConditionParameter;
    public static string NameOfDeltaParameter;
    public static string NameOfExpectedParameter;
    public static string NameOfExpectedTypeParameter;
    public static string NameOfExpressionParameter;
    public static string NameOfMessageParameter;
    public static string NameOfPatternParameter;
    public static string NameOfSubsetParameter;
    public static string NameOfSupersetParameter;
    public static string NameOfConstraintExpressionAnd;
    public static string NameOfConstraintExpressionOr;
    public static string NameOfConstraintExpressionWith;
    public static string NameOfEqualConstraintIgnoreCase;
    public static string NameOfEqualConstraintUsing;
    public static string NameOfEqualConstraintWithin;
    public static string NameOfEqualConstraintAsCollection;
    public static string NUnitFrameworkAssemblyName;
    public static string NUnitFrameworkLegacyAssemblyName;
    public static string NameOfClassicAssert;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NUnit.Analyzers.ConstraintUsage.BaseConditionConstraintAnalyzer : BaseAssertionAnalyzer {
    internal static string SuggestedConstraintString;
    internal static string SwapOperands;
    protected static String[] SupportedPositiveAssertMethods;
    protected static String[] SupportedNegativeAssertMethods;
    private static BaseConditionConstraintAnalyzer();
    protected static bool IsRefStruct(IOperation operation);
    protected static bool IsBinaryOperationNotUsingRefStructOperands(IOperation actual, BinaryOperatorKind binaryOperator);
    protected virtual ValueTuple`3<DiagnosticDescriptor, string, bool> GetDiagnosticDataWithPossibleSwapOperands(OperationAnalysisContext context, IOperation actual, bool negated);
    protected virtual ValueTuple`2<DiagnosticDescriptor, string> GetDiagnosticData(OperationAnalysisContext context, IOperation actual, bool negated);
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static bool IsPrefixNotOperation(IOperation operation, IOperation& operand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NUnit.Analyzers.ConstraintUsage.BaseConditionConstraintCodeFix : CodeFixProvider {
    internal static string UseConstraintDescriptionFormat;
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.ConstraintUsage.BaseConditionConstraintCodeFix/<RegisterCodeFixesAsync>d__2")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual ValueTuple`2<ExpressionSyntax, ExpressionSyntax> GetActualAndConstraintExpression(ExpressionSyntax conditionNode, string suggestedConstraintString, bool swapOperands);
    protected virtual ValueTuple`2<ExpressionSyntax, ExpressionSyntax> GetActualAndConstraintExpression(ExpressionSyntax conditionNode, string suggestedConstraintString);
    [NullableContextAttribute("2")]
protected static InvocationExpressionSyntax GetConstraintExpression(string constraintString, ExpressionSyntax expected);
    protected static InvocationExpressionSyntax UpdateAssertNode(InvocationExpressionSyntax assertNode, ExpressionSyntax conditionNode, IMethodSymbol assertMethod, ExpressionSyntax actual, ExpressionSyntax constraintExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ConstraintUsage.ComparisonConstraintUsageAnalyzer : BaseConditionConstraintAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ComparisonConstraintUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual ValueTuple`3<DiagnosticDescriptor, string, bool> GetDiagnosticDataWithPossibleSwapOperands(OperationAnalysisContext context, IOperation actual, bool negated);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ConstraintUsage.ComparisonConstraintUsageCodeFix : BaseConditionConstraintCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ValueTuple`2<ExpressionSyntax, ExpressionSyntax> GetActualAndConstraintExpression(ExpressionSyntax conditionNode, string suggestedConstraintString, bool swapOperands);
    private static ValueTuple`2<ExpressionSyntax, ExpressionSyntax> GetActualExpected(SyntaxNode conditionNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ConstraintUsage.ComparisonConstraintUsageConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ConstraintUsage.EqualConstraintUsageAnalyzer : BaseConditionConstraintAnalyzer {
    private static string IsEqualTo;
    private static string IsNotEqualTo;
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EqualConstraintUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual ValueTuple`2<DiagnosticDescriptor, string> GetDiagnosticData(OperationAnalysisContext context, IOperation actual, bool negated);
    private static bool IsStaticObjectEquals(IOperation operation);
    private static bool IsInstanceObjectEquals(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ConstraintUsage.EqualConstraintUsageCodeFix : BaseConditionConstraintCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ValueTuple`2<ExpressionSyntax, ExpressionSyntax> GetActualAndConstraintExpression(ExpressionSyntax conditionNode, string suggestedConstraintString);
    private static ValueTuple`2<ExpressionSyntax, ExpressionOrPatternSyntax> GetActualExpected(SyntaxNode conditionNode);
    private InvocationExpressionSyntax ConvertPattern(ExpressionSyntax member, PatternSyntax pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ConstraintUsage.EqualConstraintUsageConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ConstraintUsage.SomeItemsConstraintUsageAnalyzer : BaseConditionConstraintAnalyzer {
    private static string DoesContain;
    private static string DoesNotContain;
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SomeItemsConstraintUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual ValueTuple`2<DiagnosticDescriptor, string> GetDiagnosticData(OperationAnalysisContext context, IOperation actual, bool negated);
    private static bool IsLinqContains(IMethodSymbol methodSymbol);
    private static bool IsCollectionContains(IMethodSymbol methodSymbol);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ConstraintUsage.SomeItemsConstraintUsageCodeFix : BaseConditionConstraintCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ExpressionSyntax, ExpressionSyntax> GetActualAndConstraintExpression(ExpressionSyntax conditionNode, string suggestedConstraintString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ConstraintUsage.SomeItemsConstraintUsageConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ConstraintUsage.StringConstraintUsageAnalyzer : BaseConditionConstraintAnalyzer {
    private static DiagnosticDescriptor containsDescriptor;
    private static DiagnosticDescriptor startsWithDescriptor;
    private static DiagnosticDescriptor endsWithDescriptor;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, ValueTuple`2<string, DiagnosticDescriptor>> SupportedMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StringConstraintUsageAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual ValueTuple`2<DiagnosticDescriptor, string> GetDiagnosticData(OperationAnalysisContext context, IOperation actual, bool negated);
    private static ValueTuple`2<DiagnosticDescriptor, string> GetDiagnosticData(string stringMethod, bool negated);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.ConstraintUsage.StringConstraintUsageCodeFix : BaseConditionConstraintCodeFix {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual ValueTuple`2<ExpressionSyntax, ExpressionSyntax> GetActualAndConstraintExpression(ExpressionSyntax conditionNode, string suggestedConstraintString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ConstraintUsage.StringConstraintUsageConstants : object {
    internal static string ContainsTitle;
    internal static string StartsWithTitle;
    internal static string EndsWithTitle;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ContainsConstraintWrongActualType.ContainsConstraintWrongActualTypeAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ContainsConstraintWrongActualTypeAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ContainsConstraintWrongActualType.ContainsConstraintWrongActualTypeConstants : object {
    public static string Title;
    public static string Message;
    public static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.DelegateRequired.DelegateRequiredAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor Descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DelegateRequiredAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static bool IsDelayedConstraint(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.DelegateRequired.DelegateRequiredCodeFix : CodeFixProvider {
    internal static string UseAnonymousLambdaDescription;
    internal static string UseMethodGroupDescription;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.DelegateRequired.DelegateRequiredCodeFix/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.DelegateRequired.DelegateRequiredConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.DiagnosticDescriptorCreator : object {
    internal static DiagnosticDescriptor Create(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, string description);
    internal static DiagnosticDescriptor Create(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description);
    private static string CreateLink(string id);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.DiagnosticSuppressors.AvoidUninstantiatedInternalClassSuppressor : DiagnosticSuppressor {
    [NullableAttribute("1")]
internal static SuppressionDescriptor AvoidUninstantiatedInternalTestFixtureClasses;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SuppressionDescriptor> <SupportedSuppressions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SuppressionDescriptor> SupportedSuppressions { get; }
    private static AvoidUninstantiatedInternalClassSuppressor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<SuppressionDescriptor> get_SupportedSuppressions();
    public virtual void ReportSuppressions(SuppressionAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.DiagnosticSuppressors.DereferencePossiblyNullReferenceSuppressor : DiagnosticSuppressor {
    private static string Justification;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, SuppressionDescriptor> <SuppressionDescriptors>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SuppressionDescriptor> <SupportedSuppressions>k__BackingField;
    public static ImmutableDictionary`2<string, SuppressionDescriptor> SuppressionDescriptors { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SuppressionDescriptor> SupportedSuppressions { get; }
    private static DereferencePossiblyNullReferenceSuppressor();
    [CompilerGeneratedAttribute]
public static ImmutableDictionary`2<string, SuppressionDescriptor> get_SuppressionDescriptors();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<SuppressionDescriptor> get_SupportedSuppressions();
    public virtual void ReportSuppressions(SuppressionAnalysisContext context);
    private static bool ShouldBeSuppressed(SyntaxNode node);
    private static bool ShouldBeSuppressed(IMethodSymbol method, string nonMatchedParameterType, InvocationExpressionSyntax invocationExpression);
    private static ExpressionSyntax DetermineConditionalExpressionPath(ConditionalExpressionSyntax conditionalExpression);
    private static bool IsValidatedNotNullByPreviousStatementInSameBlock(string possibleNullReference, BlockSyntax block, StatementSyntax statement);
    private static bool IsValidatedNotNullByExpression(string possibleNullReference, ExpressionSyntax expression);
    [NullableContextAttribute("2")]
private static bool IsKnownToBeNotNull(SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool IsKnownToBeNotNull(ExpressionSyntax expression);
    private static bool InvalidatedBy(string assignment, string possibleNullReference);
    private static bool CoveredBy(string assertedNotNull, string possibleNullReference);
    private static bool IsHasValue(string argument, string possibleNullReference);
    private static ImmutableDictionary`2<string, SuppressionDescriptor> CreateSuppressionDescriptors(String[] suppressionDiagnosticsIds);
    private static SuppressionDescriptor CreateSuppressionDescriptor(string suppressedDiagnoticsId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.DiagnosticSuppressors.NonNullableFieldOrPropertyIsUninitializedSuppressor : DiagnosticSuppressor {
    internal static SuppressionDescriptor NullableFieldOrPropertyInitializedInSetUp;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SuppressionDescriptor> <SupportedSuppressions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SuppressionDescriptor> SupportedSuppressions { get; }
    private static NonNullableFieldOrPropertyIsUninitializedSuppressor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<SuppressionDescriptor> get_SupportedSuppressions();
    public virtual void ReportSuppressions(SuppressionAnalysisContext context);
    private static bool IsAssignedIn(SemanticModel model, ClassDeclarationSyntax classDeclaration, HashSet`1<MethodDeclarationSyntax> visitedMethods, MethodDeclarationSyntax method, string fieldOrPropertyName);
    private static bool IsAssignedIn(SemanticModel model, ClassDeclarationSyntax classDeclaration, HashSet`1<MethodDeclarationSyntax> visitedMethods, StatementSyntax statement, string fieldOrPropertyName);
    private static bool IsAssignedIn(SemanticModel model, ClassDeclarationSyntax classDeclaration, HashSet`1<MethodDeclarationSyntax> visitedMethods, SyntaxList`1<StatementSyntax> statements, string fieldOrPropertyName);
    private static bool IsAssignedIn(SemanticModel model, ClassDeclarationSyntax classDeclaration, HashSet`1<MethodDeclarationSyntax> visitedMethods, InvocationExpressionSyntax invocationExpression, string fieldOrPropertyName);
    private static bool IsAssignedIn(SemanticModel model, ClassDeclarationSyntax classDeclaration, HashSet`1<MethodDeclarationSyntax> visitedMethods, ExpressionSyntax expressionStatement, string fieldOrPropertyName);
    private static string GetIdentifier(ExpressionSyntax expression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.DiagnosticSuppressors.TypesThatOwnDisposableFieldsShouldBeDisposableSuppressor : DiagnosticSuppressor {
    [NullableAttribute("1")]
internal static SuppressionDescriptor TypesThatOwnDisposableFieldsShouldHaveATearDown;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SuppressionDescriptor> <SupportedSuppressions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SuppressionDescriptor> SupportedSuppressions { get; }
    private static TypesThatOwnDisposableFieldsShouldBeDisposableSuppressor();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<SuppressionDescriptor> get_SupportedSuppressions();
    public virtual void ReportSuppressions(SuppressionAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.DisposeFieldsInTearDown.DisposeFieldsAndPropertiesInTearDownAnalyzer : DiagnosticAnalyzer {
    private static Char[] AdditionalDisposalMethodsSeparators;
    private static ImmutableHashSet`1<string> StandardDisposeMethods;
    private static ImmutableHashSet`1<string> DisposableTypeNotRequiringToBeDisposed;
    private static DiagnosticDescriptor fieldIsNotDisposedInTearDown;
    [CompilerGeneratedAttribute]
private static int <EarlyOutCount>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    internal static int EarlyOutCount { get; private set; }
    private static DisposeFieldsAndPropertiesInTearDownAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
internal static int get_EarlyOutCount();
    [CompilerGeneratedAttribute]
private static void set_EarlyOutCount(int value);
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeDisposableFields(SyntaxNodeAnalysisContext context);
    private static bool CanBeAssignedTo(FieldDeclarationSyntax declaration, bool hasConstructors);
    private static bool CanBeAssignedTo(PropertyDeclarationSyntax declaration, bool hasConstructors);
    private static bool HasAttribute(IMethodSymbol method, string attributeName);
    private static void AnalyzeAssignedButNotDisposed(SyntaxNodeAnalysisContext context, Dictionary`2<string, SyntaxNode> symbols, Parameters parameters, string where, IEnumerable`1<IMethodSymbol> setUpMethods, IEnumerable`1<IMethodSymbol> tearDownMethods, HashSet`1<string> assignedWithInitializers);
    private static void AssignedIn(Parameters parameters, HashSet`1<string> assignments, IEnumerable`1<IMethodSymbol> methods);
    private static void AssignedIn(Parameters parameters, HashSet`1<string> assignments, IMethodSymbol symbol);
    private static void AssignedIn(Parameters parameters, HashSet`1<string> assignments, BaseMethodDeclarationSyntax method);
    private static void AssignedIn(Parameters parameters, HashSet`1<string> assignments, ExpressionSyntax expression);
    private static void AssignedIn(Parameters parameters, HashSet`1<string> assignments, StatementSyntax statement);
    private static void AssignedIn(Parameters parameters, HashSet`1<string> assignments, SyntaxList`1<StatementSyntax> statements);
    private static bool NeedsDisposal(SemanticModel model, ExpressionSyntax expression);
    private static bool IsPossibleDisposableCreation(ExpressionSyntax expression);
    private static bool IsDisposableTypeNotRequiringToBeDisposed(ITypeSymbol typeSymbol);
    private static void DisposedIn(Parameters parameters, HashSet`1<string> disposals, IEnumerable`1<IMethodSymbol> methods);
    private static void DisposedIn(Parameters parameters, HashSet`1<string> disposals, IMethodSymbol symbol);
    private static void DisposedIn(Parameters parameters, HashSet`1<string> disposals, MethodDeclarationSyntax method);
    private static void DisposedIn(Parameters parameters, HashSet`1<string> disposals, ExpressionSyntax expression);
    private static void DisposedIn(Parameters parameters, HashSet`1<string> disposals, StatementSyntax statement);
    private static void DisposedIn(Parameters parameters, HashSet`1<string> disposals, SyntaxList`1<StatementSyntax> statements);
    private static string GetIdentifier(ExpressionSyntax expression);
    private static bool IsDisposable(ExpressionSyntax typeExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.DisposeFieldsInTearDown.DisposeFieldsAndPropertiesInTearDownConstants : object {
    internal static string FieldOrPropertyIsNotDisposedInTearDownTitle;
    internal static string FieldOrPropertyIsNotDisposedInTearDownDescription;
    internal static string FieldOrPropertyIsNotDisposedInTearDownMessageFormat;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.EqualToIncompatibleTypes.EqualToIncompatibleTypesAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EqualToIncompatibleTypesAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    [NullableContextAttribute("2")]
private static void CheckActualVsExpectedOperation(OperationAnalysisContext context, IOperation actualOperation, IOperation expectedOperation);
    private static void CheckActualVsExpectedOperation(OperationAnalysisContext context, ITypeSymbol actualType, IOperation expectedOperation);
    private static bool HasCustomEqualityComparer(ConstraintExpressionPart constraintPartExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.EqualToIncompatibleTypes.EqualToIncompatibleTypesConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NUnit.Analyzers.Extensions.ArgumentListSyntaxExtensions : object {
    [ExtensionAttribute]
public static ArgumentListSyntax WithArguments(ArgumentListSyntax this, IEnumerable`1<ArgumentSyntax> newArguments);
    private static bool TryGetFirstEndOfLineTrivia(SyntaxToken openParenToken, SyntaxToken[] separators, SyntaxTrivia& trailingTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NUnit.Analyzers.Extensions.AttributeArgumentTypedConstantExtensions : object {
    private static IReadOnlyList`1<Type> ConvertibleTypes;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static List`1<ValueTuple`2<Type, Lazy`1<TypeConverter>>> IntrinsicTypeConverters;
    private static AttributeArgumentTypedConstantExtensions();
    [ExtensionAttribute]
internal static bool CanAssignTo(TypedConstant this, ITypeSymbol target, Compilation compilation, bool allowImplicitConversion, bool allowEnumToUnderlyingTypeConversion, bool suppressNullableWarning);
    [NullableContextAttribute("2")]
private static object GetValue(TypedConstant typedConstant);
    private static ITypeSymbol GetTargetType(ITypeSymbol target);
    private static bool TryChangeType(ITypeSymbol targetTypeSymbol, object argumentValue);
    private static bool HasBuiltInImplicitConversion(ITypeSymbol argumentType, ITypeSymbol targetType, Compilation compilation);
    private static bool CanBeTranslatedByTypeConverter(ITypeSymbol targetTypeSymbol, object argumentValue, Compilation compilation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static ImmutableArray`1<TypedConstant> AdjustArguments(ImmutableArray`1<TypedConstant> attributePositionalArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NUnit.Analyzers.Extensions.AttributeDataExtensions : object {
    [ExtensionAttribute]
public static bool DerivesFromISimpleTestBuilder(AttributeData this, Compilation compilation);
    [ExtensionAttribute]
public static bool DerivesFromITestBuilder(AttributeData this, Compilation compilation);
    [ExtensionAttribute]
public static bool DerivesFromIParameterDataSource(AttributeData this, Compilation compilation);
    [ExtensionAttribute]
public static bool IsTestMethodAttribute(AttributeData this, Compilation compilation);
    [ExtensionAttribute]
public static bool IsSetUpOrTearDownMethodAttribute(AttributeData this, Compilation compilation);
    [ExtensionAttribute]
public static bool IsFixtureLifeCycleAttribute(AttributeData this, Compilation compilation);
    [ExtensionAttribute]
public static AttributeArgumentSyntax GetConstructorArgumentSyntax(AttributeData this, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ExpressionSyntax GetAdjustedArgumentSyntax(AttributeData this, int position, ImmutableArray`1<TypedConstant> attributePositionalArguments, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static AttributeArgumentSyntax GetNamedArgumentSyntax(AttributeData this, string name, CancellationToken cancellationToken);
    private static bool DerivesFromInterface(Compilation compilation, AttributeData attributeData, string interfaceTypeFullName);
}
[ExtensionAttribute]
internal static class NUnit.Analyzers.Extensions.AttributeSyntaxExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ValueTuple`2<ImmutableArray`1<AttributeArgumentSyntax>, ImmutableArray`1<AttributeArgumentSyntax>> GetArguments(AttributeSyntax this);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NUnit.Analyzers.Extensions.ExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GetArgumentExpression(InvocationExpressionSyntax invocationSyntax, IMethodSymbol methodSymbol, string parameterName);
    [ExtensionAttribute]
public static string GetName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsSuppressNullableWarning(ExpressionSyntax expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NUnit.Analyzers.Extensions.IMethodSymbolExtensions : object {
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static ValueTuple`3<UInt32, UInt32, UInt32> GetParameterCounts(IMethodSymbol this, bool hasCancelAfterAttribute, INamedTypeSymbol cancellationTokenType);
    [ExtensionAttribute]
internal static bool IsInterfaceImplementation(IMethodSymbol this, string interfaceFullName);
    [ExtensionAttribute]
internal static bool IsTestRelatedMethod(IMethodSymbol methodSymbol, Compilation compilation);
    [ExtensionAttribute]
internal static bool HasTestRelatedAttributes(IMethodSymbol methodSymbol, Compilation compilation);
    [ExtensionAttribute]
internal static bool IsTestFixture(ITypeSymbol typeSymbol, Compilation compilation);
    [ExtensionAttribute]
internal static bool IsInstancePerTestCaseFixture(ITypeSymbol typeSymbol, Compilation compilation);
}
[ExtensionAttribute]
public static class NUnit.Analyzers.Extensions.ImmutableArrayExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TryGetValue(ImmutableArray`1<KeyValuePair`2<TKey, TValue>> this, TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NUnit.Analyzers.Extensions.IOperationExtensions : object {
    [ExtensionAttribute]
public static string GetName(IOperation this);
    [ExtensionAttribute]
public static IOperation GetInstance(IOperation this);
    [ExtensionAttribute]
public static IEnumerable`1<IOperation> SplitCallChain(IOperation this);
    [ExtensionAttribute]
public static IOperation GetArgumentOperation(IInvocationOperation this, string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NUnit.Analyzers.Extensions.ITypeSymbolExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsAssignableFrom(ITypeSymbol this, ITypeSymbol other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsAssert(ITypeSymbol this);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsAssume(ITypeSymbol this);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsClassicAssert(ITypeSymbol this);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsStringAssert(ITypeSymbol this);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsCollectionAssert(ITypeSymbol this);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsConstraint(ITypeSymbol this);
    [ExtensionAttribute]
internal static bool IsType(ITypeSymbol this, string fullMetadataName, Compilation compilation);
    [ExtensionAttribute]
internal static string GetFullMetadataName(ITypeSymbol this);
    [IteratorStateMachineAttribute("NUnit.Analyzers.Extensions.ITypeSymbolExtensions/<GetAllBaseTypes>d__9")]
[ExtensionAttribute]
internal static IEnumerable`1<INamedTypeSymbol> GetAllBaseTypes(ITypeSymbol this);
    [ExtensionAttribute]
internal static IEnumerable`1<ISymbol> GetAllMembers(ITypeSymbol this);
    [IteratorStateMachineAttribute("NUnit.Analyzers.Extensions.ITypeSymbolExtensions/<GetAllAttributes>d__11")]
[ExtensionAttribute]
internal static IEnumerable`1<AttributeData> GetAllAttributes(ITypeSymbol this);
    [ExtensionAttribute]
internal static bool IsTypeParameterAndDeclaredOnMethod(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
internal static bool IsAwaitable(ITypeSymbol this, ITypeSymbol& returnType);
    [ExtensionAttribute]
internal static bool IsIEnumerable(ITypeSymbol this, ITypeSymbol& elementType);
    [ExtensionAttribute]
internal static bool IsIEnumerableOrIAsyncEnumerable(ITypeSymbol this, ITypeSymbol& elementType);
    [ExtensionAttribute]
internal static bool IsDisposable(ITypeSymbol this);
    [ExtensionAttribute]
internal static bool IsDisposable(string fullName);
}
[ExtensionAttribute]
internal static class NUnit.Analyzers.Extensions.SyntaxReferenceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Location GetLocation(SyntaxReference this);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.Helpers.AssertHelper : object {
    [NullableContextAttribute("2")]
public static bool TryGetActualAndConstraintOperations(IInvocationOperation assertOperation, IOperation& actualOperation, ConstraintExpression& constraintExpression);
    public static ITypeSymbol UnwrapActualType(ITypeSymbol actualType);
    public static ITypeSymbol GetUnwrappedActualType(IOperation actualOperation);
    public static bool IsLiteralOperation(IOperation operation);
    public static bool IsInsideAssertMultiple(SyntaxNode node);
    public static bool IsAssert(ExpressionSyntax expression, String[] requestedMembers);
    [NullableContextAttribute("2")]
public static bool IsAssert(ExpressionSyntax expression, String& member, ArgumentListSyntax& argumentList);
    [NullableContextAttribute("2")]
public static bool IsAssertClassicAssertOrAssume(ExpressionSyntax expression, String& member, ArgumentListSyntax& argumentList);
    private static bool IsAssert(ExpressionSyntax expression, Func`2<string, bool> isNameOfAssert, String& member, ArgumentListSyntax& argumentList);
    private static SimpleNameSyntax GetClassName(MemberAccessExpressionSyntax memberAccessExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NUnit.Analyzers.Helpers.CodeFixHelper : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static InvocationExpressionSyntax UpdateClassicAssertToAssertThat(InvocationExpressionSyntax invocationExpression, TypeArgumentListSyntax& typeArguments);
    [NullableContextAttribute("2")]
public static ArgumentSyntax GetInterpolatedMessageArgumentOrDefault(ArgumentSyntax messageArgument, List`1<ArgumentSyntax> args, bool unconditional, bool argsIsArray);
    public static void UpdateStringFormatToFormattableString(List`1<ArgumentSyntax> arguments, int minimumNumberOfArguments, bool argsIsArray);
    [IteratorStateMachineAttribute("NUnit.Analyzers.Helpers.CodeFixHelper/<UpdateStringFormatToFormattableString>d__3")]
internal static IEnumerable`1<InterpolatedStringContentSyntax> UpdateStringFormatToFormattableString(string formatSpecification, ExpressionSyntax[] formatArguments);
    private static SyntaxToken InterpolatedStringTextToken(string text);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class NUnit.Analyzers.Helpers.Constraints : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <StaticClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Modifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConstraintMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Property1>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Property2>k__BackingField;
    [NullableAttribute("1")]
public string StaticClass { get; }
    public string Modifier { get; }
    public string ConstraintMethod { get; }
    public string Property1 { get; }
    public string Property2 { get; }
    public Constraints(string staticClass, string modifier, string constraintMethod, string property1, string property2);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_StaticClass();
    [CompilerGeneratedAttribute]
public string get_Modifier();
    [CompilerGeneratedAttribute]
public string get_ConstraintMethod();
    [CompilerGeneratedAttribute]
public string get_Property1();
    [CompilerGeneratedAttribute]
public string get_Property2();
    [NullableContextAttribute("1")]
public ExpressionSyntax CreateConstraint(ArgumentSyntax expected);
}
[ExtensionAttribute]
internal static class NUnit.Analyzers.Helpers.DiagnosticExtensions : object {
    [NullableAttribute("2")]
private static PropertyInfo argumentsProperty;
    private static DiagnosticExtensions();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Object[] Arguments(Diagnostic diagnostic);
}
internal static class NUnit.Analyzers.Helpers.DiagnosticsHelper : object {
    public static bool LastArgumentIsNonParamsArray(ImmutableArray`1<IArgumentOperation> arguments);
    [NullableContextAttribute("1")]
public static ImmutableDictionary`2<string, string> GetProperties(string methodName, ImmutableArray`1<IArgumentOperation> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.Helpers.NUnitEqualityComparerHelper : object {
    [NullableContextAttribute("2")]
public static bool CanBeEqual(ITypeSymbol actualType, ITypeSymbol expectedType, Compilation compilation, ImmutableHashSet`1<ValueTuple`2<ITypeSymbol, ITypeSymbol>> checkedTypes);
    private static bool IsStream(ITypeSymbol typeSymbol, string fullName);
    private static bool IsKeyValuePair(INamedTypeSymbol typeSymbol, string fullSymbolName, ITypeSymbol& keyType, ITypeSymbol& valueType);
    private static bool IsDictionary(INamedTypeSymbol typeSymbol, string fullSymbolName, ITypeSymbol& keyType, ITypeSymbol& valueType);
    private static bool IsTuple(string fullName);
    private static bool IsUri(string fullName);
    private static bool IsIEquatable(ITypeSymbol typeSymbol, ITypeSymbol equatableTypeArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.IgnoreCaseUsage.IgnoreCaseUsageAnalyzer : BaseAssertionAnalyzer {
    private static String[] SupportedIsMethods;
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IgnoreCaseUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static bool IsTypeSupported(ITypeSymbol type, HashSet`1<ITypeSymbol> checkedTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.IgnoreCaseUsage.IgnoreCaseUsageAnalyzerConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.MissingProperty.MissingPropertyAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    private static String[] implicitPropertyConstraints;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MissingPropertyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static string TryGetRequiredPropertyName(IOperation prefix);
    private static bool HasUnsupportedPrefixes(ConstraintExpressionPart constraintPart);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.MissingProperty.MissingPropertyCodeFix : CodeFixProvider {
    internal static string UsePropertyDescriptionFormat;
    private static Dictionary`2<string, string> supportedCodeFixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static MissingPropertyCodeFix();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.MissingProperty.MissingPropertyCodeFix/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.MissingProperty.MissingPropertyConstants : object {
    internal static string Title;
    internal static string MessageFormat;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.NonTestMethodAccessibilityLevel.NonTestMethodAccessibilityLevelAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor nonTestMethodIsPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NonTestMethodAccessibilityLevelAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeType(SymbolAnalysisContext context);
    private static bool IsPublicOrInternalMethod(IMethodSymbol method);
    private static bool IsOverride(IMethodSymbol method);
    private static bool IsDisposeMethod(IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.NonTestMethodAccessibilityLevel.NonTestMethodAccessibilityLevelCodeFix : CodeFixProvider {
    internal static string MakeNonTestMethodPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.NonTestMethodAccessibilityLevel.NonTestMethodAccessibilityLevelCodeFix/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static SyntaxTokenList ReplaceModifiersWithPrivate(MethodDeclarationSyntax originalExpression);
    private static bool HasExplicitPublicAccessModifier(MethodDeclarationSyntax methodDeclarationSyntax);
    private static bool IsPublicAccessModifier(SyntaxToken syntaxToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.NonTestMethodAccessibilityLevel.NonTestMethodAccessibilityLevelConstants : object {
    internal static string NonTestMethodIsPublicTitle;
    internal static string NonTestMethodIsPublicMessage;
    internal static string NonTestMethodIsPublicDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.NullConstraintUsage.NullConstraintUsageAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NullConstraintUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.NullConstraintUsage.NullConstraintUsageAnalyzerConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NUnit.Analyzers.Operations.ConstraintExpression : object {
    private IOperation expressionOperation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConstraintExpressionPart[] constraintParts;
    public ConstraintExpressionPart[] ConstraintParts { get; }
    public ConstraintExpression(IOperation expressionOperation);
    public ConstraintExpressionPart[] get_ConstraintParts();
    private static IEnumerable`1<List`1<IOperation>> SplitConstraintByOperators(IOperation constraintExpression);
    [IteratorStateMachineAttribute("NUnit.Analyzers.Operations.ConstraintExpression/<SplitConstraintByBinaryOperators>d__6")]
private static IEnumerable`1<IOperation> SplitConstraintByBinaryOperators(IOperation constraintExpression);
    [IteratorStateMachineAttribute("NUnit.Analyzers.Operations.ConstraintExpression/<SplitConstraintByConstraintExpressionOperators>d__7")]
private static IEnumerable`1<List`1<IOperation>> SplitConstraintByConstraintExpressionOperators(IOperation constraintExpression);
    private static bool IsConstraintExpressionOperator(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NUnit.Analyzers.Operations.ConstraintExpressionPart : object {
    private IReadOnlyList`1<IOperation> callChainOperations;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITypeSymbol <HelperClass>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IOperation> <Prefixes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IOperation <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IOperation> <Suffixes>k__BackingField;
    [NullableAttribute("2")]
public ITypeSymbol HelperClass { get; }
    public IReadOnlyCollection`1<IOperation> Prefixes { get; }
    [NullableAttribute("2")]
public IOperation Root { get; }
    public IReadOnlyCollection`1<IOperation> Suffixes { get; }
    public TextSpan Span { get; }
    public ConstraintExpressionPart(IReadOnlyList`1<IOperation> callChainOperations);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ITypeSymbol get_HelperClass();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IOperation> get_Prefixes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IOperation get_Root();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IOperation> get_Suffixes();
    public TextSpan get_Span();
    public String[] GetPrefixesNames();
    public String[] GetSuffixesNames();
    public IOperation GetPrefix(string name);
    public IOperation GetSuffix(string name);
    [NullableContextAttribute("2")]
public string GetConstraintName();
    [NullableContextAttribute("2")]
public IOperation GetExpectedArgument();
    [NullableContextAttribute("2")]
public IMethodSymbol GetConstraintMethod();
    public bool HasUnknownExpressions();
    public bool HasIncompatiblePrefixes();
    public Location GetLocation();
    public virtual string ToString();
    private static ValueTuple`4<ITypeSymbol, IReadOnlyCollection`1<IOperation>, IOperation, IReadOnlyCollection`1<IOperation>> SplitExpressions(IReadOnlyList`1<IOperation> callChainOperations);
    private static bool ReturnsConstraint(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ParallelizableUsage.ParallelizableUsageAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor scopeSelfNoEffectOnAssemblyUsage;
    private static DiagnosticDescriptor scopeChildrenOnNonParameterizedTest;
    private static DiagnosticDescriptor scopeFixturesOnTest;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ParallelizableUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeCompilation(CompilationAnalysisContext context);
    private static void AnalyzeMethod(SymbolAnalysisContext context, INamedTypeSymbol parallelizableAttribute);
    private static bool TryGetAttributeEnumValue(Compilation compilation, ISymbol symbol, INamedTypeSymbol parallelizableAttributeType, Int32& enumValue, AttributeData& attributeData);
    private static Nullable`1<int> GetOptionalEnumValue(AttributeData attributeData);
    private static bool IsNonParameterizedTestMethod(SymbolAnalysisContext context, IMethodSymbol methodSymbol);
    private static bool HasFlag(int enumValue, int flag);
    private static bool HasExactFlag(int enumValue, int flag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NUnit.Analyzers.ParallelizableUsage.ParallelizableUsageAnalyzerConstants : object {
    internal static string ParallelScopeSelfNoEffectOnAssemblyTitle;
    internal static string ParallelScopeSelfNoEffectOnAssemblyMessage;
    internal static string ParallelScopeSelfNoEffectOnAssemblyDescription;
    internal static string ParallelScopeChildrenOnNonParameterizedTestMethodTitle;
    internal static string ParallelScopeChildrenOnNonParameterizedTestMethodMessage;
    internal static string ParallelScopeChildrenOnNonParameterizedTestMethodDescription;
    internal static string ParallelScopeFixturesOnTestMethodTitle;
    internal static string ParallelScopeFixturesOnTestMethodMessage;
    internal static string ParallelScopeFixturesOnTestMethodDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.SameActualExpectedValue.SameActualExpectedValueAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SameActualExpectedValueAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.SameActualExpectedValue.SameActualExpectedValueAnalyzerConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.SameAsIncompatibleTypes.SameAsIncompatibleTypesAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SameAsIncompatibleTypesAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    [NullableContextAttribute("2")]
private static void CheckActualVsExpectedOperation(OperationAnalysisContext context, IOperation actualOperation, IOperation expectedOperation);
    private static bool CanBeSameType(ITypeSymbol actualType, ITypeSymbol expectedType, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NUnit.Analyzers.SameAsIncompatibleTypes.SameAsIncompatibleTypesConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.SameAsOnValueTypes.SameAsOnValueTypesAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SameAsOnValueTypesAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    [NullableContextAttribute("2")]
private static void CheckActualVsExpectedOperation(OperationAnalysisContext context, IOperation actualOperation, IOperation expectedOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.SameAsOnValueTypes.SameAsOnValueTypesCodeFix : CodeFixProvider {
    internal static string UseIsEqualToDescription;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.SameAsOnValueTypes.SameAsOnValueTypesCodeFix/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.SameAsOnValueTypes.SameAsOnValueTypesConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.SimplifyValues.SimplifyValuesAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor simplifyValues;
    private static ImmutableHashSet`1<string> nonCombinatorialAttributes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SimplifyValuesAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeParameter(SymbolAnalysisContext symbolContext, INamedTypeSymbol valuesType);
    private static HandledType GetHandledCase(ITypeSymbol typeSymbol);
    private static bool TryGetTypeArgumentFromNullableType(ITypeSymbol typeSymbol, ITypeSymbol& typeArgument);
    private static HashSet`1<object> GetAllPossibleEnumValuesOrDefault(ITypeSymbol typeSymbol);
    private static HashSet`1<object> GetAllPossibleNullableEnumValuesOrDefault(ITypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.SimplifyValues.SimplifyValuesAnalyzerConstants : object {
    internal static string SimplifyValuesTitle;
    internal static string SimplifyValuesMessage;
    internal static string SimplifyValuesDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.SimplifyValues.SimplifyValuesCodeFix : CodeFixProvider {
    internal static string SimplifyValuesTitle;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.SimplifyValues.SimplifyValuesCodeFix/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.SomeItemsIncompatibleTypes.SomeItemsIncompatibleTypesAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SomeItemsIncompatibleTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static bool IsDoesContain(ConstraintExpressionPart constraintPart);
    private static bool IsContainsItem(ConstraintExpressionPart constraintPart);
    private static string ConstraintDiagnosticDescription(ConstraintExpressionPart constraintPart);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.SomeItemsIncompatibleTypes.SomeItemsIncompatibleTypesConstants : object {
    public static string Title;
    public static string Message;
    public static string Description;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class NUnit.Analyzers.SourceCommon.SourceAttributeInformation : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStringLiteral>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <NumberOfMethodParameters>k__BackingField;
    [NullableAttribute("1")]
public INamedTypeSymbol SourceType { get; }
    public string SourceName { get; }
    public SyntaxNode SyntaxNode { get; }
    public bool IsStringLiteral { get; }
    public Nullable`1<int> NumberOfMethodParameters { get; }
    public SourceAttributeInformation(INamedTypeSymbol sourceType, string sourceName, SyntaxNode syntaxNode, bool isStringLiteral, Nullable`1<int> numberOfMethodParameters);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_SourceType();
    [CompilerGeneratedAttribute]
public string get_SourceName();
    [CompilerGeneratedAttribute]
public SyntaxNode get_SyntaxNode();
    [CompilerGeneratedAttribute]
public bool get_IsStringLiteral();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_NumberOfMethodParameters();
}
internal static class NUnit.Analyzers.SourceCommon.SourceCommonConstants : object {
    [NullableAttribute("1")]
internal static string PropertyKeyNameOfTarget;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NUnit.Analyzers.SourceCommon.SourceHelpers : object {
    public static void ReportToUseNameOfIfApplicable(SyntaxNodeAnalysisContext context, SyntaxNode syntaxNode, SourceAttributeInformation attributeInfo, ISymbol symbol, string stringConstant, DiagnosticDescriptor considerNameOfDescriptor);
    public static SourceAttributeInformation GetSourceAttributeInformation(SyntaxNodeAnalysisContext context, INamedTypeSymbol valueSourceType, string typeName);
    public static ISymbol GetMember(SourceAttributeInformation attributeInformation);
    [ExtensionAttribute]
public static ISymbol GetMember(INamedTypeSymbol typeSymbol, string name);
    public static SourceAttributeInformation ExtractInfoFromAttribute(SyntaxNodeAnalysisContext context, AttributeSyntax attributeSyntax);
    [NullableContextAttribute("2")]
private static SourceAttributeInformation ExtractElementsInAttribute(SyntaxNodeAnalysisContext context, INamedTypeSymbol sourceType, ImmutableArray`1<AttributeArgumentSyntax> positionalArguments, int sourceNameIndex);
    private static Nullable`1<ValueTuple`3<SyntaxNode, string, bool>> GetSyntaxStringConstantAndType(SyntaxNodeAnalysisContext context, ImmutableArray`1<AttributeArgumentSyntax> arguments, int index);
    private static Nullable`1<int> GetNumberOfParametersToMethod(AttributeArgumentSyntax attributeArgumentSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.SourceCommon.UseNameofFix : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.SourceCommon.UseNameofFix/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.StringAssertUsage.StringAssertUsageAnalyzer : BaseAssertionAnalyzer {
    internal static ImmutableDictionary`2<string, string> StringAssertToConstraint;
    private static DiagnosticDescriptor stringAssertDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StringAssertUsageAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool IsAssert(bool hasClassicAssert, IInvocationOperation invocationOperation);
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class NUnit.Analyzers.StringAssertUsage.StringAssertUsageCodeFix : ClassicModelAssertUsageCodeFix {
    internal static ImmutableDictionary`2<string, string> StringAssertToExpectedParameterName;
    private static ImmutableDictionary`2<string, Constraints> StringAssertToConstraints;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static StringAssertUsageCodeFix();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ValueTuple`2<ArgumentSyntax, ArgumentSyntax> ConstructActualAndConstraintArguments(Diagnostic diagnostic, IReadOnlyDictionary`2<string, ArgumentSyntax> argumentNamesToArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NUnit.Analyzers.StringAssertUsage.StringAssertUsageConstants : object {
    internal static string StringAssertTitle;
    internal static string StringAssertMessage;
    internal static string StringAssertDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.StringConstraintWrongActualType.StringConstraintWrongActualTypeAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    private static HashSet`1<string> SupportedConstraints;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StringConstraintWrongActualTypeAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.StringConstraintWrongActualType.StringConstraintWrongActualTypeConstants : object {
    public static string Title;
    public static string Message;
    public static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.TestCaseSourceUsage.TestCaseSourceUsageConstants : object {
    internal static string ConsiderNameOfInsteadOfStringConstantAnalyzerTitle;
    internal static string ConsiderNameOfInsteadOfStringConstantMessage;
    internal static string ConsiderNameOfInsteadOfStringConstantDescription;
    internal static string SourceTypeNotIEnumerableTitle;
    internal static string SourceTypeNotIEnumerableMessage;
    internal static string SourceTypeNotIEnumerableDescription;
    internal static string SourceTypeNoDefaultConstructorTitle;
    internal static string SourceTypeNoDefaultConstructorMessage;
    internal static string SourceTypeNoDefaultConstructorDescription;
    internal static string SourceIsNotStaticTitle;
    internal static string SourceIsNotStaticMessage;
    internal static string SourceIsNotStaticDescription;
    internal static string MismatchInNumberOfParametersTitle;
    internal static string MismatchInNumberOfParametersMessage;
    internal static string MismatchInNumberOfParametersDescription;
    internal static string SourceDoesNotReturnIEnumerableTitle;
    internal static string SourceDoesNotReturnIEnumerableMessage;
    internal static string SourceDoesNotReturnIEnumerableDescription;
    internal static string TestCaseSourceSuppliesParametersTitle;
    internal static string TestCaseSourceSuppliesParametersMessage;
    internal static string TestCaseSourceSuppliesParametersDescription;
    internal static string MismatchInNumberOfTestMethodParametersTitle;
    internal static string MismatchInNumberOfTestMethodParametersMessage;
    internal static string MismatchInNumberOfTestMethodParametersDescription;
    internal static string MismatchWithTestMethodParameterTypeTitle;
    internal static string MismatchWithTestMethodParameterTypeMessage;
    internal static string MismatchWithTestMethodParameterTypeDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.TestCaseSourceUsage.TestCaseSourceUsesStringAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor missingSourceDescriptor;
    private static DiagnosticDescriptor considerNameOfDescriptor;
    private static DiagnosticDescriptor sourceTypeNotIEnumerableDescriptor;
    private static DiagnosticDescriptor sourceTypeNoDefaultConstructorDescriptor;
    private static DiagnosticDescriptor sourceNotStaticDescriptor;
    private static DiagnosticDescriptor mismatchInNumberOfParameters;
    private static DiagnosticDescriptor sourceDoesNotReturnIEnumerable;
    private static DiagnosticDescriptor parametersSuppliedToFieldOrProperty;
    private static DiagnosticDescriptor mismatchInNumberOfTestMethodParameters;
    private static DiagnosticDescriptor mismatchWithTestMethodParameterType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestCaseSourceUsesStringAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    [NullableContextAttribute("2")]
private static void AnalyzeAttribute(SyntaxNodeAnalysisContext context, INamedTypeSymbol testCaseSourceAttribute, INamedTypeSymbol cancelAfterType, INamedTypeSymbol cancellationTokenType);
    private static ITypeSymbol ReportIfSymbolNotIEnumerable(SyntaxNodeAnalysisContext context, SyntaxNode syntaxNode, ITypeSymbol typeSymbol);
    private static void ReportIfParametersSupplied(SyntaxNodeAnalysisContext context, SyntaxNode syntaxNode, Nullable`1<int> numberOfMethodParameters, string kind);
    private static bool IsOrDerivesFrom(ITypeSymbol type, ITypeSymbol baseType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.TestCaseUsage.TestCaseUsageAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor notEnoughArguments;
    private static DiagnosticDescriptor parameterTypeMismatch;
    private static DiagnosticDescriptor tooManyArguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestCaseUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    [NullableContextAttribute("2")]
private static void AnalyzeMethod(SymbolAnalysisContext context, INamedTypeSymbol testCaseType, INamedTypeSymbol cancelAfterType, INamedTypeSymbol cancellationTokenType);
    private static bool IsSoleParameterAnObjectArray(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
private static bool IsTypeAnObjectArray(ITypeSymbol typeSymbol);
    private static ValueTuple`3<ITypeSymbol, string, ITypeSymbol> GetParameterType(ImmutableArray`1<IParameterSymbol> methodParameter, int position);
    [NullableContextAttribute("0")]
private static void AnalyzePositionalArgumentsAndParameters(SymbolAnalysisContext context, AttributeData attribute, ImmutableArray`1<TypedConstant> attributePositionalArguments, ImmutableArray`1<IParameterSymbol> methodParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.TestCaseUsage.TestCaseUsageAnalyzerConstants : object {
    internal static string NotEnoughArgumentsTitle;
    internal static string NotEnoughArgumentsMessage;
    internal static string NotEnoughArgumentsDescription;
    internal static string TooManyArgumentsTitle;
    internal static string TooManyArgumentsMessage;
    internal static string TooManyArgumentsDescription;
    internal static string ParameterTypeMismatchTitle;
    internal static string ParameterTypeMismatchMessage;
    internal static string ParameterTypeMismatchDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.TestContextWriteIsObsolete.TestContextWriteIsObsoleteAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestContextWriteIsObsoleteAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeInvocation(INamedTypeSymbol testContextType, OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.TestContextWriteIsObsolete.TestContextWriteIsObsoleteAnalyzerConstants : object {
    public static string Title;
    public static string Message;
    public static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.TestContextWriteIsObsolete.TestContextWriteIsObsoleteCodeFix : CodeFixProvider {
    internal static string InsertOutDescription;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.TestContextWriteIsObsolete.TestContextWriteIsObsoleteCodeFix/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.TestMethodAccessibilityLevel.TestMethodAccessibilityLevelAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor testMethodIsNotPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestMethodAccessibilityLevelAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethod(SymbolAnalysisContext context);
    private static bool IsTestMethod(Compilation compilation, IMethodSymbol methodSymbol);
    private static bool IsSetUpTearDownMethod(Compilation compilation, IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.TestMethodAccessibilityLevel.TestMethodAccessibilityLevelCodeFix : CodeFixProvider {
    internal static string MakeTestMethodPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.TestMethodAccessibilityLevel.TestMethodAccessibilityLevelCodeFix/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static SyntaxTokenList ReplaceModifiersWithPublic(MethodDeclarationSyntax originalExpression);
    private static SyntaxTokenList AddPublicModifier(MethodDeclarationSyntax originalExpression);
    private static TypeSyntax StripLeadingTriviaFromReturnType(MethodDeclarationSyntax methodDeclarationSyntax);
    private static bool HasExplicitNonPublicAccessModifier(MethodDeclarationSyntax methodDeclarationSyntax);
    private static bool IsNonPublicAccessModifier(SyntaxToken syntaxToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.TestMethodAccessibilityLevel.TestMethodAccessibilityLevelConstants : object {
    internal static string TestMethodIsNotPublicTitle;
    internal static string TestMethodIsNotPublicMessage;
    internal static string TestMethodIsNotPublicDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.TestMethodUsage.TestMethodUsageAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor expectedResultTypeMismatch;
    private static DiagnosticDescriptor specifiedExpectedResultForVoid;
    private static DiagnosticDescriptor noExpectedResultButNonVoidReturnType;
    private static DiagnosticDescriptor asyncNoExpectedResultAndVoidReturnType;
    private static DiagnosticDescriptor asyncNoExpectedResultAndNonTaskReturnType;
    private static DiagnosticDescriptor asyncExpectedResultButReturnTypeNotGenericTask;
    private static DiagnosticDescriptor simpleTestHasParameters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestMethodUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeMethod(SymbolAnalysisContext context, INamedTypeSymbol testCaseType, INamedTypeSymbol testType, INamedTypeSymbol cancelAfterType, INamedTypeSymbol cancellationTokenType);
    private static bool HasITestBuilderAttribute(Compilation compilation, ImmutableArray`1<AttributeData> attributes);
    private static bool HasIParameterDataSourceAttribute(Compilation compilation, ImmutableArray`1<AttributeData> attributes);
    private static void AnalyzeExpectedResult(SymbolAnalysisContext context, AttributeData attribute, IMethodSymbol methodSymbol);
    private static void ExpectedResultSupplied(SymbolAnalysisContext context, IMethodSymbol methodSymbol, AttributeData attributeData, TypedConstant expectedResultNamedArgument);
    private static void ReportIfExpectedResultTypeCannotBeAssignedToReturnType(SymbolAnalysisContext& context, AttributeData attributeData, TypedConstant expectedResultNamedArgument, ITypeSymbol typeSymbol);
    private static void NoExpectedResultSupplied(SymbolAnalysisContext context, IMethodSymbol methodSymbol, AttributeData attributeData);
    private static Location GetExpectedArgumentLocation(AttributeData attributeData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.TestMethodUsage.TestMethodUsageAnalyzerConstants : object {
    internal static string ExpectedResultTypeMismatchTitle;
    internal static string ExpectedResultTypeMismatchMessage;
    internal static string ExpectedResultTypeMismatchDescription;
    internal static string SpecifiedExpectedResultForVoidMethodTitle;
    internal static string SpecifiedExpectedResultForVoidMethodMessage;
    internal static string SpecifiedExpectedResultForVoidMethodDescription;
    internal static string NoExpectedResultButNonVoidReturnTypeTitle;
    internal static string NoExpectedResultButNonVoidReturnTypeMessage;
    internal static string NoExpectedResultButNonVoidReturnTypeDescription;
    internal static string AsyncNoExpectedResultAndVoidReturnTypeTitle;
    internal static string AsyncNoExpectedResultAndVoidReturnTypeMessage;
    internal static string AsyncNoExpectedResultAndVoidReturnTypeDescription;
    internal static string AsyncNoExpectedResultAndNonTaskReturnTypeTitle;
    internal static string AsyncNoExpectedResultAndNonTaskReturnTypeMessage;
    internal static string AsyncNoExpectedResultAndNonTaskReturnTypeDescription;
    internal static string AsyncExpectedResultAndNonGenericTaskReturnTypeTitle;
    internal static string AsyncExpectedResultAndNonGenericTaskReturnTypeMessage;
    internal static string AsyncExpectedResultAndNonGenericTaskReturnTypeDescription;
    internal static string SimpleTestMethodHasParametersTitle;
    internal static string SimpleTestMethodHasParametersMessage;
    internal static string SimpleTestMethodHasParametersDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.UpdateStringFormatToInterpolatableString.UpdateStringFormatToInterpolatableStringAnalyzer : BaseAssertionAnalyzer {
    private static String[] ObsoleteParamsMethods;
    private static DiagnosticDescriptor updateStringFormatToInterpolatableString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UpdateStringFormatToInterpolatableStringAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual bool IsAssert(bool hasClassicAssert, IInvocationOperation invocationOperation);
    protected virtual void AnalyzeAssertInvocation(Version nunitVersion, OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static void AnalyzeNUnit3AssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static void AnalyzeNUnit4AssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static void ReportDiagnostic(OperationAnalysisContext context, IInvocationOperation assertOperation, string methodName, int minimumNumberOfArguments, bool argsIsArray);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeNUnit3AssertInvocation>g__IsNonEmptyParamsArrayArgument|6_0(IArgumentOperation argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class NUnit.Analyzers.UpdateStringFormatToInterpolatableString.UpdateStringFormatToInterpolatableStringCodeFix : CodeFixProvider {
    internal static string UpdateStringFormatToInterpolatableStringDescription;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.UpdateStringFormatToInterpolatableString.UpdateStringFormatToInterpolatableStringCodeFix/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.UpdateStringFormatToInterpolatableString.UpdateStringFormatToInterpolatableStringConstants : object {
    internal static string UpdateStringFormatToInterpolatableStringTitle;
    internal static string UpdateStringFormatToInterpolatableStringMessage;
    internal static string UpdateStringFormatToInterpolatableStringDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.UseAssertMultiple.UseAssertMultipleAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseAssertMultipleAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    internal static bool IsIndependent(HashSet`1<string> previousArguments, string argument);
    internal static void Add(HashSet`1<string> previousArguments, string argument);
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static bool IsIndependentAssert(HashSet`1<string> previousArguments, IOperation statement);
    private static IInvocationOperation TryGetAssertThatOperation(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.UseAssertMultiple.UseAssertMultipleCodeFix : CodeFixProvider {
    internal static string WrapWithAssertMultiple;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.UseAssertMultiple.UseAssertMultipleCodeFix/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.UseAssertMultiple.UseAssertMultipleConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.UseCollectionConstraint.UseCollectionConstraintAnalyzer : BaseAssertionAnalyzer {
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseCollectionConstraintAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <AnalyzeAssertInvocation>g__IsInteger|4_0(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.UseCollectionConstraint.UseCollectionConstraintCodeFix : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.UseCollectionConstraint.UseCollectionConstraintCodeFix/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("NUnit.Analyzers.UseCollectionConstraint.UseCollectionConstraintCodeFix/<IsCollectionType>d__4")]
private static Task`1<bool> IsCollectionType(CodeFixContext context, ExpressionSyntax expression);
    private static MemberAccessExpressionSyntax MatchWithEmpty(MemberAccessExpressionSyntax constraintMemberExpression, InvocationExpressionSyntax constraintExpression, ExpressionSyntax innerConstraintExpression);
    private static bool IsNot(MemberAccessExpressionSyntax constraintMemberExpression);
    private static ExpressionSyntax FindLeftMostTerm(MemberAccessExpressionSyntax constraintMemberExpression);
    private static bool IsInvocationTo(InvocationExpressionSyntax invocationExpression, string name, string value);
    [CompilerGeneratedAttribute]
internal static bool <IsNot>g__IsNot|6_0(SimpleNameSyntax simpleName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.UseCollectionConstraint.UseCollectionConstraintConstants : object {
    internal static string Title;
    internal static string MessageFormat;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ValueSourceUsage.ValueSourceUsageAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor missingSourceDescriptor;
    private static DiagnosticDescriptor considerNameOfDescriptor;
    private static DiagnosticDescriptor sourceNotStaticDescriptor;
    private static DiagnosticDescriptor methodExpectParameters;
    private static DiagnosticDescriptor sourceDoesNotReturnIEnumerable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ValueSourceUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeAttribute(SyntaxNodeAnalysisContext context, INamedTypeSymbol valueSourceType);
    private static void ReportIfSymbolNotIEnumerable(SyntaxNodeAnalysisContext context, ISymbol symbol, SyntaxNode syntaxNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ValueSourceUsage.ValueSourceUsageConstants : object {
    internal static string SourceDoesNotSpecifyAnExistingMemberTitle;
    internal static string SourceDoesNotSpecifyAnExistingMemberMessage;
    internal static string SourceDoesNotSpecifyAnExistingMemberDescription;
    internal static string ConsiderNameOfInsteadOfStringConstantAnalyzerTitle;
    internal static string ConsiderNameOfInsteadOfStringConstantMessage;
    internal static string ConsiderNameOfInsteadOfStringConstantDescription;
    internal static string SourceIsNotStaticTitle;
    internal static string SourceIsNotStaticMessage;
    internal static string SourceIsNotStaticDescription;
    internal static string MethodExpectParametersTitle;
    internal static string MethodExpectParametersMessage;
    internal static string MethodExpectParametersDescription;
    internal static string SourceDoesNotReturnIEnumerableTitle;
    internal static string SourceDoesNotReturnIEnumerableMessage;
    internal static string SourceDoesNotReturnIEnumerableDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.ValuesUsage.ValuesUsageAnalyzer : DiagnosticAnalyzer {
    private static DiagnosticDescriptor parameterTypeMismatch;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ValuesUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeParameter(SymbolAnalysisContext symbolContext, INamedTypeSymbol valuesType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.ValuesUsage.ValuesUsageAnalyzerConstants : object {
    internal static string ParameterTypeMismatchTitle;
    internal static string ParameterTypeMismatchMessage;
    internal static string ParameterTypeMismatchDescription;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class NUnit.Analyzers.WithinUsage.WithinUsageAnalyzer : BaseAssertionAnalyzer {
    private static String[] SupportedIsMethods;
    private static DiagnosticDescriptor descriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static WithinUsageAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void AnalyzeAssertInvocation(OperationAnalysisContext context, IInvocationOperation assertOperation);
    private static bool IsTypeSupported(ITypeSymbol type, HashSet`1<ITypeSymbol> checkedTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NUnit.Analyzers.WithinUsage.WithinUsageAnalyzerConstants : object {
    internal static string Title;
    internal static string Message;
    internal static string Description;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class NUnit.Analyzers.WithinUsage.WithinUsageCodeFix : CodeFixProvider {
    internal static string RemoveWithinDescription;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("NUnit.Analyzers.WithinUsage.WithinUsageCodeFix/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
