internal class TestCentric.ArgumentNullOrEmptyException : ArgumentException {
    public ArgumentNullOrEmptyException(string paramName);
}
[DefaultMemberAttribute("Item")]
public class TestCentric.Collections.Generic.Collection`1 : object {
    internal T[] items;
    internal int size;
    private int version;
    public int Count { get; }
    public T Item { get; public set; }
    public int Capacity { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Collection`1(int capacity);
    public Collection`1(ICollection`1<T> items);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public int get_Capacity();
    public void set_Capacity(int value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    private void CheckIndex(int index);
    private void Shift(int start, int delta);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnSet(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnClear();
    internal virtual void Grow(int desired);
    protected void Resize(int new_size);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
internal static class TestCentric.Disposable : object {
    public static Disposable`1<T> Owned(T value);
    public static Disposable`1<T> NotOwned(T value);
}
internal class TestCentric.Disposable`1 : ValueType {
    internal T value;
    private bool owned;
    public Disposable`1(T value, bool owned);
    public sealed virtual void Dispose();
}
internal static class TestCentric.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
public class TestCentric.Metadata.ArrayDimension : ValueType {
    private Nullable`1<int> lower_bound;
    private Nullable`1<int> upper_bound;
    public Nullable`1<int> LowerBound { get; public set; }
    public Nullable`1<int> UpperBound { get; public set; }
    public bool IsSized { get; }
    public ArrayDimension(Nullable`1<int> lowerBound, Nullable`1<int> upperBound);
    public Nullable`1<int> get_LowerBound();
    public void set_LowerBound(Nullable`1<int> value);
    public Nullable`1<int> get_UpperBound();
    public void set_UpperBound(Nullable`1<int> value);
    public bool get_IsSized();
    public virtual string ToString();
}
public class TestCentric.Metadata.ArrayType : TypeSpecification {
    private Collection`1<ArrayDimension> dimensions;
    public Collection`1<ArrayDimension> Dimensions { get; }
    public int Rank { get; }
    public bool IsVector { get; }
    public bool IsValueType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsArray { get; }
    public ArrayType(TypeReference type);
    public ArrayType(TypeReference type, int rank);
    public Collection`1<ArrayDimension> get_Dimensions();
    public int get_Rank();
    public bool get_IsVector();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsArray();
}
[FlagsAttribute]
public enum TestCentric.Metadata.AssemblyAttributes : Enum {
    public UInt32 value__;
    public static AssemblyAttributes PublicKey;
    public static AssemblyAttributes SideBySideCompatible;
    public static AssemblyAttributes Retargetable;
    public static AssemblyAttributes WindowsRuntime;
    public static AssemblyAttributes DisableJITCompileOptimizer;
    public static AssemblyAttributes EnableJITCompileTracking;
}
public class TestCentric.Metadata.AssemblyDefinition : object {
    private AssemblyNameDefinition name;
    internal ModuleDefinition main_module;
    private Collection`1<ModuleDefinition> modules;
    private Collection`1<CustomAttribute> custom_attributes;
    public AssemblyNameDefinition Name { get; public set; }
    public string FullName { get; }
    public MetadataToken MetadataToken { get; public set; }
    public Collection`1<ModuleDefinition> Modules { get; }
    public ModuleDefinition MainModule { get; }
    public MethodDefinition EntryPoint { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public AssemblyNameDefinition get_Name();
    public void set_Name(AssemblyNameDefinition value);
    public string get_FullName();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public Collection`1<ModuleDefinition> get_Modules();
    public ModuleDefinition get_MainModule();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual void Dispose();
    public static AssemblyDefinition ReadAssembly(string fileName);
    public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters);
    public static AssemblyDefinition ReadAssembly(Stream stream);
    public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters);
    private static AssemblyDefinition ReadAssembly(ModuleDefinition module);
}
public enum TestCentric.Metadata.AssemblyHashAlgorithm : Enum {
    public UInt32 value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm Reserved;
    public static AssemblyHashAlgorithm SHA1;
}
public class TestCentric.Metadata.AssemblyNameDefinition : AssemblyNameReference {
    public Byte[] Hash { get; }
    public AssemblyNameDefinition(string name, Version version);
    public virtual Byte[] get_Hash();
}
public class TestCentric.Metadata.AssemblyNameReference : object {
    private string name;
    private string culture;
    private Version version;
    private UInt32 attributes;
    private Byte[] public_key;
    private Byte[] public_key_token;
    private AssemblyHashAlgorithm hash_algorithm;
    private Byte[] hash;
    internal MetadataToken token;
    private string full_name;
    public string Name { get; public set; }
    public string Culture { get; public set; }
    public Version Version { get; public set; }
    public AssemblyAttributes Attributes { get; public set; }
    public bool HasPublicKey { get; public set; }
    public bool IsSideBySideCompatible { get; public set; }
    public bool IsRetargetable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public Byte[] PublicKey { get; public set; }
    public Byte[] PublicKeyToken { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public string FullName { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] Hash { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public AssemblyNameReference(string name, Version version);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public string get_Culture();
    public void set_Culture(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyAttributes get_Attributes();
    public void set_Attributes(AssemblyAttributes value);
    public bool get_HasPublicKey();
    public void set_HasPublicKey(bool value);
    public bool get_IsSideBySideCompatible();
    public void set_IsSideBySideCompatible(bool value);
    public bool get_IsRetargetable();
    public void set_IsRetargetable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public Byte[] get_PublicKey();
    public void set_PublicKey(Byte[] value);
    public Byte[] get_PublicKeyToken();
    public void set_PublicKeyToken(Byte[] value);
    private Byte[] HashPublicKey();
    public virtual MetadataScopeType get_MetadataScopeType();
    public string get_FullName();
    public static AssemblyNameReference Parse(string fullName);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public virtual Byte[] get_Hash();
    public virtual void set_Hash(Byte[] value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
public class TestCentric.Metadata.AssemblyResolutionException : FileNotFoundException {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolutionException(AssemblyNameReference reference);
    public AssemblyResolutionException(AssemblyNameReference reference, Exception innerException);
    private AssemblyResolutionException(SerializationInfo info, StreamingContext context);
    public AssemblyNameReference get_AssemblyReference();
}
public class TestCentric.Metadata.AssemblyResolveEventArgs : EventArgs {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolveEventArgs(AssemblyNameReference reference);
    public AssemblyNameReference get_AssemblyReference();
}
public class TestCentric.Metadata.AssemblyResolveEventHandler : MulticastDelegate {
    public AssemblyResolveEventHandler(object object, IntPtr method);
    public virtual AssemblyDefinition Invoke(object sender, AssemblyNameReference reference);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyNameReference reference, AsyncCallback callback, object object);
    public virtual AssemblyDefinition EndInvoke(IAsyncResult result);
}
public abstract class TestCentric.Metadata.BaseAssemblyResolver : object {
    private static bool on_mono;
    private Collection`1<string> directories;
    [CompilerGeneratedAttribute]
private AssemblyResolveEventHandler ResolveFailure;
    private static BaseAssemblyResolver();
    public void AddSearchDirectory(string directory);
    public void RemoveSearchDirectory(string directory);
    public String[] GetSearchDirectories();
    [CompilerGeneratedAttribute]
public void add_ResolveFailure(AssemblyResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ResolveFailure(AssemblyResolveEventHandler value);
    private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    protected virtual AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable`1<string> directories, ReaderParameters parameters);
    private static bool IsZero(Version version);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class TestCentric.Metadata.ByReferenceType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsByReference { get; }
    public ByReferenceType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsByReference();
}
public class TestCentric.Metadata.CallSite : object {
    private MethodReference signature;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; }
    public MetadataToken MetadataToken { get; public set; }
    public string FullName { get; }
    public CallSite(TypeReference returnType);
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ModuleDefinition get_Module();
    public IMetadataScope get_Scope();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public string get_FullName();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class TestCentric.Metadata.CecilExtensions : object {
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider provider, string fullName);
    [ExtensionAttribute]
public static CustomAttribute GetAttribute(ICustomAttributeProvider provider, string fullName);
    [IteratorStateMachineAttribute("TestCentric.Metadata.CecilExtensions/<GetAttributes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<CustomAttribute> GetAttributes(ICustomAttributeProvider provider, string fullName);
    [ExtensionAttribute]
public static bool RequiresX86(AssemblyDefinition assemblyDef);
    [ExtensionAttribute]
public static Version GetRuntimeVersion(AssemblyDefinition assemblyDef);
    [ExtensionAttribute]
public static string GetFrameworkName(AssemblyDefinition assemblyDef);
    [ExtensionAttribute]
public static object GetNamedArgument(CustomAttribute attr, string name);
}
[DebuggerDisplayAttribute("{AttributeType}")]
public class TestCentric.Metadata.CustomAttribute : object {
    internal CustomAttributeValueProjection projection;
    internal UInt32 signature;
    internal bool resolved;
    private MethodReference constructor;
    private Byte[] blob;
    internal Collection`1<CustomAttributeArgument> arguments;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public MethodReference Constructor { get; public set; }
    public TypeReference AttributeType { get; }
    public bool IsResolved { get; }
    public bool HasConstructorArguments { get; }
    public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    internal bool HasImage { get; }
    internal ModuleDefinition Module { get; }
    internal CustomAttribute(UInt32 signature, MethodReference constructor);
    public CustomAttribute(MethodReference constructor);
    public CustomAttribute(MethodReference constructor, Byte[] blob);
    public MethodReference get_Constructor();
    public void set_Constructor(MethodReference value);
    public sealed virtual TypeReference get_AttributeType();
    public bool get_IsResolved();
    public sealed virtual bool get_HasConstructorArguments();
    public sealed virtual Collection`1<CustomAttributeArgument> get_ConstructorArguments();
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    internal bool get_HasImage();
    internal ModuleDefinition get_Module();
    public Byte[] GetBlob();
    private void Resolve();
    [CompilerGeneratedAttribute]
private void <Resolve>b__35_0(CustomAttribute attribute, MetadataReader reader);
}
public class TestCentric.Metadata.CustomAttributeArgument : ValueType {
    private TypeReference type;
    private object value;
    public TypeReference Type { get; }
    public object Value { get; }
    public CustomAttributeArgument(TypeReference type, object value);
    public TypeReference get_Type();
    public object get_Value();
}
public class TestCentric.Metadata.CustomAttributeNamedArgument : ValueType {
    private string name;
    private CustomAttributeArgument argument;
    public string Name { get; }
    public CustomAttributeArgument Argument { get; }
    public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument);
    public string get_Name();
    public CustomAttributeArgument get_Argument();
}
internal class TestCentric.Metadata.CustomAttributeValueProjection : object {
    public AttributeTargets Targets;
    public CustomAttributeValueTreatment Treatment;
    public CustomAttributeValueProjection(AttributeTargets targets, CustomAttributeValueTreatment treatment);
}
internal enum TestCentric.Metadata.CustomAttributeValueTreatment : Enum {
    public int value__;
    public static CustomAttributeValueTreatment None;
    public static CustomAttributeValueTreatment AllowSingle;
    public static CustomAttributeValueTreatment AllowMultiple;
    public static CustomAttributeValueTreatment VersionAttribute;
    public static CustomAttributeValueTreatment DeprecatedAttribute;
}
public class TestCentric.Metadata.DefaultAssemblyResolver : BaseAssemblyResolver {
    private IDictionary`2<string, AssemblyDefinition> cache;
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    protected void RegisterAssembly(AssemblyDefinition assembly);
    protected virtual void Dispose(bool disposing);
}
internal class TestCentric.Metadata.DeferredModuleReader : ModuleReader {
    public DeferredModuleReader(Image image);
    protected virtual void ReadModule();
    [CompilerGeneratedAttribute]
private void <ReadModule>b__1_0(ModuleDefinition _, MetadataReader reader);
}
public class TestCentric.Metadata.ExportedType : object {
    private string namespace;
    private string name;
    private UInt32 attributes;
    private IMetadataScope scope;
    private ModuleDefinition module;
    private int identifier;
    private ExportedType declaring_type;
    internal MetadataToken token;
    public string Namespace { get; public set; }
    public string Name { get; public set; }
    public TypeAttributes Attributes { get; public set; }
    public IMetadataScope Scope { get; public set; }
    public ExportedType DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public int Identifier { get; public set; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsForwarder { get; public set; }
    public string FullName { get; }
    public ExportedType(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Name();
    public void set_Name(string value);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public IMetadataScope get_Scope();
    public void set_Scope(IMetadataScope value);
    public ExportedType get_DeclaringType();
    public void set_DeclaringType(ExportedType value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public int get_Identifier();
    public void set_Identifier(int value);
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public bool get_IsRuntimeSpecialName();
    public void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsForwarder();
    public void set_IsForwarder(bool value);
    public string get_FullName();
    public virtual string ToString();
    public TypeDefinition Resolve();
    internal TypeReference CreateReference();
}
[FlagsAttribute]
public enum TestCentric.Metadata.FieldAttributes : Enum {
    public ushort value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes CompilerControlled;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PInvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
}
public class TestCentric.Metadata.FieldDefinition : FieldReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    private int offset;
    internal int rva;
    private Byte[] initial_value;
    private object constant;
    public bool HasLayoutInfo { get; }
    public int Offset { get; public set; }
    internal FieldDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public int RVA { get; }
    public Byte[] InitialValue { get; public set; }
    public FieldAttributes Attributes { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsInitOnly { get; public set; }
    public bool IsLiteral { get; public set; }
    public bool IsNotSerialized { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public int get_Offset();
    public void set_Offset(int value);
    internal FieldDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(FieldDefinitionProjection value);
    private void ResolveRVA();
    public int get_RVA();
    public Byte[] get_InitialValue();
    public void set_InitialValue(Byte[] value);
    public FieldAttributes get_Attributes();
    public void set_Attributes(FieldAttributes value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsInitOnly();
    public void set_IsInitOnly(bool value);
    public bool get_IsLiteral();
    public void set_IsLiteral(bool value);
    public bool get_IsNotSerialized();
    public void set_IsNotSerialized(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual FieldDefinition Resolve();
}
internal class TestCentric.Metadata.FieldDefinitionProjection : object {
    public FieldAttributes Attributes;
    public FieldDefinitionTreatment Treatment;
    public FieldDefinitionProjection(FieldDefinition field, FieldDefinitionTreatment treatment);
}
internal enum TestCentric.Metadata.FieldDefinitionTreatment : Enum {
    public int value__;
    public static FieldDefinitionTreatment None;
    public static FieldDefinitionTreatment Public;
}
public class TestCentric.Metadata.FieldReference : MemberReference {
    private TypeReference field_type;
    public TypeReference FieldType { get; public set; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public FieldReference(string name, TypeReference fieldType);
    public FieldReference(string name, TypeReference fieldType, TypeReference declaringType);
    public TypeReference get_FieldType();
    public void set_FieldType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual FieldDefinition Resolve();
}
internal enum TestCentric.Metadata.FileAttributes : Enum {
    public UInt32 value__;
    public static FileAttributes ContainsMetaData;
    public static FileAttributes ContainsNoMetaData;
}
public class TestCentric.Metadata.FunctionPointerType : TypeSpecification {
    private MethodReference function;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsFunctionPointer { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual ModuleDefinition get_Module();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
    public virtual TypeDefinition Resolve();
    public virtual TypeReference GetElementType();
}
public class TestCentric.Metadata.GenericInstanceMethod : MethodSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public bool IsGenericInstance { get; }
    private IGenericParameterProvider TestCentric.Metadata.IGenericContext.Method { get; }
    private IGenericParameterProvider TestCentric.Metadata.IGenericContext.Type { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public GenericInstanceMethod(MethodReference method);
    internal GenericInstanceMethod(MethodReference method, int arity);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual bool get_IsGenericInstance();
    private sealed virtual override IGenericParameterProvider TestCentric.Metadata.IGenericContext.get_Method();
    private sealed virtual override IGenericParameterProvider TestCentric.Metadata.IGenericContext.get_Type();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
}
public class TestCentric.Metadata.GenericInstanceType : TypeSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    private IGenericParameterProvider TestCentric.Metadata.IGenericContext.Type { get; }
    public GenericInstanceType(TypeReference type);
    internal GenericInstanceType(TypeReference type, int arity);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    private sealed virtual override IGenericParameterProvider TestCentric.Metadata.IGenericContext.get_Type();
}
public class TestCentric.Metadata.GenericParameter : TypeReference {
    internal int position;
    internal GenericParameterType type;
    internal IGenericParameterProvider owner;
    private ushort attributes;
    private GenericParameterConstraintCollection constraints;
    private Collection`1<CustomAttribute> custom_attributes;
    public GenericParameterAttributes Attributes { get; public set; }
    public int Position { get; }
    public GenericParameterType Type { get; }
    public IGenericParameterProvider Owner { get; }
    public bool HasConstraints { get; }
    public Collection`1<GenericParameterConstraint> Constraints { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public IMetadataScope Scope { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public MethodReference DeclaringMethod { get; }
    public ModuleDefinition Module { get; }
    public string Name { get; }
    public string Namespace { get; public set; }
    public string FullName { get; }
    public bool IsGenericParameter { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    public bool IsNonVariant { get; public set; }
    public bool IsCovariant { get; public set; }
    public bool IsContravariant { get; public set; }
    public bool HasReferenceTypeConstraint { get; public set; }
    public bool HasNotNullableValueTypeConstraint { get; public set; }
    public bool HasDefaultConstructorConstraint { get; public set; }
    public GenericParameter(IGenericParameterProvider owner);
    public GenericParameter(string name, IGenericParameterProvider owner);
    internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module);
    public GenericParameterAttributes get_Attributes();
    public void set_Attributes(GenericParameterAttributes value);
    public int get_Position();
    public GenericParameterType get_Type();
    public IGenericParameterProvider get_Owner();
    public bool get_HasConstraints();
    public Collection`1<GenericParameterConstraint> get_Constraints();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public MethodReference get_DeclaringMethod();
    public virtual ModuleDefinition get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public bool get_IsNonVariant();
    public void set_IsNonVariant(bool value);
    public bool get_IsCovariant();
    public void set_IsCovariant(bool value);
    public bool get_IsContravariant();
    public void set_IsContravariant(bool value);
    public bool get_HasReferenceTypeConstraint();
    public void set_HasReferenceTypeConstraint(bool value);
    public bool get_HasNotNullableValueTypeConstraint();
    public void set_HasNotNullableValueTypeConstraint(bool value);
    public bool get_HasDefaultConstructorConstraint();
    public void set_HasDefaultConstructorConstraint(bool value);
    private static ElementType ConvertGenericParameterType(GenericParameterType type);
    public virtual TypeDefinition Resolve();
}
[FlagsAttribute]
public enum TestCentric.Metadata.GenericParameterAttributes : Enum {
    public ushort value__;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes NonVariant;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
internal class TestCentric.Metadata.GenericParameterCollection : Collection`1<GenericParameter> {
    private IGenericParameterProvider owner;
    internal GenericParameterCollection(IGenericParameterProvider owner);
    internal GenericParameterCollection(IGenericParameterProvider owner, int capacity);
    protected virtual void OnAdd(GenericParameter item, int index);
    protected virtual void OnInsert(GenericParameter item, int index);
    protected virtual void OnSet(GenericParameter item, int index);
    private void UpdateGenericParameter(GenericParameter item, int index);
    protected virtual void OnRemove(GenericParameter item, int index);
}
public class TestCentric.Metadata.GenericParameterConstraint : object {
    internal GenericParameter generic_parameter;
    internal MetadataToken token;
    private TypeReference constraint_type;
    private Collection`1<CustomAttribute> custom_attributes;
    public TypeReference ConstraintType { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MetadataToken MetadataToken { get; public set; }
    internal GenericParameterConstraint(TypeReference constraintType, MetadataToken token);
    public GenericParameterConstraint(TypeReference constraintType);
    public TypeReference get_ConstraintType();
    public void set_ConstraintType(TypeReference value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
}
internal class TestCentric.Metadata.GenericParameterConstraintCollection : Collection`1<GenericParameterConstraint> {
    private GenericParameter generic_parameter;
    internal GenericParameterConstraintCollection(GenericParameter genericParameter);
    internal GenericParameterConstraintCollection(GenericParameter genericParameter, int length);
    protected virtual void OnAdd(GenericParameterConstraint item, int index);
    protected virtual void OnInsert(GenericParameterConstraint item, int index);
    protected virtual void OnSet(GenericParameterConstraint item, int index);
    protected virtual void OnRemove(GenericParameterConstraint item, int index);
}
public enum TestCentric.Metadata.GenericParameterType : Enum {
    public int value__;
    public static GenericParameterType Type;
    public static GenericParameterType Method;
}
public interface TestCentric.Metadata.IAssemblyResolver {
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
}
public interface TestCentric.Metadata.IConstantProvider {
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public abstract virtual bool get_HasConstant();
    public abstract virtual void set_HasConstant(bool value);
    public abstract virtual object get_Constant();
    public abstract virtual void set_Constant(object value);
}
public interface TestCentric.Metadata.ICustomAttribute {
    public TypeReference AttributeType { get; }
    public bool HasFields { get; }
    public bool HasProperties { get; }
    public bool HasConstructorArguments { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public abstract virtual TypeReference get_AttributeType();
    public abstract virtual bool get_HasFields();
    public abstract virtual bool get_HasProperties();
    public abstract virtual bool get_HasConstructorArguments();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    public abstract virtual Collection`1<CustomAttributeArgument> get_ConstructorArguments();
}
public interface TestCentric.Metadata.ICustomAttributeProvider {
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasCustomAttributes { get; }
    public abstract virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public abstract virtual bool get_HasCustomAttributes();
}
internal interface TestCentric.Metadata.IGenericContext {
    public bool IsDefinition { get; }
    public IGenericParameterProvider Type { get; }
    public IGenericParameterProvider Method { get; }
    public abstract virtual bool get_IsDefinition();
    public abstract virtual IGenericParameterProvider get_Type();
    public abstract virtual IGenericParameterProvider get_Method();
}
public interface TestCentric.Metadata.IGenericInstance {
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public abstract virtual bool get_HasGenericArguments();
    public abstract virtual Collection`1<TypeReference> get_GenericArguments();
}
public interface TestCentric.Metadata.IGenericParameterProvider {
    public bool HasGenericParameters { get; }
    public bool IsDefinition { get; }
    public ModuleDefinition Module { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public GenericParameterType GenericParameterType { get; }
    public abstract virtual bool get_HasGenericParameters();
    public abstract virtual bool get_IsDefinition();
    public abstract virtual ModuleDefinition get_Module();
    public abstract virtual Collection`1<GenericParameter> get_GenericParameters();
    public abstract virtual GenericParameterType get_GenericParameterType();
}
public interface TestCentric.Metadata.IMemberDefinition {
    public string Name { get; public set; }
    public string FullName { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual void set_IsSpecialName(bool value);
    public abstract virtual bool get_IsRuntimeSpecialName();
    public abstract virtual void set_IsRuntimeSpecialName(bool value);
    public abstract virtual TypeDefinition get_DeclaringType();
    public abstract virtual void set_DeclaringType(TypeDefinition value);
}
public interface TestCentric.Metadata.IMetadataResolver {
    public abstract virtual TypeDefinition Resolve(TypeReference type);
    public abstract virtual FieldDefinition Resolve(FieldReference field);
    public abstract virtual MethodDefinition Resolve(MethodReference method);
}
public interface TestCentric.Metadata.IMetadataScope {
    public MetadataScopeType MetadataScopeType { get; }
    public string Name { get; public set; }
    public abstract virtual MetadataScopeType get_MetadataScopeType();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public interface TestCentric.Metadata.IMetadataTokenProvider {
    public MetadataToken MetadataToken { get; public set; }
    public abstract virtual MetadataToken get_MetadataToken();
    public abstract virtual void set_MetadataToken(MetadataToken value);
}
public interface TestCentric.Metadata.IMethodSignature {
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public abstract virtual bool get_HasThis();
    public abstract virtual void set_HasThis(bool value);
    public abstract virtual bool get_ExplicitThis();
    public abstract virtual void set_ExplicitThis(bool value);
    public abstract virtual MethodCallingConvention get_CallingConvention();
    public abstract virtual void set_CallingConvention(MethodCallingConvention value);
    public abstract virtual bool get_HasParameters();
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    public abstract virtual TypeReference get_ReturnType();
    public abstract virtual void set_ReturnType(TypeReference value);
    public abstract virtual MethodReturnType get_MethodReturnType();
}
internal class TestCentric.Metadata.ImmediateModuleReader : ModuleReader {
    private bool resolve_attributes;
    public ImmediateModuleReader(Image image);
    protected virtual void ReadModule();
    public void ReadModule(ModuleDefinition module, bool resolve_attributes);
    private void ReadTypes(Collection`1<TypeDefinition> types);
    private void ReadType(TypeDefinition type);
    private void ReadInterfaces(TypeDefinition type);
    private void ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParameterConstraints(GenericParameter parameter);
    private void ReadCustomAttributes(ICustomAttributeProvider provider);
    private void ReadFields(TypeDefinition type);
    private void ReadMethods(TypeDefinition type);
    private void ReadParameters(MethodDefinition method);
    private void ReadProperties(TypeDefinition type);
    [CompilerGeneratedAttribute]
private void <ReadModule>b__2_0(ModuleDefinition module, MetadataReader reader);
}
public interface TestCentric.Metadata.IModifierType {
    public TypeReference ModifierType { get; }
    public TypeReference ElementType { get; }
    public abstract virtual TypeReference get_ModifierType();
    public abstract virtual TypeReference get_ElementType();
}
public class TestCentric.Metadata.InterfaceImplementation : object {
    internal TypeDefinition type;
    internal MetadataToken token;
    private TypeReference interface_type;
    private Collection`1<CustomAttribute> custom_attributes;
    public TypeReference InterfaceType { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MetadataToken MetadataToken { get; public set; }
    internal InterfaceImplementation(TypeReference interfaceType, MetadataToken token);
    public InterfaceImplementation(TypeReference interfaceType);
    public TypeReference get_InterfaceType();
    public void set_InterfaceType(TypeReference value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
}
internal class TestCentric.Metadata.InterfaceImplementationCollection : Collection`1<InterfaceImplementation> {
    private TypeDefinition type;
    internal InterfaceImplementationCollection(TypeDefinition type);
    internal InterfaceImplementationCollection(TypeDefinition type, int length);
    protected virtual void OnAdd(InterfaceImplementation item, int index);
    protected virtual void OnInsert(InterfaceImplementation item, int index);
    protected virtual void OnSet(InterfaceImplementation item, int index);
    protected virtual void OnRemove(InterfaceImplementation item, int index);
}
internal class TestCentric.Metadata.MemberDefinitionCollection`1 : Collection`1<T> {
    private TypeDefinition container;
    internal MemberDefinitionCollection`1(TypeDefinition container);
    internal MemberDefinitionCollection`1(TypeDefinition container, int capacity);
    protected virtual void OnAdd(T item, int index);
    protected sealed virtual void OnSet(T item, int index);
    protected sealed virtual void OnInsert(T item, int index);
    protected sealed virtual void OnRemove(T item, int index);
    protected sealed virtual void OnClear();
    private void Attach(T element);
    private static void Detach(T element);
}
public abstract class TestCentric.Metadata.MemberReference : object {
    private string name;
    private TypeReference declaring_type;
    internal MetadataToken token;
    internal object projection;
    public string Name { get; public set; }
    public string FullName { get; }
    public TypeReference DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public bool IsWindowsRuntimeProjection { get; }
    internal MemberReferenceProjection WindowsRuntimeProjection { get; internal set; }
    internal bool HasImage { get; }
    public ModuleDefinition Module { get; }
    public bool IsDefinition { get; }
    public bool ContainsGenericParameter { get; }
    internal MemberReference(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public bool get_IsWindowsRuntimeProjection();
    internal MemberReferenceProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(MemberReferenceProjection value);
    internal bool get_HasImage();
    public virtual ModuleDefinition get_Module();
    public virtual bool get_IsDefinition();
    public virtual bool get_ContainsGenericParameter();
    internal string MemberFullName();
    public IMemberDefinition Resolve();
    protected abstract virtual IMemberDefinition ResolveDefinition();
    public virtual string ToString();
}
internal class TestCentric.Metadata.MemberReferenceProjection : object {
    public string Name;
    public MemberReferenceTreatment Treatment;
    public MemberReferenceProjection(MemberReference member, MemberReferenceTreatment treatment);
}
internal enum TestCentric.Metadata.MemberReferenceTreatment : Enum {
    public int value__;
    public static MemberReferenceTreatment None;
    public static MemberReferenceTreatment Dispose;
}
internal class TestCentric.Metadata.Metadata.BlobHeap : Heap {
    public BlobHeap(Byte[] data);
    public Byte[] Read(UInt32 index);
    public void GetView(UInt32 signature, Byte[]& buffer, Int32& index, Int32& length);
}
internal enum TestCentric.Metadata.Metadata.CodedIndex : Enum {
    public int value__;
    public static CodedIndex TypeDefOrRef;
    public static CodedIndex HasConstant;
    public static CodedIndex HasCustomAttribute;
    public static CodedIndex HasFieldMarshal;
    public static CodedIndex HasDeclSecurity;
    public static CodedIndex MemberRefParent;
    public static CodedIndex HasSemantics;
    public static CodedIndex MethodDefOrRef;
    public static CodedIndex MemberForwarded;
    public static CodedIndex Implementation;
    public static CodedIndex CustomAttributeType;
    public static CodedIndex ResolutionScope;
    public static CodedIndex TypeOrMethodDef;
    public static CodedIndex HasCustomDebugInformation;
}
internal enum TestCentric.Metadata.Metadata.ElementType : Enum {
    public byte value__;
    public static ElementType None;
    public static ElementType Void;
    public static ElementType Boolean;
    public static ElementType Char;
    public static ElementType I1;
    public static ElementType U1;
    public static ElementType I2;
    public static ElementType U2;
    public static ElementType I4;
    public static ElementType U4;
    public static ElementType I8;
    public static ElementType U8;
    public static ElementType R4;
    public static ElementType R8;
    public static ElementType String;
    public static ElementType Ptr;
    public static ElementType ByRef;
    public static ElementType ValueType;
    public static ElementType Class;
    public static ElementType Var;
    public static ElementType Array;
    public static ElementType GenericInst;
    public static ElementType TypedByRef;
    public static ElementType I;
    public static ElementType U;
    public static ElementType FnPtr;
    public static ElementType Object;
    public static ElementType SzArray;
    public static ElementType MVar;
    public static ElementType CModReqD;
    public static ElementType CModOpt;
    public static ElementType Internal;
    public static ElementType Modifier;
    public static ElementType Sentinel;
    public static ElementType Pinned;
    public static ElementType Type;
    public static ElementType Boxed;
    public static ElementType Enum;
}
internal class TestCentric.Metadata.Metadata.GuidHeap : Heap {
    public GuidHeap(Byte[] data);
    public Guid Read(UInt32 index);
}
internal abstract class TestCentric.Metadata.Metadata.Heap : object {
    public int IndexSize;
    internal Byte[] data;
    protected Heap(Byte[] data);
}
internal class TestCentric.Metadata.Metadata.PdbHeap : Heap {
    public Byte[] Id;
    public UInt32 EntryPoint;
    public long TypeSystemTables;
    public UInt32[] TypeSystemTableRows;
    public PdbHeap(Byte[] data);
    public bool HasTable(Table table);
}
internal class TestCentric.Metadata.Metadata.Row`2 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    public Row`2(T1 col1, T2 col2);
}
internal class TestCentric.Metadata.Metadata.Row`3 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    public Row`3(T1 col1, T2 col2, T3 col3);
}
internal class TestCentric.Metadata.Metadata.Row`4 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    public Row`4(T1 col1, T2 col2, T3 col3, T4 col4);
}
internal class TestCentric.Metadata.Metadata.Row`5 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    public Row`5(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5);
}
internal class TestCentric.Metadata.Metadata.Row`6 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    public Row`6(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6);
}
internal class TestCentric.Metadata.Metadata.Row`9 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    internal T7 Col7;
    internal T8 Col8;
    internal T9 Col9;
    public Row`9(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9);
}
internal class TestCentric.Metadata.Metadata.RowEqualityComparer : object {
    public sealed virtual bool Equals(Row`2<string, string> x, Row`2<string, string> y);
    public sealed virtual int GetHashCode(Row`2<string, string> obj);
    public sealed virtual bool Equals(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`2<UInt32, UInt32> obj);
    public sealed virtual bool Equals(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`3<UInt32, UInt32, UInt32> obj);
}
internal class TestCentric.Metadata.Metadata.StringHeap : Heap {
    private Dictionary`2<UInt32, string> strings;
    public StringHeap(Byte[] data);
    public string Read(UInt32 index);
    protected virtual string ReadStringAt(UInt32 index);
}
internal enum TestCentric.Metadata.Metadata.Table : Enum {
    public byte value__;
    public static Table Module;
    public static Table TypeRef;
    public static Table TypeDef;
    public static Table FieldPtr;
    public static Table Field;
    public static Table MethodPtr;
    public static Table Method;
    public static Table ParamPtr;
    public static Table Param;
    public static Table InterfaceImpl;
    public static Table MemberRef;
    public static Table Constant;
    public static Table CustomAttribute;
    public static Table FieldMarshal;
    public static Table DeclSecurity;
    public static Table ClassLayout;
    public static Table FieldLayout;
    public static Table StandAloneSig;
    public static Table EventMap;
    public static Table EventPtr;
    public static Table Event;
    public static Table PropertyMap;
    public static Table PropertyPtr;
    public static Table Property;
    public static Table MethodSemantics;
    public static Table MethodImpl;
    public static Table ModuleRef;
    public static Table TypeSpec;
    public static Table ImplMap;
    public static Table FieldRVA;
    public static Table EncLog;
    public static Table EncMap;
    public static Table Assembly;
    public static Table AssemblyProcessor;
    public static Table AssemblyOS;
    public static Table AssemblyRef;
    public static Table AssemblyRefProcessor;
    public static Table AssemblyRefOS;
    public static Table File;
    public static Table ExportedType;
    public static Table ManifestResource;
    public static Table NestedClass;
    public static Table GenericParam;
    public static Table MethodSpec;
    public static Table GenericParamConstraint;
    public static Table Document;
    public static Table MethodDebugInformation;
    public static Table LocalScope;
    public static Table LocalVariable;
    public static Table LocalConstant;
    public static Table ImportScope;
    public static Table StateMachineMethod;
    public static Table CustomDebugInformation;
}
[DefaultMemberAttribute("Item")]
internal class TestCentric.Metadata.Metadata.TableHeap : Heap {
    public long Valid;
    public long Sorted;
    public TableInformation[] Tables;
    public TableInformation Item { get; }
    public TableHeap(Byte[] data);
    public TableInformation get_Item(Table table);
    public bool HasTable(Table table);
}
internal class TestCentric.Metadata.Metadata.TableInformation : ValueType {
    public UInt32 Offset;
    public UInt32 Length;
    public UInt32 RowSize;
    public bool IsLarge { get; }
    public bool get_IsLarge();
}
internal class TestCentric.Metadata.Metadata.UserStringHeap : StringHeap {
    public UserStringHeap(Byte[] data);
    protected virtual string ReadStringAt(UInt32 index);
}
public enum TestCentric.Metadata.MetadataKind : Enum {
    public int value__;
    public static MetadataKind Ecma335;
    public static MetadataKind WindowsMetadata;
    public static MetadataKind ManagedWindowsMetadata;
}
internal class TestCentric.Metadata.MetadataReader : ByteBuffer {
    internal Image image;
    internal ModuleDefinition module;
    internal MetadataSystem metadata;
    internal IGenericContext context;
    private MetadataReader metadata_reader;
    public MetadataReader(ModuleDefinition module);
    public MetadataReader(Image image, ModuleDefinition module, MetadataReader metadata_reader);
    private int GetCodedIndexSize(CodedIndex index);
    private UInt32 ReadByIndexSize(int size);
    private Byte[] ReadBlob();
    private Byte[] ReadBlob(UInt32 signature);
    private UInt32 ReadBlobIndex();
    private void GetBlobView(UInt32 signature, Byte[]& blob, Int32& index, Int32& count);
    private string ReadString();
    private UInt32 ReadStringIndex();
    private Guid ReadGuid();
    private UInt32 ReadTableIndex(Table table);
    private MetadataToken ReadMetadataToken(CodedIndex index);
    private int MoveTo(Table table);
    private bool MoveTo(Table table, UInt32 row);
    public AssemblyNameDefinition ReadAssemblyNameDefinition();
    public ModuleDefinition Populate(ModuleDefinition module);
    private void InitializeAssemblyReferences();
    public Collection`1<AssemblyNameReference> ReadAssemblyReferences();
    public MethodDefinition ReadEntryPoint();
    public Collection`1<ModuleDefinition> ReadModules();
    private string GetModuleFileName(string name);
    private void InitializeModuleReferences();
    public Collection`1<ModuleReference> ReadModuleReferences();
    private void PopulateVersionAndFlags(AssemblyNameReference name);
    private void PopulateNameAndCulture(AssemblyNameReference name);
    public TypeDefinitionCollection ReadTypes();
    private void CompleteTypes();
    private void InitializeTypeDefinitions();
    private static bool IsNested(TypeAttributes attributes);
    public bool HasNestedTypes(TypeDefinition type);
    public Collection`1<TypeDefinition> ReadNestedTypes(TypeDefinition type);
    private void InitializeNestedTypes();
    private void AddNestedMapping(UInt32 declaring, UInt32 nested);
    private static Collection`1<TValue> AddMapping(Dictionary`2<TKey, Collection`1<TValue>> cache, TKey key, TValue value);
    private TypeDefinition ReadType(UInt32 rid);
    private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type);
    private Range ReadListRange(UInt32 current_index, Table current, Table target);
    public Row`2<short, int> ReadTypeLayout(TypeDefinition type);
    private void InitializeTypeLayouts();
    public TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    private TypeDefinition ReadTypeDefinition(UInt32 rid);
    private void InitializeTypeReferences();
    public TypeReference GetTypeReference(string scope, string full_name);
    private TypeReference GetTypeReference(UInt32 rid);
    private TypeReference ReadTypeReference(UInt32 rid);
    private IMetadataScope GetTypeReferenceScope(MetadataToken scope);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    private TypeReference GetTypeSpecification(UInt32 rid);
    private SignatureReader ReadSignature(UInt32 signature);
    public bool HasInterfaces(TypeDefinition type);
    public InterfaceImplementationCollection ReadInterfaces(TypeDefinition type);
    private void InitializeInterfaces();
    private void AddInterfaceMapping(UInt32 type, Row`2<UInt32, MetadataToken> interface);
    public Collection`1<FieldDefinition> ReadFields(TypeDefinition type);
    private void ReadField(UInt32 field_rid, Collection`1<FieldDefinition> fields);
    private void InitializeFields();
    private TypeReference ReadFieldType(UInt32 signature);
    public int ReadFieldRVA(FieldDefinition field);
    private Byte[] GetFieldInitializeValue(int size, UInt32 rva);
    private static int GetFieldTypeSize(TypeReference type);
    private void InitializeFieldRVAs();
    public int ReadFieldLayout(FieldDefinition field);
    private void InitializeFieldLayouts();
    public bool HasProperties(TypeDefinition type);
    public Collection`1<PropertyDefinition> ReadProperties(TypeDefinition type);
    private void ReadProperty(UInt32 property_rid, Collection`1<PropertyDefinition> properties);
    private void InitializeProperties();
    private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method);
    private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token);
    private static TMember GetMember(Collection`1<TMember> members, MetadataToken token);
    private void InitializeMethodSemantics();
    public void ReadMethods(PropertyDefinition property);
    public void ReadAllSemantics(MethodDefinition method);
    private void ReadAllSemantics(TypeDefinition type);
    public Collection`1<MethodDefinition> ReadMethods(TypeDefinition type);
    private void ReadPointers(Table ptr, Table table, Range range, Collection`1<TMember> members, Action`2<UInt32, Collection`1<TMember>> reader);
    private static bool IsDeleted(IMemberDefinition member);
    private void InitializeMethods();
    private void ReadMethod(UInt32 method_rid, Collection`1<MethodDefinition> methods);
    private void ReadParameters(MethodDefinition method, Range param_range);
    private void ReadParameterPointers(MethodDefinition method, Range range);
    private void ReadParameter(UInt32 param_rid, MethodDefinition method);
    private void ReadMethodSignature(UInt32 signature, IMethodSignature method);
    public bool HasGenericParameters(IGenericParameterProvider provider);
    public Collection`1<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters);
    private void InitializeGenericParameters();
    private Dictionary`2<MetadataToken, Range[]> InitializeRanges(Table table, Func`1<MetadataToken> get_next);
    private static void AddRange(Dictionary`2<MetadataToken, Range[]> ranges, MetadataToken owner, Range range);
    public bool HasGenericConstraints(GenericParameter generic_parameter);
    public GenericParameterConstraintCollection ReadGenericConstraints(GenericParameter generic_parameter);
    private void InitializeGenericConstraints();
    private void AddGenericConstraintMapping(UInt32 generic_parameter, Row`2<UInt32, MetadataToken> constraint);
    public bool HasOverrides(MethodDefinition method);
    public Collection`1<MethodReference> ReadOverrides(MethodDefinition method);
    private void InitializeOverrides();
    private void AddOverrideMapping(UInt32 method_rid, MetadataToken override);
    public CallSite ReadCallSite(MetadataToken token);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    private MethodDefinition LookupMethod(UInt32 rid);
    private MethodSpecification GetMethodSpecification(UInt32 rid);
    private MethodSpecification ReadMethodSpecSignature(UInt32 signature, MethodReference method);
    private MemberReference GetMemberReference(UInt32 rid);
    private MemberReference ReadMemberReference(UInt32 rid);
    private MemberReference ReadTypeMemberReference(MetadataToken type, string name, UInt32 signature);
    private MemberReference ReadMemberReferenceSignature(UInt32 signature, TypeReference declaring_type);
    private MemberReference ReadMethodMemberReference(MetadataToken token, string name, UInt32 signature);
    private void InitializeMemberReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    private void InitializeConstants();
    public TypeReference ReadConstantSignature(MetadataToken token);
    public object ReadConstant(IConstantProvider owner);
    private object ReadConstantValue(ElementType etype, UInt32 signature);
    private string ReadConstantString(UInt32 signature);
    private object ReadConstantPrimitive(ElementType type, UInt32 signature);
    internal void InitializeCustomAttributes();
    public bool HasCustomAttributes(ICustomAttributeProvider owner);
    public Collection`1<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner);
    private void ReadCustomAttributeRange(Range range, Collection`1<CustomAttribute> custom_attributes);
    private static int RangesSize(Range[] ranges);
    public IEnumerable`1<CustomAttribute> GetCustomAttributes();
    public Byte[] ReadCustomAttributeBlob(UInt32 signature);
    public void ReadCustomAttributeSignature(CustomAttribute attribute);
    private void InitializeMarshalInfos();
    public Collection`1<ExportedType> ReadExportedTypes();
    private IMetadataScope GetExportedTypeScope(MetadataToken token);
    private ModuleReference GetModuleReferenceFromFile(MetadataToken token);
    public string ReadUTF8StringBlob(UInt32 signature);
    private string ReadUnicodeStringBlob(UInt32 signature);
    private string ReadStringBlob(UInt32 signature, Encoding encoding);
    private void InitializeStateMachineMethods();
    public MethodDefinition ReadStateMachineKickoffMethod(MethodDefinition method);
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeGenericParameters>b__93_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeCustomAttributes>b__123_0();
}
public class TestCentric.Metadata.MetadataResolver : object {
    private IAssemblyResolver assembly_resolver;
    public IAssemblyResolver AssemblyResolver { get; }
    public MetadataResolver(IAssemblyResolver assemblyResolver);
    public IAssemblyResolver get_AssemblyResolver();
    public virtual TypeDefinition Resolve(TypeReference type);
    private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference);
    private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type);
    public virtual FieldDefinition Resolve(FieldReference field);
    private FieldDefinition GetField(TypeDefinition type, FieldReference reference);
    private static FieldDefinition GetField(Collection`1<FieldDefinition> fields, FieldReference reference);
    public virtual MethodDefinition Resolve(MethodReference method);
    private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference);
    public static MethodDefinition GetMethod(Collection`1<MethodDefinition> methods, MethodReference reference);
    private static bool AreSame(Collection`1<ParameterDefinition> a, Collection`1<ParameterDefinition> b);
    private static bool IsVarArgCallTo(MethodDefinition method, MethodReference reference);
    private static bool AreSame(TypeSpecification a, TypeSpecification b);
    private static bool AreSame(ArrayType a, ArrayType b);
    private static bool AreSame(IModifierType a, IModifierType b);
    private static bool AreSame(GenericInstanceType a, GenericInstanceType b);
    private static bool AreSame(GenericParameter a, GenericParameter b);
    private static bool AreSame(TypeReference a, TypeReference b);
}
public enum TestCentric.Metadata.MetadataScopeType : Enum {
    public int value__;
    public static MetadataScopeType AssemblyNameReference;
    public static MetadataScopeType ModuleReference;
    public static MetadataScopeType ModuleDefinition;
}
internal class TestCentric.Metadata.MetadataSystem : object {
    internal AssemblyNameReference[] AssemblyReferences;
    internal ModuleReference[] ModuleReferences;
    internal TypeDefinition[] Types;
    internal TypeReference[] TypeReferences;
    internal FieldDefinition[] Fields;
    internal MethodDefinition[] Methods;
    internal MemberReference[] MemberReferences;
    internal Dictionary`2<UInt32, Collection`1<UInt32>> NestedTypes;
    internal Dictionary`2<UInt32, UInt32> ReverseNestedTypes;
    internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> Interfaces;
    internal Dictionary`2<UInt32, Row`2<ushort, UInt32>> ClassLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldRVAs;
    internal Dictionary`2<MetadataToken, UInt32> FieldMarshals;
    internal Dictionary`2<MetadataToken, Row`2<ElementType, UInt32>> Constants;
    internal Dictionary`2<UInt32, Collection`1<MetadataToken>> Overrides;
    internal Dictionary`2<MetadataToken, Range[]> CustomAttributes;
    internal Dictionary`2<MetadataToken, Range[]> SecurityDeclarations;
    internal Dictionary`2<UInt32, Range> Events;
    internal Dictionary`2<UInt32, Range> Properties;
    internal Dictionary`2<UInt32, Row`2<MethodSemanticsAttributes, MetadataToken>> Semantics;
    internal Dictionary`2<MetadataToken, Range[]> GenericParameters;
    internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> GenericConstraints;
    internal Dictionary`2<UInt32, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>>> LocalScopes;
    internal Dictionary`2<UInt32, UInt32> StateMachineMethods;
    private static Dictionary`2<string, Row`2<ElementType, bool>> primitive_value_types;
    private static void InitializePrimitives();
    public static void TryProcessPrimitiveTypeReference(TypeReference type);
    public static bool TryGetPrimitiveElementType(TypeDefinition type, ElementType& etype);
    private static bool TryGetPrimitiveData(TypeReference type, Row`2& primitive_data);
    public void Clear();
    public AssemblyNameReference GetAssemblyNameReference(UInt32 rid);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    public void AddTypeDefinition(TypeDefinition type);
    public TypeReference GetTypeReference(UInt32 rid);
    public void AddTypeReference(TypeReference type);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    public void AddFieldDefinition(FieldDefinition field);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    public void AddMethodDefinition(MethodDefinition method);
    public MemberReference GetMemberReference(UInt32 rid);
    public void AddMemberReference(MemberReference member);
    public bool TryGetNestedTypeMapping(TypeDefinition type, Collection`1& mapping);
    public void SetNestedTypeMapping(UInt32 type_rid, Collection`1<UInt32> mapping);
    public void RemoveNestedTypeMapping(TypeDefinition type);
    public bool TryGetReverseNestedTypeMapping(TypeDefinition type, UInt32& declaring);
    public void SetReverseNestedTypeMapping(UInt32 nested, UInt32 declaring);
    public void RemoveReverseNestedTypeMapping(TypeDefinition type);
    public bool TryGetInterfaceMapping(TypeDefinition type, Collection`1& mapping);
    public void SetInterfaceMapping(UInt32 type_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping);
    public void RemoveInterfaceMapping(TypeDefinition type);
    public void AddPropertiesRange(UInt32 type_rid, Range range);
    public bool TryGetPropertiesRange(TypeDefinition type, Range& range);
    public void RemovePropertiesRange(TypeDefinition type);
    public void AddEventsRange(UInt32 type_rid, Range range);
    public bool TryGetEventsRange(TypeDefinition type, Range& range);
    public void RemoveEventsRange(TypeDefinition type);
    public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, Range[]& ranges);
    public void RemoveGenericParameterRange(IGenericParameterProvider owner);
    public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, Range[]& ranges);
    public void RemoveCustomAttributeRange(ICustomAttributeProvider owner);
    public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, Collection`1& mapping);
    public void SetGenericConstraintMapping(UInt32 gp_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping);
    public void RemoveGenericConstraintMapping(GenericParameter generic_parameter);
    public bool TryGetOverrideMapping(MethodDefinition method, Collection`1& mapping);
    public void SetOverrideMapping(UInt32 rid, Collection`1<MetadataToken> mapping);
    public void RemoveOverrideMapping(MethodDefinition method);
    public bool TryGetLocalScopes(MethodDefinition method, Collection`1& scopes);
    public void SetLocalScopes(UInt32 method_rid, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>> records);
    public bool TryGetStateMachineKickOffMethod(MethodDefinition method, UInt32& rid);
    public TypeDefinition GetFieldDeclaringType(UInt32 field_rid);
    public TypeDefinition GetMethodDeclaringType(UInt32 method_rid);
    private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, UInt32 rid, bool field);
}
public class TestCentric.Metadata.MetadataToken : ValueType {
    private UInt32 token;
    public static MetadataToken Zero;
    public UInt32 RID { get; }
    public TokenType TokenType { get; }
    public MetadataToken(UInt32 token);
    public MetadataToken(TokenType type);
    public MetadataToken(TokenType type, UInt32 rid);
    public MetadataToken(TokenType type, int rid);
    private static MetadataToken();
    public UInt32 get_RID();
    public TokenType get_TokenType();
    public int ToInt32();
    public UInt32 ToUInt32();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetadataToken other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(MetadataToken one, MetadataToken other);
    public static bool op_Inequality(MetadataToken one, MetadataToken other);
    public virtual string ToString();
}
public enum TestCentric.Metadata.MetadataType : Enum {
    public byte value__;
    public static MetadataType Void;
    public static MetadataType Boolean;
    public static MetadataType Char;
    public static MetadataType SByte;
    public static MetadataType Byte;
    public static MetadataType Int16;
    public static MetadataType UInt16;
    public static MetadataType Int32;
    public static MetadataType UInt32;
    public static MetadataType Int64;
    public static MetadataType UInt64;
    public static MetadataType Single;
    public static MetadataType Double;
    public static MetadataType String;
    public static MetadataType Pointer;
    public static MetadataType ByReference;
    public static MetadataType ValueType;
    public static MetadataType Class;
    public static MetadataType Var;
    public static MetadataType Array;
    public static MetadataType GenericInstance;
    public static MetadataType TypedByReference;
    public static MetadataType IntPtr;
    public static MetadataType UIntPtr;
    public static MetadataType FunctionPointer;
    public static MetadataType Object;
    public static MetadataType MVar;
    public static MetadataType RequiredModifier;
    public static MetadataType OptionalModifier;
    public static MetadataType Sentinel;
    public static MetadataType Pinned;
}
[FlagsAttribute]
public enum TestCentric.Metadata.MethodAttributes : Enum {
    public ushort value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes CompilerControlled;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PInvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
}
public enum TestCentric.Metadata.MethodCallingConvention : Enum {
    public byte value__;
    public static MethodCallingConvention Default;
    public static MethodCallingConvention C;
    public static MethodCallingConvention StdCall;
    public static MethodCallingConvention ThisCall;
    public static MethodCallingConvention FastCall;
    public static MethodCallingConvention VarArg;
    public static MethodCallingConvention Generic;
}
public class TestCentric.Metadata.MethodDefinition : MethodReference {
    private ushort attributes;
    private ushort impl_attributes;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sem_attrs_ready;
    internal MethodSemanticsAttributes sem_attrs;
    private Collection`1<CustomAttribute> custom_attributes;
    internal UInt32 rva;
    private Collection`1<MethodReference> overrides;
    public string Name { get; public set; }
    public MethodAttributes Attributes { get; public set; }
    public MethodImplAttributes ImplAttributes { get; public set; }
    public MethodSemanticsAttributes SemanticsAttributes { get; public set; }
    internal MethodDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public int RVA { get; }
    public bool HasBody { get; }
    public bool HasOverrides { get; }
    public Collection`1<MethodReference> Overrides { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsFinal { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsHideBySig { get; public set; }
    public bool IsReuseSlot { get; public set; }
    public bool IsNewSlot { get; public set; }
    public bool IsCheckAccessOnOverride { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsUnmanagedExport { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsIL { get; public set; }
    public bool IsNative { get; public set; }
    public bool IsRuntime { get; public set; }
    public bool IsUnmanaged { get; public set; }
    public bool IsManaged { get; public set; }
    public bool IsForwardRef { get; public set; }
    public bool IsPreserveSig { get; public set; }
    public bool IsInternalCall { get; public set; }
    public bool IsSynchronized { get; public set; }
    public bool NoInlining { get; public set; }
    public bool NoOptimization { get; public set; }
    public bool AggressiveInlining { get; public set; }
    public bool IsSetter { get; public set; }
    public bool IsGetter { get; public set; }
    public bool IsOther { get; public set; }
    public bool IsAddOn { get; public set; }
    public bool IsRemoveOn { get; public set; }
    public bool IsFire { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsConstructor { get; }
    public bool IsDefinition { get; }
    public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public MethodAttributes get_Attributes();
    public void set_Attributes(MethodAttributes value);
    public MethodImplAttributes get_ImplAttributes();
    public void set_ImplAttributes(MethodImplAttributes value);
    public MethodSemanticsAttributes get_SemanticsAttributes();
    public void set_SemanticsAttributes(MethodSemanticsAttributes value);
    internal MethodDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(MethodDefinitionProjection value);
    internal void ReadSemantics();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public int get_RVA();
    public bool get_HasBody();
    public bool get_HasOverrides();
    public Collection`1<MethodReference> get_Overrides();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsFinal();
    public void set_IsFinal(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsHideBySig();
    public void set_IsHideBySig(bool value);
    public bool get_IsReuseSlot();
    public void set_IsReuseSlot(bool value);
    public bool get_IsNewSlot();
    public void set_IsNewSlot(bool value);
    public bool get_IsCheckAccessOnOverride();
    public void set_IsCheckAccessOnOverride(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public bool get_IsUnmanagedExport();
    public void set_IsUnmanagedExport(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsIL();
    public void set_IsIL(bool value);
    public bool get_IsNative();
    public void set_IsNative(bool value);
    public bool get_IsRuntime();
    public void set_IsRuntime(bool value);
    public bool get_IsUnmanaged();
    public void set_IsUnmanaged(bool value);
    public bool get_IsManaged();
    public void set_IsManaged(bool value);
    public bool get_IsForwardRef();
    public void set_IsForwardRef(bool value);
    public bool get_IsPreserveSig();
    public void set_IsPreserveSig(bool value);
    public bool get_IsInternalCall();
    public void set_IsInternalCall(bool value);
    public bool get_IsSynchronized();
    public void set_IsSynchronized(bool value);
    public bool get_NoInlining();
    public void set_NoInlining(bool value);
    public bool get_NoOptimization();
    public void set_NoOptimization(bool value);
    public bool get_AggressiveInlining();
    public void set_AggressiveInlining(bool value);
    public bool get_IsSetter();
    public void set_IsSetter(bool value);
    public bool get_IsGetter();
    public void set_IsGetter(bool value);
    public bool get_IsOther();
    public void set_IsOther(bool value);
    public bool get_IsAddOn();
    public void set_IsAddOn(bool value);
    public bool get_IsRemoveOn();
    public void set_IsRemoveOn(bool value);
    public bool get_IsFire();
    public void set_IsFire(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public bool get_IsConstructor();
    public virtual bool get_IsDefinition();
    public virtual MethodDefinition Resolve();
}
internal class TestCentric.Metadata.MethodDefinitionProjection : object {
    public MethodAttributes Attributes;
    public MethodImplAttributes ImplAttributes;
    public string Name;
    public MethodDefinitionTreatment Treatment;
    public MethodDefinitionProjection(MethodDefinition method, MethodDefinitionTreatment treatment);
}
[FlagsAttribute]
internal enum TestCentric.Metadata.MethodDefinitionTreatment : Enum {
    public int value__;
    public static MethodDefinitionTreatment None;
    public static MethodDefinitionTreatment Dispose;
    public static MethodDefinitionTreatment Abstract;
    public static MethodDefinitionTreatment Private;
    public static MethodDefinitionTreatment Public;
    public static MethodDefinitionTreatment Runtime;
    public static MethodDefinitionTreatment InternalCall;
}
[FlagsAttribute]
public enum TestCentric.Metadata.MethodImplAttributes : Enum {
    public ushort value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
}
public class TestCentric.Metadata.MethodReference : MemberReference {
    internal ParameterDefinitionCollection parameters;
    private MethodReturnType return_type;
    private bool has_this;
    private bool explicit_this;
    private MethodCallingConvention calling_convention;
    internal Collection`1<GenericParameter> generic_parameters;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    private IGenericParameterProvider TestCentric.Metadata.IGenericContext.Type { get; }
    private IGenericParameterProvider TestCentric.Metadata.IGenericContext.Method { get; }
    private GenericParameterType TestCentric.Metadata.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    public MethodReference(string name, TypeReference returnType);
    public MethodReference(string name, TypeReference returnType, TypeReference declaringType);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private sealed virtual override IGenericParameterProvider TestCentric.Metadata.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider TestCentric.Metadata.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType TestCentric.Metadata.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    public virtual MethodReference GetElementMethod();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual MethodDefinition Resolve();
}
public class TestCentric.Metadata.MethodReturnType : object {
    internal IMethodSignature method;
    internal ParameterDefinition parameter;
    private TypeReference return_type;
    public IMethodSignature Method { get; }
    public TypeReference ReturnType { get; public set; }
    internal ParameterDefinition Parameter { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ParameterAttributes Attributes { get; public set; }
    public string Name { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasDefault { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public MethodReturnType(IMethodSignature method);
    public IMethodSignature get_Method();
    public TypeReference get_ReturnType();
    public void set_ReturnType(TypeReference value);
    internal ParameterDefinition get_Parameter();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
}
[FlagsAttribute]
public enum TestCentric.Metadata.MethodSemanticsAttributes : Enum {
    public ushort value__;
    public static MethodSemanticsAttributes None;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
public abstract class TestCentric.Metadata.MethodSpecification : MethodReference {
    private MethodReference method;
    public MethodReference ElementMethod { get; }
    public string Name { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public ModuleDefinition Module { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool ContainsGenericParameter { get; }
    internal MethodSpecification(MethodReference method);
    public MethodReference get_ElementMethod();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual ModuleDefinition get_Module();
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    public virtual bool get_ContainsGenericParameter();
    public sealed virtual MethodReference GetElementMethod();
}
[ExtensionAttribute]
internal static class TestCentric.Metadata.Mixin : object {
    public static int TableCount;
    public static int CodedIndexCount;
    public static Version ZeroVersion;
    public static int NotResolvedMarker;
    public static int NoDataMarker;
    internal static object NoValue;
    internal static object NotResolved;
    public static string mscorlib;
    public static string system_runtime;
    public static string system_private_corelib;
    public static string netstandard;
    private static Mixin();
    [ExtensionAttribute]
public static UInt32 ReadCompressedUInt32(Byte[] data, Int32& position);
    [ExtensionAttribute]
public static MetadataToken GetMetadataToken(CodedIndex self, UInt32 data);
    [ExtensionAttribute]
public static int GetSize(CodedIndex self, Func`2<Table, int> counter);
    public static Version CheckVersion(Version version);
    [ExtensionAttribute]
public static void ResolveConstant(IConstantProvider self, Object& constant, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasCustomAttributes(ICustomAttributeProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool ContainsGenericParameter(IGenericInstance self);
    [ExtensionAttribute]
public static void GenericInstanceFullName(IGenericInstance self, StringBuilder builder);
    [ExtensionAttribute]
public static bool GetHasGenericParameters(IGenericParameterProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<GenericParameter> GetGenericParameters(IGenericParameterProvider self, Collection`1& collection, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetAttributes(UInt32 self, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetAttributes(UInt32 self, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetAttributes(ushort self, ushort attributes);
    [ExtensionAttribute]
public static ushort SetAttributes(ushort self, ushort attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(ushort self, ushort mask, UInt32 attributes);
    [ExtensionAttribute]
public static ushort SetMaskedAttributes(ushort self, ushort mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool HasImplicitThis(IMethodSignature self);
    [ExtensionAttribute]
public static void MethodSignatureFullName(IMethodSignature self, StringBuilder builder);
    public static void CheckModule(ModuleDefinition module);
    [ExtensionAttribute]
public static bool TryGetAssemblyNameReference(ModuleDefinition module, AssemblyNameReference name_reference, AssemblyNameReference& assembly_reference);
    private static bool Equals(Byte[] a, Byte[] b);
    private static bool Equals(T a, T b);
    private static bool Equals(AssemblyNameReference a, AssemblyNameReference b);
    [ExtensionAttribute]
public static bool GetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics);
    [ExtensionAttribute]
public static void SetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics, bool value);
    [ExtensionAttribute]
public static bool IsVarArg(IMethodSignature self);
    [ExtensionAttribute]
public static int GetSentinelPosition(IMethodSignature self);
    public static void CheckName(object name);
    public static void CheckName(string name);
    public static void CheckFileName(string fileName);
    public static void CheckFullName(string fullName);
    public static void CheckStream(object stream);
    public static void CheckWriteSeek(Stream stream);
    public static void CheckReadSeek(Stream stream);
    public static void CheckType(object type);
    public static void CheckType(object type, Argument argument);
    public static void CheckField(object field);
    public static void CheckMethod(object method);
    public static void CheckParameters(object parameters);
    public static UInt32 GetTimestamp();
    [ExtensionAttribute]
public static bool HasImage(ModuleDefinition self);
    [ExtensionAttribute]
public static string GetFileName(Stream self);
    [ExtensionAttribute]
public static TargetRuntime ParseRuntime(string self);
    [ExtensionAttribute]
public static string RuntimeVersionString(TargetRuntime runtime);
    [ExtensionAttribute]
public static bool IsWindowsMetadata(ModuleDefinition module);
    public static void Read(object o);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
    [ExtensionAttribute]
public static TypeDefinition GetNestedType(TypeDefinition self, string fullname);
    [ExtensionAttribute]
public static bool IsPrimitive(ElementType self);
    [ExtensionAttribute]
public static string TypeFullName(TypeReference self);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference self, string namespace, string name);
    [ExtensionAttribute]
public static bool IsTypeSpecification(TypeReference type);
    [ExtensionAttribute]
public static TypeDefinition CheckedResolve(TypeReference self);
    [ExtensionAttribute]
public static bool TryGetCoreLibraryReference(ModuleDefinition module, AssemblyNameReference& reference);
    [ExtensionAttribute]
public static bool IsCoreLibrary(ModuleDefinition module);
    [ExtensionAttribute]
public static void KnownValueType(TypeReference type);
    private static bool IsCoreLibrary(AssemblyNameReference reference);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] self);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Collection`1<T> self);
    [ExtensionAttribute]
public static T[] Resize(T[] self, int length);
    [ExtensionAttribute]
public static T[] Add(T[] self, T item);
}
[FlagsAttribute]
public enum TestCentric.Metadata.ModuleAttributes : Enum {
    public int value__;
    public static ModuleAttributes ILOnly;
    public static ModuleAttributes Required32Bit;
    public static ModuleAttributes ILLibrary;
    public static ModuleAttributes StrongNameSigned;
    public static ModuleAttributes Preferred32Bit;
}
[FlagsAttribute]
public enum TestCentric.Metadata.ModuleCharacteristics : Enum {
    public int value__;
    public static ModuleCharacteristics HighEntropyVA;
    public static ModuleCharacteristics DynamicBase;
    public static ModuleCharacteristics NoSEH;
    public static ModuleCharacteristics NXCompat;
    public static ModuleCharacteristics AppContainer;
    public static ModuleCharacteristics TerminalServerAware;
}
public class TestCentric.Metadata.ModuleDefinition : ModuleReference {
    internal Image Image;
    internal MetadataSystem MetadataSystem;
    internal ReadingMode ReadingMode;
    internal Disposable`1<IAssemblyResolver> assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    internal TypeSystem type_system;
    internal MetadataReader reader;
    private string file_name;
    internal string runtime_version;
    internal ModuleKind kind;
    private WindowsRuntimeProjections projections;
    private MetadataKind metadata_kind;
    private TargetRuntime runtime;
    private TargetArchitecture architecture;
    private ModuleAttributes attributes;
    private ModuleCharacteristics characteristics;
    private Guid mvid;
    internal ushort linker_version;
    internal ushort subsystem_major;
    internal ushort subsystem_minor;
    internal UInt32 timestamp;
    internal AssemblyDefinition assembly;
    private MethodDefinition entry_point;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<AssemblyNameReference> references;
    private Collection`1<ModuleReference> modules;
    private Collection`1<ExportedType> exported_types;
    private TypeDefinitionCollection types;
    private object module_lock;
    public bool IsMain { get; }
    public ModuleKind Kind { get; public set; }
    public MetadataKind MetadataKind { get; public set; }
    internal WindowsRuntimeProjections Projections { get; }
    public TargetRuntime Runtime { get; public set; }
    public string RuntimeVersion { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public ModuleAttributes Attributes { get; public set; }
    public ModuleCharacteristics Characteristics { get; public set; }
    public string FileName { get; }
    public Guid Mvid { get; public set; }
    internal bool HasImage { get; }
    public MetadataScopeType MetadataScopeType { get; }
    public AssemblyDefinition Assembly { get; }
    public IAssemblyResolver AssemblyResolver { get; }
    public IMetadataResolver MetadataResolver { get; }
    public TypeSystem TypeSystem { get; }
    public bool HasAssemblyReferences { get; }
    public Collection`1<AssemblyNameReference> AssemblyReferences { get; }
    public bool HasModuleReferences { get; }
    public Collection`1<ModuleReference> ModuleReferences { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasTypes { get; }
    public Collection`1<TypeDefinition> Types { get; }
    public bool HasExportedTypes { get; }
    public Collection`1<ExportedType> ExportedTypes { get; }
    public MethodDefinition EntryPoint { get; public set; }
    internal object SyncRoot { get; }
    internal ModuleDefinition(Image image);
    public bool get_IsMain();
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public MetadataKind get_MetadataKind();
    public void set_MetadataKind(MetadataKind value);
    internal WindowsRuntimeProjections get_Projections();
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public string get_RuntimeVersion();
    public void set_RuntimeVersion(string value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public ModuleAttributes get_Attributes();
    public void set_Attributes(ModuleAttributes value);
    public ModuleCharacteristics get_Characteristics();
    public void set_Characteristics(ModuleCharacteristics value);
    public string get_FileName();
    public Guid get_Mvid();
    public void set_Mvid(Guid value);
    internal bool get_HasImage();
    public virtual MetadataScopeType get_MetadataScopeType();
    public AssemblyDefinition get_Assembly();
    public IAssemblyResolver get_AssemblyResolver();
    public IMetadataResolver get_MetadataResolver();
    public TypeSystem get_TypeSystem();
    public bool get_HasAssemblyReferences();
    public Collection`1<AssemblyNameReference> get_AssemblyReferences();
    public bool get_HasModuleReferences();
    public Collection`1<ModuleReference> get_ModuleReferences();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasTypes();
    public Collection`1<TypeDefinition> get_Types();
    public bool get_HasExportedTypes();
    public Collection`1<ExportedType> get_ExportedTypes();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual void Dispose();
    public bool HasTypeReference(string fullName);
    public bool HasTypeReference(string scope, string fullName);
    public bool TryGetTypeReference(string fullName, TypeReference& type);
    public bool TryGetTypeReference(string scope, string fullName, TypeReference& type);
    private TypeReference GetTypeReference(string scope, string fullname);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    public IEnumerable`1<CustomAttribute> GetCustomAttributes();
    public TypeReference GetType(string fullName, bool runtimeName);
    public TypeDefinition GetType(string fullName);
    public TypeDefinition GetType(string namespace, string name);
    public IEnumerable`1<TypeDefinition> GetTypes();
    [IteratorStateMachineAttribute("TestCentric.Metadata.ModuleDefinition/<GetTypes>d__108")]
private static IEnumerable`1<TypeDefinition> GetTypes(Collection`1<TypeDefinition> types);
    private TypeDefinition GetNestedType(string fullname);
    internal FieldDefinition Resolve(FieldReference field);
    internal MethodDefinition Resolve(MethodReference method);
    internal TypeDefinition Resolve(TypeReference type);
    internal object get_SyncRoot();
    internal void Read(TItem item, Action`2<TItem, MetadataReader> read);
    internal TRet Read(TItem item, Func`3<TItem, MetadataReader, TRet> read);
    internal TRet Read(TRet& variable, TItem item, Func`3<TItem, MetadataReader, TRet> read);
    private static AssemblyNameDefinition CreateAssemblyName(string name);
    public static ModuleDefinition ReadModule(string fileName);
    public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters);
    private static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share);
    public static ModuleDefinition ReadModule(Stream stream);
    public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters);
    private static ModuleDefinition ReadModule(Disposable`1<Stream> stream, string fileName, ReaderParameters parameters);
}
public enum TestCentric.Metadata.ModuleKind : Enum {
    public int value__;
    public static ModuleKind Dll;
    public static ModuleKind Console;
    public static ModuleKind Windows;
    public static ModuleKind NetModule;
}
internal abstract class TestCentric.Metadata.ModuleReader : object {
    protected ModuleDefinition module;
    protected ModuleReader(Image image, ReadingMode mode);
    protected abstract virtual void ReadModule();
    protected void ReadModuleManifest(MetadataReader reader);
    private void ReadAssembly(MetadataReader reader);
    public static ModuleDefinition CreateModule(Image image, ReaderParameters parameters);
    private static void GetMetadataKind(ModuleDefinition module, ReaderParameters parameters);
    private static ModuleReader CreateModuleReader(Image image, ReadingMode mode);
}
public class TestCentric.Metadata.ModuleReference : object {
    private string name;
    internal MetadataToken token;
    public string Name { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ModuleReference(string name);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public virtual MetadataScopeType get_MetadataScopeType();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
public class TestCentric.Metadata.OptionalModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsOptionalModifier { get; }
    public bool ContainsGenericParameter { get; }
    public OptionalModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_ContainsGenericParameter();
}
[FlagsAttribute]
public enum TestCentric.Metadata.ParameterAttributes : Enum {
    public ushort value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Unused;
}
public class TestCentric.Metadata.ParameterDefinition : ParameterReference {
    private ushort attributes;
    internal IMethodSignature method;
    private object constant;
    private Collection`1<CustomAttribute> custom_attributes;
    public ParameterAttributes Attributes { get; public set; }
    public IMethodSignature Method { get; }
    public int Sequence { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool IsIn { get; public set; }
    public bool IsOut { get; public set; }
    public bool IsLcid { get; public set; }
    public bool IsReturnValue { get; public set; }
    public bool IsOptional { get; public set; }
    public bool HasDefault { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    internal ParameterDefinition(TypeReference parameterType, IMethodSignature method);
    public ParameterDefinition(TypeReference parameterType);
    public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public IMethodSignature get_Method();
    public int get_Sequence();
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_IsIn();
    public void set_IsIn(bool value);
    public bool get_IsOut();
    public void set_IsOut(bool value);
    public bool get_IsLcid();
    public void set_IsLcid(bool value);
    public bool get_IsReturnValue();
    public void set_IsReturnValue(bool value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public virtual ParameterDefinition Resolve();
}
internal class TestCentric.Metadata.ParameterDefinitionCollection : Collection`1<ParameterDefinition> {
    private IMethodSignature method;
    internal ParameterDefinitionCollection(IMethodSignature method);
    internal ParameterDefinitionCollection(IMethodSignature method, int capacity);
    protected virtual void OnAdd(ParameterDefinition item, int index);
    protected virtual void OnInsert(ParameterDefinition item, int index);
    protected virtual void OnSet(ParameterDefinition item, int index);
    protected virtual void OnRemove(ParameterDefinition item, int index);
}
public abstract class TestCentric.Metadata.ParameterReference : object {
    private string name;
    internal int index;
    protected TypeReference parameter_type;
    internal MetadataToken token;
    public string Name { get; public set; }
    public int Index { get; }
    public TypeReference ParameterType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    internal ParameterReference(string name, TypeReference parameterType);
    public string get_Name();
    public void set_Name(string value);
    public int get_Index();
    public TypeReference get_ParameterType();
    public void set_ParameterType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
    public abstract virtual ParameterDefinition Resolve();
}
internal class TestCentric.Metadata.PE.BinaryStreamReader : BinaryReader {
    public int Position { get; public set; }
    public int Length { get; }
    public BinaryStreamReader(Stream stream);
    public int get_Position();
    public void set_Position(int value);
    public int get_Length();
    public void Advance(int bytes);
    public void MoveTo(UInt32 position);
    public void Align(int align);
    public DataDirectory ReadDataDirectory();
}
internal class TestCentric.Metadata.PE.ByteBuffer : object {
    internal Byte[] buffer;
    internal int length;
    internal int position;
    public ByteBuffer(int length);
    public ByteBuffer(Byte[] buffer);
    public void Advance(int length);
    public byte ReadByte();
    public sbyte ReadSByte();
    public Byte[] ReadBytes(int length);
    public ushort ReadUInt16();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public int ReadInt32();
    public ulong ReadUInt64();
    public long ReadInt64();
    public UInt32 ReadCompressedUInt32();
    public int ReadCompressedInt32();
    public float ReadSingle();
    public double ReadDouble();
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteInt64(long value);
    public void WriteCompressedUInt32(UInt32 value);
    public void WriteCompressedInt32(int value);
    public void WriteBytes(Byte[] bytes);
    public void WriteBytes(int length);
    public void WriteBytes(ByteBuffer buffer);
    public void WriteSingle(float value);
    public void WriteDouble(double value);
    private void Grow(int desired);
}
internal class TestCentric.Metadata.PE.DataDirectory : ValueType {
    public UInt32 VirtualAddress;
    public UInt32 Size;
    public bool IsZero { get; }
    public DataDirectory(UInt32 rva, UInt32 size);
    public bool get_IsZero();
}
internal class TestCentric.Metadata.PE.Image : object {
    public Disposable`1<Stream> Stream;
    public string FileName;
    public ModuleKind Kind;
    public string RuntimeVersion;
    public TargetArchitecture Architecture;
    public ModuleCharacteristics Characteristics;
    public ushort LinkerVersion;
    public ushort SubSystemMajor;
    public ushort SubSystemMinor;
    public Section[] Sections;
    public Section MetadataSection;
    public UInt32 EntryPointToken;
    public UInt32 Timestamp;
    public ModuleAttributes Attributes;
    public DataDirectory Win32Resources;
    public DataDirectory Debug;
    public StringHeap StringHeap;
    public BlobHeap BlobHeap;
    public UserStringHeap UserStringHeap;
    public GuidHeap GuidHeap;
    public TableHeap TableHeap;
    public PdbHeap PdbHeap;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    public bool HasTable(Table table);
    public int GetTableLength(Table table);
    public int GetTableIndexSize(Table table);
    public int GetCodedIndexSize(CodedIndex coded_index);
    public UInt32 ResolveVirtualAddress(UInt32 rva);
    public UInt32 ResolveVirtualAddressInSection(UInt32 rva, Section section);
    public Section GetSection(string name);
    public Section GetSectionAtVirtualAddress(UInt32 rva);
    private BinaryStreamReader GetReaderAt(UInt32 rva);
    public TRet GetReaderAt(UInt32 rva, TItem item, Func`3<TItem, BinaryStreamReader, TRet> read);
    public bool HasDebugTables();
    public sealed virtual void Dispose();
}
internal class TestCentric.Metadata.PE.ImageReader : BinaryStreamReader {
    private Image image;
    private DataDirectory cli;
    private DataDirectory metadata;
    private UInt32 table_heap_offset;
    public ImageReader(Disposable`1<Stream> stream, string file_name);
    private void MoveTo(DataDirectory directory);
    private void ReadImage();
    private TargetArchitecture ReadArchitecture();
    private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem);
    private void ReadOptionalHeaders(UInt16& subsystem, UInt16& dll_characteristics);
    private string ReadAlignedString(int length);
    private string ReadZeroTerminatedString(int length);
    private void ReadSections(ushort count);
    private void ReadCLIHeader();
    private void ReadMetadata();
    private void ReadMetadataStream(Section section);
    private Byte[] ReadHeapData(UInt32 offset, UInt32 size);
    private void ReadTableHeap();
    private static void SetIndexSize(Heap heap, UInt32 sizes, byte flag);
    private int GetTableIndexSize(Table table);
    private int GetCodedIndexSize(CodedIndex index);
    private void ComputeTableInformations();
    private void ReadPdbHeap();
    public static Image ReadImage(Disposable`1<Stream> stream, string file_name);
    public static Image ReadPortablePdb(Disposable`1<Stream> stream, string file_name);
}
internal class TestCentric.Metadata.PE.Section : object {
    public string Name;
    public UInt32 VirtualAddress;
    public UInt32 VirtualSize;
    public UInt32 SizeOfRawData;
    public UInt32 PointerToRawData;
}
public class TestCentric.Metadata.PinnedType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsPinned { get; }
    public PinnedType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPinned();
}
public class TestCentric.Metadata.PointerType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsPointer { get; }
    public PointerType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPointer();
}
[FlagsAttribute]
public enum TestCentric.Metadata.PropertyAttributes : Enum {
    public ushort value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Unused;
}
public class TestCentric.Metadata.PropertyDefinition : PropertyReference {
    private Nullable`1<bool> has_this;
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition get_method;
    internal MethodDefinition set_method;
    internal Collection`1<MethodDefinition> other_methods;
    private object constant;
    public PropertyAttributes Attributes { get; public set; }
    public bool HasThis { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MethodDefinition GetMethod { get; public set; }
    public MethodDefinition SetMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public string FullName { get; }
    public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType);
    public PropertyAttributes get_Attributes();
    public void set_Attributes(PropertyAttributes value);
    public bool get_HasThis();
    public void set_HasThis(bool value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public MethodDefinition get_GetMethod();
    public void set_GetMethod(MethodDefinition value);
    public MethodDefinition get_SetMethod();
    public void set_SetMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private static Collection`1<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    public virtual string get_FullName();
    private void InitializeMethods();
    public virtual PropertyDefinition Resolve();
}
public abstract class TestCentric.Metadata.PropertyReference : MemberReference {
    private TypeReference property_type;
    public TypeReference PropertyType { get; public set; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    internal PropertyReference(string name, TypeReference propertyType);
    public TypeReference get_PropertyType();
    public void set_PropertyType(TypeReference value);
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    protected virtual IMemberDefinition ResolveDefinition();
    public abstract virtual PropertyDefinition Resolve();
}
internal class TestCentric.Metadata.Range : ValueType {
    public UInt32 Start;
    public UInt32 Length;
    public Range(UInt32 index, UInt32 length);
}
public class TestCentric.Metadata.ReaderParameters : object {
    private ReadingMode reading_mode;
    internal IAssemblyResolver assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    private bool projections;
    private bool in_memory;
    private bool read_write;
    public ReadingMode ReadingMode { get; public set; }
    public bool InMemory { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public bool ReadWrite { get; public set; }
    public bool ApplyWindowsRuntimeProjections { get; public set; }
    public ReaderParameters(ReadingMode readingMode);
    public ReadingMode get_ReadingMode();
    public void set_ReadingMode(ReadingMode value);
    public bool get_InMemory();
    public void set_InMemory(bool value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public bool get_ReadWrite();
    public void set_ReadWrite(bool value);
    public bool get_ApplyWindowsRuntimeProjections();
    public void set_ApplyWindowsRuntimeProjections(bool value);
}
public enum TestCentric.Metadata.ReadingMode : Enum {
    public int value__;
    public static ReadingMode Immediate;
    public static ReadingMode Deferred;
}
public class TestCentric.Metadata.RequiredModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsRequiredModifier { get; }
    public bool ContainsGenericParameter { get; }
    public RequiredModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_ContainsGenericParameter();
}
public class TestCentric.Metadata.ResolutionException : Exception {
    private MemberReference member;
    public MemberReference Member { get; }
    public IMetadataScope Scope { get; }
    public ResolutionException(MemberReference member);
    public ResolutionException(MemberReference member, Exception innerException);
    private ResolutionException(SerializationInfo info, StreamingContext context);
    public MemberReference get_Member();
    public IMetadataScope get_Scope();
}
public class TestCentric.Metadata.SentinelType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsSentinel { get; }
    public SentinelType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsSentinel();
}
internal class TestCentric.Metadata.SignatureReader : ByteBuffer {
    private MetadataReader reader;
    internal UInt32 start;
    internal UInt32 sig_length;
    private TypeSystem TypeSystem { get; }
    public SignatureReader(UInt32 blob, MetadataReader reader);
    private TypeSystem get_TypeSystem();
    private MetadataToken ReadTypeTokenSignature();
    private GenericParameter GetGenericParameter(GenericParameterType type, UInt32 var);
    private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index);
    private static void CheckGenericContext(IGenericParameterProvider owner, int index);
    public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance, UInt32 arity);
    private ArrayType ReadArrayTypeSignature();
    private TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeReference ReadTypeSignature();
    public TypeReference ReadTypeToken();
    private TypeReference ReadTypeSignature(ElementType etype);
    public void ReadMethodSignature(IMethodSignature method);
    public object ReadConstantSignature(ElementType type);
    public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection`1<ParameterDefinition> parameters);
    private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type);
    public void ReadCustomAttributeNamedArguments(ushort count, Collection`1& fields, Collection`1& properties);
    private void ReadCustomAttributeNamedArgument(Collection`1& fields, Collection`1& properties);
    private static Collection`1<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(Collection`1& collection);
    private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type);
    private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type);
    private object ReadCustomAttributeElementValue(TypeReference type);
    private object ReadPrimitiveValue(ElementType type);
    private TypeReference GetPrimitiveType(ElementType etype);
    private TypeReference ReadCustomAttributeFieldOrPropType();
    public TypeReference ReadTypeReference();
    private object ReadCustomAttributeEnum(TypeReference enum_type);
    private string ReadUTF8String();
    public string ReadDocumentName();
    public bool CanReadMore();
}
public enum TestCentric.Metadata.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture I386;
    public static TargetArchitecture AMD64;
    public static TargetArchitecture IA64;
    public static TargetArchitecture ARM;
    public static TargetArchitecture ARMv7;
    public static TargetArchitecture ARM64;
}
public enum TestCentric.Metadata.TargetRuntime : Enum {
    public int value__;
    public static TargetRuntime Net_1_0;
    public static TargetRuntime Net_1_1;
    public static TargetRuntime Net_2_0;
    public static TargetRuntime Net_4_0;
}
public enum TestCentric.Metadata.TokenType : Enum {
    public UInt32 value__;
    public static TokenType Module;
    public static TokenType TypeRef;
    public static TokenType TypeDef;
    public static TokenType Field;
    public static TokenType Method;
    public static TokenType Param;
    public static TokenType InterfaceImpl;
    public static TokenType MemberRef;
    public static TokenType CustomAttribute;
    public static TokenType Permission;
    public static TokenType Signature;
    public static TokenType Event;
    public static TokenType Property;
    public static TokenType ModuleRef;
    public static TokenType TypeSpec;
    public static TokenType Assembly;
    public static TokenType AssemblyRef;
    public static TokenType File;
    public static TokenType ExportedType;
    public static TokenType ManifestResource;
    public static TokenType GenericParam;
    public static TokenType MethodSpec;
    public static TokenType GenericParamConstraint;
    public static TokenType Document;
    public static TokenType MethodDebugInformation;
    public static TokenType LocalScope;
    public static TokenType LocalVariable;
    public static TokenType LocalConstant;
    public static TokenType ImportScope;
    public static TokenType StateMachineMethod;
    public static TokenType CustomDebugInformation;
    public static TokenType String;
}
[FlagsAttribute]
public enum TestCentric.Metadata.TypeAttributes : Enum {
    public UInt32 value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes Forwarder;
}
public class TestCentric.Metadata.TypeDefinition : TypeReference {
    private UInt32 attributes;
    private TypeReference base_type;
    internal Range fields_range;
    internal Range methods_range;
    private short packing_size;
    private int class_size;
    private InterfaceImplementationCollection interfaces;
    private Collection`1<TypeDefinition> nested_types;
    private Collection`1<MethodDefinition> methods;
    private Collection`1<FieldDefinition> fields;
    private Collection`1<PropertyDefinition> properties;
    private Collection`1<CustomAttribute> custom_attributes;
    public TypeAttributes Attributes { get; public set; }
    public TypeReference BaseType { get; public set; }
    public string Name { get; public set; }
    public bool HasLayoutInfo { get; }
    public short PackingSize { get; public set; }
    public int ClassSize { get; public set; }
    public bool HasInterfaces { get; }
    public Collection`1<InterfaceImplementation> Interfaces { get; }
    public bool HasNestedTypes { get; }
    public Collection`1<TypeDefinition> NestedTypes { get; }
    public bool HasMethods { get; }
    public Collection`1<MethodDefinition> Methods { get; }
    public bool HasFields { get; }
    public Collection`1<FieldDefinition> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<PropertyDefinition> Properties { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsEnum { get; }
    public bool IsValueType { get; public set; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    internal TypeDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public TypeDefinition(string namespace, string name, TypeAttributes attributes);
    public TypeDefinition(string namespace, string name, TypeAttributes attributes, TypeReference baseType);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public TypeReference get_BaseType();
    public void set_BaseType(TypeReference value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public short get_PackingSize();
    public void set_PackingSize(short value);
    public int get_ClassSize();
    public void set_ClassSize(int value);
    public bool get_HasInterfaces();
    public Collection`1<InterfaceImplementation> get_Interfaces();
    public bool get_HasNestedTypes();
    public Collection`1<TypeDefinition> get_NestedTypes();
    public bool get_HasMethods();
    public Collection`1<MethodDefinition> get_Methods();
    public bool get_HasFields();
    public Collection`1<FieldDefinition> get_Fields();
    public bool get_HasProperties();
    public Collection`1<PropertyDefinition> get_Properties();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsEnum();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    internal TypeDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(TypeDefinitionProjection value);
    protected virtual void ClearFullName();
    public virtual TypeDefinition Resolve();
}
internal class TestCentric.Metadata.TypeDefinitionCollection : Collection`1<TypeDefinition> {
    private ModuleDefinition container;
    private Dictionary`2<Row`2<string, string>, TypeDefinition> name_cache;
    internal TypeDefinitionCollection(ModuleDefinition container);
    internal TypeDefinitionCollection(ModuleDefinition container, int capacity);
    protected virtual void OnAdd(TypeDefinition item, int index);
    protected virtual void OnSet(TypeDefinition item, int index);
    protected virtual void OnInsert(TypeDefinition item, int index);
    protected virtual void OnRemove(TypeDefinition item, int index);
    protected virtual void OnClear();
    private void Attach(TypeDefinition type);
    private void Detach(TypeDefinition type);
    public TypeDefinition GetType(string fullname);
    public TypeDefinition GetType(string namespace, string name);
}
internal class TestCentric.Metadata.TypeDefinitionProjection : object {
    public TypeAttributes Attributes;
    public string Name;
    public TypeDefinitionTreatment Treatment;
    public TypeDefinitionProjection(TypeDefinition type, TypeDefinitionTreatment treatment);
}
[FlagsAttribute]
internal enum TestCentric.Metadata.TypeDefinitionTreatment : Enum {
    public int value__;
    public static TypeDefinitionTreatment None;
    public static TypeDefinitionTreatment KindMask;
    public static TypeDefinitionTreatment NormalType;
    public static TypeDefinitionTreatment NormalAttribute;
    public static TypeDefinitionTreatment UnmangleWindowsRuntimeName;
    public static TypeDefinitionTreatment PrefixWindowsRuntimeName;
    public static TypeDefinitionTreatment RedirectToClrType;
    public static TypeDefinitionTreatment RedirectToClrAttribute;
    public static TypeDefinitionTreatment Abstract;
    public static TypeDefinitionTreatment Internal;
}
internal class TestCentric.Metadata.TypeParser : object {
    private string fullname;
    private int length;
    private int position;
    private TypeParser(string fullname);
    private Type ParseType(bool fq_name);
    private static bool TryGetArity(Type type);
    private static bool TryGetArity(string name, Int32& arity);
    private static bool ParseInt32(string value, Int32& result);
    private static void TryAddArity(string name, Int32& arity);
    private string ParsePart();
    private static bool IsDelimiter(char chr);
    private void TryParseWhiteSpace();
    private String[] ParseNestedNames();
    private bool TryParse(char chr);
    private static void Add(T[]& array, T item);
    private Int32[] ParseSpecs();
    private Type[] ParseGenericArguments(int arity);
    private string ParseAssemblyName();
    public static TypeReference ParseType(ModuleDefinition module, string fullname, bool typeDefinitionOnly);
    private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info, bool type_def_only);
    private static TypeReference CreateSpecs(TypeReference type, Type type_info);
    private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info);
    public static void SplitFullName(string fullname, String& namespace, String& name);
    private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope);
    private static void AdjustGenericParameters(TypeReference type);
    private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info);
    private static bool TryGetDefinition(ModuleDefinition module, Type type_info, TypeReference& type);
    private static bool TryCurrentModule(ModuleDefinition module, Type type_info);
    public static string ToParseable(TypeReference type, bool top_level);
    private static void AppendNamePart(string part, StringBuilder name);
    private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level);
    private static string GetScopeFullName(TypeReference type);
    private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name);
    private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level);
}
public class TestCentric.Metadata.TypeReference : MemberReference {
    private string namespace;
    private bool value_type;
    internal IMetadataScope scope;
    internal ModuleDefinition module;
    internal ElementType etype;
    private string fullname;
    protected Collection`1<GenericParameter> generic_parameters;
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public bool IsValueType { get; public set; }
    public ModuleDefinition Module { get; }
    internal TypeReferenceProjection WindowsRuntimeProjection { get; internal set; }
    private IGenericParameterProvider TestCentric.Metadata.IGenericContext.Type { get; }
    private IGenericParameterProvider TestCentric.Metadata.IGenericContext.Method { get; }
    private GenericParameterType TestCentric.Metadata.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsNested { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsByReference { get; }
    public bool IsPointer { get; }
    public bool IsSentinel { get; }
    public bool IsArray { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericInstance { get; }
    public bool IsRequiredModifier { get; }
    public bool IsOptionalModifier { get; }
    public bool IsPinned { get; }
    public bool IsFunctionPointer { get; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    protected TypeReference(string namespace, string name);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual ModuleDefinition get_Module();
    internal TypeReferenceProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(TypeReferenceProjection value);
    private sealed virtual override IGenericParameterProvider TestCentric.Metadata.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider TestCentric.Metadata.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType TestCentric.Metadata.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public bool get_IsNested();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsByReference();
    public virtual bool get_IsPointer();
    public virtual bool get_IsSentinel();
    public virtual bool get_IsArray();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_IsPinned();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    protected virtual void ClearFullName();
    public virtual TypeReference GetElementType();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual TypeDefinition Resolve();
}
internal class TestCentric.Metadata.TypeReferenceProjection : object {
    public string Name;
    public string Namespace;
    public IMetadataScope Scope;
    public TypeReferenceTreatment Treatment;
    public TypeReferenceProjection(TypeReference type, TypeReferenceTreatment treatment);
}
internal enum TestCentric.Metadata.TypeReferenceTreatment : Enum {
    public int value__;
    public static TypeReferenceTreatment None;
    public static TypeReferenceTreatment SystemDelegate;
    public static TypeReferenceTreatment SystemAttribute;
    public static TypeReferenceTreatment UseProjectionInfo;
}
public abstract class TestCentric.Metadata.TypeSpecification : TypeReference {
    private TypeReference element_type;
    public TypeReference ElementType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public IMetadataScope Scope { get; public set; }
    public ModuleDefinition Module { get; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    internal TypeSpecification(TypeReference type);
    public sealed virtual TypeReference get_ElementType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual ModuleDefinition get_Module();
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public virtual TypeReference GetElementType();
}
public abstract class TestCentric.Metadata.TypeSystem : object {
    private ModuleDefinition module;
    private TypeReference type_object;
    private TypeReference type_void;
    private TypeReference type_bool;
    private TypeReference type_char;
    private TypeReference type_sbyte;
    private TypeReference type_byte;
    private TypeReference type_int16;
    private TypeReference type_uint16;
    private TypeReference type_int32;
    private TypeReference type_uint32;
    private TypeReference type_int64;
    private TypeReference type_uint64;
    private TypeReference type_single;
    private TypeReference type_double;
    private TypeReference type_intptr;
    private TypeReference type_uintptr;
    private TypeReference type_string;
    private TypeReference type_typedref;
    [ObsoleteAttribute("Use CoreLibrary")]
public IMetadataScope Corlib { get; }
    public IMetadataScope CoreLibrary { get; }
    public TypeReference Object { get; }
    public TypeReference Void { get; }
    public TypeReference Boolean { get; }
    public TypeReference Char { get; }
    public TypeReference SByte { get; }
    public TypeReference Byte { get; }
    public TypeReference Int16 { get; }
    public TypeReference UInt16 { get; }
    public TypeReference Int32 { get; }
    public TypeReference UInt32 { get; }
    public TypeReference Int64 { get; }
    public TypeReference UInt64 { get; }
    public TypeReference Single { get; }
    public TypeReference Double { get; }
    public TypeReference IntPtr { get; }
    public TypeReference UIntPtr { get; }
    public TypeReference String { get; }
    public TypeReference TypedReference { get; }
    private TypeSystem(ModuleDefinition module);
    internal static TypeSystem CreateTypeSystem(ModuleDefinition module);
    internal abstract virtual TypeReference LookupType(string namespace, string name);
    private TypeReference LookupSystemType(TypeReference& reference, string name, ElementType element_type);
    private TypeReference LookupSystemValueType(TypeReference& typeRef, string name, ElementType element_type);
    public IMetadataScope get_Corlib();
    public IMetadataScope get_CoreLibrary();
    public TypeReference get_Object();
    public TypeReference get_Void();
    public TypeReference get_Boolean();
    public TypeReference get_Char();
    public TypeReference get_SByte();
    public TypeReference get_Byte();
    public TypeReference get_Int16();
    public TypeReference get_UInt16();
    public TypeReference get_Int32();
    public TypeReference get_UInt32();
    public TypeReference get_Int64();
    public TypeReference get_UInt64();
    public TypeReference get_Single();
    public TypeReference get_Double();
    public TypeReference get_IntPtr();
    public TypeReference get_UIntPtr();
    public TypeReference get_String();
    public TypeReference get_TypedReference();
}
internal class TestCentric.Metadata.WindowsRuntimeProjections : object {
    private static Version version;
    private static Byte[] contract_pk_token;
    private static Byte[] contract_pk;
    private static Dictionary`2<string, ProjectionInfo> projections;
    private ModuleDefinition module;
    private Version corlib_version;
    private AssemblyNameReference[] virtual_references;
    private static Dictionary`2<string, ProjectionInfo> Projections { get; }
    private AssemblyNameReference[] VirtualReferences { get; }
    public WindowsRuntimeProjections(ModuleDefinition module);
    private static WindowsRuntimeProjections();
    private static Dictionary`2<string, ProjectionInfo> get_Projections();
    private AssemblyNameReference[] get_VirtualReferences();
    public static void Project(TypeDefinition type);
    private static TypeDefinitionTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinition type);
    private static bool NeedsWindowsRuntimePrefix(TypeDefinition type);
    private static bool IsClrImplementationType(TypeDefinition type);
    public static void ApplyProjection(TypeDefinition type, TypeDefinitionProjection projection);
    public static TypeDefinitionProjection RemoveProjection(TypeDefinition type);
    public static void Project(TypeReference type);
    private static TypeReferenceTreatment GetSpecialTypeReferenceTreatment(TypeReference type);
    private static bool IsAttribute(TypeReference type);
    private static bool IsEnum(TypeReference type);
    public static void ApplyProjection(TypeReference type, TypeReferenceProjection projection);
    public static TypeReferenceProjection RemoveProjection(TypeReference type);
    public static void Project(MethodDefinition method);
    private static MethodDefinitionTreatment GetMethodDefinitionTreatmentFromCustomAttributes(MethodDefinition method);
    public static void ApplyProjection(MethodDefinition method, MethodDefinitionProjection projection);
    public static MethodDefinitionProjection RemoveProjection(MethodDefinition method);
    public static void Project(MemberReference member);
    private static bool ImplementsRedirectedInterface(MemberReference member, Boolean& disposable);
    public static void ApplyProjection(MemberReference member, MemberReferenceProjection projection);
    public static MemberReferenceProjection RemoveProjection(MemberReference member);
    public void AddVirtualReferences(Collection`1<AssemblyNameReference> references);
    public void RemoveVirtualReferences(Collection`1<AssemblyNameReference> references);
    private static AssemblyNameReference[] GetAssemblyReferences(AssemblyNameReference corlib);
    private static AssemblyNameReference GetCoreLibrary(Collection`1<AssemblyNameReference> references);
    private AssemblyNameReference GetAssemblyReference(string name);
    public static void Project(ICustomAttributeProvider owner, CustomAttribute attribute);
    private static bool IsWindowsAttributeUsageAttribute(ICustomAttributeProvider owner, CustomAttribute attribute);
    private static bool HasAttribute(TypeDefinition type, string namespace, string name);
    public static void ApplyProjection(CustomAttribute attribute, CustomAttributeValueProjection projection);
    public static CustomAttributeValueProjection RemoveProjection(CustomAttribute attribute);
}
