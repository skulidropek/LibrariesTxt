public class NvAPIWrapper.Display.ColorData : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ColorDataDepth> <ColorDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorDataFormat <ColorFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorDataColorimetry <Colorimetry>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ColorDataDesktopDepth> <DesktopColorDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ColorDataDynamicRange> <DynamicRange>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ColorDataSelectionPolicy> <SelectionPolicy>k__BackingField;
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public ColorDataFormat ColorFormat { get; }
    public ColorDataColorimetry Colorimetry { get; }
    public Nullable`1<ColorDataDesktopDepth> DesktopColorDepth { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public Nullable`1<ColorDataSelectionPolicy> SelectionPolicy { get; }
    public ColorData(ColorDataFormat colorFormat, ColorDataColorimetry colorimetry, Nullable`1<ColorDataDynamicRange> dynamicRange, Nullable`1<ColorDataDepth> colorDepth, Nullable`1<ColorDataSelectionPolicy> colorSelectionPolicy, Nullable`1<ColorDataDesktopDepth> desktopColorDepth);
    internal ColorData(IColorData colorData);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    [CompilerGeneratedAttribute]
public sealed virtual ColorDataFormat get_ColorFormat();
    [CompilerGeneratedAttribute]
public sealed virtual ColorDataColorimetry get_Colorimetry();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ColorDataDesktopDepth> get_DesktopColorDepth();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ColorDataSelectionPolicy> get_SelectionPolicy();
    public sealed virtual bool Equals(ColorData other);
    public static bool op_Equality(ColorData left, ColorData right);
    public static bool op_Inequality(ColorData left, ColorData right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal ColorDataV1 AsColorDataV1(ColorDataCommand command);
    internal ColorDataV2 AsColorDataV2(ColorDataCommand command);
    internal ColorDataV3 AsColorDataV3(ColorDataCommand command);
    internal ColorDataV4 AsColorDataV4(ColorDataCommand command);
    internal ColorDataV5 AsColorDataV5(ColorDataCommand command);
}
public class NvAPIWrapper.Display.CustomResolution : object {
    [CompilerGeneratedAttribute]
private UInt32 <ColorDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorFormat <ColorFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private Timing <Timing>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private float <XRatio>k__BackingField;
    [CompilerGeneratedAttribute]
private float <YRatio>k__BackingField;
    public UInt32 ColorDepth { get; }
    public ColorFormat ColorFormat { get; }
    public UInt32 Height { get; }
    public Timing Timing { get; }
    public UInt32 Width { get; }
    public float XRatio { get; }
    public float YRatio { get; }
    public CustomResolution(UInt32 width, UInt32 height, ColorFormat colorFormat, Timing timing, float xRatio, float yRatio);
    public CustomResolution(UInt32 width, UInt32 height, UInt32 colorDepth, Timing timing, float xRatio, float yRatio);
    internal CustomResolution(CustomDisplay customDisplay);
    [CompilerGeneratedAttribute]
public UInt32 get_ColorDepth();
    [CompilerGeneratedAttribute]
public ColorFormat get_ColorFormat();
    [CompilerGeneratedAttribute]
public UInt32 get_Height();
    [CompilerGeneratedAttribute]
public Timing get_Timing();
    [CompilerGeneratedAttribute]
public UInt32 get_Width();
    [CompilerGeneratedAttribute]
public float get_XRatio();
    [CompilerGeneratedAttribute]
public float get_YRatio();
    public sealed virtual bool Equals(CustomResolution other);
    public static bool op_Equality(CustomResolution left, CustomResolution right);
    public static bool op_Inequality(CustomResolution left, CustomResolution right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal CustomDisplay AsCustomDisplay(bool hardwareModeSetOnly);
}
public class NvAPIWrapper.Display.Display : object {
    [CompilerGeneratedAttribute]
private DisplayHandle <Handle>k__BackingField;
    public DVCInformation DigitalVibranceControl { get; }
    public DisplayDevice DisplayDevice { get; }
    public string DriverBuildTitle { get; }
    public DisplayHandle Handle { get; }
    public IHDMISupportInfo HDMISupportInfo { get; }
    public HUEInformation HUEControl { get; }
    public LogicalGPU LogicalGPU { get; }
    public string Name { get; }
    public GPUOutput Output { get; }
    public PhysicalGPU[] PhysicalGPUs { get; }
    public Display(DisplayHandle handle);
    public Display(string displayName);
    public DVCInformation get_DigitalVibranceControl();
    public DisplayDevice get_DisplayDevice();
    public string get_DriverBuildTitle();
    [CompilerGeneratedAttribute]
public DisplayHandle get_Handle();
    public IHDMISupportInfo get_HDMISupportInfo();
    public HUEInformation get_HUEControl();
    public LogicalGPU get_LogicalGPU();
    public string get_Name();
    public GPUOutput get_Output();
    public PhysicalGPU[] get_PhysicalGPUs();
    public sealed virtual bool Equals(Display other);
    public static Display[] GetDisplays();
    public static bool op_Equality(Display left, Display right);
    public static bool op_Inequality(Display left, Display right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public TargetViewMode[] GetSupportedViews();
    public void OverrideRefreshRate(float refreshRate, bool isDeferred);
}
public class NvAPIWrapper.Display.DisplayDevice : object {
    [CompilerGeneratedAttribute]
private MonitorConnectionType <ConnectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DisplayId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCluster>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConnected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultiStreamRootNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOSVisible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPhysicallyConnected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWFD>k__BackingField;
    [CompilerGeneratedAttribute]
private ScanOutInformation <ScanOutInformation>k__BackingField;
    public MonitorConnectionType ConnectionType { get; }
    public ColorData CurrentColorData { get; }
    public Timing CurrentTiming { get; }
    public ColorData DefaultColorData { get; }
    public UInt32 DisplayId { get; }
    public MonitorColorData[] DisplayPortColorCapabilities { get; }
    public HDRCapabilitiesV1 DriverHDRCapabilities { get; }
    public HDRCapabilitiesV1 EffectiveHDRCapabilities { get; }
    public Nullable`1<InfoFrameAudio> HDMIAudioFrameCurrentInformation { get; }
    public Nullable`1<InfoFrameAudio> HDMIAudioFrameDefaultInformation { get; }
    public Nullable`1<InfoFrameAudio> HDMIAudioFrameOverrideInformation { get; }
    public Nullable`1<InfoFrameProperty> HDMIAudioFramePropertyInformation { get; }
    public IHDMISupportInfo HDMISupportInfo { get; }
    public Nullable`1<InfoFrameVideo> HDMIVideoFrameCurrentInformation { get; }
    public Nullable`1<InfoFrameVideo> HDMIVideoFrameDefaultInformation { get; }
    public Nullable`1<InfoFrameVideo> HDMIVideoFrameOverrideInformation { get; }
    public Nullable`1<InfoFrameProperty> HDMIVideoFramePropertyInformation { get; }
    public HDRColorData HDRColorData { get; }
    public bool IsActive { get; }
    public bool IsAvailable { get; }
    public bool IsCluster { get; }
    public bool IsConnected { get; }
    public bool IsDynamic { get; }
    public bool IsMultiStreamRootNode { get; }
    public bool IsOSVisible { get; }
    public bool IsPhysicallyConnected { get; }
    public bool IsWFD { get; }
    public GPUOutput Output { get; }
    public PhysicalGPU PhysicalGPU { get; }
    public ScanOutInformation ScanOutInformation { get; }
    public Nullable`1<MonitorVCDBCapabilities> VCDBMonitorCapabilities { get; }
    public Nullable`1<MonitorVSDBCapabilities> VSDBMonitorCapabilities { get; }
    public DisplayDevice(UInt32 displayId);
    public DisplayDevice(IDisplayIds displayIds);
    public DisplayDevice(string displayName);
    [CompilerGeneratedAttribute]
public MonitorConnectionType get_ConnectionType();
    public ColorData get_CurrentColorData();
    public Timing get_CurrentTiming();
    public ColorData get_DefaultColorData();
    [CompilerGeneratedAttribute]
public UInt32 get_DisplayId();
    public MonitorColorData[] get_DisplayPortColorCapabilities();
    public HDRCapabilitiesV1 get_DriverHDRCapabilities();
    public HDRCapabilitiesV1 get_EffectiveHDRCapabilities();
    public Nullable`1<InfoFrameAudio> get_HDMIAudioFrameCurrentInformation();
    public Nullable`1<InfoFrameAudio> get_HDMIAudioFrameDefaultInformation();
    public Nullable`1<InfoFrameAudio> get_HDMIAudioFrameOverrideInformation();
    public Nullable`1<InfoFrameProperty> get_HDMIAudioFramePropertyInformation();
    public IHDMISupportInfo get_HDMISupportInfo();
    public Nullable`1<InfoFrameVideo> get_HDMIVideoFrameCurrentInformation();
    public Nullable`1<InfoFrameVideo> get_HDMIVideoFrameDefaultInformation();
    public Nullable`1<InfoFrameVideo> get_HDMIVideoFrameOverrideInformation();
    public Nullable`1<InfoFrameProperty> get_HDMIVideoFramePropertyInformation();
    public HDRColorData get_HDRColorData();
    [CompilerGeneratedAttribute]
public bool get_IsActive();
    [CompilerGeneratedAttribute]
public bool get_IsAvailable();
    [CompilerGeneratedAttribute]
public bool get_IsCluster();
    [CompilerGeneratedAttribute]
public bool get_IsConnected();
    [CompilerGeneratedAttribute]
public bool get_IsDynamic();
    [CompilerGeneratedAttribute]
public bool get_IsMultiStreamRootNode();
    [CompilerGeneratedAttribute]
public bool get_IsOSVisible();
    [CompilerGeneratedAttribute]
public bool get_IsPhysicallyConnected();
    [CompilerGeneratedAttribute]
public bool get_IsWFD();
    public GPUOutput get_Output();
    public PhysicalGPU get_PhysicalGPU();
    [CompilerGeneratedAttribute]
public ScanOutInformation get_ScanOutInformation();
    public Nullable`1<MonitorVCDBCapabilities> get_VCDBMonitorCapabilities();
    public Nullable`1<MonitorVSDBCapabilities> get_VSDBMonitorCapabilities();
    public sealed virtual bool Equals(DisplayDevice other);
    public static void DeleteCustomResolution(CustomResolution customResolution, UInt32[] displayIds);
    public static DisplayDevice GetGDIPrimaryDisplayDevice();
    public static bool op_Equality(DisplayDevice left, DisplayDevice right);
    public static bool op_Inequality(DisplayDevice left, DisplayDevice right);
    public static void RevertCustomResolution(UInt32[] displayIds);
    public static void SaveCustomResolution(UInt32[] displayIds, bool isThisOutputIdOnly, bool isThisMonitorOnly);
    public static void TrialCustomResolution(CustomResolution customResolution, UInt32[] displayIds, bool hardwareModeSetOnly);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public Timing CalculateTiming(UInt32 width, UInt32 height, float refreshRate, bool isInterlaced);
    public void DeleteCustomResolution(CustomResolution customResolution);
    public IEnumerable`1<CustomResolution> GetCustomResolutions();
    public bool IsColorDataSupported(ColorData colorData);
    public void ResetHDMIAudioFrameInformation();
    public void ResetHDMIVideoFrameInformation();
    public void RevertCustomResolution();
    public void SaveCustomResolution(bool isThisOutputIdOnly, bool isThisMonitorOnly);
    public void SetColorData(ColorData colorData);
    public void SetHDMIAudioFrameInformation(InfoFrameAudio audio, bool isOverride);
    public void SetHDMIAudioFramePropertyInformation(InfoFrameProperty property);
    public void SetHDMIVideoFrameInformation(InfoFrameVideo video, bool isOverride);
    public void SetHDMIVideoFramePropertyInformation(InfoFrameProperty property);
    public void SetHDRColorData(HDRColorData colorData);
    public void TrialCustomResolution(CustomResolution customResolution, bool hardwareModeSetOnly);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__0_0(DisplayDevice ids);
}
public class NvAPIWrapper.Display.DVCInformation : object {
    private DisplayHandle _displayHandle;
    private OutputId _outputId;
    private Nullable`1<bool> _isLegacy;
    public double NormalizedLevel { get; public set; }
    public int CurrentLevel { get; public set; }
    public int DefaultLevel { get; }
    public int MaximumLevel { get; }
    public int MinimumLevel { get; }
    public DVCInformation(DisplayHandle displayHandle);
    public DVCInformation(OutputId outputId);
    public double get_NormalizedLevel();
    public void set_NormalizedLevel(double value);
    public sealed virtual int get_CurrentLevel();
    public void set_CurrentLevel(int value);
    public sealed virtual int get_DefaultLevel();
    public sealed virtual int get_MaximumLevel();
    public sealed virtual int get_MinimumLevel();
    public virtual string ToString();
    private IDisplayDVCInfo GetInfo();
    private IDisplayDVCInfo GetLegacyInfo();
    private IDisplayDVCInfo GetModernInfo();
    private bool SetLegacyLevel(int level);
    private void SetLevel(int level);
    private bool SetModernLevel(int level);
}
public class NvAPIWrapper.Display.FloatTexture : object {
    protected Single[] UnderlyingArray;
    [CompilerGeneratedAttribute]
private int <Channels>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    public int Channels { get; }
    public int Height { get; }
    public int Width { get; }
    public FloatTexture(int width, int height, int channels);
    protected FloatTexture(int width, int height, int channels, Single[] array);
    [CompilerGeneratedAttribute]
public int get_Channels();
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public int get_Width();
    public sealed virtual bool Equals(FloatTexture other);
    public static FloatTexture FromFloatArray(int width, int height, int channels, Single[] floats);
    public static bool op_Equality(FloatTexture left, FloatTexture right);
    public static bool op_Inequality(FloatTexture left, FloatTexture right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Single[] GetValues(int x, int y);
    public void SetValues(int x, int y, Single[] floats);
    public Single[] ToFloatArray();
}
public class NvAPIWrapper.Display.HDRColorData : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ColorDataDepth> <ColorDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ColorDataFormat> <ColorFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ColorDataDynamicRange> <DynamicRange>k__BackingField;
    [CompilerGeneratedAttribute]
private ColorDataHDRMode <HDRMode>k__BackingField;
    [CompilerGeneratedAttribute]
private MasteringDisplayColorData <MasteringDisplayData>k__BackingField;
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataFormat> ColorFormat { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public ColorDataHDRMode HDRMode { get; }
    public MasteringDisplayColorData MasteringDisplayData { get; }
    public HDRColorData(ColorDataHDRMode hdrMode, MasteringDisplayColorData masteringDisplayData, Nullable`1<ColorDataFormat> colorFormat, Nullable`1<ColorDataDynamicRange> dynamicRange, Nullable`1<ColorDataDepth> colorDepth);
    internal HDRColorData(IHDRColorData colorData);
    public sealed virtual bool Equals(HDRColorData other);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ColorDataFormat> get_ColorFormat();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    [CompilerGeneratedAttribute]
public sealed virtual ColorDataHDRMode get_HDRMode();
    [CompilerGeneratedAttribute]
public sealed virtual MasteringDisplayColorData get_MasteringDisplayData();
    public static bool op_Equality(HDRColorData left, HDRColorData right);
    public static bool op_Inequality(HDRColorData left, HDRColorData right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal HDRColorDataV1 AsHDRColorDataV1(ColorDataHDRCommand command);
    internal HDRColorDataV2 AsHDRColorDataV2(ColorDataHDRCommand command);
}
public class NvAPIWrapper.Display.HUEInformation : object {
    private DisplayHandle _displayHandle;
    private OutputId _outputId;
    public int CurrentAngle { get; public set; }
    public int DefaultAngle { get; }
    public HUEInformation(DisplayHandle displayHandle);
    public HUEInformation(OutputId outputId);
    public int get_CurrentAngle();
    public void set_CurrentAngle(int value);
    public int get_DefaultAngle();
    public virtual string ToString();
}
public class NvAPIWrapper.Display.IntensityTexture : FloatTexture {
    public IntensityTexture(int width, int height);
    private IntensityTexture(int width, int height, Single[] floats);
    public static IntensityTexture FromFloatArray(int width, int height, Single[] floats);
    public IntensityTexturePixel GetPixel(int x, int y);
    public void SetPixel(int x, int y, IntensityTexturePixel pixel);
}
public class NvAPIWrapper.Display.IntensityTexturePixel : object {
    [CompilerGeneratedAttribute]
private float <BlueIntensity>k__BackingField;
    [CompilerGeneratedAttribute]
private float <GreenIntensity>k__BackingField;
    [CompilerGeneratedAttribute]
private float <RedIntensity>k__BackingField;
    public float BlueIntensity { get; }
    public float GreenIntensity { get; }
    public float RedIntensity { get; }
    public IntensityTexturePixel(float redIntensity, float greenIntensity, float blueIntensity);
    [CompilerGeneratedAttribute]
public float get_BlueIntensity();
    [CompilerGeneratedAttribute]
public float get_GreenIntensity();
    [CompilerGeneratedAttribute]
public float get_RedIntensity();
    public sealed virtual bool Equals(IntensityTexturePixel other);
    public static bool op_Equality(IntensityTexturePixel left, IntensityTexturePixel right);
    public static bool op_Inequality(IntensityTexturePixel left, IntensityTexturePixel right);
    internal static IntensityTexturePixel FromFloatArray(Single[] floats, int index);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal Single[] ToFloatArray();
}
public class NvAPIWrapper.Display.PathInfo : object {
    [CompilerGeneratedAttribute]
private ColorFormat <ColorFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGDIPrimary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSLIFocus>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LUID> <OSAdapterLUID>k__BackingField;
    [CompilerGeneratedAttribute]
private Position <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Resolution <Resolution>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private SpanningOrientation <SpanningOrientation>k__BackingField;
    [CompilerGeneratedAttribute]
private PathTargetInfo[] <TargetsInfo>k__BackingField;
    public ColorFormat ColorFormat { get; public set; }
    public bool IsGDIPrimary { get; public set; }
    public bool IsSLIFocus { get; public set; }
    public Nullable`1<LUID> OSAdapterLUID { get; }
    public Position Position { get; public set; }
    public Resolution Resolution { get; public set; }
    public UInt32 SourceId { get; public set; }
    public SpanningOrientation SpanningOrientation { get; public set; }
    public PathTargetInfo[] TargetsInfo { get; }
    public PathInfo(Resolution resolution, ColorFormat colorFormat, PathTargetInfo[] targetInfos);
    public PathInfo(IPathInfo info);
    [CompilerGeneratedAttribute]
public ColorFormat get_ColorFormat();
    [CompilerGeneratedAttribute]
public void set_ColorFormat(ColorFormat value);
    [CompilerGeneratedAttribute]
public bool get_IsGDIPrimary();
    [CompilerGeneratedAttribute]
public void set_IsGDIPrimary(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSLIFocus();
    [CompilerGeneratedAttribute]
public void set_IsSLIFocus(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<LUID> get_OSAdapterLUID();
    [CompilerGeneratedAttribute]
public Position get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(Position value);
    [CompilerGeneratedAttribute]
public Resolution get_Resolution();
    [CompilerGeneratedAttribute]
public void set_Resolution(Resolution value);
    [CompilerGeneratedAttribute]
public UInt32 get_SourceId();
    [CompilerGeneratedAttribute]
public void set_SourceId(UInt32 value);
    [CompilerGeneratedAttribute]
public SpanningOrientation get_SpanningOrientation();
    [CompilerGeneratedAttribute]
public void set_SpanningOrientation(SpanningOrientation value);
    [CompilerGeneratedAttribute]
public PathTargetInfo[] get_TargetsInfo();
    public sealed virtual bool Equals(PathInfo other);
    public static PathInfo[] GetDisplaysConfig();
    public static bool op_Equality(PathInfo left, PathInfo right);
    public static bool op_Inequality(PathInfo left, PathInfo right);
    public static void SetDisplaysConfig(PathInfo[] pathInfos, DisplayConfigFlags flags);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public PathInfoV1 GetPathInfoV1();
    public PathInfoV2 GetPathInfoV2();
    public PathTargetInfoV1[] GetPathTargetInfoV1Array();
    public PathTargetInfoV2[] GetPathTargetInfoV2Array();
    public SourceModeInfo GetSourceModeInfo();
}
public class NvAPIWrapper.Display.PathTargetInfo : object {
    private TimingOverride _timingOverride;
    [CompilerGeneratedAttribute]
private bool <DisableVirtualModeSupport>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayDevice <DisplayDevice>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClonePanAndScanTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClonePrimary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterlaced>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreferredUnscaledTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RefreshRateInMillihertz>k__BackingField;
    [CompilerGeneratedAttribute]
private Rotate <Rotation>k__BackingField;
    [CompilerGeneratedAttribute]
private Scaling <Scaling>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectorType <TVConnectorType>k__BackingField;
    [CompilerGeneratedAttribute]
private TVFormat <TVFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <WindowsCCDTargetId>k__BackingField;
    public bool DisableVirtualModeSupport { get; public set; }
    public DisplayDevice DisplayDevice { get; }
    public bool IsClonePanAndScanTarget { get; public set; }
    public bool IsClonePrimary { get; public set; }
    public bool IsInterlaced { get; public set; }
    public bool IsPreferredUnscaledTarget { get; public set; }
    public UInt32 RefreshRateInMillihertz { get; public set; }
    public Rotate Rotation { get; public set; }
    public Scaling Scaling { get; public set; }
    public TimingOverride TimingOverride { get; public set; }
    public ConnectorType TVConnectorType { get; public set; }
    public TVFormat TVFormat { get; public set; }
    public UInt32 WindowsCCDTargetId { get; }
    public PathTargetInfo(IPathTargetInfo info);
    public PathTargetInfo(DisplayDevice device);
    [CompilerGeneratedAttribute]
public bool get_DisableVirtualModeSupport();
    [CompilerGeneratedAttribute]
public void set_DisableVirtualModeSupport(bool value);
    [CompilerGeneratedAttribute]
public DisplayDevice get_DisplayDevice();
    [CompilerGeneratedAttribute]
public bool get_IsClonePanAndScanTarget();
    [CompilerGeneratedAttribute]
public void set_IsClonePanAndScanTarget(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsClonePrimary();
    [CompilerGeneratedAttribute]
public void set_IsClonePrimary(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInterlaced();
    [CompilerGeneratedAttribute]
public void set_IsInterlaced(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPreferredUnscaledTarget();
    [CompilerGeneratedAttribute]
public void set_IsPreferredUnscaledTarget(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_RefreshRateInMillihertz();
    [CompilerGeneratedAttribute]
public void set_RefreshRateInMillihertz(UInt32 value);
    [CompilerGeneratedAttribute]
public Rotate get_Rotation();
    [CompilerGeneratedAttribute]
public void set_Rotation(Rotate value);
    [CompilerGeneratedAttribute]
public Scaling get_Scaling();
    [CompilerGeneratedAttribute]
public void set_Scaling(Scaling value);
    public TimingOverride get_TimingOverride();
    public void set_TimingOverride(TimingOverride value);
    [CompilerGeneratedAttribute]
public ConnectorType get_TVConnectorType();
    [CompilerGeneratedAttribute]
public void set_TVConnectorType(ConnectorType value);
    [CompilerGeneratedAttribute]
public TVFormat get_TVFormat();
    [CompilerGeneratedAttribute]
public void set_TVFormat(TVFormat value);
    [CompilerGeneratedAttribute]
public UInt32 get_WindowsCCDTargetId();
    public sealed virtual bool Equals(PathTargetInfo other);
    public static bool op_Equality(PathTargetInfo left, PathTargetInfo right);
    public static bool op_Inequality(PathTargetInfo left, PathTargetInfo right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public PathAdvancedTargetInfo GetPathAdvancedTargetInfo();
    public PathTargetInfoV1 GetPathTargetInfoV1();
    public PathTargetInfoV2 GetPathTargetInfoV2();
}
public class NvAPIWrapper.Display.ScanOutInformation : object {
    [CompilerGeneratedAttribute]
private DisplayDevice <DisplayDevice>k__BackingField;
    public UInt32 CloneImportance { get; }
    public DisplayDevice DisplayDevice { get; }
    public bool IsDisplayWarped { get; }
    public bool IsIntensityModified { get; }
    public Rectangle SourceDesktopRectangle { get; }
    public Rotate SourceToTargetRotation { get; }
    public Rectangle SourceViewPortRectangle { get; }
    public UInt32 TargetDisplayHeight { get; }
    public UInt32 TargetDisplayWidth { get; }
    public Rectangle TargetViewPortRectangle { get; }
    internal ScanOutInformation(DisplayDevice displayDevice);
    public UInt32 get_CloneImportance();
    [CompilerGeneratedAttribute]
public DisplayDevice get_DisplayDevice();
    public bool get_IsDisplayWarped();
    public bool get_IsIntensityModified();
    public Rectangle get_SourceDesktopRectangle();
    public Rotate get_SourceToTargetRotation();
    public Rectangle get_SourceViewPortRectangle();
    public UInt32 get_TargetDisplayHeight();
    public UInt32 get_TargetDisplayWidth();
    public Rectangle get_TargetViewPortRectangle();
    public void DisableIntensityModifications(Boolean& isSticky);
    public void DisableWarping(Boolean& isSticky);
    public void EnableIntensityModifications(IntensityTexture intensityTexture, Boolean& isSticky);
    public void EnableIntensityModifications(IntensityTexture intensityTexture, FloatTexture offsetTexture, Boolean& isSticky);
    public void EnableWarping(WarpingVerticeFormat warpingVerticeFormat, XYUVRQVortex[] vortices, Rectangle textureRectangle, Boolean& isSticky);
    public ScanOutCompositionParameterValue GetCompositionParameterValue(ScanOutCompositionParameter parameter, Single& additionalValue);
    public void SetCompositionParameterValue(ScanOutCompositionParameter parameter, ScanOutCompositionParameterValue parameterValue, float additionalValue);
}
public class NvAPIWrapper.Display.UnAttachedDisplay : object {
    [CompilerGeneratedAttribute]
private UnAttachedDisplayHandle <Handle>k__BackingField;
    public UnAttachedDisplayHandle Handle { get; }
    public string Name { get; }
    public PhysicalGPU PhysicalGPU { get; }
    public UnAttachedDisplay(UnAttachedDisplayHandle handle);
    public UnAttachedDisplay(string displayName);
    [CompilerGeneratedAttribute]
public UnAttachedDisplayHandle get_Handle();
    public string get_Name();
    public PhysicalGPU get_PhysicalGPU();
    public sealed virtual bool Equals(UnAttachedDisplay other);
    public static UnAttachedDisplay[] GetUnAttachedDisplays();
    public static bool op_Equality(UnAttachedDisplay left, UnAttachedDisplay right);
    public static bool op_Inequality(UnAttachedDisplay left, UnAttachedDisplay right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public Display CreateDisplay();
}
public class NvAPIWrapper.Display.XYUVRQVortex : object {
    [CompilerGeneratedAttribute]
private float <Q>k__BackingField;
    [CompilerGeneratedAttribute]
private float <R>k__BackingField;
    [CompilerGeneratedAttribute]
private int <U>k__BackingField;
    [CompilerGeneratedAttribute]
private int <V>k__BackingField;
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    public float Q { get; }
    public float R { get; }
    public int U { get; }
    public int V { get; }
    public int X { get; }
    public int Y { get; }
    public XYUVRQVortex(int x, int y, int u, int v, float r, float q);
    [CompilerGeneratedAttribute]
public float get_Q();
    [CompilerGeneratedAttribute]
public float get_R();
    [CompilerGeneratedAttribute]
public int get_U();
    [CompilerGeneratedAttribute]
public int get_V();
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public int get_Y();
    public sealed virtual bool Equals(XYUVRQVortex other);
    [IteratorStateMachineAttribute("NvAPIWrapper.Display.XYUVRQVortex/<FromFloatArray>d__20")]
public static IEnumerable`1<XYUVRQVortex> FromFloatArray(Single[] floats);
    public static bool op_Equality(XYUVRQVortex left, XYUVRQVortex right);
    public static bool op_Inequality(XYUVRQVortex left, XYUVRQVortex right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Single[] AsFloatArray();
}
public class NvAPIWrapper.DRS.DriverSettingsProfile : object {
    [CompilerGeneratedAttribute]
private DRSProfileHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private DriverSettingsSession <Session>k__BackingField;
    public IEnumerable`1<ProfileApplication> Applications { get; }
    public DRSGPUSupport GPUSupport { get; public set; }
    public DRSProfileHandle Handle { get; private set; }
    public bool IsPredefined { get; }
    public bool IsValid { get; }
    public string Name { get; }
    public int NumberOfApplications { get; }
    public int NumberOfSettings { get; }
    public DriverSettingsSession Session { get; }
    public IEnumerable`1<ProfileSetting> Settings { get; }
    internal DriverSettingsProfile(DRSProfileHandle handle, DriverSettingsSession parentSession);
    public IEnumerable`1<ProfileApplication> get_Applications();
    public DRSGPUSupport get_GPUSupport();
    public void set_GPUSupport(DRSGPUSupport value);
    [CompilerGeneratedAttribute]
public DRSProfileHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(DRSProfileHandle value);
    public bool get_IsPredefined();
    public bool get_IsValid();
    public string get_Name();
    public int get_NumberOfApplications();
    public int get_NumberOfSettings();
    [CompilerGeneratedAttribute]
public DriverSettingsSession get_Session();
    public IEnumerable`1<ProfileSetting> get_Settings();
    public static DriverSettingsProfile CreateProfile(DriverSettingsSession session, string profileName, Nullable`1<DRSGPUSupport> gpuSupport);
    public virtual string ToString();
    public void Delete();
    public void DeleteApplicationByName(string applicationName);
    public void DeleteSetting(UInt32 settingId);
    public void DeleteSetting(KnownSettingId settingId);
    public ProfileApplication GetApplicationByName(string applicationName);
    public ProfileSetting GetSetting(UInt32 settingId);
    public ProfileSetting GetSetting(KnownSettingId settingId);
    public void RestoreDefaults();
    public void RestoreSettingToDefault(UInt32 settingId);
    public void RestoreSettingToDefault(KnownSettingId settingId);
    public void SetSetting(KnownSettingId settingId, DRSSettingType settingType, object value);
    public void SetSetting(KnownSettingId settingId, string value);
    public void SetSetting(KnownSettingId settingId, Byte[] value);
    public void SetSetting(KnownSettingId settingId, UInt32 value);
    public void SetSetting(UInt32 settingId, DRSSettingType settingType, object value);
    public void SetSetting(UInt32 settingId, string value);
    public void SetSetting(UInt32 settingId, Byte[] value);
    public void SetSetting(UInt32 settingId, UInt32 value);
    [CompilerGeneratedAttribute]
private ProfileApplication <get_Applications>b__2_0(IDRSApplication application);
}
public class NvAPIWrapper.DRS.DriverSettingsSession : object {
    [CompilerGeneratedAttribute]
private DRSSessionHandle <Handle>k__BackingField;
    public DriverSettingsProfile BaseProfile { get; }
    public DriverSettingsProfile CurrentGlobalProfile { get; public set; }
    public DRSSessionHandle Handle { get; }
    public int NumberOfProfiles { get; }
    public IEnumerable`1<DriverSettingsProfile> Profiles { get; }
    internal DriverSettingsSession(DRSSessionHandle handle);
    public DriverSettingsProfile get_BaseProfile();
    public DriverSettingsProfile get_CurrentGlobalProfile();
    public void set_CurrentGlobalProfile(DriverSettingsProfile value);
    [CompilerGeneratedAttribute]
public DRSSessionHandle get_Handle();
    public int get_NumberOfProfiles();
    public IEnumerable`1<DriverSettingsProfile> get_Profiles();
    public sealed virtual void Dispose();
    public static DriverSettingsSession CreateAndLoad();
    public static DriverSettingsSession CreateAndLoad(string fileName);
    public virtual string ToString();
    public ProfileApplication FindApplication(string applicationName);
    public DriverSettingsProfile FindApplicationProfile(string applicationName);
    public DriverSettingsProfile FindProfileByName(string profileName);
    public void RestoreDefaults();
    public void Save();
    public void Save(string fileName);
    private void Load();
    private void Load(string fileName);
    private void ReleaseUnmanagedResources();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
private DriverSettingsProfile <get_Profiles>b__13_0(DRSProfileHandle handle);
}
public enum NvAPIWrapper.DRS.KnownSettingId : Enum {
    public UInt32 value__;
    [DescriptionAttribute("Antialiasing - Line gamma")]
public static KnownSettingId OpenGLAntiAliasingLineGamma;
    [DescriptionAttribute("Deep color for 3D applications")]
public static KnownSettingId OpenGLDeepColorScanOut;
    [DescriptionAttribute("OpenGL default swap interval")]
public static KnownSettingId OpenGLDefaultSwapInterval;
    [DescriptionAttribute("OpenGL default swap interval fraction")]
public static KnownSettingId OpenGLDefaultSwapIntervalFractional;
    [DescriptionAttribute("OpenGL default swap interval sign")]
public static KnownSettingId OpenGLDefaultSwapIntervalSign;
    [DescriptionAttribute("Event Log Severity Threshold")]
public static KnownSettingId OpenGLEventLogSeverityThreshold;
    [DescriptionAttribute("Extension String version")]
public static KnownSettingId OpenGLExtensionStringVersion;
    [DescriptionAttribute("Buffer-flipping mode")]
public static KnownSettingId OpenGLForceBlit;
    [DescriptionAttribute("Force Stereo shuttering")]
public static KnownSettingId OpenGLForceStereo;
    [DescriptionAttribute("Preferred OpenGL GPU")]
public static KnownSettingId OpenGLImplicitGPUAffinity;
    [DescriptionAttribute("Maximum frames allowed")]
public static KnownSettingId OpenGLMaximumFramesAllowed;
    [DescriptionAttribute("Exported Overlay pixel types")]
public static KnownSettingId OpenGLOverlayPixelType;
    [DescriptionAttribute("Enable overlay")]
public static KnownSettingId OpenGLOverlaySupport;
    [DescriptionAttribute("High level control of the rendering quality on OpenGL")]
public static KnownSettingId OpenGLQualityEnhancements;
    [DescriptionAttribute("Unified back/depth buffer")]
public static KnownSettingId OpenGLSingleBackDepthBuffer;
    [DescriptionAttribute("Enable NV_gpu_multicast extension")]
public static KnownSettingId OpenGLSLIMulticast;
    [DescriptionAttribute("Threaded optimization")]
public static KnownSettingId OpenGLThreadControl;
    [DescriptionAttribute("Event Log Tmon Severity Threshold")]
public static KnownSettingId OpenGLTMONLevel;
    [DescriptionAttribute("Triple buffering")]
public static KnownSettingId OpenGLTripleBuffer;
    [DescriptionAttribute("Antialiasing - Behavior Flags")]
public static KnownSettingId AntiAliasingBehaviorFlags;
    [DescriptionAttribute("Antialiasing - Transparency Multisampling")]
public static KnownSettingId AntiAliasingModeAlphaToCoverage;
    [DescriptionAttribute("Antialiasing - Gamma correction")]
public static KnownSettingId AntiAliasingModeGammaCorrection;
    [DescriptionAttribute("Antialiasing - Setting")]
public static KnownSettingId AntiAliasingModeMethod;
    [DescriptionAttribute("Antialiasing - Transparency Supersampling")]
public static KnownSettingId AntiAliasingModeReplay;
    [DescriptionAttribute("Antialiasing - Mode")]
public static KnownSettingId AntiAliasingModeSelector;
    [DescriptionAttribute("Antialiasing - SLI AA")]
public static KnownSettingId AntiAliasingModeSelectorSLIAntiAliasing;
    [DescriptionAttribute("Anisotropic filtering setting")]
public static KnownSettingId AnisotropicModeLevel;
    [DescriptionAttribute("Anisotropic filtering mode")]
public static KnownSettingId AnisotropicModeSelector;
    [DescriptionAttribute("NVIDIA Predefined Ansel Usage")]
public static KnownSettingId AnselAllow;
    [DescriptionAttribute("Enable Ansel")]
public static KnownSettingId AnselEnable;
    [DescriptionAttribute("Ansel flags for enabled applications")]
public static KnownSettingId AnselWhiteListed;
    [DescriptionAttribute("Application Profile Notification Popup Timeout")]
public static KnownSettingId ApplicationProfileNotificationTimeOut;
    [DescriptionAttribute("Steam Application ID")]
public static KnownSettingId ApplicationSteamId;
    [DescriptionAttribute("Battery Boost")]
public static KnownSettingId BatteryBoost;
    [DescriptionAttribute("Do not display this profile in the Control Panel")]
public static KnownSettingId ControlPanelHiddenProfile;
    [DescriptionAttribute("List of Universal GPU ids")]
public static KnownSettingId CUDAExcludedGPUs;
    [DescriptionAttribute("Maximum GPU Power")]
public static KnownSettingId D3DOpenGLGPUMaximumPower;
    [DescriptionAttribute("Export Performance Counters")]
public static KnownSettingId ExportPerformanceCounters;
    [DescriptionAttribute("NVIDIA Predefined FXAA Usage")]
public static KnownSettingId FXAAAllow;
    [DescriptionAttribute("Enable FXAA")]
public static KnownSettingId FXAAEnable;
    [DescriptionAttribute("Enable FXAA Indicator")]
public static KnownSettingId FXAAIndicatorEnable;
    [DescriptionAttribute("SLI indicator")]
public static KnownSettingId MCSFRShowSplit;
    [DescriptionAttribute("NVIDIA Quality upscaling")]
public static KnownSettingId NvidiaQualityUpScaling;
    [DescriptionAttribute("Maximum AA samples allowed for a given application")]
public static KnownSettingId OptimusMaximumAntiAliasing;
    [DescriptionAttribute("Display the PhysX indicator")]
public static KnownSettingId PhysxIndicator;
    [DescriptionAttribute("Power management mode")]
public static KnownSettingId PreferredPerformanceState;
    [DescriptionAttribute("No override of Anisotropic filtering")]
public static KnownSettingId PreventUiAnisotropicOverride;
    [DescriptionAttribute("Frame Rate Limiter")]
public static KnownSettingId PerformanceStateFrameRateLimiter;
    [DescriptionAttribute("Frame Rate Limiter 2 Control")]
public static KnownSettingId PerformanceStateFrameRateLimiter2Control;
    [DescriptionAttribute("Frame Rate Monitor")]
public static KnownSettingId PerformanceStateFrameRateLimiterGpsControl;
    [DescriptionAttribute("Frame Rate Monitor Control")]
public static KnownSettingId PerformanceStateFrameRateMonitorControl;
    [DescriptionAttribute("Maximum resolution allowed for a given application")]
public static KnownSettingId ShimMaxResolution;
    [DescriptionAttribute("Optimus flags for enabled applications")]
public static KnownSettingId ShimMCCOMPAT;
    [DescriptionAttribute("Enable application for Optimus")]
public static KnownSettingId ShimRenderingMode;
    [DescriptionAttribute("Shim Rendering Mode Options per application for Optimus")]
public static KnownSettingId ShimRenderingOptions;
    [DescriptionAttribute("Number of GPUs to use on SLI rendering mode")]
public static KnownSettingId SLIGPUCount;
    [DescriptionAttribute("NVIDIA predefined number of GPUs to use on SLI rendering mode")]
public static KnownSettingId SLIPredefinedGPUCount;
    [DescriptionAttribute("NVIDIA predefined number of GPUs to use on SLI rendering mode on DirectX 10")]
public static KnownSettingId SLIPredefinedGPUCountDX10;
    [DescriptionAttribute("NVIDIA predefined SLI mode")]
public static KnownSettingId SLIPredefinedMode;
    [DescriptionAttribute("NVIDIA predefined SLI mode on DirectX 10")]
public static KnownSettingId SLIPredefinedModeDX10;
    [DescriptionAttribute("SLI rendering mode")]
public static KnownSettingId SLIRenderingMode;
    [DescriptionAttribute("Virtual Reality pre-rendered frames")]
public static KnownSettingId VRPreRenderLimit;
    [DescriptionAttribute("Toggle the VRR global feature")]
public static KnownSettingId VRRFeatureIndicator;
    [DescriptionAttribute("Display the VRR Overlay Indicator")]
public static KnownSettingId VRROverlayIndicator;
    [DescriptionAttribute("VRR requested state")]
public static KnownSettingId VRRRequestState;
    [DescriptionAttribute("G-SYNC")]
public static KnownSettingId VRRApplicationOverride;
    [DescriptionAttribute("G-SYNC")]
public static KnownSettingId VRRApplicationOverrideRequestState;
    [DescriptionAttribute("Enable G-SYNC globally")]
public static KnownSettingId VRRMode;
    [DescriptionAttribute("Flag to control smooth AFR behavior")]
public static KnownSettingId VSyncSmoothAFR;
    [DescriptionAttribute("Variable refresh Rate")]
public static KnownSettingId VSyncVRRControl;
    [DescriptionAttribute("Vsync - Behavior Flags")]
public static KnownSettingId VSyncBehaviorFlags;
    [DescriptionAttribute("Stereo - Swap eyes")]
public static KnownSettingId WKSAPIStereoEyesExchange;
    [DescriptionAttribute("Stereo - Display mode")]
public static KnownSettingId WKSAPIStereoMode;
    [DescriptionAttribute("Memory Allocation Policy")]
public static KnownSettingId WKSMemoryAllocationPolicy;
    [DescriptionAttribute("Stereo - Dongle Support")]
public static KnownSettingId WKSStereoDongleSupport;
    [DescriptionAttribute("Stereo - Enable")]
public static KnownSettingId WKSStereoSupport;
    [DescriptionAttribute("Stereo ï¿½ swap mode")]
public static KnownSettingId WKSStereoSwapMode;
    [DescriptionAttribute("Ambient Occlusion")]
public static KnownSettingId AmbientOcclusionMode;
    [DescriptionAttribute("NVIDIA Predefined Ambient Occlusion Usage")]
public static KnownSettingId AmbientOcclusionModeActive;
    [DescriptionAttribute("Texture filtering - Driver Controlled LOD Bias")]
public static KnownSettingId AutoLODBiasAdjust;
    [DescriptionAttribute("Export Performance Counters for DX9 only")]
public static KnownSettingId ExportPerformanceCountersDX9Only;
    [DescriptionAttribute("ICafe Settings")]
public static KnownSettingId ICafeLogoConfig;
    [DescriptionAttribute("Texture filtering - LOD Bias")]
public static KnownSettingId LODBiasAdjust;
    [DescriptionAttribute("Enable sample interleaving (MFAA)")]
public static KnownSettingId MaxwellBSampleInterleave;
    [DescriptionAttribute("Maximum pre-rendered frames")]
public static KnownSettingId PreRenderLimit;
    [DescriptionAttribute("Shader Cache")]
public static KnownSettingId PerformanceStateShaderDiskCache;
    [DescriptionAttribute("Texture filtering - Anisotropic sample optimization")]
public static KnownSettingId PerformanceStateTextureFilteringAnisotropicOptimization;
    [DescriptionAttribute("Texture filtering - Anisotropic filter optimization")]
public static KnownSettingId PerformanceStateTextureFilteringBiLinearInAnisotropic;
    [DescriptionAttribute("Texture filtering - Trilinear optimization")]
public static KnownSettingId PerformanceStateTextureFilteringDisableTrilinearSlope;
    [DescriptionAttribute("Texture filtering - Negative LOD bias")]
public static KnownSettingId PerformanceStateTextureFilteringNoNegativeLODBias;
    [DescriptionAttribute("Texture filtering - Quality")]
public static KnownSettingId QualityEnhancements;
    [DescriptionAttribute("Preferred refresh rate")]
public static KnownSettingId RefreshRateOverride;
    [DescriptionAttribute("PowerThrottle")]
public static KnownSettingId SetPowerThrottleForPCIeCompliance;
    [DescriptionAttribute("VAB Default Data")]
public static KnownSettingId SetVABData;
    [DescriptionAttribute("Vertical Sync")]
public static KnownSettingId VSyncMode;
    [DescriptionAttribute("Vertical Sync Tear Control")]
public static KnownSettingId VSyncTearControl;
    public static KnownSettingId InvalidSetting;
}
public class NvAPIWrapper.DRS.ProfileApplication : object {
    private IDRSApplication _application;
    [CompilerGeneratedAttribute]
private DriverSettingsProfile <Profile>k__BackingField;
    public string ApplicationName { get; }
    public string CommandLine { get; }
    public String[] FilesInFolder { get; }
    public string FriendlyName { get; }
    public Nullable`1<bool> HasCommandLine { get; }
    public Nullable`1<bool> IsMetroApplication { get; }
    public bool IsPredefined { get; }
    public bool IsValid { get; }
    public string LauncherName { get; }
    public DriverSettingsProfile Profile { get; }
    internal ProfileApplication(IDRSApplication application, DriverSettingsProfile profile);
    public string get_ApplicationName();
    public string get_CommandLine();
    public String[] get_FilesInFolder();
    public string get_FriendlyName();
    public Nullable`1<bool> get_HasCommandLine();
    public Nullable`1<bool> get_IsMetroApplication();
    public bool get_IsPredefined();
    public bool get_IsValid();
    public string get_LauncherName();
    [CompilerGeneratedAttribute]
public DriverSettingsProfile get_Profile();
    public static ProfileApplication CreateApplication(DriverSettingsProfile profile, string applicationName, string friendlyName, string launcherName, String[] fileInFolders, bool isMetro, string commandLine);
    private static IDRSApplication CreateApplicationInstanceV1(string applicationName, string friendlyName, string launcherName, String[] fileInFolders, bool isMetro, string commandLine);
    private static IDRSApplication CreateApplicationInstanceV2(string applicationName, string friendlyName, string launcherName, String[] fileInFolders, bool isMetro, string commandLine);
    private static IDRSApplication CreateApplicationInstanceV3(string applicationName, string friendlyName, string launcherName, String[] fileInFolders, bool isMetro, string commandLine);
    private static IDRSApplication CreateApplicationInstanceV4(string applicationName, string friendlyName, string launcherName, String[] fileInFolders, bool isMetro, string commandLine);
    public virtual string ToString();
    public void Delete();
}
public class NvAPIWrapper.DRS.ProfileSetting : object {
    private DRSSettingV1 _setting;
    public object CurrentValue { get; }
    public bool IsCurrentValuePredefined { get; }
    public bool IsPredefinedValueValid { get; }
    public object PredefinedValue { get; }
    public UInt32 SettingId { get; }
    public SettingInfo SettingInfo { get; }
    public DRSSettingLocation SettingLocation { get; }
    public DRSSettingType SettingType { get; }
    internal ProfileSetting(DRSSettingV1 setting);
    public object get_CurrentValue();
    public bool get_IsCurrentValuePredefined();
    public bool get_IsPredefinedValueValid();
    public object get_PredefinedValue();
    public UInt32 get_SettingId();
    public SettingInfo get_SettingInfo();
    public DRSSettingLocation get_SettingLocation();
    public DRSSettingType get_SettingType();
    public virtual string ToString();
}
public class NvAPIWrapper.DRS.SettingInfo : object {
    private static UInt32[] _availableSettingIds;
    [CompilerGeneratedAttribute]
private UInt32 <SettingId>k__BackingField;
    public Object[] AvailableValues { get; }
    public object DefaultValue { get; }
    public bool IsAvailable { get; }
    public bool IsKnown { get; }
    public string KnownDescription { get; }
    public Nullable`1<KnownSettingId> KnownSettingId { get; }
    public Type KnownValueType { get; }
    public string Name { get; }
    public UInt32 SettingId { get; }
    public Nullable`1<DRSSettingType> SettingType { get; }
    private SettingInfo(UInt32 settingId);
    public Object[] get_AvailableValues();
    public object get_DefaultValue();
    public bool get_IsAvailable();
    public bool get_IsKnown();
    public string get_KnownDescription();
    public Nullable`1<KnownSettingId> get_KnownSettingId();
    public Type get_KnownValueType();
    public string get_Name();
    [CompilerGeneratedAttribute]
public UInt32 get_SettingId();
    public Nullable`1<DRSSettingType> get_SettingType();
    public static SettingInfo FromId(UInt32 settingId);
    public static SettingInfo FromKnownSettingId(KnownSettingId settingId);
    public static SettingInfo FromName(string settingName);
    public static SettingInfo[] GetAvailableSetting();
    public static Nullable`1<KnownSettingId> GetKnownSettingId(UInt32 settingId);
    public static string GetSettingDescription(KnownSettingId knownSettingId);
    public static UInt32 GetSettingId(KnownSettingId knownSettingId);
    public static bool IsSettingKnown(UInt32 settingId);
    public virtual string ToString();
    public string ResolveKnownValueName(object value);
    [CompilerGeneratedAttribute]
private bool <get_IsAvailable>b__7_0(SettingInfo info);
}
public enum NvAPIWrapper.DRS.SettingValues.AmbientOcclusionMode : Enum {
    public UInt32 value__;
    public static AmbientOcclusionMode Off;
    public static AmbientOcclusionMode Low;
    public static AmbientOcclusionMode Medium;
    public static AmbientOcclusionMode High;
    public static AmbientOcclusionMode Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AmbientOcclusionModeActive : Enum {
    public UInt32 value__;
    public static AmbientOcclusionModeActive Disabled;
    public static AmbientOcclusionModeActive Enabled;
    public static AmbientOcclusionModeActive Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AnisotropicModeLevel : Enum {
    public UInt32 value__;
    public static AnisotropicModeLevel Mask;
    public static AnisotropicModeLevel NonePoint;
    public static AnisotropicModeLevel NoneLinear;
    public static AnisotropicModeLevel Maximum;
    public static AnisotropicModeLevel Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AnisotropicModeSelector : Enum {
    public UInt32 value__;
    public static AnisotropicModeSelector Mask;
    public static AnisotropicModeSelector Application;
    public static AnisotropicModeSelector User;
    public static AnisotropicModeSelector Condition;
    public static AnisotropicModeSelector Maximum;
    public static AnisotropicModeSelector Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AnselAllow : Enum {
    public UInt32 value__;
    public static AnselAllow Disallowed;
    public static AnselAllow Allowed;
    public static AnselAllow Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AnselEnable : Enum {
    public UInt32 value__;
    public static AnselEnable Off;
    public static AnselEnable On;
    public static AnselEnable Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AnselWhiteListed : Enum {
    public UInt32 value__;
    public static AnselWhiteListed Disallowed;
    public static AnselWhiteListed Allowed;
    public static AnselWhiteListed Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AntiAliasingBehaviorFlags : Enum {
    public UInt32 value__;
    public static AntiAliasingBehaviorFlags None;
    public static AntiAliasingBehaviorFlags TreatOverrideAsApplicationControlled;
    public static AntiAliasingBehaviorFlags TreatOverrideAsEnhance;
    public static AntiAliasingBehaviorFlags DisableOverride;
    public static AntiAliasingBehaviorFlags TreatEnhanceAsApplicationControlled;
    public static AntiAliasingBehaviorFlags TreatEnhanceAsOverride;
    public static AntiAliasingBehaviorFlags DisableEnhance;
    public static AntiAliasingBehaviorFlags MapVCAAToMultiSampling;
    public static AntiAliasingBehaviorFlags SLIDisableTransparencySupersampling;
    public static AntiAliasingBehaviorFlags DisableCplaa;
    public static AntiAliasingBehaviorFlags SkipRTDIMCheckForEnhance;
    public static AntiAliasingBehaviorFlags DisableSLIAntiAliasing;
    public static AntiAliasingBehaviorFlags Default;
    public static AntiAliasingBehaviorFlags AntiAliasingRTBPPDIV4;
    public static AntiAliasingBehaviorFlags AntiAliasingRTBPPDIV4Shift;
    public static AntiAliasingBehaviorFlags NonAntiAliasingRTBPPDIV4;
    public static AntiAliasingBehaviorFlags NonAntiAliasingRTBPPDIV4Shift;
    public static AntiAliasingBehaviorFlags Mask;
}
public enum NvAPIWrapper.DRS.SettingValues.AntiAliasingModeAlphaToCoverage : Enum {
    public UInt32 value__;
    public static AntiAliasingModeAlphaToCoverage ModeMask;
    public static AntiAliasingModeAlphaToCoverage ModeOff;
    public static AntiAliasingModeAlphaToCoverage ModeOn;
    public static AntiAliasingModeAlphaToCoverage ModeMaximum;
    public static AntiAliasingModeAlphaToCoverage Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AntiAliasingModeGammaCorrection : Enum {
    public UInt32 value__;
    public static AntiAliasingModeGammaCorrection Mask;
    public static AntiAliasingModeGammaCorrection Off;
    public static AntiAliasingModeGammaCorrection OnIfFOS;
    public static AntiAliasingModeGammaCorrection OnAlways;
    public static AntiAliasingModeGammaCorrection Maximum;
    public static AntiAliasingModeGammaCorrection Default;
    public static AntiAliasingModeGammaCorrection DefaultTesla;
    public static AntiAliasingModeGammaCorrection DefaultFermi;
}
public enum NvAPIWrapper.DRS.SettingValues.AntiAliasingModeMethod : Enum {
    public UInt32 value__;
    public static AntiAliasingModeMethod None;
    public static AntiAliasingModeMethod SuperSample2XHorizontal;
    public static AntiAliasingModeMethod SuperSample2XVertical;
    public static AntiAliasingModeMethod SuperSample15X15;
    public static AntiAliasingModeMethod Free0X03;
    public static AntiAliasingModeMethod Free0X04;
    public static AntiAliasingModeMethod SuperSample4X;
    public static AntiAliasingModeMethod SuperSample4XBias;
    public static AntiAliasingModeMethod SuperSample4XGaussian;
    public static AntiAliasingModeMethod Free0X08;
    public static AntiAliasingModeMethod Free0X09;
    public static AntiAliasingModeMethod SuperSample9X;
    public static AntiAliasingModeMethod SuperSample9XBias;
    public static AntiAliasingModeMethod SuperSample16X;
    public static AntiAliasingModeMethod SuperSample16XBias;
    public static AntiAliasingModeMethod MultiSample2XDiagonal;
    public static AntiAliasingModeMethod MultiSample2XQuincunx;
    public static AntiAliasingModeMethod MultiSample4X;
    public static AntiAliasingModeMethod Free0X11;
    public static AntiAliasingModeMethod MultiSample4XGaussian;
    public static AntiAliasingModeMethod MixedSample4XSkewed4Tap;
    public static AntiAliasingModeMethod Free0X14;
    public static AntiAliasingModeMethod Free0X15;
    public static AntiAliasingModeMethod MixedSample6X;
    public static AntiAliasingModeMethod MixedSample6XSkewed6Tap;
    public static AntiAliasingModeMethod MixedSample8X;
    public static AntiAliasingModeMethod MixedSample8XSkewed8Tap;
    public static AntiAliasingModeMethod MixedSample16X;
    public static AntiAliasingModeMethod MultiSample4XGamma;
    public static AntiAliasingModeMethod MultiSample16X;
    public static AntiAliasingModeMethod VCAA32X8V24;
    public static AntiAliasingModeMethod CorruptionCheck;
    public static AntiAliasingModeMethod _6XCT;
    public static AntiAliasingModeMethod MultiSample2XDiagonalGamma;
    public static AntiAliasingModeMethod SuperSample4XGamma;
    public static AntiAliasingModeMethod MultiSample4XFosgamma;
    public static AntiAliasingModeMethod MultiSample2XDiagonalFosgamma;
    public static AntiAliasingModeMethod SuperSample4XFosgamma;
    public static AntiAliasingModeMethod MultiSample8X;
    public static AntiAliasingModeMethod VCAA8X4V4;
    public static AntiAliasingModeMethod VCAA16X4V12;
    public static AntiAliasingModeMethod VCAA16X8V8;
    public static AntiAliasingModeMethod MixedSample32X;
    public static AntiAliasingModeMethod SuperVCAA64X4V12;
    public static AntiAliasingModeMethod SuperVCAA64X8V8;
    public static AntiAliasingModeMethod MixedSample64X;
    public static AntiAliasingModeMethod MixedSample128X;
    public static AntiAliasingModeMethod Count;
    public static AntiAliasingModeMethod MethodMask;
    public static AntiAliasingModeMethod MethodMaximum;
    public static AntiAliasingModeMethod Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AntiAliasingModeReplay : Enum {
    public UInt32 value__;
    public static AntiAliasingModeReplay SamplesMask;
    public static AntiAliasingModeReplay SamplesOne;
    public static AntiAliasingModeReplay SamplesTwo;
    public static AntiAliasingModeReplay SamplesFour;
    public static AntiAliasingModeReplay SamplesEight;
    public static AntiAliasingModeReplay SamplesMaximum;
    public static AntiAliasingModeReplay ModeMask;
    public static AntiAliasingModeReplay ModeOff;
    public static AntiAliasingModeReplay ModeAlphaTest;
    public static AntiAliasingModeReplay ModePixelKill;
    public static AntiAliasingModeReplay ModeDynamicBranch;
    public static AntiAliasingModeReplay ModeOptimal;
    public static AntiAliasingModeReplay ModeAll;
    public static AntiAliasingModeReplay ModeMaximum;
    public static AntiAliasingModeReplay Transparency;
    public static AntiAliasingModeReplay DisAllowTraa;
    public static AntiAliasingModeReplay TransparencyDefault;
    public static AntiAliasingModeReplay TransparencyDefaultTesla;
    public static AntiAliasingModeReplay TransparencyDefaultFermi;
    public static AntiAliasingModeReplay Mask;
    public static AntiAliasingModeReplay Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AntiAliasingModeSelector : Enum {
    public UInt32 value__;
    public static AntiAliasingModeSelector Mask;
    public static AntiAliasingModeSelector ApplicationControl;
    public static AntiAliasingModeSelector Override;
    public static AntiAliasingModeSelector Enhance;
    public static AntiAliasingModeSelector Maximum;
    public static AntiAliasingModeSelector Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AntiAliasingModeSelectorSLIAntiAliasing : Enum {
    public UInt32 value__;
    public static AntiAliasingModeSelectorSLIAntiAliasing Disabled;
    public static AntiAliasingModeSelectorSLIAntiAliasing Enabled;
    public static AntiAliasingModeSelectorSLIAntiAliasing Default;
}
public enum NvAPIWrapper.DRS.SettingValues.ApplicationProfileNotificationTimeOut : Enum {
    public UInt32 value__;
    public static ApplicationProfileNotificationTimeOut Disabled;
    public static ApplicationProfileNotificationTimeOut NineSeconds;
    public static ApplicationProfileNotificationTimeOut FifteenSeconds;
    public static ApplicationProfileNotificationTimeOut ThirtySeconds;
    public static ApplicationProfileNotificationTimeOut OneMinute;
    public static ApplicationProfileNotificationTimeOut TwoMinutes;
    public static ApplicationProfileNotificationTimeOut Default;
}
public enum NvAPIWrapper.DRS.SettingValues.AutoLODBiasAdjust : Enum {
    public UInt32 value__;
    public static AutoLODBiasAdjust Off;
    public static AutoLODBiasAdjust On;
    public static AutoLODBiasAdjust Default;
}
public enum NvAPIWrapper.DRS.SettingValues.BatteryBoost : Enum {
    public UInt32 value__;
    public static BatteryBoost Minimum;
    public static BatteryBoost Maximum;
    public static BatteryBoost Enabled;
    public static BatteryBoost Disabled;
    public static BatteryBoost Default;
}
public enum NvAPIWrapper.DRS.SettingValues.ControlPanelHiddenProfile : Enum {
    public UInt32 value__;
    public static ControlPanelHiddenProfile Disabled;
    public static ControlPanelHiddenProfile Enabled;
    public static ControlPanelHiddenProfile Default;
}
public static class NvAPIWrapper.DRS.SettingValues.CUDAExcludedGPUs : object {
    public static string Default;
    public static string None;
}
public static class NvAPIWrapper.DRS.SettingValues.D3DOpenGLGPUMaximumPower : object {
    public static string Default;
    public static string DefaultPower;
}
public enum NvAPIWrapper.DRS.SettingValues.ExportPerformanceCounters : Enum {
    public UInt32 value__;
    public static ExportPerformanceCounters Off;
    public static ExportPerformanceCounters On;
    public static ExportPerformanceCounters Default;
}
public enum NvAPIWrapper.DRS.SettingValues.ExportPerformanceCountersDX9Only : Enum {
    public UInt32 value__;
    public static ExportPerformanceCountersDX9Only Off;
    public static ExportPerformanceCountersDX9Only On;
    public static ExportPerformanceCountersDX9Only Default;
}
public enum NvAPIWrapper.DRS.SettingValues.FXAAAllow : Enum {
    public UInt32 value__;
    public static FXAAAllow Disallowed;
    public static FXAAAllow Allowed;
    public static FXAAAllow Default;
}
public enum NvAPIWrapper.DRS.SettingValues.FXAAEnable : Enum {
    public UInt32 value__;
    public static FXAAEnable Off;
    public static FXAAEnable On;
    public static FXAAEnable Default;
}
public enum NvAPIWrapper.DRS.SettingValues.FXAAIndicatorEnable : Enum {
    public UInt32 value__;
    public static FXAAIndicatorEnable Off;
    public static FXAAIndicatorEnable On;
    public static FXAAIndicatorEnable Default;
}
public enum NvAPIWrapper.DRS.SettingValues.LODBiasAdjust : Enum {
    public UInt32 value__;
    public static LODBiasAdjust Minimum;
    public static LODBiasAdjust Maximum;
    public static LODBiasAdjust Default;
}
public enum NvAPIWrapper.DRS.SettingValues.MaxwellBSampleInterleave : Enum {
    public UInt32 value__;
    public static MaxwellBSampleInterleave Off;
    public static MaxwellBSampleInterleave On;
    public static MaxwellBSampleInterleave Default;
}
public enum NvAPIWrapper.DRS.SettingValues.MCSFRShowSplit : Enum {
    public UInt32 value__;
    public static MCSFRShowSplit Disabled;
    public static MCSFRShowSplit Enabled;
    public static MCSFRShowSplit Default;
}
public enum NvAPIWrapper.DRS.SettingValues.NvidiaQualityUpScaling : Enum {
    public UInt32 value__;
    public static NvidiaQualityUpScaling Off;
    public static NvidiaQualityUpScaling On;
    public static NvidiaQualityUpScaling Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLAntiAliasingLineGamma : Enum {
    public UInt32 value__;
    public static OpenGLAntiAliasingLineGamma Disabled;
    public static OpenGLAntiAliasingLineGamma Enabled;
    public static OpenGLAntiAliasingLineGamma Minimum;
    public static OpenGLAntiAliasingLineGamma Maximum;
    public static OpenGLAntiAliasingLineGamma Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLDeepColorScanOut : Enum {
    public UInt32 value__;
    public static OpenGLDeepColorScanOut Disable;
    public static OpenGLDeepColorScanOut Enable;
    public static OpenGLDeepColorScanOut Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLDefaultSwapInterval : Enum {
    public UInt32 value__;
    public static OpenGLDefaultSwapInterval Tear;
    public static OpenGLDefaultSwapInterval VSyncOne;
    public static OpenGLDefaultSwapInterval VSync;
    public static OpenGLDefaultSwapInterval ValueMask;
    public static OpenGLDefaultSwapInterval ForceMask;
    public static OpenGLDefaultSwapInterval ForceOff;
    public static OpenGLDefaultSwapInterval ForceOn;
    public static OpenGLDefaultSwapInterval ApplicationControlled;
    public static OpenGLDefaultSwapInterval Disable;
    public static OpenGLDefaultSwapInterval Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLDefaultSwapIntervalFractional : Enum {
    public UInt32 value__;
    public static OpenGLDefaultSwapIntervalFractional ZeroScanLines;
    public static OpenGLDefaultSwapIntervalFractional OneFullFrameOfScanLines;
    public static OpenGLDefaultSwapIntervalFractional Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLDefaultSwapIntervalSign : Enum {
    public UInt32 value__;
    public static OpenGLDefaultSwapIntervalSign Positive;
    public static OpenGLDefaultSwapIntervalSign Negative;
    public static OpenGLDefaultSwapIntervalSign Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLEventLogSeverityThreshold : Enum {
    public UInt32 value__;
    public static OpenGLEventLogSeverityThreshold Disable;
    public static OpenGLEventLogSeverityThreshold Critical;
    public static OpenGLEventLogSeverityThreshold Warning;
    public static OpenGLEventLogSeverityThreshold Information;
    public static OpenGLEventLogSeverityThreshold All;
    public static OpenGLEventLogSeverityThreshold Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLForceBlit : Enum {
    public UInt32 value__;
    public static OpenGLForceBlit On;
    public static OpenGLForceBlit Off;
    public static OpenGLForceBlit Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLForceStereo : Enum {
    public UInt32 value__;
    public static OpenGLForceStereo Off;
    public static OpenGLForceStereo On;
    public static OpenGLForceStereo Default;
}
public static class NvAPIWrapper.DRS.SettingValues.OpenGLImplicitGPUAffinity : object {
    public static string AutoSelect;
    public static string Default;
    public static string EnvironmentVariable;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLOverlayPixelType : Enum {
    public UInt32 value__;
    public static OpenGLOverlayPixelType None;
    public static OpenGLOverlayPixelType CI;
    public static OpenGLOverlayPixelType RGBA;
    public static OpenGLOverlayPixelType CIAndRGBA;
    public static OpenGLOverlayPixelType Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLOverlaySupport : Enum {
    public UInt32 value__;
    public static OpenGLOverlaySupport Off;
    public static OpenGLOverlaySupport On;
    public static OpenGLOverlaySupport ForceSoftware;
    public static OpenGLOverlaySupport Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLQualityEnhancements : Enum {
    public UInt32 value__;
    public static OpenGLQualityEnhancements HighQuality;
    public static OpenGLQualityEnhancements Quality;
    public static OpenGLQualityEnhancements Performance;
    public static OpenGLQualityEnhancements HighPerformance;
    public static OpenGLQualityEnhancements Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLSingleBackDepthBuffer : Enum {
    public UInt32 value__;
    public static OpenGLSingleBackDepthBuffer Disable;
    public static OpenGLSingleBackDepthBuffer Enable;
    public static OpenGLSingleBackDepthBuffer UseHardwareDefault;
    public static OpenGLSingleBackDepthBuffer Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLSLIMulticast : Enum {
    public UInt32 value__;
    public static OpenGLSLIMulticast Disable;
    public static OpenGLSLIMulticast Enable;
    public static OpenGLSLIMulticast ForceDisable;
    public static OpenGLSLIMulticast AllowMosaic;
    public static OpenGLSLIMulticast Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLThreadControl : Enum {
    public UInt32 value__;
    public static OpenGLThreadControl Enable;
    public static OpenGLThreadControl Disable;
    public static OpenGLThreadControl Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLTMONLevel : Enum {
    public UInt32 value__;
    public static OpenGLTMONLevel Disable;
    public static OpenGLTMONLevel Critical;
    public static OpenGLTMONLevel Warning;
    public static OpenGLTMONLevel Information;
    public static OpenGLTMONLevel Most;
    public static OpenGLTMONLevel Verbose;
    public static OpenGLTMONLevel Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OpenGLTripleBuffer : Enum {
    public UInt32 value__;
    public static OpenGLTripleBuffer Disabled;
    public static OpenGLTripleBuffer Enabled;
    public static OpenGLTripleBuffer Default;
}
public enum NvAPIWrapper.DRS.SettingValues.OptimusMaximumAntiAliasing : Enum {
    public UInt32 value__;
    public static OptimusMaximumAntiAliasing Minimum;
    public static OptimusMaximumAntiAliasing Maximum;
    public static OptimusMaximumAntiAliasing Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateFrameRateLimiter : Enum {
    public UInt32 value__;
    public static PerformanceStateFrameRateLimiter Disabled;
    public static PerformanceStateFrameRateLimiter FPS20;
    public static PerformanceStateFrameRateLimiter FPS30;
    public static PerformanceStateFrameRateLimiter FPS40;
    public static PerformanceStateFrameRateLimiter Fpsmask;
    public static PerformanceStateFrameRateLimiter NoAlign;
    public static PerformanceStateFrameRateLimiter BBQM;
    public static PerformanceStateFrameRateLimiter LowerFPSToAlign;
    public static PerformanceStateFrameRateLimiter ForceVSyncOff;
    public static PerformanceStateFrameRateLimiter GpsWeb;
    public static PerformanceStateFrameRateLimiter Disallowed;
    public static PerformanceStateFrameRateLimiter UseCPUWait;
    public static PerformanceStateFrameRateLimiter NoLagOffset;
    public static PerformanceStateFrameRateLimiter Accurate;
    public static PerformanceStateFrameRateLimiter AllowWindowed;
    public static PerformanceStateFrameRateLimiter ForceOn;
    public static PerformanceStateFrameRateLimiter Enabled;
    public static PerformanceStateFrameRateLimiter OpenGLRemoteDesktop;
    public static PerformanceStateFrameRateLimiter Mask;
    public static PerformanceStateFrameRateLimiter Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateFrameRateLimiter2Control : Enum {
    public UInt32 value__;
    public static PerformanceStateFrameRateLimiter2Control DelayCE;
    public static PerformanceStateFrameRateLimiter2Control Delay3D;
    public static PerformanceStateFrameRateLimiter2Control AvoidNoop;
    public static PerformanceStateFrameRateLimiter2Control DelayCEPresent3D;
    public static PerformanceStateFrameRateLimiter2Control AllowAllMaxwell;
    public static PerformanceStateFrameRateLimiter2Control AllowAll;
    public static PerformanceStateFrameRateLimiter2Control ForceOff;
    public static PerformanceStateFrameRateLimiter2Control EnableVCE;
    public static PerformanceStateFrameRateLimiter2Control DefaultForGM10X;
    public static PerformanceStateFrameRateLimiter2Control Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateFrameRateLimiterGpsControl : Enum {
    public UInt32 value__;
    public static PerformanceStateFrameRateLimiterGpsControl Disabled;
    public static PerformanceStateFrameRateLimiterGpsControl DecreaseFilterMask;
    public static PerformanceStateFrameRateLimiterGpsControl PauseTimeMask;
    public static PerformanceStateFrameRateLimiterGpsControl PauseTimeShift;
    public static PerformanceStateFrameRateLimiterGpsControl TargetRenderTimeMask;
    public static PerformanceStateFrameRateLimiterGpsControl TargetRenderTimeShift;
    public static PerformanceStateFrameRateLimiterGpsControl PerformanceStepSizeMask;
    public static PerformanceStateFrameRateLimiterGpsControl PerformanceStepSizeShift;
    public static PerformanceStateFrameRateLimiterGpsControl IncreaseFilterMask;
    public static PerformanceStateFrameRateLimiterGpsControl IncreaseFilterShift;
    public static PerformanceStateFrameRateLimiterGpsControl OptimalSetting;
    public static PerformanceStateFrameRateLimiterGpsControl Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateFrameRateMonitorControl : Enum {
    public UInt32 value__;
    public static PerformanceStateFrameRateMonitorControl Disabled;
    public static PerformanceStateFrameRateMonitorControl ThresholdPctMask;
    public static PerformanceStateFrameRateMonitorControl MovingAverageXMask;
    public static PerformanceStateFrameRateMonitorControl MovingAverageXShift;
    public static PerformanceStateFrameRateMonitorControl EnableFineGrained;
    public static PerformanceStateFrameRateMonitorControl EnableOnVSync;
    public static PerformanceStateFrameRateMonitorControl VSyncOffsetMask;
    public static PerformanceStateFrameRateMonitorControl VSyncOffsetShift;
    public static PerformanceStateFrameRateMonitorControl FPSUseFrl;
    public static PerformanceStateFrameRateMonitorControl FPS30;
    public static PerformanceStateFrameRateMonitorControl FPS60;
    public static PerformanceStateFrameRateMonitorControl FPSMask;
    public static PerformanceStateFrameRateMonitorControl FPSShift;
    public static PerformanceStateFrameRateMonitorControl OptimalSetting;
    public static PerformanceStateFrameRateMonitorControl VSyncOptimalSetting;
    public static PerformanceStateFrameRateMonitorControl Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateShaderDiskCache : Enum {
    public UInt32 value__;
    public static PerformanceStateShaderDiskCache Off;
    public static PerformanceStateShaderDiskCache On;
    public static PerformanceStateShaderDiskCache Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateTextureFilteringAnisotropicOptimization : Enum {
    public UInt32 value__;
    public static PerformanceStateTextureFilteringAnisotropicOptimization Off;
    public static PerformanceStateTextureFilteringAnisotropicOptimization On;
    public static PerformanceStateTextureFilteringAnisotropicOptimization Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateTextureFilteringBiLinearInAnisotropic : Enum {
    public UInt32 value__;
    public static PerformanceStateTextureFilteringBiLinearInAnisotropic Off;
    public static PerformanceStateTextureFilteringBiLinearInAnisotropic On;
    public static PerformanceStateTextureFilteringBiLinearInAnisotropic Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateTextureFilteringDisableTrilinearSlope : Enum {
    public UInt32 value__;
    public static PerformanceStateTextureFilteringDisableTrilinearSlope Off;
    public static PerformanceStateTextureFilteringDisableTrilinearSlope On;
    public static PerformanceStateTextureFilteringDisableTrilinearSlope Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PerformanceStateTextureFilteringNoNegativeLODBias : Enum {
    public UInt32 value__;
    public static PerformanceStateTextureFilteringNoNegativeLODBias Off;
    public static PerformanceStateTextureFilteringNoNegativeLODBias On;
    public static PerformanceStateTextureFilteringNoNegativeLODBias Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PhysxIndicator : Enum {
    public UInt32 value__;
    public static PhysxIndicator Disabled;
    public static PhysxIndicator Enabled;
    public static PhysxIndicator Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PreferredPerformanceState : Enum {
    public UInt32 value__;
    public static PreferredPerformanceState Adaptive;
    public static PreferredPerformanceState PreferMaximum;
    public static PreferredPerformanceState DriverControlled;
    public static PreferredPerformanceState PreferConsistentPerformance;
    public static PreferredPerformanceState PreferMinimum;
    public static PreferredPerformanceState OptimalPower;
    public static PreferredPerformanceState Minimum;
    public static PreferredPerformanceState Maximum;
    public static PreferredPerformanceState Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PreRenderLimit : Enum {
    public UInt32 value__;
    public static PreRenderLimit Minimum;
    public static PreRenderLimit Maximum;
    public static PreRenderLimit ApplicationControlled;
    public static PreRenderLimit Default;
}
public enum NvAPIWrapper.DRS.SettingValues.PreventUiAnisotropicOverride : Enum {
    public UInt32 value__;
    public static PreventUiAnisotropicOverride Off;
    public static PreventUiAnisotropicOverride On;
    public static PreventUiAnisotropicOverride Default;
}
public enum NvAPIWrapper.DRS.SettingValues.QualityEnhancements : Enum {
    public UInt32 value__;
    public static QualityEnhancements HighQuality;
    public static QualityEnhancements Quality;
    public static QualityEnhancements Performance;
    public static QualityEnhancements HighPerformance;
    public static QualityEnhancements Default;
}
public enum NvAPIWrapper.DRS.SettingValues.RefreshRateOverride : Enum {
    public UInt32 value__;
    public static RefreshRateOverride ApplicationControlled;
    public static RefreshRateOverride HighestAvailable;
    public static RefreshRateOverride LowLatencyRefreshRateMask;
    public static RefreshRateOverride Default;
}
public enum NvAPIWrapper.DRS.SettingValues.SetPowerThrottleForPCIeCompliance : Enum {
    public UInt32 value__;
    public static SetPowerThrottleForPCIeCompliance Off;
    public static SetPowerThrottleForPCIeCompliance On;
    public static SetPowerThrottleForPCIeCompliance Default;
}
public enum NvAPIWrapper.DRS.SettingValues.SetVABData : Enum {
    public UInt32 value__;
    public static SetVABData Zero;
    public static SetVABData UIntOne;
    public static SetVABData FloatOne;
    public static SetVABData FloatPosInf;
    public static SetVABData FloatNan;
    public static SetVABData UseAPIDefaults;
    public static SetVABData Default;
}
public enum NvAPIWrapper.DRS.SettingValues.ShimMCCOMPAT : Enum {
    public UInt32 value__;
    public static ShimMCCOMPAT Integrated;
    public static ShimMCCOMPAT Enable;
    public static ShimMCCOMPAT UserEditable;
    public static ShimMCCOMPAT Mask;
    public static ShimMCCOMPAT VideoMask;
    public static ShimMCCOMPAT VaryingBit;
    public static ShimMCCOMPAT AutoSelect;
    public static ShimMCCOMPAT OverrideBit;
    public static ShimMCCOMPAT Default;
}
public enum NvAPIWrapper.DRS.SettingValues.ShimRenderingMode : Enum {
    public UInt32 value__;
    public static ShimRenderingMode Integrated;
    public static ShimRenderingMode Enable;
    public static ShimRenderingMode UserEditable;
    public static ShimRenderingMode Mask;
    public static ShimRenderingMode VideoMask;
    public static ShimRenderingMode VaryingBit;
    public static ShimRenderingMode AutoSelect;
    public static ShimRenderingMode OverrideBit;
    public static ShimRenderingMode Default;
}
public enum NvAPIWrapper.DRS.SettingValues.ShimRenderingOptions : Enum {
    public UInt32 value__;
    public static ShimRenderingOptions DefaultRenderingMode;
    public static ShimRenderingOptions DisableAsyncPresent;
    public static ShimRenderingOptions EHShellDetect;
    public static ShimRenderingOptions FlashplayerHostDetect;
    public static ShimRenderingOptions VideoDRMApplicationDetect;
    public static ShimRenderingOptions IgnoreOverrides;
    public static ShimRenderingOptions Reserved1;
    public static ShimRenderingOptions EnableDWMAsyncPresent;
    public static ShimRenderingOptions Reserved2;
    public static ShimRenderingOptions AllowInheritance;
    public static ShimRenderingOptions DisableWrappers;
    public static ShimRenderingOptions DisableDxgiWrappers;
    public static ShimRenderingOptions PruneUnsupportedFormats;
    public static ShimRenderingOptions EnableAlphaFormat;
    public static ShimRenderingOptions IGPUTranscoding;
    public static ShimRenderingOptions DisableCUDA;
    public static ShimRenderingOptions AllowCpCapabilitiesForVideo;
    public static ShimRenderingOptions IGPUTranscodingFwdOptimus;
    public static ShimRenderingOptions DisableDuringSecureBoot;
    public static ShimRenderingOptions InvertForQuadro;
    public static ShimRenderingOptions InvertForMSHybrid;
    public static ShimRenderingOptions RegisterProcessEnableGold;
    public static ShimRenderingOptions HandleWindowedModePerformanceOptimal;
    public static ShimRenderingOptions HandleWin7AsyncRuntimeBug;
    public static ShimRenderingOptions ExplicitAdapterOptedByApplication;
    public static ShimRenderingOptions Default;
}
public enum NvAPIWrapper.DRS.SettingValues.SLIGPUCount : Enum {
    public UInt32 value__;
    public static SLIGPUCount AutoSelect;
    public static SLIGPUCount One;
    public static SLIGPUCount Two;
    public static SLIGPUCount Three;
    public static SLIGPUCount Four;
    public static SLIGPUCount Default;
}
public enum NvAPIWrapper.DRS.SettingValues.SLIPredefinedGPUCount : Enum {
    public UInt32 value__;
    public static SLIPredefinedGPUCount AutoSelect;
    public static SLIPredefinedGPUCount One;
    public static SLIPredefinedGPUCount Two;
    public static SLIPredefinedGPUCount Three;
    public static SLIPredefinedGPUCount Four;
    public static SLIPredefinedGPUCount Default;
}
public enum NvAPIWrapper.DRS.SettingValues.SLIPredefinedGPUCountDX10 : Enum {
    public UInt32 value__;
    public static SLIPredefinedGPUCountDX10 AutoSelect;
    public static SLIPredefinedGPUCountDX10 One;
    public static SLIPredefinedGPUCountDX10 Two;
    public static SLIPredefinedGPUCountDX10 Three;
    public static SLIPredefinedGPUCountDX10 Four;
    public static SLIPredefinedGPUCountDX10 Default;
}
public enum NvAPIWrapper.DRS.SettingValues.SLIPredefinedMode : Enum {
    public UInt32 value__;
    public static SLIPredefinedMode AutoSelect;
    public static SLIPredefinedMode ForceSingle;
    public static SLIPredefinedMode ForceAFR;
    public static SLIPredefinedMode ForceAFR2;
    public static SLIPredefinedMode ForceSFR;
    public static SLIPredefinedMode ForceAFROfSFRFallback3AFR;
    public static SLIPredefinedMode Default;
}
public enum NvAPIWrapper.DRS.SettingValues.SLIPredefinedModeDX10 : Enum {
    public UInt32 value__;
    public static SLIPredefinedModeDX10 AutoSelect;
    public static SLIPredefinedModeDX10 ForceSingle;
    public static SLIPredefinedModeDX10 ForceAFR;
    public static SLIPredefinedModeDX10 ForceAFR2;
    public static SLIPredefinedModeDX10 ForceSFR;
    public static SLIPredefinedModeDX10 ForceAFROfSFRFallback3AFR;
    public static SLIPredefinedModeDX10 Default;
}
public enum NvAPIWrapper.DRS.SettingValues.SLIRenderingMode : Enum {
    public UInt32 value__;
    public static SLIRenderingMode AutoSelect;
    public static SLIRenderingMode ForceSingle;
    public static SLIRenderingMode ForceAFR;
    public static SLIRenderingMode ForceAFR2;
    public static SLIRenderingMode ForceSFR;
    public static SLIRenderingMode ForceAFROfSFRFallback3AFR;
    public static SLIRenderingMode Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VRPreRenderLimit : Enum {
    public UInt32 value__;
    public static VRPreRenderLimit Minimum;
    public static VRPreRenderLimit Maximum;
    public static VRPreRenderLimit ApplicationControlled;
    public static VRPreRenderLimit Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VRRApplicationOverride : Enum {
    public UInt32 value__;
    public static VRRApplicationOverride Allow;
    public static VRRApplicationOverride ForceOff;
    public static VRRApplicationOverride DisAllow;
    public static VRRApplicationOverride ULMB;
    public static VRRApplicationOverride FixedRefresh;
    public static VRRApplicationOverride Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VRRApplicationOverrideRequestState : Enum {
    public UInt32 value__;
    public static VRRApplicationOverrideRequestState Allow;
    public static VRRApplicationOverrideRequestState ForceOff;
    public static VRRApplicationOverrideRequestState DisAllow;
    public static VRRApplicationOverrideRequestState ULMB;
    public static VRRApplicationOverrideRequestState FixedRefresh;
    public static VRRApplicationOverrideRequestState Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VRRFeatureIndicator : Enum {
    public UInt32 value__;
    public static VRRFeatureIndicator Disabled;
    public static VRRFeatureIndicator Enabled;
    public static VRRFeatureIndicator Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VRRMode : Enum {
    public UInt32 value__;
    public static VRRMode Disabled;
    public static VRRMode FullScreenOnly;
    public static VRRMode FullScreenAndWindowed;
    public static VRRMode Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VRROverlayIndicator : Enum {
    public UInt32 value__;
    public static VRROverlayIndicator Disabled;
    public static VRROverlayIndicator Enabled;
    public static VRROverlayIndicator Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VRRRequestState : Enum {
    public UInt32 value__;
    public static VRRRequestState Disabled;
    public static VRRRequestState FullScreenOnly;
    public static VRRRequestState FullScreenAndWindowed;
    public static VRRRequestState Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VSyncBehaviorFlags : Enum {
    public UInt32 value__;
    public static VSyncBehaviorFlags None;
    public static VSyncBehaviorFlags Default;
    public static VSyncBehaviorFlags IgnoreFlipIntervalMultiple;
}
public enum NvAPIWrapper.DRS.SettingValues.VSyncMode : Enum {
    public UInt32 value__;
    public static VSyncMode Passive;
    public static VSyncMode ForceOff;
    public static VSyncMode ForceOn;
    public static VSyncMode FlipInterval2;
    public static VSyncMode FlipInterval3;
    public static VSyncMode FlipInterval4;
    public static VSyncMode Virtual;
    public static VSyncMode Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VSyncSmoothAFR : Enum {
    public UInt32 value__;
    public static VSyncSmoothAFR Off;
    public static VSyncSmoothAFR On;
    public static VSyncSmoothAFR Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VSyncTearControl : Enum {
    public UInt32 value__;
    public static VSyncTearControl Disable;
    public static VSyncTearControl Enable;
    public static VSyncTearControl Default;
}
public enum NvAPIWrapper.DRS.SettingValues.VSyncVRRControl : Enum {
    public UInt32 value__;
    public static VSyncVRRControl Disable;
    public static VSyncVRRControl Enable;
    public static VSyncVRRControl NotSupported;
    public static VSyncVRRControl Default;
}
public enum NvAPIWrapper.DRS.SettingValues.WKSAPIStereoEyesExchange : Enum {
    public UInt32 value__;
    public static WKSAPIStereoEyesExchange Off;
    public static WKSAPIStereoEyesExchange On;
    public static WKSAPIStereoEyesExchange Default;
}
public enum NvAPIWrapper.DRS.SettingValues.WKSAPIStereoMode : Enum {
    public UInt32 value__;
    public static WKSAPIStereoMode ShutterGlasses;
    public static WKSAPIStereoMode VerticalInterlaced;
    public static WKSAPIStereoMode Twinview;
    public static WKSAPIStereoMode NV17ShutterGlassesAuto;
    public static WKSAPIStereoMode NV17ShutterGlassesDAC0;
    public static WKSAPIStereoMode NV17ShutterGlassesDAC1;
    public static WKSAPIStereoMode ColorLine;
    public static WKSAPIStereoMode ColorInterleaved;
    public static WKSAPIStereoMode Anaglyph;
    public static WKSAPIStereoMode HorizontalInterlaced;
    public static WKSAPIStereoMode SideField;
    public static WKSAPIStereoMode SubField;
    public static WKSAPIStereoMode CheckerBoard;
    public static WKSAPIStereoMode InverseCheckerBoard;
    public static WKSAPIStereoMode TridelitySL;
    public static WKSAPIStereoMode TridelityMV;
    public static WKSAPIStereoMode SeeFront;
    public static WKSAPIStereoMode StereoMirror;
    public static WKSAPIStereoMode FrameSequential;
    public static WKSAPIStereoMode AutodetectPassiveMode;
    public static WKSAPIStereoMode AegisDTFrameSequential;
    public static WKSAPIStereoMode OEMEmitterFrameSequential;
    public static WKSAPIStereoMode DPInBand;
    public static WKSAPIStereoMode UseHardwareDefault;
    public static WKSAPIStereoMode DefaultGL;
    public static WKSAPIStereoMode Default;
}
public enum NvAPIWrapper.DRS.SettingValues.WKSMemoryAllocationPolicy : Enum {
    public UInt32 value__;
    public static WKSMemoryAllocationPolicy AsNeeded;
    public static WKSMemoryAllocationPolicy ModeratePreAllocation;
    public static WKSMemoryAllocationPolicy AggressivePreAllocation;
    public static WKSMemoryAllocationPolicy Default;
}
public enum NvAPIWrapper.DRS.SettingValues.WKSStereoDongleSupport : Enum {
    public UInt32 value__;
    public static WKSStereoDongleSupport Off;
    public static WKSStereoDongleSupport DAC;
    public static WKSStereoDongleSupport DLP;
    public static WKSStereoDongleSupport Default;
}
public enum NvAPIWrapper.DRS.SettingValues.WKSStereoSupport : Enum {
    public UInt32 value__;
    public static WKSStereoSupport Off;
    public static WKSStereoSupport On;
    public static WKSStereoSupport Default;
}
public enum NvAPIWrapper.DRS.SettingValues.WKSStereoSwapMode : Enum {
    public UInt32 value__;
    public static WKSStereoSwapMode ApplicationControl;
    public static WKSStereoSwapMode PerEye;
    public static WKSStereoSwapMode PerEyePair;
    public static WKSStereoSwapMode LegacyBehavior;
    public static WKSStereoSwapMode Default;
}
public class NvAPIWrapper.GPU.AGPInformation : object {
    [CompilerGeneratedAttribute]
private int <ApertureInMB>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentRate>k__BackingField;
    public int ApertureInMB { get; }
    public int CurrentRate { get; }
    internal AGPInformation(int aperture, int currentRate);
    [CompilerGeneratedAttribute]
public int get_ApertureInMB();
    [CompilerGeneratedAttribute]
public int get_CurrentRate();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.ECCMemoryInformation : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public ulong AggregatedDoubleBitErrors { get; }
    public ulong AggregatedSingleBitErrors { get; }
    public ECCConfiguration Configuration { get; }
    public ulong CurrentDoubleBitErrors { get; }
    public ulong CurrentSingleBitErrors { get; }
    public bool IsEnabled { get; }
    public bool IsEnabledByDefault { get; }
    public bool IsSupported { get; }
    public PhysicalGPU PhysicalGPU { get; }
    internal ECCMemoryInformation(PhysicalGPU physicalGPU);
    public ulong get_AggregatedDoubleBitErrors();
    public ulong get_AggregatedSingleBitErrors();
    public ECCConfiguration get_Configuration();
    public ulong get_CurrentDoubleBitErrors();
    public ulong get_CurrentSingleBitErrors();
    public bool get_IsEnabled();
    public bool get_IsEnabledByDefault();
    public bool get_IsSupported();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public virtual string ToString();
    public void ClearAggregatedErrors();
    public void ClearCurrentErrors();
    public void ClearErrors();
    public void Disable(bool immediate);
    public void Enable(bool immediate);
}
public class NvAPIWrapper.GPU.GPUArchitectInformation : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public int NumberOfCores { get; }
    public int NumberOfGPC { get; }
    public int NumberOfROPs { get; }
    public int NumberOfShaderPipelines { get; }
    public int NumberOfShaderSubPipelines { get; }
    public int NumberOfVPEs { get; }
    public PhysicalGPU PhysicalGPU { get; }
    public int Revision { get; }
    public string ShortName { get; }
    public int TotalNumberOfSMs { get; }
    public int TotalNumberOfSPs { get; }
    public int TotalNumberOfTPCs { get; }
    internal GPUArchitectInformation(PhysicalGPU physicalGPU);
    public int get_NumberOfCores();
    public int get_NumberOfGPC();
    public int get_NumberOfROPs();
    public int get_NumberOfShaderPipelines();
    public int get_NumberOfShaderSubPipelines();
    public int get_NumberOfVPEs();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public int get_Revision();
    public string get_ShortName();
    public int get_TotalNumberOfSMs();
    public int get_TotalNumberOfSPs();
    public int get_TotalNumberOfTPCs();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUBusInformation : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public AGPInformation AGPInformation { get; }
    public int BusId { get; }
    public int BusSlot { get; }
    public GPUBusType BusType { get; }
    public int CurrentPCIeLanes { get; }
    public int IRQ { get; }
    public PCIIdentifiers PCIIdentifiers { get; }
    public PhysicalGPU PhysicalGPU { get; }
    internal GPUBusInformation(PhysicalGPU physicalGPU);
    public AGPInformation get_AGPInformation();
    public int get_BusId();
    public int get_BusSlot();
    public GPUBusType get_BusType();
    public int get_CurrentPCIeLanes();
    public int get_IRQ();
    public PCIIdentifiers get_PCIIdentifiers();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUCooler : object {
    [CompilerGeneratedAttribute]
private CoolerControlMode <ControlMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CoolerController <CoolerController>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CoolerId>k__BackingField;
    [CompilerGeneratedAttribute]
private CoolerType <CoolerType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentFanSpeedInRPM>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentMaximumLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentMinimumLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CoolerPolicy <CurrentPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultMaximumLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultMinimumLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CoolerPolicy <DefaultPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private CoolerTarget <Target>k__BackingField;
    public CoolerControlMode ControlMode { get; }
    public CoolerController CoolerController { get; }
    public int CoolerId { get; }
    public CoolerType CoolerType { get; }
    public int CurrentFanSpeedInRPM { get; }
    public int CurrentLevel { get; }
    public int CurrentMaximumLevel { get; }
    public int CurrentMinimumLevel { get; }
    public CoolerPolicy CurrentPolicy { get; }
    public int DefaultMaximumLevel { get; }
    public int DefaultMinimumLevel { get; }
    public CoolerPolicy DefaultPolicy { get; }
    public CoolerTarget Target { get; }
    internal GPUCooler(int coolerId, CoolerSetting coolerSetting, int currentRPM);
    internal GPUCooler(FanCoolersInfoEntry infoEntry, FanCoolersStatusEntry statusEntry, FanCoolersControlEntry controlEntry);
    [CompilerGeneratedAttribute]
public CoolerControlMode get_ControlMode();
    [CompilerGeneratedAttribute]
public CoolerController get_CoolerController();
    [CompilerGeneratedAttribute]
public int get_CoolerId();
    [CompilerGeneratedAttribute]
public CoolerType get_CoolerType();
    [CompilerGeneratedAttribute]
public int get_CurrentFanSpeedInRPM();
    [CompilerGeneratedAttribute]
public int get_CurrentLevel();
    [CompilerGeneratedAttribute]
public int get_CurrentMaximumLevel();
    [CompilerGeneratedAttribute]
public int get_CurrentMinimumLevel();
    [CompilerGeneratedAttribute]
public CoolerPolicy get_CurrentPolicy();
    [CompilerGeneratedAttribute]
public int get_DefaultMaximumLevel();
    [CompilerGeneratedAttribute]
public int get_DefaultMinimumLevel();
    [CompilerGeneratedAttribute]
public CoolerPolicy get_DefaultPolicy();
    [CompilerGeneratedAttribute]
public CoolerTarget get_Target();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUCoolerInformation : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public IEnumerable`1<GPUCooler> Coolers { get; }
    public int CurrentFanSpeedInRPM { get; }
    public int CurrentFanSpeedLevel { get; }
    public PhysicalGPU PhysicalGPU { get; }
    internal GPUCoolerInformation(PhysicalGPU physicalGPU);
    [IteratorStateMachineAttribute("NvAPIWrapper.GPU.GPUCoolerInformation/<get_Coolers>d__2")]
public IEnumerable`1<GPUCooler> get_Coolers();
    public int get_CurrentFanSpeedInRPM();
    public int get_CurrentFanSpeedLevel();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public virtual string ToString();
    public void RestoreCoolerSettingsToDefault();
    public void RestoreCoolerSettingsToDefault(Int32[] coolerIds);
    public void SetCoolerSettings(int coolerId, CoolerPolicy policy, int newLevel);
    public void SetCoolerSettings(int coolerId, CoolerPolicy policy);
    public void SetCoolerSettings(int coolerId, int newLevel);
}
public class NvAPIWrapper.GPU.GPUMemoryInformation : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public int FrameBufferBandwidth { get; }
    public int FrameBufferLocation { get; }
    public int InternalClockToBusClockFactor { get; }
    public int InternalClockToTransferRateFactor { get; }
    public int PhysicalFrameBufferSizeInkB { get; }
    public PhysicalGPU PhysicalGPU { get; }
    public UInt32 RAMBanks { get; }
    public UInt32 RAMBusWidth { get; }
    public GPUMemoryMaker RAMMaker { get; }
    public GPUMemoryType RAMType { get; }
    public int VirtualFrameBufferSizeInkB { get; }
    public UInt32 AvailableDedicatedVideoMemoryInkB { get; }
    public UInt32 CurrentAvailableDedicatedVideoMemoryInkB { get; }
    public UInt32 DedicatedVideoMemoryInkB { get; }
    public UInt32 SharedSystemMemoryInkB { get; }
    public UInt32 SystemVideoMemoryInkB { get; }
    internal GPUMemoryInformation(PhysicalGPU physicalGPU);
    public int get_FrameBufferBandwidth();
    public int get_FrameBufferLocation();
    public int get_InternalClockToBusClockFactor();
    public int get_InternalClockToTransferRateFactor();
    public int get_PhysicalFrameBufferSizeInkB();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public UInt32 get_RAMBanks();
    public UInt32 get_RAMBusWidth();
    public GPUMemoryMaker get_RAMMaker();
    public GPUMemoryType get_RAMType();
    public int get_VirtualFrameBufferSizeInkB();
    public sealed virtual UInt32 get_AvailableDedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_CurrentAvailableDedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_DedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_SharedSystemMemoryInkB();
    public sealed virtual UInt32 get_SystemVideoMemoryInkB();
    public static int GetMemoryBusClockFactor(GPUMemoryType memoryType);
    public static int GetMemoryTransferRateFactor(GPUMemoryType memoryType);
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUOutput : object {
    [CompilerGeneratedAttribute]
private OutputId <OutputId>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputType <OutputType>k__BackingField;
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public DVCInformation DigitalVibranceControl { get; }
    public HUEInformation HUEControl { get; }
    public OutputId OutputId { get; }
    public OutputType OutputType { get; }
    public PhysicalGPU PhysicalGPU { get; }
    internal GPUOutput(OutputId outputId, PhysicalGPUHandle gpuHandle);
    internal GPUOutput(OutputId outputId, PhysicalGPU gpu);
    public DVCInformation get_DigitalVibranceControl();
    public HUEInformation get_HUEControl();
    [CompilerGeneratedAttribute]
public OutputId get_OutputId();
    [CompilerGeneratedAttribute]
public OutputType get_OutputType();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public sealed virtual bool Equals(GPUOutput other);
    public static bool op_Equality(GPUOutput left, GPUOutput right);
    public static bool op_Inequality(GPUOutput left, GPUOutput right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public void OverrideRefreshRate(float refreshRate, bool isDeferred);
    public Byte[] ReadI2C(Nullable`1<byte> portId, bool useDDCPort, byte deviceAddress, Byte[] registerAddress, UInt32 readDataLength, I2CSpeed speed);
    public void WriteI2C(Nullable`1<byte> portId, bool useDDCPort, byte deviceAddress, Byte[] registerAddress, Byte[] data, I2CSpeed speed);
}
public class NvAPIWrapper.GPU.GPUPerformanceControl : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public PerformanceLimit CurrentActiveLimit { get; }
    public PerformanceDecreaseReason CurrentPerformanceDecreaseReason { get; }
    public bool IsNoLoadLimitSupported { get; }
    public bool IsPowerLimitSupported { get; }
    public bool IsTemperatureLimitSupported { get; }
    public bool IsVoltageLimitSupported { get; }
    public PhysicalGPU PhysicalGPU { get; }
    public IEnumerable`1<GPUPowerLimitInfo> PowerLimitInformation { get; }
    public IEnumerable`1<GPUPowerLimitPolicy> PowerLimitPolicies { get; }
    public IEnumerable`1<GPUThermalLimitInfo> ThermalLimitInformation { get; }
    public IEnumerable`1<GPUThermalLimitPolicy> ThermalLimitPolicies { get; }
    internal GPUPerformanceControl(PhysicalGPU physicalGPU);
    public PerformanceLimit get_CurrentActiveLimit();
    public PerformanceDecreaseReason get_CurrentPerformanceDecreaseReason();
    public bool get_IsNoLoadLimitSupported();
    public bool get_IsPowerLimitSupported();
    public bool get_IsTemperatureLimitSupported();
    public bool get_IsVoltageLimitSupported();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public IEnumerable`1<GPUPowerLimitInfo> get_PowerLimitInformation();
    public IEnumerable`1<GPUPowerLimitPolicy> get_PowerLimitPolicies();
    public IEnumerable`1<GPUThermalLimitInfo> get_ThermalLimitInformation();
    public IEnumerable`1<GPUThermalLimitPolicy> get_ThermalLimitPolicies();
}
public class NvAPIWrapper.GPU.GPUPerformanceState : object {
    [CompilerGeneratedAttribute]
private GPUPerformanceStateClock[] <Clocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private PCIeInformation <PCIeInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceStateId <StateId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StateIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPerformanceStateVoltage[] <Voltages>k__BackingField;
    public GPUPerformanceStateClock[] Clocks { get; }
    public bool IsReadOnly { get; }
    public PCIeInformation PCIeInformation { get; }
    public PerformanceStateId StateId { get; }
    public int StateIndex { get; }
    public GPUPerformanceStateVoltage[] Voltages { get; }
    internal GPUPerformanceState(int index, IPerformanceState20 performanceState, IPerformanceStates20ClockEntry[] statesClockEntries, IPerformanceStates20VoltageEntry[] baseVoltageEntries, PCIeInformation pcieInformation);
    [CompilerGeneratedAttribute]
public GPUPerformanceStateClock[] get_Clocks();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public PCIeInformation get_PCIeInformation();
    [CompilerGeneratedAttribute]
public PerformanceStateId get_StateId();
    [CompilerGeneratedAttribute]
public int get_StateIndex();
    [CompilerGeneratedAttribute]
public GPUPerformanceStateVoltage[] get_Voltages();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUPerformanceStateClock : object {
    [CompilerGeneratedAttribute]
private GPUPerformanceStateValueRange <BaseClockInkHz>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClockDeltaInkHz>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPerformanceStateValueRange <ClockDeltaRangeInkHz>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicClockDomain <ClockDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPerformanceStateValueRange <CurrentClockInkHz>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceVoltageDomain <DependentVoltageDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPerformanceStateValueRange <DependentVoltageRangeInMicroVolt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public GPUPerformanceStateValueRange BaseClockInkHz { get; }
    public int ClockDeltaInkHz { get; }
    public GPUPerformanceStateValueRange ClockDeltaRangeInkHz { get; }
    public PublicClockDomain ClockDomain { get; }
    public GPUPerformanceStateValueRange CurrentClockInkHz { get; }
    public PerformanceVoltageDomain DependentVoltageDomain { get; }
    public GPUPerformanceStateValueRange DependentVoltageRangeInMicroVolt { get; }
    public bool IsReadOnly { get; }
    internal GPUPerformanceStateClock(IPerformanceStates20ClockEntry states20ClockEntry);
    [CompilerGeneratedAttribute]
public GPUPerformanceStateValueRange get_BaseClockInkHz();
    [CompilerGeneratedAttribute]
public int get_ClockDeltaInkHz();
    [CompilerGeneratedAttribute]
public GPUPerformanceStateValueRange get_ClockDeltaRangeInkHz();
    [CompilerGeneratedAttribute]
public PublicClockDomain get_ClockDomain();
    [CompilerGeneratedAttribute]
public GPUPerformanceStateValueRange get_CurrentClockInkHz();
    [CompilerGeneratedAttribute]
public PerformanceVoltageDomain get_DependentVoltageDomain();
    [CompilerGeneratedAttribute]
public GPUPerformanceStateValueRange get_DependentVoltageRangeInMicroVolt();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUPerformanceStatesInformation : object {
    [CompilerGeneratedAttribute]
private GPUPerformanceState <CurrentPerformanceState>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPerformanceStateVoltage[] <GlobalVoltages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPerformanceState[] <PerformanceStates>k__BackingField;
    public GPUPerformanceState CurrentPerformanceState { get; }
    public GPUPerformanceStateVoltage[] GlobalVoltages { get; }
    public bool IsReadOnly { get; }
    public GPUPerformanceState[] PerformanceStates { get; }
    internal GPUPerformanceStatesInformation(IPerformanceStates20Info states20Info, PerformanceStateId currentPerformanceStateId, Nullable`1<PrivatePCIeInfoV2> pciInformation);
    [CompilerGeneratedAttribute]
public GPUPerformanceState get_CurrentPerformanceState();
    [CompilerGeneratedAttribute]
public GPUPerformanceStateVoltage[] get_GlobalVoltages();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public GPUPerformanceState[] get_PerformanceStates();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private string <ToString>b__13_0(GPUPerformanceState state);
}
public class NvAPIWrapper.GPU.GPUPerformanceStateValueRange : object {
    [CompilerGeneratedAttribute]
private long <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Minimum>k__BackingField;
    public long Maximum { get; }
    public long Minimum { get; }
    public GPUPerformanceStateValueRange(long min, long max);
    public GPUPerformanceStateValueRange(long value);
    [CompilerGeneratedAttribute]
public long get_Maximum();
    [CompilerGeneratedAttribute]
public long get_Minimum();
    public sealed virtual bool Equals(GPUPerformanceStateValueRange other);
    public static bool op_Equality(GPUPerformanceStateValueRange left, GPUPerformanceStateValueRange right);
    public static bool op_Inequality(GPUPerformanceStateValueRange left, GPUPerformanceStateValueRange right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUPerformanceStateVoltage : object {
    [CompilerGeneratedAttribute]
private int <BaseVoltageInMicroVolt>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CurrentVoltageInMicroVolt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VoltageDeltaInMicroVolt>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPerformanceStateValueRange <VoltageDeltaRangeInMicroVolt>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceVoltageDomain <VoltageDomain>k__BackingField;
    public int BaseVoltageInMicroVolt { get; }
    public UInt32 CurrentVoltageInMicroVolt { get; }
    public bool IsReadOnly { get; }
    public int VoltageDeltaInMicroVolt { get; }
    public GPUPerformanceStateValueRange VoltageDeltaRangeInMicroVolt { get; }
    public PerformanceVoltageDomain VoltageDomain { get; }
    internal GPUPerformanceStateVoltage(IPerformanceStates20VoltageEntry states20BaseVoltageEntry);
    [CompilerGeneratedAttribute]
public int get_BaseVoltageInMicroVolt();
    [CompilerGeneratedAttribute]
public UInt32 get_CurrentVoltageInMicroVolt();
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public int get_VoltageDeltaInMicroVolt();
    [CompilerGeneratedAttribute]
public GPUPerformanceStateValueRange get_VoltageDeltaRangeInMicroVolt();
    [CompilerGeneratedAttribute]
public PerformanceVoltageDomain get_VoltageDomain();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUPowerLimitInfo : object {
    [CompilerGeneratedAttribute]
private UInt32 <DefaultPowerInPCM>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaximumPowerInPCM>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MinimumPowerInPCM>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceStateId <PerformanceStateId>k__BackingField;
    public UInt32 DefaultPowerInPCM { get; }
    public float DefaultPowerInPercent { get; }
    public UInt32 MaximumPowerInPCM { get; }
    public float MaximumPowerInPercent { get; }
    public UInt32 MinimumPowerInPCM { get; }
    public float MinimumPowerInPercent { get; }
    public PerformanceStateId PerformanceStateId { get; }
    internal GPUPowerLimitInfo(PowerPolicyInfoEntry powerPolicyInfoEntry);
    [CompilerGeneratedAttribute]
public UInt32 get_DefaultPowerInPCM();
    public float get_DefaultPowerInPercent();
    [CompilerGeneratedAttribute]
public UInt32 get_MaximumPowerInPCM();
    public float get_MaximumPowerInPercent();
    [CompilerGeneratedAttribute]
public UInt32 get_MinimumPowerInPCM();
    public float get_MinimumPowerInPercent();
    [CompilerGeneratedAttribute]
public PerformanceStateId get_PerformanceStateId();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUPowerLimitPolicy : object {
    [CompilerGeneratedAttribute]
private PerformanceStateId <PerformanceStateId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PowerTargetInPCM>k__BackingField;
    public PerformanceStateId PerformanceStateId { get; }
    public UInt32 PowerTargetInPCM { get; }
    public float PowerTargetInPercent { get; }
    internal GPUPowerLimitPolicy(PowerPolicyStatusEntry powerPolicyStatusEntry);
    [CompilerGeneratedAttribute]
public PerformanceStateId get_PerformanceStateId();
    [CompilerGeneratedAttribute]
public UInt32 get_PowerTargetInPCM();
    public float get_PowerTargetInPercent();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUPowerTopologyInformation : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public PhysicalGPU PhysicalGPU { get; }
    public IEnumerable`1<GPUPowerTopologyStatus> PowerTopologyEntries { get; }
    internal GPUPowerTopologyInformation(PhysicalGPU physicalGPU);
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public IEnumerable`1<GPUPowerTopologyStatus> get_PowerTopologyEntries();
}
public class NvAPIWrapper.GPU.GPUPowerTopologyStatus : object {
    [CompilerGeneratedAttribute]
private PowerTopologyDomain <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PowerUsageInPCM>k__BackingField;
    public PowerTopologyDomain Domain { get; }
    public UInt32 PowerUsageInPCM { get; }
    public float PowerUsageInPercent { get; }
    internal GPUPowerTopologyStatus(PowerTopologiesStatusEntry powerTopologiesStatusEntry);
    [CompilerGeneratedAttribute]
public PowerTopologyDomain get_Domain();
    [CompilerGeneratedAttribute]
public UInt32 get_PowerUsageInPCM();
    public float get_PowerUsageInPercent();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUThermalInformation : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public int CurrentThermalLevel { get; }
    public PhysicalGPU PhysicalGPU { get; }
    public IEnumerable`1<GPUThermalSensor> ThermalSensors { get; }
    internal GPUThermalInformation(PhysicalGPU physicalGPU);
    public int get_CurrentThermalLevel();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public IEnumerable`1<GPUThermalSensor> get_ThermalSensors();
}
public class NvAPIWrapper.GPU.GPUThermalLimitInfo : object {
    [CompilerGeneratedAttribute]
private ThermalController <Controller>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultTemperature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumTemperature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumTemperature>k__BackingField;
    public ThermalController Controller { get; }
    public int DefaultTemperature { get; }
    public int MaximumTemperature { get; }
    public int MinimumTemperature { get; }
    internal GPUThermalLimitInfo(ThermalPoliciesInfoEntry policiesInfoEntry);
    [CompilerGeneratedAttribute]
public ThermalController get_Controller();
    [CompilerGeneratedAttribute]
public int get_DefaultTemperature();
    [CompilerGeneratedAttribute]
public int get_MaximumTemperature();
    [CompilerGeneratedAttribute]
public int get_MinimumTemperature();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUThermalLimitPolicy : object {
    [CompilerGeneratedAttribute]
private ThermalController <Controller>k__BackingField;
    [CompilerGeneratedAttribute]
private PerformanceStateId <PerformanceStateId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TargetTemperature>k__BackingField;
    public ThermalController Controller { get; }
    public PerformanceStateId PerformanceStateId { get; }
    public int TargetTemperature { get; }
    internal GPUThermalLimitPolicy(ThermalPoliciesStatusEntry thermalPoliciesEntry);
    [CompilerGeneratedAttribute]
public ThermalController get_Controller();
    [CompilerGeneratedAttribute]
public PerformanceStateId get_PerformanceStateId();
    [CompilerGeneratedAttribute]
public int get_TargetTemperature();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUThermalSensor : object {
    [CompilerGeneratedAttribute]
private int <SensorId>k__BackingField;
    [CompilerGeneratedAttribute]
private ThermalController <Controller>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentTemperature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultMaximumTemperature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DefaultMinimumTemperature>k__BackingField;
    [CompilerGeneratedAttribute]
private ThermalSettingsTarget <Target>k__BackingField;
    public int SensorId { get; public set; }
    public ThermalController Controller { get; }
    public int CurrentTemperature { get; }
    public int DefaultMaximumTemperature { get; }
    public int DefaultMinimumTemperature { get; }
    public ThermalSettingsTarget Target { get; }
    internal GPUThermalSensor(int sensorId, IThermalSensor thermalSensor);
    [CompilerGeneratedAttribute]
public int get_SensorId();
    [CompilerGeneratedAttribute]
public void set_SensorId(int value);
    [CompilerGeneratedAttribute]
public sealed virtual ThermalController get_Controller();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CurrentTemperature();
    [CompilerGeneratedAttribute]
public sealed virtual int get_DefaultMaximumTemperature();
    [CompilerGeneratedAttribute]
public sealed virtual int get_DefaultMinimumTemperature();
    [CompilerGeneratedAttribute]
public sealed virtual ThermalSettingsTarget get_Target();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUUsageDomainStatus : object {
    [CompilerGeneratedAttribute]
private UtilizationDomain <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Percentage>k__BackingField;
    public UtilizationDomain Domain { get; }
    public int Percentage { get; }
    internal GPUUsageDomainStatus(UtilizationDomain domain, IUtilizationDomainInfo utilizationDomainInfo);
    [CompilerGeneratedAttribute]
public UtilizationDomain get_Domain();
    [CompilerGeneratedAttribute]
public int get_Percentage();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.GPUUsageInformation : object {
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public GPUUsageDomainStatus BusInterface { get; }
    public GPUUsageDomainStatus FrameBuffer { get; }
    public GPUUsageDomainStatus GPU { get; }
    public bool IsDynamicPerformanceStatesEnabled { get; }
    public PhysicalGPU PhysicalGPU { get; }
    public IEnumerable`1<GPUUsageDomainStatus> UtilizationDomainsStatus { get; }
    public GPUUsageDomainStatus VideoEngine { get; }
    internal GPUUsageInformation(PhysicalGPU physicalGPU);
    public GPUUsageDomainStatus get_BusInterface();
    public GPUUsageDomainStatus get_FrameBuffer();
    public GPUUsageDomainStatus get_GPU();
    public bool get_IsDynamicPerformanceStatesEnabled();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public IEnumerable`1<GPUUsageDomainStatus> get_UtilizationDomainsStatus();
    public GPUUsageDomainStatus get_VideoEngine();
    public void EnableDynamicPerformanceStates();
}
public class NvAPIWrapper.GPU.LogicalGPU : object {
    [CompilerGeneratedAttribute]
private LogicalGPUHandle <Handle>k__BackingField;
    public PhysicalGPU[] CorrespondingPhysicalGPUs { get; }
    public LogicalGPUHandle Handle { get; }
    public LogicalGPU(LogicalGPUHandle handle);
    public PhysicalGPU[] get_CorrespondingPhysicalGPUs();
    [CompilerGeneratedAttribute]
public LogicalGPUHandle get_Handle();
    public sealed virtual bool Equals(LogicalGPU other);
    public static LogicalGPU[] GetLogicalGPUs();
    public static bool op_Equality(LogicalGPU left, LogicalGPU right);
    public static bool op_Inequality(LogicalGPU left, LogicalGPU right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.PCIeInformation : object {
    [CompilerGeneratedAttribute]
private PCIeGeneration <Generation>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Lanes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TransferRateInMTps>k__BackingField;
    [CompilerGeneratedAttribute]
private PCIeGeneration <Version>k__BackingField;
    public PCIeGeneration Generation { get; }
    public UInt32 Lanes { get; }
    public UInt32 TransferRateInMTps { get; }
    public PCIeGeneration Version { get; }
    internal PCIeInformation(PCIePerformanceStateInfo stateInfo);
    [CompilerGeneratedAttribute]
public PCIeGeneration get_Generation();
    [CompilerGeneratedAttribute]
public UInt32 get_Lanes();
    [CompilerGeneratedAttribute]
public UInt32 get_TransferRateInMTps();
    [CompilerGeneratedAttribute]
public PCIeGeneration get_Version();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.PCIIdentifiers : object {
    [CompilerGeneratedAttribute]
private UInt32 <DeviceId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExternalDeviceId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RevisionId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SubSystemId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VendorId>k__BackingField;
    public UInt32 DeviceId { get; }
    public ushort ExternalDeviceId { get; }
    public UInt32 RevisionId { get; }
    public UInt32 SubSystemId { get; }
    public ushort VendorId { get; }
    internal PCIIdentifiers(UInt32 deviceId, UInt32 subSystemId, UInt32 revisionId, int externalDeviceId);
    [CompilerGeneratedAttribute]
public UInt32 get_DeviceId();
    [CompilerGeneratedAttribute]
public ushort get_ExternalDeviceId();
    [CompilerGeneratedAttribute]
public UInt32 get_RevisionId();
    [CompilerGeneratedAttribute]
public UInt32 get_SubSystemId();
    [CompilerGeneratedAttribute]
public ushort get_VendorId();
    public sealed virtual bool Equals(PCIIdentifiers other);
    public static bool op_Equality(PCIIdentifiers left, PCIIdentifiers right);
    public static bool op_Inequality(PCIIdentifiers left, PCIIdentifiers right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NvAPIWrapper.GPU.PhysicalGPU : object {
    [CompilerGeneratedAttribute]
private GPUArchitectInformation <ArchitectInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUBusInformation <BusInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUCoolerInformation <CoolerInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private ECCMemoryInformation <ECCMemoryInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private PhysicalGPUHandle <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUMemoryInformation <MemoryInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPerformanceControl <PerformanceControl>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUPowerTopologyInformation <PowerTopologyInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUThermalInformation <ThermalInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private GPUUsageInformation <UsageInformation>k__BackingField;
    public GPUOutput[] ActiveOutputs { get; }
    public GPUArchitectInformation ArchitectInformation { get; }
    public IClockFrequencies BaseClockFrequencies { get; }
    public VideoBIOS Bios { get; }
    public BoardInfo Board { get; }
    public IClockFrequencies BoostClockFrequencies { get; }
    public GPUBusInformation BusInformation { get; }
    public GPUCoolerInformation CoolerInformation { get; }
    public LogicalGPU CorrespondingLogicalGPU { get; }
    public IClockFrequencies CurrentClockFrequencies { get; }
    public UInt32 DriverModel { get; }
    public ECCMemoryInformation ECCMemoryInformation { get; }
    public GPUFoundry Foundry { get; }
    public string FullName { get; }
    public UInt32 GPUId { get; }
    public GPUType GPUType { get; }
    public PhysicalGPUHandle Handle { get; }
    public bool IsQuadro { get; }
    public GPUMemoryInformation MemoryInformation { get; }
    public GPUPerformanceControl PerformanceControl { get; }
    public GPUPerformanceStatesInformation PerformanceStatesInfo { get; }
    public GPUPowerTopologyInformation PowerTopologyInformation { get; }
    public SystemType SystemType { get; }
    public GPUThermalInformation ThermalInformation { get; }
    public GPUUsageInformation UsageInformation { get; }
    public PhysicalGPU(PhysicalGPUHandle handle);
    public GPUOutput[] get_ActiveOutputs();
    [CompilerGeneratedAttribute]
public GPUArchitectInformation get_ArchitectInformation();
    public IClockFrequencies get_BaseClockFrequencies();
    public VideoBIOS get_Bios();
    public BoardInfo get_Board();
    public IClockFrequencies get_BoostClockFrequencies();
    [CompilerGeneratedAttribute]
public GPUBusInformation get_BusInformation();
    [CompilerGeneratedAttribute]
public GPUCoolerInformation get_CoolerInformation();
    public LogicalGPU get_CorrespondingLogicalGPU();
    public IClockFrequencies get_CurrentClockFrequencies();
    public UInt32 get_DriverModel();
    [CompilerGeneratedAttribute]
public ECCMemoryInformation get_ECCMemoryInformation();
    public GPUFoundry get_Foundry();
    public string get_FullName();
    public UInt32 get_GPUId();
    public GPUType get_GPUType();
    [CompilerGeneratedAttribute]
public PhysicalGPUHandle get_Handle();
    public bool get_IsQuadro();
    [CompilerGeneratedAttribute]
public GPUMemoryInformation get_MemoryInformation();
    [CompilerGeneratedAttribute]
public GPUPerformanceControl get_PerformanceControl();
    public GPUPerformanceStatesInformation get_PerformanceStatesInfo();
    [CompilerGeneratedAttribute]
public GPUPowerTopologyInformation get_PowerTopologyInformation();
    public SystemType get_SystemType();
    [CompilerGeneratedAttribute]
public GPUThermalInformation get_ThermalInformation();
    [CompilerGeneratedAttribute]
public GPUUsageInformation get_UsageInformation();
    public sealed virtual bool Equals(PhysicalGPU other);
    public static PhysicalGPU FromGPUId(UInt32 gpuId);
    public static PhysicalGPU[] GetPhysicalGPUs();
    public static PhysicalGPU[] GetTCCPhysicalGPUs();
    public static bool op_Equality(PhysicalGPU left, PhysicalGPU right);
    public static bool op_Inequality(PhysicalGPU left, PhysicalGPU right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public Process[] GetActiveApplications();
    public DisplayDevice[] GetConnectedDisplayDevices(ConnectedIdsFlag flags);
    public DisplayDevice GetDisplayDeviceByOutput(GPUOutput output);
    public DisplayDevice[] GetDisplayDevices();
    public Byte[] ReadEDIDData(GPUOutput output);
    public Byte[] ReadI2C(II2CInfo i2cInfo);
    public bool ValidateOutputCombination(GPUOutput[] outputs);
    public void WriteEDIDData(GPUOutput output, Byte[] edidData);
    public void WriteEDIDData(DisplayDevice display, Byte[] edidData);
    public void WriteI2C(II2CInfo i2cInfo);
    private void WriteEDIDData(UInt32 displayOutputId, Byte[] edidData);
}
public class NvAPIWrapper.GPU.VideoBIOS : object {
    [CompilerGeneratedAttribute]
private int <OEMRevision>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionString>k__BackingField;
    public int OEMRevision { get; }
    public UInt32 Revision { get; }
    public string VersionString { get; }
    internal VideoBIOS(UInt32 revision, int oemRevision, string versionString);
    [CompilerGeneratedAttribute]
public int get_OEMRevision();
    [CompilerGeneratedAttribute]
public UInt32 get_Revision();
    [CompilerGeneratedAttribute]
public string get_VersionString();
    public virtual string ToString();
    public Version AsVersion();
}
public class NvAPIWrapper.Mosaic.GridTopology : object {
    [CompilerGeneratedAttribute]
private bool <AcceleratePrimaryDisplay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyWithBezelCorrectedResolution>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BaseMosaicPanoramic>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private GridTopologyDisplay[] <Displays>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DriverReloadAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Frequency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImmersiveGaming>k__BackingField;
    [CompilerGeneratedAttribute]
private Resolution <Resolution>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rows>k__BackingField;
    public bool AcceleratePrimaryDisplay { get; public set; }
    public bool ApplyWithBezelCorrectedResolution { get; public set; }
    public bool BaseMosaicPanoramic { get; public set; }
    public int Columns { get; private set; }
    public GridTopologyDisplay[] Displays { get; private set; }
    public bool DriverReloadAllowed { get; public set; }
    public int Frequency { get; private set; }
    public bool ImmersiveGaming { get; public set; }
    public Resolution Resolution { get; private set; }
    public int Rows { get; private set; }
    public GridTopology(int rows, int columns, GridTopologyDisplay[] displays);
    public GridTopology(IGridTopology gridTopology);
    [CompilerGeneratedAttribute]
public bool get_AcceleratePrimaryDisplay();
    [CompilerGeneratedAttribute]
public void set_AcceleratePrimaryDisplay(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplyWithBezelCorrectedResolution();
    [CompilerGeneratedAttribute]
public void set_ApplyWithBezelCorrectedResolution(bool value);
    [CompilerGeneratedAttribute]
public bool get_BaseMosaicPanoramic();
    [CompilerGeneratedAttribute]
public void set_BaseMosaicPanoramic(bool value);
    [CompilerGeneratedAttribute]
public int get_Columns();
    [CompilerGeneratedAttribute]
private void set_Columns(int value);
    [CompilerGeneratedAttribute]
public GridTopologyDisplay[] get_Displays();
    [CompilerGeneratedAttribute]
private void set_Displays(GridTopologyDisplay[] value);
    [CompilerGeneratedAttribute]
public bool get_DriverReloadAllowed();
    [CompilerGeneratedAttribute]
public void set_DriverReloadAllowed(bool value);
    [CompilerGeneratedAttribute]
public int get_Frequency();
    [CompilerGeneratedAttribute]
private void set_Frequency(int value);
    [CompilerGeneratedAttribute]
public bool get_ImmersiveGaming();
    [CompilerGeneratedAttribute]
public void set_ImmersiveGaming(bool value);
    [CompilerGeneratedAttribute]
public Resolution get_Resolution();
    [CompilerGeneratedAttribute]
private void set_Resolution(Resolution value);
    [CompilerGeneratedAttribute]
public int get_Rows();
    [CompilerGeneratedAttribute]
private void set_Rows(int value);
    public sealed virtual bool Equals(GridTopology other);
    public static GridTopology[] GetGridTopologies();
    public static bool op_Equality(GridTopology left, GridTopology right);
    public static bool op_Inequality(GridTopology left, GridTopology right);
    public static void SetGridTopologies(GridTopology[] grids, SetDisplayTopologyFlag flags);
    public static DisplayTopologyStatus[] ValidateGridTopologies(GridTopology[] grids, SetDisplayTopologyFlag flags);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public DisplaySettingsV1 GetDisplaySettingsV1();
    public GridTopologyV1 GetGridTopologyV1();
    public GridTopologyV2 GetGridTopologyV2();
    public IDisplaySettings[] GetPossibleDisplaySettings();
    public void SetDisplays(int rows, int columns, GridTopologyDisplay[] displays);
    public void SetDisplaySettings(IDisplaySettings displaySettings);
}
public class NvAPIWrapper.Mosaic.GridTopologyDisplay : object {
    [CompilerGeneratedAttribute]
private UInt32 <CloneGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayDevice <DisplayDevice>k__BackingField;
    [CompilerGeneratedAttribute]
private Overlap <Overlap>k__BackingField;
    [CompilerGeneratedAttribute]
private PixelShiftType <PixelShiftType>k__BackingField;
    [CompilerGeneratedAttribute]
private Rotate <Rotation>k__BackingField;
    public UInt32 CloneGroup { get; public set; }
    public DisplayDevice DisplayDevice { get; }
    public Overlap Overlap { get; public set; }
    public PixelShiftType PixelShiftType { get; public set; }
    public Rotate Rotation { get; public set; }
    public GridTopologyDisplay(UInt32 displayId, Overlap overlap, Rotate rotation, UInt32 cloneGroup, PixelShiftType pixelShiftType);
    public GridTopologyDisplay(DisplayDevice display, Overlap overlap, Rotate rotation, UInt32 cloneGroup, PixelShiftType pixelShiftType);
    public GridTopologyDisplay(IGridTopologyDisplay gridTopologyDisplay);
    [CompilerGeneratedAttribute]
public UInt32 get_CloneGroup();
    [CompilerGeneratedAttribute]
public void set_CloneGroup(UInt32 value);
    [CompilerGeneratedAttribute]
public DisplayDevice get_DisplayDevice();
    [CompilerGeneratedAttribute]
public Overlap get_Overlap();
    [CompilerGeneratedAttribute]
public void set_Overlap(Overlap value);
    [CompilerGeneratedAttribute]
public PixelShiftType get_PixelShiftType();
    [CompilerGeneratedAttribute]
public void set_PixelShiftType(PixelShiftType value);
    [CompilerGeneratedAttribute]
public Rotate get_Rotation();
    [CompilerGeneratedAttribute]
public void set_Rotation(Rotate value);
    public sealed virtual bool Equals(GridTopologyDisplay other);
    public static bool op_Equality(GridTopologyDisplay left, GridTopologyDisplay right);
    public static bool op_Inequality(GridTopologyDisplay left, GridTopologyDisplay right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public GridTopologyDisplayV1 GetGridTopologyDisplayV1();
    public GridTopologyDisplayV2 GetGridTopologyDisplayV2();
}
public class NvAPIWrapper.Mosaic.Overlap : ValueType {
    [CompilerGeneratedAttribute]
private int <HorizontalOverlap>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VerticalOverlap>k__BackingField;
    public int HorizontalOverlap { get; }
    public int VerticalOverlap { get; }
    public Overlap(int overlapX, int overlapY);
    [CompilerGeneratedAttribute]
public int get_HorizontalOverlap();
    [CompilerGeneratedAttribute]
public int get_VerticalOverlap();
    public sealed virtual bool Equals(Overlap other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Overlap left, Overlap right);
    public static bool op_Inequality(Overlap left, Overlap right);
    public virtual string ToString();
}
public class NvAPIWrapper.Mosaic.OverlapLimit : ValueType {
    [CompilerGeneratedAttribute]
private int <MinimumHorizontalOverlap>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumHorizontalOverlap>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumVerticalOverlap>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumVerticalOverlap>k__BackingField;
    public int MinimumHorizontalOverlap { get; }
    public int MaximumHorizontalOverlap { get; }
    public int MinimumVerticalOverlap { get; }
    public int MaximumVerticalOverlap { get; }
    internal OverlapLimit(int minOverlapX, int maxOverlapX, int minOverlapY, int maxOverlapY);
    [CompilerGeneratedAttribute]
public int get_MinimumHorizontalOverlap();
    [CompilerGeneratedAttribute]
public int get_MaximumHorizontalOverlap();
    [CompilerGeneratedAttribute]
public int get_MinimumVerticalOverlap();
    [CompilerGeneratedAttribute]
public int get_MaximumVerticalOverlap();
    public sealed virtual bool Equals(OverlapLimit other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(OverlapLimit left, OverlapLimit right);
    public static bool op_Inequality(OverlapLimit left, OverlapLimit right);
    public virtual string ToString();
    public bool IsInHorizontalRange(int overlapX);
    public bool IsInVerticalRange(int overlapY);
    public bool IsInRange(Overlap overlap);
}
[ObsoleteAttribute("Using Mosaic API Phase 1, please consider using TopologyGrid class on newer drivers", "False")]
public class NvAPIWrapper.Mosaic.Topology : object {
    [CompilerGeneratedAttribute]
private int <Frequency>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FrequencyInMillihertz>k__BackingField;
    [CompilerGeneratedAttribute]
private Overlap <Overlap>k__BackingField;
    [CompilerGeneratedAttribute]
private Resolution <Resolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Topology <TopologyMode>k__BackingField;
    public int Frequency { get; }
    public UInt32 FrequencyInMillihertz { get; }
    public Overlap Overlap { get; }
    public Resolution Resolution { get; }
    public Topology TopologyMode { get; }
    public Topology(Resolution resolution, int frequency, Topology topology, Overlap overlap);
    public Topology(Resolution resolution, int frequency, UInt32 frequencyInMillihertz, Topology topology, Overlap overlap);
    [CompilerGeneratedAttribute]
public int get_Frequency();
    [CompilerGeneratedAttribute]
public UInt32 get_FrequencyInMillihertz();
    [CompilerGeneratedAttribute]
public Overlap get_Overlap();
    [CompilerGeneratedAttribute]
public Resolution get_Resolution();
    [CompilerGeneratedAttribute]
public Topology get_TopologyMode();
    public sealed virtual bool Equals(Topology other);
    public static void DisableCurrent();
    public static void EnableCurrent();
    public static Topology GetCurrentTopology();
    public static Topology[] GetSupportedTopologyModes(TopologyType type);
    public static IDisplaySettings[] GetSupportedTopologySettings(TopologyType type);
    public static bool IsCurrentTopologyEnabled();
    public static bool IsCurrentTopologyPossible();
    public static bool op_Equality(Topology left, Topology right);
    public static bool op_Inequality(Topology left, Topology right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public TopologyDetails[] GetDetails();
    public DisplaySettingsV1 GetDisplaySettingsV1();
    public DisplaySettingsV2 GetDisplaySettingsV2();
    public OverlapLimit GetOverlapLimits();
    public TopologyBrief GetTopologyBrief();
    public void SetAsCurrentTopology(bool apply);
}
public class NvAPIWrapper.Mosaic.TopologyDetails : object {
    [CompilerGeneratedAttribute]
private int <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private TopologyDisplay[][] <Displays>k__BackingField;
    [CompilerGeneratedAttribute]
private LogicalGPU <LogicalGPU>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rows>k__BackingField;
    [CompilerGeneratedAttribute]
private TopologyValidity <ValidityFlags>k__BackingField;
    public int Columns { get; }
    public TopologyDisplay[][] Displays { get; }
    public LogicalGPU LogicalGPU { get; }
    public int Rows { get; }
    public TopologyValidity ValidityFlags { get; }
    internal TopologyDetails(TopologyDetails details);
    [CompilerGeneratedAttribute]
public int get_Columns();
    [CompilerGeneratedAttribute]
public TopologyDisplay[][] get_Displays();
    [CompilerGeneratedAttribute]
public LogicalGPU get_LogicalGPU();
    [CompilerGeneratedAttribute]
public int get_Rows();
    [CompilerGeneratedAttribute]
public TopologyValidity get_ValidityFlags();
    public sealed virtual bool Equals(TopologyDetails other);
    public static bool op_Equality(TopologyDetails left, TopologyDetails right);
    public static bool op_Inequality(TopologyDetails left, TopologyDetails right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NvAPIWrapper.Mosaic.TopologyDisplay : object {
    [CompilerGeneratedAttribute]
private GPUOutput <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private Overlap <Overlap>k__BackingField;
    [CompilerGeneratedAttribute]
private PhysicalGPU <PhysicalGPU>k__BackingField;
    public GPUOutput Output { get; }
    public Overlap Overlap { get; }
    public PhysicalGPU PhysicalGPU { get; }
    internal TopologyDisplay(LayoutCell layoutCell);
    [CompilerGeneratedAttribute]
public GPUOutput get_Output();
    [CompilerGeneratedAttribute]
public Overlap get_Overlap();
    [CompilerGeneratedAttribute]
public PhysicalGPU get_PhysicalGPU();
    public sealed virtual bool Equals(TopologyDisplay other);
    public static bool op_Equality(TopologyDisplay left, TopologyDisplay right);
    public static bool op_Inequality(TopologyDisplay left, TopologyDisplay right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("6144")]
internal class NvAPIWrapper.Native.Attributes.AcceptsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    public Type[] Types { get; public set; }
    public AcceptsAttribute(Type[] types);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
public void set_Types(Type[] value);
}
[AttributeUsageAttribute("4096")]
internal class NvAPIWrapper.Native.Attributes.FunctionIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private FunctionId <FunctionId>k__BackingField;
    public FunctionId FunctionId { get; public set; }
    public FunctionIdAttribute(FunctionId functionId);
    [CompilerGeneratedAttribute]
public FunctionId get_FunctionId();
    [CompilerGeneratedAttribute]
public void set_FunctionId(FunctionId value);
}
[AttributeUsageAttribute("8")]
internal class NvAPIWrapper.Native.Attributes.StructureVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <VersionNumber>k__BackingField;
    public int VersionNumber { get; public set; }
    public StructureVersionAttribute(int versionNumber);
    [CompilerGeneratedAttribute]
public int get_VersionNumber();
    [CompilerGeneratedAttribute]
public void set_VersionNumber(int value);
}
internal static class NvAPIWrapper.Native.Constants.Display : object {
    public static int AdvancedDisplayHeads;
    public static int MaxDisplayHeads;
}
internal static class NvAPIWrapper.Native.Constants.General : object {
    public static int BinaryDataMax;
    public static int UnicodeStringLength;
}
internal static class NvAPIWrapper.Native.Delegates.Display : object {
}
internal static class NvAPIWrapper.Native.Delegates.DRS : object {
}
internal static class NvAPIWrapper.Native.Delegates.General : object {
}
internal static class NvAPIWrapper.Native.Delegates.GPU : object {
}
internal static class NvAPIWrapper.Native.Delegates.Mosaic : object {
}
internal static class NvAPIWrapper.Native.Delegates.Stereo : object {
}
public enum NvAPIWrapper.Native.Display.ColorDataColorimetry : Enum {
    public UInt32 value__;
    public static ColorDataColorimetry RGB;
    public static ColorDataColorimetry YCC601;
    public static ColorDataColorimetry YCC709;
    public static ColorDataColorimetry XVYCC601;
    public static ColorDataColorimetry XVYCC709;
    public static ColorDataColorimetry SYCC601;
    public static ColorDataColorimetry ADOBEYCC601;
    public static ColorDataColorimetry ADOBERGB;
    public static ColorDataColorimetry BT2020RGB;
    public static ColorDataColorimetry BT2020YCC;
    public static ColorDataColorimetry BT2020cYCC;
    public static ColorDataColorimetry Default;
    public static ColorDataColorimetry Auto;
}
public enum NvAPIWrapper.Native.Display.ColorDataCommand : Enum {
    public UInt32 value__;
    public static ColorDataCommand Get;
    public static ColorDataCommand Set;
    public static ColorDataCommand IsSupportedColor;
    public static ColorDataCommand GetDefault;
}
public enum NvAPIWrapper.Native.Display.ColorDataDepth : Enum {
    public UInt32 value__;
    public static ColorDataDepth Default;
    public static ColorDataDepth BPC6;
    public static ColorDataDepth BPC8;
    public static ColorDataDepth BPC10;
    public static ColorDataDepth BPC12;
    public static ColorDataDepth BPC16;
}
public enum NvAPIWrapper.Native.Display.ColorDataDesktopDepth : Enum {
    public UInt32 value__;
    public static ColorDataDesktopDepth Default;
    public static ColorDataDesktopDepth BPC8;
    public static ColorDataDesktopDepth BPC10;
    public static ColorDataDesktopDepth BPC16Float;
    public static ColorDataDesktopDepth BPC16FloatWcg;
    public static ColorDataDesktopDepth BPC16FloatHDR;
}
public enum NvAPIWrapper.Native.Display.ColorDataDynamicRange : Enum {
    public UInt32 value__;
    public static ColorDataDynamicRange VESA;
    public static ColorDataDynamicRange CEA;
    public static ColorDataDynamicRange Auto;
}
public enum NvAPIWrapper.Native.Display.ColorDataFormat : Enum {
    public UInt32 value__;
    public static ColorDataFormat RGB;
    public static ColorDataFormat YUV422;
    public static ColorDataFormat YUV444;
    public static ColorDataFormat YUV420;
    public static ColorDataFormat Default;
    public static ColorDataFormat Auto;
}
public enum NvAPIWrapper.Native.Display.ColorDataHDRCommand : Enum {
    public UInt32 value__;
    public static ColorDataHDRCommand Get;
    public static ColorDataHDRCommand Set;
}
public enum NvAPIWrapper.Native.Display.ColorDataHDRMode : Enum {
    public UInt32 value__;
    public static ColorDataHDRMode Off;
    public static ColorDataHDRMode UHDA;
    [ObsoleteAttribute("Do not use! Internal test mode only, to be removed.", "False")]
public static ColorDataHDRMode EDR;
    [ObsoleteAttribute("Do not use! Internal test mode only, to be removed.", "False")]
public static ColorDataHDRMode SDR;
    [ObsoleteAttribute("Experimental mode only, not for production!", "False")]
public static ColorDataHDRMode UHDAPassthrough;
    [ObsoleteAttribute("Do not use! Internal test mode only, to be removed.", "False")]
public static ColorDataHDRMode UHDANB;
    [ObsoleteAttribute("Experimental mode only, not for production!", "False")]
public static ColorDataHDRMode DolbyVision;
}
public enum NvAPIWrapper.Native.Display.ColorDataSelectionPolicy : Enum {
    public UInt32 value__;
    public static ColorDataSelectionPolicy User;
    public static ColorDataSelectionPolicy BestQuality;
    public static ColorDataSelectionPolicy Default;
    public static ColorDataSelectionPolicy Unknown;
}
public enum NvAPIWrapper.Native.Display.ColorFormat : Enum {
    public int value__;
    public static ColorFormat Unknown;
    public static ColorFormat P8;
    public static ColorFormat R5G6B5;
    public static ColorFormat A8R8G8B8;
    public static ColorFormat A16B16G16R16F;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.Display.DisplayConfigFlags : Enum {
    public int value__;
    public static DisplayConfigFlags None;
    public static DisplayConfigFlags ValidateOnly;
    public static DisplayConfigFlags SaveToPersistence;
    public static DisplayConfigFlags DriverReloadAllowed;
    public static DisplayConfigFlags ForceModeEnumeration;
    public static DisplayConfigFlags ForceCommitVideoPresentNetwork;
}
public enum NvAPIWrapper.Native.Display.DisplayPortColorDepth : Enum {
    public UInt32 value__;
    public static DisplayPortColorDepth Default;
    public static DisplayPortColorDepth BPC6;
    public static DisplayPortColorDepth BPC8;
    public static DisplayPortColorDepth BPC10;
    public static DisplayPortColorDepth BPC12;
    public static DisplayPortColorDepth BPC16;
}
public enum NvAPIWrapper.Native.Display.DisplayPortColorFormat : Enum {
    public UInt32 value__;
    public static DisplayPortColorFormat RGB;
    public static DisplayPortColorFormat YCbCr422;
    public static DisplayPortColorFormat YCbCr444;
}
public enum NvAPIWrapper.Native.Display.InfoFrameAudioChannelAllocation : Enum {
    public UInt32 value__;
    public static InfoFrameAudioChannelAllocation FrFl;
    public static InfoFrameAudioChannelAllocation LfeFrFl;
    public static InfoFrameAudioChannelAllocation FcFrFl;
    public static InfoFrameAudioChannelAllocation FcLfeFrFl;
    public static InfoFrameAudioChannelAllocation RcFrFl;
    public static InfoFrameAudioChannelAllocation RcLfeFrFl;
    public static InfoFrameAudioChannelAllocation RcFcFrFl;
    public static InfoFrameAudioChannelAllocation RcFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation RrRlFrFl;
    public static InfoFrameAudioChannelAllocation RrRlLfeFrFl;
    public static InfoFrameAudioChannelAllocation RrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation RrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation RcRrRlFrFl;
    public static InfoFrameAudioChannelAllocation RcRrRlLfeFrFl;
    public static InfoFrameAudioChannelAllocation RcRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation RcRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation RrcRlcRrRlFrFl;
    public static InfoFrameAudioChannelAllocation RrcRlcRrRlLfeFrFl;
    public static InfoFrameAudioChannelAllocation RrcRlcRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation RrcRlcRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcFcFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcRcFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcRcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcRcFcFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcRcFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcRrRlFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcRrRlLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation FrcFlcRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FchRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation FchRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation TcRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation TcRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrhFlhRrRlFrFl;
    public static InfoFrameAudioChannelAllocation FrhFlhRrRlLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrwFlwRrRlFrFl;
    public static InfoFrameAudioChannelAllocation FrwFlwRrRlLfeFrFl;
    public static InfoFrameAudioChannelAllocation TcRcRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation TcRcRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FchRcRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation FchRcRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation TcFcRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation TcFchRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrhFlhRrRlFcFrFl;
    public static InfoFrameAudioChannelAllocation FrhFlhRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation FrwFlwRrRlFcFeFl;
    public static InfoFrameAudioChannelAllocation FrwFlwRrRlFcLfeFrFl;
    public static InfoFrameAudioChannelAllocation Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameAudioChannelCount : Enum {
    public UInt32 value__;
    public static InfoFrameAudioChannelCount InHeader;
    public static InfoFrameAudioChannelCount Two;
    public static InfoFrameAudioChannelCount Three;
    public static InfoFrameAudioChannelCount Four;
    public static InfoFrameAudioChannelCount Five;
    public static InfoFrameAudioChannelCount Six;
    public static InfoFrameAudioChannelCount Seven;
    public static InfoFrameAudioChannelCount Eight;
    public static InfoFrameAudioChannelCount Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameAudioCodec : Enum {
    public UInt32 value__;
    public static InfoFrameAudioCodec InHeader;
    public static InfoFrameAudioCodec PCM;
    public static InfoFrameAudioCodec AC3;
    public static InfoFrameAudioCodec MPEG1;
    public static InfoFrameAudioCodec MP3;
    public static InfoFrameAudioCodec MPEG2;
    public static InfoFrameAudioCodec AACLC;
    public static InfoFrameAudioCodec DTS;
    public static InfoFrameAudioCodec ATRAC;
    public static InfoFrameAudioCodec DSD;
    public static InfoFrameAudioCodec EAC3;
    public static InfoFrameAudioCodec DTSHD;
    public static InfoFrameAudioCodec MLP;
    public static InfoFrameAudioCodec DST;
    public static InfoFrameAudioCodec WMAPRO;
    public static InfoFrameAudioCodec UseExtendedCodecType;
    public static InfoFrameAudioCodec Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameAudioExtendedCodec : Enum {
    public UInt32 value__;
    public static InfoFrameAudioExtendedCodec UseCodecType;
    public static InfoFrameAudioExtendedCodec HEAAC;
    public static InfoFrameAudioExtendedCodec HEAACVersion2;
    public static InfoFrameAudioExtendedCodec MPEGSurround;
    public static InfoFrameAudioExtendedCodec Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameAudioLevelShift : Enum {
    public UInt32 value__;
    public static InfoFrameAudioLevelShift Shift0Decibel;
    public static InfoFrameAudioLevelShift Shift1Decibel;
    public static InfoFrameAudioLevelShift Shift2Decibel;
    public static InfoFrameAudioLevelShift Shift3Decibel;
    public static InfoFrameAudioLevelShift Shift4Decibel;
    public static InfoFrameAudioLevelShift Shift5Decibel;
    public static InfoFrameAudioLevelShift Shift6Decibel;
    public static InfoFrameAudioLevelShift Shift7Decibel;
    public static InfoFrameAudioLevelShift Shift8Decibel;
    public static InfoFrameAudioLevelShift Shift9Decibel;
    public static InfoFrameAudioLevelShift Shift10Decibel;
    public static InfoFrameAudioLevelShift Shift11Decibel;
    public static InfoFrameAudioLevelShift Shift12Decibel;
    public static InfoFrameAudioLevelShift Shift13Decibel;
    public static InfoFrameAudioLevelShift Shift14Decibel;
    public static InfoFrameAudioLevelShift Shift15Decibel;
    public static InfoFrameAudioLevelShift Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameAudioLFEPlaybackLevel : Enum {
    public UInt32 value__;
    public static InfoFrameAudioLFEPlaybackLevel NoData;
    public static InfoFrameAudioLFEPlaybackLevel Plus0Decibel;
    public static InfoFrameAudioLFEPlaybackLevel Plus10Decibel;
    public static InfoFrameAudioLFEPlaybackLevel Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameAudioSampleRate : Enum {
    public UInt32 value__;
    public static InfoFrameAudioSampleRate InHeader;
    public static InfoFrameAudioSampleRate F32000Hz;
    public static InfoFrameAudioSampleRate F44100Hz;
    public static InfoFrameAudioSampleRate F48000Hz;
    public static InfoFrameAudioSampleRate F88200Hz;
    public static InfoFrameAudioSampleRate F96000Hz;
    public static InfoFrameAudioSampleRate F176400Hz;
    public static InfoFrameAudioSampleRate F192000Hz;
    public static InfoFrameAudioSampleRate Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameAudioSampleSize : Enum {
    public UInt32 value__;
    public static InfoFrameAudioSampleSize InHeader;
    public static InfoFrameAudioSampleSize B16;
    public static InfoFrameAudioSampleSize B20;
    public static InfoFrameAudioSampleSize B24;
    public static InfoFrameAudioSampleSize Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameBoolean : Enum {
    public UInt32 value__;
    public static InfoFrameBoolean False;
    public static InfoFrameBoolean True;
    public static InfoFrameBoolean Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameCommand : Enum {
    public UInt32 value__;
    public static InfoFrameCommand GetDefault;
    public static InfoFrameCommand Reset;
    public static InfoFrameCommand Get;
    public static InfoFrameCommand Set;
    public static InfoFrameCommand GetOverride;
    public static InfoFrameCommand SetOverride;
    public static InfoFrameCommand GetProperty;
    public static InfoFrameCommand SetProperty;
}
public enum NvAPIWrapper.Native.Display.InfoFrameDataType : Enum {
    public UInt32 value__;
    public static InfoFrameDataType AuxiliaryVideoInformation;
    public static InfoFrameDataType AudioInformation;
}
public enum NvAPIWrapper.Native.Display.InfoFramePropertyMode : Enum {
    public UInt32 value__;
    public static InfoFramePropertyMode Auto;
    public static InfoFramePropertyMode Enable;
    public static InfoFramePropertyMode Disable;
    public static InfoFramePropertyMode AllowOverride;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoAspectRatioActivePortion : Enum {
    public UInt32 value__;
    public static InfoFrameVideoAspectRatioActivePortion Disabled;
    public static InfoFrameVideoAspectRatioActivePortion LetterboxGreaterThan16X9;
    public static InfoFrameVideoAspectRatioActivePortion EqualCodedFrame;
    public static InfoFrameVideoAspectRatioActivePortion Center4X3;
    public static InfoFrameVideoAspectRatioActivePortion Center16X9;
    public static InfoFrameVideoAspectRatioActivePortion Center14X9;
    public static InfoFrameVideoAspectRatioActivePortion Bordered4X3On14X9;
    public static InfoFrameVideoAspectRatioActivePortion Bordered16X9On14X9;
    public static InfoFrameVideoAspectRatioActivePortion Bordered16X9On4X3;
    public static InfoFrameVideoAspectRatioActivePortion Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoAspectRatioCodedFrame : Enum {
    public UInt32 value__;
    public static InfoFrameVideoAspectRatioCodedFrame NoData;
    public static InfoFrameVideoAspectRatioCodedFrame Aspect4X3;
    public static InfoFrameVideoAspectRatioCodedFrame Aspect16X9;
    public static InfoFrameVideoAspectRatioCodedFrame Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoBarData : Enum {
    public UInt32 value__;
    public static InfoFrameVideoBarData NotPresent;
    public static InfoFrameVideoBarData Vertical;
    public static InfoFrameVideoBarData Horizontal;
    public static InfoFrameVideoBarData Both;
    public static InfoFrameVideoBarData Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoColorFormat : Enum {
    public UInt32 value__;
    public static InfoFrameVideoColorFormat RGB;
    public static InfoFrameVideoColorFormat YCbCr422;
    public static InfoFrameVideoColorFormat YCbCr444;
    public static InfoFrameVideoColorFormat Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoColorimetry : Enum {
    public UInt32 value__;
    public static InfoFrameVideoColorimetry NoData;
    public static InfoFrameVideoColorimetry SMPTE170M;
    public static InfoFrameVideoColorimetry ITURBT709;
    public static InfoFrameVideoColorimetry UseExtendedColorimetry;
    public static InfoFrameVideoColorimetry Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoContentType : Enum {
    public UInt32 value__;
    public static InfoFrameVideoContentType Graphics;
    public static InfoFrameVideoContentType Photo;
    public static InfoFrameVideoContentType Cinema;
    public static InfoFrameVideoContentType Game;
    public static InfoFrameVideoContentType Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoExtendedColorimetry : Enum {
    public UInt32 value__;
    public static InfoFrameVideoExtendedColorimetry xvYCC601;
    public static InfoFrameVideoExtendedColorimetry xvYCC709;
    public static InfoFrameVideoExtendedColorimetry sYCC601;
    public static InfoFrameVideoExtendedColorimetry AdobeYCC601;
    public static InfoFrameVideoExtendedColorimetry AdobeRGB;
    public static InfoFrameVideoExtendedColorimetry Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoITC : Enum {
    public UInt32 value__;
    public static InfoFrameVideoITC VideoContent;
    public static InfoFrameVideoITC ITContent;
    public static InfoFrameVideoITC Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoNonUniformPictureScaling : Enum {
    public UInt32 value__;
    public static InfoFrameVideoNonUniformPictureScaling NoData;
    public static InfoFrameVideoNonUniformPictureScaling Horizontal;
    public static InfoFrameVideoNonUniformPictureScaling Vertical;
    public static InfoFrameVideoNonUniformPictureScaling Both;
    public static InfoFrameVideoNonUniformPictureScaling Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoPixelRepetition : Enum {
    public UInt32 value__;
    public static InfoFrameVideoPixelRepetition None;
    public static InfoFrameVideoPixelRepetition X2;
    public static InfoFrameVideoPixelRepetition X3;
    public static InfoFrameVideoPixelRepetition X4;
    public static InfoFrameVideoPixelRepetition X5;
    public static InfoFrameVideoPixelRepetition X6;
    public static InfoFrameVideoPixelRepetition X7;
    public static InfoFrameVideoPixelRepetition X8;
    public static InfoFrameVideoPixelRepetition X9;
    public static InfoFrameVideoPixelRepetition X10;
    public static InfoFrameVideoPixelRepetition Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoRGBQuantization : Enum {
    public UInt32 value__;
    public static InfoFrameVideoRGBQuantization Default;
    public static InfoFrameVideoRGBQuantization LimitedRange;
    public static InfoFrameVideoRGBQuantization FullRange;
    public static InfoFrameVideoRGBQuantization Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoScanInfo : Enum {
    public UInt32 value__;
    public static InfoFrameVideoScanInfo NoData;
    public static InfoFrameVideoScanInfo OverScan;
    public static InfoFrameVideoScanInfo UnderScan;
    public static InfoFrameVideoScanInfo Auto;
}
public enum NvAPIWrapper.Native.Display.InfoFrameVideoYCCQuantization : Enum {
    public UInt32 value__;
    public static InfoFrameVideoYCCQuantization LimitedRange;
    public static InfoFrameVideoYCCQuantization FullRange;
    public static InfoFrameVideoYCCQuantization Auto;
}
public enum NvAPIWrapper.Native.Display.MonitorCapabilitiesConnectorType : Enum {
    public UInt32 value__;
    public static MonitorCapabilitiesConnectorType Unknown;
    public static MonitorCapabilitiesConnectorType VGA;
    public static MonitorCapabilitiesConnectorType TV;
    public static MonitorCapabilitiesConnectorType DVI;
    public static MonitorCapabilitiesConnectorType HDMI;
    public static MonitorCapabilitiesConnectorType DisplayPort;
}
public enum NvAPIWrapper.Native.Display.MonitorCapabilitiesType : Enum {
    public UInt32 value__;
    public static MonitorCapabilitiesType VSDB;
    public static MonitorCapabilitiesType VCDB;
}
public enum NvAPIWrapper.Native.Display.Rotate : Enum {
    public UInt32 value__;
    public static Rotate Degree0;
    public static Rotate Degree90;
    public static Rotate Degree180;
    public static Rotate Degree270;
    public static Rotate Ignored;
}
public enum NvAPIWrapper.Native.Display.Scaling : Enum {
    public int value__;
    public static Scaling Default;
    public static Scaling ToClosest;
    public static Scaling ToNative;
    public static Scaling GPUScanOutToNative;
    public static Scaling ToAspectScanOutToNative;
    public static Scaling ToAspectScanOutToClosest;
    public static Scaling GPUScanOutToClosest;
    public static Scaling Customized;
}
public enum NvAPIWrapper.Native.Display.ScanOutCompositionParameter : Enum {
    public UInt32 value__;
    public static ScanOutCompositionParameter WarpingReSamplingMethod;
}
public enum NvAPIWrapper.Native.Display.ScanOutCompositionParameterValue : Enum {
    public UInt32 value__;
    public static ScanOutCompositionParameterValue Default;
    public static ScanOutCompositionParameterValue WarpingReSamplingMethodBiLinear;
    public static ScanOutCompositionParameterValue WarpingReSamplingMethodBicubicTriangular;
    public static ScanOutCompositionParameterValue WarpingReSamplingMethodBicubicBellShaped;
    public static ScanOutCompositionParameterValue WarpingReSamplingMethodBicubicBSpline;
    public static ScanOutCompositionParameterValue WarpingReSamplingMethodBicubicAdaptiveTriangular;
    public static ScanOutCompositionParameterValue WarpingReSamplingMethodBicubicAdaptiveBellShaped;
    public static ScanOutCompositionParameterValue WarpingReSamplingMethodBicubicAdaptiveBSpline;
}
public enum NvAPIWrapper.Native.Display.SpanningOrientation : Enum {
    public int value__;
    public static SpanningOrientation None;
    public static SpanningOrientation Horizontal;
    public static SpanningOrientation Vertical;
}
public enum NvAPIWrapper.Native.Display.StaticMetadataDescriptorId : Enum {
    public UInt32 value__;
    public static StaticMetadataDescriptorId StaticMetadataType1;
}
public class NvAPIWrapper.Native.Display.Structures.ColorDataColorCoordinate : ValueType {
    private ushort _X;
    private ushort _Y;
    public float X { get; }
    public float Y { get; }
    public ColorDataColorCoordinate(float x, float y);
    public ColorDataColorCoordinate(PointF coordinate);
    public float get_X();
    public float get_Y();
    public virtual string ToString();
    public sealed virtual bool Equals(ColorDataColorCoordinate other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ColorDataColorCoordinate left, ColorDataColorCoordinate right);
    public static bool op_Inequality(ColorDataColorCoordinate left, ColorDataColorCoordinate right);
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.ColorDataV1 : ValueType {
    internal StructureVersion _Version;
    internal ushort _Size;
    private byte _Command;
    private ColorDataBag _Data;
    public ColorDataFormat ColorFormat { get; }
    public ColorDataColorimetry Colorimetry { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataSelectionPolicy> SelectionPolicy { get; }
    public Nullable`1<ColorDataDesktopDepth> DesktopColorDepth { get; }
    public ColorDataV1(ColorDataCommand command);
    public ColorDataV1(ColorDataCommand command, ColorDataFormat colorFormat, ColorDataColorimetry colorimetry);
    public sealed virtual ColorDataFormat get_ColorFormat();
    public sealed virtual ColorDataColorimetry get_Colorimetry();
    public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    public sealed virtual Nullable`1<ColorDataSelectionPolicy> get_SelectionPolicy();
    public sealed virtual Nullable`1<ColorDataDesktopDepth> get_DesktopColorDepth();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.Display.Structures.ColorDataV2 : ValueType {
    internal StructureVersion _Version;
    internal ushort _Size;
    private byte _Command;
    private ColorDataBag _Data;
    public ColorDataFormat ColorFormat { get; }
    public ColorDataColorimetry Colorimetry { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataSelectionPolicy> SelectionPolicy { get; }
    public Nullable`1<ColorDataDesktopDepth> DesktopColorDepth { get; }
    public ColorDataV2(ColorDataCommand command);
    public ColorDataV2(ColorDataCommand command, ColorDataFormat colorFormat, ColorDataColorimetry colorimetry, ColorDataDynamicRange colorDynamicRange);
    public sealed virtual ColorDataFormat get_ColorFormat();
    public sealed virtual ColorDataColorimetry get_Colorimetry();
    public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    public sealed virtual Nullable`1<ColorDataSelectionPolicy> get_SelectionPolicy();
    public sealed virtual Nullable`1<ColorDataDesktopDepth> get_DesktopColorDepth();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.Display.Structures.ColorDataV3 : ValueType {
    internal StructureVersion _Version;
    internal ushort _Size;
    private byte _Command;
    private ColorDataBag _Data;
    public ColorDataFormat ColorFormat { get; }
    public ColorDataColorimetry Colorimetry { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataSelectionPolicy> SelectionPolicy { get; }
    public Nullable`1<ColorDataDesktopDepth> DesktopColorDepth { get; }
    public ColorDataV3(ColorDataCommand command);
    public ColorDataV3(ColorDataCommand command, ColorDataFormat colorFormat, ColorDataColorimetry colorimetry, ColorDataDynamicRange colorDynamicRange, ColorDataDepth colorDepth);
    public sealed virtual ColorDataFormat get_ColorFormat();
    public sealed virtual ColorDataColorimetry get_Colorimetry();
    public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    public sealed virtual Nullable`1<ColorDataSelectionPolicy> get_SelectionPolicy();
    public sealed virtual Nullable`1<ColorDataDesktopDepth> get_DesktopColorDepth();
}
[StructureVersionAttribute("4")]
public class NvAPIWrapper.Native.Display.Structures.ColorDataV4 : ValueType {
    internal StructureVersion _Version;
    internal ushort _Size;
    private byte _Command;
    private ColorDataBag _Data;
    public ColorDataFormat ColorFormat { get; }
    public ColorDataColorimetry Colorimetry { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataSelectionPolicy> SelectionPolicy { get; }
    public Nullable`1<ColorDataDesktopDepth> DesktopColorDepth { get; }
    public ColorDataV4(ColorDataCommand command);
    public ColorDataV4(ColorDataCommand command, ColorDataFormat colorFormat, ColorDataColorimetry colorimetry, ColorDataDynamicRange colorDynamicRange, ColorDataDepth colorDepth, ColorDataSelectionPolicy colorSelectionPolicy);
    public sealed virtual ColorDataFormat get_ColorFormat();
    public sealed virtual ColorDataColorimetry get_Colorimetry();
    public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    public sealed virtual Nullable`1<ColorDataSelectionPolicy> get_SelectionPolicy();
    public sealed virtual Nullable`1<ColorDataDesktopDepth> get_DesktopColorDepth();
}
[StructureVersionAttribute("5")]
public class NvAPIWrapper.Native.Display.Structures.ColorDataV5 : ValueType {
    internal StructureVersion _Version;
    internal ushort _Size;
    private byte _Command;
    private ColorDataBag _Data;
    public ColorDataFormat ColorFormat { get; }
    public ColorDataColorimetry Colorimetry { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataSelectionPolicy> SelectionPolicy { get; }
    public Nullable`1<ColorDataDesktopDepth> DesktopColorDepth { get; }
    public ColorDataV5(ColorDataCommand command);
    public ColorDataV5(ColorDataCommand command, ColorDataFormat colorFormat, ColorDataColorimetry colorimetry, ColorDataDynamicRange dynamicRange, ColorDataDepth colorDepth, ColorDataSelectionPolicy colorSelectionPolicy, ColorDataDesktopDepth desktopColorDepth);
    public sealed virtual ColorDataFormat get_ColorFormat();
    public sealed virtual ColorDataColorimetry get_Colorimetry();
    public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    public sealed virtual Nullable`1<ColorDataSelectionPolicy> get_SelectionPolicy();
    public sealed virtual Nullable`1<ColorDataDesktopDepth> get_DesktopColorDepth();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.CustomDisplay : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Width;
    internal UInt32 _Height;
    internal UInt32 _Depth;
    internal ColorFormat _ColorFormat;
    internal ViewPortF _SourcePartition;
    internal float _XRatio;
    internal float _YRatio;
    internal Timing _Timing;
    internal UInt32 _Flags;
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public UInt32 Depth { get; }
    public ColorFormat ColorFormat { get; }
    public ViewPortF SourcePartition { get; }
    public float XRatio { get; }
    public float YRatio { get; }
    public Timing Timing { get; }
    public bool HardwareModeSetOnly { get; }
    public CustomDisplay(UInt32 width, UInt32 height, UInt32 depth, ColorFormat colorFormat, float xRatio, float yRatio, Timing timing, bool hwModeSetOnly);
    public UInt32 get_Width();
    public UInt32 get_Height();
    public UInt32 get_Depth();
    public ColorFormat get_ColorFormat();
    public ViewPortF get_SourcePartition();
    public float get_XRatio();
    public float get_YRatio();
    public Timing get_Timing();
    public bool get_HardwareModeSetOnly();
}
public class NvAPIWrapper.Native.Display.Structures.DisplayColorData : ValueType {
    private ColorDataColorCoordinate _FirstColorCoordinate;
    private ColorDataColorCoordinate _SecondColorCoordinate;
    private ColorDataColorCoordinate _ThirdColorCoordinate;
    private ColorDataColorCoordinate _WhiteColorCoordinate;
    private ushort _MaximumDesiredContentLuminance;
    private ushort _MinimumDesiredContentLuminance;
    private ushort _MaximumDesiredFrameAverageLightLevel;
    public ColorDataColorCoordinate FirstColorCoordinate { get; }
    public ColorDataColorCoordinate SecondColorCoordinate { get; }
    public ColorDataColorCoordinate ThirdColorCoordinate { get; }
    public ColorDataColorCoordinate WhiteColorCoordinate { get; }
    public float MaximumDesiredContentLuminance { get; }
    public float MaximumDesiredContentFrameAverageLightLevel { get; }
    public float MinimumDesiredContentLuminance { get; }
    public sealed virtual ColorDataColorCoordinate get_FirstColorCoordinate();
    public sealed virtual ColorDataColorCoordinate get_SecondColorCoordinate();
    public sealed virtual ColorDataColorCoordinate get_ThirdColorCoordinate();
    public sealed virtual ColorDataColorCoordinate get_WhiteColorCoordinate();
    public float get_MaximumDesiredContentLuminance();
    public float get_MaximumDesiredContentFrameAverageLightLevel();
    public float get_MinimumDesiredContentLuminance();
}
public class NvAPIWrapper.Native.Display.Structures.DisplayHandle : ValueType {
    internal IntPtr _MemoryAddress;
    public IntPtr MemoryAddress { get; }
    public bool IsNull { get; }
    public static DisplayHandle DefaultHandle { get; }
    public sealed virtual IntPtr get_MemoryAddress();
    public sealed virtual bool get_IsNull();
    public sealed virtual bool Equals(DisplayHandle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DisplayHandle left, DisplayHandle right);
    public static bool op_Inequality(DisplayHandle left, DisplayHandle right);
    public virtual string ToString();
    public static DisplayHandle get_DefaultHandle();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.HDMISupportInfoV1 : ValueType {
    internal StructureVersion _Version;
    private UInt32 _Flags;
    private UInt32 _EDID861ExtensionRevision;
    public bool IsGPUCapableOfHDMIOutput { get; }
    public Nullable`1<bool> IsMonitorCapableOfsYCC601 { get; }
    public bool IsMonitorCapableOfUnderscan { get; }
    public Nullable`1<bool> IsMonitorCapableOfAdobeYCC601 { get; }
    public bool IsMonitorCapableOfBasicAudio { get; }
    public bool IsMonitorCapableOfYCbCr444 { get; }
    public bool IsMonitorCapableOfYCbCr422 { get; }
    public bool IsMonitorCapableOfxvYCC601 { get; }
    public bool IsMonitorCapableOfxvYCC709 { get; }
    public bool IsHDMIMonitor { get; }
    public Nullable`1<bool> IsMonitorCapableOfAdobeRGB { get; }
    public UInt32 EDID861ExtensionRevision { get; }
    public sealed virtual bool get_IsGPUCapableOfHDMIOutput();
    public sealed virtual Nullable`1<bool> get_IsMonitorCapableOfsYCC601();
    public sealed virtual bool get_IsMonitorCapableOfUnderscan();
    public sealed virtual Nullable`1<bool> get_IsMonitorCapableOfAdobeYCC601();
    public sealed virtual bool get_IsMonitorCapableOfBasicAudio();
    public sealed virtual bool get_IsMonitorCapableOfYCbCr444();
    public sealed virtual bool get_IsMonitorCapableOfYCbCr422();
    public sealed virtual bool get_IsMonitorCapableOfxvYCC601();
    public sealed virtual bool get_IsMonitorCapableOfxvYCC709();
    public sealed virtual bool get_IsHDMIMonitor();
    public sealed virtual Nullable`1<bool> get_IsMonitorCapableOfAdobeRGB();
    public sealed virtual UInt32 get_EDID861ExtensionRevision();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.Display.Structures.HDMISupportInfoV2 : ValueType {
    internal StructureVersion _Version;
    private UInt32 _Flags;
    private UInt32 _EDID861ExtensionRevision;
    public bool IsGPUCapableOfHDMIOutput { get; }
    public bool IsMonitorCapableOfUnderscan { get; }
    public bool IsMonitorCapableOfBasicAudio { get; }
    public bool IsMonitorCapableOfYCbCr444 { get; }
    public bool IsMonitorCapableOfYCbCr422 { get; }
    public bool IsMonitorCapableOfxvYCC601 { get; }
    public bool IsMonitorCapableOfxvYCC709 { get; }
    public bool IsHDMIMonitor { get; }
    public Nullable`1<bool> IsMonitorCapableOfsYCC601 { get; }
    public Nullable`1<bool> IsMonitorCapableOfAdobeYCC601 { get; }
    public Nullable`1<bool> IsMonitorCapableOfAdobeRGB { get; }
    public UInt32 EDID861ExtensionRevision { get; }
    public sealed virtual bool get_IsGPUCapableOfHDMIOutput();
    public sealed virtual bool get_IsMonitorCapableOfUnderscan();
    public sealed virtual bool get_IsMonitorCapableOfBasicAudio();
    public sealed virtual bool get_IsMonitorCapableOfYCbCr444();
    public sealed virtual bool get_IsMonitorCapableOfYCbCr422();
    public sealed virtual bool get_IsMonitorCapableOfxvYCC601();
    public sealed virtual bool get_IsMonitorCapableOfxvYCC709();
    public sealed virtual bool get_IsHDMIMonitor();
    public sealed virtual Nullable`1<bool> get_IsMonitorCapableOfsYCC601();
    public sealed virtual Nullable`1<bool> get_IsMonitorCapableOfAdobeYCC601();
    public sealed virtual Nullable`1<bool> get_IsMonitorCapableOfAdobeRGB();
    public sealed virtual UInt32 get_EDID861ExtensionRevision();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.HDRCapabilitiesV1 : ValueType {
    internal StructureVersion _Version;
    private UInt32 _RawReserved;
    private StaticMetadataDescriptorId _StaticMetadataDescriptorId;
    private DisplayColorData _DisplayData;
    public DisplayColorData DisplayData { get; }
    public bool IsST2084EOTFSupported { get; }
    public bool IsTraditionalHDRGammaSupported { get; }
    public bool IsEDRSupported { get; }
    public bool IsDriverDefaultHDRParametersExpanded { get; }
    public bool IsTraditionalSDRGammaSupported { get; }
    internal HDRCapabilitiesV1(bool expandDriverDefaultHDRParameters);
    public DisplayColorData get_DisplayData();
    public bool get_IsST2084EOTFSupported();
    public bool get_IsTraditionalHDRGammaSupported();
    public bool get_IsEDRSupported();
    public bool get_IsDriverDefaultHDRParametersExpanded();
    public bool get_IsTraditionalSDRGammaSupported();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.HDRColorDataV1 : ValueType {
    internal StructureVersion _Version;
    private ColorDataHDRCommand _Command;
    private ColorDataHDRMode _HDRMode;
    private StaticMetadataDescriptorId _StaticMetadataDescriptorId;
    private MasteringDisplayColorData _MasteringDisplayData;
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataFormat> ColorFormat { get; }
    public ColorDataHDRCommand Command { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public ColorDataHDRMode HDRMode { get; }
    public MasteringDisplayColorData MasteringDisplayData { get; }
    public HDRColorDataV1(ColorDataHDRCommand command, ColorDataHDRMode hdrMode, MasteringDisplayColorData masteringDisplayData);
    public HDRColorDataV1(ColorDataHDRCommand command);
    public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    public sealed virtual Nullable`1<ColorDataFormat> get_ColorFormat();
    public ColorDataHDRCommand get_Command();
    public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public sealed virtual ColorDataHDRMode get_HDRMode();
    public sealed virtual MasteringDisplayColorData get_MasteringDisplayData();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.Display.Structures.HDRColorDataV2 : ValueType {
    internal StructureVersion _Version;
    private ColorDataHDRCommand _Command;
    private ColorDataHDRMode _HDRMode;
    private StaticMetadataDescriptorId _StaticMetadataDescriptorId;
    private MasteringDisplayColorData _MasteringDisplayData;
    private ColorDataFormat _ColorFormat;
    private ColorDataDynamicRange _DynamicRange;
    private ColorDataDepth _ColorDepth;
    public ColorDataHDRCommand Command { get; }
    public ColorDataHDRMode HDRMode { get; }
    public MasteringDisplayColorData MasteringDisplayData { get; }
    public Nullable`1<ColorDataFormat> ColorFormat { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public HDRColorDataV2(ColorDataHDRCommand command, ColorDataHDRMode hdrMode, MasteringDisplayColorData masteringDisplayData, ColorDataFormat colorFormat, ColorDataDynamicRange dynamicRange, ColorDataDepth colorDepth);
    public HDRColorDataV2(ColorDataHDRCommand command);
    public ColorDataHDRCommand get_Command();
    public sealed virtual ColorDataHDRMode get_HDRMode();
    public sealed virtual MasteringDisplayColorData get_MasteringDisplayData();
    public sealed virtual Nullable`1<ColorDataFormat> get_ColorFormat();
    public sealed virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public sealed virtual Nullable`1<ColorDataDepth> get_ColorDepth();
}
public class NvAPIWrapper.Native.Display.Structures.InfoFrameAudio : ValueType {
    private UInt32 _WordAt0;
    private UInt32 _WordAt4;
    private UInt32 _WordAt8;
    private byte _ByteAt12;
    public InfoFrameAudioCodec Codec { get; }
    public Nullable`1<InfoFrameAudioExtendedCodec> ExtendedCodec { get; }
    public InfoFrameAudioSampleSize SampleSize { get; }
    public InfoFrameAudioSampleRate SampleRate { get; }
    public InfoFrameAudioChannelCount ChannelCount { get; }
    public InfoFrameAudioChannelAllocation ChannelAllocation { get; }
    public InfoFrameBoolean IsDownMixProhibited { get; }
    public InfoFrameAudioLFEPlaybackLevel LFEPlaybackLevel { get; }
    public InfoFrameAudioLevelShift LevelShift { get; }
    public InfoFrameAudio(InfoFrameAudioCodec codec, InfoFrameAudioExtendedCodec codecExtension, InfoFrameAudioSampleSize sampleSize, InfoFrameAudioSampleRate sampleRate, InfoFrameAudioChannelCount channelCount, InfoFrameAudioChannelAllocation channelAllocation, InfoFrameBoolean isDownMixProhibited, InfoFrameAudioLFEPlaybackLevel lfePlaybackLevel, InfoFrameAudioLevelShift levelShift);
    public InfoFrameAudioCodec get_Codec();
    public Nullable`1<InfoFrameAudioExtendedCodec> get_ExtendedCodec();
    public InfoFrameAudioSampleSize get_SampleSize();
    public InfoFrameAudioSampleRate get_SampleRate();
    public InfoFrameAudioChannelCount get_ChannelCount();
    public InfoFrameAudioChannelAllocation get_ChannelAllocation();
    public InfoFrameBoolean get_IsDownMixProhibited();
    public InfoFrameAudioLFEPlaybackLevel get_LFEPlaybackLevel();
    public InfoFrameAudioLevelShift get_LevelShift();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.InfoFrameData : ValueType {
    internal StructureVersion _Version;
    private ushort _Size;
    private byte _Command;
    private byte _Type;
    private InfoFrameProperty _Property;
    private InfoFrameAudio _Audio;
    private InfoFrameVideo _Video;
    public InfoFrameDataType Type { get; }
    public InfoFrameCommand Command { get; }
    public Nullable`1<InfoFrameAudio> AudioInformation { get; }
    public Nullable`1<InfoFrameVideo> AuxiliaryVideoInformation { get; }
    public Nullable`1<InfoFrameProperty> PropertyInformation { get; }
    public InfoFrameData(InfoFrameCommand command, InfoFrameDataType dataType);
    public InfoFrameData(InfoFrameCommand command, InfoFrameDataType dataType, InfoFrameProperty propertyInformation);
    public InfoFrameData(InfoFrameCommand command, InfoFrameAudio audioInformation);
    public InfoFrameData(InfoFrameCommand command, InfoFrameVideo videoInformation);
    public InfoFrameDataType get_Type();
    public InfoFrameCommand get_Command();
    public Nullable`1<InfoFrameAudio> get_AudioInformation();
    public Nullable`1<InfoFrameVideo> get_AuxiliaryVideoInformation();
    public Nullable`1<InfoFrameProperty> get_PropertyInformation();
}
public class NvAPIWrapper.Native.Display.Structures.InfoFrameProperty : ValueType {
    private UInt32 _Word;
    public InfoFramePropertyMode Mode { get; }
    public InfoFrameBoolean IsBlackListed { get; }
    public byte Version { get; }
    public byte Length { get; }
    public InfoFrameProperty(InfoFramePropertyMode mode, InfoFrameBoolean isBlackListed);
    public InfoFramePropertyMode get_Mode();
    public InfoFrameBoolean get_IsBlackListed();
    public byte get_Version();
    public byte get_Length();
}
public class NvAPIWrapper.Native.Display.Structures.InfoFrameVideo : ValueType {
    private UInt32 _WordAt0;
    private UInt32 _WordAt4;
    private UInt32 _WordAt8;
    private UInt32 _WordAt12;
    private UInt32 _WordAt16;
    private UInt32 _WordAt20;
    public Nullable`1<byte> VideoIdentificationCode { get; }
    public InfoFrameVideoPixelRepetition PixelRepetition { get; }
    public InfoFrameVideoColorFormat ColorFormat { get; }
    public InfoFrameVideoColorimetry Colorimetry { get; }
    public Nullable`1<InfoFrameVideoExtendedColorimetry> ExtendedColorimetry { get; }
    public InfoFrameVideoRGBQuantization RGBQuantization { get; }
    public InfoFrameVideoYCCQuantization YCCQuantization { get; }
    public InfoFrameVideoITC ContentMode { get; }
    public InfoFrameVideoContentType ContentType { get; }
    public InfoFrameVideoScanInfo ScanInfo { get; }
    public InfoFrameBoolean IsActiveFormatInfoPresent { get; }
    public InfoFrameVideoAspectRatioActivePortion ActiveFormatAspectRatio { get; }
    public InfoFrameVideoAspectRatioCodedFrame PictureAspectRatio { get; }
    public InfoFrameVideoNonUniformPictureScaling NonUniformPictureScaling { get; }
    public InfoFrameVideoBarData BarInfo { get; }
    public Nullable`1<UInt32> TopBar { get; }
    public Nullable`1<UInt32> BottomBar { get; }
    public Nullable`1<UInt32> LeftBar { get; }
    public Nullable`1<UInt32> RightBar { get; }
    public InfoFrameVideo(byte videoIdentificationCode, InfoFrameVideoPixelRepetition pixelRepetition, InfoFrameVideoColorFormat colorFormat, InfoFrameVideoColorimetry colorimetry, InfoFrameVideoExtendedColorimetry extendedColorimetry, InfoFrameVideoRGBQuantization rgbQuantization, InfoFrameVideoYCCQuantization yccQuantization, InfoFrameVideoITC contentMode, InfoFrameVideoContentType contentType, InfoFrameVideoScanInfo scanInfo, InfoFrameBoolean isActiveFormatInfoPresent, InfoFrameVideoAspectRatioActivePortion activeFormatAspectRatio, InfoFrameVideoAspectRatioCodedFrame pictureAspectRatio, InfoFrameVideoNonUniformPictureScaling nonUniformPictureScaling, InfoFrameVideoBarData barInfo, Nullable`1<UInt32> topBar, Nullable`1<UInt32> bottomBar, Nullable`1<UInt32> leftBar, Nullable`1<UInt32> rightBar);
    public Nullable`1<byte> get_VideoIdentificationCode();
    public InfoFrameVideoPixelRepetition get_PixelRepetition();
    public InfoFrameVideoColorFormat get_ColorFormat();
    public InfoFrameVideoColorimetry get_Colorimetry();
    public Nullable`1<InfoFrameVideoExtendedColorimetry> get_ExtendedColorimetry();
    public InfoFrameVideoRGBQuantization get_RGBQuantization();
    public InfoFrameVideoYCCQuantization get_YCCQuantization();
    public InfoFrameVideoITC get_ContentMode();
    public InfoFrameVideoContentType get_ContentType();
    public InfoFrameVideoScanInfo get_ScanInfo();
    public InfoFrameBoolean get_IsActiveFormatInfoPresent();
    public InfoFrameVideoAspectRatioActivePortion get_ActiveFormatAspectRatio();
    public InfoFrameVideoAspectRatioCodedFrame get_PictureAspectRatio();
    public InfoFrameVideoNonUniformPictureScaling get_NonUniformPictureScaling();
    public InfoFrameVideoBarData get_BarInfo();
    public Nullable`1<UInt32> get_TopBar();
    public Nullable`1<UInt32> get_BottomBar();
    public Nullable`1<UInt32> get_LeftBar();
    public Nullable`1<UInt32> get_RightBar();
}
public interface NvAPIWrapper.Native.Display.Structures.IScanOutIntensity {
    public Single[] BlendingTexture { get; }
    public UInt32 Height { get; }
    public UInt32 Width { get; }
    public abstract virtual Single[] get_BlendingTexture();
    public abstract virtual UInt32 get_Height();
    public abstract virtual UInt32 get_Width();
}
public class NvAPIWrapper.Native.Display.Structures.LUID : ValueType {
    public UInt32 LowPart;
    public int HighPart;
    public virtual string ToString();
    public sealed virtual bool Equals(LUID other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(LUID left, LUID right);
    public static bool op_Inequality(LUID left, LUID right);
    public virtual int GetHashCode();
}
public class NvAPIWrapper.Native.Display.Structures.MasteringDisplayColorData : ValueType {
    private ColorDataColorCoordinate _FirstColorCoordinate;
    private ColorDataColorCoordinate _SecondColorCoordinate;
    private ColorDataColorCoordinate _ThirdColorCoordinate;
    private ColorDataColorCoordinate _WhiteColorCoordinate;
    private ushort _MaximumMasteringLuminance;
    private ushort _MinimumMasteringLuminance;
    private ushort _MaximumContentLightLevel;
    private ushort _MaximumFrameAverageLightLevel;
    public ColorDataColorCoordinate FirstColorCoordinate { get; }
    public ColorDataColorCoordinate SecondColorCoordinate { get; }
    public ColorDataColorCoordinate ThirdColorCoordinate { get; }
    public ColorDataColorCoordinate WhiteColorCoordinate { get; }
    public float MaximumMasteringLuminance { get; }
    public float MaximumFrameAverageLightLevel { get; }
    public float MaximumContentLightLevel { get; }
    public float MinimumMasteringLuminance { get; }
    public MasteringDisplayColorData(ColorDataColorCoordinate firstColorCoordinate, ColorDataColorCoordinate secondColorCoordinate, ColorDataColorCoordinate thirdColorCoordinate, ColorDataColorCoordinate whiteColorCoordinate, float maximumMasteringLuminance, float minimumMasteringLuminance, float maximumContentLightLevel, float maximumFrameAverageLightLevel);
    public sealed virtual ColorDataColorCoordinate get_FirstColorCoordinate();
    public sealed virtual ColorDataColorCoordinate get_SecondColorCoordinate();
    public sealed virtual ColorDataColorCoordinate get_ThirdColorCoordinate();
    public sealed virtual ColorDataColorCoordinate get_WhiteColorCoordinate();
    public float get_MaximumMasteringLuminance();
    public float get_MaximumFrameAverageLightLevel();
    public float get_MaximumContentLightLevel();
    public float get_MinimumMasteringLuminance();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.MonitorCapabilities : ValueType {
    internal StructureVersion _Version;
    private ushort _Size;
    private MonitorCapabilitiesType _Type;
    private MonitorCapabilitiesConnectorType _ConnectorType;
    private Byte[] _Data;
    public bool IsValid { get; }
    public MonitorCapabilitiesType Type { get; }
    public MonitorCapabilitiesConnectorType ConnectorType { get; }
    public Nullable`1<MonitorVCDBCapabilities> VCDBCapabilities { get; }
    public Nullable`1<MonitorVSDBCapabilities> VSDBCapabilities { get; }
    public MonitorCapabilities(MonitorCapabilitiesType type);
    public bool get_IsValid();
    public MonitorCapabilitiesType get_Type();
    public MonitorCapabilitiesConnectorType get_ConnectorType();
    public Nullable`1<MonitorVCDBCapabilities> get_VCDBCapabilities();
    public Nullable`1<MonitorVSDBCapabilities> get_VSDBCapabilities();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.MonitorColorData : ValueType {
    internal StructureVersion _Version;
    private DisplayPortColorFormat _ColorFormat;
    private DisplayPortColorDepth _ColorDepth;
    public DisplayPortColorFormat ColorFormat { get; }
    public DisplayPortColorDepth ColorDepth { get; }
    public DisplayPortColorFormat get_ColorFormat();
    public DisplayPortColorDepth get_ColorDepth();
}
public class NvAPIWrapper.Native.Display.Structures.MonitorVCDBCapabilities : ValueType {
    private Byte[] _data;
    public bool QuantizationRangeRGB { get; }
    public bool QuantizationRangeYcc { get; }
    public byte ScanInfoConsumerElectronicsVideoFormats { get; }
    public byte ScanInfoInformationTechnologyVideoFormats { get; }
    public byte ScanInfoPreferredVideoFormat { get; }
    internal MonitorVCDBCapabilities(Byte[] data);
    public bool get_QuantizationRangeRGB();
    public bool get_QuantizationRangeYcc();
    public byte get_ScanInfoConsumerElectronicsVideoFormats();
    public byte get_ScanInfoInformationTechnologyVideoFormats();
    public byte get_ScanInfoPreferredVideoFormat();
}
public class NvAPIWrapper.Native.Display.Structures.MonitorVSDBCapabilities : ValueType {
    private Byte[] _data;
    public Nullable`1<byte> AudioLatency { get; }
    public Byte[] HDMI3D { get; }
    public Byte[] HDMIVideoImageCompositors { get; }
    public Nullable`1<byte> InterlacedAudioLatency { get; }
    public Nullable`1<byte> InterlacedVideoLatency { get; }
    public bool IsAISupported { get; }
    public bool IsCinemaContentSupported { get; }
    public bool IsDeepColor30BitsSupported { get; }
    public bool IsDeepColor36BitsSupported { get; }
    public bool IsDeepColor48BitsSupported { get; }
    public bool IsDeepColorYCbCr444Supported { get; }
    public bool IsDualDVIOperationSupported { get; }
    public bool IsGameContentSupported { get; }
    public bool IsGraphicsTextContentSupported { get; }
    public bool IsPhotoContentSupported { get; }
    public byte MaxTMDSClock { get; }
    public MonitorPhysicalAddress PhysicalAddress { get; }
    public Nullable`1<byte> VideoLatency { get; }
    internal MonitorVSDBCapabilities(Byte[] data);
    public Nullable`1<byte> get_AudioLatency();
    public Byte[] get_HDMI3D();
    public Byte[] get_HDMIVideoImageCompositors();
    public Nullable`1<byte> get_InterlacedAudioLatency();
    public Nullable`1<byte> get_InterlacedVideoLatency();
    public bool get_IsAISupported();
    public bool get_IsCinemaContentSupported();
    public bool get_IsDeepColor30BitsSupported();
    public bool get_IsDeepColor36BitsSupported();
    public bool get_IsDeepColor48BitsSupported();
    public bool get_IsDeepColorYCbCr444Supported();
    public bool get_IsDualDVIOperationSupported();
    public bool get_IsGameContentSupported();
    public bool get_IsGraphicsTextContentSupported();
    public bool get_IsPhotoContentSupported();
    public byte get_MaxTMDSClock();
    public MonitorPhysicalAddress get_PhysicalAddress();
    public Nullable`1<byte> get_VideoLatency();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.PathAdvancedTargetInfo : ValueType {
    internal StructureVersion _Version;
    internal Rotate _Rotation;
    internal Scaling _Scaling;
    internal UInt32 _RefreshRateInMillihertz;
    internal UInt32 _RawReserved;
    internal ConnectorType _ConnectorType;
    internal TVFormat _TVFormat;
    internal TimingOverride _TimingOverride;
    internal Timing _Timing;
    public Rotate Rotation { get; }
    public Scaling Scaling { get; }
    public UInt32 RefreshRateInMillihertz { get; }
    public ConnectorType ConnectorType { get; }
    public TVFormat TVFormat { get; }
    public TimingOverride TimingOverride { get; }
    public Timing Timing { get; }
    public bool IsInterlaced { get; private set; }
    public bool IsClonePrimary { get; private set; }
    public bool IsClonePanAndScanTarget { get; private set; }
    public bool DisableVirtualModeSupport { get; private set; }
    public bool IsPreferredUnscaledTarget { get; private set; }
    public PathAdvancedTargetInfo(Rotate rotation, Scaling scale, UInt32 refreshRateInMillihertz, TimingOverride timingOverride, bool isInterlaced, bool isClonePrimary, bool isClonePanAndScanTarget, bool disableVirtualModeSupport, bool isPreferredUnscaledTarget);
    public PathAdvancedTargetInfo(Rotate rotation, Scaling scale, TVFormat tvFormat, ConnectorType connectorType, UInt32 refreshRateInMillihertz, TimingOverride timingOverride, bool isInterlaced, bool isClonePrimary, bool isClonePanAndScanTarget, bool disableVirtualModeSupport, bool isPreferredUnscaledTarget);
    public sealed virtual bool Equals(PathAdvancedTargetInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Rotate get_Rotation();
    public Scaling get_Scaling();
    public UInt32 get_RefreshRateInMillihertz();
    public ConnectorType get_ConnectorType();
    public TVFormat get_TVFormat();
    public TimingOverride get_TimingOverride();
    public Timing get_Timing();
    public bool get_IsInterlaced();
    private void set_IsInterlaced(bool value);
    public bool get_IsClonePrimary();
    private void set_IsClonePrimary(bool value);
    public bool get_IsClonePanAndScanTarget();
    private void set_IsClonePanAndScanTarget(bool value);
    public bool get_DisableVirtualModeSupport();
    private void set_DisableVirtualModeSupport(bool value);
    public bool get_IsPreferredUnscaledTarget();
    private void set_IsPreferredUnscaledTarget(bool value);
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.PathInfoV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _ReservedSourceId;
    internal UInt32 _TargetInfoCount;
    internal ValueTypeArray`1<PathTargetInfoV1> _TargetsInfo;
    internal ValueTypeReference`1<SourceModeInfo> _SourceModeInfo;
    public UInt32 SourceId { get; }
    public IEnumerable`1<IPathTargetInfo> TargetsInfo { get; }
    public SourceModeInfo SourceModeInfo { get; }
    public PathInfoV1(PathTargetInfoV1[] targetsInformation, SourceModeInfo sourceModeInformation, UInt32 sourceId);
    public PathInfoV1(PathTargetInfoV1[] targetsInformation, UInt32 sourceId);
    public PathInfoV1(UInt32 sourceId);
    public PathInfoV1(SourceModeInfo sourceModeInfo, UInt32 sourceId);
    public sealed virtual UInt32 get_SourceId();
    public sealed virtual IEnumerable`1<IPathTargetInfo> get_TargetsInfo();
    public sealed virtual SourceModeInfo get_SourceModeInfo();
    public sealed virtual bool Equals(PathInfoV1 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void Dispose();
    private sealed virtual override void NvAPIWrapper.Native.Interfaces.IAllocatable.Allocate();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.Display.Structures.PathInfoV2 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _SourceId;
    internal UInt32 _TargetInfoCount;
    internal ValueTypeArray`1<PathTargetInfoV2> _TargetsInfo;
    internal ValueTypeReference`1<SourceModeInfo> _SourceModeInfo;
    internal UInt32 _RawReserved;
    internal ValueTypeReference`1<LUID> _OSAdapterLUID;
    public UInt32 SourceId { get; }
    public IEnumerable`1<IPathTargetInfo> TargetsInfo { get; }
    public SourceModeInfo SourceModeInfo { get; }
    public bool IsNonNVIDIAAdapter { get; }
    public Nullable`1<LUID> OSAdapterLUID { get; }
    public PathInfoV2(PathTargetInfoV2[] targetInformations, SourceModeInfo sourceModeInfo, UInt32 sourceId);
    public PathInfoV2(PathTargetInfoV2[] targetInformations, UInt32 sourceId);
    public PathInfoV2(UInt32 sourceId);
    public PathInfoV2(SourceModeInfo sourceModeInfo, UInt32 sourceId);
    public sealed virtual UInt32 get_SourceId();
    public sealed virtual bool Equals(PathInfoV2 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IEnumerable`1<IPathTargetInfo> get_TargetsInfo();
    public sealed virtual SourceModeInfo get_SourceModeInfo();
    public bool get_IsNonNVIDIAAdapter();
    public Nullable`1<LUID> get_OSAdapterLUID();
    public sealed virtual void Dispose();
    private sealed virtual override void NvAPIWrapper.Native.Interfaces.IAllocatable.Allocate();
}
public class NvAPIWrapper.Native.Display.Structures.PathTargetInfoV1 : ValueType {
    internal UInt32 _DisplayId;
    internal ValueTypeReference`1<PathAdvancedTargetInfo> _Details;
    public UInt32 DisplayId { get; }
    public Nullable`1<PathAdvancedTargetInfo> Details { get; }
    public PathTargetInfoV1(UInt32 displayId);
    public PathTargetInfoV1(UInt32 displayId, PathAdvancedTargetInfo details);
    public virtual string ToString();
    public sealed virtual UInt32 get_DisplayId();
    public sealed virtual bool Equals(PathTargetInfoV1 other);
    public sealed virtual bool Equals(PathTargetInfoV2 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Nullable`1<PathAdvancedTargetInfo> get_Details();
    public sealed virtual void Dispose();
    private sealed virtual override void NvAPIWrapper.Native.Interfaces.IAllocatable.Allocate();
}
public class NvAPIWrapper.Native.Display.Structures.PathTargetInfoV2 : ValueType {
    internal UInt32 _DisplayId;
    internal ValueTypeReference`1<PathAdvancedTargetInfo> _Details;
    internal UInt32 _WindowsCCDTargetId;
    public UInt32 DisplayId { get; }
    public Nullable`1<PathAdvancedTargetInfo> Details { get; }
    public UInt32 WindowsCCDTargetId { get; }
    public PathTargetInfoV2(UInt32 displayId);
    public PathTargetInfoV2(UInt32 displayId, UInt32 windowsCCDTargetId);
    public PathTargetInfoV2(UInt32 displayId, PathAdvancedTargetInfo details);
    public PathTargetInfoV2(UInt32 displayId, UInt32 windowsCCDTargetId, PathAdvancedTargetInfo details);
    public sealed virtual UInt32 get_DisplayId();
    public virtual string ToString();
    public sealed virtual Nullable`1<PathAdvancedTargetInfo> get_Details();
    public UInt32 get_WindowsCCDTargetId();
    public sealed virtual bool Equals(PathTargetInfoV2 other);
    public sealed virtual bool Equals(PathTargetInfoV1 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void Dispose();
    private sealed virtual override void NvAPIWrapper.Native.Interfaces.IAllocatable.Allocate();
}
public class NvAPIWrapper.Native.Display.Structures.Position : ValueType {
    internal int _X;
    internal int _Y;
    public int X { get; }
    public int Y { get; }
    public Position(int x, int y);
    public virtual string ToString();
    public sealed virtual bool Equals(Position other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Position left, Position right);
    public static bool op_Inequality(Position left, Position right);
    public int get_X();
    public int get_Y();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.PrivateDisplayDVCInfo : ValueType {
    internal StructureVersion _Version;
    internal int _CurrentLevel;
    internal int _MinimumLevel;
    internal int _MaximumLevel;
    public int CurrentLevel { get; }
    public int MinimumLevel { get; }
    private int NvAPIWrapper.Native.Interfaces.Display.IDisplayDVCInfo.DefaultLevel { get; }
    public int MaximumLevel { get; }
    public sealed virtual int get_CurrentLevel();
    public sealed virtual int get_MinimumLevel();
    private sealed virtual override int NvAPIWrapper.Native.Interfaces.Display.IDisplayDVCInfo.get_DefaultLevel();
    public sealed virtual int get_MaximumLevel();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.PrivateDisplayDVCInfoEx : ValueType {
    internal StructureVersion _Version;
    internal int _CurrentLevel;
    internal int _MinimumLevel;
    internal int _MaximumLevel;
    internal int _DefaultLevel;
    public int CurrentLevel { get; }
    public int MinimumLevel { get; }
    public int MaximumLevel { get; }
    public int DefaultLevel { get; }
    internal PrivateDisplayDVCInfoEx(int currentLevel);
    public sealed virtual int get_CurrentLevel();
    public sealed virtual int get_MinimumLevel();
    public sealed virtual int get_MaximumLevel();
    public sealed virtual int get_DefaultLevel();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.PrivateDisplayHUEInfo : ValueType {
    internal StructureVersion _Version;
    internal int _CurrentAngle;
    internal int _DefaultAngle;
    public int CurrentAngle { get; }
    public int DefaultAngle { get; }
    public int get_CurrentAngle();
    public int get_DefaultAngle();
}
public class NvAPIWrapper.Native.Display.Structures.Resolution : ValueType {
    internal UInt32 _Width;
    internal UInt32 _Height;
    internal UInt32 _ColorDepth;
    public int Width { get; }
    public int Height { get; }
    public int ColorDepth { get; }
    public Resolution(int width, int height, int colorDepth);
    public sealed virtual bool Equals(Resolution other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Resolution left, Resolution right);
    public static bool op_Inequality(Resolution left, Resolution right);
    public virtual string ToString();
    public int get_Width();
    public int get_Height();
    public int get_ColorDepth();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.ScanOutInformationV1 : ValueType {
    internal StructureVersion _Version;
    internal Rectangle _SourceDesktopRectangle;
    internal Rectangle _SourceViewPortRectangle;
    internal Rectangle _TargetViewPortRectangle;
    internal UInt32 _TargetDisplayWidth;
    internal UInt32 _TargetDisplayHeight;
    internal UInt32 _CloneImportance;
    internal Rotate _SourceToTargetRotation;
    public Rectangle SourceDesktopRectangle { get; }
    public Rectangle SourceViewPortRectangle { get; }
    public Rectangle TargetViewPortRectangle { get; }
    public UInt32 TargetDisplayWidth { get; }
    public UInt32 TargetDisplayHeight { get; }
    public UInt32 CloneImportance { get; }
    public Rotate SourceToTargetRotation { get; }
    public Rectangle get_SourceDesktopRectangle();
    public Rectangle get_SourceViewPortRectangle();
    public Rectangle get_TargetViewPortRectangle();
    public UInt32 get_TargetDisplayWidth();
    public UInt32 get_TargetDisplayHeight();
    public UInt32 get_CloneImportance();
    public Rotate get_SourceToTargetRotation();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.ScanOutIntensityStateV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _IsEnabled;
    public bool IsEnabled { get; }
    public bool get_IsEnabled();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.ScanOutIntensityV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Width;
    internal UInt32 _Height;
    internal IntPtr _BlendingTexture;
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public Single[] BlendingTexture { get; }
    public ScanOutIntensityV1(UInt32 width, UInt32 height, Single[] blendingTexture);
    public sealed virtual UInt32 get_Width();
    public sealed virtual UInt32 get_Height();
    public sealed virtual Single[] get_BlendingTexture();
    public sealed virtual void Dispose();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.Display.Structures.ScanOutIntensityV2 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Width;
    internal UInt32 _Height;
    internal IntPtr _BlendingTexture;
    internal IntPtr _OffsetTexture;
    internal UInt32 _OffsetTextureChannels;
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public UInt32 OffsetTextureChannels { get; }
    public Single[] BlendingTexture { get; }
    public Single[] OffsetTexture { get; }
    public ScanOutIntensityV2(UInt32 width, UInt32 height, Single[] blendingTexture, UInt32 offsetTextureChannels, Single[] offsetTexture);
    public sealed virtual UInt32 get_Width();
    public sealed virtual UInt32 get_Height();
    public UInt32 get_OffsetTextureChannels();
    public sealed virtual Single[] get_BlendingTexture();
    public Single[] get_OffsetTexture();
    public sealed virtual void Dispose();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.ScanOutWarpingStateV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _IsEnabled;
    public bool IsEnabled { get; }
    public bool get_IsEnabled();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.ScanOutWarpingV1 : ValueType {
    internal StructureVersion _Version;
    internal IntPtr _Vertices;
    internal WarpingVerticeFormat _VertexFormat;
    internal UInt32 _NumberOfVertices;
    internal IntPtr _TextureRectangle;
    public WarpingVerticeFormat VertexFormat { get; }
    public Rectangle TextureRectangle { get; }
    public Single[] Vertices { get; }
    public ScanOutWarpingV1(WarpingVerticeFormat vertexFormat, Single[] vertices, Rectangle textureRectangle);
    public WarpingVerticeFormat get_VertexFormat();
    public Rectangle get_TextureRectangle();
    public Single[] get_Vertices();
    public sealed virtual void Dispose();
}
public class NvAPIWrapper.Native.Display.Structures.SourceModeInfo : ValueType {
    internal Resolution _Resolution;
    internal ColorFormat _ColorFormat;
    internal Position _Position;
    internal SpanningOrientation _SpanningOrientation;
    internal UInt32 _RawReserved;
    public Resolution Resolution { get; }
    public ColorFormat ColorFormat { get; }
    public Position Position { get; }
    public SpanningOrientation SpanningOrientation { get; }
    public bool IsGDIPrimary { get; private set; }
    public bool IsSLIFocus { get; private set; }
    public SourceModeInfo(Resolution resolution, ColorFormat colorFormat, Position position, SpanningOrientation spanningOrientation, bool isGDIPrimary, bool isSLIFocus);
    public sealed virtual bool Equals(SourceModeInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public Resolution get_Resolution();
    public ColorFormat get_ColorFormat();
    public Position get_Position();
    public SpanningOrientation get_SpanningOrientation();
    public bool get_IsGDIPrimary();
    private void set_IsGDIPrimary(bool value);
    public bool get_IsSLIFocus();
    private void set_IsSLIFocus(bool value);
}
public class NvAPIWrapper.Native.Display.Structures.Timing : ValueType {
    internal ushort _HorizontalVisible;
    internal ushort _HorizontalBorder;
    internal ushort _HorizontalFrontPorch;
    internal ushort _HorizontalSyncWidth;
    internal ushort _HorizontalTotal;
    internal TimingHorizontalSyncPolarity _HorizontalSyncPolarity;
    internal ushort _VerticalVisible;
    internal ushort _VerticalBorder;
    internal ushort _VerticalFrontPorch;
    internal ushort _VerticalSyncWidth;
    internal ushort _VerticalTotal;
    internal TimingVerticalSyncPolarity _VerticalSyncPolarity;
    internal TimingScanMode _ScanMode;
    internal UInt32 _PixelClockIn10KHertz;
    internal TimingExtra _Extra;
    public int HorizontalVisible { get; }
    public int HorizontalBorder { get; }
    public int HorizontalFrontPorch { get; }
    public int HorizontalSyncWidth { get; }
    public int HorizontalTotal { get; }
    public TimingHorizontalSyncPolarity HorizontalSyncPolarity { get; }
    public int VerticalVisible { get; }
    public int VerticalBorder { get; }
    public int VerticalFrontPorch { get; }
    public int VerticalSyncWidth { get; }
    public int VerticalTotal { get; }
    public TimingVerticalSyncPolarity VerticalSyncPolarity { get; }
    public TimingScanMode ScanMode { get; }
    public int PixelClockIn10KHertz { get; }
    public TimingExtra Extra { get; }
    public int HorizontalActive { get; }
    public int VerticalActive { get; }
    public int HorizontalBackPorch { get; }
    public int HorizontalBlanking { get; }
    public int VerticalBackPorch { get; }
    public int VerticalBlanking { get; }
    public Timing(ushort horizontalVisible, ushort verticalVisible, ushort horizontalBorder, ushort verticalBorder, ushort horizontalFrontPorch, ushort verticalFrontPorch, ushort horizontalSyncWidth, ushort verticalSyncWidth, ushort horizontalTotal, ushort verticalTotal, TimingHorizontalSyncPolarity horizontalPolarity, TimingVerticalSyncPolarity verticalPolarity, TimingScanMode scanMode, TimingExtra extra);
    public Timing(ushort horizontalVisible, ushort verticalVisible, ushort horizontalBorder, ushort verticalBorder, ushort horizontalFrontPorch, ushort verticalFrontPorch, ushort horizontalSyncWidth, ushort verticalSyncWidth, ushort horizontalTotal, ushort verticalTotal, TimingHorizontalSyncPolarity horizontalPolarity, TimingVerticalSyncPolarity verticalPolarity, TimingScanMode scanMode, double refreshRateFrequencyInHz, ushort horizontalPixelRepetition);
    public sealed virtual bool Equals(Timing other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Timing left, Timing right);
    public static bool op_Inequality(Timing left, Timing right);
    public int get_HorizontalVisible();
    public int get_HorizontalBorder();
    public int get_HorizontalFrontPorch();
    public int get_HorizontalSyncWidth();
    public int get_HorizontalTotal();
    public TimingHorizontalSyncPolarity get_HorizontalSyncPolarity();
    public int get_VerticalVisible();
    public int get_VerticalBorder();
    public int get_VerticalFrontPorch();
    public int get_VerticalSyncWidth();
    public int get_VerticalTotal();
    public TimingVerticalSyncPolarity get_VerticalSyncPolarity();
    public TimingScanMode get_ScanMode();
    public int get_PixelClockIn10KHertz();
    public TimingExtra get_Extra();
    public int get_HorizontalActive();
    public int get_VerticalActive();
    public int get_HorizontalBackPorch();
    public int get_HorizontalBlanking();
    public int get_VerticalBackPorch();
    public int get_VerticalBlanking();
}
public class NvAPIWrapper.Native.Display.Structures.TimingExtra : ValueType {
    internal UInt32 _HardwareFlags;
    internal ushort _RefreshRate;
    internal UInt32 _FrequencyInMillihertz;
    internal ushort _VerticalAspect;
    internal ushort _HorizontalAspect;
    internal ushort _HorizontalPixelRepetition;
    internal UInt32 _Standard;
    internal string _Name;
    public UInt32 HardwareFlags { get; }
    public int RefreshRate { get; }
    public int FrequencyInMillihertz { get; }
    public int VerticalAspect { get; }
    public int HorizontalAspect { get; }
    public int PixelRepetition { get; }
    public UInt32 Standard { get; }
    public string Name { get; }
    public TimingExtra(double frequencyInHertz, string name, ushort horizontalAspect, ushort verticalAspect, ushort horizontalPixelRepetition, UInt32 hardwareFlags);
    public TimingExtra(UInt32 frequencyInMillihertz, ushort refreshRate, string name, ushort horizontalAspect, ushort verticalAspect, ushort horizontalPixelRepetition, UInt32 hardwareFlags);
    public sealed virtual bool Equals(TimingExtra other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public UInt32 get_HardwareFlags();
    public int get_RefreshRate();
    public int get_FrequencyInMillihertz();
    public int get_VerticalAspect();
    public int get_HorizontalAspect();
    public int get_PixelRepetition();
    public UInt32 get_Standard();
    public string get_Name();
    public virtual string ToString();
    public static bool op_Equality(TimingExtra left, TimingExtra right);
    public static bool op_Inequality(TimingExtra left, TimingExtra right);
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Display.Structures.TimingInput : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Width;
    internal UInt32 _Height;
    internal float _RefreshRate;
    internal TimingFlag _Flags;
    internal TimingOverride _TimingType;
    public UInt32 Width { get; }
    public UInt32 Height { get; }
    public float RefreshRate { get; }
    public bool IsInterlaced { get; }
    public byte Scaling { get; }
    public TimingOverride TimingType { get; }
    public Nullable`1<TVFormat> TVFormat { get; }
    public Nullable`1<byte> CEAId { get; }
    public Nullable`1<byte> PredefinedPSFormatId { get; }
    public TimingInput(UInt32 width, UInt32 height, float refreshRate, TimingOverride timingType, bool isInterlaced, byte scaling);
    public TimingInput(TVFormat tvFormat, bool isInterlaced, byte scaling);
    public TimingInput(byte ceaIdOrPredefinedPSFormatId, TimingOverride timingType, bool isInterlaced, byte scaling);
    public TimingInput(TimingOverride timingType);
    public UInt32 get_Width();
    public UInt32 get_Height();
    public float get_RefreshRate();
    public bool get_IsInterlaced();
    public byte get_Scaling();
    public TimingOverride get_TimingType();
    public Nullable`1<TVFormat> get_TVFormat();
    public Nullable`1<byte> get_CEAId();
    public Nullable`1<byte> get_PredefinedPSFormatId();
}
public class NvAPIWrapper.Native.Display.Structures.UnAttachedDisplayHandle : ValueType {
    internal IntPtr _MemoryAddress;
    public IntPtr MemoryAddress { get; }
    public bool IsNull { get; }
    public sealed virtual bool Equals(UnAttachedDisplayHandle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(UnAttachedDisplayHandle left, UnAttachedDisplayHandle right);
    public static bool op_Inequality(UnAttachedDisplayHandle left, UnAttachedDisplayHandle right);
    public sealed virtual IntPtr get_MemoryAddress();
    public sealed virtual bool get_IsNull();
}
public class NvAPIWrapper.Native.Display.Structures.ViewPortF : ValueType {
    internal float _X;
    internal float _Y;
    internal float _Width;
    internal float _Height;
    public float X { get; }
    public float Y { get; }
    public float Width { get; }
    public float Height { get; }
    public ViewPortF(float x, float y, float width, float height);
    public ViewPortF(RectangleF rect);
    public float get_X();
    public float get_Y();
    public float get_Width();
    public float get_Height();
    public RectangleF ToRectangle();
    public virtual string ToString();
}
public enum NvAPIWrapper.Native.Display.TargetViewMode : Enum {
    public int value__;
    public static TargetViewMode Standard;
    public static TargetViewMode Clone;
    public static TargetViewMode HorizontalSpan;
    public static TargetViewMode VerticalSpan;
    public static TargetViewMode DualView;
    public static TargetViewMode MultiView;
}
public enum NvAPIWrapper.Native.Display.TimingHorizontalSyncPolarity : Enum {
    public byte value__;
    public static TimingHorizontalSyncPolarity Positive;
    public static TimingHorizontalSyncPolarity Negative;
    public static TimingHorizontalSyncPolarity Default;
}
public enum NvAPIWrapper.Native.Display.TimingOverride : Enum {
    public int value__;
    public static TimingOverride Current;
    public static TimingOverride Auto;
    public static TimingOverride EDID;
    public static TimingOverride DMT;
    public static TimingOverride DMTReducedBlanking;
    public static TimingOverride CVT;
    public static TimingOverride CVTReducedBlanking;
    public static TimingOverride GTF;
    public static TimingOverride EIA861;
    public static TimingOverride AnalogTV;
    public static TimingOverride Custom;
    public static TimingOverride Predefined;
    public static TimingOverride PSF;
    public static TimingOverride ASPR;
    public static TimingOverride SDI;
    public static TimingOverride Max;
}
public enum NvAPIWrapper.Native.Display.TimingScanMode : Enum {
    public ushort value__;
    public static TimingScanMode Progressive;
    public static TimingScanMode Interlaced;
    public static TimingScanMode InterlacedWithExtraVerticalBlank;
    public static TimingScanMode InterlacedWithNoExtraVerticalBlank;
}
public enum NvAPIWrapper.Native.Display.TimingVerticalSyncPolarity : Enum {
    public byte value__;
    public static TimingVerticalSyncPolarity Positive;
    public static TimingVerticalSyncPolarity Negative;
    public static TimingVerticalSyncPolarity Default;
}
public enum NvAPIWrapper.Native.Display.TVFormat : Enum {
    public UInt32 value__;
    public static TVFormat None;
    public static TVFormat SD_NTSCM;
    public static TVFormat SD_NTSCJ;
    public static TVFormat SD_PALM;
    public static TVFormat SD_PALBDGH;
    public static TVFormat SD_PAL_N;
    public static TVFormat SD_PAL_NC;
    public static TVFormat SD576i;
    public static TVFormat SD480i;
    public static TVFormat ED480p;
    public static TVFormat ED576p;
    public static TVFormat HD720p;
    public static TVFormat HD1080i;
    public static TVFormat HD1080p;
    public static TVFormat HD720p50;
    public static TVFormat HD1080p24;
    public static TVFormat HD1080i50;
    public static TVFormat HD1080p50;
    public static TVFormat UHD4Kp30;
    public static TVFormat UHD4Kp30_3840;
    public static TVFormat UHD4Kp25;
    public static TVFormat UHD4Kp25_3840;
    public static TVFormat UHD4Kp24;
    public static TVFormat UHD4Kp24_3840;
    public static TVFormat UHD4Kp24_SMPTE;
    public static TVFormat UHD4Kp50_3840;
    public static TVFormat UHD4Kp60_3840;
    public static TVFormat UHD4Kp30_4096;
    public static TVFormat UHD4Kp25_4096;
    public static TVFormat UHD4Kp24_4096;
    public static TVFormat UHD4Kp50_4096;
    public static TVFormat UHD4Kp60_4096;
    public static TVFormat SDOther;
    public static TVFormat EDOther;
    public static TVFormat HDOther;
    public static TVFormat Any;
}
public enum NvAPIWrapper.Native.Display.WarpingVerticeFormat : Enum {
    public UInt32 value__;
    public static WarpingVerticeFormat TriangleStripXYUVRQ;
    public static WarpingVerticeFormat TrianglesXYUVRQ;
}
public static class NvAPIWrapper.Native.DisplayApi : object {
    public static void ColorControl(UInt32 displayId, TColorData& colorData);
    public static void ColorControl(UInt32 displayId, IColorData& colorData);
    public static IColorData ColorControl(UInt32 displayId, IColorData[] colorDatas);
    public static DisplayHandle CreateDisplayFromUnAttachedDisplay(UnAttachedDisplayHandle display);
    public static void DeleteCustomDisplay(UInt32[] displayIds, CustomDisplay customDisplay);
    [IteratorStateMachineAttribute("NvAPIWrapper.Native.DisplayApi/<EnumCustomDisplays>d__5")]
public static IEnumerable`1<CustomDisplay> EnumCustomDisplays(UInt32 displayId);
    public static DisplayHandle[] EnumNvidiaDisplayHandle();
    public static UnAttachedDisplayHandle[] EnumNvidiaUnAttachedDisplayHandle();
    public static OutputId GetAssociatedDisplayOutputId(DisplayHandle display);
    public static DisplayHandle GetAssociatedNvidiaDisplayHandle(string name);
    public static string GetAssociatedNvidiaDisplayName(DisplayHandle display);
    public static UnAttachedDisplayHandle GetAssociatedUnAttachedNvidiaDisplayHandle(string name);
    public static IPathInfo[] GetDisplayConfig();
    public static string GetDisplayDriverBuildTitle(DisplayHandle displayHandle);
    public static IDisplayDriverMemoryInfo GetDisplayDriverMemoryInfo(DisplayHandle displayHandle);
    public static UInt32 GetDisplayIdByDisplayName(string displayName);
    public static PrivateDisplayDVCInfo GetDVCInfo(DisplayHandle display);
    public static PrivateDisplayDVCInfo GetDVCInfo(OutputId displayId);
    public static PrivateDisplayDVCInfoEx GetDVCInfoEx(DisplayHandle display);
    public static PrivateDisplayDVCInfoEx GetDVCInfoEx(OutputId displayId);
    public static IHDMISupportInfo GetHDMISupportInfo(DisplayHandle displayHandle, OutputId outputId);
    public static IHDMISupportInfo GetHDMISupportInfo(UInt32 displayId);
    public static PrivateDisplayHUEInfo GetHUEInfo(DisplayHandle display);
    public static PrivateDisplayHUEInfo GetHUEInfo(OutputId displayId);
    public static Nullable`1<MonitorCapabilities> GetMonitorCapabilities(UInt32 displayId, MonitorCapabilitiesType capabilitiesType);
    public static MonitorColorData[] GetMonitorColorCapabilities(UInt32 displayId);
    public static UInt32 GetGDIPrimaryDisplayId();
    public static HDRCapabilitiesV1 GetHDRCapabilities(UInt32 displayId, bool driverExpandDefaultHDRParameters);
    public static ScanOutCompositionParameterValue GetScanOutCompositionParameter(UInt32 displayId, ScanOutCompositionParameter parameter, Single& container);
    public static ScanOutInformationV1 GetScanOutConfiguration(UInt32 displayId);
    public static void GetScanOutConfiguration(UInt32 displayId, Rectangle& desktopRectangle, Rectangle& scanOutRectangle);
    public static ScanOutIntensityStateV1 GetScanOutIntensityState(UInt32 displayId);
    public static ScanOutWarpingStateV1 GetScanOutWarpingState(UInt32 displayId);
    public static TargetViewMode[] GetSupportedViews(DisplayHandle display);
    public static Timing GetTiming(UInt32 displayId, TimingInput timingInput);
    public static string GetUnAttachedAssociatedDisplayName(UnAttachedDisplayHandle display);
    public static void InfoFrameControl(UInt32 displayId, InfoFrameData& infoFrameData);
    public static void RevertCustomDisplayTrial(UInt32[] displayIds);
    public static void HDRColorControl(UInt32 displayId, THDRColorData& hdrColorData);
    public static void HDRColorControl(UInt32 displayId, IHDRColorData& hdrColorData);
    public static void SaveCustomDisplay(UInt32[] displayIds, bool isThisOutputIdOnly, bool isThisMonitorOnly);
    public static IHDRColorData HDRColorControl(UInt32 displayId, IHDRColorData[] colorDatas);
    public static void SetDisplayConfig(IPathInfo[] pathInfos, DisplayConfigFlags flags);
    public static void SetDVCLevel(DisplayHandle display, int currentLevel);
    public static void SetDVCLevel(OutputId displayId, int currentLevel);
    public static void SetDVCLevelEx(DisplayHandle display, int currentLevel);
    public static void SetDVCLevelEx(OutputId displayId, int currentLevel);
    public static void SetHUEAngle(DisplayHandle display, int currentAngle);
    public static void SetHUEAngle(OutputId displayId, int currentAngle);
    public static void SetRefreshRateOverride(DisplayHandle display, float refreshRate, bool isDeferred);
    public static void SetRefreshRateOverride(OutputId outputMask, float refreshRate, bool isDeferred);
    public static void SetScanOutCompositionParameter(UInt32 displayId, ScanOutCompositionParameter parameter, ScanOutCompositionParameterValue parameterValue, Single& container);
    public static void SetScanOutIntensity(UInt32 displayId, IScanOutIntensity scanOutIntensity, Boolean& isSticky);
    public static void SetScanOutWarping(UInt32 displayId, Nullable`1<ScanOutWarpingV1> scanOutWarping, Int32& maximumNumberOfVertices, Boolean& isSticky);
    public static void TryCustomDisplay(IDictionary`2<UInt32, CustomDisplay> displayIdCustomDisplayPairs);
}
public enum NvAPIWrapper.Native.DRS.DRSSettingLocation : Enum {
    public UInt32 value__;
    public static DRSSettingLocation CurrentProfile;
    public static DRSSettingLocation GlobalProfile;
    public static DRSSettingLocation BaseProfile;
    public static DRSSettingLocation DefaultProfile;
}
public enum NvAPIWrapper.Native.DRS.DRSSettingType : Enum {
    public UInt32 value__;
    public static DRSSettingType Integer;
    public static DRSSettingType Binary;
    public static DRSSettingType String;
    public static DRSSettingType UnicodeString;
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.DRS.Structures.DRSApplicationV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _IsPredefined;
    internal UnicodeString _ApplicationName;
    internal UnicodeString _FriendlyName;
    internal UnicodeString _LauncherName;
    public bool IsPredefined { get; private set; }
    public string ApplicationName { get; private set; }
    public string FriendlyName { get; private set; }
    public string LauncherName { get; private set; }
    public DRSApplicationV1(string applicationName, string friendlyName, string launcherName);
    public sealed virtual bool get_IsPredefined();
    private void set_IsPredefined(bool value);
    public sealed virtual string get_ApplicationName();
    private void set_ApplicationName(string value);
    public sealed virtual string get_FriendlyName();
    private void set_FriendlyName(string value);
    public sealed virtual string get_LauncherName();
    private void set_LauncherName(string value);
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.DRS.Structures.DRSApplicationV2 : ValueType {
    internal static char FileInFolderSeparator;
    internal StructureVersion _Version;
    internal UInt32 _IsPredefined;
    internal UnicodeString _ApplicationName;
    internal UnicodeString _FriendlyName;
    internal UnicodeString _LauncherName;
    internal UnicodeString _FileInFolder;
    public bool IsPredefined { get; private set; }
    public string ApplicationName { get; private set; }
    public string FriendlyName { get; private set; }
    public string LauncherName { get; private set; }
    public String[] FilesInFolder { get; private set; }
    public DRSApplicationV2(string applicationName, string friendlyName, string launcherName, String[] fileInFolders);
    public sealed virtual bool get_IsPredefined();
    private void set_IsPredefined(bool value);
    public sealed virtual string get_ApplicationName();
    private void set_ApplicationName(string value);
    public sealed virtual string get_FriendlyName();
    private void set_FriendlyName(string value);
    public sealed virtual string get_LauncherName();
    private void set_LauncherName(string value);
    public String[] get_FilesInFolder();
    private void set_FilesInFolder(String[] value);
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.DRS.Structures.DRSApplicationV3 : ValueType {
    internal static char FileInFolderSeparator;
    internal StructureVersion _Version;
    internal UInt32 _IsPredefined;
    internal UnicodeString _ApplicationName;
    internal UnicodeString _FriendlyName;
    internal UnicodeString _LauncherName;
    internal UnicodeString _FileInFolder;
    internal UInt32 _Flags;
    public bool IsPredefined { get; private set; }
    public bool IsMetroApplication { get; private set; }
    public bool HasCommandLine { get; }
    public string ApplicationName { get; private set; }
    public string FriendlyName { get; private set; }
    public string LauncherName { get; private set; }
    public String[] FilesInFolder { get; private set; }
    public DRSApplicationV3(string applicationName, string friendlyName, string launcherName, String[] fileInFolders, bool isMetro);
    public sealed virtual bool get_IsPredefined();
    private void set_IsPredefined(bool value);
    public bool get_IsMetroApplication();
    private void set_IsMetroApplication(bool value);
    public bool get_HasCommandLine();
    public sealed virtual string get_ApplicationName();
    private void set_ApplicationName(string value);
    public sealed virtual string get_FriendlyName();
    private void set_FriendlyName(string value);
    public sealed virtual string get_LauncherName();
    private void set_LauncherName(string value);
    public String[] get_FilesInFolder();
    private void set_FilesInFolder(String[] value);
}
[StructureVersionAttribute("4")]
public class NvAPIWrapper.Native.DRS.Structures.DRSApplicationV4 : ValueType {
    internal static char FileInFolderSeparator;
    internal StructureVersion _Version;
    internal UInt32 _IsPredefined;
    internal UnicodeString _ApplicationName;
    internal UnicodeString _FriendlyName;
    internal UnicodeString _LauncherName;
    internal UnicodeString _FileInFolder;
    internal UInt32 _Flags;
    internal UnicodeString _CommandLine;
    public bool IsPredefined { get; private set; }
    public bool IsMetroApplication { get; private set; }
    public bool HasCommandLine { get; private set; }
    public string ApplicationName { get; private set; }
    public string ApplicationCommandLine { get; private set; }
    public string FriendlyName { get; private set; }
    public string LauncherName { get; private set; }
    public String[] FilesInFolder { get; private set; }
    public DRSApplicationV4(string applicationName, string friendlyName, string launcherName, String[] fileInFolders, bool isMetro, string commandLine);
    public sealed virtual bool get_IsPredefined();
    private void set_IsPredefined(bool value);
    public bool get_IsMetroApplication();
    private void set_IsMetroApplication(bool value);
    public bool get_HasCommandLine();
    private void set_HasCommandLine(bool value);
    public sealed virtual string get_ApplicationName();
    private void set_ApplicationName(string value);
    public string get_ApplicationCommandLine();
    private void set_ApplicationCommandLine(string value);
    public sealed virtual string get_FriendlyName();
    private void set_FriendlyName(string value);
    public sealed virtual string get_LauncherName();
    private void set_LauncherName(string value);
    public String[] get_FilesInFolder();
    private void set_FilesInFolder(String[] value);
}
public class NvAPIWrapper.Native.DRS.Structures.DRSGPUSupport : ValueType {
    internal UInt32 _Flags;
    public bool IsGeForceSupported { get; public set; }
    public bool IsQuadroSupported { get; public set; }
    public bool IsNVSSupported { get; public set; }
    public bool get_IsGeForceSupported();
    public void set_IsGeForceSupported(bool value);
    public bool get_IsQuadroSupported();
    public void set_IsQuadroSupported(bool value);
    public bool get_IsNVSSupported();
    public void set_IsNVSSupported(bool value);
    public virtual string ToString();
}
public class NvAPIWrapper.Native.DRS.Structures.DRSProfileHandle : ValueType {
    internal IntPtr _MemoryAddress;
    public IntPtr MemoryAddress { get; }
    public bool IsNull { get; }
    public static DRSProfileHandle DefaultHandle { get; }
    public static DRSProfileHandle DefaultGlobalProfileHandle { get; }
    private DRSProfileHandle(IntPtr memoryAddress);
    public sealed virtual bool Equals(DRSProfileHandle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual IntPtr get_MemoryAddress();
    public sealed virtual bool get_IsNull();
    public static bool op_Equality(DRSProfileHandle left, DRSProfileHandle right);
    public static bool op_Inequality(DRSProfileHandle left, DRSProfileHandle right);
    public static DRSProfileHandle get_DefaultHandle();
    public static DRSProfileHandle get_DefaultGlobalProfileHandle();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.DRS.Structures.DRSProfileV1 : ValueType {
    internal StructureVersion _Version;
    internal UnicodeString _ProfileName;
    internal DRSGPUSupport _GPUSupport;
    internal UInt32 _IsPredefined;
    internal UInt32 _NumberOfApplications;
    internal UInt32 _NumberOfSettings;
    public string Name { get; }
    public DRSGPUSupport GPUSupport { get; public set; }
    public bool IsPredefined { get; }
    public int NumberOfApplications { get; }
    public int NumberOfSettings { get; }
    public DRSProfileV1(string name, DRSGPUSupport gpuSupport);
    public string get_Name();
    public DRSGPUSupport get_GPUSupport();
    public void set_GPUSupport(DRSGPUSupport value);
    public bool get_IsPredefined();
    public int get_NumberOfApplications();
    public int get_NumberOfSettings();
}
public class NvAPIWrapper.Native.DRS.Structures.DRSSessionHandle : ValueType {
    internal IntPtr _MemoryAddress;
    public IntPtr MemoryAddress { get; }
    public bool IsNull { get; }
    public static DRSSessionHandle DefaultHandle { get; }
    public sealed virtual bool Equals(DRSSessionHandle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual IntPtr get_MemoryAddress();
    public sealed virtual bool get_IsNull();
    public static bool op_Equality(DRSSessionHandle left, DRSSessionHandle right);
    public static bool op_Inequality(DRSSessionHandle left, DRSSessionHandle right);
    public static DRSSessionHandle get_DefaultHandle();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.DRS.Structures.DRSSettingV1 : ValueType {
    internal StructureVersion _Version;
    internal UnicodeString _SettingName;
    internal UInt32 _SettingId;
    internal DRSSettingType _SettingType;
    internal DRSSettingLocation _SettingLocation;
    internal UInt32 _IsCurrentPredefined;
    internal UInt32 _IsPredefinedValid;
    internal DRSSettingValue _PredefinedValue;
    internal DRSSettingValue _CurrentValue;
    public string Name { get; }
    public UInt32 Id { get; private set; }
    public DRSSettingType SettingType { get; private set; }
    public DRSSettingLocation SettingLocation { get; }
    public bool IsCurrentValuePredefined { get; private set; }
    public bool IsPredefinedValueValid { get; private set; }
    public object PredefinedValue { get; }
    public object CurrentValue { get; private set; }
    public DRSSettingV1(UInt32 id, DRSSettingType settingType, object value);
    public DRSSettingV1(UInt32 id, string value);
    public DRSSettingV1(UInt32 id, UInt32 value);
    public DRSSettingV1(UInt32 id, Byte[] value);
    public string get_Name();
    public UInt32 get_Id();
    private void set_Id(UInt32 value);
    public DRSSettingType get_SettingType();
    private void set_SettingType(DRSSettingType value);
    public DRSSettingLocation get_SettingLocation();
    public bool get_IsCurrentValuePredefined();
    private void set_IsCurrentValuePredefined(bool value);
    public bool get_IsPredefinedValueValid();
    private void set_IsPredefinedValueValid(bool value);
    public UInt32 GetPredefinedValueAsInteger();
    public Byte[] GetPredefinedValueAsBinary();
    public string GetPredefinedValueAsUnicodeString();
    public object get_PredefinedValue();
    public UInt32 GetCurrentValueAsInteger();
    public Byte[] GetCurrentValueAsBinary();
    public string GetCurrentValueAsUnicodeString();
    public void SetCurrentValueAsInteger(UInt32 value);
    public void SetCurrentValueAsBinary(Byte[] value);
    public void SetCurrentValueAsUnicodeString(string value);
    public object get_CurrentValue();
    private void set_CurrentValue(object value);
}
public class NvAPIWrapper.Native.DRS.Structures.DRSSettingValue : ValueType {
    private static int UnicodeStringLength;
    private static int BinaryDataMax;
    private static int FullStructureSize;
    internal Byte[] _BinaryValue;
    public DRSSettingValue(string value);
    public DRSSettingValue(Byte[] value);
    public DRSSettingValue(UInt32 value);
    public UInt32 AsInteger();
    public Byte[] AsBinary();
    public string AsUnicodeString();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.DRS.Structures.DRSSettingValues : ValueType {
    internal static int MaximumNumberOfValues;
    internal StructureVersion _Version;
    internal UInt32 _NumberOfValues;
    internal DRSSettingType _SettingType;
    internal DRSSettingValue _DefaultValue;
    internal DRSSettingValue[] _Values;
    public DRSSettingType SettingType { get; }
    public Object[] Values { get; }
    public object DefaultValue { get; }
    public DRSSettingType get_SettingType();
    public Object[] get_Values();
    public object get_DefaultValue();
    public UInt32 DefaultValueAsInteger();
    public Byte[] DefaultValueAsBinary();
    public string DefaultValueAsUnicodeString();
    public UInt32[] ValuesAsInteger();
    public Byte[][] ValuesAsBinary();
    public String[] ValuesAsUnicodeString();
}
public static class NvAPIWrapper.Native.DRSApi : object {
    public static IDRSApplication CreateApplication(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, IDRSApplication application);
    public static DRSProfileHandle CreateProfile(DRSSessionHandle sessionHandle, DRSProfileV1 profile);
    public static DRSSessionHandle CreateSession();
    public static void DeleteApplication(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, IDRSApplication application);
    public static void DeleteApplication(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, string applicationName);
    public static void DeleteProfile(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle);
    public static void DeleteProfileSetting(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, UInt32 settingId);
    public static void DestroySession(DRSSessionHandle sessionHandle);
    [IteratorStateMachineAttribute("NvAPIWrapper.Native.DRSApi/<EnumApplications>d__8")]
public static IEnumerable`1<IDRSApplication> EnumApplications(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle);
    public static UInt32[] EnumAvailableSettingIds();
    public static DRSSettingValues EnumAvailableSettingValues(UInt32 settingId);
    [IteratorStateMachineAttribute("NvAPIWrapper.Native.DRSApi/<EnumProfiles>d__11")]
public static IEnumerable`1<DRSProfileHandle> EnumProfiles(DRSSessionHandle sessionHandle);
    [IteratorStateMachineAttribute("NvAPIWrapper.Native.DRSApi/<EnumSettings>d__12")]
public static IEnumerable`1<DRSSettingV1> EnumSettings(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle);
    public static IDRSApplication FindApplicationByName(DRSSessionHandle sessionHandle, string applicationName, Nullable`1& profileHandle);
    public static DRSProfileHandle FindProfileByName(DRSSessionHandle sessionHandle, string profileName);
    public static IDRSApplication GetApplicationInfo(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, string applicationName);
    public static DRSProfileHandle GetBaseProfile(DRSSessionHandle sessionHandle);
    public static DRSProfileHandle GetCurrentGlobalProfile(DRSSessionHandle sessionHandle);
    public static int GetNumberOfProfiles(DRSSessionHandle sessionHandle);
    public static DRSProfileV1 GetProfileInfo(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle);
    public static Nullable`1<DRSSettingV1> GetSetting(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, UInt32 settingId);
    public static UInt32 GetSettingIdFromName(string settingName);
    public static string GetSettingNameFromId(UInt32 settingId);
    public static void LoadSettings(DRSSessionHandle sessionHandle);
    public static void LoadSettings(DRSSessionHandle sessionHandle, string fileName);
    public static void RestoreDefaults(DRSSessionHandle sessionHandle);
    public static void RestoreDefaults(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle);
    public static void RestoreDefaults(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, UInt32 settingId);
    public static void SaveSettings(DRSSessionHandle sessionHandle);
    public static void SaveSettings(DRSSessionHandle sessionHandle, string fileName);
    public static void SetCurrentGlobalProfile(DRSSessionHandle sessionHandle, string profileName);
    public static void SetProfileInfo(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, DRSProfileV1 profile);
    public static void SetSetting(DRSSessionHandle sessionHandle, DRSProfileHandle profileHandle, DRSSettingV1 setting);
}
public class NvAPIWrapper.Native.Exceptions.NVIDIAApiException : Exception {
    [CompilerGeneratedAttribute]
private Status <Status>k__BackingField;
    public string Message { get; }
    public Status Status { get; }
    internal NVIDIAApiException(Status status);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public Status get_Status();
}
public class NvAPIWrapper.Native.Exceptions.NVIDIANotSupportedException : NotSupportedException {
    internal NVIDIANotSupportedException(string message);
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.General.ChipsetInfoFlag : Enum {
    public int value__;
    public static ChipsetInfoFlag None;
    public static ChipsetInfoFlag Hybrid;
}
public enum NvAPIWrapper.Native.General.Status : Enum {
    public int value__;
    public static Status Ok;
    public static Status Error;
    public static Status LibraryNotFound;
    public static Status NoImplementation;
    public static Status ApiNotInitialized;
    public static Status InvalidArgument;
    public static Status NvidiaDeviceNotFound;
    public static Status EndEnumeration;
    public static Status InvalidHandle;
    public static Status IncompatibleStructureVersion;
    public static Status HandleInvalidated;
    public static Status OpenGLContextNotCurrent;
    public static Status InvalidPointer;
    public static Status NoGLExpert;
    public static Status InstrumentationDisabled;
    public static Status ExpectedLogicalGPUHandle;
    public static Status ExpectedPhysicalGPUHandle;
    public static Status ExpectedDisplayHandle;
    public static Status InvalidCombination;
    public static Status NotSupported;
    public static Status PortIdNotFound;
    public static Status ExpectedUnattachedDisplayHandle;
    public static Status InvalidPerformanceLevel;
    public static Status DeviceBusy;
    public static Status NvPersistFileNotFound;
    public static Status PersistDataNotFound;
    public static Status ExpectedTVDisplay;
    public static Status ExpectedTVDisplayOnDConnector;
    public static Status NoActiveSLITopology;
    public static Status SLIRenderingModeNotAllowed;
    public static Status ExpectedDigitalFlatPanel;
    public static Status ArgumentExceedMaxSize;
    public static Status DeviceSwitchingNotAllowed;
    public static Status TestingClocksNotSupported;
    public static Status UnknownUnderScanConfig;
    public static Status TimeoutReConfiguringGPUTopology;
    public static Status DataNotFound;
    public static Status ExpectedAnalogDisplay;
    public static Status NoVideoLink;
    public static Status RequiresReboot;
    public static Status InvalidHybridMode;
    public static Status MixedTargetTypes;
    public static Status SYSWOW64NotSupported;
    public static Status ImplicitSetGPUTopologyChangeNotAllowed;
    public static Status RequestUserToCloseNonMigratableApps;
    public static Status OutOfMemory;
    public static Status WasStillDrawing;
    public static Status FileNotFound;
    public static Status TooManyUniqueStateObjects;
    public static Status InvalidCall;
    public static Status D3D101LibraryNotFound;
    public static Status FunctionNotFound;
    public static Status InvalidUserPrivilege;
    public static Status ExpectedNonPrimaryDisplayHandle;
    public static Status ExpectedComputeGPUHandle;
    public static Status StereoNotInitialized;
    public static Status StereoRegistryAccessFailed;
    public static Status StereoRegistryProfileTypeNotSupported;
    public static Status StereoRegistryValueNotSupported;
    public static Status StereoNotEnabled;
    public static Status StereoNotTurnedOn;
    public static Status StereoInvalidDeviceInterface;
    public static Status StereoParameterOutOfRange;
    public static Status StereoFrustumAdjustModeNotSupported;
    public static Status TopologyNotPossible;
    public static Status ModeChangeFailed;
    public static Status D3D11LibraryNotFound;
    public static Status InvalidAddress;
    public static Status StringTooSmall;
    public static Status MatchingDeviceNotFound;
    public static Status DriverRunning;
    public static Status DriverNotRunning;
    public static Status ErrorDriverReloadRequired;
    public static Status SetNotAllowed;
    public static Status AdvancedDisplayTopologyRequired;
    public static Status SettingNotFound;
    public static Status SettingSizeTooLarge;
    public static Status TooManySettingsInProfile;
    public static Status ProfileNotFound;
    public static Status ProfileNameInUse;
    public static Status ProfileNameEmpty;
    public static Status ExecutableNotFound;
    public static Status ExecutableAlreadyInUse;
    public static Status DataTypeMismatch;
    public static Status ProfileRemoved;
    public static Status UnregisteredResource;
    public static Status IdOutOfRange;
    public static Status DisplayConfigValidationFailed;
    public static Status DPMSTChanged;
    public static Status InsufficientBuffer;
    public static Status AccessDenied;
    public static Status MosaicNotActive;
    public static Status ShareResourceRelocated;
    public static Status RequestUserToDisableDWM;
    public static Status D3DDeviceLost;
    public static Status InvalidConfiguration;
    public static Status StereoHandshakeNotDone;
    public static Status ExecutablePathIsAmbiguous;
    public static Status DefaultStereoProfileIsNotDefined;
    public static Status DefaultStereoProfileDoesNotExist;
    public static Status ClusterAlreadyExists;
    public static Status DPMSTDisplayIdExpected;
    public static Status InvalidDisplayId;
    public static Status StreamIsOutOfSync;
    public static Status IncompatibleAudioDriver;
    public static Status ValueAlreadySet;
    public static Status Timeout;
    public static Status GPUWorkstationFeatureIncomplete;
    public static Status StereoInitActivationNotDone;
    public static Status SyncNotActive;
    public static Status SyncMasterNotFound;
    public static Status InvalidSyncTopology;
    public static Status ECIDSignAlgoUnsupported;
    public static Status ECIDKeyVerificationFailed;
    public static Status FirmwareOutOfDate;
    public static Status FirmwareRevisionNotSupported;
    public static Status LicenseCallerAuthenticationFailed;
    public static Status D3DDeviceNotRegistered;
    public static Status ResourceNotAcquired;
    public static Status TimingNotSupported;
    public static Status HDCPEncryptionFailed;
    public static Status PCLKLimitationFailed;
    public static Status NoConnectorFound;
    public static Status HDCPDisabled;
    public static Status ApiInUse;
    public static Status NVIDIADisplayNotFound;
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.General.Structures.ChipsetInfoV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _VendorId;
    internal UInt32 _DeviceId;
    internal ShortString _VendorName;
    internal ShortString _ChipsetName;
    public int VendorId { get; }
    public int DeviceId { get; }
    public string VendorName { get; }
    public string ChipsetName { get; }
    public ChipsetInfoFlag Flags { get; }
    public sealed virtual bool Equals(ChipsetInfoV1 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int get_VendorId();
    public sealed virtual int get_DeviceId();
    public sealed virtual string get_VendorName();
    public sealed virtual string get_ChipsetName();
    public sealed virtual ChipsetInfoFlag get_Flags();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.General.Structures.ChipsetInfoV2 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _VendorId;
    internal UInt32 _DeviceId;
    internal ShortString _VendorName;
    internal ShortString _ChipsetName;
    internal ChipsetInfoFlag _Flags;
    public int VendorId { get; }
    public int DeviceId { get; }
    public string VendorName { get; }
    public string ChipsetName { get; }
    public ChipsetInfoFlag Flags { get; }
    public sealed virtual bool Equals(ChipsetInfoV2 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int get_VendorId();
    public sealed virtual int get_DeviceId();
    public sealed virtual string get_VendorName();
    public sealed virtual string get_ChipsetName();
    public sealed virtual ChipsetInfoFlag get_Flags();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.General.Structures.ChipsetInfoV3 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _VendorId;
    internal UInt32 _DeviceId;
    internal ShortString _VendorName;
    internal ShortString _ChipsetName;
    internal ChipsetInfoFlag _Flags;
    internal UInt32 _SubSystemVendorId;
    internal UInt32 _SubSystemDeviceId;
    internal ShortString _SubSystemVendorName;
    public int VendorId { get; }
    public int DeviceId { get; }
    public string VendorName { get; }
    public string ChipsetName { get; }
    public ChipsetInfoFlag Flags { get; }
    public int SubSystemVendorId { get; }
    public int SubSystemDeviceId { get; }
    public string SubSystemVendorName { get; }
    public sealed virtual bool Equals(ChipsetInfoV3 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int get_VendorId();
    public sealed virtual int get_DeviceId();
    public sealed virtual string get_VendorName();
    public sealed virtual string get_ChipsetName();
    public sealed virtual ChipsetInfoFlag get_Flags();
    public int get_SubSystemVendorId();
    public int get_SubSystemDeviceId();
    public string get_SubSystemVendorName();
}
[StructureVersionAttribute("4")]
public class NvAPIWrapper.Native.General.Structures.ChipsetInfoV4 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _VendorId;
    internal UInt32 _DeviceId;
    internal ShortString _VendorName;
    internal ShortString _ChipsetName;
    internal ChipsetInfoFlag _Flags;
    internal UInt32 _SubSystemVendorId;
    internal UInt32 _SubSystemDeviceId;
    internal ShortString _SubSystemVendorName;
    internal UInt32 _HostBridgeVendorId;
    internal UInt32 _HostBridgeDeviceId;
    internal UInt32 _HostBridgeSubSystemVendorId;
    internal UInt32 _HostBridgeSubSystemDeviceId;
    public int VendorId { get; }
    public int DeviceId { get; }
    public string VendorName { get; }
    public string ChipsetName { get; }
    public ChipsetInfoFlag Flags { get; }
    public int SubSystemVendorId { get; }
    public int SubSystemDeviceId { get; }
    public string SubSystemVendorName { get; }
    public int HostBridgeVendorId { get; }
    public int HostBridgeDeviceId { get; }
    public int HostBridgeSubSystemVendorId { get; }
    public int HostBridgeSubSystemDeviceId { get; }
    public sealed virtual bool Equals(ChipsetInfoV4 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int get_VendorId();
    public sealed virtual int get_DeviceId();
    public sealed virtual string get_VendorName();
    public sealed virtual string get_ChipsetName();
    public sealed virtual ChipsetInfoFlag get_Flags();
    public int get_SubSystemVendorId();
    public int get_SubSystemDeviceId();
    public string get_SubSystemVendorName();
    public int get_HostBridgeVendorId();
    public int get_HostBridgeDeviceId();
    public int get_HostBridgeSubSystemVendorId();
    public int get_HostBridgeSubSystemDeviceId();
}
internal class NvAPIWrapper.Native.General.Structures.GenericString : ValueType {
    public static int GenericStringLength;
    private string _Value;
    public string Value { get; }
    public GenericString(string value);
    public string get_Value();
    public virtual string ToString();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.General.Structures.LidDockParameters : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _CurrentLIDState;
    internal UInt32 _CurrentDockState;
    internal UInt32 _CurrentLIDPolicy;
    internal UInt32 _CurrentDockPolicy;
    internal UInt32 _ForcedLIDMechanismPresent;
    internal UInt32 _ForcedDockMechanismPresent;
    public UInt32 CurrentLidState { get; }
    public UInt32 CurrentDockState { get; }
    public UInt32 CurrentLidPolicy { get; }
    public UInt32 CurrentDockPolicy { get; }
    public UInt32 ForcedLidMechanismPresent { get; }
    public UInt32 ForcedDockMechanismPresent { get; }
    public sealed virtual bool Equals(LidDockParameters other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public UInt32 get_CurrentLidState();
    public UInt32 get_CurrentDockState();
    public UInt32 get_CurrentLidPolicy();
    public UInt32 get_CurrentDockPolicy();
    public UInt32 get_ForcedLidMechanismPresent();
    public UInt32 get_ForcedDockMechanismPresent();
}
internal class NvAPIWrapper.Native.General.Structures.LongString : ValueType {
    public static int LongStringLength;
    private string _Value;
    public string Value { get; }
    public LongString(string value);
    public string get_Value();
    public virtual string ToString();
}
public class NvAPIWrapper.Native.General.Structures.Rectangle : ValueType {
    internal int _X;
    internal int _Y;
    internal int _Width;
    internal int _Height;
    public int X { get; }
    public int Y { get; }
    public int Width { get; }
    public int Height { get; }
    public int X2 { get; }
    public int Y2 { get; }
    public Rectangle(int x, int y, int width, int height);
    public int get_X();
    public int get_Y();
    public int get_Width();
    public int get_Height();
    public int get_X2();
    public int get_Y2();
}
internal class NvAPIWrapper.Native.General.Structures.ShortString : ValueType {
    public static int ShortStringLength;
    private string _Value;
    public string Value { get; }
    public ShortString(string value);
    public string get_Value();
    public virtual string ToString();
}
internal class NvAPIWrapper.Native.General.Structures.StructureVersion : ValueType {
    private UInt32 _version;
    public int VersionNumber { get; }
    public int StructureSize { get; }
    public StructureVersion(int version, Type structureType);
    public int get_VersionNumber();
    public int get_StructureSize();
    public virtual string ToString();
}
internal class NvAPIWrapper.Native.General.Structures.UnicodeString : ValueType {
    public static int UnicodeStringLength;
    private string _Value;
    public string Value { get; }
    public UnicodeString(string value);
    public string get_Value();
    public virtual string ToString();
}
public static class NvAPIWrapper.Native.GeneralApi : object {
    public static IChipsetInfo GetChipsetInfo();
    public static UInt32 GetDriverAndBranchVersion(String& branchVersion);
    public static string GetErrorMessage(Status statusCode);
    public static string GetInterfaceVersionString();
    public static LidDockParameters GetLidAndDockInfo();
    public static void Initialize();
    public static void RestartDisplayDriver();
    public static void Unload();
}
public enum NvAPIWrapper.Native.GPU.ClockLockMode : Enum {
    public UInt32 value__;
    public static ClockLockMode None;
    public static ClockLockMode Manual;
}
public enum NvAPIWrapper.Native.GPU.ClockType : Enum {
    public UInt32 value__;
    public static ClockType CurrentClock;
    public static ClockType BaseClock;
    public static ClockType BoostClock;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.ConnectedIdsFlag : Enum {
    public UInt32 value__;
    public static ConnectedIdsFlag None;
    public static ConnectedIdsFlag UnCached;
    public static ConnectedIdsFlag SLI;
    public static ConnectedIdsFlag LidState;
    public static ConnectedIdsFlag Fake;
    public static ConnectedIdsFlag ExcludeList;
}
public enum NvAPIWrapper.Native.GPU.ConnectorType : Enum {
    public UInt32 value__;
    public static ConnectorType VGA15Pin;
    public static ConnectorType TV_Composite;
    public static ConnectorType TV_SVideo;
    public static ConnectorType TV_HDTVComponent;
    public static ConnectorType TV_SCART;
    public static ConnectorType TV_CompositeSCARTOnEIAJ4120;
    public static ConnectorType TV_HDTV_EIAJ4120;
    public static ConnectorType PC_POD_HDTV_YPbPr;
    public static ConnectorType PC_POD_SVideo;
    public static ConnectorType PC_POD_Composite;
    public static ConnectorType DVI_I_TV_SVideo;
    public static ConnectorType DVI_I_TV_COMPOSITE;
    public static ConnectorType DVI_I;
    public static ConnectorType DVI_D;
    public static ConnectorType ADC;
    public static ConnectorType LFH_DVI_I1;
    public static ConnectorType LFH_DVI_I2;
    public static ConnectorType SPWG;
    public static ConnectorType OEM;
    public static ConnectorType DisplayPortExternal;
    public static ConnectorType DisplayPortInternal;
    public static ConnectorType DisplayPortMiniExternal;
    public static ConnectorType HDMI_Analog;
    public static ConnectorType HDMI_CMini;
    public static ConnectorType LFHDisplayPort1;
    public static ConnectorType LFHDisplayPort2;
    public static ConnectorType VirtualWFD;
    public static ConnectorType Unknown;
}
public enum NvAPIWrapper.Native.GPU.CoolerController : Enum {
    public UInt32 value__;
    public static CoolerController None;
    public static CoolerController ADI;
    public static CoolerController Internal;
}
public enum NvAPIWrapper.Native.GPU.CoolerControlMode : Enum {
    public UInt32 value__;
    public static CoolerControlMode None;
    public static CoolerControlMode Toggle;
    public static CoolerControlMode Variable;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.CoolerPolicy : Enum {
    public UInt32 value__;
    public static CoolerPolicy None;
    public static CoolerPolicy Manual;
    public static CoolerPolicy Performance;
    public static CoolerPolicy TemperatureDiscrete;
    public static CoolerPolicy TemperatureContinuous;
    public static CoolerPolicy Silent;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.CoolerTarget : Enum {
    public UInt32 value__;
    public static CoolerTarget None;
    public static CoolerTarget GPU;
    public static CoolerTarget Memory;
    public static CoolerTarget PowerSupply;
    public static CoolerTarget All;
}
public enum NvAPIWrapper.Native.GPU.CoolerType : Enum {
    public UInt32 value__;
    public static CoolerType None;
    public static CoolerType Fan;
    public static CoolerType Water;
    public static CoolerType LiquidNitrogen;
}
public enum NvAPIWrapper.Native.GPU.ECCConfiguration : Enum {
    public UInt32 value__;
    public static ECCConfiguration NotSupported;
    public static ECCConfiguration Deferred;
    public static ECCConfiguration Immediate;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.FanCoolersControlMode : Enum {
    public UInt32 value__;
    public static FanCoolersControlMode Auto;
    public static FanCoolersControlMode Manual;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.GetPerformanceStatesInfoFlags : Enum {
    public int value__;
    public static GetPerformanceStatesInfoFlags Current;
    public static GetPerformanceStatesInfoFlags Default;
    public static GetPerformanceStatesInfoFlags Maximum;
    public static GetPerformanceStatesInfoFlags Minimum;
}
public enum NvAPIWrapper.Native.GPU.GPUBusType : Enum {
    public int value__;
    public static GPUBusType Undefined;
    public static GPUBusType PCI;
    public static GPUBusType AGP;
    public static GPUBusType PCIExpress;
    public static GPUBusType FPCI;
    public static GPUBusType AXI;
}
public enum NvAPIWrapper.Native.GPU.GPUFoundry : Enum {
    public UInt32 value__;
    public static GPUFoundry Unknown;
    public static GPUFoundry TSMC;
    public static GPUFoundry UMC;
    public static GPUFoundry IBM;
    public static GPUFoundry SMIC;
    public static GPUFoundry CSM;
    public static GPUFoundry Toshiba;
}
public enum NvAPIWrapper.Native.GPU.GPUMemoryMaker : Enum {
    public UInt32 value__;
    public static GPUMemoryMaker Unknown;
    public static GPUMemoryMaker Samsung;
    public static GPUMemoryMaker Qimonda;
    public static GPUMemoryMaker Elpida;
    public static GPUMemoryMaker Etron;
    public static GPUMemoryMaker Nanya;
    public static GPUMemoryMaker Hynix;
    public static GPUMemoryMaker Mosel;
    public static GPUMemoryMaker Winbond;
    public static GPUMemoryMaker Elite;
    public static GPUMemoryMaker Micron;
}
public enum NvAPIWrapper.Native.GPU.GPUMemoryType : Enum {
    public UInt32 value__;
    public static GPUMemoryType Unknown;
    public static GPUMemoryType SDRAM;
    public static GPUMemoryType DDR1;
    public static GPUMemoryType DDR2;
    public static GPUMemoryType GDDR2;
    public static GPUMemoryType GDDR3;
    public static GPUMemoryType GDDR4;
    public static GPUMemoryType DDR3;
    public static GPUMemoryType GDDR5;
    public static GPUMemoryType LPDDR2;
    public static GPUMemoryType GDDR5X;
}
public enum NvAPIWrapper.Native.GPU.GPUType : Enum {
    public int value__;
    public static GPUType Unknown;
    public static GPUType Integrated;
    public static GPUType Discrete;
}
public enum NvAPIWrapper.Native.GPU.I2CSpeed : Enum {
    public UInt32 value__;
    public static I2CSpeed Default;
    public static I2CSpeed I2C3KHz;
    public static I2CSpeed I2C10KHz;
    public static I2CSpeed I2C33KHz;
    public static I2CSpeed I2C100KHz;
    public static I2CSpeed I2C200KHz;
    public static I2CSpeed I2C400KHz;
}
public enum NvAPIWrapper.Native.GPU.IlluminationAttribute : Enum {
    public UInt32 value__;
    public static IlluminationAttribute LogoBrightness;
    public static IlluminationAttribute SLIBrightness;
}
public enum NvAPIWrapper.Native.GPU.IlluminationDeviceType : Enum {
    public UInt32 value__;
    public static IlluminationDeviceType Invalid;
    public static IlluminationDeviceType MCUV10;
}
public enum NvAPIWrapper.Native.GPU.IlluminationPiecewiseLinearCycleType : Enum {
    public UInt32 value__;
    public static IlluminationPiecewiseLinearCycleType HalfHalf;
    public static IlluminationPiecewiseLinearCycleType FullHalf;
    public static IlluminationPiecewiseLinearCycleType FullRepeat;
    public static IlluminationPiecewiseLinearCycleType Invalid;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.IlluminationZoneControlMode : Enum {
    public UInt32 value__;
    public static IlluminationZoneControlMode ManualRGB;
    public static IlluminationZoneControlMode PiecewiseLinearRGB;
    public static IlluminationZoneControlMode Invalid;
}
public enum NvAPIWrapper.Native.GPU.IlluminationZoneControlValuesType : Enum {
    public int value__;
    public static IlluminationZoneControlValuesType CurrentlyActive;
    public static IlluminationZoneControlValuesType Default;
}
public enum NvAPIWrapper.Native.GPU.IlluminationZoneLocation : Enum {
    public UInt32 value__;
    public static IlluminationZoneLocation GPUTop;
    public static IlluminationZoneLocation SLITop;
    public static IlluminationZoneLocation Invalid;
}
public enum NvAPIWrapper.Native.GPU.IlluminationZoneType : Enum {
    public UInt32 value__;
    public static IlluminationZoneType Invalid;
    public static IlluminationZoneType RGB;
    public static IlluminationZoneType FixedColor;
}
public enum NvAPIWrapper.Native.GPU.MonitorConnectionType : Enum {
    public int value__;
    public static MonitorConnectionType Uninitialized;
    public static MonitorConnectionType VGA;
    public static MonitorConnectionType Component;
    public static MonitorConnectionType SVideo;
    public static MonitorConnectionType HDMI;
    public static MonitorConnectionType DVI;
    public static MonitorConnectionType LVDS;
    public static MonitorConnectionType DisplayPort;
    public static MonitorConnectionType Composite;
    public static MonitorConnectionType Unknown;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.OutputId : Enum {
    public UInt32 value__;
    public static OutputId Invalid;
    public static OutputId Output1;
    public static OutputId Output2;
    public static OutputId Output3;
    public static OutputId Output4;
    public static OutputId Output5;
    public static OutputId Output6;
    public static OutputId Output7;
    public static OutputId Output8;
    public static OutputId Output9;
    public static OutputId Output10;
    public static OutputId Output11;
    public static OutputId Output12;
    public static OutputId Output13;
    public static OutputId Output14;
    public static OutputId Output15;
    public static OutputId Output16;
    public static OutputId Output17;
    public static OutputId Output18;
    public static OutputId Output19;
    public static OutputId Output20;
    public static OutputId Output21;
    public static OutputId Output22;
    public static OutputId Output23;
    public static OutputId Output24;
    public static OutputId Output25;
    public static OutputId Output26;
    public static OutputId Output27;
    public static OutputId Output28;
    public static OutputId Output29;
    public static OutputId Output30;
    public static OutputId Output31;
    public static OutputId Output32;
}
public enum NvAPIWrapper.Native.GPU.OutputType : Enum {
    public UInt32 value__;
    public static OutputType Unknown;
    public static OutputType CRT;
    public static OutputType DFP;
    public static OutputType TV;
}
public enum NvAPIWrapper.Native.GPU.PCIeGeneration : Enum {
    public UInt32 value__;
    public static PCIeGeneration PCIe1;
    public static PCIeGeneration PCIe1Minor1;
    public static PCIeGeneration PCIe2;
    public static PCIeGeneration PCIe3;
}
public enum NvAPIWrapper.Native.GPU.PerformanceDecreaseReason : Enum {
    public UInt32 value__;
    public static PerformanceDecreaseReason None;
    public static PerformanceDecreaseReason ThermalProtection;
    public static PerformanceDecreaseReason PowerControl;
    public static PerformanceDecreaseReason AC_BATT;
    public static PerformanceDecreaseReason ApiTriggered;
    public static PerformanceDecreaseReason InsufficientPower;
    public static PerformanceDecreaseReason Unknown;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.PerformanceLimit : Enum {
    public UInt32 value__;
    public static PerformanceLimit None;
    public static PerformanceLimit PowerLimit;
    public static PerformanceLimit TemperatureLimit;
    public static PerformanceLimit VoltageLimit;
    public static PerformanceLimit Unknown8;
    public static PerformanceLimit NoLoadLimit;
}
public enum NvAPIWrapper.Native.GPU.PerformanceStateId : Enum {
    public UInt32 value__;
    public static PerformanceStateId P0_3DPerformance;
    public static PerformanceStateId P1_3DPerformance;
    public static PerformanceStateId P2_Balanced;
    public static PerformanceStateId P3_Balanced;
    public static PerformanceStateId P4;
    public static PerformanceStateId P5;
    public static PerformanceStateId P6;
    public static PerformanceStateId P7;
    public static PerformanceStateId P8_HDVideoPlayback;
    public static PerformanceStateId P9;
    public static PerformanceStateId P10_DVDPlayback;
    public static PerformanceStateId P11;
    public static PerformanceStateId P12_Idle;
    public static PerformanceStateId P13;
    public static PerformanceStateId P14;
    public static PerformanceStateId P15;
    public static PerformanceStateId Undefined;
    public static PerformanceStateId All;
}
public enum NvAPIWrapper.Native.GPU.PerformanceStates20ClockType : Enum {
    public int value__;
    public static PerformanceStates20ClockType Single;
    public static PerformanceStates20ClockType Range;
}
public enum NvAPIWrapper.Native.GPU.PerformanceVoltageDomain : Enum {
    public UInt32 value__;
    public static PerformanceVoltageDomain Core;
    public static PerformanceVoltageDomain Undefined;
}
public enum NvAPIWrapper.Native.GPU.PowerTopologyDomain : Enum {
    public UInt32 value__;
    public static PowerTopologyDomain GPU;
    public static PowerTopologyDomain Board;
}
public enum NvAPIWrapper.Native.GPU.PublicClockDomain : Enum {
    public int value__;
    public static PublicClockDomain Undefined;
    public static PublicClockDomain Graphics;
    public static PublicClockDomain Memory;
    public static PublicClockDomain Processor;
    public static PublicClockDomain Video;
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.BoardInfo : ValueType {
    internal StructureVersion _Version;
    internal Byte[] _SerialNumber;
    public Byte[] SerialNumber { get; }
    public Byte[] get_SerialNumber();
    public sealed virtual bool Equals(BoardInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(BoardInfo left, BoardInfo right);
    public static bool op_Inequality(BoardInfo left, BoardInfo right);
}
public class NvAPIWrapper.Native.GPU.Structures.ClockDomainInfo : ValueType {
    internal UInt32 _IsPresent;
    internal UInt32 _Frequency;
    public bool IsPresent { get; }
    public UInt32 Frequency { get; }
    public bool get_IsPresent();
    public UInt32 get_Frequency();
    public virtual string ToString();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.ClockFrequenciesV1 : ValueType {
    internal static int MaxClocksPerGPU;
    internal StructureVersion _Version;
    internal UInt32 _Reserved;
    internal ClockDomainInfo[] _Clocks;
    public IReadOnlyDictionary`2<PublicClockDomain, ClockDomainInfo> Clocks { get; }
    public ClockType ClockType { get; }
    public ClockDomainInfo GraphicsClock { get; }
    public ClockDomainInfo MemoryClock { get; }
    public ClockDomainInfo VideoDecodingClock { get; }
    public ClockDomainInfo ProcessorClock { get; }
    public sealed virtual IReadOnlyDictionary`2<PublicClockDomain, ClockDomainInfo> get_Clocks();
    public sealed virtual ClockType get_ClockType();
    public sealed virtual ClockDomainInfo get_GraphicsClock();
    public sealed virtual ClockDomainInfo get_MemoryClock();
    public sealed virtual ClockDomainInfo get_VideoDecodingClock();
    public sealed virtual ClockDomainInfo get_ProcessorClock();
    public virtual string ToString();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.ClockFrequenciesV2 : ValueType {
    internal static int MaxClocksPerGpu;
    internal StructureVersion _Version;
    internal UInt32 _ClockTypeAndReserve;
    internal ClockDomainInfo[] _Clocks;
    public IReadOnlyDictionary`2<PublicClockDomain, ClockDomainInfo> Clocks { get; }
    public ClockType ClockType { get; }
    public ClockDomainInfo GraphicsClock { get; }
    public ClockDomainInfo MemoryClock { get; }
    public ClockDomainInfo VideoDecodingClock { get; }
    public ClockDomainInfo ProcessorClock { get; }
    public ClockFrequenciesV2(ClockType clockType);
    public sealed virtual IReadOnlyDictionary`2<PublicClockDomain, ClockDomainInfo> get_Clocks();
    public sealed virtual ClockType get_ClockType();
    public sealed virtual ClockDomainInfo get_GraphicsClock();
    public sealed virtual ClockDomainInfo get_MemoryClock();
    public sealed virtual ClockDomainInfo get_VideoDecodingClock();
    public sealed virtual ClockDomainInfo get_ProcessorClock();
    public virtual string ToString();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.GPU.Structures.ClockFrequenciesV3 : ValueType {
    internal static int MaxClocksPerGpu;
    internal StructureVersion _Version;
    internal UInt32 _ClockTypeAndReserve;
    internal ClockDomainInfo[] _Clocks;
    public IReadOnlyDictionary`2<PublicClockDomain, ClockDomainInfo> Clocks { get; }
    public ClockType ClockType { get; }
    public ClockDomainInfo GraphicsClock { get; }
    public ClockDomainInfo MemoryClock { get; }
    public ClockDomainInfo VideoDecodingClock { get; }
    public ClockDomainInfo ProcessorClock { get; }
    public ClockFrequenciesV3(ClockType clockType);
    public sealed virtual IReadOnlyDictionary`2<PublicClockDomain, ClockDomainInfo> get_Clocks();
    public sealed virtual ClockType get_ClockType();
    public sealed virtual ClockDomainInfo get_GraphicsClock();
    public sealed virtual ClockDomainInfo get_MemoryClock();
    public sealed virtual ClockDomainInfo get_VideoDecodingClock();
    public sealed virtual ClockDomainInfo get_ProcessorClock();
    public virtual string ToString();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.DisplayDriverMemoryInfoV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _DedicatedVideoMemory;
    internal UInt32 _AvailableDedicatedVideoMemory;
    internal UInt32 _SystemVideoMemory;
    internal UInt32 _SharedSystemMemory;
    public UInt32 DedicatedVideoMemoryInkB { get; }
    public UInt32 AvailableDedicatedVideoMemoryInkB { get; }
    public UInt32 SystemVideoMemoryInkB { get; }
    public UInt32 SharedSystemMemoryInkB { get; }
    public UInt32 CurrentAvailableDedicatedVideoMemoryInkB { get; }
    public sealed virtual UInt32 get_DedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_AvailableDedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_SystemVideoMemoryInkB();
    public sealed virtual UInt32 get_SharedSystemMemoryInkB();
    public sealed virtual UInt32 get_CurrentAvailableDedicatedVideoMemoryInkB();
    public virtual string ToString();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.DisplayDriverMemoryInfoV2 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _DedicatedVideoMemory;
    internal UInt32 _AvailableDedicatedVideoMemory;
    internal UInt32 _SystemVideoMemory;
    internal UInt32 _SharedSystemMemory;
    internal UInt32 _CurrentAvailableDedicatedVideoMemory;
    public UInt32 DedicatedVideoMemoryInkB { get; }
    public UInt32 AvailableDedicatedVideoMemoryInkB { get; }
    public UInt32 SystemVideoMemoryInkB { get; }
    public UInt32 SharedSystemMemoryInkB { get; }
    public UInt32 CurrentAvailableDedicatedVideoMemoryInkB { get; }
    public sealed virtual UInt32 get_DedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_AvailableDedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_SystemVideoMemoryInkB();
    public sealed virtual UInt32 get_SharedSystemMemoryInkB();
    public sealed virtual UInt32 get_CurrentAvailableDedicatedVideoMemoryInkB();
    public virtual string ToString();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.GPU.Structures.DisplayDriverMemoryInfoV3 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _DedicatedVideoMemory;
    internal UInt32 _AvailableDedicatedVideoMemory;
    internal UInt32 _SystemVideoMemory;
    internal UInt32 _SharedSystemMemory;
    internal UInt32 _CurrentAvailableDedicatedVideoMemory;
    internal UInt32 _DedicatedVideoMemoryEvictionsSize;
    internal UInt32 _DedicatedVideoMemoryEvictionCount;
    public UInt32 DedicatedVideoMemoryInkB { get; }
    public UInt32 AvailableDedicatedVideoMemoryInkB { get; }
    public UInt32 SystemVideoMemoryInkB { get; }
    public UInt32 SharedSystemMemoryInkB { get; }
    public UInt32 CurrentAvailableDedicatedVideoMemoryInkB { get; }
    public UInt32 DedicatedVideoMemoryEvictionsSize { get; }
    public UInt32 DedicatedVideoMemoryEvictionCount { get; }
    public sealed virtual UInt32 get_DedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_AvailableDedicatedVideoMemoryInkB();
    public sealed virtual UInt32 get_SystemVideoMemoryInkB();
    public sealed virtual UInt32 get_SharedSystemMemoryInkB();
    public sealed virtual UInt32 get_CurrentAvailableDedicatedVideoMemoryInkB();
    public UInt32 get_DedicatedVideoMemoryEvictionsSize();
    public UInt32 get_DedicatedVideoMemoryEvictionCount();
    public virtual string ToString();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.GPU.Structures.DisplayIdsV2 : ValueType {
    internal StructureVersion _Version;
    internal MonitorConnectionType _ConnectionType;
    internal UInt32 _DisplayId;
    internal UInt32 _RawReserved;
    public UInt32 DisplayId { get; }
    public MonitorConnectionType ConnectionType { get; }
    public bool IsDynamic { get; }
    public bool IsMultiStreamRootNode { get; }
    public bool IsActive { get; }
    public bool IsCluster { get; }
    public bool IsOSVisible { get; }
    public bool IsWFD { get; }
    public bool IsConnected { get; }
    public bool IsPhysicallyConnected { get; }
    public sealed virtual UInt32 get_DisplayId();
    public sealed virtual bool Equals(DisplayIdsV2 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual MonitorConnectionType get_ConnectionType();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual bool get_IsMultiStreamRootNode();
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_IsCluster();
    public sealed virtual bool get_IsOSVisible();
    public sealed virtual bool get_IsWFD();
    public sealed virtual bool get_IsConnected();
    public sealed virtual bool get_IsPhysicallyConnected();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.DynamicPerformanceStatesInfoV1 : ValueType {
    internal static int MaxGpuUtilizations;
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UtilizationDomainInfo[] _UtilizationDomain;
    public bool IsDynamicPerformanceStatesEnabled { get; }
    public Dictionary`2<UtilizationDomain, IUtilizationDomainInfo> Domains { get; }
    public IUtilizationDomainInfo GPU { get; }
    public IUtilizationDomainInfo FrameBuffer { get; }
    public IUtilizationDomainInfo VideoEngine { get; }
    public IUtilizationDomainInfo BusInterface { get; }
    public bool get_IsDynamicPerformanceStatesEnabled();
    public sealed virtual Dictionary`2<UtilizationDomain, IUtilizationDomainInfo> get_Domains();
    public sealed virtual IUtilizationDomainInfo get_GPU();
    public sealed virtual IUtilizationDomainInfo get_FrameBuffer();
    public sealed virtual IUtilizationDomainInfo get_VideoEngine();
    public sealed virtual IUtilizationDomainInfo get_BusInterface();
    public virtual string ToString();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.ECCConfigurationInfoV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    public bool IsEnabled { get; }
    public bool IsEnabledByDefault { get; }
    public bool get_IsEnabled();
    public bool get_IsEnabledByDefault();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.ECCErrorInfoV1 : ValueType {
    internal StructureVersion _Version;
    internal ECCErrorInfo _CurrentErrors;
    internal ECCErrorInfo _AggregatedErrors;
    public ECCErrorInfo CurrentErrors { get; }
    public ECCErrorInfo AggregatedErrors { get; }
    public ECCErrorInfo get_CurrentErrors();
    public ECCErrorInfo get_AggregatedErrors();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.ECCStatusInfoV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _IsSupported;
    internal ECCConfiguration _ConfigurationOptions;
    internal UInt32 _IsEnabled;
    public bool IsSupported { get; }
    public ECCConfiguration ConfigurationOptions { get; }
    public bool IsEnabled { get; }
    public bool get_IsSupported();
    public ECCConfiguration get_ConfigurationOptions();
    public bool get_IsEnabled();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.EDIDV1 : ValueType {
    public static int MaxDataSize;
    internal StructureVersion _Version;
    internal Byte[] _Data;
    public Byte[] Data { get; }
    internal static EDIDV1 CreateWithData(Byte[] data);
    public sealed virtual Byte[] get_Data();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.EDIDV2 : ValueType {
    public static int MaxDataSize;
    internal StructureVersion _Version;
    internal Byte[] _Data;
    internal UInt32 _TotalSize;
    public int TotalSize { get; }
    public Byte[] Data { get; }
    internal static EDIDV2 CreateWithData(Byte[] data, int totalSize);
    public int get_TotalSize();
    public sealed virtual Byte[] get_Data();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.GPU.Structures.EDIDV3 : ValueType {
    public static int MaxDataSize;
    internal StructureVersion _Version;
    internal Byte[] _Data;
    internal UInt32 _TotalSize;
    internal UInt32 _Identification;
    internal UInt32 _DataOffset;
    public int Identification { get; }
    public int DataOffset { get; }
    public int TotalSize { get; }
    public Byte[] Data { get; }
    internal static EDIDV3 CreateWithOffset(UInt32 id, UInt32 offset);
    internal static EDIDV3 CreateWithData(UInt32 id, UInt32 offset, Byte[] data, int totalSize);
    public int get_Identification();
    public int get_DataOffset();
    public int get_TotalSize();
    public sealed virtual Byte[] get_Data();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.GetIlluminationParameterV1 : ValueType {
    internal StructureVersion _Version;
    internal PhysicalGPUHandle _GPUHandle;
    internal IlluminationAttribute _Attribute;
    internal UInt32 _ValueInPercentage;
    public PhysicalGPUHandle PhysicalGPUHandle { get; }
    public IlluminationAttribute Attribute { get; }
    public UInt32 ValueInPercentage { get; }
    public GetIlluminationParameterV1(PhysicalGPUHandle gpuHandle, IlluminationAttribute attribute);
    public PhysicalGPUHandle get_PhysicalGPUHandle();
    public IlluminationAttribute get_Attribute();
    public UInt32 get_ValueInPercentage();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.I2CInfoV2 : ValueType {
    private StructureVersion _Version;
    private OutputId _OutputMask;
    private byte _UseDDCPort;
    private byte _I2CDeviceAddress;
    private ValueTypeArray _I2CRegisterAddress;
    private UInt32 _I2CRegisterAddressLength;
    private ValueTypeArray _Data;
    private UInt32 _DataLength;
    private UInt32 _I2CSpeed;
    private I2CSpeed _I2CSpeedInKHz;
    public OutputId OutputMask { get; }
    public bool UseDDCPort { get; }
    public I2CSpeed Speed { get; }
    public bool IsReadOperation { get; }
    public byte DeviceAddress { get; }
    public Byte[] Data { get; }
    public Byte[] RegisterAddress { get; }
    public Nullable`1<byte> PortId { get; }
    public I2CInfoV2(OutputId outputMask, bool useDDCPort, byte deviceAddress, Byte[] registerAddress, Byte[] data, I2CSpeed speed);
    public I2CInfoV2(OutputId outputMask, bool useDDCPort, byte deviceAddress, Byte[] registerAddress, UInt32 readDataLength, I2CSpeed speed);
    private I2CInfoV2(OutputId outputMask, bool useDDCPort, byte deviceAddress, bool isRead, Byte[] registerAddress, Byte[] data, I2CSpeed speed);
    public sealed virtual OutputId get_OutputMask();
    public sealed virtual bool get_UseDDCPort();
    public sealed virtual I2CSpeed get_Speed();
    public sealed virtual bool get_IsReadOperation();
    public sealed virtual byte get_DeviceAddress();
    public sealed virtual Byte[] get_Data();
    public sealed virtual Byte[] get_RegisterAddress();
    public sealed virtual Nullable`1<byte> get_PortId();
    public static void FillDDCCIChecksum(byte deviceAddress, Byte[] registerAddress, Byte[] data);
    public sealed virtual void Dispose();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.GPU.Structures.I2CInfoV3 : ValueType {
    private StructureVersion _Version;
    private OutputId _OutputMask;
    private byte _UseDDCPort;
    private byte _I2CDeviceAddress;
    private ValueTypeArray _I2CRegisterAddress;
    private UInt32 _I2CRegisterAddressLength;
    private ValueTypeArray _Data;
    private UInt32 _DataLength;
    private UInt32 _I2CSpeed;
    private I2CSpeed _I2CSpeedInKHz;
    private byte _PortId;
    private UInt32 _IsPortIdPresent;
    public OutputId OutputMask { get; }
    public bool UseDDCPort { get; }
    public I2CSpeed Speed { get; }
    public bool IsReadOperation { get; }
    public byte DeviceAddress { get; }
    public Nullable`1<byte> PortId { get; }
    public Byte[] Data { get; }
    public Byte[] RegisterAddress { get; }
    public I2CInfoV3(OutputId outputMask, Nullable`1<byte> portId, bool useDDCPort, byte deviceAddress, Byte[] registerAddress, Byte[] data, I2CSpeed speed);
    public I2CInfoV3(OutputId outputMask, Nullable`1<byte> portId, bool useDDCPort, byte deviceAddress, Byte[] registerAddress, UInt32 readDataLength, I2CSpeed speed);
    private I2CInfoV3(OutputId outputMask, Nullable`1<byte> portId, bool useDDCPort, byte deviceAddress, bool isRead, Byte[] registerAddress, Byte[] data, I2CSpeed speed);
    public sealed virtual OutputId get_OutputMask();
    public sealed virtual bool get_UseDDCPort();
    public sealed virtual I2CSpeed get_Speed();
    public sealed virtual bool get_IsReadOperation();
    public sealed virtual byte get_DeviceAddress();
    public sealed virtual Nullable`1<byte> get_PortId();
    public sealed virtual Byte[] get_Data();
    public sealed virtual Byte[] get_RegisterAddress();
    public static void FillDDCCIChecksum(byte deviceAddress, Byte[] registerAddress, Byte[] data);
    public sealed virtual void Dispose();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.IlluminationDeviceControlParametersV1 : ValueType {
    private static int MaximumNumberOfReserved;
    private static int MaximumNumberOfDevices;
    internal StructureVersion _Version;
    internal UInt32 _NumberOfDevices;
    internal Byte[] _Reserved;
    internal IlluminationDeviceControlV1[] _Devices;
    public IlluminationDeviceControlV1[] Devices { get; }
    public IlluminationDeviceControlParametersV1(IlluminationDeviceControlV1[] devices);
    public IlluminationDeviceControlV1[] get_Devices();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.IlluminationDeviceControlV1 : ValueType {
    private static int MaximumNumberOfReserved;
    internal IlluminationDeviceType _DeviceType;
    internal IlluminationDeviceSyncV1 _SyncInformation;
    internal Byte[] _Reserved;
    public IlluminationDeviceType DeviceType { get; }
    public IlluminationDeviceSyncV1 SyncInformation { get; }
    public IlluminationDeviceControlV1(IlluminationDeviceType deviceType, IlluminationDeviceSyncV1 syncInformation);
    public IlluminationDeviceType get_DeviceType();
    public IlluminationDeviceSyncV1 get_SyncInformation();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.IlluminationDeviceInfoParametersV1 : ValueType {
    private static int MaximumNumberOfReserved;
    private static int MaximumNumberOfDevices;
    internal StructureVersion _Version;
    internal UInt32 _NumberOfDevices;
    internal Byte[] _Reserved;
    internal IlluminationDeviceInfoV1[] _Devices;
    public IlluminationDeviceInfoV1[] Devices { get; }
    public IlluminationDeviceInfoV1[] get_Devices();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationDeviceInfoV1 : ValueType {
    private static int MaximumNumberOfReserved;
    private static int MaximumNumberOfDeviceData;
    internal IlluminationDeviceType _DeviceType;
    internal IlluminationZoneControlMode _ControlModes;
    internal Byte[] _DeviceData;
    internal Byte[] _Reserved;
    public IlluminationDeviceType DeviceType { get; }
    public IlluminationZoneControlMode ControlMode { get; }
    public byte MCUV10DeviceI2CIndex { get; }
    public IlluminationDeviceType get_DeviceType();
    public IlluminationZoneControlMode get_ControlMode();
    public byte get_MCUV10DeviceI2CIndex();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationDeviceSyncV1 : ValueType {
    private static int MaximumNumberOfReserved;
    internal byte _IsSync;
    internal ulong _TimeStampInMS;
    internal Byte[] _Reserved;
    public bool IsSync { get; }
    public ulong TimeStampInMS { get; }
    public IlluminationDeviceSyncV1(bool isSync, ulong timeStampInMS);
    public bool get_IsSync();
    public ulong get_TimeStampInMS();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataFixedColor : ValueType {
    private static int MaximumNumberOfDataBytes;
    private static int MaximumNumberOfReservedBytes;
    internal Byte[] _Data;
    internal Byte[] _Reserved;
    public IlluminationZoneControlDataFixedColor(IlluminationZoneControlDataManualFixedColor manualFixedColor);
    public IlluminationZoneControlDataFixedColor(IlluminationZoneControlDataPiecewiseLinearFixedColor piecewiseLinearFixedColor);
    private IlluminationZoneControlDataFixedColor(Byte[] data);
    public IlluminationZoneControlDataManualFixedColor AsManual();
    public IlluminationZoneControlDataPiecewiseLinearFixedColor AsPiecewise();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataFixedColorParameters : ValueType {
    internal byte _BrightnessInPercentage;
    public byte BrightnessInPercentage { get; }
    public IlluminationZoneControlDataFixedColorParameters(byte brightnessInPercentage);
    public byte get_BrightnessInPercentage();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataManualFixedColor : ValueType {
    internal IlluminationZoneControlDataFixedColorParameters _Parameters;
    internal IlluminationZoneControlDataFixedColorParameters Parameters { get; }
    public IlluminationZoneControlDataManualFixedColor(IlluminationZoneControlDataFixedColorParameters parameters);
    internal IlluminationZoneControlDataFixedColorParameters get_Parameters();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataManualRGB : ValueType {
    internal IlluminationZoneControlDataManualRGBParameters _Parameters;
    public IlluminationZoneControlDataManualRGBParameters Parameters { get; }
    public IlluminationZoneControlDataManualRGB(IlluminationZoneControlDataManualRGBParameters parameters);
    public IlluminationZoneControlDataManualRGBParameters get_Parameters();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataManualRGBParameters : ValueType {
    internal byte _Red;
    internal byte _Green;
    internal byte _Blue;
    internal byte _BrightnessInPercentage;
    public byte Red { get; }
    public byte Green { get; }
    public byte Blue { get; }
    public byte BrightnessInPercentage { get; }
    public IlluminationZoneControlDataManualRGBParameters(byte red, byte green, byte blue, byte brightnessInPercentage);
    public byte get_Red();
    public byte get_Green();
    public byte get_Blue();
    public byte get_BrightnessInPercentage();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataPiecewiseLinear : ValueType {
    internal IlluminationPiecewiseLinearCycleType _CycleType;
    internal byte _GroupPeriodRepeatCount;
    internal ushort _RiseDurationInMS;
    internal ushort _FallDurationInMS;
    internal ushort _ADurationInMS;
    internal ushort _BDurationInMS;
    internal ushort _NextGroupIdleDurationInMS;
    internal ushort _PhaseOffsetInMS;
    public ushort PhaseOffsetInMS { get; }
    public ushort NextGroupIdleDurationInMS { get; }
    public ushort BDurationInMS { get; }
    public ushort ADurationInMS { get; }
    public ushort FallDurationInMS { get; }
    public ushort RiseDurationInMS { get; }
    public byte GroupPeriodRepeatCount { get; }
    public IlluminationPiecewiseLinearCycleType CycleType { get; }
    public IlluminationZoneControlDataPiecewiseLinear(IlluminationPiecewiseLinearCycleType cycleType, byte groupPeriodRepeatCount, ushort riseDurationInMS, ushort fallDurationInMS, ushort aDurationInMS, ushort bDurationInMS, ushort nextGroupIdleDurationInMS, ushort phaseOffsetInMS);
    public ushort get_PhaseOffsetInMS();
    public ushort get_NextGroupIdleDurationInMS();
    public ushort get_BDurationInMS();
    public ushort get_ADurationInMS();
    public ushort get_FallDurationInMS();
    public ushort get_RiseDurationInMS();
    public byte get_GroupPeriodRepeatCount();
    public IlluminationPiecewiseLinearCycleType get_CycleType();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataPiecewiseLinearFixedColor : ValueType {
    private static int NumberColorEndPoints;
    internal IlluminationZoneControlDataFixedColorParameters[] _EndPoints;
    internal IlluminationZoneControlDataPiecewiseLinear _PiecewiseLinearData;
    public IlluminationZoneControlDataPiecewiseLinear PiecewiseLinearData { get; }
    public IlluminationZoneControlDataFixedColorParameters[] EndPoints { get; }
    public IlluminationZoneControlDataPiecewiseLinearFixedColor(IlluminationZoneControlDataFixedColorParameters[] endPoints, IlluminationZoneControlDataPiecewiseLinear piecewiseLinearData);
    public IlluminationZoneControlDataPiecewiseLinear get_PiecewiseLinearData();
    public IlluminationZoneControlDataFixedColorParameters[] get_EndPoints();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataPiecewiseLinearRGB : ValueType {
    private static int NumberColorEndPoints;
    internal IlluminationZoneControlDataManualRGBParameters[] _EndPoints;
    internal IlluminationZoneControlDataPiecewiseLinear _PiecewiseLinearData;
    public IlluminationZoneControlDataPiecewiseLinear PiecewiseLinearData { get; }
    public IlluminationZoneControlDataManualRGBParameters[] EndPoints { get; }
    public IlluminationZoneControlDataPiecewiseLinearRGB(IlluminationZoneControlDataManualRGBParameters[] endPoints, IlluminationZoneControlDataPiecewiseLinear piecewiseLinearData);
    public IlluminationZoneControlDataPiecewiseLinear get_PiecewiseLinearData();
    public IlluminationZoneControlDataManualRGBParameters[] get_EndPoints();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlDataRGB : ValueType {
    private static int MaximumNumberOfDataBytes;
    private static int MaximumNumberOfReservedBytes;
    internal Byte[] _Data;
    internal Byte[] _Reserved;
    public IlluminationZoneControlDataRGB(IlluminationZoneControlDataManualRGB manualRGB);
    public IlluminationZoneControlDataRGB(IlluminationZoneControlDataPiecewiseLinearRGB piecewiseLinearRGB);
    private IlluminationZoneControlDataRGB(Byte[] data);
    public IlluminationZoneControlDataManualRGB AsManual();
    public IlluminationZoneControlDataPiecewiseLinearRGB AsPiecewise();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlParametersV1 : ValueType {
    private static int MaximumNumberOfZoneControls;
    private static int MaximumNumberOfReservedBytes;
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UInt32 _NumberOfZoneControls;
    internal Byte[] _Reserved;
    internal IlluminationZoneControlV1[] _ZoneControls;
    public IlluminationZoneControlValuesType ValuesType { get; }
    public IlluminationZoneControlV1[] ZoneControls { get; }
    public IlluminationZoneControlParametersV1(IlluminationZoneControlValuesType valuesType);
    public IlluminationZoneControlParametersV1(IlluminationZoneControlValuesType valuesType, IlluminationZoneControlV1[] zoneControls);
    public IlluminationZoneControlValuesType get_ValuesType();
    public IlluminationZoneControlV1[] get_ZoneControls();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneControlV1 : ValueType {
    private static int MaximumNumberOfDataBytes;
    private static int MaximumNumberOfReservedBytes;
    internal IlluminationZoneType _ZoneType;
    internal IlluminationZoneControlMode _ControlMode;
    internal Byte[] _Data;
    internal Byte[] _Reserved;
    internal IlluminationZoneType ZoneType { get; }
    internal IlluminationZoneControlMode ControlMode { get; }
    public IlluminationZoneControlV1(IlluminationZoneControlMode controlMode, IlluminationZoneControlDataRGB rgbData);
    public IlluminationZoneControlV1(IlluminationZoneControlMode controlMode, IlluminationZoneControlDataFixedColor fixedColorData);
    private IlluminationZoneControlV1(IlluminationZoneControlMode controlMode, IlluminationZoneType zoneType, Byte[] data);
    internal IlluminationZoneType get_ZoneType();
    internal IlluminationZoneControlMode get_ControlMode();
    public IlluminationZoneControlDataRGB AsRGBData();
    public IlluminationZoneControlDataFixedColor AsFixedColorData();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneInfoParametersV1 : ValueType {
    private static int MaximumNumberOfReserved;
    private static int MaximumNumberOfZones;
    internal StructureVersion _Version;
    internal UInt32 _NumberOfZones;
    internal Byte[] _Reserved;
    internal IlluminationZoneInfoV1[] _Zones;
    public IlluminationZoneInfoV1[] Zones { get; }
    public IlluminationZoneInfoV1[] get_Zones();
}
public class NvAPIWrapper.Native.GPU.Structures.IlluminationZoneInfoV1 : ValueType {
    private static int MaximumNumberOfReserved;
    private static int MaximumNumberOfDataBytes;
    internal IlluminationZoneType _ZoneType;
    internal byte _DeviceIndex;
    internal byte _ProviderIndex;
    internal IlluminationZoneLocation _ZoneLocation;
    internal Byte[] _Data;
    internal Byte[] _Reserved;
    public int DeviceIndex { get; }
    public int ProviderIndex { get; }
    public IlluminationZoneLocation ZoneLocation { get; }
    internal IlluminationZoneType ZoneType { get; }
    public int get_DeviceIndex();
    public int get_ProviderIndex();
    public IlluminationZoneLocation get_ZoneLocation();
    internal IlluminationZoneType get_ZoneType();
}
public interface NvAPIWrapper.Native.GPU.Structures.IUtilizationStatus {
    public IUtilizationDomainInfo BusInterface { get; }
    public Dictionary`2<UtilizationDomain, IUtilizationDomainInfo> Domains { get; }
    public IUtilizationDomainInfo FrameBuffer { get; }
    public IUtilizationDomainInfo GPU { get; }
    public IUtilizationDomainInfo VideoEngine { get; }
    public abstract virtual IUtilizationDomainInfo get_BusInterface();
    public abstract virtual Dictionary`2<UtilizationDomain, IUtilizationDomainInfo> get_Domains();
    public abstract virtual IUtilizationDomainInfo get_FrameBuffer();
    public abstract virtual IUtilizationDomainInfo get_GPU();
    public abstract virtual IUtilizationDomainInfo get_VideoEngine();
}
public class NvAPIWrapper.Native.GPU.Structures.LogicalGPUHandle : ValueType {
    public static int MaxLogicalGPUs;
    internal IntPtr _MemoryAddress;
    public IntPtr MemoryAddress { get; }
    public bool IsNull { get; }
    public sealed virtual bool Equals(LogicalGPUHandle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(LogicalGPUHandle left, LogicalGPUHandle right);
    public static bool op_Inequality(LogicalGPUHandle left, LogicalGPUHandle right);
    public sealed virtual IntPtr get_MemoryAddress();
    public sealed virtual bool get_IsNull();
}
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStates20BaseVoltageEntryV1 : ValueType {
    internal PerformanceVoltageDomain _DomainId;
    internal UInt32 _Flags;
    internal UInt32 _Value;
    internal PerformanceStates20ParameterDelta _ValueDelta;
    public PerformanceVoltageDomain DomainId { get; }
    public bool IsEditable { get; }
    public UInt32 ValueInMicroVolt { get; }
    public PerformanceStates20ParameterDelta ValueDeltaInMicroVolt { get; }
    public PerformanceStates20BaseVoltageEntryV1(PerformanceVoltageDomain domain, UInt32 value, PerformanceStates20ParameterDelta valueDelta);
    public PerformanceStates20BaseVoltageEntryV1(PerformanceVoltageDomain domain, PerformanceStates20ParameterDelta valueDelta);
    public sealed virtual PerformanceVoltageDomain get_DomainId();
    public sealed virtual bool get_IsEditable();
    public sealed virtual UInt32 get_ValueInMicroVolt();
    public sealed virtual PerformanceStates20ParameterDelta get_ValueDeltaInMicroVolt();
}
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStates20ClockEntryV1 : ValueType {
    internal PublicClockDomain _DomainId;
    internal PerformanceStates20ClockType _ClockType;
    internal UInt32 _Flags;
    internal PerformanceStates20ParameterDelta _FrequencyDeltaInkHz;
    internal PerformanceStates20ClockDependentInfo _ClockDependentInfo;
    public PublicClockDomain DomainId { get; }
    public PerformanceStates20ClockType ClockType { get; }
    public bool IsEditable { get; }
    public PerformanceStates20ParameterDelta FrequencyDeltaInkHz { get; }
    private IPerformanceStates20ClockDependentSingleFrequency NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20ClockEntry.SingleFrequency { get; }
    private IPerformanceStates20ClockDependentFrequencyRange NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20ClockEntry.FrequencyRange { get; }
    public PerformanceStates20ClockDependentSingleFrequency SingleFrequency { get; }
    public PerformanceStates20ClockDependentFrequencyRange FrequencyRange { get; }
    public PerformanceStates20ClockEntryV1(PublicClockDomain domain, PerformanceStates20ParameterDelta valueDelta);
    public PerformanceStates20ClockEntryV1(PublicClockDomain domain, PerformanceStates20ClockType clockType, PerformanceStates20ParameterDelta valueDelta);
    public PerformanceStates20ClockEntryV1(PublicClockDomain domain, PerformanceStates20ParameterDelta valueDelta, PerformanceStates20ClockDependentSingleFrequency singleFrequency);
    public PerformanceStates20ClockEntryV1(PublicClockDomain domain, PerformanceStates20ParameterDelta valueDelta, PerformanceStates20ClockDependentFrequencyRange frequencyRange);
    public sealed virtual PublicClockDomain get_DomainId();
    public sealed virtual PerformanceStates20ClockType get_ClockType();
    public sealed virtual bool get_IsEditable();
    public sealed virtual PerformanceStates20ParameterDelta get_FrequencyDeltaInkHz();
    private sealed virtual override IPerformanceStates20ClockDependentSingleFrequency NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20ClockEntry.get_SingleFrequency();
    private sealed virtual override IPerformanceStates20ClockDependentFrequencyRange NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20ClockEntry.get_FrequencyRange();
    public PerformanceStates20ClockDependentSingleFrequency get_SingleFrequency();
    public PerformanceStates20ClockDependentFrequencyRange get_FrequencyRange();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStates20InfoV1 : ValueType {
    internal static int MaxPerformanceStates;
    internal static int MaxPerformanceStatesClocks;
    internal static int MaxPerformanceStatesBaseVoltages;
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UInt32 _NumberOfPerformanceStates;
    internal UInt32 _NumberOfClocks;
    internal UInt32 _NumberOfBaseVoltages;
    internal PerformanceState20[] _PerformanceStates;
    public IPerformanceStates20VoltageEntry[] GeneralVoltages { get; }
    public bool IsEditable { get; }
    public PerformanceState20[] PerformanceStates { get; }
    private IPerformanceState20[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.PerformanceStates { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20ClockEntryV1[]> Clocks { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20ClockEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.Clocks { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20BaseVoltageEntryV1[]> Voltages { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20VoltageEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.Voltages { get; }
    public PerformanceStates20InfoV1(PerformanceState20[] performanceStates, UInt32 clocksCount, UInt32 baseVoltagesCount);
    public sealed virtual IPerformanceStates20VoltageEntry[] get_GeneralVoltages();
    public sealed virtual bool get_IsEditable();
    public PerformanceState20[] get_PerformanceStates();
    private sealed virtual override IPerformanceState20[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_PerformanceStates();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20ClockEntryV1[]> get_Clocks();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20ClockEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_Clocks();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20BaseVoltageEntryV1[]> get_Voltages();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20VoltageEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_Voltages();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStates20InfoV2 : ValueType {
    internal static int MaxPerformanceStates;
    internal static int MaxPerformanceStatesBaseVoltages;
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UInt32 _NumberOfPerformanceStates;
    internal UInt32 _NumberOfClocks;
    internal UInt32 _NumberOfBaseVoltages;
    internal PerformanceState20[] _PerformanceStates;
    internal PerformanceStates20OverVoltingSetting _OverVoltingSettings;
    public PerformanceStates20BaseVoltageEntryV1[] GeneralVoltages { get; }
    private IPerformanceStates20VoltageEntry[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.GeneralVoltages { get; }
    public bool IsEditable { get; }
    public PerformanceState20[] PerformanceStates { get; }
    private IPerformanceState20[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.PerformanceStates { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20ClockEntryV1[]> Clocks { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20BaseVoltageEntryV1[]> Voltages { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20ClockEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.Clocks { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20VoltageEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.Voltages { get; }
    public PerformanceStates20InfoV2(PerformanceState20[] performanceStates, UInt32 clocksCount, UInt32 baseVoltagesCount);
    public PerformanceStates20InfoV2(PerformanceState20[] performanceStates, UInt32 clocksCount, UInt32 baseVoltagesCount, PerformanceStates20BaseVoltageEntryV1[] generalVoltages);
    public PerformanceStates20BaseVoltageEntryV1[] get_GeneralVoltages();
    private sealed virtual override IPerformanceStates20VoltageEntry[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_GeneralVoltages();
    public sealed virtual bool get_IsEditable();
    public PerformanceState20[] get_PerformanceStates();
    private sealed virtual override IPerformanceState20[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_PerformanceStates();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20ClockEntryV1[]> get_Clocks();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20BaseVoltageEntryV1[]> get_Voltages();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20ClockEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_Clocks();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20VoltageEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_Voltages();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStates20InfoV3 : ValueType {
    internal static int MaxPerformanceStates;
    internal static int MaxPerformanceStates20BaseVoltages;
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UInt32 _NumberOfPerformanceStates;
    internal UInt32 _NumberOfClocks;
    internal UInt32 _NumberOfBaseVoltages;
    internal PerformanceState20[] _PerformanceStates;
    internal PerformanceStates20OverVoltingSetting _OverVoltingSettings;
    public PerformanceStates20BaseVoltageEntryV1[] GeneralVoltages { get; }
    private IPerformanceStates20VoltageEntry[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.GeneralVoltages { get; }
    public bool IsEditable { get; }
    public PerformanceState20[] PerformanceStates { get; }
    private IPerformanceState20[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.PerformanceStates { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20ClockEntryV1[]> Clocks { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20BaseVoltageEntryV1[]> Voltages { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20ClockEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.Clocks { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20VoltageEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.Voltages { get; }
    public PerformanceStates20InfoV3(PerformanceState20[] performanceStates, UInt32 clocksCount, UInt32 baseVoltagesCount);
    public PerformanceStates20InfoV3(PerformanceState20[] performanceStates, UInt32 clocksCount, UInt32 baseVoltagesCount, PerformanceStates20BaseVoltageEntryV1[] generalVoltages);
    public PerformanceStates20BaseVoltageEntryV1[] get_GeneralVoltages();
    private sealed virtual override IPerformanceStates20VoltageEntry[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_GeneralVoltages();
    public sealed virtual bool get_IsEditable();
    public PerformanceState20[] get_PerformanceStates();
    private sealed virtual override IPerformanceState20[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_PerformanceStates();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20ClockEntryV1[]> get_Clocks();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStates20BaseVoltageEntryV1[]> get_Voltages();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20ClockEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_Clocks();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20VoltageEntry[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info.get_Voltages();
}
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStates20ParameterDelta : ValueType {
    internal int _DeltaValue;
    internal PerformanceState20ParameterDeltaValueRange _DeltaRange;
    public int DeltaValue { get; public set; }
    public PerformanceState20ParameterDeltaValueRange DeltaRange { get; }
    public PerformanceStates20ParameterDelta(int deltaValue, int deltaMinimum, int deltaMaximum);
    public PerformanceStates20ParameterDelta(int deltaValue);
    public int get_DeltaValue();
    public void set_DeltaValue(int value);
    public PerformanceState20ParameterDeltaValueRange get_DeltaRange();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStatesInfoV1 : ValueType {
    internal static int MaxPerformanceStates;
    internal static int MaxPerformanceStateClocks;
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UInt32 _NumberOfPerformanceStates;
    internal UInt32 _NumberOfClocks;
    internal PerformanceState[] _PerformanceStates;
    public bool IsPerformanceMonitorEnable { get; }
    public bool IsCapableOfDynamicPerformance { get; }
    public bool IsDynamicPerformanceEnable { get; }
    public PerformanceState[] PerformanceStates { get; }
    private IPerformanceState[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.PerformanceStates { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesVoltage[]> PerformanceStatesVoltages { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesClock[]> PerformanceStatesClocks { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesClock[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.PerformanceStatesClocks { get; }
    public sealed virtual bool get_IsPerformanceMonitorEnable();
    public sealed virtual bool get_IsCapableOfDynamicPerformance();
    public sealed virtual bool get_IsDynamicPerformanceEnable();
    public PerformanceState[] get_PerformanceStates();
    private sealed virtual override IPerformanceState[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.get_PerformanceStates();
    public sealed virtual IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesVoltage[]> get_PerformanceStatesVoltages();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesClock[]> get_PerformanceStatesClocks();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesClock[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.get_PerformanceStatesClocks();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStatesInfoV2 : ValueType {
    internal static int MaxPerformanceStates;
    internal static int MaxPerformanceStateClocks;
    internal static int MaxPerformanceStateVoltages;
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UInt32 _NumberOfPerformanceStates;
    internal UInt32 _NumberOfClocks;
    internal UInt32 _NumberOfVoltages;
    internal PerformanceState[] _PerformanceStates;
    public bool IsPerformanceMonitorEnable { get; }
    public bool IsCapableOfDynamicPerformance { get; }
    public bool IsDynamicPerformanceEnable { get; }
    public PerformanceState[] PerformanceStates { get; }
    private IPerformanceState[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.PerformanceStates { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesVoltage[]> PerformanceStatesVoltages { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesVoltage[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.PerformanceStatesVoltages { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesClock[]> PerformanceStatesClocks { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesClock[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.PerformanceStatesClocks { get; }
    public sealed virtual bool get_IsPerformanceMonitorEnable();
    public sealed virtual bool get_IsCapableOfDynamicPerformance();
    public sealed virtual bool get_IsDynamicPerformanceEnable();
    public PerformanceState[] get_PerformanceStates();
    private sealed virtual override IPerformanceState[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.get_PerformanceStates();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesVoltage[]> get_PerformanceStatesVoltages();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesVoltage[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.get_PerformanceStatesVoltages();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesClock[]> get_PerformanceStatesClocks();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesClock[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.get_PerformanceStatesClocks();
}
[StructureVersionAttribute("3")]
public class NvAPIWrapper.Native.GPU.Structures.PerformanceStatesInfoV3 : ValueType {
    internal static int MaxPerformanceStates;
    internal static int MaxPerformanceStateClocks;
    internal static int MaxPerformanceStateVoltages;
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UInt32 _NumberOfPerformanceStates;
    internal UInt32 _NumberOfClocks;
    internal UInt32 _NumberOfVoltages;
    internal PerformanceState[] _PerformanceStates;
    public bool IsPerformanceMonitorEnable { get; }
    public bool IsCapableOfDynamicPerformance { get; }
    public bool IsDynamicPerformanceEnable { get; }
    public PerformanceState[] PerformanceStates { get; }
    private IPerformanceState[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.PerformanceStates { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesVoltage[]> PerformanceStatesVoltages { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesVoltage[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.PerformanceStatesVoltages { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesClock[]> PerformanceStatesClocks { get; }
    private IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesClock[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.PerformanceStatesClocks { get; }
    public sealed virtual bool get_IsPerformanceMonitorEnable();
    public sealed virtual bool get_IsCapableOfDynamicPerformance();
    public sealed virtual bool get_IsDynamicPerformanceEnable();
    public PerformanceState[] get_PerformanceStates();
    private sealed virtual override IPerformanceState[] NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.get_PerformanceStates();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesVoltage[]> get_PerformanceStatesVoltages();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesVoltage[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.get_PerformanceStatesVoltages();
    public IReadOnlyDictionary`2<PerformanceStateId, PerformanceStatesClock[]> get_PerformanceStatesClocks();
    private sealed virtual override IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesClock[]> NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo.get_PerformanceStatesClocks();
}
public class NvAPIWrapper.Native.GPU.Structures.PhysicalGPUHandle : ValueType {
    public static int PhysicalGPUs;
    public static int MaxPhysicalGPUs;
    internal IntPtr _MemoryAddress;
    public IntPtr MemoryAddress { get; }
    public bool IsNull { get; }
    public static PhysicalGPUHandle DefaultHandle { get; }
    public sealed virtual bool Equals(PhysicalGPUHandle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual IntPtr get_MemoryAddress();
    public sealed virtual bool get_IsNull();
    public static bool op_Equality(PhysicalGPUHandle left, PhysicalGPUHandle right);
    public static bool op_Inequality(PhysicalGPUHandle left, PhysicalGPUHandle right);
    public static PhysicalGPUHandle get_DefaultHandle();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateActiveApplicationV2 : ValueType {
    internal static int MaximumNumberOfApplications;
    internal StructureVersion _Version;
    internal UInt32 _ProcessId;
    internal LongString _ProcessName;
    public int ProcessId { get; }
    public string ProcessName { get; }
    public int get_ProcessId();
    public string get_ProcessName();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateArchitectInfoV2 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Unknown1;
    internal UInt32 _Unknown2;
    internal UInt32 _Revision;
    public UInt32 Revision { get; }
    public UInt32 get_Revision();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateClockBoostLockV2 : ValueType {
    internal static int MaxNumberOfClocksPerGPU;
    internal StructureVersion _Version;
    internal UInt32 _Unknown;
    internal UInt32 _ClockBoostLocksCount;
    internal ClockBoostLock[] _ClockBoostLocks;
    public ClockBoostLock[] ClockBoostLocks { get; }
    public PrivateClockBoostLockV2(ClockBoostLock[] clockBoostLocks);
    public ClockBoostLock[] get_ClockBoostLocks();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateClockBoostMasksV1 : ValueType {
    internal static int MaxMasks;
    internal static int MaxUnknown1;
    internal static int MaxClockBoostMasks;
    internal static int MaxUnknown2;
    internal StructureVersion _Version;
    internal UInt32[] _Masks;
    internal UInt32[] _Unknown1;
    internal ClockBoostMask[] _ClocksBoostMasks;
    internal UInt32[] _Unknown2;
    public ClockBoostMask[] ClockBoostMasks { get; }
    public ClockBoostMask[] get_ClockBoostMasks();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateClockBoostRangesV1 : ValueType {
    internal static int MaxNumberOfClocksPerGPU;
    internal static int MaxNumberOfUnknown;
    internal StructureVersion _Version;
    internal UInt32 _ClockBoostRangesCount;
    internal UInt32[] _Unknown;
    internal ClockBoostRange[] _ClockBoostRanges;
    public ClockBoostRange[] ClockBoostRanges { get; }
    public ClockBoostRange[] get_ClockBoostRanges();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateClockBoostTableV1 : ValueType {
    internal static int MaxNumberOfMasks;
    internal static int MaxNumberOfUnknown1;
    internal static int MaxNumberOfGPUDeltas;
    internal static int MaxNumberOfMemoryFilled;
    internal static int MaxNumberOfMemoryDeltas;
    internal static int MaxNumberOfUnknown2;
    internal StructureVersion _Version;
    internal UInt32[] _Masks;
    internal UInt32[] _Unknown1;
    internal GPUDelta[] _GPUDeltas;
    internal UInt32[] _MemoryFilled;
    internal Int32[] _MemoryDeltas;
    internal UInt32[] _Unknown2;
    public GPUDelta[] GPUDeltas { get; }
    public PrivateClockBoostTableV1(GPUDelta[] gpuDeltas);
    public GPUDelta[] get_GPUDeltas();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateCoolerLevelsV1 : ValueType {
    internal static int MaxNumberOfCoolersPerGPU;
    internal StructureVersion _Version;
    internal CoolerLevel[] _CoolerLevels;
    public PrivateCoolerLevelsV1(CoolerLevel[] levels);
    public CoolerLevel[] GetCoolerLevels(int count);
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateCoolerPolicyTableV1 : ValueType {
    internal static int MaxNumberOfPolicyLevels;
    internal StructureVersion _Version;
    internal CoolerPolicy _Policy;
    internal CoolerPolicyTableEntry[] _TableEntries;
    public CoolerPolicy Policy { get; }
    public PrivateCoolerPolicyTableV1(CoolerPolicy policy, CoolerPolicyTableEntry[] policyTableEntries);
    public CoolerPolicyTableEntry[] TableEntries(int count);
    public CoolerPolicy get_Policy();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateCoolerSettingsV1 : ValueType {
    internal static int MaxNumberOfCoolersPerGPU;
    internal StructureVersion _Version;
    internal UInt32 _CoolerSettingsCount;
    internal CoolerSetting[] _CoolerSettings;
    public CoolerSetting[] CoolerSettings { get; }
    public CoolerSetting[] get_CoolerSettings();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateFanCoolersControlV1 : ValueType {
    internal static int MaxNumberOfFanCoolerControlEntries;
    internal StructureVersion _Version;
    internal UInt32 _UnknownUInt;
    internal UInt32 _FanCoolersControlCount;
    internal UInt32[] _Reserved;
    internal FanCoolersControlEntry[] _FanCoolersControlEntries;
    public FanCoolersControlEntry[] FanCoolersControlEntries { get; }
    public UInt32 UnknownUInt { get; }
    public PrivateFanCoolersControlV1(FanCoolersControlEntry[] entries, UInt32 unknownUInt);
    public FanCoolersControlEntry[] get_FanCoolersControlEntries();
    public UInt32 get_UnknownUInt();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateFanCoolersInfoV1 : ValueType {
    internal static int MaxNumberOfFanCoolerInfoEntries;
    internal StructureVersion _Version;
    internal UInt32 _UnknownUInt1;
    internal UInt32 _FanCoolersInfoCount;
    internal UInt32[] _Reserved;
    internal FanCoolersInfoEntry[] _FanCoolersInfoEntries;
    public FanCoolersInfoEntry[] FanCoolersInfoEntries { get; }
    public FanCoolersInfoEntry[] get_FanCoolersInfoEntries();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateFanCoolersStatusV1 : ValueType {
    internal static int MaxNumberOfFanCoolerStatusEntries;
    internal StructureVersion _Version;
    internal UInt32 _FanCoolersStatusCount;
    internal UInt32[] _Reserved;
    internal FanCoolersStatusEntry[] _FanCoolersStatusEntries;
    public FanCoolersStatusEntry[] FanCoolersStatusEntries { get; }
    public FanCoolersStatusEntry[] get_FanCoolersStatusEntries();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.PrivatePCIeInfoV2 : ValueType {
    internal StructureVersion _Version;
    internal PCIePerformanceStateInfo[] _PCIePerformanceStateInfos;
    public PCIePerformanceStateInfo[] PCIePerformanceStateInfos { get; }
    public PCIePerformanceStateInfo[] get_PCIePerformanceStateInfos();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivatePerformanceInfoV1 : ValueType {
    internal static int MaxNumberOfUnknown2;
    internal StructureVersion _Version;
    internal UInt32 _Unknown1;
    internal PerformanceLimit _SupportedLimits;
    internal UInt32[] _Unknown2;
    public bool IsPowerLimitSupported { get; }
    public bool IsTemperatureLimitSupported { get; }
    public bool IsVoltageLimitSupported { get; }
    public bool IsNoLoadLimitSupported { get; }
    public bool get_IsPowerLimitSupported();
    public bool get_IsTemperatureLimitSupported();
    public bool get_IsVoltageLimitSupported();
    public bool get_IsNoLoadLimitSupported();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivatePerformanceStatusV1 : ValueType {
    internal static int MaxNumberOfTimers;
    internal static int MaxNumberOfUnknown5;
    internal StructureVersion _Version;
    internal UInt32 _Unknown1;
    internal ulong _TimerInNanoSecond;
    internal PerformanceLimit _PerformanceLimit;
    internal UInt32 _Unknown2;
    internal UInt32 _Unknown3;
    internal UInt32 _Unknown4;
    internal UInt64[] _TimersInNanoSecond;
    internal UInt32[] _Unknown5;
    public PerformanceLimit PerformanceLimit { get; }
    public PerformanceLimit get_PerformanceLimit();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivatePowerPoliciesInfoV1 : ValueType {
    internal static int MaxNumberOfPowerPolicyInfoEntries;
    internal StructureVersion _Version;
    internal byte _Valid;
    internal byte _PowerPolicyEntriesCount;
    internal PowerPolicyInfoEntry[] _PowerPolicyInfoEntries;
    public PowerPolicyInfoEntry[] PowerPolicyInfoEntries { get; }
    public PowerPolicyInfoEntry[] get_PowerPolicyInfoEntries();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivatePowerPoliciesStatusV1 : ValueType {
    internal static int MaxNumberOfPowerPoliciesStatusEntries;
    internal StructureVersion _Version;
    internal UInt32 _PowerPoliciesStatusEntriesCount;
    internal PowerPolicyStatusEntry[] _PowerPoliciesStatusEntries;
    public PowerPolicyStatusEntry[] PowerPolicyStatusEntries { get; }
    public PrivatePowerPoliciesStatusV1(PowerPolicyStatusEntry[] powerPoliciesStatusEntries);
    public PowerPolicyStatusEntry[] get_PowerPolicyStatusEntries();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivatePowerTopologiesStatusV1 : ValueType {
    internal static int MaxNumberOfPowerTopologiesStatusEntries;
    internal StructureVersion _Version;
    internal UInt32 _PowerTopologiesStatusEntriesCount;
    internal PowerTopologiesStatusEntry[] _PowerTopologiesStatusEntries;
    public PowerTopologiesStatusEntry[] PowerPolicyStatusEntries { get; }
    public PowerTopologiesStatusEntry[] get_PowerPolicyStatusEntries();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateThermalPoliciesInfoV2 : ValueType {
    internal static int MaxNumberOfThermalPoliciesInfoEntries;
    internal StructureVersion _Version;
    internal byte _ThermalPoliciesInfoCount;
    internal byte _Unknown;
    internal ThermalPoliciesInfoEntry[] _ThermalPoliciesInfoEntries;
    public ThermalPoliciesInfoEntry[] ThermalPoliciesInfoEntries { get; }
    public ThermalPoliciesInfoEntry[] get_ThermalPoliciesInfoEntries();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateThermalPoliciesStatusV2 : ValueType {
    internal static int MaxNumberOfThermalPoliciesStatusEntries;
    internal StructureVersion _Version;
    internal UInt32 _ThermalPoliciesStatusEntriesCount;
    internal ThermalPoliciesStatusEntry[] _ThermalPoliciesStatusEntries;
    public ThermalPoliciesStatusEntry[] ThermalPoliciesStatusEntries { get; }
    public PrivateThermalPoliciesStatusV2(ThermalPoliciesStatusEntry[] policiesStatusEntries);
    public ThermalPoliciesStatusEntry[] get_ThermalPoliciesStatusEntries();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateUsagesInfoV1 : ValueType {
    internal static int MaxNumberOfUsageEntries;
    internal StructureVersion _Version;
    internal UInt32 _Unknown;
    internal UsagesInfoEntry[] _UsagesInfoEntries;
    public Dictionary`2<UtilizationDomain, IUtilizationDomainInfo> Domains { get; }
    public IUtilizationDomainInfo GPU { get; }
    public IUtilizationDomainInfo FrameBuffer { get; }
    public IUtilizationDomainInfo VideoEngine { get; }
    public IUtilizationDomainInfo BusInterface { get; }
    public sealed virtual Dictionary`2<UtilizationDomain, IUtilizationDomainInfo> get_Domains();
    public sealed virtual IUtilizationDomainInfo get_GPU();
    public sealed virtual IUtilizationDomainInfo get_FrameBuffer();
    public sealed virtual IUtilizationDomainInfo get_VideoEngine();
    public sealed virtual IUtilizationDomainInfo get_BusInterface();
    public virtual string ToString();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateVFPCurveV1 : ValueType {
    internal static int MaxNumberOfMasks;
    internal static int MaxNumberOfUnknown1;
    internal static int MaxNumberOfGPUCurveEntries;
    internal static int MaxNumberOfMemoryCurveEntries;
    internal static int MaxNumberOfUnknown2;
    internal StructureVersion _Version;
    internal UInt32[] _Masks;
    internal UInt32[] _Unknown1;
    internal VFPCurveEntry[] _GPUCurveEntries;
    internal VFPCurveEntry[] _MemoryCurveEntries;
    internal UInt32[] _Unknown2;
    public VFPCurveEntry[] GPUCurveEntries { get; }
    public VFPCurveEntry[] MemoryCurveEntries { get; }
    public VFPCurveEntry[] get_GPUCurveEntries();
    public VFPCurveEntry[] get_MemoryCurveEntries();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateVoltageBoostPercentV1 : ValueType {
    internal static int MaxNumberOfUnknown;
    internal StructureVersion _Version;
    internal UInt32 _Percent;
    internal UInt32[] _Unknown;
    public UInt32 Percent { get; }
    public PrivateVoltageBoostPercentV1(UInt32 percent);
    public UInt32 get_Percent();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.PrivateVoltageStatusV1 : ValueType {
    internal static int MaxNumberOfUnknown2;
    internal static int MaxNumberOfUnknown3;
    internal StructureVersion _Version;
    internal UInt32 _Unknown1;
    internal UInt32[] _Unknown2;
    internal UInt32 _ValueInuV;
    internal UInt32[] _Unknown3;
    public UInt32 ValueInMicroVolt { get; }
    public UInt32 get_ValueInMicroVolt();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.QueryIlluminationSupportParameterV1 : ValueType {
    internal StructureVersion _Version;
    internal PhysicalGPUHandle _GPUHandle;
    internal IlluminationAttribute _Attribute;
    internal UInt32 _IsSupported;
    public PhysicalGPUHandle PhysicalGPUHandle { get; }
    public IlluminationAttribute Attribute { get; }
    public bool IsSupported { get; }
    public QueryIlluminationSupportParameterV1(PhysicalGPUHandle gpuHandle, IlluminationAttribute attribute);
    public PhysicalGPUHandle get_PhysicalGPUHandle();
    public IlluminationAttribute get_Attribute();
    public bool get_IsSupported();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.SetIlluminationParameterV1 : ValueType {
    internal StructureVersion _Version;
    internal PhysicalGPUHandle _GPUHandle;
    internal IlluminationAttribute _Attribute;
    internal UInt32 _ValueInPercentage;
    public PhysicalGPUHandle PhysicalGPUHandle { get; }
    public IlluminationAttribute Attribute { get; }
    public UInt32 ValueInPercentage { get; }
    public SetIlluminationParameterV1(PhysicalGPUHandle gpuHandle, IlluminationAttribute attribute, UInt32 valueInPercentage);
    public PhysicalGPUHandle get_PhysicalGPUHandle();
    public IlluminationAttribute get_Attribute();
    public UInt32 get_ValueInPercentage();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.GPU.Structures.ThermalSettingsV1 : ValueType {
    internal static int MaxThermalSensorsPerGPU;
    internal StructureVersion _Version;
    internal UInt32 _Count;
    internal ThermalSensor[] _Sensors;
    public IThermalSensor[] Sensors { get; }
    public sealed virtual IThermalSensor[] get_Sensors();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.GPU.Structures.ThermalSettingsV2 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Count;
    internal ThermalSensor[] _Sensors;
    public IThermalSensor[] Sensors { get; }
    public sealed virtual IThermalSensor[] get_Sensors();
}
public enum NvAPIWrapper.Native.GPU.SystemType : Enum {
    public int value__;
    public static SystemType Unknown;
    public static SystemType Laptop;
    public static SystemType Desktop;
}
public enum NvAPIWrapper.Native.GPU.ThermalController : Enum {
    public int value__;
    public static ThermalController None;
    public static ThermalController GPU;
    public static ThermalController ADM1032;
    public static ThermalController MAX6649;
    public static ThermalController MAX1617;
    public static ThermalController LM99;
    public static ThermalController LM89;
    public static ThermalController LM64;
    public static ThermalController ADT7473;
    public static ThermalController SBMAX6649;
    public static ThermalController VideoBiosEvent;
    public static ThermalController OperatingSystem;
    public static ThermalController Unknown;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.GPU.ThermalSettingsTarget : Enum {
    public int value__;
    public static ThermalSettingsTarget None;
    public static ThermalSettingsTarget GPU;
    public static ThermalSettingsTarget Memory;
    public static ThermalSettingsTarget PowerSupply;
    public static ThermalSettingsTarget Board;
    public static ThermalSettingsTarget VisualComputingBoard;
    public static ThermalSettingsTarget VisualComputingInlet;
    public static ThermalSettingsTarget VisualComputingOutlet;
    public static ThermalSettingsTarget All;
    public static ThermalSettingsTarget Unknown;
}
public enum NvAPIWrapper.Native.GPU.UtilizationDomain : Enum {
    public int value__;
    public static UtilizationDomain GPU;
    public static UtilizationDomain FrameBuffer;
    public static UtilizationDomain VideoEngine;
    public static UtilizationDomain BusInterface;
}
public static class NvAPIWrapper.Native.GPUApi : object {
    public static LogicalGPUHandle[] EnumLogicalGPUs();
    public static PhysicalGPUHandle[] EnumPhysicalGPUs();
    public static PhysicalGPUHandle[] EnumTCCPhysicalGPUs();
    public static int GetAGPAperture(PhysicalGPUHandle gpuHandle);
    public static PrivateArchitectInfoV2 GetArchitectInfo(PhysicalGPUHandle gpuHandle);
    public static BoardInfo GetBoardInfo(PhysicalGPUHandle gpuHandle);
    public static int GetBusId(PhysicalGPUHandle gpuHandle);
    public static int GetBusSlotId(PhysicalGPUHandle gpuHandle);
    public static GPUBusType GetBusType(PhysicalGPUHandle gpuHandle);
    public static int GetCurrentAGPRate(PhysicalGPUHandle gpuHandle);
    public static int GetCurrentPCIEDownStreamWidth(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetDriverModel(PhysicalGPUHandle gpuHandle);
    public static ECCConfigurationInfoV1 GetECCConfigurationInfo(PhysicalGPUHandle gpuHandle);
    public static ECCErrorInfoV1 GetECCErrorInfo(PhysicalGPUHandle gpuHandle);
    public static ECCStatusInfoV1 GetECCStatusInfo(PhysicalGPUHandle gpuHandle);
    public static GPUFoundry GetFoundry(PhysicalGPUHandle gpuHandle);
    public static void GetFrameBufferWidthAndLocation(PhysicalGPUHandle gpuHandle, UInt32& width, UInt32& location);
    public static string GetFullName(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetGPUCoreCount(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetGPUIDFromPhysicalGPU(PhysicalGPUHandle gpuHandle);
    public static GPUType GetGPUType(PhysicalGPUHandle gpuHandle);
    public static int GetIRQ(PhysicalGPUHandle gpuHandle);
    public static void GetLogicalFrameBufferWidthAndLocation(LogicalGPUHandle gpuHandle, UInt32& width, UInt32& location);
    public static LogicalGPUHandle GetLogicalGPUFromPhysicalGPU(PhysicalGPUHandle gpuHandle);
    public static IDisplayDriverMemoryInfo GetMemoryInfo(PhysicalGPUHandle physicalGPUHandle);
    public static UInt32 GetPartitionCount(PhysicalGPUHandle gpuHandle);
    public static PrivatePCIeInfoV2 GetPCIEInfo(PhysicalGPUHandle gpuHandle);
    public static void GetPCIIdentifiers(PhysicalGPUHandle gpuHandle, UInt32& deviceId, UInt32& subSystemId, UInt32& revisionId, UInt32& extDeviceId);
    public static int GetPhysicalFrameBufferSize(PhysicalGPUHandle gpuHandle);
    public static PhysicalGPUHandle GetPhysicalGPUFromGPUID(UInt32 gpuId);
    public static PhysicalGPUHandle[] GetPhysicalGPUsFromLogicalGPU(LogicalGPUHandle gpuHandle);
    public static bool GetQuadroStatus(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetRAMBankCount(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetRAMBusWidth(PhysicalGPUHandle gpuHandle);
    public static GPUMemoryMaker GetRAMMaker(PhysicalGPUHandle gpuHandle);
    public static GPUMemoryType GetRAMType(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetROPCount(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetShaderPipeCount(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetShaderSubPipeCount(PhysicalGPUHandle gpuHandle);
    public static string GetShortName(PhysicalGPUHandle gpuHandle);
    public static SystemType GetSystemType(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetTotalSMCount(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetTotalSPCount(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetTotalTPCCount(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetVBIOSOEMRevision(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetVBIOSRevision(PhysicalGPUHandle gpuHandle);
    public static string GetVBIOSVersionString(PhysicalGPUHandle gpuHandle);
    public static int GetVirtualFrameBufferSize(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetVPECount(PhysicalGPUHandle gpuHandle);
    public static void I2CRead(PhysicalGPUHandle gpuHandle, TI2CInfo& i2cInfo);
    public static void I2CRead(PhysicalGPUHandle gpuHandle, II2CInfo& i2cInfo);
    public static void I2CWrite(PhysicalGPUHandle gpuHandle, II2CInfo i2cInfo);
    public static void ResetECCErrorInfo(PhysicalGPUHandle gpuHandle, bool resetCurrent, bool resetAggregated);
    public static void SetECCConfiguration(PhysicalGPUHandle gpuHandle, bool isEnable, bool isEnableImmediately);
    public static OutputId GetActiveOutputs(PhysicalGPUHandle gpuHandle);
    public static DisplayIdsV2[] GetAllDisplayIds(PhysicalGPUHandle gpuHandle);
    public static DisplayIdsV2[] GetConnectedDisplayIds(PhysicalGPUHandle gpuHandle, ConnectedIdsFlag flags);
    public static UInt32 GetDisplayIdFromGPUAndOutputId(PhysicalGPUHandle gpuHandle, OutputId outputId);
    public static EDIDV3 GetEDID(PhysicalGPUHandle gpuHandle, OutputId outputId, int offset, int readIdentification);
    public static IEDID GetEDID(PhysicalGPUHandle gpuHandle, OutputId outputId);
    public static OutputId GetGPUAndOutputIdFromDisplayId(UInt32 displayId, PhysicalGPUHandle& gpuHandle);
    public static LogicalGPUHandle GetLogicalGPUFromDisplay(DisplayHandle display);
    public static OutputType GetOutputType(PhysicalGPUHandle gpuHandle, OutputId outputId);
    public static OutputType GetOutputType(PhysicalGPUHandle gpuHandle, UInt32 displayId);
    public static PhysicalGPUHandle GetPhysicalGPUFromDisplayId(UInt32 displayId);
    public static PhysicalGPUHandle GetPhysicalGPUFromUnAttachedDisplay(UnAttachedDisplayHandle display);
    public static PhysicalGPUHandle[] GetPhysicalGPUsFromDisplay(DisplayHandle display);
    public static void SetEDID(PhysicalGPUHandle gpuHandle, OutputId outputId, IEDID edid);
    public static void SetEDID(PhysicalGPUHandle gpuHandle, UInt32 displayId, IEDID edid);
    public static bool ValidateOutputCombination(PhysicalGPUHandle gpuHandle, OutputId outputIds);
    public static IlluminationDeviceControlParametersV1 ClientIlluminationDevicesGetControl(PhysicalGPUHandle gpuHandle);
    public static IlluminationDeviceInfoParametersV1 ClientIlluminationDevicesGetInfo(PhysicalGPUHandle gpuHandle);
    public static void ClientIlluminationDevicesSetControl(PhysicalGPUHandle gpuHandle, IlluminationDeviceControlParametersV1 deviceControlParameters);
    public static IlluminationZoneControlParametersV1 ClientIlluminationZonesGetControl(PhysicalGPUHandle gpuHandle, IlluminationZoneControlValuesType valuesType);
    public static IlluminationZoneInfoParametersV1 ClientIlluminationZonesGetInfo(PhysicalGPUHandle gpuHandle);
    public static void ClientIlluminationZonesSetControl(PhysicalGPUHandle gpuHandle, IlluminationZoneControlParametersV1 zoneControlParameters);
    public static UInt32 GetIllumination(PhysicalGPUHandle gpuHandle, IlluminationAttribute attribute);
    public static bool QueryIlluminationSupport(PhysicalGPUHandle gpuHandle, IlluminationAttribute attribute);
    public static void SetIllumination(PhysicalGPUHandle gpuHandle, IlluminationAttribute attribute, UInt32 valueInPercentage);
    public static void EnableOverclockedPStates(PhysicalGPUHandle gpuHandle);
    public static IClockFrequencies GetAllClockFrequencies(PhysicalGPUHandle physicalGPUHandle, IClockFrequencies clockFrequencyOptions);
    public static PrivateClockBoostLockV2 GetClockBoostLock(PhysicalGPUHandle gpuHandle);
    public static PrivateClockBoostMasksV1 GetClockBoostMask(PhysicalGPUHandle gpuHandle);
    public static PrivateClockBoostRangesV1 GetClockBoostRanges(PhysicalGPUHandle gpuHandle);
    public static PrivateClockBoostTableV1 GetClockBoostTable(PhysicalGPUHandle gpuHandle);
    public static PrivateVoltageBoostPercentV1 GetCoreVoltageBoostPercent(PhysicalGPUHandle gpuHandle);
    public static PerformanceStateId GetCurrentPerformanceState(PhysicalGPUHandle gpuHandle);
    public static PrivateVoltageStatusV1 GetCurrentVoltage(PhysicalGPUHandle gpuHandle);
    public static IPerformanceStatesInfo GetPerformanceStates(PhysicalGPUHandle physicalGPUHandle, GetPerformanceStatesInfoFlags flags);
    public static IPerformanceStates20Info GetPerformanceStates20(PhysicalGPUHandle physicalGPUHandle);
    public static PrivateVFPCurveV1 GetVFPCurve(PhysicalGPUHandle gpuHandle);
    public static PrivatePerformanceInfoV1 PerformancePoliciesGetInfo(PhysicalGPUHandle gpuHandle);
    public static PrivatePerformanceStatusV1 PerformancePoliciesGetStatus(PhysicalGPUHandle gpuHandle);
    public static void SetClockBoostLock(PhysicalGPUHandle gpuHandle, PrivateClockBoostLockV2 clockBoostLock);
    public static void SetClockBoostTable(PhysicalGPUHandle gpuHandle, PrivateClockBoostTableV1 clockBoostTable);
    public static void SetCoreVoltageBoostPercent(PhysicalGPUHandle gpuHandle, PrivateVoltageBoostPercentV1 boostPercent);
    public static void SetPerformanceStates20(PhysicalGPUHandle physicalGPUHandle, IPerformanceStates20Info performanceStates20Info);
    public static PrivatePowerPoliciesInfoV1 ClientPowerPoliciesGetInfo(PhysicalGPUHandle gpuHandle);
    public static PrivatePowerPoliciesStatusV1 ClientPowerPoliciesGetStatus(PhysicalGPUHandle gpuHandle);
    public static void ClientPowerPoliciesSetStatus(PhysicalGPUHandle gpuHandle, PrivatePowerPoliciesStatusV1 policiesStatus);
    public static PrivatePowerTopologiesStatusV1 ClientPowerTopologyGetStatus(PhysicalGPUHandle gpuHandle);
    public static PrivateCoolerPolicyTableV1 GetCoolerPolicyTable(PhysicalGPUHandle gpuHandle, CoolerPolicy policy, UInt32 index, UInt32& count);
    public static PrivateCoolerSettingsV1 GetCoolerSettings(PhysicalGPUHandle gpuHandle, CoolerTarget coolerTarget);
    public static UInt32 GetCurrentFanSpeedLevel(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetCurrentThermalLevel(PhysicalGPUHandle gpuHandle);
    public static UInt32 GetTachReading(PhysicalGPUHandle gpuHandle);
    public static PrivateThermalPoliciesInfoV2 GetThermalPoliciesInfo(PhysicalGPUHandle gpuHandle);
    public static PrivateThermalPoliciesStatusV2 GetThermalPoliciesStatus(PhysicalGPUHandle gpuHandle);
    public static IThermalSettings GetThermalSettings(PhysicalGPUHandle physicalGPUHandle, ThermalSettingsTarget sensorTarget);
    public static void RestoreCoolerPolicyTable(PhysicalGPUHandle gpuHandle, CoolerPolicy policy, UInt32[] indexes);
    public static void RestoreCoolerSettings(PhysicalGPUHandle gpuHandle, UInt32[] indexes);
    public static void SetCoolerLevels(PhysicalGPUHandle gpuHandle, UInt32 index, PrivateCoolerLevelsV1 coolerLevels, UInt32 levelsCount);
    public static void SetCoolerPolicyTable(PhysicalGPUHandle gpuHandle, UInt32 index, PrivateCoolerPolicyTableV1 coolerPolicyTable, UInt32 policyLevelsCount);
    public static void SetThermalPoliciesStatus(PhysicalGPUHandle gpuHandle, PrivateThermalPoliciesStatusV2 thermalPoliciesStatus);
    public static PrivateFanCoolersInfoV1 GetClientFanCoolersInfo(PhysicalGPUHandle gpuHandle);
    public static PrivateFanCoolersStatusV1 GetClientFanCoolersStatus(PhysicalGPUHandle gpuHandle);
    public static PrivateFanCoolersControlV1 GetClientFanCoolersControl(PhysicalGPUHandle gpuHandle);
    public static void SetClientFanCoolersControl(PhysicalGPUHandle gpuHandle, PrivateFanCoolersControlV1 control);
    public static void EnableDynamicPStates(PhysicalGPUHandle gpuHandle);
    public static DynamicPerformanceStatesInfoV1 GetDynamicPerformanceStatesInfoEx(PhysicalGPUHandle physicalGPUHandle);
    public static PerformanceDecreaseReason GetPerformanceDecreaseInfo(PhysicalGPUHandle gpuHandle);
    public static PrivateUsagesInfoV1 GetUsages(PhysicalGPUHandle gpuHandle);
    public static PrivateActiveApplicationV2[] QueryActiveApps(PhysicalGPUHandle gpuHandle);
}
internal static class NvAPIWrapper.Native.Helpers.DelegateFactory : object {
    private static Dictionary`2<KeyValuePair`2<FunctionId, Type>, object> Delegates;
    private static DelegateFactory();
    public static T GetDelegate();
    private static IntPtr NvAPI_QueryInterface(UInt32 interfaceId);
    private static IntPtr NvAPI32_QueryInterface(UInt32 interfaceId);
    private static IntPtr NvAPI64_QueryInterface(UInt32 interfaceId);
}
[ExtensionAttribute]
internal static class NvAPIWrapper.Native.Helpers.ExtensionMethods : object {
    [ExtensionAttribute]
public static Type[] Accepts(Delegate delegate, int parameterIndex);
    [IteratorStateMachineAttribute("NvAPIWrapper.Native.Helpers.ExtensionMethods/<AllocateAll>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> AllocateAll(IEnumerable`1<T> allocatableArray);
    public static TResult BitWiseConvert(T source);
    [ExtensionAttribute]
public static void DisposeAll(IEnumerable`1<T> disposableArray);
    [ExtensionAttribute]
public static bool GetBit(T integer, int index);
    [ExtensionAttribute]
public static ulong GetBits(T integer, int index, int count);
    [ExtensionAttribute]
public static T Instantiate(Type type);
    [ExtensionAttribute]
public static T[] Repeat(T structure, int count);
    [ExtensionAttribute]
public static T SetBit(T integer, int index, bool value);
    [ExtensionAttribute]
public static T SetBits(T integer, int index, int count, ulong value);
    [ExtensionAttribute]
public static Byte[] ToByteArray(T structure);
    [ExtensionAttribute]
public static T ToStructure(Byte[] byteArray);
}
internal enum NvAPIWrapper.Native.Helpers.FunctionId : Enum {
    public UInt32 value__;
    public static FunctionId NvAPI_CreateDisplayFromUnAttachedDisplay;
    public static FunctionId NvAPI_D3D_BeginResourceRendering;
    public static FunctionId NvAPI_D3D_ConfigureAnsel;
    public static FunctionId NvAPI_D3D_CreateLateLatchObject;
    public static FunctionId NvAPI_D3D_EndResourceRendering;
    public static FunctionId NvAPI_D3D_GetCurrentSLIState;
    public static FunctionId NvAPI_D3D_GetObjectHandleForResource;
    public static FunctionId NvAPI_D3D_ImplicitSLIControl;
    public static FunctionId NvAPI_D3D_InitializeSMPAssist;
    public static FunctionId NvAPI_D3D_IsGSyncActive;
    public static FunctionId NvAPI_D3D_IsGSyncCapable;
    public static FunctionId NvAPI_D3D_QueryLateLatchSupport;
    public static FunctionId NvAPI_D3D_QueryModifiedWSupport;
    public static FunctionId NvAPI_D3D_QueryMultiViewSupport;
    public static FunctionId NvAPI_D3D_QuerySinglePassStereoSupport;
    public static FunctionId NvAPI_D3D_QuerySMPAssistSupport;
    public static FunctionId NvAPI_D3D_RegisterDevice;
    public static FunctionId NvAPI_D3D_SetFPSIndicatorState;
    public static FunctionId NvAPI_D3D_SetModifiedWMode;
    public static FunctionId NvAPI_D3D_SetMultiViewMode;
    public static FunctionId NvAPI_D3D_SetResourceHint;
    public static FunctionId NvAPI_D3D_SetSinglePassStereoMode;
    public static FunctionId NvAPI_D3D10_SetDepthBoundsTest;
    public static FunctionId NvAPI_D3D11_AliasMSAATexture2DAsNonMSAA;
    public static FunctionId NvAPI_D3D11_BeginUAVOverlap;
    public static FunctionId NvAPI_D3D11_BeginUAVOverlapEx;
    public static FunctionId NvAPI_D3D11_CopyTileMappings;
    public static FunctionId NvAPI_D3D11_CreateDevice;
    public static FunctionId NvAPI_D3D11_CreateDeviceAndSwapChain;
    public static FunctionId NvAPI_D3D11_CreateDomainShaderEx;
    public static FunctionId NvAPI_D3D11_CreateFastGeometryShader;
    public static FunctionId NvAPI_D3D11_CreateFastGeometryShaderExplicit;
    public static FunctionId NvAPI_D3D11_CreateGeometryShaderEx_2;
    public static FunctionId NvAPI_D3D11_CreateHullShaderEx;
    public static FunctionId NvAPI_D3D11_CreateMultiGPUDevice;
    public static FunctionId NvAPI_D3D11_CreatePixelShaderEx_2;
    public static FunctionId NvAPI_D3D11_CreateRasterizerState;
    public static FunctionId NvAPI_D3D11_CreateShadingRateResourceView;
    public static FunctionId NvAPI_D3D11_CreateTiledTexture2DArray;
    public static FunctionId NvAPI_D3D11_CreateVertexShaderEx;
    public static FunctionId NvAPI_D3D11_EndUAVOverlap;
    public static FunctionId NvAPI_D3D11_IsNvShaderExtnOpCodeSupported;
    public static FunctionId NvAPI_D3D11_MultiDrawIndexedInstancedIndirect;
    public static FunctionId NvAPI_D3D11_MultiDrawInstancedIndirect;
    public static FunctionId NvAPI_D3D11_MultiGPU_GetCaps;
    public static FunctionId NvAPI_D3D11_MultiGPU_Init;
    public static FunctionId NvAPI_D3D11_RSGetPixelShadingRateSampleOrder;
    public static FunctionId NvAPI_D3D11_RSSetExclusiveScissorRects;
    public static FunctionId NvAPI_D3D11_RSSetPixelShadingRateSampleOrder;
    public static FunctionId NvAPI_D3D11_RSSetShadingRateResourceView;
    public static FunctionId NvAPI_D3D11_RSSetViewportsPixelShadingRates;
    public static FunctionId NvAPI_D3D11_SetDepthBoundsTest;
    public static FunctionId NvAPI_D3D11_SetNvShaderExtnSlot;
    public static FunctionId NvAPI_D3D11_SetNvShaderExtnSlotLocalThread;
    public static FunctionId NvAPI_D3D11_TiledResourceBarrier;
    public static FunctionId NvAPI_D3D11_TiledTexture2DArrayGetDesc;
    public static FunctionId NvAPI_D3D11_UpdateTileMappings;
    public static FunctionId NvAPI_D3D12_CopyTileMappings;
    public static FunctionId NvAPI_D3D12_CreateComputePipelineState;
    public static FunctionId NvAPI_D3D12_CreateGraphicsPipelineState;
    public static FunctionId NvAPI_D3D12_CreateHeap;
    public static FunctionId NvAPI_D3D12_CreateReservedResource;
    public static FunctionId NvAPI_D3D12_IsNvShaderExtnOpCodeSupported;
    public static FunctionId NvAPI_D3D12_Mosaic_GetCompanionAllocations;
    public static FunctionId NvAPI_D3D12_Mosaic_GetViewportAndGpuPartitions;
    public static FunctionId NvAPI_D3D12_QueryModifiedWSupport;
    public static FunctionId NvAPI_D3D12_QuerySinglePassStereoSupport;
    public static FunctionId NvAPI_D3D12_ReservedResourceGetDesc;
    public static FunctionId NvAPI_D3D12_ResourceAliasingBarrier;
    public static FunctionId NvAPI_D3D12_SetDepthBoundsTestValues;
    public static FunctionId NvAPI_D3D12_SetModifiedWMode;
    public static FunctionId NvAPI_D3D12_SetSinglePassStereoMode;
    public static FunctionId NvAPI_D3D12_UpdateTileMappings;
    public static FunctionId NvAPI_D3D12_UseDriverHeapPriorities;
    public static FunctionId NvAPI_D3D1x_CreateSwapChain;
    public static FunctionId NvAPI_D3D1x_DisableShaderDiskCache;
    public static FunctionId NvAPI_D3D1x_GetGraphicsCapabilities;
    public static FunctionId NvAPI_D3D9_AliasSurfaceAsTexture;
    public static FunctionId NvAPI_D3D9_ClearRT;
    public static FunctionId NvAPI_D3D9_CreateSwapChain;
    public static FunctionId NvAPI_D3D9_GetSurfaceHandle;
    public static FunctionId NvAPI_D3D9_RegisterResource;
    public static FunctionId NvAPI_D3D9_StretchRectEx;
    public static FunctionId NvAPI_D3D9_UnregisterResource;
    public static FunctionId NvAPI_D3D9_VideoSetStereoInfo;
    public static FunctionId NvAPI_DisableHWCursor;
    public static FunctionId NvAPI_Disp_ColorControl;
    public static FunctionId NvAPI_DISP_DeleteCustomDisplay;
    public static FunctionId NvAPI_DISP_EnumCustomDisplay;
    public static FunctionId NvAPI_DISP_GetAssociatedUnAttachedNvidiaDisplayHandle;
    public static FunctionId NvAPI_DISP_GetDisplayConfig;
    public static FunctionId NvAPI_DISP_GetDisplayIdByDisplayName;
    public static FunctionId NvAPI_DISP_GetGDIPrimaryDisplayId;
    public static FunctionId NvAPI_Disp_GetHdrCapabilities;
    public static FunctionId NvAPI_DISP_GetMonitorCapabilities;
    public static FunctionId NvAPI_DISP_GetMonitorColorCapabilities;
    public static FunctionId NvAPI_DISP_GetTiming;
    public static FunctionId NvAPI_Disp_HdrColorControl;
    public static FunctionId NvAPI_Disp_InfoFrameControl;
    public static FunctionId NvAPI_DISP_RevertCustomDisplayTrial;
    public static FunctionId NvAPI_DISP_SaveCustomDisplay;
    public static FunctionId NvAPI_DISP_SetDisplayConfig;
    public static FunctionId NvAPI_DISP_TryCustomDisplay;
    public static FunctionId NvAPI_DRS_CreateApplication;
    public static FunctionId NvAPI_DRS_CreateProfile;
    public static FunctionId NvAPI_DRS_CreateSession;
    public static FunctionId NvAPI_DRS_DeleteApplication;
    public static FunctionId NvAPI_DRS_DeleteApplicationEx;
    public static FunctionId NvAPI_DRS_DeleteProfile;
    public static FunctionId NvAPI_DRS_DeleteProfileSetting;
    public static FunctionId NvAPI_DRS_DestroySession;
    public static FunctionId NvAPI_DRS_EnumApplications;
    public static FunctionId NvAPI_DRS_EnumAvailableSettingIds;
    public static FunctionId NvAPI_DRS_EnumAvailableSettingValues;
    public static FunctionId NvAPI_DRS_EnumProfiles;
    public static FunctionId NvAPI_DRS_EnumSettings;
    public static FunctionId NvAPI_DRS_FindApplicationByName;
    public static FunctionId NvAPI_DRS_FindProfileByName;
    public static FunctionId NvAPI_DRS_GetApplicationInfo;
    public static FunctionId NvAPI_DRS_GetBaseProfile;
    public static FunctionId NvAPI_DRS_GetCurrentGlobalProfile;
    public static FunctionId NvAPI_DRS_GetNumProfiles;
    public static FunctionId NvAPI_DRS_GetProfileInfo;
    public static FunctionId NvAPI_DRS_GetSetting;
    public static FunctionId NvAPI_DRS_GetSettingIdFromName;
    public static FunctionId NvAPI_DRS_GetSettingNameFromId;
    public static FunctionId NvAPI_DRS_LoadSettings;
    public static FunctionId NvAPI_DRS_LoadSettingsFromFile;
    public static FunctionId NvAPI_DRS_RestoreAllDefaults;
    public static FunctionId NvAPI_DRS_RestoreProfileDefault;
    public static FunctionId NvAPI_DRS_RestoreProfileDefaultSetting;
    public static FunctionId NvAPI_DRS_SaveSettings;
    public static FunctionId NvAPI_DRS_SaveSettingsToFile;
    public static FunctionId NvAPI_DRS_SetCurrentGlobalProfile;
    public static FunctionId NvAPI_DRS_SetProfileInfo;
    public static FunctionId NvAPI_DRS_SetSetting;
    public static FunctionId NvAPI_EnableCurrentMosaicTopology;
    public static FunctionId NvAPI_EnableHWCursor;
    public static FunctionId NvAPI_EnumLogicalGPUs;
    public static FunctionId NvAPI_EnumNvidiaDisplayHandle;
    public static FunctionId NvAPI_EnumNvidiaUnAttachedDisplayHandle;
    public static FunctionId NvAPI_EnumPhysicalGPUs;
    public static FunctionId NvAPI_EnumTCCPhysicalGPUs;
    public static FunctionId NvAPI_GetAssociatedDisplayOutputId;
    public static FunctionId NvAPI_GetAssociatedNvidiaDisplayHandle;
    public static FunctionId NvAPI_GetAssociatedNvidiaDisplayName;
    public static FunctionId NvAPI_GetCurrentMosaicTopology;
    public static FunctionId NvAPI_GetDisplayDriverVersion;
    public static FunctionId NvAPI_GetDisplayPortInfo;
    public static FunctionId NvAPI_GetErrorMessage;
    public static FunctionId NvAPI_GetHDMISupportInfo;
    public static FunctionId NvAPI_GetInterfaceVersionString;
    public static FunctionId NvAPI_GetLogicalGPUFromDisplay;
    public static FunctionId NvAPI_GetLogicalGPUFromPhysicalGPU;
    public static FunctionId NvAPI_GetPhysicalGPUFromUnAttachedDisplay;
    public static FunctionId NvAPI_GetPhysicalGPUsFromDisplay;
    public static FunctionId NvAPI_GetPhysicalGPUsFromLogicalGPU;
    public static FunctionId NvAPI_GetSupportedMosaicTopologies;
    public static FunctionId NvAPI_GetSupportedViews;
    public static FunctionId NvAPI_GetUnAttachedAssociatedDisplayName;
    public static FunctionId NvAPI_GetVBlankCounter;
    public static FunctionId NvAPI_GetView;
    public static FunctionId NvAPI_GetViewEx;
    public static FunctionId NvAPI_GPU_ClientIllumDevicesGetControl;
    public static FunctionId NvAPI_GPU_ClientIllumDevicesGetInfo;
    public static FunctionId NvAPI_GPU_ClientIllumDevicesSetControl;
    public static FunctionId NvAPI_GPU_ClientIllumZonesGetControl;
    public static FunctionId NvAPI_GPU_ClientIllumZonesGetInfo;
    public static FunctionId NvAPI_GPU_ClientIllumZonesSetControl;
    public static FunctionId NvAPI_GPU_GetActiveOutputs;
    public static FunctionId NvAPI_GPU_GetAGPAperture;
    public static FunctionId NvAPI_GPU_GetAllClockFrequencies;
    public static FunctionId NvAPI_GPU_GetAllDisplayIds;
    public static FunctionId NvAPI_GPU_GetAllOutputs;
    public static FunctionId NvAPI_GPU_GetBoardInfo;
    public static FunctionId NvAPI_GPU_GetBusId;
    public static FunctionId NvAPI_GPU_GetBusSlotId;
    public static FunctionId NvAPI_GPU_GetBusType;
    public static FunctionId NvAPI_GPU_GetConnectedDisplayIds;
    public static FunctionId NvAPI_GPU_GetConnectedOutputs;
    public static FunctionId NvAPI_GPU_GetConnectedOutputsWithLidState;
    public static FunctionId NvAPI_GPU_GetConnectedSLIOutputs;
    public static FunctionId NvAPI_GPU_GetConnectedSLIOutputsWithLidState;
    public static FunctionId NvAPI_GPU_GetCurrentAGPRate;
    public static FunctionId NvAPI_GPU_GetCurrentPCIEDownstreamWidth;
    public static FunctionId NvAPI_GPU_GetCurrentPstate;
    public static FunctionId NvAPI_GPU_GetDynamicPstatesInfoEx;
    public static FunctionId NvAPI_GPU_GetECCConfigurationInfo;
    public static FunctionId NvAPI_GPU_GetECCErrorInfo;
    public static FunctionId NvAPI_GPU_GetECCStatusInfo;
    public static FunctionId NvAPI_GPU_GetEDID;
    public static FunctionId NvAPI_GPU_GetFullName;
    public static FunctionId NvAPI_GPU_GetGpuCoreCount;
    public static FunctionId NvAPI_GPU_GetGPUType;
    public static FunctionId NvAPI_GPU_GetHDCPSupportStatus;
    public static FunctionId NvAPI_GPU_GetIllumination;
    public static FunctionId NvAPI_GPU_GetIRQ;
    public static FunctionId NvAPI_GPU_GetMemoryInfo;
    public static FunctionId NvAPI_GPU_GetOutputType;
    public static FunctionId NvAPI_GPU_GetPCIIdentifiers;
    public static FunctionId NvAPI_GPU_GetPerfDecreaseInfo;
    public static FunctionId NvAPI_GPU_GetPhysicalFrameBufferSize;
    public static FunctionId NvAPI_GPU_GetPstates20;
    public static FunctionId NvAPI_GPU_GetPstatesInfoEx;
    public static FunctionId NvAPI_GPU_GetQuadroStatus;
    public static FunctionId NvAPI_GPU_GetScanoutCompositionParameter;
    public static FunctionId NvAPI_GPU_GetScanoutConfiguration;
    public static FunctionId NvAPI_GPU_GetScanoutConfigurationEx;
    public static FunctionId NvAPI_GPU_GetScanoutIntensityState;
    public static FunctionId NvAPI_GPU_GetScanoutWarpingState;
    public static FunctionId NvAPI_GPU_GetShaderSubPipeCount;
    public static FunctionId NvAPI_GPU_GetSystemType;
    public static FunctionId NvAPI_GPU_GetTachReading;
    public static FunctionId NvAPI_GPU_GetThermalSettings;
    public static FunctionId NvAPI_GPU_GetVbiosOEMRevision;
    public static FunctionId NvAPI_GPU_GetVbiosRevision;
    public static FunctionId NvAPI_GPU_GetVbiosVersionString;
    public static FunctionId NvAPI_GPU_GetVirtualFrameBufferSize;
    public static FunctionId NvAPI_GPU_QueryIlluminationSupport;
    public static FunctionId NvAPI_GPU_ResetECCErrorInfo;
    public static FunctionId NvAPI_GPU_SetECCConfiguration;
    public static FunctionId NvAPI_GPU_SetEDID;
    public static FunctionId NvAPI_GPU_SetIllumination;
    public static FunctionId NvAPI_GPU_SetScanoutCompositionParameter;
    public static FunctionId NvAPI_GPU_SetScanoutIntensity;
    public static FunctionId NvAPI_GPU_SetScanoutWarping;
    public static FunctionId NvAPI_GPU_ValidateOutputCombination;
    public static FunctionId NvAPI_GPU_WorkstationFeatureQuery;
    public static FunctionId NvAPI_GPU_WorkstationFeatureSetup;
    public static FunctionId NvAPI_GSync_AdjustSyncDelay;
    public static FunctionId NvAPI_GSync_EnumSyncDevices;
    public static FunctionId NvAPI_GSync_GetControlParameters;
    public static FunctionId NvAPI_GSync_GetStatusParameters;
    public static FunctionId NvAPI_GSync_GetSyncStatus;
    public static FunctionId NvAPI_GSync_GetTopology;
    public static FunctionId NvAPI_GSync_QueryCapabilities;
    public static FunctionId NvAPI_GSync_SetControlParameters;
    public static FunctionId NvAPI_GSync_SetSyncStateSettings;
    public static FunctionId NvAPI_I2CRead;
    public static FunctionId NvAPI_I2CWrite;
    public static FunctionId NvAPI_Mosaic_EnableCurrentTopo;
    public static FunctionId NvAPI_Mosaic_EnumDisplayGrids;
    public static FunctionId NvAPI_Mosaic_EnumDisplayModes;
    public static FunctionId NvAPI_Mosaic_GetCurrentTopo;
    public static FunctionId NvAPI_Mosaic_GetDisplayViewportsByResolution;
    public static FunctionId NvAPI_Mosaic_GetOverlapLimits;
    public static FunctionId NvAPI_Mosaic_GetSupportedTopoInfo;
    public static FunctionId NvAPI_Mosaic_GetTopoGroup;
    public static FunctionId NvAPI_Mosaic_SetCurrentTopo;
    public static FunctionId NvAPI_Mosaic_SetDisplayGrids;
    public static FunctionId NvAPI_Mosaic_ValidateDisplayGrids;
    public static FunctionId NvAPI_OGL_ExpertModeDefaultsGet;
    public static FunctionId NvAPI_OGL_ExpertModeDefaultsSet;
    public static FunctionId NvAPI_OGL_ExpertModeGet;
    public static FunctionId NvAPI_OGL_ExpertModeSet;
    public static FunctionId NvAPI_SetCurrentMosaicTopology;
    public static FunctionId NvAPI_SetDisplayPort;
    public static FunctionId NvAPI_SetRefreshRateOverride;
    public static FunctionId NvAPI_SetView;
    public static FunctionId NvAPI_SetViewEx;
    public static FunctionId NvAPI_Stereo_Activate;
    public static FunctionId NvAPI_Stereo_CaptureJpegImage;
    public static FunctionId NvAPI_Stereo_CapturePngImage;
    public static FunctionId NvAPI_Stereo_CreateConfigurationProfileRegistryKey;
    public static FunctionId NvAPI_Stereo_CreateHandleFromIUnknown;
    public static FunctionId NvAPI_Stereo_Deactivate;
    public static FunctionId NvAPI_Stereo_Debug_WasLastDrawStereoized;
    public static FunctionId NvAPI_Stereo_DecreaseConvergence;
    public static FunctionId NvAPI_Stereo_DecreaseSeparation;
    public static FunctionId NvAPI_Stereo_DeleteConfigurationProfileRegistryKey;
    public static FunctionId NvAPI_Stereo_DeleteConfigurationProfileValue;
    public static FunctionId NvAPI_Stereo_DestroyHandle;
    public static FunctionId NvAPI_Stereo_Disable;
    public static FunctionId NvAPI_Stereo_Enable;
    public static FunctionId NvAPI_Stereo_GetConvergence;
    public static FunctionId NvAPI_Stereo_GetDefaultProfile;
    public static FunctionId NvAPI_Stereo_GetEyeSeparation;
    public static FunctionId NvAPI_Stereo_GetFrustumAdjustMode;
    public static FunctionId NvAPI_Stereo_GetSeparation;
    public static FunctionId NvAPI_Stereo_GetStereoSupport;
    public static FunctionId NvAPI_Stereo_GetSurfaceCreationMode;
    public static FunctionId NvAPI_Stereo_IncreaseConvergence;
    public static FunctionId NvAPI_Stereo_IncreaseSeparation;
    public static FunctionId NvAPI_Stereo_InitActivation;
    public static FunctionId NvAPI_Stereo_IsActivated;
    public static FunctionId NvAPI_Stereo_IsEnabled;
    public static FunctionId NvAPI_Stereo_IsWindowedModeSupported;
    public static FunctionId NvAPI_Stereo_ReverseStereoBlitControl;
    public static FunctionId NvAPI_Stereo_SetActiveEye;
    public static FunctionId NvAPI_Stereo_SetConfigurationProfileValue;
    public static FunctionId NvAPI_Stereo_SetConvergence;
    public static FunctionId NvAPI_Stereo_SetDefaultProfile;
    public static FunctionId NvAPI_Stereo_SetDriverMode;
    public static FunctionId NvAPI_Stereo_SetFrustumAdjustMode;
    public static FunctionId NvAPI_Stereo_SetNotificationMessage;
    public static FunctionId NvAPI_Stereo_SetSeparation;
    public static FunctionId NvAPI_Stereo_SetSurfaceCreationMode;
    public static FunctionId NvAPI_Stereo_Trigger_Activation;
    public static FunctionId NvAPI_SYS_GetChipSetInfo;
    public static FunctionId NvAPI_SYS_GetDisplayIdFromGpuAndOutputId;
    public static FunctionId NvAPI_SYS_GetDriverAndBranchVersion;
    public static FunctionId NvAPI_SYS_GetGpuAndOutputIdFromDisplayId;
    public static FunctionId NvAPI_SYS_GetLidAndDockInfo;
    public static FunctionId NvAPI_SYS_GetPhysicalGpuFromDisplayId;
    public static FunctionId NvAPI_VIO_Close;
    public static FunctionId NvAPI_VIO_EnumDataFormats;
    public static FunctionId NvAPI_VIO_EnumDevices;
    public static FunctionId NvAPI_VIO_EnumSignalFormats;
    public static FunctionId NvAPI_VIO_GetCapabilities;
    public static FunctionId NvAPI_VIO_GetConfig;
    public static FunctionId NvAPI_VIO_GetCSC;
    public static FunctionId NvAPI_VIO_GetGamma;
    public static FunctionId NvAPI_VIO_GetPCIInfo;
    public static FunctionId NvAPI_VIO_GetSyncDelay;
    public static FunctionId NvAPI_VIO_IsFrameLockModeCompatible;
    public static FunctionId NvAPI_VIO_IsRunning;
    public static FunctionId NvAPI_VIO_Open;
    public static FunctionId NvAPI_VIO_QueryTopology;
    public static FunctionId NvAPI_VIO_SetConfig;
    public static FunctionId NvAPI_VIO_SetCSC;
    public static FunctionId NvAPI_VIO_SetGamma;
    public static FunctionId NvAPI_VIO_SetSyncDelay;
    public static FunctionId NvAPI_VIO_Start;
    public static FunctionId NvAPI_VIO_Status;
    public static FunctionId NvAPI_VIO_Stop;
    public static FunctionId NvAPI_VIO_SyncFormatDetect;
    public static FunctionId NvAPI_3D_GetProperty;
    public static FunctionId NvAPI_3D_GetPropertyRange;
    public static FunctionId NvAPI_3D_SetProperty;
    public static FunctionId NvAPI_AccessDisplayDriverRegistry;
    public static FunctionId NvAPI_Coproc_GetApplicationCoprocInfo;
    public static FunctionId NvAPI_Coproc_GetCoprocInfoFlagsEx;
    public static FunctionId NvAPI_Coproc_GetCoprocStatus;
    public static FunctionId NvAPI_Coproc_NotifyCoprocPowerState;
    public static FunctionId NvAPI_Coproc_SetCoprocInfoFlagsEx;
    public static FunctionId NvAPI_CreateUnAttachedDisplayFromDisplay;
    public static FunctionId NvAPI_D3D_CreateQuery;
    public static FunctionId NvAPI_D3D_DestroyQuery;
    public static FunctionId NvAPI_D3D_Query_Begin;
    public static FunctionId NvAPI_D3D_Query_End;
    public static FunctionId NvAPI_D3D_Query_GetData;
    public static FunctionId NvAPI_D3D_Query_GetDataSize;
    public static FunctionId NvAPI_D3D_Query_GetType;
    public static FunctionId NvAPI_D3D_RegisterApp;
    public static FunctionId NvAPI_D3D10_AliasPrimaryAsTexture;
    public static FunctionId NvAPI_D3D10_BeginShareResource;
    public static FunctionId NvAPI_D3D10_BeginShareResourceEx;
    public static FunctionId NvAPI_D3D10_CreateDevice;
    public static FunctionId NvAPI_D3D10_CreateDeviceAndSwapChain;
    public static FunctionId NvAPI_D3D10_EndShareResource;
    public static FunctionId NvAPI_D3D10_GetRenderedCursorAsBitmap;
    public static FunctionId NvAPI_D3D10_ProcessCallbacks;
    public static FunctionId NvAPI_D3D10_SetPrimaryFlipChainCallbacks;
    public static FunctionId NvAPI_D3D11_BeginShareResource;
    public static FunctionId NvAPI_D3D11_EndShareResource;
    public static FunctionId NvAPI_D3D1x_BindSwapBarrier;
    public static FunctionId NvAPI_D3D1x_IFR_SetUpTargetBufferToSys;
    public static FunctionId NvAPI_D3D1x_IFR_TransferRenderTarget;
    public static FunctionId NvAPI_D3D1x_JoinSwapGroup;
    public static FunctionId NvAPI_D3D1x_Present;
    public static FunctionId NvAPI_D3D1x_QueryFrameCount;
    public static FunctionId NvAPI_D3D1x_QueryMaxSwapGroup;
    public static FunctionId NvAPI_D3D1x_QuerySwapGroup;
    public static FunctionId NvAPI_D3D1x_ResetFrameCount;
    public static FunctionId NvAPI_D3D9_AliasPrimaryAsTexture;
    public static FunctionId NvAPI_D3D9_AliasPrimaryFromDevice;
    public static FunctionId NvAPI_D3D9_BindSwapBarrier;
    public static FunctionId NvAPI_D3D9_CreatePathContextNV;
    public static FunctionId NvAPI_D3D9_CreatePathNV;
    public static FunctionId NvAPI_D3D9_CreateRenderTarget;
    public static FunctionId NvAPI_D3D9_CreateTexture;
    public static FunctionId NvAPI_D3D9_CreateVideo;
    public static FunctionId NvAPI_D3D9_CreateVideoBegin;
    public static FunctionId NvAPI_D3D9_CreateVideoEnd;
    public static FunctionId NvAPI_D3D9_DeletePathNV;
    public static FunctionId NvAPI_D3D9_DestroyPathContextNV;
    public static FunctionId NvAPI_D3D9_DMA;
    public static FunctionId NvAPI_D3D9_DrawPathNV;
    public static FunctionId NvAPI_D3D9_EnableStereo;
    public static FunctionId NvAPI_D3D9_EnumVideoFeatures;
    public static FunctionId NvAPI_D3D9_FreeVideo;
    public static FunctionId NvAPI_D3D9_GetCurrentRenderTargetHandle;
    public static FunctionId NvAPI_D3D9_GetCurrentZBufferHandle;
    public static FunctionId NvAPI_D3D9_GetIndexBufferHandle;
    public static FunctionId NvAPI_D3D9_GetOverlaySurfaceHandles;
    public static FunctionId NvAPI_D3D9_GetSLIInfo;
    public static FunctionId NvAPI_D3D9_GetTextureHandle;
    public static FunctionId NvAPI_D3D9_GetVertexBufferHandle;
    public static FunctionId NvAPI_D3D9_GetVideoCapabilities;
    public static FunctionId NvAPI_D3D9_GetVideoState;
    public static FunctionId NvAPI_D3D9_GPUBasedCPUSleep;
    public static FunctionId NvAPI_D3D9_GpuSyncAcquire;
    public static FunctionId NvAPI_D3D9_GpuSyncEnd;
    public static FunctionId NvAPI_D3D9_GpuSyncGetHandleSize;
    public static FunctionId NvAPI_D3D9_GpuSyncInit;
    public static FunctionId NvAPI_D3D9_GpuSyncMapIndexBuffer;
    public static FunctionId NvAPI_D3D9_GpuSyncMapSurfaceBuffer;
    public static FunctionId NvAPI_D3D9_GpuSyncMapTexBuffer;
    public static FunctionId NvAPI_D3D9_GpuSyncMapVertexBuffer;
    public static FunctionId NvAPI_D3D9_GpuSyncRelease;
    public static FunctionId NvAPI_D3D9_IFR_SetUpTargetBufferToNV12BLVideoSurface;
    public static FunctionId NvAPI_D3D9_IFR_SetUpTargetBufferToSys;
    public static FunctionId NvAPI_D3D9_IFR_TransferRenderTarget;
    public static FunctionId NvAPI_D3D9_IFR_TransferRenderTargetToNV12BLVideoSurface;
    public static FunctionId NvAPI_D3D9_JoinSwapGroup;
    public static FunctionId NvAPI_D3D9_Lock;
    public static FunctionId NvAPI_D3D9_NVFBC_GetStatus;
    public static FunctionId NvAPI_D3D9_PathClearDepthNV;
    public static FunctionId NvAPI_D3D9_PathDepthNV;
    public static FunctionId NvAPI_D3D9_PathEnableColorWriteNV;
    public static FunctionId NvAPI_D3D9_PathEnableDepthTestNV;
    public static FunctionId NvAPI_D3D9_PathMatrixNV;
    public static FunctionId NvAPI_D3D9_PathParameterfNV;
    public static FunctionId NvAPI_D3D9_PathParameteriNV;
    public static FunctionId NvAPI_D3D9_PathVerticesNV;
    public static FunctionId NvAPI_D3D9_Present;
    public static FunctionId NvAPI_D3D9_PresentSurfaceToDesktop;
    public static FunctionId NvAPI_D3D9_PresentVideo;
    public static FunctionId NvAPI_D3D9_QueryAAOverrideMode;
    public static FunctionId NvAPI_D3D9_QueryFrameCount;
    public static FunctionId NvAPI_D3D9_QueryMaxSwapGroup;
    public static FunctionId NvAPI_D3D9_QuerySwapGroup;
    public static FunctionId NvAPI_D3D9_QueryVideoInfo;
    public static FunctionId NvAPI_D3D9_ResetFrameCount;
    public static FunctionId NvAPI_D3D9_SetGamutData;
    public static FunctionId NvAPI_D3D9_SetPitchSurfaceCreation;
    public static FunctionId NvAPI_D3D9_SetResourceHint;
    public static FunctionId NvAPI_D3D9_SetSLIMode;
    public static FunctionId NvAPI_D3D9_SetSurfaceCreationLayout;
    public static FunctionId NvAPI_D3D9_SetVideoState;
    public static FunctionId NvAPI_D3D9_StretchRect;
    public static FunctionId NvAPI_D3D9_Unlock;
    public static FunctionId NvAPI_D3D9_VideoSurfaceEncryptionControl;
    public static FunctionId NvAPI_DeleteCustomDisplay;
    public static FunctionId NvAPI_DeleteUnderscanConfig;
    public static FunctionId NvAPI_Disp_DpAuxChannelControl;
    public static FunctionId NvAPI_DISP_EnumHDMIStereoModes;
    public static FunctionId NvAPI_DISP_GetDisplayBlankingState;
    public static FunctionId NvAPI_DISP_GetHCloneTopology;
    public static FunctionId NvAPI_DISP_GetVirtualModeData;
    public static FunctionId NvAPI_DISP_OverrideDisplayModeList;
    public static FunctionId NvAPI_DISP_SetDisplayBlankingState;
    public static FunctionId NvAPI_DISP_SetHCloneTopology;
    public static FunctionId NvAPI_DISP_ValidateHCloneTopology;
    public static FunctionId NvAPI_EnumCustomDisplay;
    public static FunctionId NvAPI_EnumUnderscanConfig;
    public static FunctionId NvAPI_Event_RegisterCallback;
    public static FunctionId NvAPI_Event_UnregisterCallback;
    public static FunctionId NvAPI_GetDisplayDriverBuildTitle;
    public static FunctionId NvAPI_GetDisplayDriverCompileType;
    public static FunctionId NvAPI_GetDisplayDriverMemoryInfo;
    public static FunctionId NvAPI_GetDisplayDriverRegistryPath;
    public static FunctionId NvAPI_GetDisplayDriverSecurityLevel;
    public static FunctionId NvAPI_GetDisplayFeatureConfig;
    public static FunctionId NvAPI_GetDisplayFeatureConfigDefaults;
    public static FunctionId NvAPI_GetDisplayPosition;
    public static FunctionId NvAPI_GetDisplaySettings;
    public static FunctionId NvAPI_GetDriverMemoryInfo;
    public static FunctionId NvAPI_GetDriverModel;
    public static FunctionId NvAPI_GetDVCInfo;
    public static FunctionId NvAPI_GetDVCInfoEx;
    public static FunctionId NvAPI_GetGPUIDfromPhysicalGPU;
    public static FunctionId NvAPI_GetHDCPLinkParameters;
    public static FunctionId NvAPI_GetHUEInfo;
    public static FunctionId NvAPI_GetHybridMode;
    public static FunctionId NvAPI_GetImageSharpeningInfo;
    public static FunctionId NvAPI_GetInfoFrame;
    public static FunctionId NvAPI_GetInfoFrameState;
    public static FunctionId NvAPI_GetInfoFrameStatePvt;
    public static FunctionId NvAPI_GetInvalidGpuTopologies;
    public static FunctionId NvAPI_GetLoadedMicrocodePrograms;
    public static FunctionId NvAPI_GetPhysicalGPUFromDisplay;
    public static FunctionId NvAPI_GetPhysicalGPUFromGPUID;
    public static FunctionId NvAPI_GetPVExtName;
    public static FunctionId NvAPI_GetPVExtProfile;
    public static FunctionId NvAPI_GetScalingCaps;
    public static FunctionId NvAPI_GetTiming;
    public static FunctionId NvAPI_GetTopologyDisplayGPU;
    public static FunctionId NvAPI_GetTVEncoderControls;
    public static FunctionId NvAPI_GetTVOutputBorderColor;
    public static FunctionId NvAPI_GetTVOutputInfo;
    public static FunctionId NvAPI_GetUnAttachedDisplayDriverRegistryPath;
    public static FunctionId NvAPI_GetValidGpuTopologies;
    public static FunctionId NvAPI_GetVideoState;
    public static FunctionId NvAPI_GPS_GetPerfSensors;
    public static FunctionId NvAPI_GPS_GetPowerSteeringStatus;
    public static FunctionId NvAPI_GPS_GetThermalLimit;
    public static FunctionId NvAPI_GPS_GetVPStateCap;
    public static FunctionId NvAPI_GPS_SetPowerSteeringStatus;
    public static FunctionId NvAPI_GPS_SetThermalLimit;
    public static FunctionId NvAPI_GPS_SetVPStateCap;
    public static FunctionId NvAPI_GPU_ClearPCIELinkAERInfo;
    public static FunctionId NvAPI_GPU_ClearPCIELinkErrorInfo;
    public static FunctionId NvAPI_GPU_ClientPowerPoliciesGetInfo;
    public static FunctionId NvAPI_GPU_ClientPowerPoliciesGetStatus;
    public static FunctionId NvAPI_GPU_ClientPowerPoliciesSetStatus;
    public static FunctionId NvAPI_GPU_ClientPowerTopologyGetInfo;
    public static FunctionId NvAPI_GPU_ClientPowerTopologyGetStatus;
    public static FunctionId NvAPI_GPU_CudaEnumComputeCapableGpus;
    public static FunctionId NvAPI_GPU_EnableDynamicPstates;
    public static FunctionId NvAPI_GPU_EnableOverclockedPstates;
    public static FunctionId NvAPI_GPU_Get_DisplayPort_DongleInfo;
    public static FunctionId NvAPI_GPU_GetAllClocks;
    public static FunctionId NvAPI_GPU_GetAllGpusOnSameBoard;
    public static FunctionId NvAPI_GPU_GetArchInfo;
    public static FunctionId NvAPI_GPU_GetBarInfo;
    public static FunctionId NvAPI_GPU_GetClockBoostLock;
    public static FunctionId NvAPI_GPU_GetClockBoostMask;
    public static FunctionId NvAPI_GPU_GetClockBoostRanges;
    public static FunctionId NvAPI_GPU_GetClockBoostTable;
    public static FunctionId NvAPI_GPU_GetColorSpaceConversion;
    public static FunctionId NvAPI_GPU_GetConnectorInfo;
    public static FunctionId NvAPI_GPU_GetCoolerPolicyTable;
    public static FunctionId NvAPI_GPU_GetCoolerSettings;
    public static FunctionId NvAPI_GPU_GetCoreVoltageBoostPercent;
    public static FunctionId NvAPI_GPU_GetCurrentFanSpeedLevel;
    public static FunctionId NvAPI_GPU_GetCurrentThermalLevel;
    public static FunctionId NvAPI_GPU_GetCurrentVoltage;
    public static FunctionId NvAPI_GPU_GetDeepIdleState;
    public static FunctionId NvAPI_GPU_GetDeviceDisplayMode;
    public static FunctionId NvAPI_GPU_GetDisplayUnderflowStatus;
    public static FunctionId NvAPI_GPU_GetDitherControl;
    public static FunctionId NvAPI_GPU_GetExtendedMinorRevision;
    public static FunctionId NvAPI_GPU_GetFBWidthAndLocation;
    public static FunctionId NvAPI_GPU_GetFlatPanelInfo;
    public static FunctionId NvAPI_GPU_GetFoundry;
    public static FunctionId NvAPI_GPU_GetFrameBufferCalibrationLockFailures;
    public static FunctionId NvAPI_GPU_GetHardwareQualType;
    public static FunctionId NvAPI_GPU_GetHybridControllerInfo;
    public static FunctionId NvAPI_GPU_GetLogicalFBWidthAndLocation;
    public static FunctionId NvAPI_GPU_GetManufacturingInfo;
    public static FunctionId NvAPI_GPU_GetMemPartitionMask;
    public static FunctionId NvAPI_GPU_GetMXMBlock;
    public static FunctionId NvAPI_GPU_GetPartitionCount;
    public static FunctionId NvAPI_GPU_GetPCIEInfo;
    public static FunctionId NvAPI_GPU_GetPerfClocks;
    public static FunctionId NvAPI_GPU_GetPerfHybridMode;
    public static FunctionId NvAPI_GPU_GetPerGpuTopologyStatus;
    public static FunctionId NvAPI_GPU_GetPixelClockRange;
    public static FunctionId NvAPI_GPU_GetPowerMizerInfo;
    public static FunctionId NvAPI_GPU_GetPSFloorSweepStatus;
    public static FunctionId NvAPI_GPU_GetPstateClientLimits;
    public static FunctionId NvAPI_GPU_GetPstatesInfo;
    public static FunctionId NvAPI_GPU_GetRamBankCount;
    public static FunctionId NvAPI_GPU_GetRamBusWidth;
    public static FunctionId NvAPI_GPU_GetRamConfigStrap;
    public static FunctionId NvAPI_GPU_GetRamMaker;
    public static FunctionId NvAPI_GPU_GetRamType;
    public static FunctionId NvAPI_GPU_GetRawFuseData;
    public static FunctionId NvAPI_GPU_GetROPCount;
    public static FunctionId NvAPI_GPU_GetSampleType;
    public static FunctionId NvAPI_GPU_GetSerialNumber;
    public static FunctionId NvAPI_GPU_GetShaderPipeCount;
    public static FunctionId NvAPI_GPU_GetShortName;
    public static FunctionId NvAPI_GPU_GetSMMask;
    public static FunctionId NvAPI_GPU_GetTargetID;
    public static FunctionId NvAPI_GPU_GetThermalPoliciesInfo;
    public static FunctionId NvAPI_GPU_GetThermalPoliciesStatus;
    public static FunctionId NvAPI_GPU_GetThermalTable;
    public static FunctionId NvAPI_GPU_GetTotalSMCount;
    public static FunctionId NvAPI_GPU_GetTotalSPCount;
    public static FunctionId NvAPI_GPU_GetTotalTPCCount;
    public static FunctionId NvAPI_GPU_GetTPCMask;
    public static FunctionId NvAPI_GPU_GetUsages;
    public static FunctionId NvAPI_GPU_GetVbiosImage;
    public static FunctionId NvAPI_GPU_GetVbiosMxmVersion;
    public static FunctionId NvAPI_GPU_GetVFPCurve;
    public static FunctionId NvAPI_GPU_GetVoltageDomainsStatus;
    public static FunctionId NvAPI_GPU_GetVoltages;
    public static FunctionId NvAPI_GPU_GetVoltageStep;
    public static FunctionId NvAPI_GPU_GetVPECount;
    public static FunctionId NvAPI_GPU_GetVSFloorSweepStatus;
    public static FunctionId NvAPI_GPU_GPIOQueryLegalPins;
    public static FunctionId NvAPI_GPU_GPIOReadFromPin;
    public static FunctionId NvAPI_GPU_GPIOWriteToPin;
    public static FunctionId NvAPI_GPU_PerfPoliciesGetInfo;
    public static FunctionId NvAPI_GPU_PerfPoliciesGetStatus;
    public static FunctionId NvAPI_GPU_PhysxQueryRecommendedState;
    public static FunctionId NvAPI_GPU_PhysxSetState;
    public static FunctionId NvAPI_GPU_QueryActiveApps;
    public static FunctionId NvAPI_GPU_RestoreCoolerPolicyTable;
    public static FunctionId NvAPI_GPU_RestoreCoolerSettings;
    public static FunctionId NvAPI_GPU_SetClockBoostLock;
    public static FunctionId NvAPI_GPU_SetClockBoostTable;
    public static FunctionId NvAPI_GPU_SetClocks;
    public static FunctionId NvAPI_GPU_SetColorSpaceConversion;
    public static FunctionId NvAPI_GPU_SetCoolerLevels;
    public static FunctionId NvAPI_GPU_SetCoolerPolicyTable;
    public static FunctionId NvAPI_GPU_SetCoreVoltageBoostPercent;
    public static FunctionId NvAPI_GPU_SetCurrentPCIESpeed;
    public static FunctionId NvAPI_GPU_SetCurrentPCIEWidth;
    public static FunctionId NvAPI_GPU_SetDeepIdleState;
    public static FunctionId NvAPI_GPU_SetDisplayUnderflowMode;
    public static FunctionId NvAPI_GPU_SetDitherControl;
    public static FunctionId NvAPI_GPU_SetPerfClocks;
    public static FunctionId NvAPI_GPU_SetPerfHybridMode;
    public static FunctionId NvAPI_GPU_SetPixelClockRange;
    public static FunctionId NvAPI_GPU_SetPowerMizerInfo;
    public static FunctionId NvAPI_GPU_SetPstateClientLimits;
    public static FunctionId NvAPI_GPU_SetPstates20;
    public static FunctionId NvAPI_GPU_SetPstatesInfo;
    public static FunctionId NvAPI_GPU_SetThermalPoliciesStatus;
    public static FunctionId NvAPI_Hybrid_IsAppMigrationStateChangeable;
    public static FunctionId NvAPI_Hybrid_QueryBlockedMigratableApps;
    public static FunctionId NvAPI_Hybrid_QueryUnblockedNonMigratableApps;
    public static FunctionId NvAPI_Hybrid_SetAppMigrationState;
    public static FunctionId NvAPI_I2CReadEx;
    public static FunctionId NvAPI_I2CWriteEx;
    public static FunctionId NvAPI_LoadMicrocode;
    public static FunctionId NvAPI_Mosaic_ChooseGpuTopologies;
    public static FunctionId NvAPI_Mosaic_EnumGridTopologies;
    public static FunctionId NvAPI_Mosaic_GetDisplayCapabilities;
    public static FunctionId NvAPI_Mosaic_GetMosaicCapabilities;
    public static FunctionId NvAPI_Mosaic_GetMosaicViewports;
    public static FunctionId NvAPI_Mosaic_SetGridTopology;
    public static FunctionId NvAPI_Mosaic_ValidateDisplayGridsWithSLI;
    public static FunctionId NvAPI_QueryNonMigratableApps;
    public static FunctionId NvAPI_QueryUnderscanCap;
    public static FunctionId NvAPI_RestartDisplayDriver;
    public static FunctionId NvAPI_RevertCustomDisplayTrial;
    public static FunctionId NvAPI_SaveCustomDisplay;
    public static FunctionId NvAPI_SetDisplayFeatureConfig;
    public static FunctionId NvAPI_SetDisplayPosition;
    public static FunctionId NvAPI_SetDisplaySettings;
    public static FunctionId NvAPI_SetDVCLevel;
    public static FunctionId NvAPI_SetDVCLevelEx;
    public static FunctionId NvAPI_SetFrameRateNotify;
    public static FunctionId NvAPI_SetGpuTopologies;
    public static FunctionId NvAPI_SetHUEAngle;
    public static FunctionId NvAPI_SetHybridMode;
    public static FunctionId NvAPI_SetImageSharpeningLevel;
    public static FunctionId NvAPI_SetInfoFrame;
    public static FunctionId NvAPI_SetInfoFrameState;
    public static FunctionId NvAPI_SetPVExtName;
    public static FunctionId NvAPI_SetPVExtProfile;
    public static FunctionId NvAPI_SetTopologyDisplayGPU;
    public static FunctionId NvAPI_SetTopologyFocusDisplayAndView;
    public static FunctionId NvAPI_SetTVEncoderControls;
    public static FunctionId NvAPI_SetTVOutputBorderColor;
    public static FunctionId NvAPI_SetUnderscanConfig;
    public static FunctionId NvAPI_SetVideoState;
    public static FunctionId NvAPI_Stereo_AppHandShake;
    public static FunctionId NvAPI_Stereo_ForceToScreenDepth;
    public static FunctionId NvAPI_Stereo_GetCursorSeparation;
    public static FunctionId NvAPI_Stereo_GetPixelShaderConstantB;
    public static FunctionId NvAPI_Stereo_GetPixelShaderConstantF;
    public static FunctionId NvAPI_Stereo_GetPixelShaderConstantI;
    public static FunctionId NvAPI_Stereo_GetStereoCaps;
    public static FunctionId NvAPI_Stereo_GetVertexShaderConstantB;
    public static FunctionId NvAPI_Stereo_GetVertexShaderConstantF;
    public static FunctionId NvAPI_Stereo_GetVertexShaderConstantI;
    public static FunctionId NvAPI_Stereo_HandShake_Message_Control;
    public static FunctionId NvAPI_Stereo_HandShake_Trigger_Activation;
    public static FunctionId NvAPI_Stereo_Is3DCursorSupported;
    public static FunctionId NvAPI_Stereo_SetCursorSeparation;
    public static FunctionId NvAPI_Stereo_SetPixelShaderConstantB;
    public static FunctionId NvAPI_Stereo_SetPixelShaderConstantF;
    public static FunctionId NvAPI_Stereo_SetPixelShaderConstantI;
    public static FunctionId NvAPI_Stereo_SetVertexShaderConstantB;
    public static FunctionId NvAPI_Stereo_SetVertexShaderConstantF;
    public static FunctionId NvAPI_Stereo_SetVertexShaderConstantI;
    public static FunctionId NvAPI_SYS_GetChipSetTopologyStatus;
    public static FunctionId NvAPI_SYS_GetSliApprovalCookie;
    public static FunctionId NvAPI_SYS_SetPostOutput;
    public static FunctionId NvAPI_SYS_VenturaGetCoolingBudget;
    public static FunctionId NvAPI_SYS_VenturaGetPowerReading;
    public static FunctionId NvAPI_SYS_VenturaGetState;
    public static FunctionId NvAPI_SYS_VenturaSetCoolingBudget;
    public static FunctionId NvAPI_SYS_VenturaSetState;
    public static FunctionId NvAPI_TryCustomDisplay;
    public static FunctionId NvAPI_VideoGetStereoInfo;
    public static FunctionId NvAPI_VideoSetStereoInfo;
    public static FunctionId NvAPI_GPU_ClientFanCoolersGetInfo;
    public static FunctionId NvAPI_GPU_ClientFanCoolersGetStatus;
    public static FunctionId NvAPI_GPU_ClientFanCoolersGetControl;
    public static FunctionId NvAPI_GPU_ClientFanCoolersSetControl;
    public static FunctionId Unknown_1629A173;
    public static FunctionId Unknown_36E39E6B;
    public static FunctionId Unknown_B7BCF50D;
    public static FunctionId Unknown_F1D2777B;
    public static FunctionId NvAPI_Unload;
    public static FunctionId NvAPI_Initialize;
}
internal class NvAPIWrapper.Native.Helpers.Structures.ValueTypeArray : ValueType {
    [CompilerGeneratedAttribute]
private IntPtr <MemoryAddress>k__BackingField;
    public IntPtr MemoryAddress { get; }
    public static ValueTypeArray Null { get; }
    public bool IsNull { get; }
    public ValueTypeArray(IntPtr memoryAddress);
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_MemoryAddress();
    public static ValueTypeArray get_Null();
    public sealed virtual bool get_IsNull();
    public static ValueTypeArray FromArray(IEnumerable`1<object> list);
    public static ValueTypeArray FromArray(IEnumerable`1<object> list, Type type);
    public sealed virtual bool Equals(ValueTypeArray other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTypeArray left, ValueTypeArray right);
    public static bool op_Inequality(ValueTypeArray left, ValueTypeArray right);
    public static ValueTypeArray FromArray(T[] array);
    public T[] ToArray(int count);
    public T[] ToArray(int count, Type type);
    public T[] ToArray(int start, int count);
    public T[] ToArray(int start, int count, Type type);
    public IEnumerable`1<T> AsEnumerable(int count);
    public IEnumerable`1<T> AsEnumerable(int count, Type type);
    public IEnumerable`1<T> AsEnumerable(int start, int count);
    [IteratorStateMachineAttribute("NvAPIWrapper.Native.Helpers.Structures.ValueTypeArray/<AsEnumerable>d__23`1")]
public IEnumerable`1<T> AsEnumerable(int start, int count, Type type);
    public sealed virtual void Dispose();
}
internal class NvAPIWrapper.Native.Helpers.Structures.ValueTypeArray`1 : ValueType {
    private ValueTypeArray underlyingArray;
    public IntPtr MemoryAddress { get; }
    public static ValueTypeArray`1<T> Null { get; }
    public bool IsNull { get; }
    public ValueTypeArray`1(IntPtr memoryAddress);
    private ValueTypeArray`1(ValueTypeArray underlyingArray);
    public sealed virtual IntPtr get_MemoryAddress();
    public static ValueTypeArray`1<T> get_Null();
    public sealed virtual bool get_IsNull();
    public static ValueTypeArray`1<T> FromArray(T[] array);
    public static ValueTypeArray`1<T> FromArray(IEnumerable`1<T> list, Type type);
    public sealed virtual bool Equals(ValueTypeArray`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTypeArray`1<T> left, ValueTypeArray`1<T> right);
    public static bool op_Inequality(ValueTypeArray`1<T> left, ValueTypeArray`1<T> right);
    public T[] ToArray(int count);
    public T[] ToArray(int count, Type type);
    public T[] ToArray(int start, int count);
    public T[] ToArray(int start, int count, Type type);
    public IEnumerable`1<T> AsEnumerable(int count);
    public IEnumerable`1<T> AsEnumerable(int count, Type type);
    public IEnumerable`1<T> AsEnumerable(int start, int count);
    public IEnumerable`1<T> AsEnumerable(int start, int count, Type type);
    public sealed virtual void Dispose();
}
internal class NvAPIWrapper.Native.Helpers.Structures.ValueTypeReference : ValueType {
    [CompilerGeneratedAttribute]
private IntPtr <MemoryAddress>k__BackingField;
    public IntPtr MemoryAddress { get; }
    public static ValueTypeReference Null { get; }
    public bool IsNull { get; }
    public ValueTypeReference(IntPtr memoryAddress);
    [CompilerGeneratedAttribute]
public sealed virtual IntPtr get_MemoryAddress();
    public static ValueTypeReference get_Null();
    public sealed virtual bool get_IsNull();
    public static ValueTypeReference FromValueType(T valueType);
    public static ValueTypeReference FromValueType(object valueType, Type type);
    public sealed virtual bool Equals(ValueTypeReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTypeReference left, ValueTypeReference right);
    public static bool op_Inequality(ValueTypeReference left, ValueTypeReference right);
    public T ToValueType(Type type);
    public Nullable`1<T> ToValueType();
    public sealed virtual void Dispose();
}
internal class NvAPIWrapper.Native.Helpers.Structures.ValueTypeReference`1 : ValueType {
    private ValueTypeReference underlyingReference;
    public IntPtr MemoryAddress { get; }
    public static ValueTypeReference`1<T> Null { get; }
    public bool IsNull { get; }
    public ValueTypeReference`1(IntPtr memoryAddress);
    private ValueTypeReference`1(ValueTypeReference underlyingReference);
    public sealed virtual IntPtr get_MemoryAddress();
    public static ValueTypeReference`1<T> get_Null();
    public sealed virtual bool get_IsNull();
    public static ValueTypeReference`1<T> FromValueType(T valueType);
    public static ValueTypeReference`1<T> FromValueType(object valueType, Type type);
    public sealed virtual bool Equals(ValueTypeReference`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTypeReference`1<T> left, ValueTypeReference`1<T> right);
    public static bool op_Inequality(ValueTypeReference`1<T> left, ValueTypeReference`1<T> right);
    public T ToValueType(Type type);
    public Nullable`1<T> ToValueType();
    public sealed virtual void Dispose();
}
public interface NvAPIWrapper.Native.Interfaces.Display.IColorData {
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public ColorDataFormat ColorFormat { get; }
    public ColorDataColorimetry Colorimetry { get; }
    public Nullable`1<ColorDataSelectionPolicy> SelectionPolicy { get; }
    public Nullable`1<ColorDataDesktopDepth> DesktopColorDepth { get; }
    public abstract virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    public abstract virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public abstract virtual ColorDataFormat get_ColorFormat();
    public abstract virtual ColorDataColorimetry get_Colorimetry();
    public abstract virtual Nullable`1<ColorDataSelectionPolicy> get_SelectionPolicy();
    public abstract virtual Nullable`1<ColorDataDesktopDepth> get_DesktopColorDepth();
}
public interface NvAPIWrapper.Native.Interfaces.Display.IDisplayColorData {
    public ColorDataColorCoordinate FirstColorCoordinate { get; }
    public ColorDataColorCoordinate SecondColorCoordinate { get; }
    public ColorDataColorCoordinate ThirdColorCoordinate { get; }
    public ColorDataColorCoordinate WhiteColorCoordinate { get; }
    public abstract virtual ColorDataColorCoordinate get_FirstColorCoordinate();
    public abstract virtual ColorDataColorCoordinate get_SecondColorCoordinate();
    public abstract virtual ColorDataColorCoordinate get_ThirdColorCoordinate();
    public abstract virtual ColorDataColorCoordinate get_WhiteColorCoordinate();
}
public interface NvAPIWrapper.Native.Interfaces.Display.IDisplayDVCInfo {
    public int CurrentLevel { get; }
    public int DefaultLevel { get; }
    public int MaximumLevel { get; }
    public int MinimumLevel { get; }
    public abstract virtual int get_CurrentLevel();
    public abstract virtual int get_DefaultLevel();
    public abstract virtual int get_MaximumLevel();
    public abstract virtual int get_MinimumLevel();
}
public interface NvAPIWrapper.Native.Interfaces.Display.IHDMISupportInfo {
    public UInt32 EDID861ExtensionRevision { get; }
    public bool IsGPUCapableOfHDMIOutput { get; }
    public bool IsHDMIMonitor { get; }
    public Nullable`1<bool> IsMonitorCapableOfAdobeRGB { get; }
    public Nullable`1<bool> IsMonitorCapableOfAdobeYCC601 { get; }
    public bool IsMonitorCapableOfBasicAudio { get; }
    public Nullable`1<bool> IsMonitorCapableOfsYCC601 { get; }
    public bool IsMonitorCapableOfUnderscan { get; }
    public bool IsMonitorCapableOfxvYCC601 { get; }
    public bool IsMonitorCapableOfxvYCC709 { get; }
    public bool IsMonitorCapableOfYCbCr422 { get; }
    public bool IsMonitorCapableOfYCbCr444 { get; }
    public abstract virtual UInt32 get_EDID861ExtensionRevision();
    public abstract virtual bool get_IsGPUCapableOfHDMIOutput();
    public abstract virtual bool get_IsHDMIMonitor();
    public abstract virtual Nullable`1<bool> get_IsMonitorCapableOfAdobeRGB();
    public abstract virtual Nullable`1<bool> get_IsMonitorCapableOfAdobeYCC601();
    public abstract virtual bool get_IsMonitorCapableOfBasicAudio();
    public abstract virtual Nullable`1<bool> get_IsMonitorCapableOfsYCC601();
    public abstract virtual bool get_IsMonitorCapableOfUnderscan();
    public abstract virtual bool get_IsMonitorCapableOfxvYCC601();
    public abstract virtual bool get_IsMonitorCapableOfxvYCC709();
    public abstract virtual bool get_IsMonitorCapableOfYCbCr422();
    public abstract virtual bool get_IsMonitorCapableOfYCbCr444();
}
public interface NvAPIWrapper.Native.Interfaces.Display.IHDRColorData {
    public Nullable`1<ColorDataDepth> ColorDepth { get; }
    public Nullable`1<ColorDataFormat> ColorFormat { get; }
    public Nullable`1<ColorDataDynamicRange> DynamicRange { get; }
    public ColorDataHDRMode HDRMode { get; }
    public MasteringDisplayColorData MasteringDisplayData { get; }
    public abstract virtual Nullable`1<ColorDataDepth> get_ColorDepth();
    public abstract virtual Nullable`1<ColorDataFormat> get_ColorFormat();
    public abstract virtual Nullable`1<ColorDataDynamicRange> get_DynamicRange();
    public abstract virtual ColorDataHDRMode get_HDRMode();
    public abstract virtual MasteringDisplayColorData get_MasteringDisplayData();
}
public interface NvAPIWrapper.Native.Interfaces.Display.IPathInfo {
    public UInt32 SourceId { get; }
    public SourceModeInfo SourceModeInfo { get; }
    public IEnumerable`1<IPathTargetInfo> TargetsInfo { get; }
    public abstract virtual UInt32 get_SourceId();
    public abstract virtual SourceModeInfo get_SourceModeInfo();
    public abstract virtual IEnumerable`1<IPathTargetInfo> get_TargetsInfo();
}
public interface NvAPIWrapper.Native.Interfaces.Display.IPathTargetInfo {
    public Nullable`1<PathAdvancedTargetInfo> Details { get; }
    public UInt32 DisplayId { get; }
    public abstract virtual Nullable`1<PathAdvancedTargetInfo> get_Details();
    public abstract virtual UInt32 get_DisplayId();
}
public interface NvAPIWrapper.Native.Interfaces.DRS.IDRSApplication {
    public string ApplicationName { get; }
    public string FriendlyName { get; }
    public bool IsPredefined { get; }
    public string LauncherName { get; }
    public abstract virtual string get_ApplicationName();
    public abstract virtual string get_FriendlyName();
    public abstract virtual bool get_IsPredefined();
    public abstract virtual string get_LauncherName();
}
public interface NvAPIWrapper.Native.Interfaces.General.IChipsetInfo {
    public string ChipsetName { get; }
    public int DeviceId { get; }
    public ChipsetInfoFlag Flags { get; }
    public int VendorId { get; }
    public string VendorName { get; }
    public abstract virtual string get_ChipsetName();
    public abstract virtual int get_DeviceId();
    public abstract virtual ChipsetInfoFlag get_Flags();
    public abstract virtual int get_VendorId();
    public abstract virtual string get_VendorName();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IClockFrequencies {
    public IReadOnlyDictionary`2<PublicClockDomain, ClockDomainInfo> Clocks { get; }
    public ClockType ClockType { get; }
    public ClockDomainInfo GraphicsClock { get; }
    public ClockDomainInfo MemoryClock { get; }
    public ClockDomainInfo ProcessorClock { get; }
    public ClockDomainInfo VideoDecodingClock { get; }
    public abstract virtual IReadOnlyDictionary`2<PublicClockDomain, ClockDomainInfo> get_Clocks();
    public abstract virtual ClockType get_ClockType();
    public abstract virtual ClockDomainInfo get_GraphicsClock();
    public abstract virtual ClockDomainInfo get_MemoryClock();
    public abstract virtual ClockDomainInfo get_ProcessorClock();
    public abstract virtual ClockDomainInfo get_VideoDecodingClock();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IDisplayDriverMemoryInfo {
    public UInt32 AvailableDedicatedVideoMemoryInkB { get; }
    public UInt32 CurrentAvailableDedicatedVideoMemoryInkB { get; }
    public UInt32 DedicatedVideoMemoryInkB { get; }
    public UInt32 SharedSystemMemoryInkB { get; }
    public UInt32 SystemVideoMemoryInkB { get; }
    public abstract virtual UInt32 get_AvailableDedicatedVideoMemoryInkB();
    public abstract virtual UInt32 get_CurrentAvailableDedicatedVideoMemoryInkB();
    public abstract virtual UInt32 get_DedicatedVideoMemoryInkB();
    public abstract virtual UInt32 get_SharedSystemMemoryInkB();
    public abstract virtual UInt32 get_SystemVideoMemoryInkB();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IDisplayIds {
    public MonitorConnectionType ConnectionType { get; }
    public UInt32 DisplayId { get; }
    public bool IsActive { get; }
    public bool IsCluster { get; }
    public bool IsConnected { get; }
    public bool IsDynamic { get; }
    public bool IsMultiStreamRootNode { get; }
    public bool IsOSVisible { get; }
    public bool IsPhysicallyConnected { get; }
    public bool IsWFD { get; }
    public abstract virtual MonitorConnectionType get_ConnectionType();
    public abstract virtual UInt32 get_DisplayId();
    public abstract virtual bool get_IsActive();
    public abstract virtual bool get_IsCluster();
    public abstract virtual bool get_IsConnected();
    public abstract virtual bool get_IsDynamic();
    public abstract virtual bool get_IsMultiStreamRootNode();
    public abstract virtual bool get_IsOSVisible();
    public abstract virtual bool get_IsPhysicallyConnected();
    public abstract virtual bool get_IsWFD();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IEDID {
    public Byte[] Data { get; }
    public abstract virtual Byte[] get_Data();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.II2CInfo {
    public Byte[] Data { get; }
    public byte DeviceAddress { get; }
    public bool IsReadOperation { get; }
    public OutputId OutputMask { get; }
    public Nullable`1<byte> PortId { get; }
    public Byte[] RegisterAddress { get; }
    public I2CSpeed Speed { get; }
    public bool UseDDCPort { get; }
    public abstract virtual Byte[] get_Data();
    public abstract virtual byte get_DeviceAddress();
    public abstract virtual bool get_IsReadOperation();
    public abstract virtual OutputId get_OutputMask();
    public abstract virtual Nullable`1<byte> get_PortId();
    public abstract virtual Byte[] get_RegisterAddress();
    public abstract virtual I2CSpeed get_Speed();
    public abstract virtual bool get_UseDDCPort();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceState {
    public bool IsOverclockable { get; }
    public bool IsOverclocked { get; }
    public bool IsPCIELimited { get; }
    public PerformanceStateId StateId { get; }
    public abstract virtual bool get_IsOverclockable();
    public abstract virtual bool get_IsOverclocked();
    public abstract virtual bool get_IsPCIELimited();
    public abstract virtual PerformanceStateId get_StateId();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceState20 {
    public bool IsEditable { get; }
    public PerformanceStateId StateId { get; }
    public abstract virtual bool get_IsEditable();
    public abstract virtual PerformanceStateId get_StateId();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20ClockDependentFrequencyRange {
    public UInt32 MaximumFrequencyInkHz { get; }
    public UInt32 MaximumVoltageInMicroVolt { get; }
    public UInt32 MinimumFrequencyInkHz { get; }
    public UInt32 MinimumVoltageInMicroVolt { get; }
    public PerformanceVoltageDomain VoltageDomainId { get; }
    public abstract virtual UInt32 get_MaximumFrequencyInkHz();
    public abstract virtual UInt32 get_MaximumVoltageInMicroVolt();
    public abstract virtual UInt32 get_MinimumFrequencyInkHz();
    public abstract virtual UInt32 get_MinimumVoltageInMicroVolt();
    public abstract virtual PerformanceVoltageDomain get_VoltageDomainId();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20ClockDependentSingleFrequency {
    public UInt32 FrequencyInkHz { get; }
    public abstract virtual UInt32 get_FrequencyInkHz();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20ClockEntry {
    public PerformanceStates20ClockType ClockType { get; }
    public PublicClockDomain DomainId { get; }
    public PerformanceStates20ParameterDelta FrequencyDeltaInkHz { get; }
    public IPerformanceStates20ClockDependentFrequencyRange FrequencyRange { get; }
    public bool IsEditable { get; }
    public IPerformanceStates20ClockDependentSingleFrequency SingleFrequency { get; }
    public abstract virtual PerformanceStates20ClockType get_ClockType();
    public abstract virtual PublicClockDomain get_DomainId();
    public abstract virtual PerformanceStates20ParameterDelta get_FrequencyDeltaInkHz();
    public abstract virtual IPerformanceStates20ClockDependentFrequencyRange get_FrequencyRange();
    public abstract virtual bool get_IsEditable();
    public abstract virtual IPerformanceStates20ClockDependentSingleFrequency get_SingleFrequency();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20Info {
    public IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20ClockEntry[]> Clocks { get; }
    public IPerformanceStates20VoltageEntry[] GeneralVoltages { get; }
    public bool IsEditable { get; }
    public IPerformanceState20[] PerformanceStates { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20VoltageEntry[]> Voltages { get; }
    public abstract virtual IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20ClockEntry[]> get_Clocks();
    public abstract virtual IPerformanceStates20VoltageEntry[] get_GeneralVoltages();
    public abstract virtual bool get_IsEditable();
    public abstract virtual IPerformanceState20[] get_PerformanceStates();
    public abstract virtual IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStates20VoltageEntry[]> get_Voltages();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStates20VoltageEntry {
    public PerformanceVoltageDomain DomainId { get; }
    public bool IsEditable { get; }
    public PerformanceStates20ParameterDelta ValueDeltaInMicroVolt { get; }
    public UInt32 ValueInMicroVolt { get; }
    public abstract virtual PerformanceVoltageDomain get_DomainId();
    public abstract virtual bool get_IsEditable();
    public abstract virtual PerformanceStates20ParameterDelta get_ValueDeltaInMicroVolt();
    public abstract virtual UInt32 get_ValueInMicroVolt();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesClock {
    public PublicClockDomain DomainId { get; }
    public UInt32 Frequency { get; }
    public abstract virtual PublicClockDomain get_DomainId();
    public abstract virtual UInt32 get_Frequency();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesInfo {
    public bool IsCapableOfDynamicPerformance { get; }
    public bool IsDynamicPerformanceEnable { get; }
    public bool IsPerformanceMonitorEnable { get; }
    public IPerformanceState[] PerformanceStates { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesClock[]> PerformanceStatesClocks { get; }
    public IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesVoltage[]> PerformanceStatesVoltages { get; }
    public abstract virtual bool get_IsCapableOfDynamicPerformance();
    public abstract virtual bool get_IsDynamicPerformanceEnable();
    public abstract virtual bool get_IsPerformanceMonitorEnable();
    public abstract virtual IPerformanceState[] get_PerformanceStates();
    public abstract virtual IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesClock[]> get_PerformanceStatesClocks();
    public abstract virtual IReadOnlyDictionary`2<PerformanceStateId, IPerformanceStatesVoltage[]> get_PerformanceStatesVoltages();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IPerformanceStatesVoltage {
    public PerformanceVoltageDomain DomainId { get; }
    public UInt32 Value { get; }
    public abstract virtual PerformanceVoltageDomain get_DomainId();
    public abstract virtual UInt32 get_Value();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IThermalSensor {
    public ThermalController Controller { get; }
    public int CurrentTemperature { get; }
    public int DefaultMaximumTemperature { get; }
    public int DefaultMinimumTemperature { get; }
    public ThermalSettingsTarget Target { get; }
    public abstract virtual ThermalController get_Controller();
    public abstract virtual int get_CurrentTemperature();
    public abstract virtual int get_DefaultMaximumTemperature();
    public abstract virtual int get_DefaultMinimumTemperature();
    public abstract virtual ThermalSettingsTarget get_Target();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IThermalSettings {
    public IThermalSensor[] Sensors { get; }
    public abstract virtual IThermalSensor[] get_Sensors();
}
public interface NvAPIWrapper.Native.Interfaces.GPU.IUtilizationDomainInfo {
    public bool IsPresent { get; }
    public UInt32 Percentage { get; }
    public abstract virtual bool get_IsPresent();
    public abstract virtual UInt32 get_Percentage();
}
internal interface NvAPIWrapper.Native.Interfaces.IAllocatable {
    public abstract virtual void Allocate();
}
public interface NvAPIWrapper.Native.Interfaces.IHandle {
    public bool IsNull { get; }
    public IntPtr MemoryAddress { get; }
    public abstract virtual bool get_IsNull();
    public abstract virtual IntPtr get_MemoryAddress();
}
internal interface NvAPIWrapper.Native.Interfaces.IInitializable {
}
public interface NvAPIWrapper.Native.Interfaces.Mosaic.IDisplaySettings {
    public int BitsPerPixel { get; }
    public int Frequency { get; }
    public UInt32 FrequencyInMillihertz { get; }
    public int Height { get; }
    public int Width { get; }
    public abstract virtual int get_BitsPerPixel();
    public abstract virtual int get_Frequency();
    public abstract virtual UInt32 get_FrequencyInMillihertz();
    public abstract virtual int get_Height();
    public abstract virtual int get_Width();
}
public interface NvAPIWrapper.Native.Interfaces.Mosaic.IGridTopology {
    public bool AcceleratePrimaryDisplay { get; }
    public bool ApplyWithBezelCorrectedResolution { get; }
    public bool BaseMosaicPanoramic { get; }
    public int Columns { get; }
    public IEnumerable`1<IGridTopologyDisplay> Displays { get; }
    public DisplaySettingsV1 DisplaySettings { get; }
    public bool DriverReloadAllowed { get; }
    public bool ImmersiveGaming { get; }
    public int Rows { get; }
    public abstract virtual bool get_AcceleratePrimaryDisplay();
    public abstract virtual bool get_ApplyWithBezelCorrectedResolution();
    public abstract virtual bool get_BaseMosaicPanoramic();
    public abstract virtual int get_Columns();
    public abstract virtual IEnumerable`1<IGridTopologyDisplay> get_Displays();
    public abstract virtual DisplaySettingsV1 get_DisplaySettings();
    public abstract virtual bool get_DriverReloadAllowed();
    public abstract virtual bool get_ImmersiveGaming();
    public abstract virtual int get_Rows();
}
public interface NvAPIWrapper.Native.Interfaces.Mosaic.IGridTopologyDisplay {
    public UInt32 CloneGroup { get; }
    public UInt32 DisplayId { get; }
    public int OverlapX { get; }
    public int OverlapY { get; }
    public PixelShiftType PixelShiftType { get; }
    public Rotate Rotation { get; }
    public abstract virtual UInt32 get_CloneGroup();
    public abstract virtual UInt32 get_DisplayId();
    public abstract virtual int get_OverlapX();
    public abstract virtual int get_OverlapY();
    public abstract virtual PixelShiftType get_PixelShiftType();
    public abstract virtual Rotate get_Rotation();
}
public interface NvAPIWrapper.Native.Interfaces.Mosaic.ISupportedTopologiesInfo {
    public IEnumerable`1<IDisplaySettings> DisplaySettings { get; }
    public IEnumerable`1<TopologyBrief> TopologyBriefs { get; }
    public abstract virtual IEnumerable`1<IDisplaySettings> get_DisplaySettings();
    public abstract virtual IEnumerable`1<TopologyBrief> get_TopologyBriefs();
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.Mosaic.DisplayCapacityProblem : Enum {
    public UInt32 value__;
    public static DisplayCapacityProblem NoProblem;
    public static DisplayCapacityProblem DisplayOnInvalidGPU;
    public static DisplayCapacityProblem DisplayOnWrongConnector;
    public static DisplayCapacityProblem NoCommonTimings;
    public static DisplayCapacityProblem NoEDIDAvailable;
    public static DisplayCapacityProblem MismatchedOutputType;
    public static DisplayCapacityProblem NoDisplayConnected;
    public static DisplayCapacityProblem NoGPUTopology;
    public static DisplayCapacityProblem NotSupported;
    public static DisplayCapacityProblem NoSLIBridge;
    public static DisplayCapacityProblem ECCEnabled;
    public static DisplayCapacityProblem GPUTopologyNotSupported;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.Mosaic.DisplayTopologyWarning : Enum {
    public UInt32 value__;
    public static DisplayTopologyWarning NoWarning;
    public static DisplayTopologyWarning DisplayPosition;
    public static DisplayTopologyWarning DriverReloadRequired;
}
public enum NvAPIWrapper.Native.Mosaic.PixelShiftType : Enum {
    public int value__;
    public static PixelShiftType NoPixelShift;
    public static PixelShiftType TopLeft2X2Pixels;
    public static PixelShiftType BottomRight2X2Pixels;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.Mosaic.SetDisplayTopologyFlag : Enum {
    public UInt32 value__;
    public static SetDisplayTopologyFlag NoFlag;
    public static SetDisplayTopologyFlag CurrentGPUTopology;
    public static SetDisplayTopologyFlag NoDriverReload;
    public static SetDisplayTopologyFlag MaximizePerformance;
    public static SetDisplayTopologyFlag AllowInvalid;
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Mosaic.Structures.DisplaySettingsV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Width;
    internal UInt32 _Height;
    internal UInt32 _BitsPerPixel;
    internal UInt32 _Frequency;
    public int Width { get; }
    public int Height { get; }
    public int BitsPerPixel { get; }
    public int Frequency { get; }
    public UInt32 FrequencyInMillihertz { get; }
    public DisplaySettingsV1(int width, int height, int bitsPerPixel, int frequency);
    public sealed virtual bool Equals(DisplaySettingsV1 other);
    public sealed virtual bool Equals(DisplaySettingsV2 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DisplaySettingsV1 left, DisplaySettingsV1 right);
    public static bool op_Inequality(DisplaySettingsV1 left, DisplaySettingsV1 right);
    public sealed virtual int get_Width();
    public sealed virtual int get_Height();
    public sealed virtual int get_BitsPerPixel();
    public sealed virtual int get_Frequency();
    public sealed virtual UInt32 get_FrequencyInMillihertz();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.Mosaic.Structures.DisplaySettingsV2 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Width;
    internal UInt32 _Height;
    internal UInt32 _BitsPerPixel;
    internal UInt32 _Frequency;
    internal UInt32 _FrequencyInMillihertz;
    public int Width { get; }
    public int Height { get; }
    public int BitsPerPixel { get; }
    public int Frequency { get; }
    public UInt32 FrequencyInMillihertz { get; }
    public DisplaySettingsV2(int width, int height, int bitsPerPixel, int frequency, UInt32 frequencyInMillihertz);
    public sealed virtual bool Equals(DisplaySettingsV2 other);
    public sealed virtual bool Equals(DisplaySettingsV1 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DisplaySettingsV2 left, DisplaySettingsV2 right);
    public static bool op_Inequality(DisplaySettingsV2 left, DisplaySettingsV2 right);
    public sealed virtual int get_Width();
    public sealed virtual int get_Height();
    public sealed virtual int get_BitsPerPixel();
    public sealed virtual int get_Frequency();
    public sealed virtual UInt32 get_FrequencyInMillihertz();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Mosaic.Structures.DisplayTopologyStatus : ValueType {
    public static int MaxDisplays;
    internal StructureVersion _Version;
    internal DisplayCapacityProblem _Errors;
    internal DisplayTopologyWarning _Warnings;
    internal UInt32 _DisplayCounts;
    internal Display[] _Displays;
    public DisplayCapacityProblem Errors { get; }
    public DisplayTopologyWarning Warnings { get; }
    public Display[] Displays { get; }
    public DisplayCapacityProblem get_Errors();
    public DisplayTopologyWarning get_Warnings();
    public Display[] get_Displays();
}
public class NvAPIWrapper.Native.Mosaic.Structures.GridTopologyDisplayV1 : ValueType {
    internal UInt32 _DisplayId;
    internal int _OverlapX;
    internal int _OverlapY;
    internal Rotate _Rotation;
    internal UInt32 _CloneGroup;
    public UInt32 DisplayId { get; }
    public int OverlapX { get; }
    public int OverlapY { get; }
    public Rotate Rotation { get; }
    public UInt32 CloneGroup { get; }
    public PixelShiftType PixelShiftType { get; }
    public GridTopologyDisplayV1(UInt32 displayId, int overlapX, int overlapY, Rotate rotation, UInt32 cloneGroup);
    public sealed virtual bool Equals(GridTopologyDisplayV1 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(GridTopologyDisplayV1 left, GridTopologyDisplayV1 right);
    public static bool op_Inequality(GridTopologyDisplayV1 left, GridTopologyDisplayV1 right);
    public sealed virtual UInt32 get_DisplayId();
    public sealed virtual int get_OverlapX();
    public sealed virtual int get_OverlapY();
    public sealed virtual Rotate get_Rotation();
    public sealed virtual UInt32 get_CloneGroup();
    public sealed virtual PixelShiftType get_PixelShiftType();
}
[StructureVersionAttribute]
public class NvAPIWrapper.Native.Mosaic.Structures.GridTopologyDisplayV2 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _DisplayId;
    internal int _OverlapX;
    internal int _OverlapY;
    internal Rotate _Rotation;
    internal UInt32 _CloneGroup;
    internal PixelShiftType _PixelShiftType;
    public UInt32 DisplayId { get; }
    public int OverlapX { get; }
    public int OverlapY { get; }
    public Rotate Rotation { get; }
    public UInt32 CloneGroup { get; }
    public PixelShiftType PixelShiftType { get; }
    public GridTopologyDisplayV2(UInt32 displayId, int overlapX, int overlapY, Rotate rotation, UInt32 cloneGroup, PixelShiftType pixelShiftType);
    public sealed virtual bool Equals(GridTopologyDisplayV2 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(GridTopologyDisplayV2 left, GridTopologyDisplayV2 right);
    public static bool op_Inequality(GridTopologyDisplayV2 left, GridTopologyDisplayV2 right);
    public sealed virtual UInt32 get_DisplayId();
    public sealed virtual int get_OverlapX();
    public sealed virtual int get_OverlapY();
    public sealed virtual Rotate get_Rotation();
    public sealed virtual UInt32 get_CloneGroup();
    public sealed virtual PixelShiftType get_PixelShiftType();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Mosaic.Structures.GridTopologyV1 : ValueType {
    public static int MaxDisplays;
    internal StructureVersion _Version;
    internal UInt32 _Rows;
    internal UInt32 _Columns;
    internal UInt32 _DisplayCount;
    internal UInt32 _RawReserved;
    internal GridTopologyDisplayV1[] _Displays;
    internal DisplaySettingsV1 _DisplaySettings;
    public int Rows { get; }
    public int Columns { get; }
    public IEnumerable`1<IGridTopologyDisplay> Displays { get; }
    public DisplaySettingsV1 DisplaySettings { get; }
    public bool ApplyWithBezelCorrectedResolution { get; private set; }
    public bool ImmersiveGaming { get; private set; }
    public bool BaseMosaicPanoramic { get; private set; }
    public bool DriverReloadAllowed { get; private set; }
    public bool AcceleratePrimaryDisplay { get; private set; }
    public GridTopologyV1(int rows, int columns, GridTopologyDisplayV1[] displays, DisplaySettingsV1 displaySettings, bool applyWithBezelCorrectedResolution, bool immersiveGaming, bool baseMosaicPanoramic, bool driverReloadAllowed, bool acceleratePrimaryDisplay);
    public sealed virtual bool Equals(GridTopologyV1 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int get_Rows();
    public sealed virtual int get_Columns();
    public sealed virtual IEnumerable`1<IGridTopologyDisplay> get_Displays();
    public sealed virtual DisplaySettingsV1 get_DisplaySettings();
    public sealed virtual bool get_ApplyWithBezelCorrectedResolution();
    private void set_ApplyWithBezelCorrectedResolution(bool value);
    public sealed virtual bool get_ImmersiveGaming();
    private void set_ImmersiveGaming(bool value);
    public sealed virtual bool get_BaseMosaicPanoramic();
    private void set_BaseMosaicPanoramic(bool value);
    public sealed virtual bool get_DriverReloadAllowed();
    private void set_DriverReloadAllowed(bool value);
    public sealed virtual bool get_AcceleratePrimaryDisplay();
    private void set_AcceleratePrimaryDisplay(bool value);
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.Mosaic.Structures.GridTopologyV2 : ValueType {
    public static int MaxDisplays;
    internal StructureVersion _Version;
    internal UInt32 _Rows;
    internal UInt32 _Columns;
    internal UInt32 _DisplayCount;
    internal UInt32 _RawReserved;
    internal GridTopologyDisplayV2[] _Displays;
    internal DisplaySettingsV1 _DisplaySettings;
    public int Rows { get; }
    public int Columns { get; }
    public IEnumerable`1<IGridTopologyDisplay> Displays { get; }
    public DisplaySettingsV1 DisplaySettings { get; }
    public bool ApplyWithBezelCorrectedResolution { get; private set; }
    public bool ImmersiveGaming { get; private set; }
    public bool BaseMosaicPanoramic { get; private set; }
    public bool DriverReloadAllowed { get; private set; }
    public bool AcceleratePrimaryDisplay { get; private set; }
    public bool PixelShift { get; private set; }
    public GridTopologyV2(int rows, int columns, GridTopologyDisplayV2[] displays, DisplaySettingsV1 displaySettings, bool applyWithBezelCorrectedResolution, bool immersiveGaming, bool baseMosaicPanoramic, bool driverReloadAllowed, bool acceleratePrimaryDisplay, bool pixelShift);
    public sealed virtual bool Equals(GridTopologyV2 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int get_Rows();
    public sealed virtual int get_Columns();
    public sealed virtual IEnumerable`1<IGridTopologyDisplay> get_Displays();
    public sealed virtual DisplaySettingsV1 get_DisplaySettings();
    public sealed virtual bool get_ApplyWithBezelCorrectedResolution();
    private void set_ApplyWithBezelCorrectedResolution(bool value);
    public sealed virtual bool get_ImmersiveGaming();
    private void set_ImmersiveGaming(bool value);
    public sealed virtual bool get_BaseMosaicPanoramic();
    private void set_BaseMosaicPanoramic(bool value);
    public sealed virtual bool get_DriverReloadAllowed();
    private void set_DriverReloadAllowed(bool value);
    public sealed virtual bool get_AcceleratePrimaryDisplay();
    private void set_AcceleratePrimaryDisplay(bool value);
    public bool get_PixelShift();
    private void set_PixelShift(bool value);
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Mosaic.Structures.SupportedTopologiesInfoV1 : ValueType {
    public static int MaxSettings;
    internal StructureVersion _Version;
    internal UInt32 _TopologyBriefsCount;
    internal TopologyBrief[] _TopologyBriefs;
    internal UInt32 _DisplaySettingsCount;
    internal DisplaySettingsV1[] _DisplaySettings;
    public IEnumerable`1<TopologyBrief> TopologyBriefs { get; }
    public IEnumerable`1<IDisplaySettings> DisplaySettings { get; }
    public sealed virtual bool Equals(SupportedTopologiesInfoV1 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IEnumerable`1<TopologyBrief> get_TopologyBriefs();
    public sealed virtual IEnumerable`1<IDisplaySettings> get_DisplaySettings();
}
[StructureVersionAttribute("2")]
public class NvAPIWrapper.Native.Mosaic.Structures.SupportedTopologiesInfoV2 : ValueType {
    public static int MaxSettings;
    internal StructureVersion _Version;
    internal UInt32 _TopologyBriefsCount;
    internal TopologyBrief[] _TopologyBriefs;
    internal UInt32 _DisplaySettingsCount;
    internal DisplaySettingsV2[] _DisplaySettings;
    public IEnumerable`1<TopologyBrief> TopologyBriefs { get; }
    public IEnumerable`1<IDisplaySettings> DisplaySettings { get; }
    public sealed virtual bool Equals(SupportedTopologiesInfoV2 other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IEnumerable`1<TopologyBrief> get_TopologyBriefs();
    public sealed virtual IEnumerable`1<IDisplaySettings> get_DisplaySettings();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Mosaic.Structures.TopologyBrief : ValueType {
    internal StructureVersion _Version;
    internal Topology _Topology;
    internal UInt32 _IsEnable;
    internal UInt32 _IsPossible;
    public Topology Topology { get; }
    public bool IsEnable { get; }
    public bool IsPossible { get; }
    public TopologyBrief(Topology topology);
    public sealed virtual bool Equals(TopologyBrief other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TopologyBrief left, TopologyBrief right);
    public static bool op_Inequality(TopologyBrief left, TopologyBrief right);
    public Topology get_Topology();
    public bool get_IsEnable();
    public bool get_IsPossible();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Mosaic.Structures.TopologyDetails : ValueType {
    public static int MaxLayoutRows;
    public static int MaxLayoutColumns;
    internal StructureVersion _Version;
    internal LogicalGPUHandle _LogicalGPUHandle;
    internal TopologyValidity _ValidityFlags;
    internal UInt32 _Rows;
    internal UInt32 _Columns;
    internal LayoutRow[] _LayoutRows;
    public LogicalGPUHandle LogicalGPUHandle { get; }
    public TopologyValidity ValidityFlags { get; }
    public int Rows { get; }
    public int Columns { get; }
    public LayoutCell[][] Layout { get; }
    public sealed virtual bool Equals(TopologyDetails other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TopologyDetails left, TopologyDetails right);
    public static bool op_Inequality(TopologyDetails left, TopologyDetails right);
    public LogicalGPUHandle get_LogicalGPUHandle();
    public TopologyValidity get_ValidityFlags();
    public int get_Rows();
    public int get_Columns();
    public LayoutCell[][] get_Layout();
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Mosaic.Structures.TopologyGroup : ValueType {
    public static int MaxTopologyPerGroup;
    internal StructureVersion _Version;
    internal TopologyBrief _Brief;
    internal UInt32 _TopologiesCount;
    internal TopologyDetails[] _TopologyDetails;
    public TopologyBrief Brief { get; }
    public TopologyDetails[] TopologyDetails { get; }
    public TopologyBrief get_Brief();
    public TopologyDetails[] get_TopologyDetails();
    public sealed virtual bool Equals(TopologyGroup other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(TopologyGroup left, TopologyGroup right);
    public static bool op_Inequality(TopologyGroup left, TopologyGroup right);
    public virtual int GetHashCode();
}
public enum NvAPIWrapper.Native.Mosaic.Topology : Enum {
    public int value__;
    public static Topology None;
    public static Topology Basic_1X2;
    public static Topology Basic_2X1;
    public static Topology Basic_1X3;
    public static Topology Basic_3X1;
    public static Topology Basic_1X4;
    public static Topology Basic_4X1;
    public static Topology Basic_2X2;
    public static Topology Basic_2X3;
    public static Topology Basic_2X4;
    public static Topology Basic_3X2;
    public static Topology Basic_4X2;
    public static Topology Basic_1X5;
    public static Topology Basic_1X6;
    public static Topology Basic_7X1;
    public static Topology PassiveStereo_1X2;
    public static Topology PassiveStereo_2X1;
    public static Topology PassiveStereo_1X3;
    public static Topology PassiveStereo_3X1;
    public static Topology PassiveStereo_1X4;
    public static Topology PassiveStereo_4X1;
    public static Topology PassiveStereo_2X2;
    public static Topology Max;
}
public enum NvAPIWrapper.Native.Mosaic.TopologyType : Enum {
    public int value__;
    public static TopologyType All;
    public static TopologyType Basic;
    public static TopologyType PassiveStereo;
    public static TopologyType ScaledClone;
    public static TopologyType PassiveStereoScaledClone;
}
[FlagsAttribute]
public enum NvAPIWrapper.Native.Mosaic.TopologyValidity : Enum {
    public UInt32 value__;
    public static TopologyValidity Valid;
    public static TopologyValidity MissingGPU;
    public static TopologyValidity MissingDisplay;
    public static TopologyValidity MixedDisplayTypes;
}
public static class NvAPIWrapper.Native.MosaicApi : object {
    public static void EnableCurrentTopology(bool enable);
    public static IGridTopology[] EnumDisplayGrids();
    public static IDisplaySettings[] EnumDisplayModes(IGridTopology gridTopology);
    public static void GetCurrentTopology(TopologyBrief& topoBrief, IDisplaySettings& displaySettings, Int32& overlapX, Int32& overlapY);
    public static void GetOverlapLimits(TopologyBrief topoBrief, IDisplaySettings displaySettings, Int32& minOverlapX, Int32& maxOverlapX, Int32& minOverlapY, Int32& maxOverlapY);
    public static ISupportedTopologiesInfo GetSupportedTopologiesInfo(TopologyType topologyType);
    public static TopologyGroup GetTopologyGroup(TopologyBrief topoBrief);
    public static void SetCurrentTopology(TopologyBrief topoBrief, IDisplaySettings displaySettings, int overlapX, int overlapY, bool enable);
    public static void SetDisplayGrids(IGridTopology[] gridTopologies, SetDisplayTopologyFlag flags);
    public static DisplayTopologyStatus[] ValidateDisplayGrids(IGridTopology[] gridTopologies, SetDisplayTopologyFlag flags);
}
public enum NvAPIWrapper.Native.Stereo.StereoActivationFlag : Enum {
    public int value__;
    public static StereoActivationFlag Immediate;
    public static StereoActivationFlag Delayed;
}
public enum NvAPIWrapper.Native.Stereo.StereoActiveEye : Enum {
    public int value__;
    public static StereoActiveEye None;
    public static StereoActiveEye RightEye;
    public static StereoActiveEye LeftEye;
    public static StereoActiveEye Mono;
}
public enum NvAPIWrapper.Native.Stereo.StereoDriverMode : Enum {
    public int value__;
    public static StereoDriverMode Automatic;
    public static StereoDriverMode Direct;
}
public enum NvAPIWrapper.Native.Stereo.StereoFrustumAdjustMode : Enum {
    public int value__;
    public static StereoFrustumAdjustMode NoFrustumAdjust;
    public static StereoFrustumAdjustMode Stretch;
    public static StereoFrustumAdjustMode ClearEdges;
}
public enum NvAPIWrapper.Native.Stereo.StereoRegistryIdentification : Enum {
    public int value__;
    public static StereoRegistryIdentification Convergence;
    public static StereoRegistryIdentification FrustumAdjustMode;
}
public enum NvAPIWrapper.Native.Stereo.StereoRegistryProfileType : Enum {
    public int value__;
    public static StereoRegistryProfileType DefaultProfile;
    public static StereoRegistryProfileType DirectX9Profile;
    public static StereoRegistryProfileType DirectX10Profile;
}
public enum NvAPIWrapper.Native.Stereo.StereoSurfaceCreateMode : Enum {
    public int value__;
    public static StereoSurfaceCreateMode Auto;
    public static StereoSurfaceCreateMode ForceStereo;
    public static StereoSurfaceCreateMode ForceMono;
}
public enum NvAPIWrapper.Native.Stereo.StereoSwapChainMode : Enum {
    public int value__;
    public static StereoSwapChainMode Default;
    public static StereoSwapChainMode Stereo;
    public static StereoSwapChainMode Mono;
}
[StructureVersionAttribute("1")]
public class NvAPIWrapper.Native.Stereo.Structures.StereoCapabilitiesV1 : ValueType {
    internal StructureVersion _Version;
    internal UInt32 _Flags;
    internal UInt32 _Reserved1;
    internal UInt32 _Reserved2;
    internal UInt32 _Reserved3;
    public bool IsNoWindowedModeSupported { get; }
    public bool IsAutomaticWindowedModeSupported { get; }
    public bool IsPersistentWindowedModeSupported { get; }
    public bool get_IsNoWindowedModeSupported();
    public bool get_IsAutomaticWindowedModeSupported();
    public bool get_IsPersistentWindowedModeSupported();
}
public class NvAPIWrapper.Native.Stereo.Structures.StereoHandle : ValueType {
    internal IntPtr _MemoryAddress;
    public IntPtr MemoryAddress { get; }
    public bool IsNull { get; }
    public static StereoHandle DefaultHandle { get; }
    public sealed virtual bool Equals(StereoHandle other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual IntPtr get_MemoryAddress();
    public sealed virtual bool get_IsNull();
    public static bool op_Equality(StereoHandle left, StereoHandle right);
    public static bool op_Inequality(StereoHandle left, StereoHandle right);
    public static StereoHandle get_DefaultHandle();
}
public static class NvAPIWrapper.Native.StereoApi : object {
    public static void ActivateStereo(StereoHandle handle);
    public static void CaptureJpegImage(StereoHandle handle, UInt32 quality);
    public static void CapturePngImage(StereoHandle handle);
    public static void CreateConfigurationProfileRegistryKey(StereoRegistryProfileType registryProfileType);
    public static StereoHandle CreateHandleFromIUnknown(IntPtr d3dDevice);
    public static IntPtr D3D1XCreateSwapChain(StereoHandle handle, IntPtr dxgiSwapChainDescription, StereoSwapChainMode swapChainMode);
    public static IntPtr D3D9CreateSwapChain(StereoHandle handle, IntPtr d3dPresentParameters, StereoSwapChainMode swapChainMode);
    public static void DeactivateStereo(StereoHandle handle);
    public static void DecreaseConvergence(StereoHandle handle);
    public static void DecreaseSeparation(StereoHandle handle);
    public static void DeleteConfigurationProfileRegistryKey(StereoRegistryProfileType registryProfileType);
    public static void DeleteConfigurationProfileValue(StereoRegistryProfileType registryProfileType, StereoRegistryIdentification registryId);
    public static void DestroyHandle(StereoHandle handle);
    public static void DisableStereo();
    public static void EnableStereo();
    public static float GetConvergence(StereoHandle handle);
    public static string GetDefaultProfile();
    public static float GetEyeSeparation(StereoHandle handle);
    public static StereoFrustumAdjustMode GetFrustumAdjustMode(StereoHandle handle);
    public static float GetSeparation(StereoHandle handle);
    public static StereoCapabilitiesV1 GetStereoSupport(IntPtr monitorHandle);
    public static StereoSurfaceCreateMode GetSurfaceCreationMode(StereoHandle handle);
    public static void IncreaseConvergence(StereoHandle handle);
    public static void IncreaseSeparation(StereoHandle handle);
    public static void InitActivation(StereoHandle handle, StereoActivationFlag activationFlag);
    public static bool IsStereoActivated(StereoHandle handle);
    public static bool IsStereoEnabled();
    public static bool IsWindowedModeSupported();
    public static void ReverseStereoBlitControl(StereoHandle handle, bool turnOn);
    public static void SetActiveEye(StereoHandle handle, StereoActiveEye activeEye);
    public static void SetConfigurationProfileValue(StereoRegistryProfileType registryProfileType, StereoRegistryIdentification registryId, float value);
    public static void SetConfigurationProfileValue(StereoRegistryProfileType registryProfileType, StereoRegistryIdentification registryId, int value);
    public static void SetConvergence(StereoHandle handle, float convergence);
    public static void SetDefaultProfile(string profileName);
    public static void SetDriverMode(StereoDriverMode driverMode);
    public static void SetFrustumAdjustMode(StereoHandle handle, StereoFrustumAdjustMode frustumAdjustMode);
    public static bool WasLastDrawStereoizedDebug(StereoHandle handle);
    public static void SetNotificationMessage(StereoHandle handle, ulong windowsHandle, ulong messageId);
    public static void SetSeparation(StereoHandle handle, float separationPercentage);
    public static void SetSurfaceCreationMode(StereoHandle handle, StereoSurfaceCreateMode surfaceCreateMode);
    public static void TriggerActivation(StereoHandle handle);
}
public static class NvAPIWrapper.NVIDIA : object {
    public static IChipsetInfo ChipsetInfo { get; }
    public static string DriverBranchVersion { get; }
    public static UInt32 DriverVersion { get; }
    public static string InterfaceVersionString { get; }
    public static LidDockParameters LidAndDockParameters { get; }
    public static IChipsetInfo get_ChipsetInfo();
    public static string get_DriverBranchVersion();
    public static UInt32 get_DriverVersion();
    public static string get_InterfaceVersionString();
    public static LidDockParameters get_LidAndDockParameters();
    public static void Initialize();
    public static void RestartDisplayDriver();
    public static void Unload();
}
public class NvAPIWrapper.Stereo.StereoApplicationConfiguration : object {
    [CompilerGeneratedAttribute]
private static StereoApplicationConfiguration <DefaultConfigurationProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private static StereoApplicationConfiguration <DirectX10ConfigurationProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private static StereoApplicationConfiguration <DirectX9ConfigurationProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private StereoRegistryProfileType <ProfileType>k__BackingField;
    public static StereoApplicationConfiguration DefaultConfigurationProfile { get; }
    public static string DefaultProfile { get; }
    public static StereoApplicationConfiguration DirectX10ConfigurationProfile { get; }
    public static StereoApplicationConfiguration DirectX9ConfigurationProfile { get; }
    public static bool IsStereoEnable { get; }
    public static bool IsWindowedModeSupported { get; }
    public StereoRegistryProfileType ProfileType { get; }
    private StereoApplicationConfiguration(StereoRegistryProfileType profileType);
    private static StereoApplicationConfiguration();
    [CompilerGeneratedAttribute]
public static StereoApplicationConfiguration get_DefaultConfigurationProfile();
    public static string get_DefaultProfile();
    [CompilerGeneratedAttribute]
public static StereoApplicationConfiguration get_DirectX10ConfigurationProfile();
    [CompilerGeneratedAttribute]
public static StereoApplicationConfiguration get_DirectX9ConfigurationProfile();
    public static bool get_IsStereoEnable();
    public static bool get_IsWindowedModeSupported();
    [CompilerGeneratedAttribute]
public StereoRegistryProfileType get_ProfileType();
    public static void DisableStereo();
    public static void EnableStereo();
    public static StereoCapabilitiesV1 GetMonitorCapabilities(IntPtr monitorHandle);
    public static void SetDefaultProfile(string profileName);
    public static void SetDriverMode(StereoDriverMode driverMode);
    public void DeleteAllValues();
    public void DeleteValue(StereoRegistryIdentification valueId);
    public void SetValue(StereoRegistryIdentification valueId, float value);
    public void SetValue(StereoRegistryIdentification valueId, int value);
}
public class NvAPIWrapper.Stereo.StereoDeviceSession : object {
    [CompilerGeneratedAttribute]
private StereoHandle <Handle>k__BackingField;
    public float Convergence { get; public set; }
    public float EyeSeparation { get; }
    public StereoFrustumAdjustMode FrustumAdjustMode { get; public set; }
    public StereoHandle Handle { get; private set; }
    public bool IsStereoActivated { get; }
    public bool IsValid { get; }
    public float Separation { get; public set; }
    public StereoSurfaceCreateMode SurfaceCreationMode { get; public set; }
    public StereoDeviceSession(StereoHandle handle);
    public float get_Convergence();
    public void set_Convergence(float value);
    public float get_EyeSeparation();
    public StereoFrustumAdjustMode get_FrustumAdjustMode();
    public void set_FrustumAdjustMode(StereoFrustumAdjustMode value);
    [CompilerGeneratedAttribute]
public StereoHandle get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(StereoHandle value);
    public bool get_IsStereoActivated();
    public bool get_IsValid();
    public float get_Separation();
    public void set_Separation(float value);
    public StereoSurfaceCreateMode get_SurfaceCreationMode();
    public void set_SurfaceCreationMode(StereoSurfaceCreateMode value);
    public sealed virtual void Dispose();
    public static StereoDeviceSession CreateFromIUnknownD3DDevice(IntPtr d3dDevice);
    public void ActivateStereo();
    public void CaptureJPEGImage(UInt32 quality);
    public void CapturePNGImage();
    public IntPtr D3D1XCreateSwapChain(IntPtr dxgiSwapChainDescription, StereoSwapChainMode swapChainMode);
    public IntPtr D3D9CreateSwapChain(IntPtr d3dPresentParameters, StereoSwapChainMode swapChainMode);
    public void DeactivateStereo();
    public void DecreaseConvergence();
    public void DecreaseSeparation();
    public void IncreaseConvergence();
    public void IncreaseSeparation();
    public void InitActivation(StereoActivationFlag activationFlag);
    public void ReverseStereoBlitControl(bool turnOn);
    public void SetActiveEye(StereoActiveEye activeKey);
    public void SetNotificationMessage(ulong windowsHandle, ulong messageId);
    public void TriggerActivation();
    public bool WasLastDrawStereoizedDebugOnly();
    private void ReleaseUnmanagedResources();
    protected virtual override void Finalize();
}
