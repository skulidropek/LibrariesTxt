[ExtensionAttribute]
public static class NuGet.Packaging.CollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
internal class NuGet.Packaging.EmptyFrameworkFolderFile : PhysicalPackageFile {
    public EmptyFrameworkFolderFile(string directoryPathInPackage);
}
public class NuGet.Packaging.FallbackPackagePathInfo : object {
    [CompilerGeneratedAttribute]
private VersionFolderPathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    public VersionFolderPathResolver PathResolver { get; }
    public string Id { get; }
    public NuGetVersion Version { get; }
    public FallbackPackagePathInfo(string id, NuGetVersion version, VersionFolderPathResolver resolver);
    [CompilerGeneratedAttribute]
public VersionFolderPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
}
public class NuGet.Packaging.FallbackPackagePathResolver : object {
    private List`1<VersionFolderPathResolver> _pathResolvers;
    public FallbackPackagePathResolver(INuGetPathContext pathContext);
    public FallbackPackagePathResolver(string userPackageFolder, IEnumerable`1<string> fallbackPackageFolders);
    public string GetPackageDirectory(string packageId, string version);
    public string GetPackageDirectory(string packageId, NuGetVersion version);
    public FallbackPackagePathInfo GetPackageInfo(string packageId, NuGetVersion version);
}
public class NuGet.Packaging.FrameworkAssemblyReference : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NuGetFramework> <SupportedFrameworks>k__BackingField;
    public string AssemblyName { get; private set; }
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; private set; }
    public FrameworkAssemblyReference(string assemblyName, IEnumerable`1<NuGetFramework> supportedFrameworks);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
private void set_SupportedFrameworks(IEnumerable`1<NuGetFramework> value);
}
public static class NuGet.Packaging.FrameworkNameUtility : object {
    public static FrameworkName ParseFrameworkNameFromFilePath(string filePath, String& effectivePath);
    public static FrameworkName ParseFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
}
[ExtensionAttribute]
public static class NuGet.Packaging.FrameworksExtensions : object {
    [ExtensionAttribute]
public static string GetFrameworkString(NuGetFramework self);
}
public interface NuGet.Packaging.INuspecReader {
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public abstract virtual string GetLanguage();
}
public interface NuGet.Packaging.IPackageContentReader {
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
}
public interface NuGet.Packaging.IPackageFile {
    public string Path { get; }
    public string EffectivePath { get; }
    public FrameworkName TargetFramework { get; }
    public abstract virtual string get_Path();
    public abstract virtual string get_EffectivePath();
    public abstract virtual FrameworkName get_TargetFramework();
    public abstract virtual Stream GetStream();
}
public interface NuGet.Packaging.IPackageMetadata {
    public string Id { get; }
    public NuGetVersion Version { get; }
    public string Title { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public Uri IconUrl { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public bool DevelopmentDependency { get; }
    public string Description { get; }
    public string Summary { get; }
    public string ReleaseNotes { get; }
    public string Language { get; }
    public string Tags { get; }
    public bool Serviceable { get; }
    public string Copyright { get; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; }
    public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; }
    public Version MinClientVersion { get; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; }
    public IEnumerable`1<PackageType> PackageTypes { get; }
    public abstract virtual string get_Id();
    public abstract virtual NuGetVersion get_Version();
    public abstract virtual string get_Title();
    public abstract virtual IEnumerable`1<string> get_Authors();
    public abstract virtual IEnumerable`1<string> get_Owners();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual bool get_DevelopmentDependency();
    public abstract virtual string get_Description();
    public abstract virtual string get_Summary();
    public abstract virtual string get_ReleaseNotes();
    public abstract virtual string get_Language();
    public abstract virtual string get_Tags();
    public abstract virtual bool get_Serviceable();
    public abstract virtual string get_Copyright();
    public abstract virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    public abstract virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public abstract virtual Version get_MinClientVersion();
    public abstract virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    public abstract virtual IEnumerable`1<PackageType> get_PackageTypes();
}
public interface NuGet.Packaging.IPackageResolver {
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
}
public class NuGet.Packaging.Manifest : object {
    private static string SchemaVersionAttributeName;
    [CompilerGeneratedAttribute]
private ManifestMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFilesNode>k__BackingField;
    public ManifestMetadata Metadata { get; }
    public ICollection`1<ManifestFile> Files { get; }
    public bool HasFilesNode { get; }
    public Manifest(ManifestMetadata metadata);
    public Manifest(ManifestMetadata metadata, ICollection`1<ManifestFile> files);
    [CompilerGeneratedAttribute]
public ManifestMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestFile> get_Files();
    [CompilerGeneratedAttribute]
public bool get_HasFilesNode();
    public void Save(Stream stream);
    public void Save(Stream stream, int minimumManifestVersion);
    public void Save(Stream stream, bool validate);
    public void Save(Stream stream, bool validate, int minimumManifestVersion);
    public static Manifest ReadFrom(Stream stream, bool validateSchema);
    public static Manifest ReadFrom(Stream stream, Func`2<string, string> propertyProvider, bool validateSchema);
    private static string GetSchemaNamespace(XDocument document);
    public static Manifest Create(IPackageMetadata metadata);
    private static void ValidateManifestSchema(XDocument document, string schemaNamespace);
    private static void CheckSchemaVersion(XDocument document);
    private static string GetPackageId(XElement metadataElement);
    private static XElement GetMetadataElement(XDocument document);
    public static void Validate(Manifest manifest);
    private static void ValidateDependencyGroups(IPackageMetadata metadata);
    private static void ValidateDependencyVersion(PackageDependency dependency);
}
public class NuGet.Packaging.ManifestContentFiles : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flatten>k__BackingField;
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public string BuildAction { get; public set; }
    public string CopyToOutput { get; public set; }
    public string Flatten { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(string value);
    [CompilerGeneratedAttribute]
public string get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(string value);
    [CompilerGeneratedAttribute]
public string get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(string value);
}
public class NuGet.Packaging.ManifestFile : object {
    private static Char[] _invalidSourceCharacters;
    internal static Char[] ReferenceFileInvalidCharacters;
    private static Char[] _invalidTargetChars;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    public string Source { get; public set; }
    public string Target { get; public set; }
    public string Exclude { get; public set; }
    private static ManifestFile();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestFile/<Validate>d__15")]
public IEnumerable`1<string> Validate();
}
public class NuGet.Packaging.ManifestMetadata : object {
    private string _minClientVersionString;
    private IEnumerable`1<string> _authors;
    private IEnumerable`1<string> _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    private IEnumerable`1<PackageDependencyGroup> _dependencyGroups;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    private IEnumerable`1<PackageReferenceSet> _packageAssemblyReferences;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageType> <PackageTypes>k__BackingField;
    [ManifestVersionAttribute("5")]
public string MinClientVersionString { get; public set; }
    public Version MinClientVersion { get; private set; }
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public string Title { get; public set; }
    public IEnumerable`1<string> Authors { get; public set; }
    public IEnumerable`1<string> Owners { get; public set; }
    public Uri IconUrl { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    [ManifestVersionAttribute("2")]
public string ReleaseNotes { get; public set; }
    [ManifestVersionAttribute("2")]
public string Copyright { get; public set; }
    public string Language { get; public set; }
    public string Tags { get; public set; }
    public bool Serviceable { get; public set; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; public set; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; public set; }
    [ManifestVersionAttribute("2")]
public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; public set; }
    public IEnumerable`1<PackageType> PackageTypes { get; public set; }
    public ManifestMetadata(IPackageMetadata copy);
    public string get_MinClientVersionString();
    public void set_MinClientVersionString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
private void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public sealed virtual IEnumerable`1<string> get_Authors();
    public void set_Authors(IEnumerable`1<string> value);
    public sealed virtual IEnumerable`1<string> get_Owners();
    public void set_Owners(IEnumerable`1<string> value);
    public void SetIconUrl(string iconUrl);
    public sealed virtual Uri get_IconUrl();
    public void SetLicenseUrl(string licenseUrl);
    public sealed virtual Uri get_LicenseUrl();
    public void SetProjectUrl(string projectUrl);
    public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public void set_DependencyGroups(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferences(IEnumerable`1<FrameworkAssemblyReference> value);
    public sealed virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public void set_PackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> value);
    private static IEnumerable`1<PackageReferenceSet> MergePackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> referenceSets);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IEnumerable`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(IEnumerable`1<PackageType> value);
    private static IEnumerable`1<PackageDependencyGroup> MergeDependencyGroups(IEnumerable`1<PackageDependencyGroup> actualDependencyGroups);
    private static PackageDependencyGroup CreatePackageDependencyGroup(PackageDependencyGroup dependencyGroup);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestMetadata/<Validate>d__101")]
public IEnumerable`1<string> Validate();
}
internal static class NuGet.Packaging.ManifestReader : object {
    private static String[] RequiredElements;
    private static ManifestReader();
    public static Manifest ReadManifest(XDocument document);
    private static ManifestMetadata ReadMetadata(XElement xElement);
    private static void ReadMetadataValue(ManifestMetadata manifestMetadata, XElement element, HashSet`1<string> allElements);
    private static List`1<ManifestContentFiles> ReadContentFiles(XElement contentFilesElement);
    private static List`1<PackageReferenceSet> ReadReferenceSets(XElement referencesElement);
    public static List`1<string> ReadReference(XElement referenceElement, bool throwIfEmpty);
    private static List`1<FrameworkAssemblyReference> ReadFrameworkAssemblies(XElement frameworkElement);
    private static List`1<PackageDependencyGroup> ReadDependencyGroups(XElement dependenciesElement);
    private static List`1<PackageDependency> ReadDependencies(XElement containerElement);
    private static List`1<ManifestFile> ReadFilesList(XElement xElement);
}
public static class NuGet.Packaging.ManifestSchemaUtility : object {
    internal static string SchemaVersionV1;
    internal static string SchemaVersionV2;
    internal static string SchemaVersionV3;
    internal static string SchemaVersionV4;
    internal static string SchemaVersionV5;
    internal static string SchemaVersionV6;
    private static String[] VersionToSchemaMappings;
    private static ManifestSchemaUtility();
    public static int GetVersionFromNamespace(string namespace);
    public static string GetSchemaNamespace(int version);
    public static bool IsKnownSchema(string schemaNamespace);
}
[AttributeUsageAttribute("128")]
internal class NuGet.Packaging.ManifestVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; private set; }
    public ManifestVersionAttribute(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
}
public static class NuGet.Packaging.ManifestVersionUtility : object {
    public static int DefaultVersion;
    public static int SemverVersion;
    public static int TargetFrameworkSupportForDependencyContentsAndToolsVersion;
    public static int TargetFrameworkSupportForReferencesVersion;
    public static int XdtTransformationVersion;
    public static int GetManifestVersion(ManifestMetadata metadata);
    private static int GetMaxVersionFromMetadata(ManifestMetadata metadata);
    private static int GetVersionFromObject(object obj);
    private static int GetVersionFromPropertyInfo(object obj, PropertyInfo property);
    private static int VisitList(IEnumerable list);
    private static Nullable`1<int> GetPropertyVersion(PropertyInfo property);
}
public class NuGet.Packaging.MinClientVersionException : PackagingException {
    public MinClientVersionException(string message);
}
public static class NuGet.Packaging.MinClientVersionUtility : object {
    private static NuGetVersion _clientVersion;
    public static void VerifyMinClientVersion(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuGetVersion packageMinClientVersion);
    public static NuGetVersion GetNuGetClientVersion();
}
public class NuGet.Packaging.NuspecReader : NuspecCoreReaderBase {
    private static string Dependencies;
    private static string Group;
    private static string TargetFramework;
    private static string Dependency;
    private static string References;
    private static string Reference;
    private static string File;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Language;
    private static string ContentFiles;
    private static string Files;
    private static string BuildAction;
    private static string Flatten;
    private static string CopyToOutput;
    private static string IncludeFlags;
    private static string ExcludeFlags;
    private static string LicenseUrl;
    private static Char[] CommaArray;
    private IFrameworkNameProvider _frameworkProvider;
    private static List`1<string> EmptyList;
    public NuspecReader(string path);
    public NuspecReader(string path, IFrameworkNameProvider frameworkProvider);
    public NuspecReader(Stream stream);
    public NuspecReader(XDocument xml);
    public NuspecReader(Stream stream, IFrameworkNameProvider frameworkProvider, bool leaveStreamOpen);
    public NuspecReader(XDocument xml, IFrameworkNameProvider frameworkProvider);
    private static NuspecReader();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetDependencyGroups>d__27")]
public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetReferenceGroups>d__28")]
public IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public string GetLanguage();
    public string GetLicenseUrl();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetContentFiles>d__32")]
public IEnumerable`1<ContentFilesEntry> GetContentFiles();
    public string GetTitle();
    public string GetAuthors();
    public string GetTags();
    public string GetOwners();
    public string GetDescription();
    public string GetReleaseNotes();
    public string GetSummary();
    public string GetProjectUrl();
    public string GetIconUrl();
    public string GetCopyright();
    public bool GetRequireLicenseAcceptance();
    private static Nullable`1<bool> AttributeAsNullableBool(XElement element, string attributeName);
    private static string GetAttributeValue(XElement element, string attributeName);
    private static List`1<string> GetFlags(string flags);
}
public class NuGet.Packaging.PackageArchiveReader : PackageReaderBase {
    private ZipArchive _zipArchive;
    public PackageArchiveReader(Stream stream);
    public PackageArchiveReader(Stream stream, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(ZipArchive zipArchive);
    public PackageArchiveReader(ZipArchive zipArchive, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(string filePath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public virtual IEnumerable`1<string> GetFiles();
    public virtual IEnumerable`1<string> GetFiles(string folder);
    public virtual Stream GetStream(string path);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public string ExtractFile(string packageFile, string targetFilePath, ILogger logger);
    private ZipArchiveEntry GetEntry(string packageFile);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<EnumeratePackageEntries>d__15")]
public IEnumerable`1<ZipFilePair> EnumeratePackageEntries(IEnumerable`1<string> packageFiles, string packageDirectory);
}
public class NuGet.Packaging.PackageBuilder : object {
    private static DateTime MinZipLastWriteTime;
    private static string DefaultContentType;
    private static Uri DefaultUri;
    internal static string ManifestRelationType;
    private bool _includeEmptyDirectories;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSnapshotVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IPackageFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageReferenceSet> <PackageAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public bool HasSnapshotVersion { get; public set; }
    public string Title { get; public set; }
    public ISet`1<string> Authors { get; private set; }
    public ISet`1<string> Owners { get; private set; }
    public Uri IconUrl { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool Serviceable { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public string OutputName { get; public set; }
    public ISet`1<string> Tags { get; private set; }
    public Dictionary`2<string, string> Properties { get; private set; }
    public string Copyright { get; public set; }
    public Collection`1<PackageDependencyGroup> DependencyGroups { get; private set; }
    public ICollection`1<IPackageFile> Files { get; private set; }
    public Collection`1<FrameworkAssemblyReference> FrameworkReferences { get; private set; }
    public IList`1<NuGetFramework> TargetFrameworks { get; public set; }
    public ICollection`1<ManifestContentFiles> ContentFiles { get; private set; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public ICollection`1<PackageType> PackageTypes { get; public set; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Owners { get; }
    private string NuGet.Packaging.IPackageMetadata.Tags { get; }
    private IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences { get; }
    private IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.DependencyGroups { get; }
    private IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.FrameworkReferences { get; }
    private IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.ContentFiles { get; }
    private IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.PackageTypes { get; }
    public Version MinClientVersion { get; public set; }
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(Stream stream, string basePath);
    public PackageBuilder(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    private PackageBuilder(bool includeEmptyDirectories);
    private static PackageBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_HasSnapshotVersion();
    [CompilerGeneratedAttribute]
public void set_HasSnapshotVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public Collection`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
private void set_DependencyGroups(Collection`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public ICollection`1<IPackageFile> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(ICollection`1<IPackageFile> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferences(Collection`1<FrameworkAssemblyReference> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
private void set_ContentFiles(ICollection`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    [CompilerGeneratedAttribute]
public void set_PackageAssemblyReferences(ICollection`1<PackageReferenceSet> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(ICollection`1<PackageType> value);
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Owners();
    private sealed virtual override string NuGet.Packaging.IPackageMetadata.get_Tags();
    private sealed virtual override IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.get_PackageAssemblyReferences();
    private sealed virtual override IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.get_DependencyGroups();
    private sealed virtual override IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.get_FrameworkReferences();
    private sealed virtual override IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.get_ContentFiles();
    private sealed virtual override IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.get_PackageTypes();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    public void Save(Stream stream);
    private static string CreatorInfo();
    private static int DetermineMinimumSchemaVersion(ICollection`1<IPackageFile> Files, ICollection`1<PackageDependencyGroup> package);
    private static bool RequiresV4TargetFrameworkSchema(ICollection`1<IPackageFile> files);
    private static bool HasContentFilesV2(ICollection`1<IPackageFile> contentFiles);
    private static bool HasIncludeExclude(IEnumerable`1<PackageDependencyGroup> dependencyGroups);
    private static bool HasXdtTransformFile(ICollection`1<IPackageFile> contentFiles);
    public static void ValidateDependencyGroups(SemanticVersion version, IEnumerable`1<PackageDependencyGroup> dependencies);
    public static void ValidateReferenceAssemblies(IEnumerable`1<IPackageFile> files, IEnumerable`1<PackageReferenceSet> packageAssemblyReferences);
    private void ReadManifest(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public void Populate(ManifestMetadata manifestMetadata);
    public void PopulateFiles(string basePath, IEnumerable`1<ManifestFile> files);
    private void WriteManifest(ZipArchive package, int minimumManifestVersion, string psmdcpPath);
    private HashSet`1<string> WriteFiles(ZipArchive package, HashSet`1<string> filesWithoutExtensions);
    public void AddFiles(string basePath, string source, string destination, string exclude);
    internal static IEnumerable`1<PhysicalPackageFile> ResolveSearchPattern(string basePath, string searchPath, string targetPath, bool includeEmptyDirectories);
    internal static string ResolvePackagePath(string searchDirectory, string searchPattern, string fullPath, string targetPath);
    private static bool IsKnownFolder(string targetPath);
    private static void ExcludeFiles(List`1<PhysicalPackageFile> searchFiles, string basePath, string exclude);
    private static void CreatePart(ZipArchive package, IPackageFile file, Stream sourceStream);
    internal static string CreatePartEntryName(string path);
    internal static string GetStringForPartUri(string escapedPath);
    private static IEnumerable`1<string> ParseTags(string tags);
    private static bool IsPrereleaseDependency(PackageDependency dependency);
    private static bool ValidateSpecialVersionLength(SemanticVersion version);
    private void WriteOpcManifestRelationship(ZipArchive package, string path, string psmdcpPath);
    private static void WriteOpcContentTypes(ZipArchive package, HashSet`1<string> extensions, HashSet`1<string> filesWithoutExtensions);
    private void WriteOpcPackageProperties(ZipArchive package, string psmdcpPath);
    private string GenerateRelationshipId();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class NuGet.Packaging.PackageCreation.Resources.NuGetResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string CannotCreateEmptyPackage { get; }
    public static string DependencyHasInvalidVersion { get; }
    public static string DuplicateDependenciesDefined { get; }
    public static string IncompatibleSchema { get; }
    public static string InvalidPackageId { get; }
    public static string Manifest_DependenciesHasMixedElements { get; }
    public static string Manifest_ExcludeContainsInvalidCharacters { get; }
    public static string Manifest_IdMaxLengthExceeded { get; }
    public static string Manifest_InvalidMinClientVersion { get; }
    public static string Manifest_InvalidPrereleaseDependency { get; }
    public static string Manifest_InvalidReference { get; }
    public static string Manifest_InvalidReferenceFile { get; }
    public static string Manifest_ReferencesHasMixedElements { get; }
    public static string Manifest_ReferencesIsEmpty { get; }
    public static string Manifest_RequiredElementMissing { get; }
    public static string Manifest_RequiredMetadataMissing { get; }
    public static string Manifest_RequireLicenseAcceptanceRequiresLicenseUrl { get; }
    public static string Manifest_SourceContainsInvalidCharacters { get; }
    public static string Manifest_TargetContainsInvalidCharacters { get; }
    public static string Manifest_UriCannotBeEmpty { get; }
    public static string PackageAuthoring_FileNotFound { get; }
    public static string SemVerSpecialVersionTooLong { get; }
    public static string UnknownSchemaVersion { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_CannotCreateEmptyPackage();
    public static string get_DependencyHasInvalidVersion();
    public static string get_DuplicateDependenciesDefined();
    public static string get_IncompatibleSchema();
    public static string get_InvalidPackageId();
    public static string get_Manifest_DependenciesHasMixedElements();
    public static string get_Manifest_ExcludeContainsInvalidCharacters();
    public static string get_Manifest_IdMaxLengthExceeded();
    public static string get_Manifest_InvalidMinClientVersion();
    public static string get_Manifest_InvalidPrereleaseDependency();
    public static string get_Manifest_InvalidReference();
    public static string get_Manifest_InvalidReferenceFile();
    public static string get_Manifest_ReferencesHasMixedElements();
    public static string get_Manifest_ReferencesIsEmpty();
    public static string get_Manifest_RequiredElementMissing();
    public static string get_Manifest_RequiredMetadataMissing();
    public static string get_Manifest_RequireLicenseAcceptanceRequiresLicenseUrl();
    public static string get_Manifest_SourceContainsInvalidCharacters();
    public static string get_Manifest_TargetContainsInvalidCharacters();
    public static string get_Manifest_UriCannotBeEmpty();
    public static string get_PackageAuthoring_FileNotFound();
    public static string get_SemVerSpecialVersionTooLong();
    public static string get_UnknownSchemaVersion();
}
public static class NuGet.Packaging.PackageExtraction.PackageExtractionBehavior : object {
    private static string XmlDocFileSaveModeEnvironmentKey;
    private static Nullable`1<XmlDocFileSaveMode> _xmlDocFileSaveMode;
    public static XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public static XmlDocFileSaveMode get_XmlDocFileSaveMode();
    public static void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
}
public class NuGet.Packaging.PackageExtractionContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopySatelliteFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLegacyPackageInstallPath>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocFileSaveMode <XmlDocFileSaveMode>k__BackingField;
    public ILogger Logger { get; private set; }
    public bool CopySatelliteFiles { get; public set; }
    public bool UseLegacyPackageInstallPath { get; public set; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public PackageExtractionContext(ILogger logger);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public bool get_CopySatelliteFiles();
    [CompilerGeneratedAttribute]
public void set_CopySatelliteFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseLegacyPackageInstallPath();
    [CompilerGeneratedAttribute]
public void set_UseLegacyPackageInstallPath(bool value);
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public XmlDocFileSaveMode get_XmlDocFileSaveMode();
    [CompilerGeneratedAttribute]
public void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
}
public static class NuGet.Packaging.PackageExtractor : object {
    public static IEnumerable`1<string> ExtractPackage(Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token);
    public static IEnumerable`1<string> ExtractPackage(PackageReaderBase packageReader, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__2")]
public static Task InstallFromSourceAsync(Func`2<Stream, Task> copyToAsync, VersionFolderPathContext versionFolderPathContext, CancellationToken token);
    private static bool ShouldInclude(string fullName, string hashFileName);
    public static IEnumerable`1<string> CopySatelliteFiles(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    private static IEnumerable`1<string> CopySatelliteFiles(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
}
public class NuGet.Packaging.PackageFileExtractor : object {
    private HashSet`1<string> _intellisenseXmlFiles;
    private XmlDocFileSaveMode _xmlDocFileSaveMode;
    public PackageFileExtractor(IEnumerable`1<string> packageFiles, XmlDocFileSaveMode xmlDocFileSaveMode);
    private static HashSet`1<string> GatherIntellisenseXmlFiles(IEnumerable`1<string> packageFiles);
    private static string GetBinaryForLanguageSpecificXml(string file);
    public string ExtractPackageFile(string source, string target, Stream stream);
}
public class NuGet.Packaging.PackageFolderReader : PackageReaderBase {
    private DirectoryInfo _root;
    public PackageFolderReader(string folderPath);
    public PackageFolderReader(DirectoryInfo folder);
    public PackageFolderReader(string folderPath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageFolderReader(DirectoryInfo folder, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public virtual string GetNuspecFile();
    public virtual Stream GetStream(string path);
    private FileInfo GetFile(string path);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageFolderReader/<GetFiles>d__8")]
public virtual IEnumerable`1<string> GetFiles();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageFolderReader/<GetFiles>d__9")]
public virtual IEnumerable`1<string> GetFiles(string folder);
    private static string GetRelativePath(DirectoryInfo root, FileInfo file);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    protected virtual void Dispose(bool disposing);
}
public static class NuGet.Packaging.PackageHelper : object {
    private static String[] ExcludePaths;
    private static Char[] Slashes;
    private static string ExcludeExtension;
    private static PackageHelper();
    public static bool IsAssembly(string path);
    public static bool IsNuspec(string path);
    public static bool IsManifest(string path);
    public static bool IsRoot(string path);
    public static bool IsPackageFile(string packageFileName, PackageSaveMode packageSaveMode);
    public static bool IsSatellitePackage(IPackageCoreReader packageReader, PackageIdentity& runtimePackageIdentity, String& packageLanguage);
    public static IEnumerable`1<string> GetSatelliteFiles(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, String& runtimePackageDirectory);
    public static IEnumerable`1<ZipFilePair> GetInstalledPackageFiles(PackageArchiveReader packageReader, PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode);
    public static Tuple`2<string, IEnumerable`1<ZipFilePair>> GetInstalledSatelliteFiles(PackageArchiveReader packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode);
}
public static class NuGet.Packaging.PackageIdValidator : object {
    internal static int MaxPackageIdLength;
    private static Regex _idRegex;
    private static PackageIdValidator();
    public static bool IsValidPackageId(string packageId);
    public static void ValidatePackageId(string packageId);
}
public static class NuGet.Packaging.PackagePathHelper : object {
    internal static IEnumerable`1<string> GetFiles(string root, string path, string filter, bool recursive);
    internal static IEnumerable`1<string> GetDirectories(string root, string path);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackagePathHelper/<GetPackageFiles>d__2")]
private static IEnumerable`1<string> GetPackageFiles(string root, string filter);
    private static bool FileNameMatchesPattern(PackageIdentity packageIdentity, string path);
    public static IEnumerable`1<string> GetPackageLookupPaths(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
    public static string GetInstalledPackageFilePath(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
}
public class NuGet.Packaging.PackagePathResolver : object {
    private string _rootDirectory;
    [CompilerGeneratedAttribute]
private bool <UseSideBySidePaths>k__BackingField;
    public bool UseSideBySidePaths { get; }
    protected internal string Root { get; }
    public PackagePathResolver(string rootDirectory, bool useSideBySidePaths);
    [CompilerGeneratedAttribute]
public bool get_UseSideBySidePaths();
    protected internal string get_Root();
    public string GetPackageDirectoryName(PackageIdentity packageIdentity);
    public string GetPackageFileName(PackageIdentity packageIdentity);
    public string GetManifestFileName(PackageIdentity packageIdentity);
    public virtual string GetInstallPath(PackageIdentity packageIdentity);
    public string GetInstalledPath(PackageIdentity packageIdentity);
    public string GetInstalledPackageFilePath(PackageIdentity packageIdentity);
    private string GetId(PackageIdentity identity);
    private string GetVersion(PackageIdentity identity);
    private StringBuilder GetPathBase(PackageIdentity packageIdentity);
}
public abstract class NuGet.Packaging.PackageReaderBase : object {
    private NuspecReader _nuspecReader;
    private IFrameworkNameProvider _frameworkProvider;
    private IFrameworkCompatibilityProvider _compatibilityProvider;
    public NuspecReader NuspecReader { get; }
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider);
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public virtual PackageIdentity GetIdentity();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual Stream GetNuspec();
    public virtual string GetNuspecFile();
    public virtual NuspecReader get_NuspecReader();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public IEnumerable`1<NuGetFramework> GetSupportedFrameworks();
    public sealed virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public bool IsServiceable();
    public sealed virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    private static bool IsAllowedBuildFile(string packageId, string path);
    public sealed virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public sealed virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public sealed virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
    public sealed virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    private static bool IsReferenceAssembly(string path);
    public sealed virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public bool GetDevelopmentDependency();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReaderBase/<GetFileGroups>d__30")]
protected IEnumerable`1<FrameworkSpecificGroup> GetFileGroups(string folder);
    private NuGetFramework GetFrameworkFromPath(string path, bool allowSubFolders);
}
[ExtensionAttribute]
public static class NuGet.Packaging.PackageReaderExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetPackageFiles(IPackageCoreReader packageReader, PackageSaveMode packageSaveMode);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetSatelliteFiles(IPackageContentReader packageReader, string packageLanguage);
}
[DebuggerDisplayAttribute("{PackageIdentity} {TargetFramework}")]
public class NuGet.Packaging.PackageReference : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <AllowedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUserInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireReinstallation>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public VersionRange AllowedVersions { get; }
    public bool HasAllowedVersions { get; }
    public NuGetFramework TargetFramework { get; }
    public bool IsDevelopmentDependency { get; }
    public bool IsUserInstalled { get; }
    public bool RequireReinstallation { get; }
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation, VersionRange allowedVersions);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public VersionRange get_AllowedVersions();
    public bool get_HasAllowedVersions();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public bool get_IsDevelopmentDependency();
    [CompilerGeneratedAttribute]
public bool get_IsUserInstalled();
    [CompilerGeneratedAttribute]
public bool get_RequireReinstallation();
    public virtual string ToString();
}
public class NuGet.Packaging.PackageReferenceSet : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    public IReadOnlyCollection`1<string> References { get; }
    public NuGetFramework TargetFramework { get; }
    public PackageReferenceSet(IEnumerable`1<string> references);
    public PackageReferenceSet(string targetFramework, IEnumerable`1<string> references);
    public PackageReferenceSet(NuGetFramework targetFramework, IEnumerable`1<string> references);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_References();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReferenceSet/<Validate>d__9")]
public IEnumerable`1<string> Validate();
}
[FlagsAttribute]
public enum NuGet.Packaging.PackageSaveMode : Enum {
    public int value__;
    public static PackageSaveMode None;
    public static PackageSaveMode Nuspec;
    public static PackageSaveMode Nupkg;
    public static PackageSaveMode Files;
    public static PackageSaveMode Defaultv2;
    public static PackageSaveMode Defaultv3;
}
public static class NuGet.Packaging.PackagesConfig : object {
    public static string PackagesNodeName;
    public static string PackageNodeName;
    public static string IdAttributeName;
    public static string VersionAttributeName;
    public static string TargetFrameworkAttributeName;
    public static string MinClientAttributeName;
    public static string developmentDependencyAttributeName;
    public static string allowedVersionsAttributeName;
    public static string RequireInstallAttributeName;
    public static string UserInstalledAttributeName;
    private static PackagesConfig();
    public static bool TryGetAttribute(XElement node, string name, String& value);
    public static bool HasAttributeValue(XElement node, string attributeName, string targetValue, XElement& element);
    public static bool BoolAttribute(XElement node, string name, bool defaultValue);
}
public class NuGet.Packaging.PackagesConfigReader : object {
    private XDocument _doc;
    private IFrameworkNameProvider _frameworkMappings;
    public PackagesConfigReader(XDocument xml);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, XDocument xml);
    public PackagesConfigReader(Stream stream);
    public PackagesConfigReader(Stream stream, bool leaveStreamOpen);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, Stream stream, bool leaveStreamOpen);
    public NuGetVersion GetMinClientVersion();
    public IEnumerable`1<PackageReference> GetPackages();
    public IEnumerable`1<PackageReference> GetPackages(bool allowDuplicatePackageIds);
}
public class NuGet.Packaging.PackagesConfigReaderException : PackagingException {
    public PackagesConfigReaderException(string message);
    public PackagesConfigReaderException(string message, Exception innerException);
}
public class NuGet.Packaging.PackagesConfigWriter : object {
    private Stream _stream;
    private string _filePath;
    private bool _disposed;
    private NuGetVersion _minClientVersion;
    private IFrameworkNameProvider _frameworkMappings;
    private XDocument _xDocument;
    public PackagesConfigWriter(string fullPath, bool createNew);
    public PackagesConfigWriter(string fullPath, bool createNew, IFrameworkNameProvider frameworkMappings);
    public PackagesConfigWriter(Stream stream, bool createNew);
    public PackagesConfigWriter(Stream stream, bool createNew, IFrameworkNameProvider frameworkMappings);
    public void WriteMinClientVersion(NuGetVersion version);
    public void AddPackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageReference entry);
    public void UpdatePackageEntry(PackageReference oldEntry, PackageReference newEntry);
    public void UpdateOrAddPackageEntry(XDocument originalConfig, PackageReference newEntry);
    public void RemovePackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageReference entry);
    private XElement CreateXElementForPackageEntry(PackageReference entry);
    private void CreateDefaultXDocument();
    private XElement EnsurePackagesNode();
    private XElement FindMatchingPackageNode(PackageReference entry, XElement packagesNode);
    private XElement ReplacePackageAttributes(XElement existingNode, PackageReference newEntry);
    private void SortPackageNodes(XElement packagesNode);
    private void WriteFile();
    public void WriteFile(string fullPath);
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.PackagesConfigWriterException : PackagingException {
    public PackagesConfigWriterException(string message);
    public PackagesConfigWriterException(string message, Exception innerException);
}
public static class NuGet.Packaging.PackagingConstants : object {
    public static string AnyFramework;
    public static string AgnosticFramework;
    public static string TargetFrameworkPropertyKey;
    public static string ContentFilesDefaultBuildAction;
    public static string ManifestExtension;
    internal static string PackageEmptyFileName;
    private static PackagingConstants();
}
public class NuGet.Packaging.PhysicalPackageFile : object {
    private Func`1<Stream> _streamFactory;
    private string _targetPath;
    private FrameworkName _targetFramework;
    [CompilerGeneratedAttribute]
private MemoryStream <MemoryStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectivePath>k__BackingField;
    private MemoryStream MemoryStream { get; private set; }
    public string SourcePath { get; public set; }
    public string TargetPath { get; public set; }
    public string Path { get; }
    public string EffectivePath { get; private set; }
    public FrameworkName TargetFramework { get; }
    public PhysicalPackageFile(MemoryStream stream);
    internal PhysicalPackageFile(Func`1<Stream> streamFactory);
    [CompilerGeneratedAttribute]
private MemoryStream get_MemoryStream();
    [CompilerGeneratedAttribute]
private void set_MemoryStream(MemoryStream value);
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public void set_SourcePath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EffectivePath();
    [CompilerGeneratedAttribute]
private void set_EffectivePath(string value);
    public sealed virtual FrameworkName get_TargetFramework();
    public Nullable`1<DateTime> GetLastWriteTime();
    public sealed virtual Stream GetStream();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class NuGet.Packaging.StreamExtensions : object {
    [ExtensionAttribute]
public static string CopyToFile(Stream inputStream, string fileFullPath);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.StringExtensions : object {
    [ExtensionAttribute]
public static string SafeTrim(string value);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class NuGet.Packaging.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string Error_InvalidTargetFramework { get; }
    public static string ErrorDuplicatePackages { get; }
    public static string ErrorInvalidAllowedVersions { get; }
    public static string ErrorInvalidMinClientVersion { get; }
    public static string ErrorInvalidPackageVersion { get; }
    public static string ErrorNullOrEmptyPackageId { get; }
    public static string ErrorUnableToDeleteFile { get; }
    public static string FailedFileTime { get; }
    public static string FailToLoadPackagesConfig { get; }
    public static string FailToWritePackagesConfig { get; }
    public static string FallbackFolderNotFound { get; }
    public static string InvalidNuspecElement { get; }
    public static string InvalidNuspecEntry { get; }
    public static string InvalidPackageFrameworkFolderName { get; }
    public static string Log_InstallingPackage { get; }
    public static string MinClientVersionAlreadyExist { get; }
    public static string MissingNuspec { get; }
    public static string MultipleNuspecFiles { get; }
    public static string MustContainAbsolutePath { get; }
    public static string PackageEntryAlreadyExist { get; }
    public static string PackageEntryNotExist { get; }
    public static string PackageMinVersionNotSatisfied { get; }
    public static string PackagesNodeNotExist { get; }
    public static string PackageStreamShouldBeSeekable { get; }
    public static string StringCannotBeNullOrEmpty { get; }
    public static string UnableToAddEntry { get; }
    public static string UnableToParseClientVersion { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_Error_InvalidTargetFramework();
    public static string get_ErrorDuplicatePackages();
    public static string get_ErrorInvalidAllowedVersions();
    public static string get_ErrorInvalidMinClientVersion();
    public static string get_ErrorInvalidPackageVersion();
    public static string get_ErrorNullOrEmptyPackageId();
    public static string get_ErrorUnableToDeleteFile();
    public static string get_FailedFileTime();
    public static string get_FailToLoadPackagesConfig();
    public static string get_FailToWritePackagesConfig();
    public static string get_FallbackFolderNotFound();
    public static string get_InvalidNuspecElement();
    public static string get_InvalidNuspecEntry();
    public static string get_InvalidPackageFrameworkFolderName();
    public static string get_Log_InstallingPackage();
    public static string get_MinClientVersionAlreadyExist();
    public static string get_MissingNuspec();
    public static string get_MultipleNuspecFiles();
    public static string get_MustContainAbsolutePath();
    public static string get_PackageEntryAlreadyExist();
    public static string get_PackageEntryNotExist();
    public static string get_PackageMinVersionNotSatisfied();
    public static string get_PackagesNodeNotExist();
    public static string get_PackageStreamShouldBeSeekable();
    public static string get_StringCannotBeNullOrEmpty();
    public static string get_UnableToAddEntry();
    public static string get_UnableToParseClientVersion();
}
public class NuGet.Packaging.VersionFolderPathContext : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocFileSaveMode <XmlDocFileSaveMode>k__BackingField;
    public PackageIdentity Package { get; }
    public string PackagesDirectory { get; }
    public ILogger Logger { get; }
    public PackageSaveMode PackageSaveMode { get; }
    public XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public VersionFolderPathContext(PackageIdentity package, string packagesDirectory, ILogger logger, PackageSaveMode packageSaveMode, XmlDocFileSaveMode xmlDocFileSaveMode);
    [CompilerGeneratedAttribute]
public PackageIdentity get_Package();
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public XmlDocFileSaveMode get_XmlDocFileSaveMode();
    [CompilerGeneratedAttribute]
public void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
}
public class NuGet.Packaging.VersionFolderPathResolver : object {
    private string _path;
    public VersionFolderPathResolver(string path);
    public string GetInstallPath(string packageId, NuGetVersion version);
    public string GetVersionListPath(string packageId);
    public string GetPackageFilePath(string packageId, NuGetVersion version);
    public string GetManifestFilePath(string packageId, NuGetVersion version);
    public string GetHashPath(string packageId, NuGetVersion version);
    public string GetVersionListDirectory(string packageId);
    public string GetPackageDirectory(string packageId, NuGetVersion version);
    public string GetPackageFileName(string packageId, NuGetVersion version);
    public string GetManifestFileName(string packageId, NuGetVersion version);
    private string Normalize(NuGetVersion version);
    private string Normalize(string packageId);
}
[ExtensionAttribute]
public static class NuGet.Packaging.XElementExtensions : object {
    [ExtensionAttribute]
public static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(XContainer container, string localName);
    [ExtensionAttribute]
public static XElement Except(XElement source, XElement target);
    private static XElement FindElement(XElement source, XElement targetChild);
    private static int Compare(XElement target, XElement left, XElement right);
    private static int CountMatches(XElement left, XElement right, Func`3<XAttribute, XAttribute, bool> matcher);
    private static bool HasComment(XElement element, XComment comment);
    private static bool HasConflict(XElement source, XElement target);
    private static bool AttributeEquals(XAttribute source, XAttribute target);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Xml.PackageMetadataXmlExtensions : object {
    private static string References;
    private static string Reference;
    private static string Group;
    private static string File;
    private static string TargetFramework;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Dependencies;
    private static string Files;
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns);
    private static XElement GetXElementFromGroupableItemSets(XNamespace ns, IEnumerable`1<TSet> objectSets, Func`2<TSet, bool> isGroupable, Func`2<TSet, string> getGroupIdentifer, Func`2<TSet, IEnumerable`1<TItem>> getItems, Func`3<XNamespace, TItem, XElement> getXElementFromItem, string parentName, string identiferAttributeName);
    private static XElement GetXElementFromPackageReference(XNamespace ns, string reference);
    private static XElement GetXElementFromPackageDependency(XNamespace ns, PackageDependency dependency);
    private static XElement GetXElementFromFrameworkAssemblies(XNamespace ns, IEnumerable`1<FrameworkAssemblyReference> references);
    private static XElement GetXElementFromManifestContentFiles(XNamespace ns, IEnumerable`1<ManifestContentFiles> contentFiles);
    private static XElement GetXElementFromManifestContentFile(XNamespace ns, ManifestContentFiles file);
    private static XElement GetXElementFromManifestPackageTypes(XNamespace ns, IEnumerable`1<PackageType> packageTypes);
    private static XElement GetXElementFromManifestPackageType(XNamespace ns, PackageType packageType);
    private static XAttribute GetXAttributeFromNameAndValue(string name, object value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value, Func`2<T, object> process);
}
public enum NuGet.Packaging.XmlDocFileSaveMode : Enum {
    public int value__;
    public static XmlDocFileSaveMode None;
    public static XmlDocFileSaveMode Skip;
    public static XmlDocFileSaveMode Compress;
}
public static class NuGet.Packaging.XmlUtility : object {
    public static XDocument LoadSafe(Stream input);
    public static XDocument LoadSafe(Stream input, bool ignoreWhiteSpace);
    private static XmlReaderSettings CreateSafeSettings(bool ignoreWhiteSpace);
}
[ExtensionAttribute]
public static class NuGet.Packaging.ZipArchiveExtensions : object {
    [ExtensionAttribute]
public static ZipArchiveEntry LookupEntry(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetFiles(ZipArchive zipArchive);
    private static string UnescapePath(string path);
    [ExtensionAttribute]
public static Stream OpenFile(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static string SaveAsFile(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
    [ExtensionAttribute]
public static void UpdateFileTimeFromEntry(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
}
public class NuGet.Packaging.ZipFilePair : object {
    private ZipArchiveEntry _packageEntry;
    private string _fileFullPath;
    public string FileFullPath { get; }
    public ZipArchiveEntry PackageEntry { get; }
    public ZipFilePair(string fileFullPath, ZipArchiveEntry entry);
    public string get_FileFullPath();
    public ZipArchiveEntry get_PackageEntry();
    public bool IsInstalled();
}
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
}
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private bool _initialized;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    internal void AddInt32(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(TValue o, IEqualityComparer`1<TValue> comparer);
    internal void AddObject(object o);
    internal static int GetHashCode(Object[] objects);
    private void CheckInitialized();
}
