public class Autofac.Builder.ConcreteReflectionActivatorData : ReflectionActivatorData {
    public IInstanceActivator Activator { get; }
    public ConcreteReflectionActivatorData(Type implementer);
    public sealed virtual IInstanceActivator get_Activator();
}
[FlagsAttribute]
public enum Autofac.Builder.ContainerBuildOptions : Enum {
    public int value__;
    public static ContainerBuildOptions None;
    public static ContainerBuildOptions ExcludeDefaultModules;
    public static ContainerBuildOptions IgnoreStartableComponents;
}
public class Autofac.Builder.DeferredCallback : object {
    private Action`1<IComponentRegistry> _callback;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Action`1<IComponentRegistry> Callback { get; public set; }
    public Guid Id { get; }
    public DeferredCallback(Action`1<IComponentRegistry> callback);
    public Action`1<IComponentRegistry> get_Callback();
    public void set_Callback(Action`1<IComponentRegistry> value);
    [CompilerGeneratedAttribute]
public Guid get_Id();
}
public class Autofac.Builder.DynamicRegistrationStyle : object {
}
public interface Autofac.Builder.IConcreteActivatorData {
    public IInstanceActivator Activator { get; }
    public abstract virtual IInstanceActivator get_Activator();
}
[EditorBrowsableAttribute("1")]
public interface Autofac.Builder.IHideObjectMembers {
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object other);
}
public interface Autofac.Builder.IRegistrationBuilder`3 {
    [EditorBrowsableAttribute("1")]
public TActivatorData ActivatorData { get; }
    [EditorBrowsableAttribute("1")]
public TRegistrationStyle RegistrationStyle { get; }
    [EditorBrowsableAttribute("1")]
public RegistrationData RegistrationData { get; }
    public abstract virtual TActivatorData get_ActivatorData();
    public abstract virtual TRegistrationStyle get_RegistrationStyle();
    public abstract virtual RegistrationData get_RegistrationData();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> ExternallyOwned();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OwnedByLifetimeScope();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerDependency();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> SingleInstance();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerLifetimeScope();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerMatchingLifetimeScope(Object[] lifetimeScopeTag);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Type[] services);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Service[] services);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey, Type serviceType);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnPreparing(Action`1<PreparingEventArgs> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivating(Action`1<IActivatingEventArgs`1<TLimit>> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivated(Action`1<IActivatedEventArgs`1<TLimit>> handler);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IPropertySelector propertySelector, bool allowCircularDependencies);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(string key, object value);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public abstract virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(Action`1<MetadataConfiguration`1<TMetadata>> configurationAction);
}
public class Autofac.Builder.MetadataConfiguration`1 : object {
    private IDictionary`2<string, object> _properties;
    internal IEnumerable`1<KeyValuePair`2<string, object>> Properties { get; }
    internal IEnumerable`1<KeyValuePair`2<string, object>> get_Properties();
    public MetadataConfiguration`1<TMetadata> For(Expression`1<Func`2<TMetadata, TProperty>> propertyAccessor, TProperty value);
}
internal static class Autofac.Builder.MetadataKeys : object {
    internal static string RegistrationOrderMetadataKey;
    internal static string AutoActivated;
}
public class Autofac.Builder.ReflectionActivatorData : object {
    private Type _implementer;
    private IConstructorFinder _constructorFinder;
    private IConstructorSelector _constructorSelector;
    private static IConstructorFinder DefaultConstructorFinder;
    private static IConstructorSelector DefaultConstructorSelector;
    [CompilerGeneratedAttribute]
private IList`1<Parameter> <ConfiguredParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Parameter> <ConfiguredProperties>k__BackingField;
    public Type ImplementationType { get; public set; }
    public IConstructorFinder ConstructorFinder { get; public set; }
    public IConstructorSelector ConstructorSelector { get; public set; }
    public IList`1<Parameter> ConfiguredParameters { get; }
    public IList`1<Parameter> ConfiguredProperties { get; }
    public ReflectionActivatorData(Type implementer);
    private static ReflectionActivatorData();
    public Type get_ImplementationType();
    public void set_ImplementationType(Type value);
    public IConstructorFinder get_ConstructorFinder();
    public void set_ConstructorFinder(IConstructorFinder value);
    public IConstructorSelector get_ConstructorSelector();
    public void set_ConstructorSelector(IConstructorSelector value);
    [CompilerGeneratedAttribute]
public IList`1<Parameter> get_ConfiguredParameters();
    [CompilerGeneratedAttribute]
public IList`1<Parameter> get_ConfiguredProperties();
}
[ExtensionAttribute]
public static class Autofac.Builder.RegistrationBuilder : object {
    public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> ForDelegate(Func`3<IComponentContext, IEnumerable`1<Parameter>, T> delegate);
    public static IRegistrationBuilder`3<object, SimpleActivatorData, SingleRegistrationStyle> ForDelegate(Type limitType, Func`3<IComponentContext, IEnumerable`1<Parameter>, object> delegate);
    public static IRegistrationBuilder`3<TImplementer, ConcreteReflectionActivatorData, SingleRegistrationStyle> ForType();
    public static IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle> ForType(Type implementationType);
    [ExtensionAttribute]
public static IComponentRegistration CreateRegistration(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> builder);
    public static IComponentRegistration CreateRegistration(Guid id, RegistrationData data, IInstanceActivator activator, IEnumerable`1<Service> services);
    public static IComponentRegistration CreateRegistration(Guid id, RegistrationData data, IInstanceActivator activator, IEnumerable`1<Service> services, IComponentRegistration target);
    public static void RegisterSingleComponent(IComponentRegistry cr, IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> builder);
}
internal class Autofac.Builder.RegistrationBuilder`3 : object {
    [CompilerGeneratedAttribute]
private TActivatorData <ActivatorData>k__BackingField;
    [CompilerGeneratedAttribute]
private TRegistrationStyle <RegistrationStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistrationData <RegistrationData>k__BackingField;
    [EditorBrowsableAttribute("1")]
public TActivatorData ActivatorData { get; }
    [EditorBrowsableAttribute("1")]
public TRegistrationStyle RegistrationStyle { get; }
    [EditorBrowsableAttribute("1")]
public RegistrationData RegistrationData { get; }
    public RegistrationBuilder`3(Service defaultService, TActivatorData activatorData, TRegistrationStyle style);
    [CompilerGeneratedAttribute]
public sealed virtual TActivatorData get_ActivatorData();
    [CompilerGeneratedAttribute]
public sealed virtual TRegistrationStyle get_RegistrationStyle();
    [CompilerGeneratedAttribute]
public sealed virtual RegistrationData get_RegistrationData();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> ExternallyOwned();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OwnedByLifetimeScope();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerDependency();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> SingleInstance();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerLifetimeScope();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerMatchingLifetimeScope(Object[] lifetimeScopeTag);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> InstancePerOwned(object serviceKey, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As();
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Type[] services);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> As(Service[] services);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Named(string serviceName);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey, Type serviceType);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> Keyed(object serviceKey);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnPreparing(Action`1<PreparingEventArgs> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivating(Action`1<IActivatingEventArgs`1<TLimit>> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnActivated(Action`1<IActivatedEventArgs`1<TLimit>> handler);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IPropertySelector propertySelector, bool allowCircularDependencies);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(string key, object value);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(IEnumerable`1<KeyValuePair`2<string, object>> properties);
    public sealed virtual IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> WithMetadata(Action`1<MetadataConfiguration`1<TMetadata>> configurationAction);
    private sealed virtual override Type Autofac.Builder.IHideObjectMembers.GetType();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Builder.RegistrationBuilderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ComponentDoesNotSupportService { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ComponentDoesNotSupportService();
}
public class Autofac.Builder.RegistrationData : object {
    private bool _defaultServiceOverridden;
    private Service _defaultService;
    private ICollection`1<Service> _services;
    private IComponentLifetime _lifetime;
    [CompilerGeneratedAttribute]
private InstanceOwnership <Ownership>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceSharing <Sharing>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DeferredCallback <DeferredCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<PreparingEventArgs>> <PreparingHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> <ActivatingHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> <ActivatedHandlers>k__BackingField;
    public IEnumerable`1<Service> Services { get; }
    public InstanceOwnership Ownership { get; public set; }
    public IComponentLifetime Lifetime { get; public set; }
    public InstanceSharing Sharing { get; public set; }
    public IDictionary`2<string, object> Metadata { get; }
    public DeferredCallback DeferredCallback { get; public set; }
    public ICollection`1<EventHandler`1<PreparingEventArgs>> PreparingHandlers { get; }
    public ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> ActivatingHandlers { get; }
    public ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> ActivatedHandlers { get; }
    public RegistrationData(Service defaultService);
    public IEnumerable`1<Service> get_Services();
    public void AddServices(IEnumerable`1<Service> services);
    public void AddService(Service service);
    [CompilerGeneratedAttribute]
public InstanceOwnership get_Ownership();
    [CompilerGeneratedAttribute]
public void set_Ownership(InstanceOwnership value);
    public IComponentLifetime get_Lifetime();
    public void set_Lifetime(IComponentLifetime value);
    [CompilerGeneratedAttribute]
public InstanceSharing get_Sharing();
    [CompilerGeneratedAttribute]
public void set_Sharing(InstanceSharing value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public DeferredCallback get_DeferredCallback();
    [CompilerGeneratedAttribute]
public void set_DeferredCallback(DeferredCallback value);
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<PreparingEventArgs>> get_PreparingHandlers();
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ActivatingEventArgs`1<object>>> get_ActivatingHandlers();
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ActivatedEventArgs`1<object>>> get_ActivatedHandlers();
    public void CopyFrom(RegistrationData that, bool includeDefaultService);
    private static void AddAll(ICollection`1<T> to, IEnumerable`1<T> from);
    public void ClearServices();
}
[ExtensionAttribute]
public static class Autofac.Builder.RegistrationExtensions : object {
    [ExtensionAttribute]
public static IRegistrationBuilder`3<Delegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<Delegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType, Service service);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Service service);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> NamedParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> PositionalParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> TypedParameterMapping(IRegistrationBuilder`3<TDelegate, TGeneratedFactoryActivatorData, TSingleRegistrationStyle> registration);
}
[ExtensionAttribute]
internal static class Autofac.Builder.RegistrationOrderExtensions : object {
    [ExtensionAttribute]
internal static long GetRegistrationOrder(IComponentRegistration registration);
    [ExtensionAttribute]
internal static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> InheritRegistrationOrderFrom(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, IComponentRegistration source);
}
public class Autofac.Builder.SimpleActivatorData : object {
    [CompilerGeneratedAttribute]
private IInstanceActivator <Activator>k__BackingField;
    public IInstanceActivator Activator { get; }
    public SimpleActivatorData(IInstanceActivator activator);
    [CompilerGeneratedAttribute]
public sealed virtual IInstanceActivator get_Activator();
}
public class Autofac.Builder.SingleRegistrationStyle : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> <RegisteredHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Target>k__BackingField;
    public Guid Id { get; public set; }
    public ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> RegisteredHandlers { get; }
    public bool PreserveDefaults { get; public set; }
    public IComponentRegistration Target { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public ICollection`1<EventHandler`1<ComponentRegisteredEventArgs>> get_RegisteredHandlers();
    [CompilerGeneratedAttribute]
public bool get_PreserveDefaults();
    [CompilerGeneratedAttribute]
public void set_PreserveDefaults(bool value);
    [CompilerGeneratedAttribute]
public IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(IComponentRegistration value);
}
public class Autofac.ContainerBuilder : object {
    private IList`1<DeferredCallback> _configurationCallbacks;
    private bool _wasBuilt;
    private static string BuildCallbackPropertyKey;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public IDictionary`2<string, object> Properties { get; }
    internal ContainerBuilder(IDictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    public virtual DeferredCallback RegisterCallback(Action`1<IComponentRegistry> configurationCallback);
    public ContainerBuilder RegisterBuildCallback(Action`1<IContainer> buildCallback);
    public IContainer Build(ContainerBuildOptions options);
    private static void StartStartableComponents(IComponentContext componentContext);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IContainer container);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IContainer container, ContainerBuildOptions options);
    [ObsoleteAttribute("Containers should generally be considered immutable. Register all of your dependencies before building/resolving. If you need to change the contents of a container, you technically should rebuild the container. This method may be removed in a future major release.")]
public void Update(IComponentRegistry componentRegistry);
    internal void UpdateRegistry(IComponentRegistry componentRegistry);
    private void Build(IComponentRegistry componentRegistry, bool excludeDefaultModules);
    private void RegisterDefaultAdapters(IComponentRegistry componentRegistry);
    private List`1<Action`1<IContainer>> GetBuildCallbacks();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.ContainerBuilderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BuildCanOnlyBeCalledOnce { get; }
    internal static string ErrorAutoActivating { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BuildCanOnlyBeCalledOnce();
    internal static string get_ErrorAutoActivating();
}
public class Autofac.Core.ActivatedEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Instance>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public T Instance { get; }
    public ActivatedEventArgs`1(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters, T instance);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_Component();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Instance();
}
public class Autofac.Core.ActivatingEventArgs`1 : EventArgs {
    private T _instance;
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public T Instance { get; public set; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public ActivatingEventArgs`1(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters, T instance);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_Component();
    public sealed virtual T get_Instance();
    public void set_Instance(T value);
    public sealed virtual void ReplaceInstance(object instance);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
}
public class Autofac.Core.Activators.Delegate.DelegateActivator : InstanceActivator {
    private Func`3<IComponentContext, IEnumerable`1<Parameter>, object> _activationFunction;
    public DelegateActivator(Type limitType, Func`3<IComponentContext, IEnumerable`1<Parameter>, object> activationFunction);
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Delegate.DelegateActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NullFromActivationDelegateFor { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NullFromActivationDelegateFor();
}
public abstract class Autofac.Core.Activators.InstanceActivator : Disposable {
    [CompilerGeneratedAttribute]
private Type <LimitType>k__BackingField;
    public Type LimitType { get; }
    protected InstanceActivator(Type limitType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_LimitType();
    public virtual string ToString();
}
public class Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivator : InstanceActivator {
    private object _instance;
    private bool _activated;
    [CompilerGeneratedAttribute]
private bool <DisposeInstance>k__BackingField;
    public bool DisposeInstance { get; public set; }
    public ProvidedInstanceActivator(object instance);
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public bool get_DisposeInstance();
    [CompilerGeneratedAttribute]
public void set_DisposeInstance(bool value);
    protected virtual void Dispose(bool disposing);
    private static Type GetType(object instance);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.ProvidedInstance.ProvidedInstanceActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string InstanceAlreadyActivated { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_InstanceAlreadyActivated();
}
public class Autofac.Core.Activators.Reflection.AutowiringParameter : Parameter {
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
internal class Autofac.Core.Activators.Reflection.AutowiringPropertyInjector : object {
    public static string InstanceTypeNamedParameter;
    public static void InjectProperties(IComponentContext context, object instance, IPropertySelector propertySelector, IEnumerable`1<Parameter> parameters);
}
public class Autofac.Core.Activators.Reflection.ConstructorParameterBinding : object {
    private ConstructorInfo _ci;
    private Func`1[] _valueRetrievers;
    private static ConcurrentDictionary`2<ConstructorInfo, Func`2<Object[], object>> ConstructorInvokers;
    private ParameterInfo _firstNonBindableParameter;
    [CompilerGeneratedAttribute]
private bool <CanInstantiate>k__BackingField;
    public ConstructorInfo TargetConstructor { get; }
    public bool CanInstantiate { get; }
    public string Description { get; }
    public ConstructorParameterBinding(ConstructorInfo ci, IEnumerable`1<Parameter> availableParameters, IComponentContext context);
    private static ConstructorParameterBinding();
    public ConstructorInfo get_TargetConstructor();
    [CompilerGeneratedAttribute]
public bool get_CanInstantiate();
    public object Instantiate();
    public string get_Description();
    public virtual string ToString();
    private static Func`2<Object[], object> GetConstructorInvoker(ConstructorInfo constructorInfo);
    public static MethodCallExpression ConvertPrimitiveType(Expression valueExpression, Type conversionType);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.ConstructorParameterBindingResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string BoundConstructor { get; }
    public static string CannotInstantitate { get; }
    public static string ExceptionDuringInstantiation { get; }
    public static string NonBindableConstructor { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_BoundConstructor();
    public static string get_CannotInstantitate();
    public static string get_ExceptionDuringInstantiation();
    public static string get_NonBindableConstructor();
}
public class Autofac.Core.Activators.Reflection.DefaultConstructorFinder : object {
    private Func`2<Type, ConstructorInfo[]> _finder;
    private static ConcurrentDictionary`2<Type, ConstructorInfo[]> DefaultPublicConstructorsCache;
    public DefaultConstructorFinder(Func`2<Type, ConstructorInfo[]> finder);
    private static DefaultConstructorFinder();
    public sealed virtual ConstructorInfo[] FindConstructors(Type targetType);
    private static ConstructorInfo[] GetDefaultPublicConstructors(Type type);
}
public class Autofac.Core.Activators.Reflection.DefaultValueParameter : Parameter {
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
public interface Autofac.Core.Activators.Reflection.IConstructorFinder {
    public abstract virtual ConstructorInfo[] FindConstructors(Type targetType);
}
public interface Autofac.Core.Activators.Reflection.IConstructorSelector {
    public abstract virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings);
}
public class Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelector : object {
    private Type[] _signature;
    public MatchingSignatureConstructorSelector(Type[] signature);
    public sealed virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings);
    [CompilerGeneratedAttribute]
private bool <SelectConstructorBinding>b__2_0(ConstructorParameterBinding b);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.MatchingSignatureConstructorSelectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AtLeastOneBindingRequired { get; }
    internal static string RequiredConstructorNotAvailable { get; }
    internal static string TooManyConstructorsMatch { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AtLeastOneBindingRequired();
    internal static string get_RequiredConstructorNotAvailable();
    internal static string get_TooManyConstructorsMatch();
}
public class Autofac.Core.Activators.Reflection.MostParametersConstructorSelector : object {
    public sealed virtual ConstructorParameterBinding SelectConstructorBinding(ConstructorParameterBinding[] constructorBindings);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.MostParametersConstructorSelectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string UnableToChooseFromMultipleConstructors { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_UnableToChooseFromMultipleConstructors();
}
public class Autofac.Core.Activators.Reflection.ReflectionActivator : InstanceActivator {
    private Type _implementationType;
    private Parameter[] _configuredProperties;
    private Parameter[] _defaultParameters;
    private ConstructorInfo[] _availableConstructors;
    [CompilerGeneratedAttribute]
private IConstructorFinder <ConstructorFinder>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstructorSelector <ConstructorSelector>k__BackingField;
    public IConstructorFinder ConstructorFinder { get; }
    public IConstructorSelector ConstructorSelector { get; }
    public ReflectionActivator(Type implementationType, IConstructorFinder constructorFinder, IConstructorSelector constructorSelector, IEnumerable`1<Parameter> configuredParameters, IEnumerable`1<Parameter> configuredProperties);
    [CompilerGeneratedAttribute]
public IConstructorFinder get_ConstructorFinder();
    [CompilerGeneratedAttribute]
public IConstructorSelector get_ConstructorSelector();
    public sealed virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    private ConstructorParameterBinding[] GetValidConstructorBindings(IComponentContext context, IEnumerable`1<Parameter> parameters);
    private string GetBindingFailureMessage(IEnumerable`1<ConstructorParameterBinding> constructorBindings);
    private void InjectProperties(object instance, IComponentContext context);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Activators.Reflection.ReflectionActivatorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NoConstructorsAvailable { get; }
    internal static string NoConstructorsBindable { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NoConstructorsAvailable();
    internal static string get_NoConstructorsBindable();
}
internal class Autofac.Core.AutoActivateService : Service {
    public string Description { get; }
    public virtual string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Autofac.Core.ComponentRegisteredEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <ComponentRegistration>k__BackingField;
    public IComponentRegistry ComponentRegistry { get; }
    public IComponentRegistration ComponentRegistration { get; }
    public ComponentRegisteredEventArgs(IComponentRegistry registry, IComponentRegistration componentRegistration);
    [CompilerGeneratedAttribute]
public IComponentRegistry get_ComponentRegistry();
    [CompilerGeneratedAttribute]
public IComponentRegistration get_ComponentRegistration();
}
[ExtensionAttribute]
public static class Autofac.Core.ComponentRegistrationExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<object> MatchingLifetimeScopeTags(IComponentRegistration registration);
}
public abstract class Autofac.Core.ConstantParameter : Parameter {
    private Predicate`1<ParameterInfo> _predicate;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    protected ConstantParameter(object value, Predicate`1<ParameterInfo> predicate);
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
    [CompilerGeneratedAttribute]
private object <CanSupplyValue>b__5_0();
}
[DebuggerDisplayAttribute("Tag = {Tag}, IsDisposed = {IsDisposed}")]
public class Autofac.Core.Container : Disposable {
    private ILifetimeScope _rootLifetimeScope;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public IComponentRegistry ComponentRegistry { get; }
    internal Container(IDictionary`2<string, object> properties);
    public sealed virtual ILifetimeScope BeginLifetimeScope();
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag);
    public sealed virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    public sealed virtual IDisposer get_Disposer();
    public sealed virtual object get_Tag();
    public sealed virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    public sealed virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    public sealed virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    public sealed virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    public sealed virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    public sealed virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistry get_ComponentRegistry();
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    protected virtual void Dispose(bool disposing);
    public sealed virtual object GetService(Type serviceType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.ContainerResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SelfRegistrationCannotBeActivated { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SelfRegistrationCannotBeActivated();
}
public class Autofac.Core.DefaultPropertySelector : object {
    [CompilerGeneratedAttribute]
private bool <PreserveSetValues>k__BackingField;
    [CompilerGeneratedAttribute]
private static IPropertySelector <OverwriteSetValueInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private static IPropertySelector <PreserveSetValueInstance>k__BackingField;
    public bool PreserveSetValues { get; protected set; }
    internal static IPropertySelector OverwriteSetValueInstance { get; }
    internal static IPropertySelector PreserveSetValueInstance { get; }
    public DefaultPropertySelector(bool preserveSetValues);
    private static DefaultPropertySelector();
    [CompilerGeneratedAttribute]
public bool get_PreserveSetValues();
    [CompilerGeneratedAttribute]
protected void set_PreserveSetValues(bool value);
    [CompilerGeneratedAttribute]
internal static IPropertySelector get_OverwriteSetValueInstance();
    [CompilerGeneratedAttribute]
internal static IPropertySelector get_PreserveSetValueInstance();
    public virtual bool InjectProperty(PropertyInfo propertyInfo, object instance);
}
public class Autofac.Core.DelegatePropertySelector : object {
    private Func`3<PropertyInfo, object, bool> _finder;
    public DelegatePropertySelector(Func`3<PropertyInfo, object, bool> finder);
    public sealed virtual bool InjectProperty(PropertyInfo property, object instance);
}
public class Autofac.Core.DependencyResolutionException : Exception {
    public string Message { get; }
    public DependencyResolutionException(string message);
    public DependencyResolutionException(string message, Exception innerException);
    public virtual string get_Message();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.DependencyResolutionExceptionResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MessageNestingFormat { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MessageNestingFormat();
}
[ObsoleteAttribute("Use the more general Autofac.IStartable interface instead. The IContainer parameter can be emulated when implementing IStartable by taking a dependency on IComponentContext or ILifetimeScope.", "True")]
public interface Autofac.Core.Diagnostics.IContainerAwareComponent {
    public abstract virtual void SetContainer(IContainer container);
}
internal class Autofac.Core.Disposer : Disposable {
    private Stack`1<IDisposable> _items;
    private object _synchRoot;
    protected virtual void Dispose(bool disposing);
    public sealed virtual void AddInstanceForDisposal(IDisposable instance);
}
public interface Autofac.Core.IActivatedEventArgs`1 {
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public T Instance { get; }
    public abstract virtual IComponentContext get_Context();
    public abstract virtual IComponentRegistration get_Component();
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
    public abstract virtual T get_Instance();
}
public interface Autofac.Core.IActivatingEventArgs`1 {
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public T Instance { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public abstract virtual IComponentContext get_Context();
    public abstract virtual IComponentRegistration get_Component();
    public abstract virtual T get_Instance();
    public abstract virtual void ReplaceInstance(object instance);
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
}
public interface Autofac.Core.IComponentLifetime {
    public abstract virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
public interface Autofac.Core.IComponentRegistration {
    public Guid Id { get; }
    public IInstanceActivator Activator { get; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public IComponentRegistration Target { get; }
    public abstract virtual Guid get_Id();
    public abstract virtual IInstanceActivator get_Activator();
    public abstract virtual IComponentLifetime get_Lifetime();
    public abstract virtual InstanceSharing get_Sharing();
    public abstract virtual InstanceOwnership get_Ownership();
    public abstract virtual IEnumerable`1<Service> get_Services();
    public abstract virtual IDictionary`2<string, object> get_Metadata();
    public abstract virtual IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public abstract virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public abstract virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public abstract virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
}
public interface Autofac.Core.IComponentRegistry {
    public IDictionary`2<string, object> Properties { get; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    public abstract virtual IDictionary`2<string, object> get_Properties();
    public abstract virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public abstract virtual bool IsRegistered(Service service);
    public abstract virtual void Register(IComponentRegistration registration);
    public abstract virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    public abstract virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public abstract virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public abstract virtual void AddRegistrationSource(IRegistrationSource source);
    public abstract virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public abstract virtual bool get_HasLocalComponents();
    [CompilerGeneratedAttribute]
public abstract virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
}
public interface Autofac.Core.IDisposer {
    public abstract virtual void AddInstanceForDisposal(IDisposable instance);
}
public interface Autofac.Core.IInstanceActivator {
    public Type LimitType { get; }
    public abstract virtual object ActivateInstance(IComponentContext context, IEnumerable`1<Parameter> parameters);
    public abstract virtual Type get_LimitType();
}
public interface Autofac.Core.IModule {
    public abstract virtual void Configure(IComponentRegistry componentRegistry);
}
public enum Autofac.Core.InstanceOwnership : Enum {
    public int value__;
    public static InstanceOwnership ExternallyOwned;
    public static InstanceOwnership OwnedByLifetimeScope;
}
public enum Autofac.Core.InstanceSharing : Enum {
    public int value__;
    public static InstanceSharing None;
    public static InstanceSharing Shared;
}
public interface Autofac.Core.IPropertySelector {
    public abstract virtual bool InjectProperty(PropertyInfo propertyInfo, object instance);
}
public interface Autofac.Core.IRegistrationSource {
    public bool IsAdapterForIndividualComponents { get; }
    public abstract virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public abstract virtual bool get_IsAdapterForIndividualComponents();
}
public interface Autofac.Core.IServiceWithType {
    public Type ServiceType { get; }
    public abstract virtual Type get_ServiceType();
    public abstract virtual Service ChangeType(Type newType);
}
public interface Autofac.Core.ISharingLifetimeScope {
    public ISharingLifetimeScope RootLifetimeScope { get; }
    public ISharingLifetimeScope ParentLifetimeScope { get; }
    public abstract virtual ISharingLifetimeScope get_RootLifetimeScope();
    public abstract virtual ISharingLifetimeScope get_ParentLifetimeScope();
    public abstract virtual object GetOrCreateAndShare(Guid id, Func`1<object> creator);
}
public class Autofac.Core.KeyedService : Service {
    [CompilerGeneratedAttribute]
private object <ServiceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public object ServiceKey { get; }
    public Type ServiceType { get; }
    public string Description { get; }
    public KeyedService(object serviceKey, Type serviceType);
    [CompilerGeneratedAttribute]
public object get_ServiceKey();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    public virtual string get_Description();
    public sealed virtual bool Equals(KeyedService other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Service ChangeType(Type newType);
}
public class Autofac.Core.Lifetime.CurrentScopeLifetime : object {
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
[DebuggerDisplayAttribute("Tag = {Tag}, IsDisposed = {IsDisposed}")]
public class Autofac.Core.Lifetime.LifetimeScope : Disposable {
    private object _synchRoot;
    private IDictionary`2<Guid, object> _sharedInstances;
    private ISharingLifetimeScope _parent;
    [CompilerGeneratedAttribute]
private static Guid <SelfRegistrationId>k__BackingField;
    private static Action`1<ContainerBuilder> NoConfiguration;
    public static object RootTag;
    [CompilerGeneratedAttribute]
private ISharingLifetimeScope <RootLifetimeScope>k__BackingField;
    [CompilerGeneratedAttribute]
private IDisposer <Disposer>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<LifetimeScopeBeginningEventArgs> ChildLifetimeScopeBeginning;
    [CompilerGeneratedAttribute]
private EventHandler`1<LifetimeScopeEndingEventArgs> CurrentScopeEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<ResolveOperationBeginningEventArgs> ResolveOperationBeginning;
    internal static Guid SelfRegistrationId { get; }
    public ISharingLifetimeScope ParentLifetimeScope { get; }
    public ISharingLifetimeScope RootLifetimeScope { get; }
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public IComponentRegistry ComponentRegistry { get; }
    protected LifetimeScope(IComponentRegistry componentRegistry, LifetimeScope parent, object tag);
    public LifetimeScope(IComponentRegistry componentRegistry, object tag);
    public LifetimeScope(IComponentRegistry componentRegistry);
    private static LifetimeScope();
    [CompilerGeneratedAttribute]
internal static Guid get_SelfRegistrationId();
    private static object MakeAnonymousTag();
    public sealed virtual ILifetimeScope BeginLifetimeScope();
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag);
    private void RaiseBeginning(ILifetimeScope scope);
    public sealed virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public sealed virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    private ScopeRestrictedRegistry CreateScopeRestrictedRegistry(object tag, Action`1<ContainerBuilder> configurationAction);
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    public sealed virtual ISharingLifetimeScope get_ParentLifetimeScope();
    [CompilerGeneratedAttribute]
public sealed virtual ISharingLifetimeScope get_RootLifetimeScope();
    public sealed virtual object GetOrCreateAndShare(Guid id, Func`1<object> creator);
    [CompilerGeneratedAttribute]
public sealed virtual IDisposer get_Disposer();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistry get_ComponentRegistry();
    protected virtual void Dispose(bool disposing);
    private void CheckNotDisposed();
    public sealed virtual object GetService(Type serviceType);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
}
public class Autofac.Core.Lifetime.LifetimeScopeBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ILifetimeScope <LifetimeScope>k__BackingField;
    public ILifetimeScope LifetimeScope { get; }
    public LifetimeScopeBeginningEventArgs(ILifetimeScope lifetimeScope);
    [CompilerGeneratedAttribute]
public ILifetimeScope get_LifetimeScope();
}
public class Autofac.Core.Lifetime.LifetimeScopeEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ILifetimeScope <LifetimeScope>k__BackingField;
    public ILifetimeScope LifetimeScope { get; }
    public LifetimeScopeEndingEventArgs(ILifetimeScope lifetimeScope);
    [CompilerGeneratedAttribute]
public ILifetimeScope get_LifetimeScope();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Lifetime.LifetimeScopeResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ScopeIsDisposed { get; }
    internal static string SelfConstructingDependencyDetected { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ScopeIsDisposed();
    internal static string get_SelfConstructingDependencyDetected();
}
public class Autofac.Core.Lifetime.MatchingScopeLifetime : object {
    private Object[] _tagsToMatch;
    public IEnumerable`1<object> TagsToMatch { get; }
    public MatchingScopeLifetime(Object[] lifetimeScopeTagsToMatch);
    public IEnumerable`1<object> get_TagsToMatch();
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Lifetime.MatchingScopeLifetimeResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MatchingScopeNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MatchingScopeNotFound();
}
public static class Autofac.Core.Lifetime.MatchingScopeLifetimeTags : object {
    public static object RequestLifetimeScopeTag;
    private static MatchingScopeLifetimeTags();
}
public class Autofac.Core.Lifetime.RootScopeLifetime : object {
    public sealed virtual ISharingLifetimeScope FindScope(ISharingLifetimeScope mostNestedVisibleScope);
}
public class Autofac.Core.NamedPropertyParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public NamedPropertyParameter(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public abstract class Autofac.Core.Parameter : object {
    public abstract virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
}
public class Autofac.Core.PreparingEventArgs : EventArgs {
    private IEnumerable`1<Parameter> _parameters;
    [CompilerGeneratedAttribute]
private IComponentContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistration <Component>k__BackingField;
    public IComponentContext Context { get; }
    public IComponentRegistration Component { get; }
    public IEnumerable`1<Parameter> Parameters { get; public set; }
    public PreparingEventArgs(IComponentContext context, IComponentRegistration component, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public IComponentContext get_Context();
    [CompilerGeneratedAttribute]
public IComponentRegistration get_Component();
    public IEnumerable`1<Parameter> get_Parameters();
    public void set_Parameters(IEnumerable`1<Parameter> value);
}
internal class Autofac.Core.Registration.AdaptationSandbox : object {
    private IEnumerable`1<IRegistrationSource> _adapters;
    private IComponentRegistration _registration;
    private IEnumerable`1<Service> _adapterServices;
    private IDictionary`2<Service, IList`1<IRegistrationSource>> _adaptersToQuery;
    private IList`1<IComponentRegistration> _registrations;
    public AdaptationSandbox(IEnumerable`1<IRegistrationSource> adapters, IComponentRegistration registration, IEnumerable`1<Service> adapterServices);
    public IEnumerable`1<IComponentRegistration> GetAdapters();
    private IEnumerable`1<IComponentRegistration> GetAndInitialiseRegistrationsFor(Service service);
    [CompilerGeneratedAttribute]
private bool <GetAdapters>b__6_0(IComponentRegistration r);
}
public class Autofac.Core.Registration.ComponentNotRegisteredException : DependencyResolutionException {
    public ComponentNotRegisteredException(Service service);
    public ComponentNotRegisteredException(Service service, Exception innerException);
    private static string FormatMessage(Service service);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ComponentNotRegisteredExceptionResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Message { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Message();
}
public class Autofac.Core.Registration.ComponentRegistration : Disposable {
    private IComponentRegistration _target;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstanceActivator <Activator>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentLifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceSharing <Sharing>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceOwnership <Ownership>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Service> <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PreparingEventArgs> Preparing;
    [CompilerGeneratedAttribute]
private EventHandler`1<ActivatingEventArgs`1<object>> Activating;
    [CompilerGeneratedAttribute]
private EventHandler`1<ActivatedEventArgs`1<object>> Activated;
    public IComponentRegistration Target { get; }
    public Guid Id { get; }
    public IInstanceActivator Activator { get; public set; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public ComponentRegistration(Guid id, IInstanceActivator activator, IComponentLifetime lifetime, InstanceSharing sharing, InstanceOwnership ownership, IEnumerable`1<Service> services, IDictionary`2<string, object> metadata);
    public ComponentRegistration(Guid id, IInstanceActivator activator, IComponentLifetime lifetime, InstanceSharing sharing, InstanceOwnership ownership, IEnumerable`1<Service> services, IDictionary`2<string, object> metadata, IComponentRegistration target);
    public sealed virtual IComponentRegistration get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual IInstanceActivator get_Activator();
    [CompilerGeneratedAttribute]
public void set_Activator(IInstanceActivator value);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentLifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public sealed virtual InstanceSharing get_Sharing();
    [CompilerGeneratedAttribute]
public sealed virtual InstanceOwnership get_Ownership();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Service> get_Services();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Autofac.Core.Registration.ComponentRegistrationExtensions : object {
    [ExtensionAttribute]
public static bool IsAdapting(IComponentRegistration componentRegistration);
}
internal class Autofac.Core.Registration.ComponentRegistrationLifetimeDecorator : Disposable {
    private IComponentRegistration _inner;
    [CompilerGeneratedAttribute]
private IComponentLifetime <Lifetime>k__BackingField;
    public Guid Id { get; }
    public IInstanceActivator Activator { get; }
    public IComponentLifetime Lifetime { get; }
    public InstanceSharing Sharing { get; }
    public InstanceOwnership Ownership { get; }
    public IEnumerable`1<Service> Services { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public IComponentRegistration Target { get; }
    public ComponentRegistrationLifetimeDecorator(IComponentRegistration inner, IComponentLifetime lifetime);
    public sealed virtual Guid get_Id();
    public sealed virtual IInstanceActivator get_Activator();
    [CompilerGeneratedAttribute]
public sealed virtual IComponentLifetime get_Lifetime();
    public sealed virtual InstanceSharing get_Sharing();
    public sealed virtual InstanceOwnership get_Ownership();
    public sealed virtual IEnumerable`1<Service> get_Services();
    public sealed virtual IDictionary`2<string, object> get_Metadata();
    public sealed virtual IComponentRegistration get_Target();
    public sealed virtual void add_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void remove_Preparing(EventHandler`1<PreparingEventArgs> value);
    public sealed virtual void RaisePreparing(IComponentContext context, IEnumerable`1& parameters);
    public sealed virtual void add_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void remove_Activating(EventHandler`1<ActivatingEventArgs`1<object>> value);
    public sealed virtual void RaiseActivating(IComponentContext context, IEnumerable`1<Parameter> parameters, Object& instance);
    public sealed virtual void add_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void remove_Activated(EventHandler`1<ActivatedEventArgs`1<object>> value);
    public sealed virtual void RaiseActivated(IComponentContext context, IEnumerable`1<Parameter> parameters, object instance);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ComponentRegistrationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ToStringFormat { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ToStringFormat();
}
public class Autofac.Core.Registration.ComponentRegistry : Disposable {
    private object _synchRoot;
    private IList`1<IRegistrationSource> _dynamicRegistrationSources;
    private ICollection`1<IComponentRegistration> _registrations;
    private IDictionary`2<Service, ServiceRegistrationInfo> _serviceInfo;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ComponentRegisteredEventArgs> Registered;
    [CompilerGeneratedAttribute]
private EventHandler`1<RegistrationSourceAddedEventArgs> RegistrationSourceAdded;
    public IDictionary`2<string, object> Properties { get; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    internal ComponentRegistry(IDictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Properties();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public sealed virtual bool IsRegistered(Service service);
    public sealed virtual void Register(IComponentRegistration registration);
    public virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    private void UpdateInitialisedAdapters(IComponentRegistration registration);
    private void AddRegistration(IComponentRegistration registration, bool preserveDefaults, bool originatedFromSource);
    public sealed virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void AddRegistrationSource(IRegistrationSource source);
    public sealed virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public sealed virtual bool get_HasLocalComponents();
    [CompilerGeneratedAttribute]
public sealed virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    private ServiceRegistrationInfo GetInitializedServiceInfo(Service service);
    private ServiceRegistrationInfo GetServiceInfo(Service service);
}
internal class Autofac.Core.Registration.CopyOnWriteRegistry : object {
    private IComponentRegistry _readRegistry;
    private Func`1<IComponentRegistry> _createWriteRegistry;
    private IComponentRegistry _writeRegistry;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    private IComponentRegistry Registry { get; }
    private IComponentRegistry WriteRegistry { get; }
    public IDictionary`2<string, object> Properties { get; public set; }
    public IEnumerable`1<IComponentRegistration> Registrations { get; }
    public IEnumerable`1<IRegistrationSource> Sources { get; }
    public bool HasLocalComponents { get; }
    public CopyOnWriteRegistry(IComponentRegistry readRegistry, Func`1<IComponentRegistry> createWriteRegistry);
    private IComponentRegistry get_Registry();
    private IComponentRegistry get_WriteRegistry();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
    public sealed virtual void Dispose();
    public sealed virtual bool TryGetRegistration(Service service, IComponentRegistration& registration);
    public sealed virtual bool IsRegistered(Service service);
    public sealed virtual void Register(IComponentRegistration registration);
    public sealed virtual void Register(IComponentRegistration registration, bool preserveDefaults);
    public sealed virtual IEnumerable`1<IComponentRegistration> get_Registrations();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service);
    public sealed virtual void add_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void remove_Registered(EventHandler`1<ComponentRegisteredEventArgs> value);
    public sealed virtual void AddRegistrationSource(IRegistrationSource source);
    public sealed virtual IEnumerable`1<IRegistrationSource> get_Sources();
    public sealed virtual bool get_HasLocalComponents();
    public sealed virtual void add_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
    public sealed virtual void remove_RegistrationSourceAdded(EventHandler`1<RegistrationSourceAddedEventArgs> value);
}
internal class Autofac.Core.Registration.ExternalRegistrySource : object {
    private IComponentRegistry _registry;
    public bool IsAdapterForIndividualComponents { get; }
    public ExternalRegistrySource(IComponentRegistry registry);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
}
public interface Autofac.Core.Registration.IModuleRegistrar {
    public abstract virtual IModuleRegistrar RegisterModule(IModule module);
}
internal class Autofac.Core.Registration.ModuleRegistrar : object {
    private ContainerBuilder _builder;
    public ModuleRegistrar(ContainerBuilder builder);
    public sealed virtual IModuleRegistrar RegisterModule(IModule module);
}
internal class Autofac.Core.Registration.ScopeRestrictedRegistry : ComponentRegistry {
    private IComponentLifetime _restrictedRootScopeLifetime;
    internal ScopeRestrictedRegistry(object scopeTag, IDictionary`2<string, object> properties);
    public virtual void Register(IComponentRegistration registration, bool preserveDefaults);
}
internal class Autofac.Core.Registration.ServiceRegistrationInfo : object {
    private Service _service;
    private List`1<IComponentRegistration> _defaultImplementations;
    private List`1<IComponentRegistration> _sourceImplementations;
    private List`1<IComponentRegistration> _preserveDefaultImplementations;
    private IComponentRegistration _defaultImplementation;
    private Queue`1<IRegistrationSource> _sourcesToQuery;
    [CompilerGeneratedAttribute]
private bool <IsInitialized>k__BackingField;
    public bool IsInitialized { get; private set; }
    public IEnumerable`1<IComponentRegistration> Implementations { get; }
    public bool IsRegistered { get; }
    private bool Any { get; }
    public bool IsInitializing { get; }
    public bool HasSourcesToQuery { get; }
    public ServiceRegistrationInfo(Service service);
    [CompilerGeneratedAttribute]
public bool get_IsInitialized();
    [CompilerGeneratedAttribute]
private void set_IsInitialized(bool value);
    public IEnumerable`1<IComponentRegistration> get_Implementations();
    private void RequiresInitialization();
    public bool get_IsRegistered();
    private bool get_Any();
    public void AddImplementation(IComponentRegistration registration, bool preserveDefaults, bool originatedFromSource);
    public bool TryGetRegistration(IComponentRegistration& registration);
    public void Include(IRegistrationSource source);
    public bool get_IsInitializing();
    public bool get_HasSourcesToQuery();
    public void BeginInitialization(IEnumerable`1<IRegistrationSource> sources);
    public void SkipSource(IRegistrationSource source);
    private void EnforceDuringInitialization();
    public IRegistrationSource DequeueNextSource();
    public void CompleteInitialization();
    public bool ShouldRecalculateAdaptersOn(IComponentRegistration registration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Registration.ServiceRegistrationInfoResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NotDuringInitialization { get; }
    internal static string NotInitialized { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NotDuringInitialization();
    internal static string get_NotInitialized();
}
public class Autofac.Core.RegistrationSourceAddedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IRegistrationSource <RegistrationSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IComponentRegistry <ComponentRegistry>k__BackingField;
    public IRegistrationSource RegistrationSource { get; }
    public IComponentRegistry ComponentRegistry { get; }
    public RegistrationSourceAddedEventArgs(IComponentRegistry componentRegistry, IRegistrationSource registrationSource);
    [CompilerGeneratedAttribute]
public IRegistrationSource get_RegistrationSource();
    [CompilerGeneratedAttribute]
public IComponentRegistry get_ComponentRegistry();
}
public class Autofac.Core.ResolvedParameter : Parameter {
    private Func`3<ParameterInfo, IComponentContext, bool> _predicate;
    private Func`3<ParameterInfo, IComponentContext, object> _valueAccessor;
    public ResolvedParameter(Func`3<ParameterInfo, IComponentContext, bool> predicate, Func`3<ParameterInfo, IComponentContext, object> valueAccessor);
    public virtual bool CanSupplyValue(ParameterInfo pi, IComponentContext context, Func`1& valueProvider);
    public static ResolvedParameter ForNamed(string serviceName);
    public static ResolvedParameter ForKeyed(object serviceKey);
}
internal class Autofac.Core.Resolving.CircularDependencyDetector : object {
    private static int MaxResolveDepth;
    private static string CreateDependencyGraphTo(IComponentRegistration registration, IEnumerable`1<InstanceLookup> activationStack);
    private static string Display(IComponentRegistration registration);
    public static void CheckForCircularDependency(IComponentRegistration registration, Stack`1<InstanceLookup> activationStack, int callDepth);
    private static bool IsCircularDependency(IComponentRegistration registration, IEnumerable`1<InstanceLookup> activationStack);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.CircularDependencyDetectorResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CircularDependency { get; }
    internal static string MaxDepthExceeded { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CircularDependency();
    internal static string get_MaxDepthExceeded();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.ComponentActivationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string ActivationAlreadyExecuted { get; }
    public static string ErrorDuringActivation { get; }
    public static string UnableToLocateLifetimeScope { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_ActivationAlreadyExecuted();
    public static string get_ErrorDuringActivation();
    public static string get_UnableToLocateLifetimeScope();
}
public interface Autofac.Core.Resolving.IInstanceLookup {
    public IComponentRegistration ComponentRegistration { get; }
    public ILifetimeScope ActivationScope { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public abstract virtual IComponentRegistration get_ComponentRegistration();
    public abstract virtual ILifetimeScope get_ActivationScope();
    public abstract virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public abstract virtual void add_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
}
internal class Autofac.Core.Resolving.InstanceLookup : object {
    private IResolveOperation _context;
    private ISharingLifetimeScope _activationScope;
    private object _newInstance;
    private bool _executed;
    [CompilerGeneratedAttribute]
private IComponentRegistration <ComponentRegistration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Parameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupEndingEventArgs> InstanceLookupEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupCompletionBeginningEventArgs> CompletionBeginning;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupCompletionEndingEventArgs> CompletionEnding;
    private bool NewInstanceActivated { get; }
    public IComponentRegistry ComponentRegistry { get; }
    public IComponentRegistration ComponentRegistration { get; }
    public ILifetimeScope ActivationScope { get; }
    public IEnumerable`1<Parameter> Parameters { get; }
    public InstanceLookup(IComponentRegistration registration, IResolveOperation context, ISharingLifetimeScope mostNestedVisibleScope, IEnumerable`1<Parameter> parameters);
    public object Execute();
    private bool get_NewInstanceActivated();
    private object Activate(IEnumerable`1<Parameter> parameters);
    public void Complete();
    public sealed virtual IComponentRegistry get_ComponentRegistry();
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public sealed virtual IComponentRegistration get_ComponentRegistration();
    public sealed virtual ILifetimeScope get_ActivationScope();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Parameter> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void add_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InstanceLookupEnding(EventHandler`1<InstanceLookupEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CompletionBeginning(EventHandler`1<InstanceLookupCompletionBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CompletionEnding(EventHandler`1<InstanceLookupCompletionEndingEventArgs> value);
    [CompilerGeneratedAttribute]
private object <Execute>b__5_0();
}
public class Autofac.Core.Resolving.InstanceLookupBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupBeginningEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
public class Autofac.Core.Resolving.InstanceLookupCompletionBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupCompletionBeginningEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
public class Autofac.Core.Resolving.InstanceLookupCompletionEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupCompletionEndingEventArgs(IInstanceLookup instanceLookup);
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
public class Autofac.Core.Resolving.InstanceLookupEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <NewInstanceActivated>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstanceLookup <InstanceLookup>k__BackingField;
    public bool NewInstanceActivated { get; }
    public IInstanceLookup InstanceLookup { get; }
    public InstanceLookupEndingEventArgs(IInstanceLookup instanceLookup, bool newInstanceActivated);
    [CompilerGeneratedAttribute]
public bool get_NewInstanceActivated();
    [CompilerGeneratedAttribute]
public IInstanceLookup get_InstanceLookup();
}
public interface Autofac.Core.Resolving.IResolveOperation {
    public abstract virtual object GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
}
internal class Autofac.Core.Resolving.ResolveOperation : object {
    private Stack`1<InstanceLookup> _activationStack;
    private ICollection`1<InstanceLookup> _successfulActivations;
    private ISharingLifetimeScope _mostNestedLifetimeScope;
    private int _callDepth;
    private bool _ended;
    [CompilerGeneratedAttribute]
private EventHandler`1<ResolveOperationEndingEventArgs> CurrentOperationEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<InstanceLookupBeginningEventArgs> InstanceLookupBeginning;
    public IComponentRegistry ComponentRegistry { get; }
    public ResolveOperation(ISharingLifetimeScope mostNestedLifetimeScope);
    public sealed virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    public object Execute(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    public sealed virtual object GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CurrentOperationEnding(EventHandler`1<ResolveOperationEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_InstanceLookupBeginning(EventHandler`1<InstanceLookupBeginningEventArgs> value);
    private void CompleteActivations();
    private void ResetSuccessfulActivations();
    public sealed virtual IComponentRegistry get_ComponentRegistry();
    private void End(Exception exception);
}
public class Autofac.Core.Resolving.ResolveOperationBeginningEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IResolveOperation <ResolveOperation>k__BackingField;
    public IResolveOperation ResolveOperation { get; }
    public ResolveOperationBeginningEventArgs(IResolveOperation resolveOperation);
    [CompilerGeneratedAttribute]
public IResolveOperation get_ResolveOperation();
}
public class Autofac.Core.Resolving.ResolveOperationEndingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IResolveOperation <ResolveOperation>k__BackingField;
    public Exception Exception { get; }
    public IResolveOperation ResolveOperation { get; }
    public ResolveOperationEndingEventArgs(IResolveOperation resolveOperation, Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public IResolveOperation get_ResolveOperation();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.Resolving.ResolveOperationResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExceptionDuringResolve { get; }
    internal static string MaxDepthExceeded { get; }
    internal static string TemporaryContextDisposed { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExceptionDuringResolve();
    internal static string get_MaxDepthExceeded();
    internal static string get_TemporaryContextDisposed();
}
public abstract class Autofac.Core.Service : object {
    public string Description { get; }
    public abstract virtual string get_Description();
    public virtual string ToString();
    public static bool op_Equality(Service left, Service right);
    public static bool op_Inequality(Service left, Service right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Core.ServiceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MustOverrideEquals { get; }
    internal static string MustOverrideGetHashCode { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MustOverrideEquals();
    internal static string get_MustOverrideGetHashCode();
}
public class Autofac.Core.TypedService : Service {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    public Type ServiceType { get; }
    public string Description { get; }
    public TypedService(Type serviceType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    public virtual string get_Description();
    public sealed virtual bool Equals(TypedService other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Service ChangeType(Type newType);
}
public class Autofac.Core.UniqueService : Service {
    private Guid _id;
    public string Description { get; }
    public UniqueService(Guid id);
    public virtual string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Autofac.Features.AttributeFilters.KeyFilterAttribute : ParameterFilterAttribute {
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public object Key { get; }
    public KeyFilterAttribute(object key);
    [CompilerGeneratedAttribute]
public object get_Key();
    public virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
}
public class Autofac.Features.AttributeFilters.MetadataFilterAttribute : ParameterFilterAttribute {
    private static MethodInfo FilterOneMethod;
    private static MethodInfo FilterAllMethod;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Key { get; }
    public object Value { get; private set; }
    public MetadataFilterAttribute(string key, object value);
    private static MetadataFilterAttribute();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    public virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
    private static Type GetElementType(Type type);
    private static T FilterOne(IComponentContext context, string metadataKey, object metadataValue);
    private static IEnumerable`1<T> FilterAll(IComponentContext context, string metadataKey, object metadataValue);
}
[AttributeUsageAttribute("2048")]
public abstract class Autofac.Features.AttributeFilters.ParameterFilterAttribute : Attribute {
    public abstract virtual object ResolveParameter(ParameterInfo parameter, IComponentContext context);
}
[ExtensionAttribute]
public static class Autofac.Features.AttributeFilters.RegistrationExtensions : object {
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TRegistrationStyle> WithAttributeFiltering(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TRegistrationStyle> builder);
}
internal class Autofac.Features.Collections.CollectionRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Collections.CollectionRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CollectionRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CollectionRegistrationSourceDescription();
}
public class Autofac.Features.GeneratedFactories.FactoryGenerator : object {
    private Func`3<IComponentContext, IEnumerable`1<Parameter>, Delegate> _generator;
    public FactoryGenerator(Type delegateType, Service service, ParameterMapping parameterMapping);
    public FactoryGenerator(Type delegateType, IComponentRegistration productRegistration, ParameterMapping parameterMapping);
    private static ParameterMapping GetParameterMapping(Type delegateType, ParameterMapping configuredParameterMapping);
    private static bool DelegateTypeIsFunc(Type delegateType);
    private static Func`3<IComponentContext, IEnumerable`1<Parameter>, Delegate> CreateGenerator(Func`3<Expression, Expression[], Expression> makeResolveCall, Type delegateType, ParameterMapping pm);
    private static Expression[] MapParameters(IEnumerable`1<ParameterExpression> creatorParams, ParameterMapping pm);
    public Delegate GenerateFactory(IComponentContext context, IEnumerable`1<Parameter> parameters);
    public TDelegate GenerateFactory(IComponentContext context, IEnumerable`1<Parameter> parameters);
}
public class Autofac.Features.GeneratedFactories.GeneratedFactoryActivatorData : object {
    private Type _delegateType;
    private Service _productService;
    [CompilerGeneratedAttribute]
private ParameterMapping <ParameterMapping>k__BackingField;
    public ParameterMapping ParameterMapping { get; public set; }
    public IInstanceActivator Activator { get; }
    public GeneratedFactoryActivatorData(Type delegateType, Service productService);
    [CompilerGeneratedAttribute]
public ParameterMapping get_ParameterMapping();
    [CompilerGeneratedAttribute]
public void set_ParameterMapping(ParameterMapping value);
    public sealed virtual IInstanceActivator get_Activator();
}
internal static class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationExtensions : object {
    internal static IRegistrationBuilder`3<TLimit, GeneratedFactoryActivatorData, SingleRegistrationStyle> RegisterGeneratedFactory(ContainerBuilder builder, Type delegateType, Service service);
}
internal class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.GeneratedFactories.GeneratedFactoryRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DuplicateTypesInTypeMappedFuncParameterList { get; }
    internal static string GeneratedFactoryRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DuplicateTypesInTypeMappedFuncParameterList();
    internal static string get_GeneratedFactoryRegistrationSourceDescription();
}
public enum Autofac.Features.GeneratedFactories.ParameterMapping : Enum {
    public int value__;
    public static ParameterMapping Adaptive;
    public static ParameterMapping ByName;
    public static ParameterMapping ByType;
    public static ParameterMapping ByPosition;
}
[DefaultMemberAttribute("Item")]
public interface Autofac.Features.Indexed.IIndex`2 {
    public TValue Item { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[DefaultMemberAttribute("Item")]
internal class Autofac.Features.Indexed.KeyedServiceIndex`2 : object {
    private IComponentContext _context;
    public TValue Item { get; }
    public KeyedServiceIndex`2(IComponentContext context);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private static KeyedService GetService(TKey key);
}
internal class Autofac.Features.LazyDependencies.LazyRegistrationSource : object {
    private static MethodInfo CreateLazyRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static LazyRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateLazyRegistration(Service providedService, IComponentRegistration valueRegistration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LazyDependencies.LazyRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string LazyRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_LazyRegistrationSourceDescription();
}
internal class Autofac.Features.LazyDependencies.LazyWithMetadataRegistrationSource : object {
    private static MethodInfo CreateLazyRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static LazyWithMetadataRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateLazyRegistration(Service providedService, IComponentRegistration valueRegistration);
    private static Type GetLazyType(IServiceWithType serviceWithType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LazyDependencies.LazyWithMetadataRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string LazyWithMetadataRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_LazyWithMetadataRegistrationSourceDescription();
}
public class Autofac.Features.LightweightAdapters.LightweightAdapterActivatorData : object {
    [CompilerGeneratedAttribute]
private Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> <Adapter>k__BackingField;
    [CompilerGeneratedAttribute]
private Service <FromService>k__BackingField;
    public Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> Adapter { get; }
    public Service FromService { get; }
    public LightweightAdapterActivatorData(Service fromService, Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> adapter);
    [CompilerGeneratedAttribute]
public Func`4<IComponentContext, IEnumerable`1<Parameter>, object, object> get_Adapter();
    [CompilerGeneratedAttribute]
public Service get_FromService();
}
internal static class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationExtensions : object {
    public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter);
    public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TService, TService> decorator, object fromKey, object toKey);
    private static Service ServiceWithKey(object key);
    private static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter, Service fromService, Service toService);
}
internal class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSource : object {
    private RegistrationData _registrationData;
    private LightweightAdapterActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public LightweightAdapterRegistrationSource(RegistrationData registrationData, LightweightAdapterActivatorData activatorData);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private IComponentRegistration <RegistrationsFor>b__3_0(IComponentRegistration r);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.LightweightAdapters.LightweightAdapterRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AdapterFromToDescription { get; }
    internal static string FromAndToMustDiffer { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AdapterFromToDescription();
    internal static string get_FromAndToMustDiffer();
}
public class Autofac.Features.Metadata.Meta`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Metadata>k__BackingField;
    public T Value { get; }
    public IDictionary`2<string, object> Metadata { get; }
    public Meta`1(T value, IDictionary`2<string, object> metadata);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Metadata();
}
public class Autofac.Features.Metadata.Meta`2 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TMetadata <Metadata>k__BackingField;
    public T Value { get; }
    public TMetadata Metadata { get; }
    public Meta`2(T value, TMetadata metadata);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public TMetadata get_Metadata();
}
internal static class Autofac.Features.Metadata.MetadataViewProvider : object {
    private static MethodInfo GetMetadataValueMethod;
    private static MetadataViewProvider();
    public static Func`2<IDictionary`2<string, object>, TMetadata> GetMetadataViewProvider();
    private static TValue GetMetadataValue(IDictionary`2<string, object> metadata, string name, DefaultValueAttribute defaultValue);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Metadata.MetadataViewProviderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidViewImplementation { get; }
    internal static string MissingMetadata { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidViewImplementation();
    internal static string get_MissingMetadata();
}
internal class Autofac.Features.Metadata.MetaRegistrationSource : object {
    private static MethodInfo CreateMetaRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static MetaRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateMetaRegistration(Service providedService, IComponentRegistration valueRegistration);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.Metadata.MetaRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MetaRegistrationSourceDescription { get; }
    internal static string StronglyTypedMetaRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MetaRegistrationSourceDescription();
    internal static string get_StronglyTypedMetaRegistrationSourceDescription();
}
internal class Autofac.Features.Metadata.StronglyTypedMetaRegistrationSource : object {
    private static MethodInfo CreateMetaRegistrationMethod;
    public bool IsAdapterForIndividualComponents { get; }
    private static StronglyTypedMetaRegistrationSource();
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
    private static IComponentRegistration CreateMetaRegistration(Service providedService, IComponentRegistration valueRegistration);
}
public class Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorData : ReflectionActivatorData {
    [CompilerGeneratedAttribute]
private IServiceWithType <FromService>k__BackingField;
    public IServiceWithType FromService { get; }
    public OpenGenericDecoratorActivatorData(Type implementer, IServiceWithType fromService);
    [CompilerGeneratedAttribute]
public IServiceWithType get_FromService();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorActivatorDataResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DecoratedServiceIsNotOpenGeneric { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DecoratedServiceIsNotOpenGeneric();
}
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorRegistrationSource : object {
    private RegistrationData _registrationData;
    private OpenGenericDecoratorActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public OpenGenericDecoratorRegistrationSource(RegistrationData registrationData, OpenGenericDecoratorActivatorData activatorData);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    private static IEnumerable`1<Parameter> AddDecoratedComponentParameter(Type decoratedParameterType, IComponentRegistration decoratedComponent, IEnumerable`1<Parameter> configuredParameters);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericDecoratorRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FromAndToMustDiffer { get; }
    internal static string OpenGenericDecoratorRegistrationSourceImplFromTo { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FromAndToMustDiffer();
    internal static string get_OpenGenericDecoratorRegistrationSourceImplFromTo();
}
internal static class Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensions : object {
    public static IRegistrationBuilder`3<object, ReflectionActivatorData, DynamicRegistrationStyle> RegisterGeneric(ContainerBuilder builder, Type implementor);
    public static IRegistrationBuilder`3<object, OpenGenericDecoratorActivatorData, DynamicRegistrationStyle> RegisterGenericDecorator(ContainerBuilder builder, Type decoratorType, Type decoratedServiceType, object fromKey, object toKey);
    private static IServiceWithType GetServiceWithKey(Type serviceType, object key);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ImplementorMustBeOpenGenericType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ImplementorMustBeOpenGenericType();
}
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationSource : object {
    private RegistrationData _registrationData;
    private ReflectionActivatorData _activatorData;
    public bool IsAdapterForIndividualComponents { get; }
    public OpenGenericRegistrationSource(RegistrationData registrationData, ReflectionActivatorData activatorData);
    [IteratorStateMachineAttribute("Autofac.Features.OpenGenerics.OpenGenericRegistrationSource/<RegistrationsFor>d__3")]
public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string OpenGenericRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_OpenGenericRegistrationSourceDescription();
}
internal static class Autofac.Features.OpenGenerics.OpenGenericServiceBinder : object {
    public static bool TryBindServiceType(Service service, IEnumerable`1<Service> configuredOpenGenericServices, Type openGenericImplementationType, Type& constructedImplementationType, IEnumerable`1& constructedServices);
    private static Type[] TryMapImplementationGenericArguments(Type implementationType, Type serviceType, Type serviceTypeDefinition, Type[] serviceGenericArguments);
    private static Type GetInterface(Type implementationType, Type serviceType);
    private static Type TryFindServiceArgumentForImplementationArgumentDefinition(Type implementationGenericArgumentDefinition, IEnumerable`1<KeyValuePair`2<Type, Type>> serviceArgumentDefinitionToArgument);
    public static void EnforceBindable(Type implementationType, IEnumerable`1<Service> services);
    private static bool IsCompatibleGenericClassDefinition(Type implementor, Type serviceType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OpenGenerics.OpenGenericServiceBinderResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ImplementorDoesntImplementService { get; }
    internal static string ImplementorMustBeOpenGenericTypeDefinition { get; }
    internal static string InterfaceIsNotImplemented { get; }
    internal static string ServiceTypeMustBeOpenGenericTypeDefinition { get; }
    internal static string TypesAreNotConvertible { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ImplementorDoesntImplementService();
    internal static string get_ImplementorMustBeOpenGenericTypeDefinition();
    internal static string get_InterfaceIsNotImplemented();
    internal static string get_ServiceTypeMustBeOpenGenericTypeDefinition();
    internal static string get_TypesAreNotConvertible();
}
public class Autofac.Features.OwnedInstances.Owned`1 : Disposable {
    private IDisposable _lifetime;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public Owned`1(T value, IDisposable lifetime);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    protected virtual void Dispose(bool disposing);
}
internal class Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSource : object {
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.OwnedInstances.OwnedInstanceRegistrationSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string OwnedInstanceRegistrationSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_OwnedInstanceRegistrationSourceDescription();
}
public class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSource : object {
    private Func`2<Type, bool> _predicate;
    [CompilerGeneratedAttribute]
private Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> <RegistrationConfiguration>k__BackingField;
    public bool IsAdapterForIndividualComponents { get; }
    public Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> RegistrationConfiguration { get; public set; }
    public AnyConcreteTypeNotAlreadyRegisteredSource(Func`2<Type, bool> predicate);
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
    [CompilerGeneratedAttribute]
public Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> get_RegistrationConfiguration();
    [CompilerGeneratedAttribute]
public void set_RegistrationConfiguration(Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSourceExtensions : object {
    [ExtensionAttribute]
public static AnyConcreteTypeNotAlreadyRegisteredSource WithRegistrationsAs(AnyConcreteTypeNotAlreadyRegisteredSource source, Action`1<IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>> configurationAction);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Features.ResolveAnything.AnyConcreteTypeNotAlreadyRegisteredSourceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AnyConcreteTypeNotAlreadyRegisteredSourceDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AnyConcreteTypeNotAlreadyRegisteredSourceDescription();
}
public class Autofac.Features.Scanning.ScanningActivatorData : ReflectionActivatorData {
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<Type, bool>> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> <ConfigurationActions>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Action`1<IComponentRegistry>> <PostScanningCallbacks>k__BackingField;
    public ICollection`1<Func`2<Type, bool>> Filters { get; }
    public ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> ConfigurationActions { get; }
    public ICollection`1<Action`1<IComponentRegistry>> PostScanningCallbacks { get; }
    [CompilerGeneratedAttribute]
public ICollection`1<Func`2<Type, bool>> get_Filters();
    [CompilerGeneratedAttribute]
public ICollection`1<Action`2<Type, IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle>>> get_ConfigurationActions();
    [CompilerGeneratedAttribute]
public ICollection`1<Action`1<IComponentRegistry>> get_PostScanningCallbacks();
}
[ExtensionAttribute]
internal static class Autofac.Features.Scanning.ScanningRegistrationExtensions : object {
    public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterAssemblyTypes(ContainerBuilder builder, Assembly[] assemblies);
    public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterTypes(ContainerBuilder builder, Type[] types);
    private static void ScanAssemblies(IEnumerable`1<Assembly> assemblies, IComponentRegistry cr, IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> rb);
    private static void ScanTypes(IEnumerable`1<Type> types, IComponentRegistry cr, IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> rb);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, object serviceKey);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AssignableTo(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type type);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Service>> serviceMapping);
    public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration);
}
public class Autofac.Features.Variance.ContravariantRegistrationSource : object {
    private static string IsContravariantAdapter;
    public bool IsAdapterForIndividualComponents { get; }
    public sealed virtual IEnumerable`1<IComponentRegistration> RegistrationsFor(Service service, Func`2<Service, IEnumerable`1<IComponentRegistration>> registrationAccessor);
    private static Type[] SubstituteArrayElementAt(Type[] array, Type newElement, int index);
    private static IEnumerable`1<Type> GetTypesAssignableFrom(Type type);
    [IteratorStateMachineAttribute("Autofac.Features.Variance.ContravariantRegistrationSource/<GetBagOfTypesAssignableFrom>d__4")]
private static IEnumerable`1<Type> GetBagOfTypesAssignableFrom(Type type);
    private static bool IsCompatibleInterfaceType(Type type, Int32& contravariantParameterIndex);
    public sealed virtual bool get_IsAdapterForIndividualComponents();
}
public interface Autofac.IComponentContext {
    public IComponentRegistry ComponentRegistry { get; }
    public abstract virtual IComponentRegistry get_ComponentRegistry();
    public abstract virtual object ResolveComponent(IComponentRegistration registration, IEnumerable`1<Parameter> parameters);
}
public interface Autofac.IContainer {
}
public interface Autofac.ILifetimeScope {
    public IDisposer Disposer { get; }
    public object Tag { get; }
    public abstract virtual ILifetimeScope BeginLifetimeScope();
    public abstract virtual ILifetimeScope BeginLifetimeScope(object tag);
    public abstract virtual ILifetimeScope BeginLifetimeScope(Action`1<ContainerBuilder> configurationAction);
    public abstract virtual ILifetimeScope BeginLifetimeScope(object tag, Action`1<ContainerBuilder> configurationAction);
    public abstract virtual IDisposer get_Disposer();
    public abstract virtual object get_Tag();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChildLifetimeScopeBeginning(EventHandler`1<LifetimeScopeBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CurrentScopeEnding(EventHandler`1<LifetimeScopeEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResolveOperationBeginning(EventHandler`1<ResolveOperationBeginningEventArgs> value);
}
public interface Autofac.IStartable {
    public abstract virtual void Start();
}
public abstract class Autofac.Module : object {
    protected Assembly ThisAssembly { get; }
    public sealed virtual void Configure(IComponentRegistry componentRegistry);
    protected virtual void Load(ContainerBuilder builder);
    protected virtual void AttachToComponentRegistration(IComponentRegistry componentRegistry, IComponentRegistration registration);
    protected virtual void AttachToRegistrationSource(IComponentRegistry componentRegistry, IRegistrationSource registrationSource);
    private void AttachToRegistrations(IComponentRegistry componentRegistry);
    private void AttachToSources(IComponentRegistry componentRegistry);
    protected virtual Assembly get_ThisAssembly();
    [CompilerGeneratedAttribute]
private void <AttachToRegistrations>b__4_0(object sender, ComponentRegisteredEventArgs e);
    [CompilerGeneratedAttribute]
private void <AttachToSources>b__5_0(object sender, RegistrationSourceAddedEventArgs e);
}
[ExtensionAttribute]
public static class Autofac.ModuleRegistrationExtensions : object {
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(ContainerBuilder builder, Type moduleType, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterAssemblyModules(IModuleRegistrar registrar, Type moduleType, Assembly[] assemblies);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(ContainerBuilder builder);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(IModuleRegistrar registrar);
    [ExtensionAttribute]
public static IModuleRegistrar RegisterModule(ContainerBuilder builder, IModule module);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.ModuleResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string ThisAssemblyUnavailable { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_ThisAssemblyUnavailable();
}
public class Autofac.NamedParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public NamedParameter(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[ExtensionAttribute]
public static class Autofac.ParameterExtensions : object {
    [ExtensionAttribute]
public static T Named(IEnumerable`1<Parameter> parameters, string name);
    [ExtensionAttribute]
public static T Positional(IEnumerable`1<Parameter> parameters, int position);
    [ExtensionAttribute]
public static T TypedAs(IEnumerable`1<Parameter> parameters);
    private static TValue ConstantValue(IEnumerable`1<Parameter> parameters, Func`2<TParameter, bool> predicate);
}
public class Autofac.PositionalParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; private set; }
    public PositionalParameter(int position, object value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
}
[FlagsAttribute]
public enum Autofac.PropertyWiringOptions : Enum {
    public int value__;
    public static PropertyWiringOptions None;
    public static PropertyWiringOptions AllowCircularDependencies;
    public static PropertyWiringOptions PreserveSetValues;
}
[ExtensionAttribute]
public static class Autofac.RegistrationExtensions : object {
    [ExtensionAttribute]
public static void RegisterComponent(ContainerBuilder builder, IComponentRegistration registration);
    [ExtensionAttribute]
public static void RegisterSource(ContainerBuilder builder, IRegistrationSource registrationSource);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> RegisterInstance(ContainerBuilder builder, T instance);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TImplementer, ConcreteReflectionActivatorData, SingleRegistrationStyle> RegisterType(ContainerBuilder builder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ConcreteReflectionActivatorData, SingleRegistrationStyle> RegisterType(ContainerBuilder builder, Type implementationType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> Register(ContainerBuilder builder, Func`2<IComponentContext, T> delegate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<T, SimpleActivatorData, SingleRegistrationStyle> Register(ContainerBuilder builder, Func`3<IComponentContext, IEnumerable`1<Parameter>, T> delegate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ReflectionActivatorData, DynamicRegistrationStyle> RegisterGeneric(ContainerBuilder builder, Type implementer);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> PreserveExistingDefaults(IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterAssemblyTypes(ContainerBuilder builder, Assembly[] assemblies);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> RegisterTypes(ContainerBuilder builder, Type[] types);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Where(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, bool> predicate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Service>> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, Service> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, Type> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> As(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<Type>> serviceMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> AsSelf(IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> WithMetadata(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, IEnumerable`1<KeyValuePair`2<string, object>>> metadataMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> WithMetadataFrom(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> WithMetadata(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, string metadataKey, Func`2<Type, object> metadataValueMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Named(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Func`2<Type, string> serviceNameMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Named(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, string> serviceNameMapping, Type serviceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Keyed(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> Keyed(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Func`2<Type, object> serviceKeyMapping, Type serviceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, TConcreteActivatorData, SingleRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> AsImplementedInterfaces(IRegistrationBuilder`3<TLimit, ReflectionActivatorData, DynamicRegistrationStyle> registration);
    private static Type[] GetImplementedInterfaces(Type type);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> FindConstructorsWith(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IConstructorFinder constructorFinder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> FindConstructorsWith(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Func`2<Type, ConstructorInfo[]> finder);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> PropertiesAutowired(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration, PropertyWiringOptions wiringFlags);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> PropertiesAutowired(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Func`3<PropertyInfo, object, bool> propertySelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Type[] signature);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IConstructorSelector constructorSelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> UsingConstructor(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Expression`1<Func`1<TLimit>> constructorSelector);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, string parameterName, object parameterValue);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Parameter parameter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameter(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Func`3<ParameterInfo, IComponentContext, bool> parameterSelector, Func`3<ParameterInfo, IComponentContext, object> valueProvider);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithParameters(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperty(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, string propertyName, object propertyValue);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperty(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, Parameter property);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> WithProperties(IRegistrationBuilder`3<TLimit, TReflectionActivatorData, TStyle> registration, IEnumerable`1<Parameter> properties);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> Targeting(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, IComponentRegistration target);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> OnRegistered(IRegistrationBuilder`3<TLimit, TActivatorData, TSingleRegistrationStyle> registration, Action`1<ComponentRegisteredEventArgs> handler);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> OnRegistered(IRegistrationBuilder`3<TLimit, ScanningActivatorData, TRegistrationStyle> registration, Action`1<ComponentRegisteredEventArgs> handler);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, object serviceKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AsClosedTypesOf(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type openGenericServiceType, Func`2<Type, object> serviceKeyMapping);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> AssignableTo(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, Type type);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> AssignableTo(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Except(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> Except(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration, Action`1<IRegistrationBuilder`3<T, ConcreteReflectionActivatorData, SingleRegistrationStyle>> customizedRegistration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> InNamespaceOf(IRegistrationBuilder`3<object, ScanningActivatorData, DynamicRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> InNamespace(IRegistrationBuilder`3<TLimit, TScanningActivatorData, TRegistrationStyle> registration, string ns);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`3<IComponentContext, TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TTo, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterAdapter(ContainerBuilder builder, Func`2<TFrom, TTo> adapter);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<object, OpenGenericDecoratorActivatorData, DynamicRegistrationStyle> RegisterGenericDecorator(ContainerBuilder builder, Type decoratorType, Type decoratedServiceType, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`4<IComponentContext, IEnumerable`1<Parameter>, TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`3<IComponentContext, TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TService, LightweightAdapterActivatorData, DynamicRegistrationStyle> RegisterDecorator(ContainerBuilder builder, Func`2<TService, TService> decorator, object fromKey, object toKey);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> OnRelease(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration, Action`1<TLimit> releaseAction);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> AutoActivate(IRegistrationBuilder`3<TLimit, TActivatorData, TRegistrationStyle> registration);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> InstancePerRequest(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Object[] lifetimeScopeTags);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> OnlyIf(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Predicate`1<IComponentRegistry> predicate);
    [ExtensionAttribute]
public static IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> IfNotRegistered(IRegistrationBuilder`3<TLimit, TActivatorData, TStyle> registration, Type serviceType);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class Autofac.RegistrationExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string InstanceRegistrationsAreSingleInstanceOnly { get; }
    public static string MetadataAttributeNotFound { get; }
    public static string MultipleMetadataAttributesSameType { get; }
    public static string NoMatchingConstructorExists { get; }
    public static string OnlyIfRequiresCallbackContainer { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_InstanceRegistrationsAreSingleInstanceOnly();
    public static string get_MetadataAttributeNotFound();
    public static string get_MultipleMetadataAttributesSameType();
    public static string get_NoMatchingConstructorExists();
    public static string get_OnlyIfRequiresCallbackContainer();
}
[ExtensionAttribute]
public static class Autofac.ResolutionExtensions : object {
    public static string PropertyInjectedInstanceTypeNamedParameter;
    private static IEnumerable`1<Parameter> NoParameters;
    private static ResolutionExtensions();
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, Parameter[] parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectProperties(IComponentContext context, TService instance, IPropertySelector propertySelector, Parameter[] parameters);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService InjectUnsetProperties(IComponentContext context, TService instance, Parameter[] parameters);
    [ExtensionAttribute]
public static bool IsRegistered(IComponentContext context);
    [ExtensionAttribute]
public static bool IsRegistered(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static bool IsRegisteredService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static bool IsRegisteredWithKey(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static bool IsRegisteredWithKey(IComponentContext context, object serviceKey, Type serviceType);
    [ExtensionAttribute]
public static bool IsRegisteredWithName(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static bool IsRegisteredWithName(IComponentContext context, string serviceName, Type serviceType);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService Resolve(IComponentContext context, Parameter[] parameters);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object Resolve(IComponentContext context, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveKeyed(IComponentContext context, object serviceKey, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveNamed(IComponentContext context, string serviceName, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveNamed(IComponentContext context, string serviceName, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptional(IComponentContext context, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveOptional(IComponentContext context, Type serviceType, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalKeyed(IComponentContext context, object serviceKey, Parameter[] parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static TService ResolveOptionalNamed(IComponentContext context, string serviceName, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveOptionalService(IComponentContext context, Service service, Parameter[] parameters);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters);
    [ExtensionAttribute]
public static object ResolveService(IComponentContext context, Service service, Parameter[] parameters);
    [ExtensionAttribute]
public static bool TryResolve(IComponentContext context, T& instance);
    [ExtensionAttribute]
public static bool TryResolve(IComponentContext context, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveKeyed(IComponentContext context, object serviceKey, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveNamed(IComponentContext context, string serviceName, Type serviceType, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveService(IComponentContext context, Service service, Object& instance);
    [ExtensionAttribute]
public static bool TryResolveService(IComponentContext context, Service service, IEnumerable`1<Parameter> parameters, Object& instance);
}
public class Autofac.TypedParameter : ConstantParameter {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; private set; }
    public TypedParameter(Type type, object value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    public static TypedParameter From(T value);
}
[ExtensionAttribute]
public static class Autofac.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsInNamespace(Type this, string namespace);
    [ExtensionAttribute]
public static bool IsInNamespaceOf(Type this);
    [ExtensionAttribute]
public static bool IsClosedTypeOf(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type this);
    [ExtensionAttribute]
public static ConstructorInfo GetMatchingConstructor(Type type, Type[] constructorParameterTypes);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.TypeExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string NotOpenGenericType { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_NotOpenGenericType();
}
[ExtensionAttribute]
public static class Autofac.Util.AssemblyExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetLoadableTypes(Assembly assembly);
}
public class Autofac.Util.Disposable : object {
    private static int DisposedFlag;
    private int _isDisposed;
    protected bool IsDisposed { get; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected bool get_IsDisposed();
}
internal static class Autofac.Util.Enforce : object {
    public static IEnumerable`1<T> ArgumentElementNotNull(IEnumerable`1<T> value, string name);
    public static T NotNull(T value);
    public static string ArgumentNotNullOrEmpty(string value, string description);
    public static void ArgumentTypeIsFunction(Type delegateType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Util.EnforceResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotBeEmpty { get; }
    internal static string CannotBeNull { get; }
    internal static string DelegateReturnsVoid { get; }
    internal static string ElementCannotBeNull { get; }
    internal static string NotDelegate { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotBeEmpty();
    internal static string get_CannotBeNull();
    internal static string get_DelegateReturnsVoid();
    internal static string get_ElementCannotBeNull();
    internal static string get_NotDelegate();
}
[DefaultMemberAttribute("Item")]
internal class Autofac.Util.FallbackDictionary`2 : object {
    private IDictionary`2<TKey, TValue> _localValues;
    [CompilerGeneratedAttribute]
private IDictionary`2<TKey, TValue> <Parent>k__BackingField;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public IDictionary`2<TKey, TValue> Parent { get; private set; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public FallbackDictionary`2(IDictionary`2<TKey, TValue> parent);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    [CompilerGeneratedAttribute]
public IDictionary`2<TKey, TValue> get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(IDictionary`2<TKey, TValue> value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    [IteratorStateMachineAttribute("Autofac.Util.FallbackDictionary`2/<GetEnumerator>d__24")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IEnumerable`1<TKey> OrderedKeys();
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class Autofac.Util.FallbackDictionaryResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string DuplicateItem { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_DuplicateItem();
}
[ExtensionAttribute]
internal static class Autofac.Util.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool TryGetDeclaringProperty(ParameterInfo pi, PropertyInfo& prop);
    public static PropertyInfo GetProperty(Expression`1<Func`2<TDeclaring, TProperty>> propertyAccessor);
    public static MethodInfo GetMethod(Expression`1<Action`1<TDeclaring>> methodCallExpression);
    public static ConstructorInfo GetConstructor(Expression`1<Func`1<TDeclaring>> constructorCallExpression);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Autofac.Util.ReflectionExtensionsResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExpressionNotConstructorCall { get; }
    internal static string ExpressionNotMethodCall { get; }
    internal static string ExpressionNotPropertyAccessor { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExpressionNotConstructorCall();
    internal static string get_ExpressionNotMethodCall();
    internal static string get_ExpressionNotPropertyAccessor();
}
internal class Autofac.Util.ReleaseAction`1 : Disposable {
    private Action`1<TLimit> _action;
    private Func`1<TLimit> _factory;
    public ReleaseAction`1(Action`1<TLimit> action, Func`1<TLimit> factory);
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class Autofac.Util.SequenceExtensions : object {
    [ExtensionAttribute]
public static string JoinWith(IEnumerable`1<string> elements, string separator);
    [IteratorStateMachineAttribute("Autofac.Util.SequenceExtensions/<Append>d__1`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Append(IEnumerable`1<T> sequence, T trailingItem);
    [IteratorStateMachineAttribute("Autofac.Util.SequenceExtensions/<Prepend>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Prepend(IEnumerable`1<T> sequence, T leadingItem);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
internal static class Autofac.Util.SequenceGenerator : object {
    private static long _lastSequence;
    internal static long GetNextUniqueSequence();
}
internal static class Autofac.Util.Traverse : object {
    [IteratorStateMachineAttribute("Autofac.Util.Traverse/<Across>d__0`1")]
public static IEnumerable`1<T> Across(T first, Func`2<T, T> next);
}
[ExtensionAttribute]
internal static class Autofac.Util.TypeExtensions : object {
    private static ConcurrentDictionary`2<Type, bool> IsGenericEnumerableInterfaceCache;
    private static ConcurrentDictionary`2<Type, bool> IsGenericListOrCollectionInterfaceTypeCache;
    private static ConcurrentDictionary`2<Tuple`2<Type, Type>, bool> IsGenericTypeDefinedByCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static Type FunctionReturnType(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetTypesThatClose(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsClosedTypeOf(Type this, Type openGeneric);
    [ExtensionAttribute]
public static bool IsCompatibleWithGenericParameterConstraints(Type genericTypeDefinition, Type[] parameters);
    [ExtensionAttribute]
public static bool IsCompilerGenerated(Type type);
    [ExtensionAttribute]
public static bool IsDelegate(Type type);
    [ExtensionAttribute]
public static bool IsGenericEnumerableInterfaceType(Type type);
    [ExtensionAttribute]
public static bool IsGenericListOrCollectionInterfaceType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinedBy(Type this, Type openGeneric);
    private static IEnumerable`1<Type> FindAssignableTypesThatClose(Type candidateType, Type openGenericServiceType);
    private static Type SubstituteGenericParameterConstraint(Type[] parameters, Type constraint);
    private static bool ParameterCompatibleWithTypeConstraint(Type parameter, Type constraint);
    private static bool ParameterEqualsConstraint(Type parameter, Type constraint);
    private static IEnumerable`1<Type> TypesAssignableFrom(Type candidateType);
}
[AttributeUsageAttribute("2048")]
internal class Autofac.Util.ValidatedNotNullAttribute : Attribute {
}
