public enum Gendarme.Framework.ApplicabilityScope : Enum {
    public int value__;
    public static ApplicabilityScope Visible;
    public static ApplicabilityScope NonVisible;
    public static ApplicabilityScope All;
}
public class Gendarme.Framework.AssemblyResolver : BaseAssemblyResolver {
    private Dictionary`2<string, AssemblyDefinition> assemblies;
    private static AssemblyResolver resolver;
    public IDictionary`2<string, AssemblyDefinition> AssemblyCache { get; }
    public static AssemblyResolver Resolver { get; }
    public IDictionary`2<string, AssemblyDefinition> get_AssemblyCache();
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public void CacheAssembly(AssemblyDefinition assembly);
    public static AssemblyResolver get_Resolver();
}
public class Gendarme.Framework.BasicIgnoreList : object {
    private Dictionary`2<string, HashSet`1<IMetadataTokenProvider>> ignore;
    [CompilerGeneratedAttribute]
private IRunner <Runner>k__BackingField;
    public IRunner Runner { get; private set; }
    public BasicIgnoreList(IRunner runner);
    [CompilerGeneratedAttribute]
public sealed virtual IRunner get_Runner();
    [CompilerGeneratedAttribute]
private void set_Runner(IRunner value);
    public sealed virtual void Add(string rule, IMetadataTokenProvider metadata);
    public sealed virtual bool IsIgnored(IRule rule, IMetadataTokenProvider metadata);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, IMetadataTokenProvider metadata);
    private static bool IsIgnoredUsingCasts(ICollection`1<IMetadataTokenProvider> list, IMetadataTokenProvider metadata);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, ModuleDefinition module);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, TypeReference type);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, EventDefinition evnt);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, FieldDefinition field);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, PropertyDefinition property);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, MemberReference member);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, ParameterDefinition parameter);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, GenericParameter parameter);
    private static bool IsIgnored(ICollection`1<IMetadataTokenProvider> list, MethodReturnType returnType);
}
public class Gendarme.Framework.Bitmask`1 : object {
    private ulong mask;
    public Bitmask`1(bool initialValues);
    public void Clear(T bit);
    public void ClearAll();
    public int Count();
    public bool Get(T bit);
    public void Set(T bit);
    public void SetAll();
    private void SetRange(int start, int end);
    public void SetDown(T bit);
    public void SetUp(T bit);
    public bool Intersect(Bitmask`1<T> bitmask);
    public bool IsSubsetOf(Bitmask`1<T> bitmask);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Bitmask`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum Gendarme.Framework.Confidence : Enum {
    public int value__;
    public static Confidence Total;
    public static Confidence High;
    public static Confidence Normal;
    public static Confidence Low;
}
public class Gendarme.Framework.Defect : object {
    private string source;
    [CompilerGeneratedAttribute]
private Confidence <Confidence>k__BackingField;
    [CompilerGeneratedAttribute]
private Instruction <Instruction>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTokenProvider <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private IRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private Severity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private IMetadataTokenProvider <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public AssemblyDefinition Assembly { get; }
    public Confidence Confidence { get; private set; }
    public Instruction Instruction { get; private set; }
    public IMetadataTokenProvider Location { get; private set; }
    public IRule Rule { get; private set; }
    public Severity Severity { get; private set; }
    public string Source { get; }
    public IMetadataTokenProvider Target { get; private set; }
    public string Text { get; private set; }
    public Defect(IRule rule, IMetadataTokenProvider target, IMetadataTokenProvider location, Severity severity, Confidence confidence, string text);
    public Defect(IRule rule, IMetadataTokenProvider target, IMetadataTokenProvider location, Severity severity, Confidence confidence);
    public Defect(IRule rule, IMetadataTokenProvider target, MethodDefinition location, Instruction ins, Severity severity, Confidence confidence, string text);
    public Defect(IRule rule, IMetadataTokenProvider target, MethodDefinition location, Instruction ins, Severity severity, Confidence confidence);
    public AssemblyDefinition get_Assembly();
    [CompilerGeneratedAttribute]
public Confidence get_Confidence();
    [CompilerGeneratedAttribute]
private void set_Confidence(Confidence value);
    [CompilerGeneratedAttribute]
public Instruction get_Instruction();
    [CompilerGeneratedAttribute]
private void set_Instruction(Instruction value);
    [CompilerGeneratedAttribute]
public IMetadataTokenProvider get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(IMetadataTokenProvider value);
    [CompilerGeneratedAttribute]
public IRule get_Rule();
    [CompilerGeneratedAttribute]
private void set_Rule(IRule value);
    [CompilerGeneratedAttribute]
public Severity get_Severity();
    [CompilerGeneratedAttribute]
private void set_Severity(Severity value);
    public string get_Source();
    [CompilerGeneratedAttribute]
public IMetadataTokenProvider get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(IMetadataTokenProvider value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
}
[AttributeUsageAttribute("4")]
public class Gendarme.Framework.DocumentationUriAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Uri <DocumentationUri>k__BackingField;
    public Uri DocumentationUri { get; private set; }
    public DocumentationUriAttribute(string documentationUri);
    [CompilerGeneratedAttribute]
public Uri get_DocumentationUri();
    [CompilerGeneratedAttribute]
private void set_DocumentationUri(Uri value);
}
public abstract class Gendarme.Framework.Engine : object {
    [CompilerGeneratedAttribute]
private EngineController <Controller>k__BackingField;
    protected EngineController Controller { get; private set; }
    [CompilerGeneratedAttribute]
protected EngineController get_Controller();
    [CompilerGeneratedAttribute]
private void set_Controller(EngineController value);
    public virtual void Initialize(EngineController controller);
    public virtual void TearDown();
}
[DefaultMemberAttribute("Item")]
public class Gendarme.Framework.EngineController : object {
    private Dictionary`2<string, Engine> engines;
    private EventHandler`1<EngineEventArgs> BuildingCustomAttributes;
    private EventHandler`1<EngineEventArgs> BuildingMethodBody;
    private EventHandler`1<EngineEventArgs> BuildingType;
    private EventHandler`1<EngineEventArgs> BuildingModule;
    private EventHandler`1<EngineEventArgs> BuildingAssembly;
    [CompilerGeneratedAttribute]
private IRunner <Runner>k__BackingField;
    public IRunner Runner { get; private set; }
    public Engine Item { get; }
    public OpCodeEngine OpCode { get; }
    public EngineController(IRunner runner);
    [CompilerGeneratedAttribute]
public IRunner get_Runner();
    [CompilerGeneratedAttribute]
private void set_Runner(IRunner value);
    public void Subscribe(string engineName);
    public void Unsubscribe(string engineName);
    public void add_BuildingCustomAttributes(EventHandler`1<EngineEventArgs> value);
    public void remove_BuildingCustomAttributes(EventHandler`1<EngineEventArgs> value);
    public void add_BuildingMethodBody(EventHandler`1<EngineEventArgs> value);
    public void remove_BuildingMethodBody(EventHandler`1<EngineEventArgs> value);
    public void add_BuildingType(EventHandler`1<EngineEventArgs> value);
    public void remove_BuildingType(EventHandler`1<EngineEventArgs> value);
    public void add_BuildingModule(EventHandler`1<EngineEventArgs> value);
    public void remove_BuildingModule(EventHandler`1<EngineEventArgs> value);
    public void add_BuildingAssembly(EventHandler`1<EngineEventArgs> value);
    public void remove_BuildingAssembly(EventHandler`1<EngineEventArgs> value);
    public void Build(IList`1<AssemblyDefinition> list);
    private void BuildCustomAttributes(ICustomAttributeProvider custom, EngineEventArgs e);
    private void Build(MethodDefinition method, EngineEventArgs e);
    private void Build(TypeDefinition type, EngineEventArgs e);
    private void Build(ModuleDefinition module, EngineEventArgs e);
    private void Build(AssemblyDefinition assembly, EngineEventArgs e);
    public void TearDown();
    public Engine get_Item(string name);
    public OpCodeEngine get_OpCode();
}
[AttributeUsageAttribute("4")]
public class Gendarme.Framework.EngineDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <EngineType>k__BackingField;
    public string EngineType { get; internal set; }
    public EngineDependencyAttribute(Type engineType);
    public EngineDependencyAttribute(string engineType);
    [CompilerGeneratedAttribute]
public string get_EngineType();
    [CompilerGeneratedAttribute]
internal void set_EngineType(string value);
}
public class Gendarme.Framework.EngineEventArgs : HierarchicalEventArgs {
    [CompilerGeneratedAttribute]
private EngineController <Controller>k__BackingField;
    public EngineController Controller { get; private set; }
    public EngineEventArgs(EngineController controller);
    [CompilerGeneratedAttribute]
public EngineController get_Controller();
    [CompilerGeneratedAttribute]
private void set_Controller(EngineController value);
}
public class Gendarme.Framework.Engines.NamespaceEngine : Engine {
    private static Dictionary`2<AssemblyDefinition, HashSet`1<string>> assemblies;
    private static Dictionary`2<string, HashSet`1<TypeDefinition>> namespaces;
    private static NamespaceEngine();
    public virtual void Initialize(EngineController controller);
    private void OnType(object sender, EngineEventArgs e);
    public static IEnumerable`1<string> AllNamespaces();
    public static bool Exists(string nameSpace);
    public static IEnumerable`1<string> NamespacesInside(AssemblyDefinition assembly);
    public static IEnumerable`1<TypeDefinition> TypesInside(string nameSpace);
}
public class Gendarme.Framework.Engines.OpCodeEngine : Engine {
    private static Dictionary`2<MethodDefinition, OpCodeBitmask> bitmasks;
    private static OpCodeEngine();
    public virtual void Initialize(EngineController controller);
    private void OnMethodBody(object sender, EngineEventArgs e);
    public static OpCodeBitmask GetBitmask(MethodDefinition method);
}
public class Gendarme.Framework.Engines.SuppressMessageEngine : Engine {
    private static string SuppressMessage;
    private static Type fxCopCompatibility;
    private Dictionary`2<string, HashSet`1<string>> mapper;
    private Dictionary`2<string, HashSet`1<string>> targets;
    [CompilerGeneratedAttribute]
private static Func`2<TypeReference, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    private static SuppressMessageEngine();
    public virtual void Initialize(EngineController controller);
    private void OnAssembly(object sender, EngineEventArgs e);
    private static string GetPropertyString(ICustomAttribute attribute, string name);
    private void OnCustomAttributes(object sender, EngineEventArgs e);
    private void AddIgnore(IMetadataTokenProvider token, IEnumerable`1<string> mapped_names);
    private void AddTargets(string target, IEnumerable`1<string> mapped_names);
    private void ResolveTargets();
    private void ResolveMethod(MemberReference method);
    private void Add(IMetadataTokenProvider metadata, IEnumerable`1<string> rules);
    [CompilerGeneratedAttribute]
private static bool <OnAssembly>b__0(TypeReference tr);
}
[AttributeUsageAttribute("4")]
public class Gendarme.Framework.FxCopCompatibilityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    public string Category { get; internal set; }
    public string CheckId { get; internal set; }
    public FxCopCompatibilityAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
internal void set_Category(string value);
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
internal void set_CheckId(string value);
}
public static class Gendarme.Framework.Helpers.Log : object {
    private static Dictionary`2<string, bool> enabled;
    private static Log();
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(T category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(T category, string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(T category, MemberReference member);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string category, string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string category, MemberReference member);
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
    public static bool IsEnabled(string category);
}
public class Gendarme.Framework.Helpers.MethodPrinter : object {
    private IList`1<Instruction> instructions;
    private MethodDefinition method;
    private IDictionary branchTable;
    public MethodPrinter(MethodDefinition m);
    public virtual string ToString();
    public static Int32[] BranchTargets(Instruction instruction);
    public bool IsLeader(Instruction instruction, Instruction previous);
    public ExceptionHandler StartsHandlerRegion(Instruction instruction);
    public ExceptionHandler EndsTryRegion(Instruction instruction);
    public ExceptionHandler EndsHandlerRegion(Instruction instruction);
    private static bool IsBranch(Instruction instruction);
    private static bool OffsetsEqual(Instruction insn1, Instruction insn2);
    private ExceptionHandler StartsTryRegion(Instruction instruction);
    private void InitBranchTable();
}
public class Gendarme.Framework.Helpers.MethodSignature : object {
    private Func`2<MethodReference, bool> extra_match_logic;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Parameters>k__BackingField;
    public string Name { get; private set; }
    public string ReturnType { get; private set; }
    public ReadOnlyCollection`1<string> Parameters { get; private set; }
    public MethodSignature(string name);
    public MethodSignature(string name, Func`2<MethodReference, bool> extraMatchingLogic);
    public MethodSignature(string name, string returnType);
    public MethodSignature(string name, string returnType, Func`2<MethodReference, bool> extraMatchingLogic);
    public MethodSignature(string name, string returnType, String[] parameters);
    public MethodSignature(string name, string returnType, String[] parameters, Func`2<MethodReference, bool> extraMatchingLogic);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(ReadOnlyCollection`1<string> value);
    public bool Matches(MethodReference method);
    public virtual string ToString();
}
public static class Gendarme.Framework.Helpers.MethodSignatures : object {
    private static String[] NoParameter;
    public static MethodSignature Equals;
    public static MethodSignature Finalize;
    public static MethodSignature GetHashCode;
    public static MethodSignature ToString;
    public static MethodSignature Clone;
    public static MethodSignature Dispose;
    public static MethodSignature DisposeExplicit;
    private static String[] SerializationParameters;
    public static MethodSignature SerializationConstructor;
    public static MethodSignature GetObjectData;
    public static MethodSignature SerializationEventHandler;
    public static MethodSignature op_UnaryPlus;
    public static MethodSignature op_UnaryNegation;
    public static MethodSignature op_LogicalNot;
    public static MethodSignature op_OnesComplement;
    public static MethodSignature op_Increment;
    public static MethodSignature op_Decrement;
    public static MethodSignature op_True;
    public static MethodSignature op_False;
    public static MethodSignature op_Addition;
    public static MethodSignature op_Subtraction;
    public static MethodSignature op_Multiply;
    public static MethodSignature op_Division;
    public static MethodSignature op_Modulus;
    public static MethodSignature op_BitwiseAnd;
    public static MethodSignature op_BitwiseOr;
    public static MethodSignature op_ExclusiveOr;
    public static MethodSignature op_LeftShift;
    public static MethodSignature op_RightShift;
    public static MethodSignature op_Equality;
    public static MethodSignature op_Inequality;
    public static MethodSignature op_GreaterThan;
    public static MethodSignature op_LessThan;
    public static MethodSignature op_GreaterThanOrEqual;
    public static MethodSignature op_LessThanOrEqual;
    public static MethodSignature Invoke;
    public static MethodSignature TryParse;
    public static MethodSignature Parse;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate1f;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate20;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate21;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate22;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate23;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate24;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate25;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate26;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate27;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate28;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate29;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate2a;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate2b;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate2c;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate2d;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate2e;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate2f;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate30;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate31;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate32;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate33;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate34;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate35;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate36;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate37;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate38;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate39;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate3a;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate3b;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate3c;
    [CompilerGeneratedAttribute]
private static Func`2<MethodReference, bool> CS$<>9__CachedAnonymousMethodDelegate3d;
    private static MethodSignatures();
    private static bool CheckAttributes(MethodReference method, MethodAttributes attrs);
    private static bool IsOperator(MethodReference method, int parameters);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__0(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__2(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__3(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__4(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__5(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__6(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__7(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__8(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__9(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__a(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__b(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__c(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__d(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__e(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__f(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__10(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__11(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__12(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__13(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__14(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__15(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__16(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__17(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__18(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__19(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1a(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1b(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1c(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1d(MethodReference method);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__1e(MethodReference method);
}
public class Gendarme.Framework.Helpers.NamespaceDefinition : object {
    internal static TokenType NamespaceTokenType;
    private string ns;
    private static String[] Specializations;
    private static Dictionary`2<string, NamespaceDefinition> cache;
    [CompilerGeneratedAttribute]
private MetadataToken <MetadataToken>k__BackingField;
    public string Name { get; }
    public MetadataToken MetadataToken { get; public set; }
    private NamespaceDefinition(string name);
    private static NamespaceDefinition();
    public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual MetadataToken get_MetadataToken();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
    public static bool IsSpecialized(string name);
    public static NamespaceDefinition GetDefinition(string name);
}
public class Gendarme.Framework.Helpers.OpCodeBitmask : object {
    private UInt64[] mask;
    private static OpCodeBitmask all;
    private static OpCodeBitmask calls;
    private static OpCodeBitmask conversion;
    private static OpCodeBitmask load_argument;
    private static OpCodeBitmask load_element;
    private static OpCodeBitmask load_indirect;
    private static OpCodeBitmask load_local;
    private static OpCodeBitmask store_argument;
    private static OpCodeBitmask store_local;
    private static OpCodeBitmask flow_control_branch;
    private static OpCodeBitmask flow_control_return;
    public static OpCodeBitmask All { get; }
    public static OpCodeBitmask Calls { get; }
    public static OpCodeBitmask Conversion { get; }
    public static OpCodeBitmask LoadArgument { get; }
    public static OpCodeBitmask LoadElement { get; }
    public static OpCodeBitmask LoadIndirect { get; }
    public static OpCodeBitmask LoadLocal { get; }
    public static OpCodeBitmask StoreArgument { get; }
    public static OpCodeBitmask StoreLocal { get; }
    public static OpCodeBitmask FlowControlBranch { get; }
    public static OpCodeBitmask FlowControlReturn { get; }
    public OpCodeBitmask(OpCodeBitmask bitmask);
    public OpCodeBitmask(ulong a, ulong b, ulong c, ulong d);
    public void Clear(Code code);
    public void ClearAll();
    public bool Get(Code code);
    public void Set(Code code);
    public void SetAll();
    public void UnionWith(OpCodeBitmask bitmask);
    public bool Intersect(OpCodeBitmask bitmask);
    public bool IsSubsetOf(OpCodeBitmask bitmask);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCodeBitmask other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static OpCodeBitmask get_All();
    public static OpCodeBitmask get_Calls();
    public static OpCodeBitmask get_Conversion();
    public static OpCodeBitmask get_LoadArgument();
    public static OpCodeBitmask get_LoadElement();
    public static OpCodeBitmask get_LoadIndirect();
    public static OpCodeBitmask get_LoadLocal();
    public static OpCodeBitmask get_StoreArgument();
    public static OpCodeBitmask get_StoreLocal();
    public static OpCodeBitmask get_FlowControlBranch();
    public static OpCodeBitmask get_FlowControlReturn();
}
public static class Gendarme.Framework.Helpers.PrimitiveReferences : object {
    private static TypeReference single_ref;
    private static TypeReference double_ref;
    private static TypeReference GetReference(Type type, IMetadataTokenProvider metadata);
    public static TypeReference GetDouble(IMetadataTokenProvider metadata);
    public static TypeReference GetSingle(IMetadataTokenProvider metadata);
}
public class Gendarme.Framework.Helpers.StackEntryAnalysis : object {
    private static List`1<KeyValuePair`2<InstructionWithLeave, int>> UsedBy;
    private static List`1<KeyValuePair`2<InstructionWithLeave, int>> AlternativePaths;
    private static List`1<InstructionWithLeave> LoadAlternatives;
    private static List`1<InstructionWithLeave> LoadResults;
    [CompilerGeneratedAttribute]
private MethodDefinition <Method>k__BackingField;
    public MethodDefinition Method { get; private set; }
    private MethodBody Body { get; }
    public StackEntryAnalysis(MethodDefinition method);
    private static StackEntryAnalysis();
    [CompilerGeneratedAttribute]
public MethodDefinition get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodDefinition value);
    private MethodBody get_Body();
    public StackEntryUsageResult[] GetStackEntryUsage(Instruction ins);
    private void CheckUsedBy(int start);
    private KeyValuePair`2<InstructionWithLeave, int> FollowStackEntry(InstructionWithLeave startInstruction, int stackEntryDistance);
    private List`1<InstructionWithLeave> FindLoad(InstructionWithLeave insWithLeave, StoreSlot slot);
    public static Instruction GetNextInstruction(Instruction ins, Object& alternative);
    private StoreSlot GetLoadSlot(Instruction ins);
    private StoreSlot GetStoreSlot(Instruction ins);
}
public class Gendarme.Framework.Helpers.StackEntryUsageResult : ValueType {
    public Instruction Instruction;
    public int StackOffset;
    public StackEntryUsageResult(Instruction ins, int offset);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StackEntryUsageResult other);
    public virtual int GetHashCode();
    public static bool op_Equality(StackEntryUsageResult left, StackEntryUsageResult right);
    public static bool op_Inequality(StackEntryUsageResult left, StackEntryUsageResult right);
}
public class Gendarme.Framework.Helpers.StreamLineReader : object {
    private StreamReader sr;
    private Char[] buff;
    private int n;
    private int max;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    public bool EndOfStream { get; }
    protected bool Disposed { get; private set; }
    public StreamLineReader(string fileName);
    public StreamLineReader(Stream stream);
    private void Initialize();
    public bool get_EndOfStream();
    public int ReadLine(Char[] buffer, int index, int count);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
protected bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
}
public abstract class Gendarme.Framework.HierarchicalEventArgs : EventArgs {
    private AssemblyDefinition assembly;
    private ModuleDefinition module;
    private TypeDefinition type;
    private MethodDefinition method;
    public AssemblyDefinition CurrentAssembly { get; public set; }
    public ModuleDefinition CurrentModule { get; public set; }
    public TypeDefinition CurrentType { get; public set; }
    public MethodDefinition CurrentMethod { get; public set; }
    public AssemblyDefinition get_CurrentAssembly();
    public void set_CurrentAssembly(AssemblyDefinition value);
    public ModuleDefinition get_CurrentModule();
    public void set_CurrentModule(ModuleDefinition value);
    public TypeDefinition get_CurrentType();
    public void set_CurrentType(TypeDefinition value);
    public MethodDefinition get_CurrentMethod();
    public void set_CurrentMethod(MethodDefinition value);
}
public interface Gendarme.Framework.IAssemblyRule {
    public abstract virtual RuleResult CheckAssembly(AssemblyDefinition assembly);
}
public interface Gendarme.Framework.IIgnoreList {
    public IRunner Runner { get; }
    public abstract virtual IRunner get_Runner();
    public abstract virtual void Add(string rule, IMetadataTokenProvider metadata);
    public abstract virtual bool IsIgnored(IRule rule, IMetadataTokenProvider metadata);
}
public interface Gendarme.Framework.IMethodRule {
    public abstract virtual RuleResult CheckMethod(MethodDefinition method);
}
public interface Gendarme.Framework.IRule {
    public bool Active { get; public set; }
    public IRunner Runner { get; }
    public string Name { get; }
    public string FullName { get; }
    public Uri Uri { get; }
    public string Problem { get; }
    public string Solution { get; }
    public ApplicabilityScope ApplicabilityScope { get; public set; }
    public abstract virtual bool get_Active();
    public abstract virtual void set_Active(bool value);
    public abstract virtual IRunner get_Runner();
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
    public abstract virtual Uri get_Uri();
    public abstract virtual string get_Problem();
    public abstract virtual string get_Solution();
    public abstract virtual void Initialize(IRunner runner);
    public abstract virtual void TearDown();
    public abstract virtual ApplicabilityScope get_ApplicabilityScope();
    public abstract virtual void set_ApplicabilityScope(ApplicabilityScope value);
}
[ComVisibleAttribute("False")]
public interface Gendarme.Framework.IRunner {
    public Collection`1<IRule> Rules { get; }
    public Collection`1<AssemblyDefinition> Assemblies { get; }
    public IIgnoreList IgnoreList { get; public set; }
    public Collection`1<Defect> Defects { get; }
    public int DefectsLimit { get; }
    public Bitmask`1<Severity> SeverityBitmask { get; }
    public Bitmask`1<Confidence> ConfidenceBitmask { get; }
    public int VerbosityLevel { get; }
    public EngineController Engines { get; }
    public RuleResult CurrentRuleResult { get; }
    public abstract virtual Collection`1<IRule> get_Rules();
    public abstract virtual Collection`1<AssemblyDefinition> get_Assemblies();
    public abstract virtual IIgnoreList get_IgnoreList();
    public abstract virtual void set_IgnoreList(IIgnoreList value);
    public abstract virtual Collection`1<Defect> get_Defects();
    public abstract virtual int get_DefectsLimit();
    public abstract virtual Bitmask`1<Severity> get_SeverityBitmask();
    public abstract virtual Bitmask`1<Confidence> get_ConfidenceBitmask();
    public abstract virtual int get_VerbosityLevel();
    public abstract virtual EngineController get_Engines();
    public abstract virtual RuleResult get_CurrentRuleResult();
    public abstract virtual void add_AnalyzeAssembly(EventHandler`1<RunnerEventArgs> value);
    public abstract virtual void remove_AnalyzeAssembly(EventHandler`1<RunnerEventArgs> value);
    public abstract virtual void add_AnalyzeModule(EventHandler`1<RunnerEventArgs> value);
    public abstract virtual void remove_AnalyzeModule(EventHandler`1<RunnerEventArgs> value);
    public abstract virtual void add_AnalyzeType(EventHandler`1<RunnerEventArgs> value);
    public abstract virtual void remove_AnalyzeType(EventHandler`1<RunnerEventArgs> value);
    public abstract virtual void add_AnalyzeMethod(EventHandler`1<RunnerEventArgs> value);
    public abstract virtual void remove_AnalyzeMethod(EventHandler`1<RunnerEventArgs> value);
    public abstract virtual void Initialize();
    public abstract virtual void Report(Defect defect);
    public abstract virtual void Report(IMetadataTokenProvider metadata, Severity severity, Confidence confidence);
    public abstract virtual void Report(IMetadataTokenProvider metadata, Severity severity, Confidence confidence, string message);
    public abstract virtual void Report(MethodDefinition method, Instruction ins, Severity severity, Confidence confidence);
    public abstract virtual void Report(MethodDefinition method, Instruction ins, Severity severity, Confidence confidence, string message);
    public abstract virtual void TearDown();
}
public interface Gendarme.Framework.ITypeRule {
    public abstract virtual RuleResult CheckType(TypeDefinition type);
}
[AttributeUsageAttribute("4")]
public class Gendarme.Framework.ProblemAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Problem>k__BackingField;
    public string Problem { get; private set; }
    public ProblemAttribute(string problem);
    [CompilerGeneratedAttribute]
public string get_Problem();
    [CompilerGeneratedAttribute]
private void set_Problem(string value);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.AssemblyRocks : object {
    [ExtensionAttribute]
public static bool References(AssemblyDefinition self, string assemblyName);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.CollectionRocks : object {
    [ExtensionAttribute]
public static void AddIfNew(ICollection`1<T> self, T item);
    [ExtensionAttribute]
public static void AddRangeIfNew(ICollection`1<T> self, IEnumerable`1<T> items);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.CustomAttributeRocks : object {
    [ExtensionAttribute]
internal static bool HasAnyGeneratedCodeAttribute(ICustomAttributeProvider self);
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider self, string nameSpace, string name);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.FieldRocks : object {
    [ExtensionAttribute]
public static bool IsGeneratedCode(FieldReference self);
    [ExtensionAttribute]
public static bool IsVisible(FieldReference self);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.InstructionRocks : object {
    [ExtensionAttribute]
public static FieldDefinition GetField(Instruction self);
    [ExtensionAttribute]
public static MethodReference GetMethod(Instruction self);
    [ExtensionAttribute]
public static object GetOperand(Instruction self, MethodDefinition method);
    [ExtensionAttribute]
public static TypeReference GetOperandType(Instruction self, MethodDefinition method);
    [ExtensionAttribute]
public static ParameterDefinition GetParameter(Instruction self, MethodDefinition method);
    [ExtensionAttribute]
public static int GetPopCount(Instruction self, IMethodSignature method);
    [ExtensionAttribute]
public static int GetPushCount(Instruction self);
    [ExtensionAttribute]
public static VariableDefinition GetVariable(Instruction self, MethodDefinition method);
    [ExtensionAttribute]
public static bool Is(Instruction self, Code code);
    [ExtensionAttribute]
public static bool IsLoadArgument(Instruction self);
    [ExtensionAttribute]
public static bool IsLoadElement(Instruction self);
    [ExtensionAttribute]
public static bool IsLoadIndirect(Instruction self);
    [ExtensionAttribute]
public static bool IsLoadLocal(Instruction self);
    [ExtensionAttribute]
public static bool IsOperandZero(Instruction self);
    [ExtensionAttribute]
public static bool IsStoreArgument(Instruction self);
    [ExtensionAttribute]
public static bool IsStoreLocal(Instruction self);
    [ExtensionAttribute]
public static Instruction TraceBack(Instruction self, IMethodSignature method);
    [ExtensionAttribute]
public static Instruction TraceBack(Instruction self, IMethodSignature method, int offset);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.MetadataTokenProviderRock : object {
    private static Dictionary`2<MemberReference, string> full_name_cache;
    private static MetadataTokenProviderRock();
    [ExtensionAttribute]
public static AssemblyDefinition GetAssembly(IMetadataTokenProvider self);
    private static AssemblyDefinition GetAssemblyUsingCasts(IMetadataTokenProvider metadata);
    private static AssemblyDefinition GetAssembly(MemberReference method);
    [ExtensionAttribute]
public static bool Equals(IMetadataTokenProvider self, IMetadataTokenProvider other);
    [ExtensionAttribute]
public static string GetFullName(MemberReference self);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.MethodRocks : object {
    [ExtensionAttribute]
public static bool IsNamed(MemberReference self, string nameSpace, string typeName, string methodName);
    [ExtensionAttribute]
public static bool IsEntryPoint(MethodReference self);
    [ExtensionAttribute]
public static bool IsFinalizer(MethodReference self);
    [ExtensionAttribute]
public static bool IsGeneratedCode(MethodReference self);
    [ExtensionAttribute]
public static bool IsMain(MethodReference self);
    [ExtensionAttribute]
public static bool IsOverride(MethodReference self);
    [ExtensionAttribute]
public static bool IsProperty(MethodReference self);
    [ExtensionAttribute]
public static bool IsVisible(MethodReference self);
    [ExtensionAttribute]
public static bool IsEventCallback(MethodReference self);
    [ExtensionAttribute]
public static PropertyDefinition GetPropertyByAccessor(MethodReference self);
    private static bool AreSameElementTypes(TypeReference a, TypeReference b);
    [ExtensionAttribute]
public static bool CompareSignature(IMethodSignature self, IMethodSignature signature);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.ModuleRocks : object {
    private static bool running_on_mono;
    private static TypeDefinition[] Empty;
    private static Dictionary`2<ModuleDefinition, IEnumerable`1<MemberReference>> member_ref_cache;
    private static Dictionary`2<ModuleDefinition, IEnumerable`1<TypeReference>> type_ref_cache;
    [CompilerGeneratedAttribute]
private static Func`2<TypeDefinition, IEnumerable`1<TypeDefinition>> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<TypeDefinition, IEnumerable`1<TypeDefinition>> CS$<>9__CachedAnonymousMethodDelegate3;
    private static bool RunningOnMono { get; }
    private static ModuleRocks();
    private static bool get_RunningOnMono();
    [ExtensionAttribute]
public static void LoadDebuggingSymbols(ModuleDefinition self);
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinition> GetAllTypes(ModuleDefinition self);
    [ExtensionAttribute]
private static IEnumerable`1<TypeDefinition> GetAllTypes(TypeDefinition self);
    [ExtensionAttribute]
public static bool AnyMemberReference(ModuleDefinition self, Func`2<MemberReference, bool> predicate);
    [ExtensionAttribute]
public static bool AnyTypeReference(ModuleDefinition self, Func`2<TypeReference, bool> predicate);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<TypeDefinition> <GetAllTypes>b__0(TypeDefinition t);
    [CompilerGeneratedAttribute]
private static IEnumerable`1<TypeDefinition> <GetAllTypes>b__2(TypeDefinition t);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.ParameterRocks : object {
    [ExtensionAttribute]
public static bool IsParams(ParameterDefinition self);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.PropertyRocks : object {
    [ExtensionAttribute]
public static bool IsGeneratedCode(PropertyDefinition self);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.SystemRocks : object {
    [ExtensionAttribute]
public static bool IsEmpty(Version self);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.TypeRocks : object {
    [ExtensionAttribute]
public static IEnumerable`1<TypeDefinition> AllSuperTypes(TypeReference self);
    [ExtensionAttribute]
public static MethodDefinition GetMethod(TypeReference self, MethodSignature signature);
    [ExtensionAttribute]
public static MethodDefinition GetMethod(TypeReference self, MethodAttributes attributes, string name, string returnType, String[] parameters, Func`2<MethodDefinition, bool> customCondition);
    [ExtensionAttribute]
public static MethodDefinition GetMethod(TypeReference self, MethodAttributes attributes, string name, string returnType, String[] parameters);
    [ExtensionAttribute]
public static MethodDefinition GetMethod(TypeReference self, MethodAttributes attributes, string name);
    [ExtensionAttribute]
public static MethodDefinition GetMethod(TypeReference self, string name, string returnType, String[] parameters);
    [ExtensionAttribute]
public static MethodDefinition GetMethod(TypeReference self, string name);
    [ExtensionAttribute]
public static MethodDefinition GetMethod(TypeReference self, Func`2<MethodDefinition, bool> customCondition);
    [ExtensionAttribute]
public static bool HasMethod(TypeReference self, MethodSignature signature);
    [ExtensionAttribute]
public static bool Implements(TypeReference self, string nameSpace, string name);
    private static bool Implements(TypeDefinition type, string nameSpace, string iname);
    private static bool Match(TypeReference type, string nameSpace, string name);
    [ExtensionAttribute]
public static bool Inherits(TypeReference self, string nameSpace, string name);
    [ExtensionAttribute]
public static bool IsNamed(TypeReference self, string nameSpace, string name);
    [ExtensionAttribute]
public static bool IsNamed(TypeReference self, string fullName);
    [ExtensionAttribute]
public static bool IsAttribute(TypeReference self);
    [ExtensionAttribute]
public static bool IsDelegate(TypeReference self);
    [ExtensionAttribute]
public static bool IsFlags(TypeReference self);
    [ExtensionAttribute]
public static bool IsFloatingPoint(TypeReference self);
    [ExtensionAttribute]
public static bool IsGeneratedCode(TypeReference self);
    [ExtensionAttribute]
public static bool IsNative(TypeReference self);
    [ExtensionAttribute]
public static bool IsStatic(TypeReference self);
    [ExtensionAttribute]
public static bool IsVisible(TypeReference self);
}
[ExtensionAttribute]
public static class Gendarme.Framework.Rocks.VariableDefinitionRocks : object {
    [ExtensionAttribute]
public static bool IsGeneratedName(VariableReference self);
    [ExtensionAttribute]
public static string GetName(VariableReference self);
}
public abstract class Gendarme.Framework.Rule : object {
    private bool active;
    private string name;
    private string full_name;
    private string problem;
    private string solution;
    private Uri uri;
    private Type type;
    private ApplicabilityScope applicability_scope;
    private Object[] engine_dependencies;
    [CompilerGeneratedAttribute]
private IRunner <Runner>k__BackingField;
    public bool Active { get; public set; }
    public IRunner Runner { get; private set; }
    public string Name { get; }
    public string FullName { get; }
    private Type Type { get; }
    public string Problem { get; }
    public string Solution { get; }
    public Uri Uri { get; }
    public ApplicabilityScope ApplicabilityScope { get; public set; }
    public virtual bool get_Active();
    public virtual void set_Active(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IRunner get_Runner();
    [CompilerGeneratedAttribute]
private void set_Runner(IRunner value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private Type get_Type();
    private object GetCustomAttribute(Type t);
    public virtual string get_Problem();
    public virtual string get_Solution();
    public virtual Uri get_Uri();
    public virtual void Initialize(IRunner runner);
    public virtual void TearDown();
    public sealed virtual ApplicabilityScope get_ApplicabilityScope();
    public sealed virtual void set_ApplicabilityScope(ApplicabilityScope value);
}
public enum Gendarme.Framework.RuleResult : Enum {
    public int value__;
    public static RuleResult DoesNotApply;
    public static RuleResult Success;
    public static RuleResult Failure;
    public static RuleResult Abort;
}
public abstract class Gendarme.Framework.Runner : object {
    private Collection`1<Defect> defect_list;
    private int defects_limit;
    private Bitmask`1<Severity> severity_bitmask;
    private Bitmask`1<Confidence> confidence_bitmask;
    private Collection`1<IRule> rules;
    private Collection`1<AssemblyDefinition> assemblies;
    private int verbose_level;
    private IEnumerable`1<IAssemblyRule> assembly_rules;
    private IEnumerable`1<ITypeRule> type_rules;
    private IEnumerable`1<IMethodRule> method_rules;
    private IRule currentRule;
    private IMetadataTokenProvider currentTarget;
    private IIgnoreList ignoreList;
    private int defectCountBeforeCheck;
    private Object[] engine_dependencies;
    private EventHandler`1<RunnerEventArgs> AnalyzeAssembly;
    private EventHandler`1<RunnerEventArgs> AnalyzeModule;
    private EventHandler`1<RunnerEventArgs> AnalyzeType;
    private EventHandler`1<RunnerEventArgs> AnalyzeMethod;
    private EngineController ec;
    protected IRule CurrentRule { get; protected set; }
    protected IMetadataTokenProvider CurrentTarget { get; protected set; }
    public IIgnoreList IgnoreList { get; public set; }
    public Collection`1<IRule> Rules { get; }
    public Collection`1<AssemblyDefinition> Assemblies { get; }
    public Collection`1<Defect> Defects { get; }
    public int DefectsLimit { get; public set; }
    public Bitmask`1<Severity> SeverityBitmask { get; }
    public Bitmask`1<Confidence> ConfidenceBitmask { get; }
    public int VerbosityLevel { get; public set; }
    public EngineController Engines { get; }
    public RuleResult CurrentRuleResult { get; }
    public sealed virtual void add_AnalyzeAssembly(EventHandler`1<RunnerEventArgs> value);
    public sealed virtual void remove_AnalyzeAssembly(EventHandler`1<RunnerEventArgs> value);
    public sealed virtual void add_AnalyzeModule(EventHandler`1<RunnerEventArgs> value);
    public sealed virtual void remove_AnalyzeModule(EventHandler`1<RunnerEventArgs> value);
    public sealed virtual void add_AnalyzeType(EventHandler`1<RunnerEventArgs> value);
    public sealed virtual void remove_AnalyzeType(EventHandler`1<RunnerEventArgs> value);
    public sealed virtual void add_AnalyzeMethod(EventHandler`1<RunnerEventArgs> value);
    public sealed virtual void remove_AnalyzeMethod(EventHandler`1<RunnerEventArgs> value);
    protected IRule get_CurrentRule();
    protected void set_CurrentRule(IRule value);
    protected IMetadataTokenProvider get_CurrentTarget();
    protected void set_CurrentTarget(IMetadataTokenProvider value);
    public sealed virtual IIgnoreList get_IgnoreList();
    public sealed virtual void set_IgnoreList(IIgnoreList value);
    public sealed virtual Collection`1<IRule> get_Rules();
    public sealed virtual Collection`1<AssemblyDefinition> get_Assemblies();
    public sealed virtual Collection`1<Defect> get_Defects();
    public sealed virtual int get_DefectsLimit();
    public void set_DefectsLimit(int value);
    public sealed virtual Bitmask`1<Severity> get_SeverityBitmask();
    public sealed virtual Bitmask`1<Confidence> get_ConfidenceBitmask();
    public sealed virtual int get_VerbosityLevel();
    public void set_VerbosityLevel(int value);
    public sealed virtual EngineController get_Engines();
    public virtual void Initialize();
    private bool Filter(Severity severity, Confidence confidence, IMetadataTokenProvider location);
    public virtual void Report(Defect defect);
    public sealed virtual void Report(IMetadataTokenProvider metadata, Severity severity, Confidence confidence);
    public sealed virtual void Report(IMetadataTokenProvider metadata, Severity severity, Confidence confidence, string message);
    public sealed virtual void Report(MethodDefinition method, Instruction ins, Severity severity, Confidence confidence);
    public sealed virtual void Report(MethodDefinition method, Instruction ins, Severity severity, Confidence confidence, string message);
    public void Reset();
    private void OnEvent(EventHandler`1<RunnerEventArgs> handler, RunnerEventArgs e);
    private static bool VisibilityCheck(ApplicabilityScope scope, bool visible);
    protected virtual void OnAssembly(RunnerEventArgs e);
    protected virtual void OnModule(RunnerEventArgs e);
    protected virtual void OnType(RunnerEventArgs e);
    protected virtual void OnMethod(RunnerEventArgs e);
    public sealed virtual RuleResult get_CurrentRuleResult();
    public virtual void Run();
    public virtual void TearDown();
    public virtual void TearDown(IRule rule);
}
public class Gendarme.Framework.RunnerEventArgs : HierarchicalEventArgs {
    [CompilerGeneratedAttribute]
private IRunner <Runner>k__BackingField;
    public IRunner Runner { get; private set; }
    public RunnerEventArgs(IRunner runner);
    [CompilerGeneratedAttribute]
public IRunner get_Runner();
    [CompilerGeneratedAttribute]
private void set_Runner(IRunner value);
}
public enum Gendarme.Framework.Severity : Enum {
    public int value__;
    public static Severity Critical;
    public static Severity High;
    public static Severity Medium;
    public static Severity Low;
    public static Severity Audit;
}
[AttributeUsageAttribute("4")]
public class Gendarme.Framework.SolutionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Solution>k__BackingField;
    public string Solution { get; private set; }
    public SolutionAttribute(string solution);
    [CompilerGeneratedAttribute]
public string get_Solution();
    [CompilerGeneratedAttribute]
private void set_Solution(string value);
}
public static class Gendarme.Framework.Symbols : object {
    private static int PdbHiddenLine;
    private static string AlmostEqualTo;
    private static Instruction ExtractFirst(TypeDefinition type);
    private static Instruction ExtractFirst(MethodDefinition method);
    private static TypeDefinition FindTypeFromLocation(IMetadataTokenProvider location);
    private static MethodDefinition FindMethodFromLocation(IMetadataTokenProvider location);
    private static string FormatSequencePoint(SequencePoint sp, bool exact);
    private static string FormatSequencePoint(string document, int line, int column, bool exact);
    private static string GetSource(Instruction ins);
    private static string FormatSource(Instruction candidate);
    public static string GetSource(Defect defect);
}
public enum Gendarme.Framework.ThreadModel : Enum {
    public int value__;
    public static ThreadModel MainThread;
    public static ThreadModel SingleThread;
    public static ThreadModel Serializable;
    public static ThreadModel Concurrent;
    public static ThreadModel AllowEveryCaller;
}
[AttributeUsageAttribute("5836")]
public class Gendarme.Framework.ThreadModelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ThreadModel <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowsEveryCaller>k__BackingField;
    public ThreadModel Model { get; public set; }
    public bool AllowsEveryCaller { get; public set; }
    public ThreadModelAttribute(ThreadModel model);
    [CompilerGeneratedAttribute]
public ThreadModel get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(ThreadModel value);
    [CompilerGeneratedAttribute]
public bool get_AllowsEveryCaller();
    [CompilerGeneratedAttribute]
public void set_AllowsEveryCaller(bool value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ThreadModelAttribute other);
    public static bool op_Equality(ThreadModelAttribute lhs, ThreadModelAttribute rhs);
    public static bool op_Inequality(ThreadModelAttribute lhs, ThreadModelAttribute rhs);
    public virtual int GetHashCode();
}
