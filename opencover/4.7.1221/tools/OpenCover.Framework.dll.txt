public class OpenCover.Framework.Bootstrapper : object {
    private ILog _logger;
    private IContainer _container;
    private bool _disposed;
    public Bootstrapper(ILog logger);
    public T Resolve();
    public void Initialise(IFilter filter, ICommandLine commandLine, IPersistance persistance, IPerfCounters perfCounters);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class OpenCover.Framework.CommandLineParser : CommandLineParserBase {
    [CompilerGeneratedAttribute]
private bool <Register>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SafeMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Registration <Registration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipAutoImplementedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetDir>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SearchDirs>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExcludeDirs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoDefaultFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeByHash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowUnvisited>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnTargetCode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReturnCodeOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AttributeExclusionFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <FileExclusionFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <TestFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SkippedMethod> <HideSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TraceByTest>k__BackingField;
    [CompilerGeneratedAttribute]
private Level <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceEnvironment <ServiceEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ServiceStartTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OldStyleInstrumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePerformanceCounters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RegExFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeExistingOutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommunicationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiagMode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SendVisitPointsTimerInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCtrlC>k__BackingField;
    public bool Register { get; private set; }
    public bool SafeMode { get; private set; }
    public Registration Registration { get; private set; }
    public bool SkipAutoImplementedProperties { get; private set; }
    public string Target { get; private set; }
    public string TargetDir { get; private set; }
    public String[] SearchDirs { get; private set; }
    public String[] ExcludeDirs { get; private set; }
    public string TargetArgs { get; private set; }
    public bool PrintUsage { get; private set; }
    public string OutputFile { get; private set; }
    public bool NoDefaultFilters { get; private set; }
    public bool MergeByHash { get; private set; }
    public bool ShowUnvisited { get; private set; }
    public bool ReturnTargetCode { get; private set; }
    public List`1<string> Filters { get; private set; }
    public string FilterFile { get; private set; }
    public int ReturnCodeOffset { get; private set; }
    public List`1<string> AttributeExclusionFilters { get; private set; }
    public List`1<string> FileExclusionFilters { get; private set; }
    public List`1<string> TestFilters { get; private set; }
    public List`1<SkippedMethod> HideSkipped { get; private set; }
    public ulong Threshold { get; private set; }
    public bool TraceByTest { get; private set; }
    public Level LogLevel { get; private set; }
    public bool Service { get; private set; }
    public ServiceEnvironment ServiceEnvironment { get; private set; }
    public TimeSpan ServiceStartTimeout { get; private set; }
    public bool OldStyleInstrumentation { get; private set; }
    public bool EnablePerformanceCounters { get; private set; }
    public bool RegExFilters { get; private set; }
    public bool MergeExistingOutputFile { get; private set; }
    public bool PrintVersion { get; private set; }
    public int CommunicationTimeout { get; private set; }
    public bool DiagMode { get; private set; }
    public UInt32 SendVisitPointsTimerInterval { get; private set; }
    public bool IgnoreCtrlC { get; private set; }
    public CommandLineParser(String[] arguments);
    public string Usage();
    public void ExtractAndValidateArguments();
    private T ExtractValue(string argumentName, Action onError);
    private static List`1<string> ExtractFilters(string rawFilters);
    private static List`1<SkippedMethod> ExtractSkipped(string skippedArg);
    private static SafeMode ExtractSafeMode(string safeModeArg);
    private TimeSpan ParseTimeoutValue(string timeoutValue);
    private static Exception ExceptionForInvalidArgumentValue(string argumentName, string argumentValue);
    private void ValidateArguments();
    [CompilerGeneratedAttribute]
public bool get_Register();
    [CompilerGeneratedAttribute]
private void set_Register(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SafeMode();
    [CompilerGeneratedAttribute]
private void set_SafeMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Registration get_Registration();
    [CompilerGeneratedAttribute]
private void set_Registration(Registration value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipAutoImplementedProperties();
    [CompilerGeneratedAttribute]
private void set_SkipAutoImplementedProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetDir();
    [CompilerGeneratedAttribute]
private void set_TargetDir(string value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_SearchDirs();
    [CompilerGeneratedAttribute]
private void set_SearchDirs(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExcludeDirs();
    [CompilerGeneratedAttribute]
private void set_ExcludeDirs(String[] value);
    [CompilerGeneratedAttribute]
public string get_TargetArgs();
    [CompilerGeneratedAttribute]
private void set_TargetArgs(string value);
    [CompilerGeneratedAttribute]
public bool get_PrintUsage();
    [CompilerGeneratedAttribute]
private void set_PrintUsage(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputFile();
    [CompilerGeneratedAttribute]
private void set_OutputFile(string value);
    [CompilerGeneratedAttribute]
public bool get_NoDefaultFilters();
    [CompilerGeneratedAttribute]
private void set_NoDefaultFilters(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_MergeByHash();
    [CompilerGeneratedAttribute]
private void set_MergeByHash(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShowUnvisited();
    [CompilerGeneratedAttribute]
private void set_ShowUnvisited(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReturnTargetCode();
    [CompilerGeneratedAttribute]
private void set_ReturnTargetCode(bool value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Filters();
    [CompilerGeneratedAttribute]
private void set_Filters(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_FilterFile();
    [CompilerGeneratedAttribute]
private void set_FilterFile(string value);
    [CompilerGeneratedAttribute]
public int get_ReturnCodeOffset();
    [CompilerGeneratedAttribute]
private void set_ReturnCodeOffset(int value);
    [CompilerGeneratedAttribute]
public List`1<string> get_AttributeExclusionFilters();
    [CompilerGeneratedAttribute]
private void set_AttributeExclusionFilters(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_FileExclusionFilters();
    [CompilerGeneratedAttribute]
private void set_FileExclusionFilters(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_TestFilters();
    [CompilerGeneratedAttribute]
private void set_TestFilters(List`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual List`1<SkippedMethod> get_HideSkipped();
    [CompilerGeneratedAttribute]
private void set_HideSkipped(List`1<SkippedMethod> value);
    [CompilerGeneratedAttribute]
public sealed virtual ulong get_Threshold();
    [CompilerGeneratedAttribute]
private void set_Threshold(ulong value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TraceByTest();
    [CompilerGeneratedAttribute]
private void set_TraceByTest(bool value);
    [CompilerGeneratedAttribute]
public Level get_LogLevel();
    [CompilerGeneratedAttribute]
private void set_LogLevel(Level value);
    [CompilerGeneratedAttribute]
public bool get_Service();
    [CompilerGeneratedAttribute]
private void set_Service(bool value);
    [CompilerGeneratedAttribute]
public ServiceEnvironment get_ServiceEnvironment();
    [CompilerGeneratedAttribute]
private void set_ServiceEnvironment(ServiceEnvironment value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ServiceStartTimeout();
    [CompilerGeneratedAttribute]
private void set_ServiceStartTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_OldStyleInstrumentation();
    [CompilerGeneratedAttribute]
private void set_OldStyleInstrumentation(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnablePerformanceCounters();
    [CompilerGeneratedAttribute]
private void set_EnablePerformanceCounters(bool value);
    [CompilerGeneratedAttribute]
public bool get_RegExFilters();
    [CompilerGeneratedAttribute]
private void set_RegExFilters(bool value);
    [CompilerGeneratedAttribute]
public bool get_MergeExistingOutputFile();
    [CompilerGeneratedAttribute]
private void set_MergeExistingOutputFile(bool value);
    [CompilerGeneratedAttribute]
public bool get_PrintVersion();
    [CompilerGeneratedAttribute]
private void set_PrintVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CommunicationTimeout();
    [CompilerGeneratedAttribute]
private void set_CommunicationTimeout(int value);
    [CompilerGeneratedAttribute]
public bool get_DiagMode();
    [CompilerGeneratedAttribute]
private void set_DiagMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_SendVisitPointsTimerInterval();
    [CompilerGeneratedAttribute]
private void set_SendVisitPointsTimerInterval(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCtrlC();
    [CompilerGeneratedAttribute]
private void set_IgnoreCtrlC(bool value);
    [CompilerGeneratedAttribute]
private void <ExtractAndValidateArguments>b__2_3();
}
public abstract class OpenCover.Framework.CommandLineParserBase : object {
    private String[] _arguments;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ParsedArguments>k__BackingField;
    protected IDictionary`2<string, string> ParsedArguments { get; private set; }
    public int ArgumentCount { get; }
    protected CommandLineParserBase(String[] arguments);
    [CompilerGeneratedAttribute]
protected IDictionary`2<string, string> get_ParsedArguments();
    [CompilerGeneratedAttribute]
private void set_ParsedArguments(IDictionary`2<string, string> value);
    protected void ParseArguments();
    private void ExtractArgumentValue(string trimmed);
    private static bool ExtractTrimmedArgument(string argument, String& trimmed);
    public int get_ArgumentCount();
    public bool HasArgument(string argument);
    public string GetArgumentValue(string argument);
}
public class OpenCover.Framework.Communication.CommunicationManager : object {
    private IMessageHandler _messageHandler;
    public CommunicationManager(IMessageHandler messageHandler);
    public sealed virtual void HandleCommunicationBlock(IManagedCommunicationBlock mcb, Action`1<ManagedBufferBlock> offloadHandling);
    private static void SendChunkAndWaitForConfirmation(int writeSize, IManagedCommunicationBlock mcb);
    public sealed virtual Byte[] HandleMemoryBlock(IManagedMemoryBlock mmb);
    public sealed virtual void Complete();
}
public interface OpenCover.Framework.Communication.ICommunicationManager {
    public abstract virtual void HandleCommunicationBlock(IManagedCommunicationBlock mcb, Action`1<ManagedBufferBlock> offloadHandling);
    public abstract virtual Byte[] HandleMemoryBlock(IManagedMemoryBlock mmb);
    public abstract virtual void Complete();
}
public interface OpenCover.Framework.Communication.IMarshalWrapper {
    public abstract virtual T PtrToStructure(IntPtr pinnedMemory);
    public abstract virtual void StructureToPtr(T structure, IntPtr pinnedMemory, bool fDeleteOld);
}
public interface OpenCover.Framework.Communication.IMessageHandler {
    public int ReadSize { get; }
    public abstract virtual int StandardMessage(MSG_Type msgType, IManagedCommunicationBlock mcb, Action`2<int, IManagedCommunicationBlock> chunkReady, Action`1<ManagedBufferBlock> offloadHandling);
    public abstract virtual int get_ReadSize();
    public abstract virtual void Complete();
}
public class OpenCover.Framework.Communication.MarshalWrapper : object {
    public sealed virtual T PtrToStructure(IntPtr pinnedMemory);
    public sealed virtual void StructureToPtr(T structure, IntPtr pinnedMemory, bool fDeleteOld);
}
public class OpenCover.Framework.Communication.MessageHandler : object {
    private static int GspBufSize;
    private static int GbpBufSize;
    private IProfilerCommunication _profilerCommunication;
    private IMarshalWrapper _marshalWrapper;
    private IMemoryManager _memoryManager;
    private static ILog DebugLogger;
    private int _readSize;
    public int ReadSize { get; }
    public MessageHandler(IProfilerCommunication profilerCommunication, IMarshalWrapper marshalWrapper, IMemoryManager memoryManager);
    private static MessageHandler();
    public sealed virtual int StandardMessage(MSG_Type msgType, IManagedCommunicationBlock mcb, Action`2<int, IManagedCommunicationBlock> chunkReady, Action`1<ManagedBufferBlock> offloadHandling);
    private int HandleGetSequencePointsMessage(IntPtr pinnedMemory, IManagedCommunicationBlock mcb, Action`2<int, IManagedCommunicationBlock> chunkReady);
    private int HandleGetBranchPointsMessage(IntPtr pinnedMemory, IManagedCommunicationBlock mcb, Action`2<int, IManagedCommunicationBlock> chunkReady);
    private int HandleAllocateBufferMessage(Action`1<ManagedBufferBlock> offloadHandling, IntPtr pinnedMemory);
    private int HandleCloseChannelMessage(IntPtr pinnedMemory);
    private int HandleTrackMethodMessage(IntPtr pinnedMemory);
    private int HandleTrackAssemblyMessage(IntPtr pinnedMemory);
    private int HandleTrackProcessMessage(IntPtr pinnedMemory);
    public sealed virtual int get_ReadSize();
    public sealed virtual void Complete();
}
public class OpenCover.Framework.Communication.MSG_AllocateBuffer_Request : ValueType {
    public MSG_Type type;
    public int bufferSize;
    public UInt32 version_high;
    public UInt32 version_low;
}
public class OpenCover.Framework.Communication.MSG_AllocateBuffer_Response : ValueType {
    public bool allocated;
    public UInt32 bufferId;
    public MSG_AllocateBufferFailure reason;
}
public enum OpenCover.Framework.Communication.MSG_AllocateBufferFailure : Enum {
    public UInt32 value__;
    public static MSG_AllocateBufferFailure ABF_NotApplicable;
    public static MSG_AllocateBufferFailure ABF_ProfilerVersionMismatch;
}
public class OpenCover.Framework.Communication.MSG_BranchPoint : ValueType {
    public UInt32 uniqueId;
    public int offset;
    public int path;
}
public class OpenCover.Framework.Communication.MSG_CloseChannel_Request : ValueType {
    public MSG_Type type;
    public UInt32 bufferId;
}
public class OpenCover.Framework.Communication.MSG_CloseChannel_Response : ValueType {
    public bool done;
}
public class OpenCover.Framework.Communication.MSG_GetBranchPoints_Request : ValueType {
    public MSG_Type type;
    public int functionToken;
    public string processPath;
    public string modulePath;
    public string assemblyName;
}
public class OpenCover.Framework.Communication.MSG_GetBranchPoints_Response : ValueType {
    public bool more;
    public int count;
}
public class OpenCover.Framework.Communication.MSG_GetSequencePoints_Request : ValueType {
    public MSG_Type type;
    public int functionToken;
    public string processPath;
    public string modulePath;
    public string assemblyName;
}
public class OpenCover.Framework.Communication.MSG_GetSequencePoints_Response : ValueType {
    public bool more;
    public int count;
}
public enum OpenCover.Framework.Communication.MSG_IdType : Enum {
    public UInt32 value__;
    public static MSG_IdType IT_VisitPoint;
    public static MSG_IdType IT_MethodEnter;
    public static MSG_IdType IT_MethodLeave;
    public static MSG_IdType IT_MethodTailcall;
    public static MSG_IdType IT_Mask;
}
public class OpenCover.Framework.Communication.MSG_SequencePoint : ValueType {
    public UInt32 uniqueId;
    public int offset;
}
public class OpenCover.Framework.Communication.MSG_TrackAssembly_Request : ValueType {
    public MSG_Type type;
    public string processPath;
    public string modulePath;
    public string assemblyName;
}
public class OpenCover.Framework.Communication.MSG_TrackAssembly_Response : ValueType {
    public bool track;
}
public class OpenCover.Framework.Communication.MSG_TrackMethod_Request : ValueType {
    public MSG_Type type;
    public int functionToken;
    public string modulePath;
    public string assemblyName;
}
public class OpenCover.Framework.Communication.MSG_TrackMethod_Response : ValueType {
    public bool track;
    public UInt32 uniqueId;
}
public class OpenCover.Framework.Communication.MSG_TrackProcess_Request : ValueType {
    public MSG_Type type;
    public string processPath;
}
public class OpenCover.Framework.Communication.MSG_TrackProcess_Response : ValueType {
    public bool track;
}
public enum OpenCover.Framework.Communication.MSG_Type : Enum {
    public int value__;
    public static MSG_Type MSG_Unknown;
    public static MSG_Type MSG_TrackAssembly;
    public static MSG_Type MSG_GetSequencePoints;
    public static MSG_Type MSG_GetBranchPoints;
    public static MSG_Type MSG_TrackMethod;
    public static MSG_Type MSG_AllocateMemoryBuffer;
    public static MSG_Type MSG_CloseChannel;
    public static MSG_Type MSG_TrackProcess;
}
[AttributeUsageAttribute("228")]
[ExcludeFromCoverageAttribute("It is an attribute and is not actually executed directly by a test but is used to hide code from coverage")]
internal class OpenCover.Framework.ExcludeFromCoverageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; private set; }
    public ExcludeFromCoverageAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(string value);
}
public class OpenCover.Framework.ExitApplicationWithoutReportingException : Exception {
}
public class OpenCover.Framework.Filter : object {
    private static ILog Logger;
    [CompilerGeneratedAttribute]
private IList`1<AssemblyAndClassFilter> <InclusionFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AssemblyAndClassFilter> <ExclusionFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<RegexFilter> <ExcludedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<RegexFilter> <ExcludedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<RegexFilter> <TestFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RegExFilters>k__BackingField;
    private IList`1<string> _excludePaths;
    internal IList`1<AssemblyAndClassFilter> InclusionFilters { get; private set; }
    internal IList`1<AssemblyAndClassFilter> ExclusionFilters { get; private set; }
    internal IList`1<RegexFilter> ExcludedAttributes { get; private set; }
    internal IList`1<RegexFilter> ExcludedFiles { get; private set; }
    internal IList`1<RegexFilter> TestFiles { get; private set; }
    public bool RegExFilters { get; private set; }
    public Filter(bool useRegexFilters);
    private static Filter();
    [CompilerGeneratedAttribute]
internal IList`1<AssemblyAndClassFilter> get_InclusionFilters();
    [CompilerGeneratedAttribute]
private void set_InclusionFilters(IList`1<AssemblyAndClassFilter> value);
    [CompilerGeneratedAttribute]
internal IList`1<AssemblyAndClassFilter> get_ExclusionFilters();
    [CompilerGeneratedAttribute]
private void set_ExclusionFilters(IList`1<AssemblyAndClassFilter> value);
    [CompilerGeneratedAttribute]
internal IList`1<RegexFilter> get_ExcludedAttributes();
    [CompilerGeneratedAttribute]
private void set_ExcludedAttributes(IList`1<RegexFilter> value);
    [CompilerGeneratedAttribute]
internal IList`1<RegexFilter> get_ExcludedFiles();
    [CompilerGeneratedAttribute]
private void set_ExcludedFiles(IList`1<RegexFilter> value);
    [CompilerGeneratedAttribute]
internal IList`1<RegexFilter> get_TestFiles();
    [CompilerGeneratedAttribute]
private void set_TestFiles(IList`1<RegexFilter> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RegExFilters();
    [CompilerGeneratedAttribute]
private void set_RegExFilters(bool value);
    public sealed virtual bool UseAssembly(string processName, string assemblyName);
    public sealed virtual bool InstrumentClass(string processName, string assemblyName, string className);
    private bool ExcludeProcessOrAssembly(string processName, string assemblyName, IList`1& matchingExclusionFilters);
    public sealed virtual bool InstrumentClass(string assemblyName, string className);
    public sealed virtual void AddFilter(string processAssemblyClassFilter);
    private static void GetAssemblyClassName(string processAssemblyClassFilter, bool useRegEx, FilterType& filterType, String& assemblyFilter, String& classFilter, String& processFilter);
    private static void HandleInvalidFilterFormat(string filter);
    public sealed virtual void AddAttributeExclusionFilters(String[] exclusionFilters);
    public sealed virtual bool ExcludeByAttribute(IMemberDefinition originalEntity);
    private static IMemberDefinition GetDeclaringMethod(IMemberDefinition entity);
    private static bool MatchDeclaringMethod(IMemberDefinition entity, MethodDefinition& target);
    private bool IsExcludedByAttributeSimple(IMemberDefinition entity, Boolean& excludeByAttribute);
    private bool ExcludeByAttribute(ICustomAttributeProvider entity);
    public sealed virtual bool ExcludeByAttribute(AssemblyDefinition entity);
    public sealed virtual bool ExcludeByFile(string fileName);
    public sealed virtual void AddFileExclusionFilters(String[] exclusionFilters);
    public sealed virtual bool UseTestAssembly(string assemblyName);
    public sealed virtual void AddTestFileFilters(String[] testFilters);
    public sealed virtual bool IsAutoImplementedProperty(MethodDefinition method, TypeDefinition type);
    public sealed virtual bool IsFSharpInternal(MethodDefinition method);
    public sealed virtual bool InstrumentProcess(string processName);
    private bool IsProcessExcluded(string processName);
    public sealed virtual void AddExcludedFolder(string excludedPath);
    public sealed virtual bool UseModule(string modulePath);
    public static IFilter BuildFilter(CommandLineParser parser);
    private static void AddFilters(ICollection`1<RegexFilter> target, IEnumerable`1<string> filters, bool isRegexFilter, string filterType);
    private static string ValidateAndEscape(string match, string notAllowed, string filterType);
}
internal class OpenCover.Framework.Filtering.AssemblyAndClassFilter : object {
    private RegexFilter _processFilter;
    private RegexFilter _assemblyFilter;
    private RegexFilter _classFilter;
    internal string ProcessName { get; }
    internal string AssemblyName { get; }
    internal string ClassName { get; }
    internal AssemblyAndClassFilter(string processFilter, string assemblyFilter, string classFilter);
    internal string get_ProcessName();
    internal string get_AssemblyName();
    internal string get_ClassName();
    internal bool IsMatchingProcessName(string processName);
    internal bool IsMatchingAssemblyName(string assemblyName);
    internal bool IsMatchingClassName(string className);
}
[ExtensionAttribute]
internal static class OpenCover.Framework.Filtering.FilterHelper : object {
    [ExtensionAttribute]
internal static string WrapWithAnchors(string data);
    [ExtensionAttribute]
internal static IList`1<AssemblyAndClassFilter> GetMatchingFiltersForAssemblyName(IEnumerable`1<AssemblyAndClassFilter> filters, string assemblyName);
    [ExtensionAttribute]
internal static IList`1<AssemblyAndClassFilter> GetMatchingFiltersForProcessName(IEnumerable`1<AssemblyAndClassFilter> filters, string processName);
    [ExtensionAttribute]
internal static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> range);
}
public enum OpenCover.Framework.Filtering.FilterType : Enum {
    public int value__;
    public static FilterType Inclusion;
    public static FilterType Exclusion;
}
[ExtensionAttribute]
internal static class OpenCover.Framework.Filtering.FilterTypeExtensions : object {
    [ExtensionAttribute]
public static FilterType ParseFilterType(string type);
}
internal class OpenCover.Framework.Filtering.RegexFilter : object {
    private Lazy`1<Regex> _regex;
    [CompilerGeneratedAttribute]
private string <FilterExpression>k__BackingField;
    internal string FilterExpression { get; private set; }
    public RegexFilter(string filterExpression, bool shouldWrapExpression);
    [CompilerGeneratedAttribute]
internal string get_FilterExpression();
    [CompilerGeneratedAttribute]
private void set_FilterExpression(string value);
    public bool IsMatchingExpression(string input);
}
[ExtensionAttribute]
internal static class OpenCover.Framework.HelperExtensions : object {
    [ExtensionAttribute]
public static TRet Maybe(T value, Func`2<T, TRet> action, TRet defValue);
    [ExtensionAttribute]
public static T Do(T value, Action`1<T> action);
    [ExtensionAttribute]
public static T Try(T value, Action`1<T> action);
}
public interface OpenCover.Framework.ICommandLine {
    public string TargetDir { get; }
    public String[] SearchDirs { get; }
    public String[] ExcludeDirs { get; }
    public bool MergeByHash { get; }
    public bool ShowUnvisited { get; }
    public List`1<SkippedMethod> HideSkipped { get; }
    public ulong Threshold { get; }
    public bool TraceByTest { get; }
    public bool SafeMode { get; }
    public Registration Registration { get; }
    public bool SkipAutoImplementedProperties { get; }
    public int CommunicationTimeout { get; }
    public UInt32 SendVisitPointsTimerInterval { get; }
    public abstract virtual string get_TargetDir();
    public abstract virtual String[] get_SearchDirs();
    public abstract virtual String[] get_ExcludeDirs();
    public abstract virtual bool get_MergeByHash();
    public abstract virtual bool get_ShowUnvisited();
    public abstract virtual List`1<SkippedMethod> get_HideSkipped();
    public abstract virtual ulong get_Threshold();
    public abstract virtual bool get_TraceByTest();
    public abstract virtual bool get_SafeMode();
    public abstract virtual Registration get_Registration();
    public abstract virtual bool get_SkipAutoImplementedProperties();
    public abstract virtual int get_CommunicationTimeout();
    public abstract virtual UInt32 get_SendVisitPointsTimerInterval();
}
public interface OpenCover.Framework.IFilter {
    public bool RegExFilters { get; }
    public abstract virtual void AddFilter(string assemblyClassName);
    public abstract virtual bool UseAssembly(string processName, string assemblyName);
    public abstract virtual bool UseTestAssembly(string assemblyName);
    public abstract virtual void AddFileExclusionFilters(String[] exclusionFilters);
    public abstract virtual bool InstrumentClass(string assemblyName, string className);
    public abstract virtual bool InstrumentClass(string processName, string assemblyName, string className);
    public abstract virtual void AddAttributeExclusionFilters(String[] exclusionFilters);
    public abstract virtual bool ExcludeByAttribute(IMemberDefinition entity);
    public abstract virtual bool ExcludeByAttribute(AssemblyDefinition entity);
    public abstract virtual bool ExcludeByFile(string fileName);
    public abstract virtual void AddTestFileFilters(String[] testFilters);
    public abstract virtual bool IsAutoImplementedProperty(MethodDefinition method, TypeDefinition type);
    public abstract virtual bool IsFSharpInternal(MethodDefinition method);
    public abstract virtual bool get_RegExFilters();
    public abstract virtual bool InstrumentProcess(string processName);
    public abstract virtual void AddExcludedFolder(string excludedPath);
    public abstract virtual bool UseModule(string modulePath);
}
public interface OpenCover.Framework.Manager.IManagedCommunicationBlock {
    public MemoryMappedViewStream StreamAccessorComms { get; }
    public EventWaitHandle ProfilerRequestsInformation { get; }
    public EventWaitHandle InformationReadyForProfiler { get; }
    public EventWaitHandle InformationReadByProfiler { get; }
    public Byte[] DataCommunication { get; }
    public GCHandle PinnedDataCommunication { get; }
    public abstract virtual MemoryMappedViewStream get_StreamAccessorComms();
    public abstract virtual EventWaitHandle get_ProfilerRequestsInformation();
    public abstract virtual EventWaitHandle get_InformationReadyForProfiler();
    public abstract virtual EventWaitHandle get_InformationReadByProfiler();
    public abstract virtual Byte[] get_DataCommunication();
    public abstract virtual GCHandle get_PinnedDataCommunication();
}
public interface OpenCover.Framework.Manager.IManagedMemoryBlock {
    public EventWaitHandle ProfilerHasResults { get; }
    public EventWaitHandle ResultsHaveBeenReceived { get; }
    public MemoryMappedViewStream StreamAccessorResults { get; }
    public int BufferSize { get; }
    public Byte[] Buffer { get; }
    public abstract virtual EventWaitHandle get_ProfilerHasResults();
    public abstract virtual EventWaitHandle get_ResultsHaveBeenReceived();
    public abstract virtual MemoryMappedViewStream get_StreamAccessorResults();
    public abstract virtual int get_BufferSize();
    public abstract virtual Byte[] get_Buffer();
}
public interface OpenCover.Framework.Manager.IMemoryManager {
    public IReadOnlyList`1<ManagedBufferBlock> GetBlocks { get; }
    public abstract virtual void Initialise(string nameSpace, string key, IEnumerable`1<string> servicePrincipal);
    public abstract virtual ManagedBufferBlock AllocateMemoryBuffer(int bufferSize, UInt32& bufferId);
    public abstract virtual IReadOnlyList`1<ManagedBufferBlock> get_GetBlocks();
    public abstract virtual void DeactivateMemoryBuffer(UInt32 bufferId);
    public abstract virtual void RemoveDeactivatedBlock(ManagedBufferBlock block);
    public abstract virtual void WaitForBlocksToClose(int bufferWaitCount);
    public abstract virtual void FetchRemainingBufferData(Action`1<Byte[]> processBuffer);
}
public interface OpenCover.Framework.Manager.IProfilerManager {
    public abstract virtual void RunProcess(Action`1<Action`1<StringDictionary>> process, String[] servicePrincipal);
}
public class OpenCover.Framework.Manager.ManagedBufferBlock : object {
    [CompilerGeneratedAttribute]
private IManagedCommunicationBlock <CommunicationBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private IManagedMemoryBlock <MemoryBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <BufferId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    public IManagedCommunicationBlock CommunicationBlock { get; public set; }
    public IManagedMemoryBlock MemoryBlock { get; public set; }
    public UInt32 BufferId { get; public set; }
    public bool Active { get; public set; }
    [CompilerGeneratedAttribute]
public IManagedCommunicationBlock get_CommunicationBlock();
    [CompilerGeneratedAttribute]
public void set_CommunicationBlock(IManagedCommunicationBlock value);
    [CompilerGeneratedAttribute]
public IManagedMemoryBlock get_MemoryBlock();
    [CompilerGeneratedAttribute]
public void set_MemoryBlock(IManagedMemoryBlock value);
    [CompilerGeneratedAttribute]
public UInt32 get_BufferId();
    [CompilerGeneratedAttribute]
public void set_BufferId(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_Active();
    [CompilerGeneratedAttribute]
public void set_Active(bool value);
}
public class OpenCover.Framework.Manager.MemoryManager : object {
    private string _namespace;
    private string _key;
    private object _lockObject;
    private UInt32 _bufferId;
    private static ILog DebugLogger;
    private IList`1<ManagedBufferBlock> _blocks;
    private bool _isIntialised;
    private String[] _servicePrincipal;
    private bool _disposed;
    public IReadOnlyList`1<ManagedBufferBlock> GetBlocks { get; }
    private static MemoryManager();
    public sealed virtual void Initialise(string namespace, string key, IEnumerable`1<string> servicePrincipal);
    public sealed virtual ManagedBufferBlock AllocateMemoryBuffer(int bufferSize, UInt32& bufferId);
    public sealed virtual IReadOnlyList`1<ManagedBufferBlock> get_GetBlocks();
    public sealed virtual void DeactivateMemoryBuffer(UInt32 bufferId);
    public sealed virtual void RemoveDeactivatedBlock(ManagedBufferBlock block);
    public sealed virtual void WaitForBlocksToClose(int bufferWaitCount);
    public sealed virtual void FetchRemainingBufferData(Action`1<Byte[]> processBuffer);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class OpenCover.Framework.Manager.ProfilerManager : object {
    private static int MaxMsgSize;
    private static int NumHandlesPerBlock;
    private static string ProfilerGuid;
    private ICommunicationManager _communicationManager;
    private IPersistance _persistance;
    private IMemoryManager _memoryManager;
    private ICommandLine _commandLine;
    private IPerfCounters _perfCounters;
    private ManagedCommunicationBlock _mcb;
    private ConcurrentQueue`1<Byte[]> _messageQueue;
    private object _syncRoot;
    [CompilerGeneratedAttribute]
private static int <BufferWaitCount>k__BackingField;
    private static ILog DebugLogger;
    private bool _continueWait;
    public object SyncRoot { get; }
    internal static int BufferWaitCount { get; internal set; }
    public ProfilerManager(ICommunicationManager communicationManager, IPersistance persistance, IMemoryManager memoryManager, ICommandLine commandLine, IPerfCounters perfCounters);
    private static ProfilerManager();
    public object get_SyncRoot();
    [CompilerGeneratedAttribute]
internal static int get_BufferWaitCount();
    [CompilerGeneratedAttribute]
internal static void set_BufferWaitCount(int value);
    public sealed virtual void RunProcess(Action`1<Action`1<StringDictionary>> process, String[] servicePrincipal);
    private WaitCallback SetProfilerAttributes(Action`1<Action`1<StringDictionary>> process, string profilerKey, string profilerNamespace, EventWaitHandle environmentKeyRead, EventWaitHandle processMgmt);
    private void SetProfilerAttributesOnDictionary(string profilerKey, string profilerNamespace, StringDictionary dictionary);
    private WaitCallback SaveVisitData(EventWaitHandle queueMgmt);
    private void ProcessMessages(WaitHandle[] handles);
    private static void ConsumeException(Action doSomething);
    private ThreadTermination StartProcessingThread(ManagedBufferBlock block);
    private WaitCallback ProcessBlock(ManagedBufferBlock block, EventWaitHandle threadActivatedEvent, ThreadTermination threadTermination);
    private bool ProcessActiveBlock(ManagedBufferBlock block, WaitHandle[] processEvents);
}
public class OpenCover.Framework.Model.BranchPoint : InstrumentationPoint {
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<int> <OffsetPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    [XmlAttributeAttribute("sl")]
public int StartLine { get; public set; }
    [XmlAttributeAttribute("path")]
public int Path { get; public set; }
    [XmlAttributeAttribute("offsetchain")]
public List`1<int> OffsetPoints { get; public set; }
    [XmlAttributeAttribute("offsetend")]
public int EndOffset { get; public set; }
    [XmlAttributeAttribute("fileid")]
public UInt32 FileId { get; public set; }
    [XmlAttributeAttribute("url")]
public string Document { get; public set; }
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public void set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(int value);
    [CompilerGeneratedAttribute]
public List`1<int> get_OffsetPoints();
    [CompilerGeneratedAttribute]
public void set_OffsetPoints(List`1<int> value);
    public bool ShouldSerializeOffsetPoints();
    [CompilerGeneratedAttribute]
public int get_EndOffset();
    [CompilerGeneratedAttribute]
public void set_EndOffset(int value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_FileId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FileId(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Document(string value);
}
public class OpenCover.Framework.Model.Class : SummarySkippedEntity {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private File[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Method[] <Methods>k__BackingField;
    public string FullName { get; public set; }
    [XmlIgnoreAttribute]
internal File[] Files { get; internal set; }
    public Method[] Methods { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
    [CompilerGeneratedAttribute]
internal File[] get_Files();
    [CompilerGeneratedAttribute]
internal void set_Files(File[] value);
    [CompilerGeneratedAttribute]
public Method[] get_Methods();
    [CompilerGeneratedAttribute]
public void set_Methods(Method[] value);
    public virtual void MarkAsSkipped(SkippedMethod reason);
}
public class OpenCover.Framework.Model.CoverageSession : object {
    private string _version;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Summary <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private Module[] <Modules>k__BackingField;
    public string SessionId { get; public set; }
    public Summary Summary { get; public set; }
    public Module[] Modules { get; public set; }
    [XmlAttributeAttribute("Version")]
public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(string value);
    [CompilerGeneratedAttribute]
public Summary get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(Summary value);
    [CompilerGeneratedAttribute]
public Module[] get_Modules();
    [CompilerGeneratedAttribute]
public void set_Modules(Module[] value);
    public string get_Version();
    public void set_Version(string value);
}
public class OpenCover.Framework.Model.File : FileRef {
    private static int _uId;
    private static List`1<File> Files;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    [XmlAttributeAttribute("fullPath")]
public string FullPath { get; public set; }
    private static File();
    internal static void ResetAfterLoading();
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
public void set_FullPath(string value);
}
internal class OpenCover.Framework.Model.FileEqualityComparer : object {
    public sealed virtual bool Equals(File x, File y);
    public sealed virtual int GetHashCode(File obj);
}
public class OpenCover.Framework.Model.FileRef : object {
    [CompilerGeneratedAttribute]
private UInt32 <UniqueId>k__BackingField;
    [XmlAttributeAttribute("uid")]
public UInt32 UniqueId { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_UniqueId();
    [CompilerGeneratedAttribute]
public void set_UniqueId(UInt32 value);
}
public interface OpenCover.Framework.Model.IDocumentReference {
    public string Document { get; public set; }
    public UInt32 FileId { get; public set; }
    public abstract virtual string get_Document();
    public abstract virtual void set_Document(string value);
    public abstract virtual UInt32 get_FileId();
    public abstract virtual void set_FileId(UInt32 value);
}
public interface OpenCover.Framework.Model.IInstrumentationModelBuilder {
    public bool CanInstrument { get; }
    public AssemblyDefinition GetAssemblyDefinition { get; }
    public abstract virtual Module BuildModuleModel(bool full);
    public abstract virtual Module BuildModuleTestModel(Module module, bool full);
    public abstract virtual bool get_CanInstrument();
    public abstract virtual AssemblyDefinition get_GetAssemblyDefinition();
}
public interface OpenCover.Framework.Model.IInstrumentationModelBuilderFactory {
    public abstract virtual IInstrumentationModelBuilder CreateModelBuilder(string modulePath, string moduleName);
}
internal class OpenCover.Framework.Model.InstrumentationModelBuilder : object {
    private ISymbolManager _symbolManager;
    public bool CanInstrument { get; }
    public AssemblyDefinition GetAssemblyDefinition { get; }
    public InstrumentationModelBuilder(ISymbolManager symbolManager);
    public sealed virtual Module BuildModuleModel(bool full);
    private Module CreateModule(bool full);
    public sealed virtual Module BuildModuleTestModel(Module module, bool full);
    private static string HashFile(string sPath);
    public sealed virtual bool get_CanInstrument();
    public sealed virtual AssemblyDefinition get_GetAssemblyDefinition();
    private void BuildClassModel(Class class, File[] files);
}
internal class OpenCover.Framework.Model.InstrumentationModelBuilderFactory : object {
    private ICommandLine _commandLine;
    private IFilter _filter;
    private ILog _logger;
    private ITrackedMethodStrategyManager _trackedMethodStrategyManager;
    private ISymbolFileHelper _symbolFileHelper;
    public InstrumentationModelBuilderFactory(ICommandLine commandLine, IFilter filter, ILog logger, ITrackedMethodStrategyManager trackedMethodStrategyManager, ISymbolFileHelper symbolFileHelper);
    public sealed virtual IInstrumentationModelBuilder CreateModelBuilder(string modulePath, string moduleName);
}
public class OpenCover.Framework.Model.InstrumentationPoint : object {
    private static int _instrumentPoint;
    private static object LockObject;
    private static List`1<InstrumentationPoint> InstrumentPoints;
    private List`1<TrackedMethodRef> _tracked;
    [CompilerGeneratedAttribute]
private int <VisitCount>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UniqueSequencePoint>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSkipped>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OrigSequencePoint>k__BackingField;
    public static int Count { get; }
    [XmlAttributeAttribute("vc")]
public int VisitCount { get; public set; }
    [XmlAttributeAttribute("uspid")]
public UInt32 UniqueSequencePoint { get; public set; }
    [XmlAttributeAttribute("ordinal")]
public UInt32 Ordinal { get; public set; }
    [XmlAttributeAttribute("offset")]
public int Offset { get; public set; }
    [XmlIgnoreAttribute]
public bool IsSkipped { get; public set; }
    public TrackedMethodRef[] TrackedMethodRefs { get; public set; }
    [XmlIgnoreAttribute]
public UInt32 OrigSequencePoint { get; public set; }
    private static InstrumentationPoint();
    internal static void Clear();
    internal static void ResetAfterLoading();
    public static int get_Count();
    public static int GetVisitCount(UInt32 spid);
    public static bool AddVisitCount(UInt32 spid, UInt32 trackedMethodId, int amount);
    private static void AddOrUpdateTrackingPoint(UInt32 trackedMethodId, int amount, InstrumentationPoint point);
    [CompilerGeneratedAttribute]
public int get_VisitCount();
    [CompilerGeneratedAttribute]
public void set_VisitCount(int value);
    [CompilerGeneratedAttribute]
public UInt32 get_UniqueSequencePoint();
    [CompilerGeneratedAttribute]
public void set_UniqueSequencePoint(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Ordinal();
    [CompilerGeneratedAttribute]
public void set_Ordinal(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public bool get_IsSkipped();
    [CompilerGeneratedAttribute]
public void set_IsSkipped(bool value);
    public TrackedMethodRef[] get_TrackedMethodRefs();
    public void set_TrackedMethodRefs(TrackedMethodRef[] value);
    [CompilerGeneratedAttribute]
public UInt32 get_OrigSequencePoint();
    [CompilerGeneratedAttribute]
public void set_OrigSequencePoint(UInt32 value);
}
public class OpenCover.Framework.Model.Method : SummarySkippedEntity {
    [CompilerGeneratedAttribute]
private int <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private FileRef <FileRef>k__BackingField;
    private SequencePoint[] _sequencePoints;
    private BranchPoint[] _branchPoints;
    [CompilerGeneratedAttribute]
private InstrumentationPoint <MethodPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Visited>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NPathComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <SequenceCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <BranchCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <CrapScore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSetter>k__BackingField;
    private Nullable`1<bool> _resolvedIsGenerated;
    private string _resolvedCallName;
    private static RegexOptions RegexOptions;
    private static Regex IsGeneratedMethodRegex;
    public int MetadataToken { get; public set; }
    [XmlElementAttribute("Name")]
public string FullName { get; public set; }
    public FileRef FileRef { get; public set; }
    internal UInt32 FileRefUniqueId { get; }
    public SequencePoint[] SequencePoints { get; public set; }
    public BranchPoint[] BranchPoints { get; public set; }
    public InstrumentationPoint MethodPoint { get; public set; }
    [XmlAttributeAttribute("visited")]
public bool Visited { get; public set; }
    [XmlAttributeAttribute("cyclomaticComplexity")]
public int CyclomaticComplexity { get; public set; }
    [XmlAttributeAttribute("nPathComplexity")]
public int NPathComplexity { get; public set; }
    [XmlAttributeAttribute("sequenceCoverage")]
public decimal SequenceCoverage { get; public set; }
    [XmlAttributeAttribute("branchCoverage")]
public decimal BranchCoverage { get; public set; }
    [XmlAttributeAttribute("crapScore")]
public decimal CrapScore { get; public set; }
    [XmlAttributeAttribute("isConstructor")]
public bool IsConstructor { get; public set; }
    [XmlAttributeAttribute("isStatic")]
public bool IsStatic { get; public set; }
    [XmlAttributeAttribute("isGetter")]
public bool IsGetter { get; public set; }
    [XmlAttributeAttribute("isSetter")]
public bool IsSetter { get; public set; }
    internal bool IsGenerated { get; }
    internal string CallName { get; }
    private static Method();
    [CompilerGeneratedAttribute]
public int get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(int value);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
    [CompilerGeneratedAttribute]
public FileRef get_FileRef();
    [CompilerGeneratedAttribute]
public void set_FileRef(FileRef value);
    internal UInt32 get_FileRefUniqueId();
    public SequencePoint[] get_SequencePoints();
    public void set_SequencePoints(SequencePoint[] value);
    public BranchPoint[] get_BranchPoints();
    public void set_BranchPoints(BranchPoint[] value);
    [CompilerGeneratedAttribute]
public InstrumentationPoint get_MethodPoint();
    [CompilerGeneratedAttribute]
public void set_MethodPoint(InstrumentationPoint value);
    [CompilerGeneratedAttribute]
public bool get_Visited();
    [CompilerGeneratedAttribute]
public void set_Visited(bool value);
    [CompilerGeneratedAttribute]
public int get_CyclomaticComplexity();
    [CompilerGeneratedAttribute]
public void set_CyclomaticComplexity(int value);
    [CompilerGeneratedAttribute]
public int get_NPathComplexity();
    [CompilerGeneratedAttribute]
public void set_NPathComplexity(int value);
    [CompilerGeneratedAttribute]
public decimal get_SequenceCoverage();
    [CompilerGeneratedAttribute]
public void set_SequenceCoverage(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_BranchCoverage();
    [CompilerGeneratedAttribute]
public void set_BranchCoverage(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_CrapScore();
    [CompilerGeneratedAttribute]
public void set_CrapScore(decimal value);
    [CompilerGeneratedAttribute]
public bool get_IsConstructor();
    [CompilerGeneratedAttribute]
public void set_IsConstructor(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
public void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsGetter();
    [CompilerGeneratedAttribute]
public void set_IsGetter(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSetter();
    [CompilerGeneratedAttribute]
public void set_IsSetter(bool value);
    public virtual void MarkAsSkipped(SkippedMethod reason);
    internal bool get_IsGenerated();
    internal string get_CallName();
}
public class OpenCover.Framework.Model.Module : SummarySkippedEntity {
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ModuleTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Aliases>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private File[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Class[] <Classes>k__BackingField;
    [CompilerGeneratedAttribute]
private TrackedMethod[] <TrackedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleHash>k__BackingField;
    public string ModulePath { get; public set; }
    public DateTime ModuleTime { get; public set; }
    [XmlIgnoreAttribute]
public IList`1<string> Aliases { get; private set; }
    public string ModuleName { get; public set; }
    public File[] Files { get; public set; }
    public Class[] Classes { get; public set; }
    public TrackedMethod[] TrackedMethods { get; public set; }
    [XmlAttributeAttribute("hash")]
public string ModuleHash { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
public void set_ModulePath(string value);
    [CompilerGeneratedAttribute]
public DateTime get_ModuleTime();
    [CompilerGeneratedAttribute]
public void set_ModuleTime(DateTime value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Aliases();
    [CompilerGeneratedAttribute]
private void set_Aliases(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
public void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public File[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(File[] value);
    [CompilerGeneratedAttribute]
public Class[] get_Classes();
    [CompilerGeneratedAttribute]
public void set_Classes(Class[] value);
    [CompilerGeneratedAttribute]
public TrackedMethod[] get_TrackedMethods();
    [CompilerGeneratedAttribute]
public void set_TrackedMethods(TrackedMethod[] value);
    [CompilerGeneratedAttribute]
public string get_ModuleHash();
    [CompilerGeneratedAttribute]
public void set_ModuleHash(string value);
    public virtual void MarkAsSkipped(SkippedMethod reason);
}
public class OpenCover.Framework.Model.SequencePoint : InstrumentationPoint {
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BranchExitsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BranchExitsVisit>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Document>k__BackingField;
    private List`1<BranchPoint> _branchPoints;
    [XmlAttributeAttribute("sl")]
public int StartLine { get; public set; }
    [XmlAttributeAttribute("sc")]
public int StartColumn { get; public set; }
    [XmlAttributeAttribute("el")]
public int EndLine { get; public set; }
    [XmlAttributeAttribute("ec")]
public int EndColumn { get; public set; }
    [XmlAttributeAttribute("bec")]
public int BranchExitsCount { get; public set; }
    [XmlAttributeAttribute("bev")]
public int BranchExitsVisit { get; public set; }
    [XmlAttributeAttribute("fileid")]
public UInt32 FileId { get; public set; }
    [XmlAttributeAttribute("url")]
public string Document { get; public set; }
    internal List`1<BranchPoint> BranchPoints { get; internal set; }
    public bool IsSingleCharSequencePoint { get; }
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public void set_StartLine(int value);
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public void set_StartColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public int get_BranchExitsCount();
    [CompilerGeneratedAttribute]
public void set_BranchExitsCount(int value);
    [CompilerGeneratedAttribute]
public int get_BranchExitsVisit();
    [CompilerGeneratedAttribute]
public void set_BranchExitsVisit(int value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_FileId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FileId(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Document(string value);
    internal List`1<BranchPoint> get_BranchPoints();
    internal void set_BranchPoints(List`1<BranchPoint> value);
    public bool get_IsSingleCharSequencePoint();
    private bool IsLineEqual(SequencePoint sp);
    private bool IsColumnEqual(SequencePoint sp);
    public bool IsPositionEqual(SequencePoint sp);
    public bool IsFileIdEqual(SequencePoint sp);
}
public abstract class OpenCover.Framework.Model.SkippedEntity : object {
    private Nullable`1<SkippedMethod> _skippedDueTo;
    [XmlAttributeAttribute("skippedDueTo")]
public SkippedMethod SkippedDueTo { get; public set; }
    public SkippedMethod get_SkippedDueTo();
    public void set_SkippedDueTo(SkippedMethod value);
    public bool ShouldSerializeSkippedDueTo();
    public abstract virtual void MarkAsSkipped(SkippedMethod reason);
}
public enum OpenCover.Framework.Model.SkippedMethod : Enum {
    public int value__;
    public static SkippedMethod Attribute;
    public static SkippedMethod File;
    public static SkippedMethod Filter;
    public static SkippedMethod MissingPdb;
    public static SkippedMethod Inferred;
    public static SkippedMethod AutoImplementedProperty;
    public static SkippedMethod NativeCode;
    public static SkippedMethod Unknown;
    public static SkippedMethod FolderExclusion;
    public static SkippedMethod Delegate;
    public static SkippedMethod FSharpInternal;
}
public class OpenCover.Framework.Model.Summary : object {
    [CompilerGeneratedAttribute]
private int <NumSequencePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VisitedSequencePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumBranchPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VisitedBranchPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <SequenceCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <BranchCoverage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxCyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinCyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <MaxCrapScore>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <MinCrapScore>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VisitedClasses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumClasses>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VisitedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumMethods>k__BackingField;
    [XmlAttributeAttribute("numSequencePoints")]
public int NumSequencePoints { get; public set; }
    [XmlAttributeAttribute("visitedSequencePoints")]
public int VisitedSequencePoints { get; public set; }
    [XmlAttributeAttribute("numBranchPoints")]
public int NumBranchPoints { get; public set; }
    [XmlAttributeAttribute("visitedBranchPoints")]
public int VisitedBranchPoints { get; public set; }
    [XmlAttributeAttribute("sequenceCoverage")]
public decimal SequenceCoverage { get; public set; }
    [XmlAttributeAttribute("branchCoverage")]
public decimal BranchCoverage { get; public set; }
    [XmlAttributeAttribute("maxCyclomaticComplexity")]
public int MaxCyclomaticComplexity { get; public set; }
    [XmlAttributeAttribute("minCyclomaticComplexity")]
public int MinCyclomaticComplexity { get; public set; }
    [XmlAttributeAttribute("maxCrapScore")]
public decimal MaxCrapScore { get; public set; }
    [XmlAttributeAttribute("minCrapScore")]
public decimal MinCrapScore { get; public set; }
    [XmlAttributeAttribute("visitedClasses")]
public int VisitedClasses { get; public set; }
    [XmlAttributeAttribute("numClasses")]
public int NumClasses { get; public set; }
    [XmlAttributeAttribute("visitedMethods")]
public int VisitedMethods { get; public set; }
    [XmlAttributeAttribute("numMethods")]
public int NumMethods { get; public set; }
    [CompilerGeneratedAttribute]
public int get_NumSequencePoints();
    [CompilerGeneratedAttribute]
public void set_NumSequencePoints(int value);
    [CompilerGeneratedAttribute]
public int get_VisitedSequencePoints();
    [CompilerGeneratedAttribute]
public void set_VisitedSequencePoints(int value);
    [CompilerGeneratedAttribute]
public int get_NumBranchPoints();
    [CompilerGeneratedAttribute]
public void set_NumBranchPoints(int value);
    [CompilerGeneratedAttribute]
public int get_VisitedBranchPoints();
    [CompilerGeneratedAttribute]
public void set_VisitedBranchPoints(int value);
    [CompilerGeneratedAttribute]
public decimal get_SequenceCoverage();
    [CompilerGeneratedAttribute]
public void set_SequenceCoverage(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_BranchCoverage();
    [CompilerGeneratedAttribute]
public void set_BranchCoverage(decimal value);
    [CompilerGeneratedAttribute]
public int get_MaxCyclomaticComplexity();
    [CompilerGeneratedAttribute]
public void set_MaxCyclomaticComplexity(int value);
    [CompilerGeneratedAttribute]
public int get_MinCyclomaticComplexity();
    [CompilerGeneratedAttribute]
public void set_MinCyclomaticComplexity(int value);
    [CompilerGeneratedAttribute]
public decimal get_MaxCrapScore();
    [CompilerGeneratedAttribute]
public void set_MaxCrapScore(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_MinCrapScore();
    [CompilerGeneratedAttribute]
public void set_MinCrapScore(decimal value);
    [CompilerGeneratedAttribute]
public int get_VisitedClasses();
    [CompilerGeneratedAttribute]
public void set_VisitedClasses(int value);
    [CompilerGeneratedAttribute]
public int get_NumClasses();
    [CompilerGeneratedAttribute]
public void set_NumClasses(int value);
    [CompilerGeneratedAttribute]
public int get_VisitedMethods();
    [CompilerGeneratedAttribute]
public void set_VisitedMethods(int value);
    [CompilerGeneratedAttribute]
public int get_NumMethods();
    [CompilerGeneratedAttribute]
public void set_NumMethods(int value);
}
public abstract class OpenCover.Framework.Model.SummarySkippedEntity : SkippedEntity {
    [CompilerGeneratedAttribute]
private Summary <Summary>k__BackingField;
    public Summary Summary { get; public set; }
    [CompilerGeneratedAttribute]
public Summary get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(Summary value);
    public bool ShouldSerializeSummary();
}
public class OpenCover.Framework.Model.TrackedMethod : object {
    [CompilerGeneratedAttribute]
private UInt32 <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Strategy>k__BackingField;
    [XmlAttributeAttribute("uid")]
public UInt32 UniqueId { get; public set; }
    [XmlAttributeAttribute("token")]
public int MetadataToken { get; public set; }
    [XmlAttributeAttribute("name")]
public string FullName { get; public set; }
    [XmlAttributeAttribute("strategy")]
public string Strategy { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_UniqueId();
    [CompilerGeneratedAttribute]
public void set_UniqueId(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_MetadataToken();
    [CompilerGeneratedAttribute]
public void set_MetadataToken(int value);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public void set_FullName(string value);
    [CompilerGeneratedAttribute]
public string get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(string value);
}
public class OpenCover.Framework.Model.TrackedMethodRef : object {
    [CompilerGeneratedAttribute]
private UInt32 <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VisitCount>k__BackingField;
    [XmlAttributeAttribute("uid")]
public UInt32 UniqueId { get; public set; }
    [XmlAttributeAttribute("vc")]
public int VisitCount { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_UniqueId();
    [CompilerGeneratedAttribute]
public void set_UniqueId(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_VisitCount();
    [CompilerGeneratedAttribute]
public void set_VisitCount(int value);
}
public abstract class OpenCover.Framework.Persistance.BasePersistance : object {
    private static object Protection;
    protected ICommandLine CommandLine;
    private ILog _logger;
    private UInt32 _trackedMethodId;
    private Dictionary`2<Module, Dictionary`2<int, KeyValuePair`2<Class, Method>>> _moduleMethodMap;
    private static ILog DebugLogger;
    [CompilerGeneratedAttribute]
private CoverageSession <CoverageSession>k__BackingField;
    private static RegexOptions regexOptions;
    private static Regex contractRegex;
    public CoverageSession CoverageSession { get; private set; }
    protected BasePersistance(ICommandLine commandLine, ILog logger);
    private static BasePersistance();
    [CompilerGeneratedAttribute]
public sealed virtual CoverageSession get_CoverageSession();
    [CompilerGeneratedAttribute]
private void set_CoverageSession(CoverageSession value);
    public sealed virtual void PersistModule(Module module);
    protected void ClearCoverageSession();
    protected void ReassignCoverageSession(CoverageSession session);
    private void BuildMethodMapForModule(Module module);
    public sealed virtual bool IsTracking(string modulePath);
    public virtual void Commit();
    private void ProcessSkippedAction(SkippedMethod skippedMethod);
    private void RemoveSkippedModules(SkippedMethod skipped);
    private void RemoveSkippedClasses(SkippedMethod skipped);
    private void RemoveSkippedMethods(SkippedMethod skipped);
    private void RemoveEmptyClasses();
    private void RemoveUnreferencedFiles();
    private void MarkSkippedMethods();
    private void CalculateCoverage();
    private void ProcessModuleData(Module module);
    private static void ProcessClassData(Class class, Module module);
    private static void ProcessMethodData(Method method, Class class);
    private static void CalculateCrapScore(Method method, Class class);
    private static void CalculateCyclomaticComplexity(Method method, Class class);
    private static void CalculateNPathComplexity(Method method);
    private static void MapFileReferences(IEnumerable`1<IDocumentReference> points, IDictionary`2<string, UInt32> filesDictionary);
    private static void CalculateCoverage(Summary summary);
    private static void AddPoints(Summary parent, Summary child);
    public sealed virtual bool GetSequencePointsForFunction(string modulePath, int functionToken, InstrumentationPoint[]& sequencePoints);
    public sealed virtual bool GetBranchPointsForFunction(string modulePath, int functionToken, BranchPoint[]& branchPoints);
    private Method GetMethod(string modulePath, int functionToken, Class& class);
    public sealed virtual string GetClassFullName(string modulePath, int functionToken);
    public sealed virtual void SaveVisitData(Byte[] data);
    public sealed virtual bool GetTrackingMethod(string modulePath, string assemblyName, int functionToken, UInt32& uniqueId);
    private void TransformSequences();
    private static void TransformSequences_Initialize(IEnumerable`1<Method> methods);
    private static void TransformSequences_JoinWithBranches(IEnumerable`1<Method> methods);
    private static void TransformSequences_AddSources(IEnumerable`1<File> files, IEnumerable`1<Method> methods, IDictionary`2<UInt32, CodeCoverageStringTextSource> sourceRepository);
    private static void TransformSequences_RemoveCompilerGeneratedBranches(IEnumerable`1<Method> methods, SourceRepository sourceRepository, DateTime moduleTime);
    private static bool TransformSequences_RemoveCompilerGeneratedBranches(Method method, CodeCoverageStringTextSource source);
    private static void TransformSequences_RemoveCompilerGeneratedBranches(Method method, CodeCoverageStringTextSource source, Int64& startOffset, Int64& finalOffset);
    private static bool TransformSequences_RemoveCompilerGeneratedBranches(Method method, CodeCoverageStringTextSource source, long startOffset, long finalOffset);
    private static void TransformSequences_RemoveFalsePositiveUnvisited(IEnumerable`1<Method> methods, SourceRepository sourceRepository, DateTime moduleTime);
    private static void TransformSequences_RemoveFalsePositiveUnvisited(IEnumerable`1<Method> methods, ISet`1<SequencePoint> sequencePointsSet);
    private static void TransformSequences_RemoveFalsePositiveUnvisited(Method method, CodeCoverageStringTextSource source, ICollection`1<Tuple`2<Method, SequencePoint>> toRemoveMethodSequencePoint);
    private static void TransformSequences_ReduceBranches(IEnumerable`1<Method> methods);
}
public class OpenCover.Framework.Persistance.FilePersistance : BasePersistance {
    private ILog _logger;
    private string _fileName;
    public FilePersistance(ICommandLine commandLine, ILog logger);
    public bool Initialise(string fileName, bool loadExisting);
    internal bool HandleFileAccess(Action loadFile, string fileName);
    private void LoadCoverageFile();
    public virtual void Commit();
    private bool SaveCoverageFile();
    [CompilerGeneratedAttribute]
private void <SaveCoverageFile>b__7_0();
}
public interface OpenCover.Framework.Persistance.IPersistance {
    public CoverageSession CoverageSession { get; }
    public abstract virtual void PersistModule(Module module);
    public abstract virtual void Commit();
    public abstract virtual bool GetSequencePointsForFunction(string modulePath, int functionToken, InstrumentationPoint[]& sequencePoints);
    public abstract virtual bool GetBranchPointsForFunction(string modulePath, int functionToken, BranchPoint[]& branchPoints);
    public abstract virtual bool IsTracking(string modulePath);
    public abstract virtual string GetClassFullName(string modulePath, int functionToken);
    public abstract virtual CoverageSession get_CoverageSession();
    public abstract virtual void SaveVisitData(Byte[] data);
    public abstract virtual bool GetTrackingMethod(string modulePath, string assemblyName, int functionToken, UInt32& uniqueId);
}
[ExcludeFromCoverageAttribute("Intentionally not unit tested - as this is calling regsvr32 which does what it does and does not need more testing from me")]
public static class OpenCover.Framework.ProfilerRegistration : object {
    private static string UserRegistrationString;
    private static ILog Logger;
    private static ProfilerRegistration();
    public static void Register(Registration registration);
    public static void Unregister(Registration registration);
    private static void ExecuteRegsvr32(bool userRegistration, bool register);
    private static int ExecuteProcess(ProcessStartInfo psi);
    private static void ExecuteRegsvr32(bool userRegistration, bool register, bool is64);
    private static string GetAssemblyLocation();
    public static string GetProfilerPath(bool is64);
    public static string GetProfilerPath(Registration registration);
}
public enum OpenCover.Framework.Registration : Enum {
    public int value__;
    public static Registration Normal;
    public static Registration User;
    public static Registration Path32;
    public static Registration Path64;
}
public enum OpenCover.Framework.SafeMode : Enum {
    public int value__;
    public static SafeMode On;
    public static SafeMode Yes;
    public static SafeMode Off;
    public static SafeMode No;
}
public interface OpenCover.Framework.Service.IProfilerCommunication {
    public abstract virtual bool TrackAssembly(string processPath, string modulePath, string assemblyName);
    public abstract virtual bool GetSequencePoints(string processPath, string modulePath, string assemblyName, int functionToken, InstrumentationPoint[]& sequencePoints);
    public abstract virtual bool GetBranchPoints(string processPath, string modulePath, string assemblyName, int functionToken, BranchPoint[]& branchPoints);
    public abstract virtual void Stopping();
    public abstract virtual bool TrackMethod(string modulePath, string assemblyName, int functionToken, UInt32& uniqueId);
    public abstract virtual bool TrackProcess(string processPath);
}
internal class OpenCover.Framework.Service.ProfilerCommunication : object {
    private IFilter _filter;
    private IPersistance _persistance;
    private IInstrumentationModelBuilderFactory _instrumentationModelBuilderFactory;
    public ProfilerCommunication(IFilter filter, IPersistance persistance, IInstrumentationModelBuilderFactory instrumentationModelBuilderFactory);
    public sealed virtual bool TrackAssembly(string processPath, string modulePath, string assemblyName);
    public sealed virtual bool GetBranchPoints(string processPath, string modulePath, string assemblyName, int functionToken, BranchPoint[]& instrumentPoints);
    public sealed virtual bool GetSequencePoints(string processPath, string modulePath, string assemblyName, int functionToken, InstrumentationPoint[]& instrumentPoints);
    private bool GetPoints(Func`1<bool> getPointsFunc, string processPath, string modulePath, string assemblyName, int functionToken, T[]& points);
    private bool CanReturnPoints(string processPath, string modulePath, string assemblyName, int functionToken);
    public sealed virtual void Stopping();
    public sealed virtual bool TrackMethod(string modulePath, string assemblyName, int functionToken, UInt32& uniqueId);
    public sealed virtual bool TrackProcess(string processPath);
}
public enum OpenCover.Framework.ServiceEnvironment : Enum {
    public int value__;
    public static ServiceEnvironment None;
    public static ServiceEnvironment ByName;
}
public interface OpenCover.Framework.Strategy.ITrackedMethodStrategy {
    public abstract virtual IEnumerable`1<TrackedMethod> GetTrackedMethods(IEnumerable`1<TypeDefinition> typeDefinitions);
}
public interface OpenCover.Framework.Strategy.ITrackedMethodStrategyManager {
    public abstract virtual TrackedMethod[] GetTrackedMethods(string assembly);
}
public class OpenCover.Framework.Strategy.TrackedMethodStrategyManager : object {
    private AppDomain _domain;
    private TrackedMethodStrategyProxy _proxy;
    private int _methodId;
    private bool _disposed;
    public sealed virtual TrackedMethod[] GetTrackedMethods(string assembly);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class OpenCover.Framework.Symbols.CecilSymbolManageExtensions : object {
    [ExtensionAttribute]
public static MethodBody SafeGetMethodBody(MethodDefinition methodDefinition);
}
internal class OpenCover.Framework.Symbols.CecilSymbolManager : object {
    private ICommandLine _commandLine;
    private IFilter _filter;
    private ILog _logger;
    private ITrackedMethodStrategyManager _trackedMethodStrategyManager;
    private ISymbolFileHelper _symbolFileHelper;
    private AssemblyDefinition _sourceAssembly;
    private Dictionary`2<int, MethodDefinition> _methodMap;
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    private static Regex CachedAnonymousDelegateFieldName;
    public string ModulePath { get; private set; }
    public string ModuleName { get; private set; }
    public AssemblyDefinition SourceAssembly { get; }
    public CecilSymbolManager(ICommandLine commandLine, IFilter filter, ILog logger, ITrackedMethodStrategyManager trackedMethodStrategyManager, ISymbolFileHelper symbolFileHelper);
    private static CecilSymbolManager();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ModulePath();
    [CompilerGeneratedAttribute]
private void set_ModulePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ModuleName();
    [CompilerGeneratedAttribute]
private void set_ModuleName(string value);
    public void Initialise(string modulePath, string moduleName);
    private AssemblyDefinition SearchForSymbolsAndLoad();
    public sealed virtual AssemblyDefinition get_SourceAssembly();
    public sealed virtual File[] GetFiles();
    public sealed virtual Class[] GetInstrumentableTypes();
    private static void GetInstrumentableTypes(IEnumerable`1<TypeDefinition> typeDefinitions, List`1<Class> classes, IFilter filter, string assemblyName);
    [IteratorStateMachineAttribute("OpenCover.Framework.Symbols.CecilSymbolManager/<GetInstructionsWithSequencePoints>d__23")]
private static IEnumerable`1<Tuple`2<Instruction, SequencePoint>> GetInstructionsWithSequencePoints(MethodDefinition methodDefinition);
    private static bool IgnoreSequencePointAtOffset(ICollection`1<Instruction> instructions, int offset);
    private static bool IsEmptyBranch(Instruction instruction);
    private static Class BuildClass(IFilter filter, string assemblyName, TypeDefinition typeDefinition);
    public sealed virtual Method[] GetMethodsForType(Class type, File[] files);
    private static string GetFirstFile(MethodDefinition methodDefinition);
    private static void GetMethodsForType(IEnumerable`1<TypeDefinition> typeDefinitions, string fullName, List`1<Method> methods, File[] files, IFilter filter, ICommandLine commandLine);
    private static void BuildMethods(ICollection`1<Method> methods, File[] files, IFilter filter, TypeDefinition typeDefinition, ICommandLine commandLine);
    private static void BuildPropertyMethods(ICollection`1<Method> methods, File[] files, IFilter filter, TypeDefinition typeDefinition, ICommandLine commandLine);
    private static Method BuildMethod(IEnumerable`1<File> files, IFilter filter, MethodDefinition methodDefinition, bool alreadySkippedDueToAttr, ICommandLine commandLine, TypeDefinition typeDefinition);
    public sealed virtual SequencePoint[] GetSequencePointsForToken(int token);
    public sealed virtual BranchPoint[] GetBranchPointsForToken(int token);
    public sealed virtual int GetCyclomaticComplexityForToken(int token);
    private void BuildMethodMap();
    private void BuildMethodMap(IEnumerable`1<TypeDefinition> typeDefinitions);
    private void GetSequencePointsForToken(int token, List`1<SequencePoint> list);
    private IList`1<ICollection`1<Instruction>> GetInstrumentedBlocks(MethodDefinition methodDefinition);
    private void GetBranchPointsForToken(int token, List`1<BranchPoint> list);
    private bool LoadPointsForConditionalBranch(List`1<BranchPoint> list, Instruction instruction, int branchingInstructionLine, string document, int branchOffset, int pathCounter, Collection`1<Instruction> instructions, UInt32& ordinal);
    private bool IgnoreConditionalBranchSequence(Instruction instruction, Collection`1<Instruction> instructions, int branchOffset);
    private UInt32 BuildPointsForConditionalBranch(List`1<BranchPoint> list, Instruction current, Instruction[] branchInstructions, int branchingInstructionLine, string document, int branchOffset, UInt32 ordinal, Int32& pathCounter);
    private List`1<int> GetConditionalBranchPath(Instruction instruction);
    private static Instruction FindClosestInstructionWithSequencePoint(MethodBody methodBody, Instruction instruction);
    private static bool HasValidSequencePoint(Instruction instruction, MethodDefinition methodDefinition);
    private MethodDefinition GetMethodDefinition(int token);
    private void GetCyclomaticComplexityForToken(int token, Int32& complexity);
    public sealed virtual TrackedMethod[] GetTrackedMethods();
}
internal interface OpenCover.Framework.Symbols.ISymbolFileHelper {
    public abstract virtual IEnumerable`1<string> GetSymbolFileLocations(string modulePath, ICommandLine commandLine);
}
public interface OpenCover.Framework.Symbols.ISymbolManager {
    public string ModulePath { get; }
    public string ModuleName { get; }
    public AssemblyDefinition SourceAssembly { get; }
    public abstract virtual string get_ModulePath();
    public abstract virtual string get_ModuleName();
    public abstract virtual File[] GetFiles();
    public abstract virtual Class[] GetInstrumentableTypes();
    public abstract virtual Method[] GetMethodsForType(Class type, File[] files);
    public abstract virtual SequencePoint[] GetSequencePointsForToken(int token);
    public abstract virtual BranchPoint[] GetBranchPointsForToken(int token);
    public abstract virtual int GetCyclomaticComplexityForToken(int token);
    public abstract virtual AssemblyDefinition get_SourceAssembly();
    public abstract virtual TrackedMethod[] GetTrackedMethods();
}
internal class OpenCover.Framework.Symbols.SymbolFileHelper : object {
    public sealed virtual IEnumerable`1<string> GetSymbolFileLocations(string modulePath, ICommandLine commandLine);
    private static string FindSymbolFile(string fileName, string targetfolder);
}
public class OpenCover.Framework.Utility.CodeCoverageStringTextSource : object {
    private FileType _fileType;
    private string _filePath;
    private bool _fileFound;
    private DateTime _fileTime;
    private string _textSource;
    private LineInfo[] _lines;
    private static ushort carriageReturn;
    private static ushort lineFeed;
    private bool cr;
    private bool lf;
    public FileType FileType { get; }
    public string FilePath { get; }
    public bool FileFound { get; }
    public DateTime FileTime { get; }
    public int LinesCount { get; }
    public CodeCoverageStringTextSource(string source, string filePath);
    public FileType get_FileType();
    public string get_FilePath();
    public bool get_FileFound();
    public DateTime get_FileTime();
    private LineInfo[] InitLines();
    private bool NextChar(ushort ch);
    public string GetText(SequencePoint sp);
    public string GetText(int startLine, int startColumn, int endLine, int endColumn);
    public int get_LinesCount();
    public string GetLine(int lineNo);
    public bool IsChanged(DateTime referenceTime);
    public static CodeCoverageStringTextSource GetSource(string filePath);
}
public enum OpenCover.Framework.Utility.FileType : Enum {
    public byte value__;
    public static FileType Unsupported;
    public static FileType CSharp;
}
public interface OpenCover.Framework.Utility.IPerfCounters {
    public long CurrentMemoryQueueSize { get; public set; }
    public abstract virtual long get_CurrentMemoryQueueSize();
    public abstract virtual void set_CurrentMemoryQueueSize(long value);
    public abstract virtual void IncrementBlocksReceived();
    public abstract virtual void ResetCounters();
}
[ExtensionAttribute]
public static class OpenCover.Framework.Utility.LogHelper : object {
    private static string loggerName;
    [ExtensionAttribute]
public static void InformUser(Exception e);
    [ExtensionAttribute]
public static void InformUser(string message);
    [ExtensionAttribute]
public static void InformUserSoft(string message);
}
[ExcludeFromCoverageAttribute("Performance counters can only be created by Administrators")]
public class OpenCover.Framework.Utility.NullPerfCounter : object {
    [CompilerGeneratedAttribute]
private long <CurrentMemoryQueueSize>k__BackingField;
    public long CurrentMemoryQueueSize { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void set_CurrentMemoryQueueSize(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_CurrentMemoryQueueSize();
    public sealed virtual void IncrementBlocksReceived();
    public sealed virtual void ResetCounters();
}
[ExcludeFromCoverageAttribute("Performance counters can only be created by Administrators")]
public class OpenCover.Framework.Utility.PerfCounters : object {
    private PerformanceCounter _memoryQueue;
    private PerformanceCounter _queueThroughput;
    private static string CategoryName;
    private static string MemoryQueue;
    private static string QueueThroughput;
    public long CurrentMemoryQueueSize { get; public set; }
    public sealed virtual long get_CurrentMemoryQueueSize();
    public sealed virtual void set_CurrentMemoryQueueSize(long value);
    public sealed virtual void IncrementBlocksReceived();
    private void CreateCounters();
    public sealed virtual void ResetCounters();
}
public class OpenCover.Framework.Utility.SequencePointComparer : EqualityComparer`1<SequencePoint> {
    public virtual bool Equals(SequencePoint x, SequencePoint y);
    public virtual int GetHashCode(SequencePoint obj);
}
[DefaultMemberAttribute("Item")]
public class OpenCover.Framework.Utility.SourceRepository : object {
    private IDictionary`2<UInt32, CodeCoverageStringTextSource> repo;
    public CodeCoverageStringTextSource Item { get; public set; }
    public ICollection`1<UInt32> Keys { get; }
    public ICollection`1<CodeCoverageStringTextSource> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public CodeCoverageStringTextSource GetCodeCoverageStringTextSource(UInt32 fileId);
    public string GetSequencePointText(SequencePoint sp);
    public sealed virtual bool ContainsKey(UInt32 key);
    public sealed virtual void Add(UInt32 key, CodeCoverageStringTextSource value);
    public sealed virtual bool Remove(UInt32 key);
    public sealed virtual bool TryGetValue(UInt32 key, CodeCoverageStringTextSource& value);
    public sealed virtual CodeCoverageStringTextSource get_Item(UInt32 key);
    public sealed virtual void set_Item(UInt32 key, CodeCoverageStringTextSource value);
    public sealed virtual ICollection`1<UInt32> get_Keys();
    public sealed virtual ICollection`1<CodeCoverageStringTextSource> get_Values();
    public sealed virtual void Add(KeyValuePair`2<UInt32, CodeCoverageStringTextSource> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<UInt32, CodeCoverageStringTextSource> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<UInt32, CodeCoverageStringTextSource> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<KeyValuePair`2<UInt32, CodeCoverageStringTextSource>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class OpenCover.Framework.Utility.ThreadHelper : object {
    public static void YieldOrSleep(int millisecondsInTimeout);
}
