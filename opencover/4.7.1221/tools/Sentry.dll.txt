[FlagsAttribute]
public enum Sentry.DeduplicateMode : Enum {
    public int value__;
    public static DeduplicateMode SameEvent;
    public static DeduplicateMode SameExceptionInstance;
    public static DeduplicateMode InnerException;
    public static DeduplicateMode AggregateException;
    public static DeduplicateMode All;
}
[AttributeUsageAttribute("1")]
public class Sentry.DsnAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Dsn>k__BackingField;
    public string Dsn { get; }
    public DsnAttribute(string dsn);
    [CompilerGeneratedAttribute]
public string get_Dsn();
}
public abstract class Sentry.Extensibility.BaseRequestPayloadExtractor : object {
    public sealed virtual object ExtractPayload(IHttpRequest request);
    protected abstract virtual bool IsSupported(IHttpRequest request);
    protected abstract virtual object DoExtractPayLoad(IHttpRequest request);
}
public class Sentry.Extensibility.DefaultRequestPayloadExtractor : BaseRequestPayloadExtractor {
    protected virtual bool IsSupported(IHttpRequest request);
    protected virtual object DoExtractPayLoad(IHttpRequest request);
}
[ExtensionAttribute]
internal static class Sentry.Extensibility.DiagnosticLoggerExtensions : object {
    [ExtensionAttribute]
public static void LogDebug(IDiagnosticLogger logger, string message, TArg arg);
    [ExtensionAttribute]
public static void LogDebug(IDiagnosticLogger logger, string message, TArg arg, TArg2 arg2);
    [ExtensionAttribute]
public static void LogDebug(IDiagnosticLogger logger, string message);
    [ExtensionAttribute]
public static void LogInfo(IDiagnosticLogger logger, string message);
    [ExtensionAttribute]
public static void LogInfo(IDiagnosticLogger logger, string message, TArg arg);
    [ExtensionAttribute]
public static void LogInfo(IDiagnosticLogger logger, string message, TArg arg, TArg2 arg2);
    [ExtensionAttribute]
public static void LogWarning(IDiagnosticLogger logger, string message);
    [ExtensionAttribute]
public static void LogWarning(IDiagnosticLogger logger, string message, TArg arg);
    [ExtensionAttribute]
public static void LogWarning(IDiagnosticLogger logger, string message, TArg arg, TArg2 arg2);
    [ExtensionAttribute]
public static void LogError(IDiagnosticLogger logger, string message, Exception exception);
    [ExtensionAttribute]
public static void LogError(IDiagnosticLogger logger, string message, Exception exception, TArg arg);
    [ExtensionAttribute]
public static void LogError(IDiagnosticLogger logger, string message, Exception exception, TArg arg, TArg2 arg2);
    [ExtensionAttribute]
public static void LogFatal(IDiagnosticLogger logger, string message, Exception exception);
    [ExtensionAttribute]
internal static void LogIfEnabled(IDiagnosticLogger logger, SentryLevel level, string message, Exception exception);
    [ExtensionAttribute]
internal static void LogIfEnabled(IDiagnosticLogger logger, SentryLevel level, string message, TArg arg, Exception exception);
    [ExtensionAttribute]
internal static void LogIfEnabled(IDiagnosticLogger logger, SentryLevel level, string message, TArg arg, TArg2 arg2, Exception exception);
    [ExtensionAttribute]
internal static void LogIfEnabled(IDiagnosticLogger logger, SentryLevel level, string message, TArg arg, TArg2 arg2, TArg3 arg3, Exception exception);
}
public class Sentry.Extensibility.DisabledHub : object {
    public static DisabledHub Instance;
    public bool IsEnabled { get; }
    public SentryId LastEventId { get; }
    private static DisabledHub();
    public sealed virtual bool get_IsEnabled();
    public sealed virtual void ConfigureScope(Action`1<Scope> configureScope);
    public sealed virtual Task ConfigureScopeAsync(Func`2<Scope, Task> configureScope);
    public sealed virtual IDisposable PushScope();
    public sealed virtual IDisposable PushScope(TState state);
    public sealed virtual void WithScope(Action`1<Scope> scopeCallback);
    public sealed virtual void BindClient(ISentryClient client);
    public sealed virtual SentryId CaptureEvent(SentryEvent evt, Scope scope);
    public sealed virtual Task FlushAsync(TimeSpan timeout);
    public sealed virtual void Dispose();
    public sealed virtual SentryId get_LastEventId();
}
public class Sentry.Extensibility.FormRequestPayloadExtractor : BaseRequestPayloadExtractor {
    private static string SupportedContentType;
    protected virtual bool IsSupported(IHttpRequest request);
    protected virtual object DoExtractPayLoad(IHttpRequest request);
}
[DebuggerStepThroughAttribute]
public class Sentry.Extensibility.HubAdapter : object {
    public static HubAdapter Instance;
    public bool IsEnabled { get; }
    public SentryId LastEventId { get; }
    private static HubAdapter();
    [DebuggerStepThroughAttribute]
public sealed virtual bool get_IsEnabled();
    [DebuggerStepThroughAttribute]
public sealed virtual SentryId get_LastEventId();
    [DebuggerStepThroughAttribute]
public sealed virtual void ConfigureScope(Action`1<Scope> configureScope);
    [DebuggerStepThroughAttribute]
public sealed virtual Task ConfigureScopeAsync(Func`2<Scope, Task> configureScope);
    [DebuggerStepThroughAttribute]
public sealed virtual IDisposable PushScope();
    [DebuggerStepThroughAttribute]
public sealed virtual IDisposable PushScope(TState state);
    [DebuggerStepThroughAttribute]
public sealed virtual void WithScope(Action`1<Scope> scopeCallback);
    [DebuggerStepThroughAttribute]
public sealed virtual void BindClient(ISentryClient client);
    [DebuggerStepThroughAttribute]
public void AddBreadcrumb(string message, string category, string type, IDictionary`2<string, string> data, BreadcrumbLevel level);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public void AddBreadcrumb(ISystemClock clock, string message, string category, string type, IDictionary`2<string, string> data, BreadcrumbLevel level);
    [DebuggerStepThroughAttribute]
public SentryId CaptureEvent(SentryEvent evt);
    [DebuggerStepThroughAttribute]
public SentryId CaptureException(Exception exception);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public sealed virtual SentryId CaptureEvent(SentryEvent evt, Scope scope);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public sealed virtual Task FlushAsync(TimeSpan timeout);
}
public interface Sentry.Extensibility.IBackgroundWorker {
    public int QueuedItems { get; }
    public abstract virtual bool EnqueueEvent(SentryEvent event);
    public abstract virtual Task FlushAsync(TimeSpan timeout);
    public abstract virtual int get_QueuedItems();
}
public interface Sentry.Extensibility.IDiagnosticLogger {
    public abstract virtual bool IsEnabled(SentryLevel level);
    public abstract virtual void Log(SentryLevel logLevel, string message, Exception exception, Object[] args);
}
public interface Sentry.Extensibility.IExceptionFilter {
    public abstract virtual bool Filter(Exception ex);
}
public interface Sentry.Extensibility.IHttpRequest {
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public Stream Body { get; }
    public IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> Form { get; }
    public abstract virtual Nullable`1<long> get_ContentLength();
    public abstract virtual string get_ContentType();
    public abstract virtual Stream get_Body();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> get_Form();
}
public interface Sentry.Extensibility.IRequestPayloadExtractor {
    public abstract virtual object ExtractPayload(IHttpRequest request);
}
public interface Sentry.Extensibility.ISentryEventExceptionProcessor {
    public abstract virtual void Process(Exception exception, SentryEvent sentryEvent);
}
public interface Sentry.Extensibility.ISentryEventProcessor {
    public abstract virtual SentryEvent Process(SentryEvent event);
}
public interface Sentry.Extensibility.ISentryStackTraceFactory {
    public abstract virtual SentryStackTrace Create(Exception exception);
}
public interface Sentry.Extensibility.ITransport {
    public abstract virtual Task CaptureEventAsync(SentryEvent event, CancellationToken cancellationToken);
}
public class Sentry.Extensibility.RequestBodyExtractionDispatcher : object {
    private SentryOptions _options;
    private Func`1<RequestSize> _sizeSwitch;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRequestPayloadExtractor> <Extractors>k__BackingField;
    internal IEnumerable`1<IRequestPayloadExtractor> Extractors { get; }
    public RequestBodyExtractionDispatcher(IEnumerable`1<IRequestPayloadExtractor> extractors, SentryOptions options, Func`1<RequestSize> sizeSwitch);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<IRequestPayloadExtractor> get_Extractors();
    public sealed virtual object ExtractPayload(IHttpRequest request);
}
public enum Sentry.Extensibility.RequestSize : Enum {
    public int value__;
    public static RequestSize None;
    public static RequestSize Small;
    public static RequestSize Medium;
    public static RequestSize Always;
}
public abstract class Sentry.Extensibility.SentryEventExceptionProcessor`1 : object {
    public sealed virtual void Process(Exception exception, SentryEvent sentryEvent);
    protected internal abstract virtual void ProcessException(TException exception, SentryEvent sentryEvent);
}
public class Sentry.Extensibility.SentryStackTraceFactory : object {
    private SentryOptions _options;
    public SentryStackTraceFactory(SentryOptions options);
    public sealed virtual SentryStackTrace Create(Exception exception);
    protected virtual StackTrace CreateStackTrace(Exception exception);
    internal SentryStackTrace Create(StackTrace stackTrace, bool isCurrentStackTrace);
    [IteratorStateMachineAttribute("Sentry.Extensibility.SentryStackTraceFactory/<CreateFrames>d__5")]
internal IEnumerable`1<SentryStackFrame> CreateFrames(StackTrace stackTrace, bool isCurrentStackTrace);
    internal SentryStackFrame CreateFrame(StackFrame stackFrame);
    protected virtual SentryStackFrame CreateFrame(StackFrame stackFrame, bool isCurrentStackTrace);
    protected SentryStackFrame InternalCreateFrame(StackFrame stackFrame, bool demangle);
    protected virtual MethodBase GetMethod(StackFrame stackFrame);
    private bool IsSystemModuleName(string moduleName);
    private static void DemangleAsyncFunctionName(SentryStackFrame frame);
    internal static void DemangleAnonymousFunction(SentryStackFrame frame);
}
public interface Sentry.Http.ISentryHttpClientFactory {
    public abstract virtual HttpClient Create(Dsn dsn, SentryOptions options);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Sentry.HubExtensions : object {
    [ExtensionAttribute]
public static void AddBreadcrumb(IHub hub, string message, string category, string type, IDictionary`2<string, string> data, BreadcrumbLevel level);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void AddBreadcrumb(IHub hub, ISystemClock clock, string message, string category, string type, IDictionary`2<string, string> data, BreadcrumbLevel level);
    [ExtensionAttribute]
public static IDisposable PushAndLockScope(IHub hub);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void LockScope(IHub hub);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void UnlockScope(IHub hub);
}
public interface Sentry.IHub {
    public SentryId LastEventId { get; }
    public abstract virtual SentryId get_LastEventId();
}
public class Sentry.Infrastructure.ConsoleDiagnosticLogger : object {
    private SentryLevel _minimalLevel;
    public ConsoleDiagnosticLogger(SentryLevel minimalLevel);
    public sealed virtual bool IsEnabled(SentryLevel level);
    public sealed virtual void Log(SentryLevel logLevel, string message, Exception exception, Object[] args);
}
public class Sentry.Infrastructure.DebugDiagnosticLogger : object {
    private SentryLevel _minimalLevel;
    public DebugDiagnosticLogger(SentryLevel minimalLevel);
    public sealed virtual bool IsEnabled(SentryLevel level);
    public sealed virtual void Log(SentryLevel logLevel, string message, Exception exception, Object[] args);
}
public interface Sentry.Infrastructure.ISystemClock {
    public abstract virtual DateTimeOffset GetUtcNow();
}
public class Sentry.Infrastructure.SystemClock : object {
    public static SystemClock Clock;
    private static SystemClock();
    public sealed virtual DateTimeOffset GetUtcNow();
}
internal class Sentry.Integrations.AppDomainProcessExitIntegration : object {
    private IAppDomain _appDomain;
    private IHub _hub;
    public AppDomainProcessExitIntegration(IAppDomain appDomain);
    public sealed virtual void Register(IHub hub, SentryOptions options);
    public sealed virtual void Unregister(IHub hub);
    internal void HandleProcessExit(object sender, EventArgs e);
}
internal class Sentry.Integrations.AppDomainUnhandledExceptionIntegration : object {
    private IAppDomain _appDomain;
    private IHub _hub;
    internal AppDomainUnhandledExceptionIntegration(IAppDomain appDomain);
    public sealed virtual void Register(IHub hub, SentryOptions _);
    public sealed virtual void Unregister(IHub hub);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecurityCriticalAttribute]
internal void Handle(object sender, UnhandledExceptionEventArgs e);
}
public interface Sentry.Integrations.ISdkIntegration {
    public abstract virtual void Register(IHub hub, SentryOptions options);
}
internal class Sentry.Integrations.TaskUnobservedTaskExceptionIntegration : object {
    private IAppDomain _appDomain;
    private IHub _hub;
    internal TaskUnobservedTaskExceptionIntegration(IAppDomain appDomain);
    public sealed virtual void Register(IHub hub, SentryOptions _);
    public sealed virtual void Unregister(IHub hub);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecurityCriticalAttribute]
internal void Handle(object sender, UnobservedTaskExceptionEventArgs e);
}
internal class Sentry.Internal.AppDomainAdapter : object {
    [CompilerGeneratedAttribute]
private static AppDomainAdapter <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private UnhandledExceptionEventHandler UnhandledException;
    [CompilerGeneratedAttribute]
private EventHandler ProcessExit;
    [CompilerGeneratedAttribute]
private EventHandler`1<UnobservedTaskExceptionEventArgs> UnobservedTaskException;
    public static AppDomainAdapter Instance { get; }
    private static AppDomainAdapter();
    [CompilerGeneratedAttribute]
public static AppDomainAdapter get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    private void OnProcessExit(object sender, EventArgs e);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecurityCriticalAttribute]
private void OnUnhandledException(object sender, UnhandledExceptionEventArgs e);
    [HandleProcessCorruptedStateExceptionsAttribute]
[SecurityCriticalAttribute]
private void OnUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e);
}
internal static class Sentry.Internal.ApplicationVersionLocator : object {
    public static string GetCurrent();
    internal static string GetCurrent(Assembly asm);
}
internal class Sentry.Internal.BackgroundWorker : object {
    private SentryOptions _options;
    private ConcurrentQueue`1<SentryEvent> _queue;
    private CancellationTokenSource _shutdownSource;
    private SemaphoreSlim _queuedEventSemaphore;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private int _maxItems;
    private int _currentItems;
    [CompilerGeneratedAttribute]
private EventHandler OnFlushObjectReceived;
    [CompilerGeneratedAttribute]
private Task <WorkerTask>k__BackingField;
    internal Task WorkerTask { get; }
    public int QueuedItems { get; }
    public BackgroundWorker(ITransport transport, SentryOptions options);
    internal BackgroundWorker(ITransport transport, SentryOptions options, CancellationTokenSource shutdownSource, ConcurrentQueue`1<SentryEvent> queue);
    [CompilerGeneratedAttribute]
private void add_OnFlushObjectReceived(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove_OnFlushObjectReceived(EventHandler value);
    [CompilerGeneratedAttribute]
internal Task get_WorkerTask();
    public sealed virtual int get_QueuedItems();
    public sealed virtual bool EnqueueEvent(SentryEvent event);
    [AsyncStateMachineAttribute("Sentry.Internal.BackgroundWorker/<WorkerAsync>d__18")]
private Task WorkerAsync(ConcurrentQueue`1<SentryEvent> queue, SentryOptions options, ITransport transport, SemaphoreSlim queuedEventSemaphore, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Sentry.Internal.BackgroundWorker/<FlushAsync>d__19")]
public sealed virtual Task FlushAsync(TimeSpan timeout);
    public sealed virtual void Dispose();
}
internal static class Sentry.Internal.Constants : object {
    public static string DsnEnvironmentVariable;
    public static string ReleaseEnvironmentVariable;
    public static string EnvironmentEnvironmentVariable;
    public static string SdkName;
}
internal class Sentry.Internal.DelegateEventProcessor : object {
    private Func`2<SentryEvent, SentryEvent> _func;
    public DelegateEventProcessor(Func`2<SentryEvent, SentryEvent> func);
    public sealed virtual SentryEvent Process(SentryEvent event);
}
internal static class Sentry.Internal.DsnLocator : object {
    internal static string FindDsnStringOrDisable(Assembly asm);
    internal static string FindDsn(Assembly asm);
}
internal class Sentry.Internal.DuplicateEventDetectionEventProcessor : object {
    private SentryOptions _options;
    private ConditionalWeakTable`2<object, object> _capturedObjects;
    public DuplicateEventDetectionEventProcessor(SentryOptions options);
    public sealed virtual SentryEvent Process(SentryEvent event);
    private bool IsDuplicate(Exception ex);
}
internal static class Sentry.Internal.EnvironmentLocator : object {
    private static Lazy`1<string> Environment;
    public static string Current { get; }
    private static EnvironmentLocator();
    public static string get_Current();
    internal static string Locate();
}
internal class Sentry.Internal.ExceptionTypeFilter`1 : object {
    private Type _filteredType;
    public sealed virtual bool Filter(Exception ex);
}
internal class Sentry.Internal.Http.DefaultSentryHttpClientFactory : object {
    private Action`2<HttpClientHandler, Dsn> _configureHandler;
    private Action`2<HttpClient, Dsn> _configureClient;
    public DefaultSentryHttpClientFactory(Action`2<HttpClientHandler, Dsn> configureHandler, Action`2<HttpClient, Dsn> configureClient);
    public sealed virtual HttpClient Create(Dsn dsn, SentryOptions options);
}
internal class Sentry.Internal.Http.GzipBufferedRequestBodyHandler : DelegatingHandler {
    private static string Gzip;
    private CompressionLevel _compressionLevel;
    public GzipBufferedRequestBodyHandler(HttpMessageHandler innerHandler, CompressionLevel compressionLevel);
    [AsyncStateMachineAttribute("Sentry.Internal.Http.GzipBufferedRequestBodyHandler/<SendAsync>d__3")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class Sentry.Internal.Http.GzipRequestBodyHandler : DelegatingHandler {
    private static string Gzip;
    private CompressionLevel _compressionLevel;
    public GzipRequestBodyHandler(HttpMessageHandler innerHandler, CompressionLevel compressionLevel);
    protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class Sentry.Internal.Http.HttpTransport : object {
    private SentryOptions _options;
    private HttpClient _httpClient;
    private Action`1<HttpRequestHeaders> _addAuth;
    internal static string NoMessageFallback;
    public HttpTransport(SentryOptions options, HttpClient httpClient, Action`1<HttpRequestHeaders> addAuth);
    [AsyncStateMachineAttribute("Sentry.Internal.Http.HttpTransport/<CaptureEventAsync>d__5")]
public sealed virtual Task CaptureEventAsync(SentryEvent event, CancellationToken cancellationToken);
    internal HttpRequestMessage CreateRequest(SentryEvent event);
}
internal class Sentry.Internal.Http.RetryAfterHandler : DelegatingHandler {
    private ISystemClock _clock;
    private static HttpStatusCode TooManyRequests;
    private long _retryAfterUtcTicks;
    private HttpResponseMessage _tooManyRequestsResponse;
    internal long RetryAfterUtcTicks { get; }
    public RetryAfterHandler(HttpMessageHandler innerHandler);
    internal RetryAfterHandler(HttpMessageHandler innerHandler, ISystemClock clock);
    internal long get_RetryAfterUtcTicks();
    [AsyncStateMachineAttribute("Sentry.Internal.Http.RetryAfterHandler/<SendAsync>d__8")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal static class Sentry.Internal.Http.SentryHeaders : object {
    public static string SentryErrorHeader;
    public static string SentryAuthHeader;
    public static Action`1<HttpRequestHeaders> AddSentryAuth(int sentryVersion, string clientVersion, string publicKey, string secretKey, ISystemClock clock);
}
internal class Sentry.Internal.Hub : object {
    private SentryOptions _options;
    private ISdkIntegration[] _integrations;
    private IDisposable _rootScope;
    private SentryClient _ownedClient;
    [CompilerGeneratedAttribute]
private SentryScopeManager <ScopeManager>k__BackingField;
    internal SentryScopeManager ScopeManager { get; }
    public bool IsEnabled { get; }
    public SentryId LastEventId { get; }
    public Hub(SentryOptions options);
    [CompilerGeneratedAttribute]
internal SentryScopeManager get_ScopeManager();
    public sealed virtual bool get_IsEnabled();
    public sealed virtual void ConfigureScope(Action`1<Scope> configureScope);
    [AsyncStateMachineAttribute("Sentry.Internal.Hub/<ConfigureScopeAsync>d__11")]
public sealed virtual Task ConfigureScopeAsync(Func`2<Scope, Task> configureScope);
    public sealed virtual IDisposable PushScope();
    public sealed virtual IDisposable PushScope(TState state);
    public sealed virtual void WithScope(Action`1<Scope> scopeCallback);
    public sealed virtual void BindClient(ISentryClient client);
    public sealed virtual SentryId CaptureEvent(SentryEvent evt, Scope scope);
    [AsyncStateMachineAttribute("Sentry.Internal.Hub/<FlushAsync>d__17")]
public sealed virtual Task FlushAsync(TimeSpan timeout);
    public sealed virtual void Dispose();
    public sealed virtual SentryId get_LastEventId();
}
internal interface Sentry.Internal.IAppDomain {
    [CompilerGeneratedAttribute]
public abstract virtual void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
}
internal interface Sentry.Internal.IInternalScopeManager {
    public abstract virtual KeyValuePair`2<Scope, ISentryClient> GetCurrent();
}
internal interface Sentry.Internal.IInternalSdkIntegration {
    public abstract virtual void Unregister(IHub hub);
}
internal static class Sentry.Internal.JsonSerializer : object {
    private static StringEnumConverter StringEnumConverter;
    private static JsonSerializerSettings Settings;
    private static JsonSerializer();
    public static string SerializeObject(T object);
    public static object DeserializeObject(string json);
}
internal class Sentry.Internal.MainExceptionProcessor : object {
    private SentryOptions _options;
    [CompilerGeneratedAttribute]
private Func`1<ISentryStackTraceFactory> <SentryStackTraceFactoryAccessor>k__BackingField;
    internal Func`1<ISentryStackTraceFactory> SentryStackTraceFactoryAccessor { get; }
    public MainExceptionProcessor(SentryOptions options, Func`1<ISentryStackTraceFactory> sentryStackTraceFactoryAccessor);
    [CompilerGeneratedAttribute]
internal Func`1<ISentryStackTraceFactory> get_SentryStackTraceFactoryAccessor();
    public sealed virtual void Process(Exception exception, SentryEvent sentryEvent);
    private static void MoveExceptionExtrasToEvent(SentryEvent sentryEvent, IReadOnlyList`1<SentryException> sentryExceptions);
    [IteratorStateMachineAttribute("Sentry.Internal.MainExceptionProcessor/<CreateSentryException>d__7")]
internal IEnumerable`1<SentryException> CreateSentryException(Exception exception);
    internal static Mechanism GetMechanism(Exception exception);
}
internal class Sentry.Internal.MainSentryEventProcessor : object {
    private Lazy`1<string> _release;
    private Lazy`1<Runtime> _runtime;
    private static SdkVersion NameAndVersion;
    private static string ProtocolPackageName;
    private SentryOptions _options;
    [CompilerGeneratedAttribute]
private Func`1<ISentryStackTraceFactory> <SentryStackTraceFactoryAccessor>k__BackingField;
    internal Func`1<ISentryStackTraceFactory> SentryStackTraceFactoryAccessor { get; }
    internal string Release { get; }
    internal Runtime Runtime { get; }
    public MainSentryEventProcessor(SentryOptions options, Func`1<ISentryStackTraceFactory> sentryStackTraceFactoryAccessor);
    private static MainSentryEventProcessor();
    [CompilerGeneratedAttribute]
internal Func`1<ISentryStackTraceFactory> get_SentryStackTraceFactoryAccessor();
    internal string get_Release();
    internal Runtime get_Runtime();
    public sealed virtual SentryEvent Process(SentryEvent event);
    private static IDictionary`2<string, string> CultureInfoToDictionary(CultureInfo cultureInfo);
}
internal class Sentry.Internal.OptionalHub : object {
    private IHub _hub;
    public bool IsEnabled { get; }
    public SentryId LastEventId { get; }
    public OptionalHub(SentryOptions options);
    public sealed virtual bool get_IsEnabled();
    public sealed virtual SentryId CaptureEvent(SentryEvent evt, Scope scope);
    public sealed virtual Task FlushAsync(TimeSpan timeout);
    public sealed virtual void ConfigureScope(Action`1<Scope> configureScope);
    public sealed virtual Task ConfigureScopeAsync(Func`2<Scope, Task> configureScope);
    public sealed virtual void BindClient(ISentryClient client);
    public sealed virtual IDisposable PushScope();
    public sealed virtual IDisposable PushScope(TState state);
    public sealed virtual void WithScope(Action`1<Scope> scopeCallback);
    public sealed virtual SentryId get_LastEventId();
    public sealed virtual void Dispose();
}
internal static class Sentry.Internal.ReleaseLocator : object {
    public static string GetCurrent();
}
internal class Sentry.Internal.SdkComposer : object {
    private SentryOptions _options;
    public SdkComposer(SentryOptions options);
    public IBackgroundWorker CreateBackgroundWorker();
}
internal class Sentry.Internal.SentryScopeManager : object {
    private SentryOptions _options;
    private AsyncLocal`1<KeyValuePair`2[]> _asyncLocalScope;
    [CompilerGeneratedAttribute]
private Func`1<KeyValuePair`2[]> <NewStack>k__BackingField;
    internal KeyValuePair`2[] ScopeAndClientStack { get; internal set; }
    private Func`1<KeyValuePair`2[]> NewStack { get; }
    public SentryScopeManager(SentryOptions options, ISentryClient rootClient);
    internal KeyValuePair`2[] get_ScopeAndClientStack();
    internal void set_ScopeAndClientStack(KeyValuePair`2[] value);
    [CompilerGeneratedAttribute]
private Func`1<KeyValuePair`2[]> get_NewStack();
    public sealed virtual KeyValuePair`2<Scope, ISentryClient> GetCurrent();
    public sealed virtual void ConfigureScope(Action`1<Scope> configureScope);
    public sealed virtual Task ConfigureScopeAsync(Func`2<Scope, Task> configureScope);
    public sealed virtual IDisposable PushScope();
    public sealed virtual IDisposable PushScope(TState state);
    public sealed virtual void WithScope(Action`1<Scope> scopeCallback);
    public sealed virtual void BindClient(ISentryClient client);
    public sealed virtual void Dispose();
}
internal class Sentry.Internal.Web.SystemWebHttpRequest : object {
    private HttpRequest _request;
    public Nullable`1<long> ContentLength { get; }
    public string ContentType { get; }
    public Stream Body { get; }
    public IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> Form { get; }
    public SystemWebHttpRequest(HttpRequest request);
    public sealed virtual Nullable`1<long> get_ContentLength();
    public sealed virtual string get_ContentType();
    public sealed virtual Stream get_Body();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, IEnumerable`1<string>>> get_Form();
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, IEnumerable`1<string>> <get_Form>b__8_0(string kv);
}
internal class Sentry.Internal.Web.SystemWebRequestEventProcessor : object {
    private SentryOptions _options;
    [CompilerGeneratedAttribute]
private IRequestPayloadExtractor <PayloadExtractor>k__BackingField;
    internal IRequestPayloadExtractor PayloadExtractor { get; }
    public SystemWebRequestEventProcessor(IRequestPayloadExtractor payloadExtractor, SentryOptions options);
    [CompilerGeneratedAttribute]
internal IRequestPayloadExtractor get_PayloadExtractor();
    public sealed virtual SentryEvent Process(SentryEvent event);
}
public interface Sentry.ISentryClient {
    public bool IsEnabled { get; }
    public abstract virtual bool get_IsEnabled();
    public abstract virtual SentryId CaptureEvent(SentryEvent evt, Scope scope);
    public abstract virtual Task FlushAsync(TimeSpan timeout);
}
public interface Sentry.ISentryScopeManager {
    public abstract virtual void ConfigureScope(Action`1<Scope> configureScope);
    public abstract virtual Task ConfigureScopeAsync(Func`2<Scope, Task> configureScope);
    public abstract virtual void BindClient(ISentryClient client);
    public abstract virtual IDisposable PushScope();
    public abstract virtual IDisposable PushScope(TState state);
    public abstract virtual void WithScope(Action`1<Scope> scopeCallback);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Sentry.Reflection.AssemblyExtensions : object {
    [ExtensionAttribute]
public static SdkVersion GetNameAndVersion(Assembly asm);
}
public class Sentry.Scope : BaseScope {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _hasEvaluated;
    private object _evaluationSync;
    [CompilerGeneratedAttribute]
private bool <Locked>k__BackingField;
    [CompilerGeneratedAttribute]
private SentryOptions <Options>k__BackingField;
    private object _lastEventIdSync;
    private SentryId _lastEventId;
    private Lazy`1<ConcurrentBag`1<ISentryEventExceptionProcessor>> _lazyExceptionProcessors;
    private Lazy`1<ConcurrentBag`1<ISentryEventProcessor>> _lazyEventProcessors;
    [CompilerGeneratedAttribute]
private EventHandler OnEvaluating;
    internal bool Locked { get; internal set; }
    internal SentryOptions Options { get; }
    internal SentryId LastEventId { get; internal set; }
    internal bool HasEvaluated { get; }
    internal ConcurrentBag`1<ISentryEventExceptionProcessor> ExceptionProcessors { get; }
    internal ConcurrentBag`1<ISentryEventProcessor> EventProcessors { get; }
    public Scope(SentryOptions options);
    [CompilerGeneratedAttribute]
internal bool get_Locked();
    [CompilerGeneratedAttribute]
internal void set_Locked(bool value);
    [CompilerGeneratedAttribute]
internal SentryOptions get_Options();
    internal SentryId get_LastEventId();
    internal void set_LastEventId(SentryId value);
    internal bool get_HasEvaluated();
    internal ConcurrentBag`1<ISentryEventExceptionProcessor> get_ExceptionProcessors();
    internal ConcurrentBag`1<ISentryEventProcessor> get_EventProcessors();
    [CompilerGeneratedAttribute]
internal void add_OnEvaluating(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_OnEvaluating(EventHandler value);
    public Scope Clone();
    internal void Evaluate();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Sentry.ScopeExtensions : object {
    [IteratorStateMachineAttribute("Sentry.ScopeExtensions/<GetAllEventProcessors>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<ISentryEventProcessor> GetAllEventProcessors(Scope scope);
    [IteratorStateMachineAttribute("Sentry.ScopeExtensions/<GetAllExceptionProcessors>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<ISentryEventExceptionProcessor> GetAllExceptionProcessors(Scope scope);
    [ExtensionAttribute]
public static void AddExceptionProcessor(Scope scope, ISentryEventExceptionProcessor processor);
    [ExtensionAttribute]
public static void AddExceptionProcessors(Scope scope, IEnumerable`1<ISentryEventExceptionProcessor> processors);
    [ExtensionAttribute]
public static void AddEventProcessor(Scope scope, ISentryEventProcessor processor);
    [ExtensionAttribute]
public static void AddEventProcessor(Scope scope, Func`2<SentryEvent, SentryEvent> processor);
    [ExtensionAttribute]
public static void AddEventProcessors(Scope scope, IEnumerable`1<ISentryEventProcessor> processors);
}
public class Sentry.SentryClient : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private SentryOptions _options;
    private Lazy`1<Random> _random;
    [CompilerGeneratedAttribute]
private IBackgroundWorker <Worker>k__BackingField;
    internal Random Random { get; }
    internal IBackgroundWorker Worker { get; }
    public bool IsEnabled { get; }
    public SentryClient(SentryOptions options);
    internal SentryClient(SentryOptions options, IBackgroundWorker worker);
    internal Random get_Random();
    [CompilerGeneratedAttribute]
internal IBackgroundWorker get_Worker();
    public sealed virtual bool get_IsEnabled();
    public sealed virtual SentryId CaptureEvent(SentryEvent event, Scope scope);
    public sealed virtual Task FlushAsync(TimeSpan timeout);
    private SentryId DoSendEvent(SentryEvent event, Scope scope);
    private SentryEvent BeforeSend(SentryEvent event);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Sentry.SentryClientExtensions : object {
    [ExtensionAttribute]
public static SentryId CaptureException(ISentryClient client, Exception ex);
    [ExtensionAttribute]
public static SentryId CaptureMessage(ISentryClient client, string message, SentryLevel level);
}
public class Sentry.SentryOptions : object {
    private Func`1<ISentryStackTraceFactory> _sentryStackTraceFactoryAccessor;
    [CompilerGeneratedAttribute]
private ISentryStackTraceFactory <SentryStackTraceFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SentryVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ISentryEventExceptionProcessor[] <ExceptionProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISentryEventProcessor[] <EventProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1[] <EventProcessorsProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1[] <ExceptionProcessorsProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private ISdkIntegration[] <Integrations>k__BackingField;
    [CompilerGeneratedAttribute]
private IExceptionFilter[] <ExceptionFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private IBackgroundWorker <BackgroundWorker>k__BackingField;
    [CompilerGeneratedAttribute]
private ISentryHttpClientFactory <SentryHttpClientFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ISentryScopeStateProcessor <SentryScopeStateProcessor>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <InAppExclude>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <InAppInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendDefaultPii>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnvironmentUser>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AttachStacktrace>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBreadcrumbs>k__BackingField;
    private Nullable`1<float> _sampleRate;
    [CompilerGeneratedAttribute]
private string <Release>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private Dsn <Dsn>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<SentryEvent, SentryEvent> <BeforeSend>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Breadcrumb, Breadcrumb> <BeforeBreadcrumb>k__BackingField;
    private int _maxQueueItems;
    [CompilerGeneratedAttribute]
private TimeSpan <ShutdownTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private DecompressionMethods <DecompressionMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <RequestBodyCompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestBodyCompressionBuffered>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <HttpProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<HttpClientHandler, Dsn> <ConfigureHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Dsn, HttpClientHandler> <CreateHttpClientHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<HttpClient, Dsn> <ConfigureClient>k__BackingField;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _debug;
    [CompilerGeneratedAttribute]
private SentryLevel <DiagnosticsLevel>k__BackingField;
    private IDiagnosticLogger modreq(System.Runtime.CompilerServices.IsVolatile) _diagnosticLogger;
    [CompilerGeneratedAttribute]
private bool <ReportAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private DeduplicateMode <DeduplicateMode>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestSize <MaxRequestBodySize>k__BackingField;
    internal ISentryStackTraceFactory SentryStackTraceFactory { get; internal set; }
    internal string ClientVersion { get; }
    internal int SentryVersion { get; }
    internal ISentryEventExceptionProcessor[] ExceptionProcessors { get; internal set; }
    internal ISentryEventProcessor[] EventProcessors { get; internal set; }
    internal Func`1[] EventProcessorsProviders { get; internal set; }
    internal Func`1[] ExceptionProcessorsProviders { get; internal set; }
    internal ISdkIntegration[] Integrations { get; internal set; }
    internal IExceptionFilter[] ExceptionFilters { get; internal set; }
    internal IBackgroundWorker BackgroundWorker { get; internal set; }
    internal ISentryHttpClientFactory SentryHttpClientFactory { get; internal set; }
    public ISentryScopeStateProcessor SentryScopeStateProcessor { get; public set; }
    internal String[] InAppExclude { get; internal set; }
    internal String[] InAppInclude { get; internal set; }
    public bool SendDefaultPii { get; public set; }
    public bool IsEnvironmentUser { get; public set; }
    public string ServerName { get; public set; }
    public bool AttachStacktrace { get; public set; }
    public int MaxBreadcrumbs { get; public set; }
    public Nullable`1<float> SampleRate { get; public set; }
    public string Release { get; public set; }
    public string Environment { get; public set; }
    public Dsn Dsn { get; public set; }
    public Func`2<SentryEvent, SentryEvent> BeforeSend { get; public set; }
    public Func`2<Breadcrumb, Breadcrumb> BeforeBreadcrumb { get; public set; }
    public int MaxQueueItems { get; public set; }
    public TimeSpan ShutdownTimeout { get; public set; }
    public DecompressionMethods DecompressionMethods { get; public set; }
    public CompressionLevel RequestBodyCompressionLevel { get; public set; }
    public bool RequestBodyCompressionBuffered { get; public set; }
    public IWebProxy HttpProxy { get; public set; }
    [ObsoleteAttribute("Please use 'CreateHttpClientHandler' instead. You can create an instance of 'HttpClientHandler' and modify it at once.")]
public Action`2<HttpClientHandler, Dsn> ConfigureHandler { get; public set; }
    public Func`2<Dsn, HttpClientHandler> CreateHttpClientHandler { get; public set; }
    public Action`2<HttpClient, Dsn> ConfigureClient { get; public set; }
    public bool Debug { get; public set; }
    public SentryLevel DiagnosticsLevel { get; public set; }
    public IDiagnosticLogger DiagnosticLogger { get; public set; }
    public bool ReportAssemblies { get; public set; }
    public DeduplicateMode DeduplicateMode { get; public set; }
    public RequestSize MaxRequestBodySize { get; public set; }
    [CompilerGeneratedAttribute]
internal ISentryStackTraceFactory get_SentryStackTraceFactory();
    [CompilerGeneratedAttribute]
internal void set_SentryStackTraceFactory(ISentryStackTraceFactory value);
    [CompilerGeneratedAttribute]
internal string get_ClientVersion();
    [CompilerGeneratedAttribute]
internal int get_SentryVersion();
    [CompilerGeneratedAttribute]
internal ISentryEventExceptionProcessor[] get_ExceptionProcessors();
    [CompilerGeneratedAttribute]
internal void set_ExceptionProcessors(ISentryEventExceptionProcessor[] value);
    [CompilerGeneratedAttribute]
internal ISentryEventProcessor[] get_EventProcessors();
    [CompilerGeneratedAttribute]
internal void set_EventProcessors(ISentryEventProcessor[] value);
    [CompilerGeneratedAttribute]
internal Func`1[] get_EventProcessorsProviders();
    [CompilerGeneratedAttribute]
internal void set_EventProcessorsProviders(Func`1[] value);
    [CompilerGeneratedAttribute]
internal Func`1[] get_ExceptionProcessorsProviders();
    [CompilerGeneratedAttribute]
internal void set_ExceptionProcessorsProviders(Func`1[] value);
    [CompilerGeneratedAttribute]
internal ISdkIntegration[] get_Integrations();
    [CompilerGeneratedAttribute]
internal void set_Integrations(ISdkIntegration[] value);
    [CompilerGeneratedAttribute]
internal IExceptionFilter[] get_ExceptionFilters();
    [CompilerGeneratedAttribute]
internal void set_ExceptionFilters(IExceptionFilter[] value);
    [CompilerGeneratedAttribute]
internal IBackgroundWorker get_BackgroundWorker();
    [CompilerGeneratedAttribute]
internal void set_BackgroundWorker(IBackgroundWorker value);
    [CompilerGeneratedAttribute]
internal ISentryHttpClientFactory get_SentryHttpClientFactory();
    [CompilerGeneratedAttribute]
internal void set_SentryHttpClientFactory(ISentryHttpClientFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual ISentryScopeStateProcessor get_SentryScopeStateProcessor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SentryScopeStateProcessor(ISentryScopeStateProcessor value);
    [CompilerGeneratedAttribute]
internal String[] get_InAppExclude();
    [CompilerGeneratedAttribute]
internal void set_InAppExclude(String[] value);
    [CompilerGeneratedAttribute]
internal String[] get_InAppInclude();
    [CompilerGeneratedAttribute]
internal void set_InAppInclude(String[] value);
    [CompilerGeneratedAttribute]
public bool get_SendDefaultPii();
    [CompilerGeneratedAttribute]
public void set_SendDefaultPii(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnvironmentUser();
    [CompilerGeneratedAttribute]
public void set_IsEnvironmentUser(bool value);
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public void set_ServerName(string value);
    [CompilerGeneratedAttribute]
public bool get_AttachStacktrace();
    [CompilerGeneratedAttribute]
public void set_AttachStacktrace(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxBreadcrumbs();
    [CompilerGeneratedAttribute]
public void set_MaxBreadcrumbs(int value);
    public Nullable`1<float> get_SampleRate();
    public void set_SampleRate(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public string get_Release();
    [CompilerGeneratedAttribute]
public void set_Release(string value);
    [CompilerGeneratedAttribute]
public string get_Environment();
    [CompilerGeneratedAttribute]
public void set_Environment(string value);
    [CompilerGeneratedAttribute]
public Dsn get_Dsn();
    [CompilerGeneratedAttribute]
public void set_Dsn(Dsn value);
    [CompilerGeneratedAttribute]
public Func`2<SentryEvent, SentryEvent> get_BeforeSend();
    [CompilerGeneratedAttribute]
public void set_BeforeSend(Func`2<SentryEvent, SentryEvent> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<Breadcrumb, Breadcrumb> get_BeforeBreadcrumb();
    [CompilerGeneratedAttribute]
public void set_BeforeBreadcrumb(Func`2<Breadcrumb, Breadcrumb> value);
    public int get_MaxQueueItems();
    public void set_MaxQueueItems(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ShutdownTimeout();
    [CompilerGeneratedAttribute]
public void set_ShutdownTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public DecompressionMethods get_DecompressionMethods();
    [CompilerGeneratedAttribute]
public void set_DecompressionMethods(DecompressionMethods value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_RequestBodyCompressionLevel();
    [CompilerGeneratedAttribute]
public void set_RequestBodyCompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public bool get_RequestBodyCompressionBuffered();
    [CompilerGeneratedAttribute]
public void set_RequestBodyCompressionBuffered(bool value);
    [CompilerGeneratedAttribute]
public IWebProxy get_HttpProxy();
    [CompilerGeneratedAttribute]
public void set_HttpProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public Action`2<HttpClientHandler, Dsn> get_ConfigureHandler();
    [CompilerGeneratedAttribute]
public void set_ConfigureHandler(Action`2<HttpClientHandler, Dsn> value);
    [CompilerGeneratedAttribute]
public Func`2<Dsn, HttpClientHandler> get_CreateHttpClientHandler();
    [CompilerGeneratedAttribute]
public void set_CreateHttpClientHandler(Func`2<Dsn, HttpClientHandler> value);
    [CompilerGeneratedAttribute]
public Action`2<HttpClient, Dsn> get_ConfigureClient();
    [CompilerGeneratedAttribute]
public void set_ConfigureClient(Action`2<HttpClient, Dsn> value);
    public bool get_Debug();
    public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public SentryLevel get_DiagnosticsLevel();
    [CompilerGeneratedAttribute]
public void set_DiagnosticsLevel(SentryLevel value);
    public IDiagnosticLogger get_DiagnosticLogger();
    public void set_DiagnosticLogger(IDiagnosticLogger value);
    [CompilerGeneratedAttribute]
public bool get_ReportAssemblies();
    [CompilerGeneratedAttribute]
public void set_ReportAssemblies(bool value);
    [CompilerGeneratedAttribute]
public DeduplicateMode get_DeduplicateMode();
    [CompilerGeneratedAttribute]
public void set_DeduplicateMode(DeduplicateMode value);
    [CompilerGeneratedAttribute]
public RequestSize get_MaxRequestBodySize();
    [CompilerGeneratedAttribute]
public void set_MaxRequestBodySize(RequestSize value);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISentryEventProcessor> <.ctor>b__159_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISentryEventExceptionProcessor> <.ctor>b__159_1();
    [CompilerGeneratedAttribute]
private ISentryStackTraceFactory <.ctor>b__159_2();
    [CompilerGeneratedAttribute]
private RequestSize <.ctor>b__159_3();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Sentry.SentryOptionsExtensions : object {
    [ExtensionAttribute]
public static void DisableDuplicateEventDetection(SentryOptions options);
    [ExtensionAttribute]
public static void DisableAppDomainUnhandledExceptionCapture(SentryOptions options);
    [ExtensionAttribute]
public static void DisableAppDomainProcessExitFlush(SentryOptions options);
    [ExtensionAttribute]
public static void AddIntegration(SentryOptions options, ISdkIntegration integration);
    [ExtensionAttribute]
internal static void RemoveIntegration(SentryOptions options);
    [ExtensionAttribute]
public static void AddExceptionFilter(SentryOptions options, IExceptionFilter exceptionFilter);
    [ExtensionAttribute]
public static void AddExceptionFilterForType(SentryOptions options);
    [ExtensionAttribute]
public static void AddInAppExclude(SentryOptions options, string prefix);
    [ExtensionAttribute]
public static void AddInAppInclude(SentryOptions options, string prefix);
    [ExtensionAttribute]
public static void AddExceptionProcessor(SentryOptions options, ISentryEventExceptionProcessor processor);
    [ExtensionAttribute]
public static void AddExceptionProcessors(SentryOptions options, IEnumerable`1<ISentryEventExceptionProcessor> processors);
    [ExtensionAttribute]
public static void AddEventProcessor(SentryOptions options, ISentryEventProcessor processor);
    [ExtensionAttribute]
public static void AddEventProcessors(SentryOptions options, IEnumerable`1<ISentryEventProcessor> processors);
    [ExtensionAttribute]
public static void AddEventProcessorProvider(SentryOptions options, Func`1<IEnumerable`1<ISentryEventProcessor>> processorProvider);
    [ExtensionAttribute]
public static void AddExceptionProcessorProvider(SentryOptions options, Func`1<IEnumerable`1<ISentryEventExceptionProcessor>> processorProvider);
    [ExtensionAttribute]
public static IEnumerable`1<ISentryEventProcessor> GetAllEventProcessors(SentryOptions options);
    [ExtensionAttribute]
public static IEnumerable`1<ISentryEventExceptionProcessor> GetAllExceptionProcessors(SentryOptions options);
    [ExtensionAttribute]
public static SentryOptions UseStackTraceFactory(SentryOptions options, ISentryStackTraceFactory sentryStackTraceFactory);
    [ExtensionAttribute]
internal static void SetupLogging(SentryOptions options);
}
public static class Sentry.SentrySdk : object {
    private static IHub _hub;
    public static SentryId LastEventId { get; }
    public static bool IsEnabled { get; }
    private static SentrySdk();
    [DebuggerStepThroughAttribute]
public static SentryId get_LastEventId();
    public static IDisposable Init();
    public static IDisposable Init(string dsn);
    public static IDisposable Init(Dsn dsn);
    public static IDisposable Init(Action`1<SentryOptions> configureOptions);
    [EditorBrowsableAttribute("1")]
public static IDisposable Init(SentryOptions options);
    internal static IDisposable UseHub(IHub hub);
    [DebuggerStepThroughAttribute]
public static Task FlushAsync(TimeSpan timeout);
    [EditorBrowsableAttribute("1")]
public static void Close();
    [DebuggerStepThroughAttribute]
public static bool get_IsEnabled();
    [DebuggerStepThroughAttribute]
public static IDisposable PushScope(TState state);
    [DebuggerStepThroughAttribute]
public static IDisposable PushScope();
    [DebuggerStepThroughAttribute]
public static void BindClient(ISentryClient client);
    [DebuggerStepThroughAttribute]
public static void AddBreadcrumb(string message, string category, string type, IDictionary`2<string, string> data, BreadcrumbLevel level);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static void AddBreadcrumb(ISystemClock clock, string message, string category, string type, IDictionary`2<string, string> data, BreadcrumbLevel level);
    [DebuggerStepThroughAttribute]
public static void WithScope(Action`1<Scope> scopeCallback);
    [DebuggerStepThroughAttribute]
public static void ConfigureScope(Action`1<Scope> configureScope);
    [DebuggerStepThroughAttribute]
public static Task ConfigureScopeAsync(Func`2<Scope, Task> configureScope);
    [DebuggerStepThroughAttribute]
public static SentryId CaptureEvent(SentryEvent evt);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
public static SentryId CaptureEvent(SentryEvent evt, Scope scope);
    [DebuggerStepThroughAttribute]
public static SentryId CaptureException(Exception exception);
    [DebuggerStepThroughAttribute]
public static SentryId CaptureMessage(string message, SentryLevel level);
}
