internal static class FxResources.System.Text.Json.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.Buffers.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private int _index;
    private static int DefaultInitialBufferSize;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
    private static void ThrowOutOfMemoryException(UInt32 capacity);
}
internal enum System.Buffers.Text.SequenceValidity : Enum {
    public int value__;
    public static SequenceValidity Empty;
    public static SequenceValidity WellFormed;
    public static SequenceValidity Incomplete;
    public static SequenceValidity Invalid;
}
internal class System.Collections.Generic.ReferenceEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static ReferenceEqualityComparer <Instance>k__BackingField;
    public static ReferenceEqualityComparer Instance { get; }
    private static ReferenceEqualityComparer();
    [CompilerGeneratedAttribute]
public static ReferenceEqualityComparer get_Instance();
    public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.StackExtensions : object {
    [ExtensionAttribute]
public static bool TryPeek(Stack`1<T> stack, T& result);
    [ExtensionAttribute]
public static bool TryPop(Stack`1<T> stack, T& result);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("27072")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("352")]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    public DynamicDependencyAttribute(string memberSignature);
    public DynamicDependencyAttribute(string memberSignature, Type type);
    public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArrayDepthTooLarge { get; }
    internal static string CallFlushToAvoidDataLoss { get; }
    internal static string CannotReadIncompleteUTF16 { get; }
    internal static string CannotReadInvalidUTF16 { get; }
    internal static string CannotStartObjectArrayAfterPrimitiveOrClose { get; }
    internal static string CannotStartObjectArrayWithoutProperty { get; }
    internal static string CannotTranscodeInvalidUtf8 { get; }
    internal static string CannotDecodeInvalidBase64 { get; }
    internal static string CannotTranscodeInvalidUtf16 { get; }
    internal static string CannotEncodeInvalidUTF16 { get; }
    internal static string CannotEncodeInvalidUTF8 { get; }
    internal static string CannotWritePropertyWithinArray { get; }
    internal static string CannotWritePropertyAfterProperty { get; }
    internal static string CannotWriteValueAfterPrimitiveOrClose { get; }
    internal static string CannotWriteValueWithinObject { get; }
    internal static string DepthTooLarge { get; }
    internal static string EmptyJsonIsInvalid { get; }
    internal static string EndOfCommentNotFound { get; }
    internal static string EndOfStringNotFound { get; }
    internal static string ExpectedEndAfterSingleJson { get; }
    internal static string ExpectedEndOfDigitNotFound { get; }
    internal static string ExpectedFalse { get; }
    internal static string ExpectedJsonTokens { get; }
    internal static string ExpectedOneCompleteToken { get; }
    internal static string ExpectedNextDigitEValueNotFound { get; }
    internal static string ExpectedNull { get; }
    internal static string ExpectedSeparatorAfterPropertyNameNotFound { get; }
    internal static string ExpectedStartOfPropertyNotFound { get; }
    internal static string ExpectedStartOfPropertyOrValueNotFound { get; }
    internal static string ExpectedStartOfValueNotFound { get; }
    internal static string ExpectedTrue { get; }
    internal static string ExpectedValueAfterPropertyNameNotFound { get; }
    internal static string FailedToGetLargerSpan { get; }
    internal static string FoundInvalidCharacter { get; }
    internal static string InvalidCast { get; }
    internal static string InvalidCharacterAfterEscapeWithinString { get; }
    internal static string InvalidCharacterWithinString { get; }
    internal static string InvalidEndOfJsonNonPrimitive { get; }
    internal static string InvalidHexCharacterWithinString { get; }
    internal static string JsonDocumentDoesNotSupportComments { get; }
    internal static string JsonElementHasWrongType { get; }
    internal static string MaxDepthMustBePositive { get; }
    internal static string CommentHandlingMustBeValid { get; }
    internal static string MismatchedObjectArray { get; }
    internal static string CannotWriteEndAfterProperty { get; }
    internal static string ObjectDepthTooLarge { get; }
    internal static string PropertyNameTooLarge { get; }
    internal static string FormatDecimal { get; }
    internal static string FormatDouble { get; }
    internal static string FormatInt32 { get; }
    internal static string FormatInt64 { get; }
    internal static string FormatSingle { get; }
    internal static string FormatUInt32 { get; }
    internal static string FormatUInt64 { get; }
    internal static string RequiredDigitNotFoundAfterDecimal { get; }
    internal static string RequiredDigitNotFoundAfterSign { get; }
    internal static string RequiredDigitNotFoundEndOfData { get; }
    internal static string SpecialNumberValuesNotSupported { get; }
    internal static string ValueTooLarge { get; }
    internal static string ZeroDepthAtEnd { get; }
    internal static string DeserializeUnableToConvertValue { get; }
    internal static string DeserializeWrongType { get; }
    internal static string SerializationInvalidBufferSize { get; }
    internal static string BufferWriterAdvancedTooFar { get; }
    internal static string InvalidComparison { get; }
    internal static string FormatDateTime { get; }
    internal static string FormatDateTimeOffset { get; }
    internal static string FormatGuid { get; }
    internal static string ExpectedStartOfPropertyOrValueAfterComment { get; }
    internal static string TrailingCommaNotAllowedBeforeArrayEnd { get; }
    internal static string TrailingCommaNotAllowedBeforeObjectEnd { get; }
    internal static string SerializerOptionsImmutable { get; }
    internal static string StreamNotWritable { get; }
    internal static string CannotWriteCommentWithEmbeddedDelimiter { get; }
    internal static string SerializerPropertyNameConflict { get; }
    internal static string SerializerPropertyNameNull { get; }
    internal static string DeserializeDuplicateKey { get; }
    internal static string SerializationDataExtensionPropertyInvalid { get; }
    internal static string SerializationDuplicateTypeAttribute { get; }
    internal static string SerializationNotSupportedType { get; }
    internal static string InvalidCharacterAtStartOfComment { get; }
    internal static string UnexpectedEndOfDataWhileReadingComment { get; }
    internal static string CannotSkip { get; }
    internal static string NotEnoughData { get; }
    internal static string UnexpectedEndOfLineSeparator { get; }
    internal static string JsonSerializerDoesNotSupportComments { get; }
    internal static string DeserializeNoConstructor { get; }
    internal static string DeserializePolymorphicInterface { get; }
    internal static string SerializationConverterOnAttributeNotCompatible { get; }
    internal static string SerializationConverterOnAttributeInvalid { get; }
    internal static string SerializationConverterRead { get; }
    internal static string SerializationConverterNotCompatible { get; }
    internal static string SerializationConverterWrite { get; }
    internal static string NamingPolicyReturnNull { get; }
    internal static string SerializationDuplicateAttribute { get; }
    internal static string SerializeUnableToSerialize { get; }
    internal static string FormatByte { get; }
    internal static string FormatInt16 { get; }
    internal static string FormatSByte { get; }
    internal static string FormatUInt16 { get; }
    internal static string SerializerCycleDetected { get; }
    internal static string EmptyStringToInitializeNumber { get; }
    internal static string JsonObjectDuplicateKey { get; }
    internal static string PropertyNotFound { get; }
    internal static string PropertyTypeMismatch { get; }
    internal static string InvalidDuplicatePropertyNameHandling { get; }
    internal static string InvalidLeadingZeroInNumber { get; }
    internal static string ArrayModifiedDuringIteration { get; }
    internal static string NotNodeJsonElementParent { get; }
    internal static string MetadataCannotParsePreservedObjectToImmutable { get; }
    internal static string MetadataDuplicateIdFound { get; }
    internal static string MetadataIdIsNotFirstProperty { get; }
    internal static string MetadataInvalidReferenceToValueType { get; }
    internal static string MetadataInvalidTokenAfterValues { get; }
    internal static string MetadataPreservedArrayFailed { get; }
    internal static string MetadataPreservedArrayInvalidProperty { get; }
    internal static string MetadataPreservedArrayPropertyNotFound { get; }
    internal static string MetadataReferenceCannotContainOtherProperties { get; }
    internal static string MetadataReferenceNotFound { get; }
    internal static string MetadataValueWasNotString { get; }
    internal static string MetadataInvalidPropertyWithLeadingDollarSign { get; }
    internal static string MultipleMembersBindWithConstructorParameter { get; }
    internal static string ConstructorParamIncompleteBinding { get; }
    internal static string ConstructorMaxOf64Parameters { get; }
    internal static string ObjectWithParameterizedCtorRefMetadataNotHonored { get; }
    internal static string SerializerConverterFactoryReturnsNull { get; }
    internal static string SerializationNotSupportedParentType { get; }
    internal static string ExtensionDataCannotBindToCtorParam { get; }
    internal static string BufferMaximumSizeExceeded { get; }
    internal static string CannotSerializeInvalidType { get; }
    internal static string SerializeTypeInstanceNotSupported { get; }
    internal static string JsonIncludeOnNonPublicInvalid { get; }
    internal static string CannotSerializeInvalidMember { get; }
    internal static string CannotPopulateCollection { get; }
    internal static string DefaultIgnoreConditionAlreadySpecified { get; }
    internal static string DefaultIgnoreConditionInvalid { get; }
    internal static string FormatBoolean { get; }
    internal static string DictionaryKeyTypeNotSupported { get; }
    internal static string IgnoreConditionOnValueTypeInvalid { get; }
    internal static string NumberHandlingConverterMustBeBuiltIn { get; }
    internal static string NumberHandlingOnPropertyTypeMustBeNumberOrCollection { get; }
    internal static string ConverterCanConvertNullableRedundant { get; }
    internal static string MetadataReferenceOfTypeCannotBeAssignedToType { get; }
    internal static string DeserializeUnableToAssignValue { get; }
    internal static string DeserializeUnableToAssignNull { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArrayDepthTooLarge();
    internal static string get_CallFlushToAvoidDataLoss();
    internal static string get_CannotReadIncompleteUTF16();
    internal static string get_CannotReadInvalidUTF16();
    internal static string get_CannotStartObjectArrayAfterPrimitiveOrClose();
    internal static string get_CannotStartObjectArrayWithoutProperty();
    internal static string get_CannotTranscodeInvalidUtf8();
    internal static string get_CannotDecodeInvalidBase64();
    internal static string get_CannotTranscodeInvalidUtf16();
    internal static string get_CannotEncodeInvalidUTF16();
    internal static string get_CannotEncodeInvalidUTF8();
    internal static string get_CannotWritePropertyWithinArray();
    internal static string get_CannotWritePropertyAfterProperty();
    internal static string get_CannotWriteValueAfterPrimitiveOrClose();
    internal static string get_CannotWriteValueWithinObject();
    internal static string get_DepthTooLarge();
    internal static string get_EmptyJsonIsInvalid();
    internal static string get_EndOfCommentNotFound();
    internal static string get_EndOfStringNotFound();
    internal static string get_ExpectedEndAfterSingleJson();
    internal static string get_ExpectedEndOfDigitNotFound();
    internal static string get_ExpectedFalse();
    internal static string get_ExpectedJsonTokens();
    internal static string get_ExpectedOneCompleteToken();
    internal static string get_ExpectedNextDigitEValueNotFound();
    internal static string get_ExpectedNull();
    internal static string get_ExpectedSeparatorAfterPropertyNameNotFound();
    internal static string get_ExpectedStartOfPropertyNotFound();
    internal static string get_ExpectedStartOfPropertyOrValueNotFound();
    internal static string get_ExpectedStartOfValueNotFound();
    internal static string get_ExpectedTrue();
    internal static string get_ExpectedValueAfterPropertyNameNotFound();
    internal static string get_FailedToGetLargerSpan();
    internal static string get_FoundInvalidCharacter();
    internal static string get_InvalidCast();
    internal static string get_InvalidCharacterAfterEscapeWithinString();
    internal static string get_InvalidCharacterWithinString();
    internal static string get_InvalidEndOfJsonNonPrimitive();
    internal static string get_InvalidHexCharacterWithinString();
    internal static string get_JsonDocumentDoesNotSupportComments();
    internal static string get_JsonElementHasWrongType();
    internal static string get_MaxDepthMustBePositive();
    internal static string get_CommentHandlingMustBeValid();
    internal static string get_MismatchedObjectArray();
    internal static string get_CannotWriteEndAfterProperty();
    internal static string get_ObjectDepthTooLarge();
    internal static string get_PropertyNameTooLarge();
    internal static string get_FormatDecimal();
    internal static string get_FormatDouble();
    internal static string get_FormatInt32();
    internal static string get_FormatInt64();
    internal static string get_FormatSingle();
    internal static string get_FormatUInt32();
    internal static string get_FormatUInt64();
    internal static string get_RequiredDigitNotFoundAfterDecimal();
    internal static string get_RequiredDigitNotFoundAfterSign();
    internal static string get_RequiredDigitNotFoundEndOfData();
    internal static string get_SpecialNumberValuesNotSupported();
    internal static string get_ValueTooLarge();
    internal static string get_ZeroDepthAtEnd();
    internal static string get_DeserializeUnableToConvertValue();
    internal static string get_DeserializeWrongType();
    internal static string get_SerializationInvalidBufferSize();
    internal static string get_BufferWriterAdvancedTooFar();
    internal static string get_InvalidComparison();
    internal static string get_FormatDateTime();
    internal static string get_FormatDateTimeOffset();
    internal static string get_FormatGuid();
    internal static string get_ExpectedStartOfPropertyOrValueAfterComment();
    internal static string get_TrailingCommaNotAllowedBeforeArrayEnd();
    internal static string get_TrailingCommaNotAllowedBeforeObjectEnd();
    internal static string get_SerializerOptionsImmutable();
    internal static string get_StreamNotWritable();
    internal static string get_CannotWriteCommentWithEmbeddedDelimiter();
    internal static string get_SerializerPropertyNameConflict();
    internal static string get_SerializerPropertyNameNull();
    internal static string get_DeserializeDuplicateKey();
    internal static string get_SerializationDataExtensionPropertyInvalid();
    internal static string get_SerializationDuplicateTypeAttribute();
    internal static string get_SerializationNotSupportedType();
    internal static string get_InvalidCharacterAtStartOfComment();
    internal static string get_UnexpectedEndOfDataWhileReadingComment();
    internal static string get_CannotSkip();
    internal static string get_NotEnoughData();
    internal static string get_UnexpectedEndOfLineSeparator();
    internal static string get_JsonSerializerDoesNotSupportComments();
    internal static string get_DeserializeNoConstructor();
    internal static string get_DeserializePolymorphicInterface();
    internal static string get_SerializationConverterOnAttributeNotCompatible();
    internal static string get_SerializationConverterOnAttributeInvalid();
    internal static string get_SerializationConverterRead();
    internal static string get_SerializationConverterNotCompatible();
    internal static string get_SerializationConverterWrite();
    internal static string get_NamingPolicyReturnNull();
    internal static string get_SerializationDuplicateAttribute();
    internal static string get_SerializeUnableToSerialize();
    internal static string get_FormatByte();
    internal static string get_FormatInt16();
    internal static string get_FormatSByte();
    internal static string get_FormatUInt16();
    internal static string get_SerializerCycleDetected();
    internal static string get_EmptyStringToInitializeNumber();
    internal static string get_JsonObjectDuplicateKey();
    internal static string get_PropertyNotFound();
    internal static string get_PropertyTypeMismatch();
    internal static string get_InvalidDuplicatePropertyNameHandling();
    internal static string get_InvalidLeadingZeroInNumber();
    internal static string get_ArrayModifiedDuringIteration();
    internal static string get_NotNodeJsonElementParent();
    internal static string get_MetadataCannotParsePreservedObjectToImmutable();
    internal static string get_MetadataDuplicateIdFound();
    internal static string get_MetadataIdIsNotFirstProperty();
    internal static string get_MetadataInvalidReferenceToValueType();
    internal static string get_MetadataInvalidTokenAfterValues();
    internal static string get_MetadataPreservedArrayFailed();
    internal static string get_MetadataPreservedArrayInvalidProperty();
    internal static string get_MetadataPreservedArrayPropertyNotFound();
    internal static string get_MetadataReferenceCannotContainOtherProperties();
    internal static string get_MetadataReferenceNotFound();
    internal static string get_MetadataValueWasNotString();
    internal static string get_MetadataInvalidPropertyWithLeadingDollarSign();
    internal static string get_MultipleMembersBindWithConstructorParameter();
    internal static string get_ConstructorParamIncompleteBinding();
    internal static string get_ConstructorMaxOf64Parameters();
    internal static string get_ObjectWithParameterizedCtorRefMetadataNotHonored();
    internal static string get_SerializerConverterFactoryReturnsNull();
    internal static string get_SerializationNotSupportedParentType();
    internal static string get_ExtensionDataCannotBindToCtorParam();
    internal static string get_BufferMaximumSizeExceeded();
    internal static string get_CannotSerializeInvalidType();
    internal static string get_SerializeTypeInstanceNotSupported();
    internal static string get_JsonIncludeOnNonPublicInvalid();
    internal static string get_CannotSerializeInvalidMember();
    internal static string get_CannotPopulateCollection();
    internal static string get_DefaultIgnoreConditionAlreadySpecified();
    internal static string get_DefaultIgnoreConditionInvalid();
    internal static string get_FormatBoolean();
    internal static string get_DictionaryKeyTypeNotSupported();
    internal static string get_IgnoreConditionOnValueTypeInvalid();
    internal static string get_NumberHandlingConverterMustBeBuiltIn();
    internal static string get_NumberHandlingOnPropertyTypeMustBeNumberOrCollection();
    internal static string get_ConverterCanConvertNullableRedundant();
    internal static string get_MetadataReferenceOfTypeCannotBeAssignedToType();
    internal static string get_DeserializeUnableToAssignValue();
    internal static string get_DeserializeUnableToAssignNull();
}
internal class System.Text.Json.Arguments`4 : object {
    public TArg0 Arg0;
    public TArg1 Arg1;
    public TArg2 Arg2;
    public TArg3 Arg3;
}
internal class System.Text.Json.ArgumentState : object {
    public object Arguments;
    public ValueTuple`5[] FoundProperties;
    public ValueTuple`3[] FoundPropertiesAsync;
    public int FoundPropertyCount;
    public JsonParameterInfo JsonParameterInfo;
    public int ParameterIndex;
    public List`1<ParameterRef> ParameterRefCache;
    public bool FoundKey;
    public bool FoundValue;
}
internal class System.Text.Json.BitStack : ValueType {
    private static int AllocationFreeMaxDepth;
    private static int DefaultInitialArraySize;
    private Int32[] _array;
    private ulong _allocationFreeContainer;
    private int _currentDepth;
    public int CurrentDepth { get; }
    public int get_CurrentDepth();
    public void PushTrue();
    public void PushFalse();
    private void PushToArray(bool value);
    public bool Pop();
    private bool PopFromArray();
    private void DoubleArray(int minSize);
    public void SetFirstBit();
    public void ResetFirstBit();
    private static int Div32Rem(int number, Int32& remainder);
}
internal enum System.Text.Json.ClassType : Enum {
    public byte value__;
    public static ClassType None;
    public static ClassType Object;
    public static ClassType Value;
    public static ClassType NewValue;
    public static ClassType Enumerable;
    public static ClassType Dictionary;
}
internal enum System.Text.Json.ConsumeNumberResult : Enum {
    public byte value__;
    public static ConsumeNumberResult Success;
    public static ConsumeNumberResult OperationIncomplete;
    public static ConsumeNumberResult NeedMoreData;
}
internal enum System.Text.Json.ConsumeTokenResult : Enum {
    public byte value__;
    public static ConsumeTokenResult Success;
    public static ConsumeTokenResult NotEnoughDataRollBackState;
    public static ConsumeTokenResult IncompleteNoRollBackNecessary;
}
internal enum System.Text.Json.DataType : Enum {
    public int value__;
    public static DataType Boolean;
    public static DataType DateTime;
    public static DataType DateTimeOffset;
    public static DataType Base64String;
    public static DataType Guid;
}
internal enum System.Text.Json.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArrayDepthTooLarge;
    public static ExceptionResource EndOfCommentNotFound;
    public static ExceptionResource EndOfStringNotFound;
    public static ExceptionResource RequiredDigitNotFoundAfterDecimal;
    public static ExceptionResource RequiredDigitNotFoundAfterSign;
    public static ExceptionResource RequiredDigitNotFoundEndOfData;
    public static ExceptionResource ExpectedEndAfterSingleJson;
    public static ExceptionResource ExpectedEndOfDigitNotFound;
    public static ExceptionResource ExpectedFalse;
    public static ExceptionResource ExpectedNextDigitEValueNotFound;
    public static ExceptionResource ExpectedNull;
    public static ExceptionResource ExpectedSeparatorAfterPropertyNameNotFound;
    public static ExceptionResource ExpectedStartOfPropertyNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueAfterComment;
    public static ExceptionResource ExpectedStartOfValueNotFound;
    public static ExceptionResource ExpectedTrue;
    public static ExceptionResource ExpectedValueAfterPropertyNameNotFound;
    public static ExceptionResource FoundInvalidCharacter;
    public static ExceptionResource InvalidCharacterWithinString;
    public static ExceptionResource InvalidCharacterAfterEscapeWithinString;
    public static ExceptionResource InvalidHexCharacterWithinString;
    public static ExceptionResource InvalidEndOfJsonNonPrimitive;
    public static ExceptionResource MismatchedObjectArray;
    public static ExceptionResource ObjectDepthTooLarge;
    public static ExceptionResource ZeroDepthAtEnd;
    public static ExceptionResource DepthTooLarge;
    public static ExceptionResource CannotStartObjectArrayWithoutProperty;
    public static ExceptionResource CannotStartObjectArrayAfterPrimitiveOrClose;
    public static ExceptionResource CannotWriteValueWithinObject;
    public static ExceptionResource CannotWriteValueAfterPrimitiveOrClose;
    public static ExceptionResource CannotWritePropertyWithinArray;
    public static ExceptionResource ExpectedJsonTokens;
    public static ExceptionResource TrailingCommaNotAllowedBeforeArrayEnd;
    public static ExceptionResource TrailingCommaNotAllowedBeforeObjectEnd;
    public static ExceptionResource InvalidCharacterAtStartOfComment;
    public static ExceptionResource UnexpectedEndOfDataWhileReadingComment;
    public static ExceptionResource UnexpectedEndOfLineSeparator;
    public static ExceptionResource ExpectedOneCompleteToken;
    public static ExceptionResource NotEnoughData;
    public static ExceptionResource InvalidLeadingZeroInNumber;
}
internal class System.Text.Json.JsonCamelCaseNamingPolicy : JsonNamingPolicy {
    public virtual string ConvertName(string name);
    private static void FixCasing(Span`1<char> chars);
}
[DebuggerDisplayAttribute("ClassType.{ClassType}, {Type.Name}")]
[DebuggerDisplayAttribute("ClassType.{ClassType}, {Type.Name}")]
internal class System.Text.Json.JsonClassInfo : object {
    [CompilerGeneratedAttribute]
private ConstructorDelegate <CreateObject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CreateObjectWithArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AddMethodDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private ClassType <ClassType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <DataExtensionProperty>k__BackingField;
    private JsonClassInfo _elementClassInfo;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <PropertyInfoForClassInfo>k__BackingField;
    public static Type ObjectType;
    private static int PropertyNameKeyLength;
    private static int ParameterNameCountCacheThreshold;
    private static int PropertyNameCountCacheThreshold;
    [CompilerGeneratedAttribute]
private int <ParameterCount>k__BackingField;
    public Dictionary`2<string, JsonParameterInfo> ParameterCache;
    public Dictionary`2<string, JsonPropertyInfo> PropertyCache;
    public JsonPropertyInfo[] PropertyCacheArray;
    private ParameterRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _parameterRefsSorted;
    private PropertyRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _propertyRefsSorted;
    public ConstructorDelegate CreateObject { get; private set; }
    public object CreateObjectWithArgs { get; public set; }
    public object AddMethodDelegate { get; public set; }
    public ClassType ClassType { get; private set; }
    public JsonPropertyInfo DataExtensionProperty { get; private set; }
    public JsonClassInfo ElementClassInfo { get; }
    public Type ElementType { get; public set; }
    public JsonSerializerOptions Options { get; private set; }
    public Type Type { get; private set; }
    public JsonPropertyInfo PropertyInfoForClassInfo { get; private set; }
    public int ParameterCount { get; private set; }
    public JsonClassInfo(Type type, JsonSerializerOptions options);
    private static JsonClassInfo();
    [CompilerGeneratedAttribute]
public ConstructorDelegate get_CreateObject();
    [CompilerGeneratedAttribute]
private void set_CreateObject(ConstructorDelegate value);
    [CompilerGeneratedAttribute]
public object get_CreateObjectWithArgs();
    [CompilerGeneratedAttribute]
public void set_CreateObjectWithArgs(object value);
    [CompilerGeneratedAttribute]
public object get_AddMethodDelegate();
    [CompilerGeneratedAttribute]
public void set_AddMethodDelegate(object value);
    [CompilerGeneratedAttribute]
public ClassType get_ClassType();
    [CompilerGeneratedAttribute]
private void set_ClassType(ClassType value);
    [CompilerGeneratedAttribute]
public JsonPropertyInfo get_DataExtensionProperty();
    [CompilerGeneratedAttribute]
private void set_DataExtensionProperty(JsonPropertyInfo value);
    public JsonClassInfo get_ElementClassInfo();
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(Type value);
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public JsonPropertyInfo get_PropertyInfoForClassInfo();
    [CompilerGeneratedAttribute]
private void set_PropertyInfoForClassInfo(JsonPropertyInfo value);
    private void CacheMember(Type declaringType, Type memberType, MemberInfo memberInfo, Nullable`1<JsonNumberHandling> typeNumberHandling, Dictionary`2<string, JsonPropertyInfo> cache, Dictionary`2& ignoredMembers);
    private void InitializeConstructorParameters(ConstructorInfo constructorInfo);
    private static bool PropertyIsOverridenAndIgnored(MemberInfo currentMember, Dictionary`2<string, MemberInfo> ignoredMembers);
    private static bool PropertyIsVirtual(PropertyInfo propertyInfo);
    public bool DetermineExtensionDataProperty(Dictionary`2<string, JsonPropertyInfo> cache);
    private static JsonPropertyInfo GetPropertyWithUniqueAttribute(Type classType, Type attributeType, Dictionary`2<string, JsonPropertyInfo> cache);
    private static JsonParameterInfo AddConstructorParameter(ParameterInfo parameterInfo, JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options);
    public static JsonConverter GetConverter(Type type, Type parentClassType, MemberInfo memberInfo, Type& runtimeType, JsonSerializerOptions options);
    private static void ValidateType(Type type, Type parentClassType, MemberInfo memberInfo, JsonSerializerOptions options);
    private static bool IsInvalidForSerialization(Type type);
    private static bool IsByRefLike(Type type);
    private static Nullable`1<JsonNumberHandling> GetNumberHandlingForType(Type type);
    [CompilerGeneratedAttribute]
public int get_ParameterCount();
    [CompilerGeneratedAttribute]
private void set_ParameterCount(int value);
    public static JsonPropertyInfo AddProperty(MemberInfo memberInfo, Type memberType, Type parentClassType, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, JsonSerializerOptions options);
    internal static JsonPropertyInfo CreateProperty(Type declaredPropertyType, Type runtimePropertyType, MemberInfo memberInfo, Type parentClassType, JsonConverter converter, JsonSerializerOptions options, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, Nullable`1<JsonIgnoreCondition> ignoreCondition);
    internal static JsonPropertyInfo CreatePropertyInfoForClassInfo(Type declaredPropertyType, Type runtimePropertyType, JsonConverter converter, JsonSerializerOptions options);
    public JsonPropertyInfo GetProperty(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame, Byte[]& utf8PropertyName);
    public JsonParameterInfo GetParameter(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame, Byte[]& utf8PropertyName);
    private static bool IsPropertyRefEqual(PropertyRef& propertyRef, ReadOnlySpan`1<byte> propertyName, ulong key);
    private static bool IsParameterRefEqual(ParameterRef& parameterRef, ReadOnlySpan`1<byte> parameterName, ulong key);
    public static ulong GetKey(ReadOnlySpan`1<byte> name);
    public void UpdateSortedPropertyCache(ReadStackFrame& frame);
    public void UpdateSortedParameterCache(ReadStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static Type <InitializeConstructorParameters>g__GetMemberType|46_0(MemberInfo memberInfo);
}
public enum System.Text.Json.JsonCommentHandling : Enum {
    public byte value__;
    public static JsonCommentHandling Disallow;
    public static JsonCommentHandling Skip;
    public static JsonCommentHandling Allow;
}
internal static class System.Text.Json.JsonConstants : object {
    public static byte OpenBrace;
    public static byte CloseBrace;
    public static byte OpenBracket;
    public static byte CloseBracket;
    public static byte Space;
    public static byte CarriageReturn;
    public static byte LineFeed;
    public static byte Tab;
    public static byte ListSeparator;
    public static byte KeyValueSeperator;
    public static byte Quote;
    public static byte BackSlash;
    public static byte Slash;
    public static byte BackSpace;
    public static byte FormFeed;
    public static byte Asterisk;
    public static byte Colon;
    public static byte Period;
    public static byte Plus;
    public static byte Hyphen;
    public static byte UtcOffsetToken;
    public static byte TimePrefix;
    public static byte StartingByteOfNonStandardSeparator;
    public static int SpacesPerIndent;
    public static int MaxWriterDepth;
    public static int RemoveFlagsBitMask;
    public static int StackallocThreshold;
    public static int MaxExpansionFactorWhileEscaping;
    public static int MaxExpansionFactorWhileTranscoding;
    public static int MaxEscapedTokenSize;
    public static int MaxUnescapedTokenSize;
    public static int MaxBase64ValueTokenSize;
    public static int MaxCharacterTokenSize;
    public static int MaximumFormatBooleanLength;
    public static int MaximumFormatInt64Length;
    public static int MaximumFormatUInt64Length;
    public static int MaximumFormatDoubleLength;
    public static int MaximumFormatSingleLength;
    public static int MaximumFormatDecimalLength;
    public static int MaximumFormatGuidLength;
    public static int MaximumEscapedGuidLength;
    public static int MaximumFormatDateTimeLength;
    public static int MaximumFormatDateTimeOffsetLength;
    public static int MaxDateTimeUtcOffsetHours;
    public static int DateTimeNumFractionDigits;
    public static int MaxDateTimeFraction;
    public static int DateTimeParseNumFractionDigits;
    public static int MaximumDateTimeOffsetParseLength;
    public static int MinimumDateTimeParseLength;
    public static int MaximumEscapedDateTimeOffsetParseLength;
    internal static char ScientificNotationFormat;
    public static char HighSurrogateStart;
    public static char HighSurrogateEnd;
    public static char LowSurrogateStart;
    public static char LowSurrogateEnd;
    public static int UnicodePlane01StartValue;
    public static int HighSurrogateStartValue;
    public static int HighSurrogateEndValue;
    public static int LowSurrogateStartValue;
    public static int LowSurrogateEndValue;
    public static int BitShiftBy10;
    public static int UnboxedParameterCountThreshold;
    public static int MaxParameterCount;
    public static ReadOnlySpan`1<byte> Utf8Bom { get; }
    public static ReadOnlySpan`1<byte> TrueValue { get; }
    public static ReadOnlySpan`1<byte> FalseValue { get; }
    public static ReadOnlySpan`1<byte> NullValue { get; }
    public static ReadOnlySpan`1<byte> NaNValue { get; }
    public static ReadOnlySpan`1<byte> PositiveInfinityValue { get; }
    public static ReadOnlySpan`1<byte> NegativeInfinityValue { get; }
    public static ReadOnlySpan`1<byte> Delimiters { get; }
    public static ReadOnlySpan`1<byte> EscapableChars { get; }
    public static ReadOnlySpan`1<byte> get_Utf8Bom();
    public static ReadOnlySpan`1<byte> get_TrueValue();
    public static ReadOnlySpan`1<byte> get_FalseValue();
    public static ReadOnlySpan`1<byte> get_NullValue();
    public static ReadOnlySpan`1<byte> get_NaNValue();
    public static ReadOnlySpan`1<byte> get_PositiveInfinityValue();
    public static ReadOnlySpan`1<byte> get_NegativeInfinityValue();
    public static ReadOnlySpan`1<byte> get_Delimiters();
    public static ReadOnlySpan`1<byte> get_EscapableChars();
}
internal class System.Text.Json.JsonDefaultNamingPolicy : JsonNamingPolicy {
    public virtual string ConvertName(string name);
}
public class System.Text.Json.JsonDocument : object {
    private ReadOnlyMemory`1<byte> _utf8Json;
    private MetadataDb _parsedData;
    private Byte[] _extraRentedBytes;
    private ValueTuple`2<int, string> _lastIndexAndString;
    [CompilerGeneratedAttribute]
private bool <IsDisposable>k__BackingField;
    private static int UnseekableStreamInitialRentSize;
    internal bool IsDisposable { get; }
    public JsonElement RootElement { get; }
    private JsonDocument(ReadOnlyMemory`1<byte> utf8Json, MetadataDb parsedData, Byte[] extraRentedBytes, bool isDisposable);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposable();
    public JsonElement get_RootElement();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
    internal JsonTokenType GetJsonTokenType(int index);
    internal int GetArrayLength(int index);
    internal JsonElement GetArrayIndexElement(int currentIndex, int arrayIndex);
    internal int GetEndIndex(int index, bool includeEndElement);
    private ReadOnlyMemory`1<byte> GetRawValue(int index, bool includeQuotes);
    private ReadOnlyMemory`1<byte> GetPropertyRawValue(int valueIndex);
    internal string GetString(int index, JsonTokenType expectedType);
    internal bool TextEquals(int index, ReadOnlySpan`1<char> otherText, bool isPropertyName);
    internal bool TextEquals(int index, ReadOnlySpan`1<byte> otherUtf8Text, bool isPropertyName, bool shouldUnescape);
    internal string GetNameOfPropertyValue(int index);
    internal bool TryGetValue(int index, Byte[]& value);
    internal bool TryGetValue(int index, SByte& value);
    internal bool TryGetValue(int index, Byte& value);
    internal bool TryGetValue(int index, Int16& value);
    internal bool TryGetValue(int index, UInt16& value);
    internal bool TryGetValue(int index, Int32& value);
    internal bool TryGetValue(int index, UInt32& value);
    internal bool TryGetValue(int index, Int64& value);
    internal bool TryGetValue(int index, UInt64& value);
    internal bool TryGetValue(int index, Double& value);
    internal bool TryGetValue(int index, Single& value);
    internal bool TryGetValue(int index, Decimal& value);
    internal bool TryGetValue(int index, DateTime& value);
    internal bool TryGetValue(int index, DateTimeOffset& value);
    internal bool TryGetValue(int index, Guid& value);
    internal string GetRawValueAsString(int index);
    internal string GetPropertyRawValueAsString(int valueIndex);
    internal JsonElement CloneElement(int index);
    internal void WriteElementTo(int index, Utf8JsonWriter writer);
    private void WriteComplexElement(int index, Utf8JsonWriter writer);
    private ReadOnlySpan`1<byte> UnescapeString(DbRow& row, ArraySegment`1& rented);
    private static void ClearAndReturn(ArraySegment`1<byte> rented);
    private void WritePropertyName(DbRow& row, Utf8JsonWriter writer);
    private void WriteString(DbRow& row, Utf8JsonWriter writer);
    private static void Parse(ReadOnlySpan`1<byte> utf8JsonSpan, JsonReaderOptions readerOptions, MetadataDb& database, StackRowStack& stack);
    private void CheckNotDisposed();
    private void CheckExpectedType(JsonTokenType expected, JsonTokenType actual);
    private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName);
    public static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonDocumentOptions options);
    public static JsonDocument Parse(ReadOnlySequence`1<byte> utf8Json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static JsonDocument Parse(Stream utf8Json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static Task`1<JsonDocument> ParseAsync(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ParseAsyncCore>d__57")]
private static Task`1<JsonDocument> ParseAsyncCore(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    public static JsonDocument Parse(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static JsonDocument Parse(string json, JsonDocumentOptions options);
    [NullableContextAttribute("2")]
public static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document);
    [NullableContextAttribute("1")]
public static JsonDocument ParseValue(Utf8JsonReader& reader);
    private static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document, bool shouldThrow);
    private static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedBytes);
    private static ArraySegment`1<byte> ReadToEnd(Stream stream);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ReadToEndAsync>d__65")]
private static Task`1<ArraySegment`1<byte>> ReadToEndAsync(Stream stream, CancellationToken cancellationToken);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<char> propertyName, JsonElement& value);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
    private bool TryGetNamedPropertyValue(int startIndex, int endIndex, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
}
public class System.Text.Json.JsonDocumentOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
    internal JsonReaderOptions GetReaderOptions();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonElement : ValueType {
    private JsonDocument _parent;
    private int _idx;
    [DebuggerBrowsableAttribute("0")]
private JsonTokenType TokenType { get; }
    public JsonValueKind ValueKind { get; }
    public JsonElement Item { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonElement(JsonDocument parent, int idx);
    private JsonTokenType get_TokenType();
    public JsonValueKind get_ValueKind();
    public JsonElement get_Item(int index);
    public int GetArrayLength();
    [NullableContextAttribute("1")]
public JsonElement GetProperty(string propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<char> propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<byte> utf8PropertyName);
    [NullableContextAttribute("1")]
public bool TryGetProperty(string propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<char> propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<byte> utf8PropertyName, JsonElement& value);
    public bool GetBoolean();
    [NullableContextAttribute("2")]
public string GetString();
    [NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    [NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    public bool TryGetByte(Byte& value);
    public byte GetByte();
    public bool TryGetInt16(Int16& value);
    public short GetInt16();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    public bool TryGetInt32(Int32& value);
    public int GetInt32();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    public bool TryGetInt64(Int64& value);
    public long GetInt64();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    public bool TryGetDouble(Double& value);
    public double GetDouble();
    public bool TryGetSingle(Single& value);
    public float GetSingle();
    public bool TryGetDecimal(Decimal& value);
    public decimal GetDecimal();
    public bool TryGetDateTime(DateTime& value);
    public DateTime GetDateTime();
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    public DateTimeOffset GetDateTimeOffset();
    public bool TryGetGuid(Guid& value);
    public Guid GetGuid();
    internal string GetPropertyName();
    [NullableContextAttribute("1")]
public string GetRawText();
    internal string GetPropertyRawText();
    [NullableContextAttribute("2")]
public bool ValueEquals(string text);
    public bool ValueEquals(ReadOnlySpan`1<byte> utf8Text);
    public bool ValueEquals(ReadOnlySpan`1<char> text);
    internal bool TextEqualsHelper(ReadOnlySpan`1<byte> utf8Text, bool isPropertyName, bool shouldUnescape);
    internal bool TextEqualsHelper(ReadOnlySpan`1<char> text, bool isPropertyName);
    [NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
    public ArrayEnumerator EnumerateArray();
    public ObjectEnumerator EnumerateObject();
    [NullableContextAttribute("2")]
public virtual string ToString();
    public JsonElement Clone();
    private void CheckValidInstance();
    private string get_DebuggerDisplay();
}
[IsReadOnlyAttribute]
public class System.Text.Json.JsonEncodedText : ValueType {
    private Byte[] _utf8Value;
    private string _value;
    public ReadOnlySpan`1<byte> EncodedUtf8Bytes { get; }
    private JsonEncodedText(Byte[] utf8Value);
    public ReadOnlySpan`1<byte> get_EncodedUtf8Bytes();
    [NullableContextAttribute("1")]
public static JsonEncodedText Encode(string value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    private static JsonEncodedText TranscodeAndEncode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    private static JsonEncodedText EncodeHelper(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public sealed virtual bool Equals(JsonEncodedText other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonException : Exception {
    internal string _message;
    [CompilerGeneratedAttribute]
private bool <AppendPathInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BytePositionInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    internal bool AppendPathInformation { get; internal set; }
    public Nullable`1<long> LineNumber { get; internal set; }
    public Nullable`1<long> BytePositionInLine { get; internal set; }
    public string Path { get; internal set; }
    [NullableAttribute("1")]
public string Message { get; }
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine, Exception innerException);
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine);
    public JsonException(string message, Exception innerException);
    public JsonException(string message);
    [NullableContextAttribute("1")]
protected JsonException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal bool get_AppendPathInformation();
    [CompilerGeneratedAttribute]
internal void set_AppendPathInformation(bool value);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LineNumber();
    [CompilerGeneratedAttribute]
internal void set_LineNumber(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BytePositionInLine();
    [CompilerGeneratedAttribute]
internal void set_BytePositionInLine(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    internal void SetMessage(string message);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonHelpers : object {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    private static JsonHelpers();
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> GetSpan(Utf8JsonReader& reader);
    public static bool IsValidUnicodeScalar(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsInRangeInclusive(int value, int lowerBound, int upperBound);
    public static bool IsInRangeInclusive(long value, long lowerBound, long upperBound);
    public static bool IsInRangeInclusive(JsonTokenType value, JsonTokenType lowerBound, JsonTokenType upperBound);
    public static bool IsDigit(byte value);
    [ExtensionAttribute]
public static void ReadWithVerify(Utf8JsonReader& reader);
    public static string Utf8GetString(ReadOnlySpan`1<byte> bytes);
    public static bool TryAdd(Dictionary`2<TKey, TValue> dictionary, TKey& key, TValue& value);
    public static bool IsFinite(double value);
    public static bool IsFinite(float value);
    public static string FormatDateTimeOffset(DateTimeOffset value);
    public static string FormatDateTime(DateTime value);
    public static bool TryParseAsISO(ReadOnlySpan`1<char> source, DateTime& value);
    public static bool TryParseAsISO(ReadOnlySpan`1<char> source, DateTimeOffset& value);
    public static bool IsValidDateTimeOffsetParseLength(int length);
    public static bool IsValidDateTimeOffsetParseLength(long length);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    private static bool TryParseDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeParseData& parseData);
    private static bool TryGetNextTwoDigits(ReadOnlySpan`1<byte> source, Int32& value);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(DateTimeParseData parseData, DateTimeOffset& value);
    private static bool TryCreateDateTime(DateTimeParseData parseData, DateTimeKind kind, DateTime& value);
    public static Byte[] GetEscapedPropertyNameSection(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public static Byte[] EscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    private static Byte[] GetEscapedPropertyNameSection(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    private static Byte[] GetPropertyNameSection(ReadOnlySpan`1<byte> utf8Value);
    [CompilerGeneratedAttribute]
internal static bool <TryParseDateTimeOffset>g__ParseOffset|21_0(DateTimeParseData& parseData, ReadOnlySpan`1<byte> offsetData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.JsonNamingPolicy : object {
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <CamelCase>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <Default>k__BackingField;
    public static JsonNamingPolicy CamelCase { get; }
    internal static JsonNamingPolicy Default { get; }
    private static JsonNamingPolicy();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_CamelCase();
    [CompilerGeneratedAttribute]
internal static JsonNamingPolicy get_Default();
    public abstract virtual string ConvertName(string name);
}
internal abstract class System.Text.Json.JsonParameterInfo : object {
    [CompilerGeneratedAttribute]
private JsonConverter <ConverterBase>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDefaultValuesOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <NameAsUtf8Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    private JsonClassInfo _runtimeClassInfo;
    [CompilerGeneratedAttribute]
private Type <RuntimePropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDeserialize>k__BackingField;
    public JsonConverter ConverterBase { get; private set; }
    public object DefaultValue { get; protected set; }
    public bool IgnoreDefaultValuesOnRead { get; private set; }
    public JsonSerializerOptions Options { get; public set; }
    public Byte[] NameAsUtf8Bytes { get; private set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; private set; }
    public int Position { get; private set; }
    public JsonClassInfo RuntimeClassInfo { get; }
    internal Type RuntimePropertyType { get; internal set; }
    public bool ShouldDeserialize { get; private set; }
    [CompilerGeneratedAttribute]
public JsonConverter get_ConverterBase();
    [CompilerGeneratedAttribute]
private void set_ConverterBase(JsonConverter value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
protected void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreDefaultValuesOnRead();
    [CompilerGeneratedAttribute]
private void set_IgnoreDefaultValuesOnRead(bool value);
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
public Byte[] get_NameAsUtf8Bytes();
    [CompilerGeneratedAttribute]
private void set_NameAsUtf8Bytes(Byte[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
private void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public JsonClassInfo get_RuntimeClassInfo();
    [CompilerGeneratedAttribute]
internal Type get_RuntimePropertyType();
    [CompilerGeneratedAttribute]
internal void set_RuntimePropertyType(Type value);
    [CompilerGeneratedAttribute]
public bool get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
private void set_ShouldDeserialize(bool value);
    public virtual void Initialize(Type runtimePropertyType, ParameterInfo parameterInfo, JsonPropertyInfo matchingProperty, JsonSerializerOptions options);
    public static JsonParameterInfo CreateIgnoredParameterPlaceholder(JsonPropertyInfo matchingProperty);
}
internal class System.Text.Json.JsonParameterInfo`1 : JsonParameterInfo {
    [CompilerGeneratedAttribute]
private T <TypedDefaultValue>k__BackingField;
    public T TypedDefaultValue { get; private set; }
    [CompilerGeneratedAttribute]
public T get_TypedDefaultValue();
    [CompilerGeneratedAttribute]
private void set_TypedDefaultValue(T value);
    public virtual void Initialize(Type runtimePropertyType, ParameterInfo parameterInfo, JsonPropertyInfo matchingProperty, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonProperty : ValueType {
    [CompilerGeneratedAttribute]
private JsonElement <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <_name>k__BackingField;
    public JsonElement Value { get; }
    [NullableAttribute("2")]
private string _name { get; }
    public string Name { get; }
    private string DebuggerDisplay { get; }
    internal JsonProperty(JsonElement value, string name);
    [CompilerGeneratedAttribute]
public JsonElement get_Value();
    [CompilerGeneratedAttribute]
private string get__name();
    public string get_Name();
    [NullableContextAttribute("2")]
public bool NameEquals(string text);
    [NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<byte> utf8Text);
    [NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<char> text);
    internal bool EscapedNameEquals(ReadOnlySpan`1<byte> utf8Text);
    public void WriteTo(Utf8JsonWriter writer);
    public virtual string ToString();
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("MemberInfo={MemberInfo}")]
internal abstract class System.Text.Json.JsonPropertyInfo : object {
    public static JsonPropertyInfo s_missingProperty;
    private JsonClassInfo _runtimeClassInfo;
    public ClassType ClassType;
    [CompilerGeneratedAttribute]
private Type <DeclaredPropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDefaultValuesOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDefaultValuesOnWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsForClassInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameAsString>k__BackingField;
    public Byte[] NameAsUtf8Bytes;
    public Byte[] EscapedNameSection;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParentClassType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimePropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDeserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonNumberHandling> <NumberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropertyTypeCanBeNull>k__BackingField;
    public JsonConverter ConverterBase { get; public set; }
    public Type DeclaredPropertyType { get; private set; }
    public bool HasGetter { get; public set; }
    public bool HasSetter { get; public set; }
    public bool IgnoreDefaultValuesOnRead { get; private set; }
    public bool IgnoreDefaultValuesOnWrite { get; private set; }
    public bool IsForClassInfo { get; protected set; }
    public string NameAsString { get; private set; }
    protected JsonSerializerOptions Options { get; protected set; }
    public Type ParentClassType { get; private set; }
    public MemberInfo MemberInfo { get; private set; }
    public JsonClassInfo RuntimeClassInfo { get; }
    public Type RuntimePropertyType { get; private set; }
    public bool ShouldSerialize { get; private set; }
    public bool ShouldDeserialize { get; private set; }
    public bool IsIgnored { get; private set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; private set; }
    public bool PropertyTypeCanBeNull { get; protected set; }
    private static JsonPropertyInfo();
    public abstract virtual JsonConverter get_ConverterBase();
    public abstract virtual void set_ConverterBase(JsonConverter value);
    public static JsonPropertyInfo GetPropertyPlaceholder();
    public static JsonPropertyInfo CreateIgnoredPropertyPlaceholder(MemberInfo memberInfo, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public Type get_DeclaredPropertyType();
    [CompilerGeneratedAttribute]
private void set_DeclaredPropertyType(Type value);
    public virtual void GetPolicies(Nullable`1<JsonIgnoreCondition> ignoreCondition, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, bool defaultValueIsNull);
    private void DeterminePropertyName();
    private void DetermineSerializationCapabilities(Nullable`1<JsonIgnoreCondition> ignoreCondition);
    private void DetermineIgnoreCondition(Nullable`1<JsonIgnoreCondition> ignoreCondition, bool defaultValueIsNull);
    private void DetermineNumberHandling(Nullable`1<JsonNumberHandling> parentTypeNumberHandling);
    public static TAttribute GetAttribute(MemberInfo memberInfo);
    public abstract virtual bool GetMemberAndWriteJson(object obj, WriteStack& state, Utf8JsonWriter writer);
    public abstract virtual bool GetMemberAndWriteJsonExtensionData(object obj, WriteStack& state, Utf8JsonWriter writer);
    public abstract virtual object GetValueAsObject(object obj);
    [CompilerGeneratedAttribute]
public bool get_HasGetter();
    [CompilerGeneratedAttribute]
public void set_HasGetter(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasSetter();
    [CompilerGeneratedAttribute]
public void set_HasSetter(bool value);
    public virtual void Initialize(Type parentClassType, Type declaredPropertyType, Type runtimePropertyType, ClassType runtimeClassType, MemberInfo memberInfo, JsonConverter converter, Nullable`1<JsonIgnoreCondition> ignoreCondition, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public bool get_IgnoreDefaultValuesOnRead();
    [CompilerGeneratedAttribute]
private void set_IgnoreDefaultValuesOnRead(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreDefaultValuesOnWrite();
    [CompilerGeneratedAttribute]
private void set_IgnoreDefaultValuesOnWrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsForClassInfo();
    [CompilerGeneratedAttribute]
protected void set_IsForClassInfo(bool value);
    [CompilerGeneratedAttribute]
public string get_NameAsString();
    [CompilerGeneratedAttribute]
private void set_NameAsString(string value);
    [CompilerGeneratedAttribute]
protected JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
protected void set_Options(JsonSerializerOptions value);
    public bool ReadJsonAndAddExtensionProperty(object obj, ReadStack& state, Utf8JsonReader& reader);
    public abstract virtual bool ReadJsonAndSetMember(object obj, ReadStack& state, Utf8JsonReader& reader);
    public abstract virtual bool ReadJsonAsObject(ReadStack& state, Utf8JsonReader& reader, Object& value);
    public bool ReadJsonExtensionDataValue(ReadStack& state, Utf8JsonReader& reader, Object& value);
    [CompilerGeneratedAttribute]
public Type get_ParentClassType();
    [CompilerGeneratedAttribute]
private void set_ParentClassType(Type value);
    [CompilerGeneratedAttribute]
public MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
private void set_MemberInfo(MemberInfo value);
    public JsonClassInfo get_RuntimeClassInfo();
    [CompilerGeneratedAttribute]
public Type get_RuntimePropertyType();
    [CompilerGeneratedAttribute]
private void set_RuntimePropertyType(Type value);
    public abstract virtual void SetExtensionDictionaryAsObject(object obj, object extensionDict);
    [CompilerGeneratedAttribute]
public bool get_ShouldSerialize();
    [CompilerGeneratedAttribute]
private void set_ShouldSerialize(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
private void set_ShouldDeserialize(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsIgnored();
    [CompilerGeneratedAttribute]
private void set_IsIgnored(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonNumberHandling> get_NumberHandling();
    [CompilerGeneratedAttribute]
private void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    [CompilerGeneratedAttribute]
public bool get_PropertyTypeCanBeNull();
    [CompilerGeneratedAttribute]
protected void set_PropertyTypeCanBeNull(bool value);
}
internal class System.Text.Json.JsonPropertyInfo`1 : JsonPropertyInfo {
    private bool _converterIsExternalAndPolymorphic;
    [CompilerGeneratedAttribute]
private Func`2<object, T> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, T> <Set>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter`1<T> <Converter>k__BackingField;
    public Func`2<object, T> Get { get; private set; }
    public Action`2<object, T> Set { get; private set; }
    public JsonConverter`1<T> Converter { get; internal set; }
    public JsonConverter ConverterBase { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<object, T> get_Get();
    [CompilerGeneratedAttribute]
private void set_Get(Func`2<object, T> value);
    [CompilerGeneratedAttribute]
public Action`2<object, T> get_Set();
    [CompilerGeneratedAttribute]
private void set_Set(Action`2<object, T> value);
    [CompilerGeneratedAttribute]
public JsonConverter`1<T> get_Converter();
    [CompilerGeneratedAttribute]
internal void set_Converter(JsonConverter`1<T> value);
    public virtual void Initialize(Type parentClassType, Type declaredPropertyType, Type runtimePropertyType, ClassType runtimeClassType, MemberInfo memberInfo, JsonConverter converter, Nullable`1<JsonIgnoreCondition> ignoreCondition, Nullable`1<JsonNumberHandling> parentTypeNumberHandling, JsonSerializerOptions options);
    public virtual JsonConverter get_ConverterBase();
    public virtual void set_ConverterBase(JsonConverter value);
    public virtual object GetValueAsObject(object obj);
    public virtual bool GetMemberAndWriteJson(object obj, WriteStack& state, Utf8JsonWriter writer);
    public virtual bool GetMemberAndWriteJsonExtensionData(object obj, WriteStack& state, Utf8JsonWriter writer);
    public virtual bool ReadJsonAndSetMember(object obj, ReadStack& state, Utf8JsonReader& reader);
    public virtual bool ReadJsonAsObject(ReadStack& state, Utf8JsonReader& reader, Object& value);
    public virtual void SetExtensionDictionaryAsObject(object obj, object extensionDict);
}
internal class System.Text.Json.JsonReaderException : JsonException {
    public JsonReaderException(string message, long lineNumber, long bytePositionInLine);
    private JsonReaderException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonReaderHelper : object {
    private static ulong XorPowerOfTwoToHighByte;
    public static UTF8Encoding s_utf8Encoding;
    private static JsonReaderHelper();
    public static ValueTuple`2<int, int> CountNewLines(ReadOnlySpan`1<byte> data);
    [ExtensionAttribute]
internal static JsonValueKind ToValueKind(JsonTokenType tokenType);
    public static bool IsTokenTypePrimitive(JsonTokenType tokenType);
    public static bool IsHexDigit(byte nextByte);
    [ExtensionAttribute]
public static int IndexOfQuoteOrAnyControlOrBackSlash(ReadOnlySpan`1<byte> span);
    private static int IndexOfOrLessThan(Byte& searchSpace, byte value0, byte value1, byte lessThan, int length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    public static bool TryGetEscapedDateTime(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryGetEscapedDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    public static bool TryGetEscapedGuid(ReadOnlySpan`1<byte> source, Guid& value);
    public static char GetFloatingPointStandardParseFormat(ReadOnlySpan`1<byte> span);
    public static bool TryGetFloatingPointConstant(ReadOnlySpan`1<byte> span, Single& value);
    public static bool TryGetFloatingPointConstant(ReadOnlySpan`1<byte> span, Double& value);
    public static bool TryGetUnescapedBase64Bytes(ReadOnlySpan`1<byte> utf8Source, int idx, Byte[]& bytes);
    public static string GetUnescapedString(ReadOnlySpan`1<byte> utf8Source, int idx);
    public static ReadOnlySpan`1<byte> GetUnescapedSpan(ReadOnlySpan`1<byte> utf8Source, int idx);
    public static bool UnescapeAndCompare(ReadOnlySpan`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool UnescapeAndCompare(ReadOnlySequence`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool TryDecodeBase64InPlace(Span`1<byte> utf8Unescaped, Byte[]& bytes);
    public static bool TryDecodeBase64(ReadOnlySpan`1<byte> utf8Unescaped, Byte[]& bytes);
    public static string TranscodeHelper(ReadOnlySpan`1<byte> utf8Unescaped);
    internal static int GetUtf8ByteCount(ReadOnlySpan`1<char> text);
    internal static int GetUtf8FromText(ReadOnlySpan`1<char> text, Span`1<byte> dest);
    internal static string GetTextFromUtf8(ReadOnlySpan`1<byte> utf8Text);
    internal static void Unescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int idx, Int32& written);
    private static void EncodeToUtf8Bytes(UInt32 scalar, Span`1<byte> utf8Destination, Int32& bytesWritten);
}
public class System.Text.Json.JsonReaderOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
}
public class System.Text.Json.JsonReaderState : ValueType {
    internal long _lineNumber;
    internal long _bytePositionInLine;
    internal bool _inObject;
    internal bool _isNotPrimitive;
    internal char _numberFormat;
    internal bool _stringHasEscaping;
    internal bool _trailingCommaBeforeComment;
    internal JsonTokenType _tokenType;
    internal JsonTokenType _previousTokenType;
    internal JsonReaderOptions _readerOptions;
    internal BitStack _bitStack;
    public JsonReaderOptions Options { get; }
    public JsonReaderState(JsonReaderOptions options);
    public JsonReaderOptions get_Options();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Text.Json.JsonSerializer : object {
    internal static Byte[] s_idPropertyName;
    internal static Byte[] s_refPropertyName;
    internal static Byte[] s_valuesPropertyName;
    private static DynamicallyAccessedMemberTypes MembersAccessedOnRead;
    internal static JsonEncodedText s_metadataId;
    internal static JsonEncodedText s_metadataRef;
    internal static JsonEncodedText s_metadataValues;
    private static DynamicallyAccessedMemberTypes MembersAccessedOnWrite;
    private static JsonSerializer();
    internal static bool IsValidNumberHandlingValue(JsonNumberHandling handling);
    internal static bool ResolveMetadataForJsonObject(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal static bool ResolveMetadataForJsonArray(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    private static bool TryReadAheadMetadataAndSetState(Utf8JsonReader& reader, ReadStack& state, StackFrameObjectState nextState);
    internal static MetadataPropertyName GetMetadataPropertyName(ReadOnlySpan`1<byte> propertyName);
    internal static bool TryGetReferenceFromJsonElement(ReadStack& state, JsonElement element, Object& referenceValue);
    private static void ValidateValueIsCorrectType(object value, string referenceId);
    internal static JsonPropertyInfo LookupProperty(object obj, ReadOnlySpan`1<byte> unescapedPropertyName, ReadStack& state, Boolean& useExtensionProperty, bool createExtensionProperty);
    internal static ReadOnlySpan`1<byte> GetPropertyName(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    internal static void CreateDataExtensionProperty(object obj, JsonPropertyInfo jsonPropertyInfo);
    private static TValue ReadCore(Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options);
    private static TValue ReadCore(JsonConverter jsonConverter, Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    [NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<ReadAsync>d__20`1")]
private static ValueTask`1<TValue> ReadAsync(Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken);
    private static TValue ReadCore(JsonReaderState& readerState, bool isFinalBlock, ReadOnlySpan`1<byte> buffer, JsonSerializerOptions options, ReadStack& state, JsonConverter converterBase);
    [NullableContextAttribute("2")]
public static TValue Deserialize(string json, JsonSerializerOptions options);
    public static object Deserialize(string json, Type returnType, JsonSerializerOptions options);
    private static TValue Deserialize(string json, Type returnType, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options);
    private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName);
    private static TValue ReadValueCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state);
    public static Byte[] SerializeToUtf8Bytes(TValue value, JsonSerializerOptions options);
    public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerOptions options);
    private static Byte[] WriteCoreBytes(TValue& value, Type inputType, JsonSerializerOptions options);
    internal static MetadataPropertyName WriteReferenceForObject(JsonConverter jsonConverter, object currentValue, WriteStack& state, Utf8JsonWriter writer);
    internal static MetadataPropertyName WriteReferenceForCollection(JsonConverter jsonConverter, object currentValue, WriteStack& state, Utf8JsonWriter writer);
    private static void WriteCore(Utf8JsonWriter writer, TValue& value, Type inputType, JsonSerializerOptions options);
    private static bool WriteCore(JsonConverter jsonConverter, Utf8JsonWriter writer, TValue& value, JsonSerializerOptions options, WriteStack& state);
    public static Task SerializeAsync(Stream utf8Json, TValue value, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<WriteAsyncCore>d__42`1")]
private static Task WriteAsyncCore(Stream utf8Json, TValue value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static string Serialize(TValue value, JsonSerializerOptions options);
    public static string Serialize(object value, Type inputType, JsonSerializerOptions options);
    private static string Serialize(TValue& value, Type inputType, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, TValue value, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerOptions options);
    private static void Serialize(Utf8JsonWriter writer, TValue& value, Type type, JsonSerializerOptions options);
}
public enum System.Text.Json.JsonSerializerDefaults : Enum {
    public int value__;
    public static JsonSerializerDefaults General;
    public static JsonSerializerDefaults Web;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonSerializerOptions : object {
    private static Dictionary`2<Type, JsonConverter> s_defaultSimpleConverters;
    private static JsonConverter[] s_defaultFactoryConverters;
    private ConcurrentDictionary`2<Type, JsonConverter> _converters;
    private ConcurrentDictionary`2<Type, JsonConverter> _dictionaryKeyConverters;
    [CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    internal static int BufferSizeDefault;
    internal static JsonSerializerOptions s_defaultOptions;
    private ConcurrentDictionary`2<Type, JsonClassInfo> _classes;
    [CompilerGeneratedAttribute]
private JsonClassInfo <_lastClass>k__BackingField;
    private MemberAccessor _memberAccessorStrategy;
    private JsonNamingPolicy _dictionaryKeyPolicy;
    private JsonNamingPolicy _jsonPropertyNamingPolicy;
    private JsonCommentHandling _readCommentHandling;
    private ReferenceHandler _referenceHandler;
    private JavaScriptEncoder _encoder;
    private JsonIgnoreCondition _defaultIgnoreCondition;
    private JsonNumberHandling _numberHandling;
    private int _defaultBufferSize;
    private int _maxDepth;
    private bool _allowTrailingCommas;
    private bool _haveTypesBeenCreated;
    private bool _ignoreNullValues;
    private bool _ignoreReadOnlyProperties;
    private bool _ignoreReadonlyFields;
    private bool _includeFields;
    private bool _propertyNameCaseInsensitive;
    private bool _writeIndented;
    [CompilerGeneratedAttribute]
private int <EffectiveMaxDepth>k__BackingField;
    [NullableAttribute("1")]
public IList`1<JsonConverter> Converters { get; }
    private JsonClassInfo _lastClass { get; private set; }
    public bool AllowTrailingCommas { get; public set; }
    public int DefaultBufferSize { get; public set; }
    public JavaScriptEncoder Encoder { get; public set; }
    public JsonNamingPolicy DictionaryKeyPolicy { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool IgnoreNullValues { get; public set; }
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IncludeFields { get; public set; }
    public int MaxDepth { get; public set; }
    internal int EffectiveMaxDepth { get; private set; }
    public JsonNamingPolicy PropertyNamingPolicy { get; public set; }
    public bool PropertyNameCaseInsensitive { get; public set; }
    public JsonCommentHandling ReadCommentHandling { get; public set; }
    public bool WriteIndented { get; public set; }
    public ReferenceHandler ReferenceHandler { get; public set; }
    [NullableAttribute("1")]
internal MemberAccessor MemberAccessorStrategy { get; }
    [NullableContextAttribute("1")]
public JsonSerializerOptions(JsonSerializerOptions options);
    public JsonSerializerOptions(JsonSerializerDefaults defaults);
    private static JsonSerializerOptions();
    private static Dictionary`2<Type, JsonConverter> GetDefaultSimpleConverters();
    internal JsonConverter GetDictionaryKeyConverter(Type keyType);
    private static ConcurrentDictionary`2<Type, JsonConverter> GetDictionaryKeyConverters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    internal JsonConverter DetermineConverter(Type parentClassType, Type runtimePropertyType, MemberInfo memberInfo);
    [NullableContextAttribute("1")]
public JsonConverter GetConverter(Type typeToConvert);
    private JsonConverter GetConverterFromAttribute(JsonConverterAttribute converterAttribute, Type typeToConvert, Type classTypeAttributeIsOn, MemberInfo memberInfo);
    private static Attribute GetAttributeThatCanHaveMultiple(Type classType, Type attributeType, MemberInfo memberInfo);
    internal static Attribute GetAttributeThatCanHaveMultiple(Type classType, Type attributeType);
    private static Attribute GetAttributeThatCanHaveMultiple(Type attributeType, Type classType, MemberInfo memberInfo, Object[] attributes);
    [CompilerGeneratedAttribute]
private JsonClassInfo get__lastClass();
    [CompilerGeneratedAttribute]
private void set__lastClass(JsonClassInfo value);
    public bool get_AllowTrailingCommas();
    public void set_AllowTrailingCommas(bool value);
    public int get_DefaultBufferSize();
    public void set_DefaultBufferSize(int value);
    public JavaScriptEncoder get_Encoder();
    public void set_Encoder(JavaScriptEncoder value);
    public JsonNamingPolicy get_DictionaryKeyPolicy();
    public void set_DictionaryKeyPolicy(JsonNamingPolicy value);
    public bool get_IgnoreNullValues();
    public void set_IgnoreNullValues(bool value);
    public JsonIgnoreCondition get_DefaultIgnoreCondition();
    public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    public JsonNumberHandling get_NumberHandling();
    public void set_NumberHandling(JsonNumberHandling value);
    public bool get_IgnoreReadOnlyProperties();
    public void set_IgnoreReadOnlyProperties(bool value);
    public bool get_IgnoreReadOnlyFields();
    public void set_IgnoreReadOnlyFields(bool value);
    public bool get_IncludeFields();
    public void set_IncludeFields(bool value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_EffectiveMaxDepth();
    [CompilerGeneratedAttribute]
private void set_EffectiveMaxDepth(int value);
    public JsonNamingPolicy get_PropertyNamingPolicy();
    public void set_PropertyNamingPolicy(JsonNamingPolicy value);
    public bool get_PropertyNameCaseInsensitive();
    public void set_PropertyNameCaseInsensitive(bool value);
    public JsonCommentHandling get_ReadCommentHandling();
    public void set_ReadCommentHandling(JsonCommentHandling value);
    public bool get_WriteIndented();
    public void set_WriteIndented(bool value);
    public ReferenceHandler get_ReferenceHandler();
    public void set_ReferenceHandler(ReferenceHandler value);
    internal MemberAccessor get_MemberAccessorStrategy();
    internal JsonClassInfo GetOrAddClass(Type type);
    internal JsonClassInfo GetOrAddClassForRootType(Type type);
    internal bool TypeIsCached(Type type);
    internal JsonReaderOptions GetReaderOptions();
    internal JsonWriterOptions GetWriterOptions();
    internal void VerifyMutable();
    [CompilerGeneratedAttribute]
internal static void <GetDefaultSimpleConverters>g__Add|3_0(JsonConverter converter, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
private JsonConverter <GetDictionaryKeyConverter>g__GetEnumConverter|4_0(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static void <GetDictionaryKeyConverters>g__Add|6_0(JsonConverter converter, <>c__DisplayClass6_0& );
}
public enum System.Text.Json.JsonTokenType : Enum {
    public byte value__;
    public static JsonTokenType None;
    public static JsonTokenType StartObject;
    public static JsonTokenType EndObject;
    public static JsonTokenType StartArray;
    public static JsonTokenType EndArray;
    public static JsonTokenType PropertyName;
    public static JsonTokenType Comment;
    public static JsonTokenType String;
    public static JsonTokenType Number;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Null;
}
public enum System.Text.Json.JsonValueKind : Enum {
    public byte value__;
    public static JsonValueKind Undefined;
    public static JsonValueKind Object;
    public static JsonValueKind Array;
    public static JsonValueKind String;
    public static JsonValueKind Number;
    public static JsonValueKind True;
    public static JsonValueKind False;
    public static JsonValueKind Null;
}
internal static class System.Text.Json.JsonWriterHelper : object {
    private static StandardFormat s_dateTimeStandardFormat;
    public static int LastAsciiCharacter;
    private static StandardFormat s_hexStandardFormat;
    private static ReadOnlySpan`1<byte> AllowList { get; }
    private static JsonWriterHelper();
    public static void WriteIndentation(Span`1<byte> buffer, int indent);
    public static void ValidateProperty(ReadOnlySpan`1<byte> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<byte> value);
    public static void ValidateBytes(ReadOnlySpan`1<byte> bytes);
    public static void ValidateDouble(double value);
    public static void ValidateSingle(float value);
    public static void ValidateProperty(ReadOnlySpan`1<char> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndBytes(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public static void ValidatePropertyAndBytes(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> bytes);
    internal static void ValidateNumber(ReadOnlySpan`1<byte> utf8FormattedNumber);
    public static void WriteDateTimeTrimmed(Span`1<byte> buffer, DateTime value, Int32& bytesWritten);
    public static void WriteDateTimeOffsetTrimmed(Span`1<byte> buffer, DateTimeOffset value, Int32& bytesWritten);
    public static void TrimDateTimeOffset(Span`1<byte> buffer, Int32& bytesWritten);
    private static UInt32 DivMod(UInt32 numerator, UInt32 denominator, UInt32& modulo);
    private static ReadOnlySpan`1<byte> get_AllowList();
    private static bool NeedsEscaping(byte value);
    private static bool NeedsEscapingNoBoundsCheck(char value);
    public static int NeedsEscaping(ReadOnlySpan`1<byte> value, JavaScriptEncoder encoder);
    public static int NeedsEscaping(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static int GetMaxEscapedLength(int textLength, int firstIndexToEscape);
    private static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextBytes(byte value, Span`1<byte> destination, Int32& written);
    private static bool IsAsciiValue(byte value);
    private static bool IsAsciiValue(char value);
    private static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextChars(char value, Span`1<char> destination, Int32& written);
    private static int WriteHex(int value, Span`1<char> destination, int written);
    public static OperationStatus ToUtf8(ReadOnlySpan`1<byte> utf16Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten);
    private static int PtrDiff(Char* a, Char* b);
    private static int PtrDiff(Byte* a, Byte* b);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonWriterOptions : ValueType {
    private int _optionsMask;
    [CompilerGeneratedAttribute]
private JavaScriptEncoder <Encoder>k__BackingField;
    private static int IndentBit;
    private static int SkipValidationBit;
    public JavaScriptEncoder Encoder { get; public set; }
    public bool Indented { get; public set; }
    public bool SkipValidation { get; public set; }
    internal bool IndentedOrNotSkipValidation { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public JavaScriptEncoder get_Encoder();
    [CompilerGeneratedAttribute]
public void set_Encoder(JavaScriptEncoder value);
    public bool get_Indented();
    public void set_Indented(bool value);
    public bool get_SkipValidation();
    public void set_SkipValidation(bool value);
    internal bool get_IndentedOrNotSkipValidation();
}
internal abstract class System.Text.Json.MemberAccessor : object {
    public abstract virtual ConstructorDelegate CreateConstructor(Type classType);
    public abstract virtual ParameterizedConstructorDelegate`1<T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public abstract virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public abstract virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    public abstract virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    public abstract virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    public abstract virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public abstract virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    public abstract virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public abstract virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
}
internal enum System.Text.Json.MetadataPropertyName : Enum {
    public int value__;
    public static MetadataPropertyName NoMetadata;
    public static MetadataPropertyName Values;
    public static MetadataPropertyName Id;
    public static MetadataPropertyName Ref;
}
internal enum System.Text.Json.NumericType : Enum {
    public int value__;
    public static NumericType Byte;
    public static NumericType SByte;
    public static NumericType Int16;
    public static NumericType Int32;
    public static NumericType Int64;
    public static NumericType UInt16;
    public static NumericType UInt32;
    public static NumericType UInt64;
    public static NumericType Single;
    public static NumericType Double;
    public static NumericType Decimal;
}
[IsReadOnlyAttribute]
internal class System.Text.Json.ParameterRef : ValueType {
    public ulong Key;
    public JsonParameterInfo Info;
    public Byte[] NameFromJson;
    public ParameterRef(ulong key, JsonParameterInfo info, Byte[] nameFromJson);
}
internal class System.Text.Json.PooledByteBufferWriter : object {
    private Byte[] _rentedBuffer;
    private int _index;
    private static int MinimumBufferSize;
    public ReadOnlyMemory`1<byte> WrittenMemory { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public PooledByteBufferWriter(int initialCapacity);
    public ReadOnlyMemory`1<byte> get_WrittenMemory();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    private void ClearHelper();
    public sealed virtual void Dispose();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    internal Task WriteToStreamAsync(Stream destination, CancellationToken cancellationToken);
    private void CheckAndResizeBuffer(int sizeHint);
}
[IsReadOnlyAttribute]
internal class System.Text.Json.PropertyRef : ValueType {
    public ulong Key;
    public JsonPropertyInfo Info;
    public Byte[] NameFromJson;
    public PropertyRef(ulong key, JsonPropertyInfo info, Byte[] nameFromJson);
}
[DebuggerDisplayAttribute("Path:{JsonPath()} Current: ClassType.{Current.JsonClassInfo.ClassType}, {Current.JsonClassInfo.Type.Name}")]
internal class System.Text.Json.ReadStack : ValueType {
    internal static Char[] SpecialCharacters;
    private int _continuationCount;
    private int _count;
    private List`1<ReadStackFrame> _previous;
    private List`1<ArgumentState> _ctorArgStateCache;
    public long BytesConsumed;
    public ReadStackFrame Current;
    public bool ReadAhead;
    public ReferenceResolver ReferenceResolver;
    public bool SupportContinuation;
    public bool UseFastPath;
    public bool IsContinuation { get; }
    public bool IsLastContinuation { get; }
    private static ReadStack();
    public bool get_IsContinuation();
    public bool get_IsLastContinuation();
    private void AddCurrent();
    public void Initialize(Type type, JsonSerializerOptions options, bool supportContinuation);
    public void Push();
    public void Pop(bool success);
    public string JsonPath();
    private void SetConstructorArgumentState();
    [CompilerGeneratedAttribute]
internal static void <JsonPath>g__AppendStackFrame|19_0(StringBuilder sb, ReadStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static int <JsonPath>g__GetCount|19_1(IEnumerable enumerable);
    [CompilerGeneratedAttribute]
internal static void <JsonPath>g__AppendPropertyName|19_2(StringBuilder sb, string propertyName);
    [CompilerGeneratedAttribute]
internal static string <JsonPath>g__GetPropertyName|19_3(ReadStackFrame& frame);
}
[DebuggerDisplayAttribute("ClassType.{JsonClassInfo.ClassType}, {JsonClassInfo.Type.Name}")]
internal class System.Text.Json.ReadStackFrame : ValueType {
    public JsonPropertyInfo JsonPropertyInfo;
    public StackFramePropertyState PropertyState;
    public bool UseExtensionProperty;
    public Byte[] JsonPropertyName;
    public string JsonPropertyNameAsString;
    public object DictionaryKey;
    public int OriginalDepth;
    public JsonTokenType OriginalTokenType;
    public object ReturnValue;
    public JsonClassInfo JsonClassInfo;
    public StackFrameObjectState ObjectState;
    public bool ValidateEndTokenOnArray;
    public int PropertyIndex;
    public List`1<PropertyRef> PropertyRefCache;
    public int CtorArgumentStateIndex;
    public ArgumentState CtorArgumentState;
    public Nullable`1<JsonNumberHandling> NumberHandling;
    public void EndConstructorParameter();
    public void EndProperty();
    public void EndElement();
    public bool IsProcessingDictionary();
    public bool IsProcessingEnumerable();
    public void Reset();
}
[DefaultMemberAttribute("Item")]
internal class System.Text.Json.Serialization.ConverterList : object {
    private List`1<JsonConverter> _list;
    private JsonSerializerOptions _options;
    public JsonConverter Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ConverterList(JsonSerializerOptions options);
    public ConverterList(JsonSerializerOptions options, ConverterList source);
    public sealed virtual JsonConverter get_Item(int index);
    public sealed virtual void set_Item(int index, JsonConverter value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(JsonConverter item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JsonConverter item);
    public sealed virtual void CopyTo(JsonConverter[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<JsonConverter> GetEnumerator();
    public sealed virtual int IndexOf(JsonConverter item);
    public sealed virtual void Insert(int index, JsonConverter item);
    public sealed virtual bool Remove(JsonConverter item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Text.Json.Serialization.Converters.ArrayConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanHaveIdMetadata { get; }
    internal virtual bool get_CanHaveIdMetadata();
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.BooleanConverter : JsonConverter`1<bool> {
    public virtual bool Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, bool value, JsonSerializerOptions options);
    internal virtual bool ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, bool value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.ByteArrayConverter : JsonConverter`1<Byte[]> {
    public virtual Byte[] Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Byte[] value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ByteConverter : JsonConverter`1<byte> {
    public virtual byte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, byte value, JsonSerializerOptions options);
    internal virtual byte ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, byte value, JsonSerializerOptions options, WriteStack& state);
    internal virtual byte ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, byte value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.CharConverter : JsonConverter`1<char> {
    public virtual char Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, char value, JsonSerializerOptions options);
    internal virtual char ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, char value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.ConcurrentQueueOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.ConcurrentStackOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DateTimeConverter : JsonConverter`1<DateTime> {
    public virtual DateTime Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options);
    internal virtual DateTime ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DateTimeOffsetConverter : JsonConverter`1<DateTimeOffset> {
    public virtual DateTimeOffset Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options);
    internal virtual DateTimeOffset ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DecimalConverter : JsonConverter`1<decimal> {
    public virtual decimal Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options);
    internal virtual decimal ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options, WriteStack& state);
    internal virtual decimal ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, decimal value, JsonNumberHandling handling);
}
internal abstract class System.Text.Json.Serialization.Converters.DictionaryDefaultConverter`3 : JsonDictionaryConverter`1<TCollection> {
    private static Type s_valueType;
    protected Type KeyType;
    protected bool IsStringKey;
    protected JsonConverter`1<TKey> _keyConverter;
    protected JsonConverter`1<TValue> _valueConverter;
    internal Type ElementType { get; }
    private static DictionaryDefaultConverter`3();
    protected abstract virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    internal virtual Type get_ElementType();
    protected static JsonConverter`1<TValue> GetValueConverter(JsonClassInfo elementClassInfo);
    protected static JsonConverter`1<TKey> GetKeyConverter(Type keyType, JsonSerializerOptions options);
    internal sealed virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TCollection& value);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, TCollection dictionary, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void CreateInstanceForReferenceResolver(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
private TKey <OnTryRead>g__ReadDictionaryKey|12_0(Utf8JsonReader& reader, ReadStack& state, <>c__DisplayClass12_0& );
}
internal class System.Text.Json.Serialization.Converters.DictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TCollection, TKey, TValue> {
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.DoubleConverter : JsonConverter`1<double> {
    public virtual double Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, double value, JsonSerializerOptions options);
    internal virtual double ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, double value, JsonSerializerOptions options, WriteStack& state);
    internal virtual double ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, double value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.EnumConverter`1 : JsonConverter`1<T> {
    private static TypeCode s_enumTypeCode;
    private static string s_negativeSign;
    private static string ValueSeparator;
    private EnumConverterOptions _converterOptions;
    private JsonNamingPolicy _namingPolicy;
    private ConcurrentDictionary`2<ulong, JsonEncodedText> _nameCache;
    private static int NameCacheSizeSoftLimit;
    public EnumConverter`1(EnumConverterOptions converterOptions, JsonSerializerOptions serializerOptions);
    public EnumConverter`1(EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions serializerOptions);
    private static EnumConverter`1();
    public virtual bool CanConvert(Type type);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    private static ulong ConvertToUInt64(object value);
    private static bool IsValidIdentifier(string value);
    private JsonEncodedText FormatEnumValue(string value, JavaScriptEncoder encoder);
    private string FormatEnumValueToString(string value, JavaScriptEncoder encoder);
    internal virtual T ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.EnumConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type type);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
}
[FlagsAttribute]
internal enum System.Text.Json.Serialization.Converters.EnumConverterOptions : Enum {
    public int value__;
    public static EnumConverterOptions AllowStrings;
    public static EnumConverterOptions AllowNumbers;
}
internal class System.Text.Json.Serialization.Converters.GuidConverter : JsonConverter`1<Guid> {
    public virtual Guid Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options);
    internal virtual Guid ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.ICollectionOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IDictionaryConverter`1 : DictionaryDefaultConverter`3<TCollection, string, object> {
    private JsonConverter`1<object> _objectConverter;
    internal Type RuntimeType { get; }
    protected virtual void Add(string key, Object& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    private static JsonConverter`1<object> GetObjectKeyConverter(JsonSerializerOptions options);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TCollection, TKey, TValue> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IEnumerableConverter`1 : IEnumerableDefaultConverter`2<TCollection, object> {
    internal Type RuntimeType { get; }
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IEnumerableConverterFactory : JsonConverterFactory {
    private static IDictionaryConverter`1<IDictionary> s_converterForIDictionary;
    private static IEnumerableConverter`1<IEnumerable> s_converterForIEnumerable;
    private static IListConverter`1<IList> s_converterForIList;
    private static IEnumerableConverterFactory();
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Converters.IEnumerableDefaultConverter`2 : JsonCollectionConverter`2<TCollection, TElement> {
    protected abstract virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected abstract virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected static JsonConverter`1<TElement> GetElementConverter(JsonClassInfo elementClassInfo);
    protected static JsonConverter`1<TElement> GetElementConverter(WriteStack& state);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, TCollection& value);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    protected abstract virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void CreateInstanceForReferenceResolver(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.IEnumerableOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IEnumerableWithAddMethodConverter`1 : IEnumerableDefaultConverter`2<TCollection, object> {
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.IListConverter`1 : IEnumerableDefaultConverter`2<TCollection, object> {
    internal Type RuntimeType { get; }
    protected virtual void Add(Object& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.IListOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.ImmutableDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TCollection, TKey, TValue> {
    internal bool CanHaveIdMetadata { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    internal virtual bool get_CanHaveIdMetadata();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.ImmutableEnumerableOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal bool CanHaveIdMetadata { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    internal virtual bool get_CanHaveIdMetadata();
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual void ConvertCollection(ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.Int16Converter : JsonConverter`1<short> {
    public virtual short Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, short value, JsonSerializerOptions options);
    internal virtual short ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, short value, JsonSerializerOptions options, WriteStack& state);
    internal virtual short ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, short value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.Int32Converter : JsonConverter`1<int> {
    public virtual int Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options);
    internal virtual int ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, int value, JsonSerializerOptions options, WriteStack& state);
    internal virtual int ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, int value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.Int64Converter : JsonConverter`1<long> {
    public virtual long Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options);
    internal virtual long ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, long value, JsonSerializerOptions options, WriteStack& state);
    internal virtual long ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, long value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.IReadOnlyDictionaryOfTKeyTValueConverter`3 : DictionaryDefaultConverter`3<TCollection, TKey, TValue> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TKey key, TValue& modreq(System.Runtime.InteropServices.InAttribute) value, JsonSerializerOptions options, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state);
    protected internal virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.ISetOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    internal Type RuntimeType { get; }
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
    internal virtual Type get_RuntimeType();
}
internal class System.Text.Json.Serialization.Converters.JsonDocumentConverter : JsonConverter`1<JsonDocument> {
    public virtual JsonDocument Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonDocument value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonElementConverter : JsonConverter`1<JsonElement> {
    public virtual JsonElement Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonElement value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.KeyValuePairConverter`2 : SmallObjectWithParameterizedConstructorConverter`5<KeyValuePair`2<TKey, TValue>, TKey, TValue, object, object> {
    private static string KeyNameCLR;
    private static string ValueNameCLR;
    private static int NumProperties;
    private string _keyName;
    private string _valueName;
    private static ConstructorInfo s_constructorInfo;
    private static KeyValuePairConverter`2();
    internal virtual void Initialize(JsonSerializerOptions options);
    protected virtual bool TryLookupConstructorParameter(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options, JsonParameterInfo& jsonParameterInfo);
    protected virtual void EndRead(ReadStack& state);
    private bool FoundKeyProperty(string propertyName, bool caseInsensitiveMatch);
    private bool FoundValueProperty(string propertyName, bool caseInsensitiveMatch);
}
internal class System.Text.Json.Serialization.Converters.LargeObjectWithParameterizedConstructorConverter`1 : ObjectWithParameterizedConstructorConverter`1<T> {
    protected virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    protected virtual object CreateObject(ReadStackFrame& frame);
    protected virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ListOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.NullableConverter`1 : JsonConverter`1<Nullable`1<T>> {
    private JsonConverter`1<T> _converter;
    public NullableConverter`1(JsonConverter`1<T> converter);
    public virtual Nullable`1<T> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Nullable`1<T> value, JsonSerializerOptions options);
    internal virtual Nullable`1<T> ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling numberHandling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, Nullable`1<T> value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.NullableConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    public static JsonConverter CreateValueConverter(Type valueTypeToConvert, JsonConverter valueConverter);
}
internal class System.Text.Json.Serialization.Converters.ObjectConverter : JsonConverter`1<object> {
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
    internal virtual object ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    private JsonConverter GetRuntimeConverter(Type runtimeType, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.ObjectConverterFactory : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    private bool IsKeyValuePair(Type typeToConvert);
    private JsonConverter CreateKeyValuePairConverter(Type type, JsonSerializerOptions options);
    private ConstructorInfo GetDeserializationConstructor(Type type);
}
internal class System.Text.Json.Serialization.Converters.ObjectDefaultConverter`1 : JsonObjectConverter`1<T> {
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal sealed virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    protected void ReadPropertyValue(object obj, ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo, bool useExtensionProperty);
    protected bool ReadAheadPropertyValue(ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo);
    internal sealed virtual void CreateInstanceForReferenceResolver(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter`1 : ObjectDefaultConverter`1<T> {
    internal bool ConstructorIsParameterized { get; }
    internal sealed virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    protected abstract virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
    protected abstract virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    protected abstract virtual object CreateObject(ReadStackFrame& frame);
    private void ReadConstructorArguments(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    private bool ReadConstructorArgumentsWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    private bool HandleConstructorArgumentWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    private bool HandlePropertyWithContinuation(ReadStack& state, Utf8JsonReader& reader, JsonPropertyInfo jsonPropertyInfo);
    private void BeginRead(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options);
    protected virtual void EndRead(ReadStack& state);
    protected virtual bool TryLookupConstructorParameter(ReadStack& state, Utf8JsonReader& reader, JsonSerializerOptions options, JsonParameterInfo& jsonParameterInfo);
    internal virtual bool get_ConstructorIsParameterized();
}
internal class System.Text.Json.Serialization.Converters.QueueOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.SByteConverter : JsonConverter`1<sbyte> {
    public virtual sbyte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options);
    internal virtual sbyte ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options, WriteStack& state);
    internal virtual sbyte ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, sbyte value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.SingleConverter : JsonConverter`1<float> {
    public virtual float Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, float value, JsonSerializerOptions options);
    internal virtual float ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, float value, JsonSerializerOptions options, WriteStack& state);
    internal virtual float ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, float value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.SmallObjectWithParameterizedConstructorConverter`5 : ObjectWithParameterizedConstructorConverter`1<T> {
    protected virtual object CreateObject(ReadStackFrame& frame);
    protected virtual bool ReadAndCacheConstructorArgument(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo);
    private bool TryRead(ReadStack& state, Utf8JsonReader& reader, JsonParameterInfo jsonParameterInfo, TArg& arg);
    protected virtual void InitializeConstructorArgumentCaches(ReadStack& state, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.StackOfTConverter`2 : IEnumerableDefaultConverter`2<TCollection, TElement> {
    protected virtual void Add(TElement& modreq(System.Runtime.InteropServices.InAttribute) value, ReadStack& state);
    protected virtual void CreateCollection(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    protected virtual bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.StringConverter : JsonConverter`1<string> {
    public virtual string Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options);
    internal virtual string ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, string value, JsonSerializerOptions options, WriteStack& state);
}
internal class System.Text.Json.Serialization.Converters.TypeConverter : JsonConverter`1<Type> {
    public virtual Type Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Type value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.UInt16Converter : JsonConverter`1<ushort> {
    public virtual ushort Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options);
    internal virtual ushort ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options, WriteStack& state);
    internal virtual ushort ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ushort value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UInt32Converter : JsonConverter`1<UInt32> {
    public virtual UInt32 Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options);
    internal virtual UInt32 ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options, WriteStack& state);
    internal virtual UInt32 ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, UInt32 value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UInt64Converter : JsonConverter`1<ulong> {
    public virtual ulong Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options);
    internal virtual ulong ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options, WriteStack& state);
    internal virtual ulong ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ulong value, JsonNumberHandling handling);
}
internal class System.Text.Json.Serialization.Converters.UriConverter : JsonConverter`1<Uri> {
    public virtual Uri Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options);
}
[ExtensionAttribute]
internal static class System.Text.Json.Serialization.IEnumerableConverterFactoryHelpers : object {
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    private static string CreateRangeMethodName;
    private static string CreateRangeMethodNameForEnumerable;
    private static string CreateRangeMethodNameForDictionary;
    private static string ImmutableCollectionsAssembly;
    [ExtensionAttribute]
internal static Type GetCompatibleGenericBaseClass(Type type, Type baseType);
    [ExtensionAttribute]
internal static Type GetCompatibleGenericInterface(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool IsImmutableDictionaryType(Type type);
    [ExtensionAttribute]
public static bool IsImmutableEnumerableType(Type type);
    [ExtensionAttribute]
[DynamicDependencyAttribute("CreateRange`1", "System.Collections.Immutable.ImmutableArray", "System.Collections.Immutable")]
[DynamicDependencyAttribute("CreateRange`1", "System.Collections.Immutable.ImmutableList", "System.Collections.Immutable")]
[DynamicDependencyAttribute("CreateRange`1", "System.Collections.Immutable.ImmutableStack", "System.Collections.Immutable")]
[DynamicDependencyAttribute("CreateRange`1", "System.Collections.Immutable.ImmutableQueue", "System.Collections.Immutable")]
[DynamicDependencyAttribute("CreateRange`1", "System.Collections.Immutable.ImmutableSortedSet", "System.Collections.Immutable")]
[DynamicDependencyAttribute("CreateRange`1", "System.Collections.Immutable.ImmutableHashSet", "System.Collections.Immutable")]
public static MethodInfo GetImmutableEnumerableCreateRangeMethod(Type type, Type elementType);
    [ExtensionAttribute]
[DynamicDependencyAttribute("CreateRange`2", "System.Collections.Immutable.ImmutableDictionary", "System.Collections.Immutable")]
[DynamicDependencyAttribute("CreateRange`2", "System.Collections.Immutable.ImmutableSortedDictionary", "System.Collections.Immutable")]
public static MethodInfo GetImmutableDictionaryCreateRangeMethod(Type type, Type keyType, Type valueType);
    private static Type GetImmutableEnumerableConstructingType(Type type);
    private static Type GetImmutableDictionaryConstructingType(Type type);
    [ExtensionAttribute]
public static bool IsNonGenericStackOrQueue(Type type);
    private static Type GetTypeIfExists(string name);
}
public abstract class System.Text.Json.Serialization.JsonAttribute : Attribute {
}
internal abstract class System.Text.Json.Serialization.JsonCollectionConverter`2 : JsonResumableConverter`1<TCollection> {
    internal ClassType ClassType { get; }
    internal Type ElementType { get; }
    internal sealed virtual ClassType get_ClassType();
    internal virtual Type get_ElementType();
}
[AttributeUsageAttribute("32")]
public class System.Text.Json.Serialization.JsonConstructorAttribute : JsonAttribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverter : object {
    [CompilerGeneratedAttribute]
private bool <CanUseDirectReadOrWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBePolymorphic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInternalConverter>k__BackingField;
    internal bool IsInternalConverterForNumberType;
    [CompilerGeneratedAttribute]
private bool <ConstructorIsParameterized>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <ConstructorInfo>k__BackingField;
    internal ClassType ClassType { get; }
    internal bool CanUseDirectReadOrWrite { get; internal set; }
    internal bool CanHaveIdMetadata { get; }
    internal bool CanBePolymorphic { get; internal set; }
    [NullableAttribute("2")]
internal Type ElementType { get; }
    internal bool IsValueType { get; internal set; }
    internal bool IsInternalConverter { get; internal set; }
    internal Type RuntimeType { get; }
    internal Type TypeToConvert { get; }
    internal bool ConstructorIsParameterized { get; }
    [NullableAttribute("2")]
internal ConstructorInfo ConstructorInfo { get; internal set; }
    public abstract virtual bool CanConvert(Type typeToConvert);
    internal abstract virtual ClassType get_ClassType();
    [CompilerGeneratedAttribute]
internal bool get_CanUseDirectReadOrWrite();
    [CompilerGeneratedAttribute]
internal void set_CanUseDirectReadOrWrite(bool value);
    internal virtual bool get_CanHaveIdMetadata();
    [CompilerGeneratedAttribute]
internal bool get_CanBePolymorphic();
    [CompilerGeneratedAttribute]
internal void set_CanBePolymorphic(bool value);
    internal abstract virtual JsonPropertyInfo CreateJsonPropertyInfo();
    internal abstract virtual JsonParameterInfo CreateJsonParameterInfo();
    internal abstract virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
internal bool get_IsValueType();
    [CompilerGeneratedAttribute]
internal void set_IsValueType(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsInternalConverter();
    [CompilerGeneratedAttribute]
internal void set_IsInternalConverter(bool value);
    internal abstract virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal virtual Type get_RuntimeType();
    internal bool ShouldFlush(Utf8JsonWriter writer, WriteStack& state);
    internal abstract virtual Type get_TypeToConvert();
    internal abstract virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal abstract virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal abstract virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal abstract virtual void WriteWithQuotesAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    [CompilerGeneratedAttribute]
internal virtual bool get_ConstructorIsParameterized();
    [CompilerGeneratedAttribute]
internal ConstructorInfo get_ConstructorInfo();
    [CompilerGeneratedAttribute]
internal void set_ConstructorInfo(ConstructorInfo value);
    internal virtual void Initialize(JsonSerializerOptions options);
    internal virtual void CreateInstanceForReferenceResolver(Utf8JsonReader& reader, ReadStack& state, JsonSerializerOptions options);
    internal static bool SingleValueReadWithReadAhead(ClassType classType, Utf8JsonReader& reader, ReadStack& state);
    internal static bool DoSingleValueReadWithReadAhead(Utf8JsonReader& reader, ReadStack& state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverter`1 : JsonConverter {
    [CompilerGeneratedAttribute]
private bool <HandleNullOnRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HandleNullOnWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeNull>k__BackingField;
    internal ClassType ClassType { get; }
    [NullableAttribute("2")]
internal Type ElementType { get; }
    public bool HandleNull { get; }
    internal bool HandleNullOnRead { get; private set; }
    internal bool HandleNullOnWrite { get; private set; }
    internal bool CanBeNull { get; }
    internal Type TypeToConvert { get; }
    internal sealed virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal T ReadCore(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal bool WriteCore(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state);
    public virtual bool CanConvert(Type typeToConvert);
    internal virtual ClassType get_ClassType();
    internal sealed virtual JsonPropertyInfo CreateJsonPropertyInfo();
    internal sealed virtual JsonParameterInfo CreateJsonParameterInfo();
    internal virtual Type get_ElementType();
    public virtual bool get_HandleNull();
    [CompilerGeneratedAttribute]
internal bool get_HandleNullOnRead();
    [CompilerGeneratedAttribute]
private void set_HandleNullOnRead(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HandleNullOnWrite();
    [CompilerGeneratedAttribute]
private void set_HandleNullOnWrite(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CanBeNull();
    internal sealed virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal virtual bool OnTryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    public abstract virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    internal bool TryRead(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options, ReadStack& state, T& value);
    internal sealed virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal bool TryWrite(Utf8JsonWriter writer, T& value, JsonSerializerOptions options, WriteStack& state);
    internal bool TryWriteDataExtensionProperty(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual Type get_TypeToConvert();
    internal void VerifyRead(JsonTokenType tokenType, int depth, long bytesConsumed, bool isValueConverter, Utf8JsonReader& reader);
    internal void VerifyWrite(int originalDepth, Utf8JsonWriter writer);
    public abstract virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual T ReadWithQuotes(Utf8JsonReader& reader);
    internal virtual void WriteWithQuotes(Utf8JsonWriter writer, T value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void WriteWithQuotesAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal virtual T ReadNumberWithCustomHandling(Utf8JsonReader& reader, JsonNumberHandling handling);
    internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("412")]
public class System.Text.Json.Serialization.JsonConverterAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    [NullableAttribute("2")]
[DynamicallyAccessedMembersAttribute("1")]
public Type ConverterType { get; private set; }
    public JsonConverterAttribute(Type converterType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
private void set_ConverterType(Type value);
    public virtual JsonConverter CreateConverter(Type typeToConvert);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverterFactory : JsonConverter {
    internal ClassType ClassType { get; }
    [NullableAttribute("2")]
internal Type ElementType { get; }
    internal Type TypeToConvert { get; }
    internal sealed virtual ClassType get_ClassType();
    public abstract virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    internal virtual JsonPropertyInfo CreateJsonPropertyInfo();
    internal virtual JsonParameterInfo CreateJsonParameterInfo();
    internal sealed virtual Type get_ElementType();
    internal JsonConverter GetConverterInternal(Type typeToConvert, JsonSerializerOptions options);
    internal sealed virtual object ReadCoreAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state);
    internal sealed virtual bool TryReadAsObject(Utf8JsonReader& reader, JsonSerializerOptions options, ReadStack& state, Object& value);
    internal sealed virtual bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual Type get_TypeToConvert();
    internal sealed virtual bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
    internal sealed virtual void WriteWithQuotesAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, WriteStack& state);
}
internal abstract class System.Text.Json.Serialization.JsonDictionaryConverter`1 : JsonResumableConverter`1<T> {
    internal ClassType ClassType { get; }
    internal sealed virtual ClassType get_ClassType();
    protected internal abstract virtual bool OnWriteResume(Utf8JsonWriter writer, T dictionary, JsonSerializerOptions options, WriteStack& state);
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonExtensionDataAttribute : JsonAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonIgnoreAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonIgnoreCondition <Condition>k__BackingField;
    public JsonIgnoreCondition Condition { get; public set; }
    [CompilerGeneratedAttribute]
public JsonIgnoreCondition get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(JsonIgnoreCondition value);
}
public enum System.Text.Json.Serialization.JsonIgnoreCondition : Enum {
    public int value__;
    public static JsonIgnoreCondition Never;
    public static JsonIgnoreCondition Always;
    public static JsonIgnoreCondition WhenWritingDefault;
    public static JsonIgnoreCondition WhenWritingNull;
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonIncludeAttribute : JsonAttribute {
}
[FlagsAttribute]
public enum System.Text.Json.Serialization.JsonNumberHandling : Enum {
    public int value__;
    public static JsonNumberHandling Strict;
    public static JsonNumberHandling AllowReadingFromString;
    public static JsonNumberHandling WriteAsString;
    public static JsonNumberHandling AllowNamedFloatingPointLiterals;
}
[AttributeUsageAttribute("396")]
public class System.Text.Json.Serialization.JsonNumberHandlingAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private JsonNumberHandling <Handling>k__BackingField;
    public JsonNumberHandling Handling { get; }
    public JsonNumberHandlingAttribute(JsonNumberHandling handling);
    [CompilerGeneratedAttribute]
public JsonNumberHandling get_Handling();
}
internal abstract class System.Text.Json.Serialization.JsonObjectConverter`1 : JsonResumableConverter`1<T> {
    internal ClassType ClassType { get; }
    internal Type ElementType { get; }
    internal sealed virtual ClassType get_ClassType();
    internal sealed virtual Type get_ElementType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonPropertyNameAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public JsonPropertyNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
internal abstract class System.Text.Json.Serialization.JsonResumableConverter`1 : JsonConverter`1<T> {
    public bool HandleNull { get; }
    public sealed virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public sealed virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public sealed virtual bool get_HandleNull();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.JsonStringEnumConverter : JsonConverterFactory {
    private JsonNamingPolicy _namingPolicy;
    private EnumConverterOptions _converterOptions;
    [NullableContextAttribute("2")]
public JsonStringEnumConverter(JsonNamingPolicy namingPolicy, bool allowIntegerValues);
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.PreserveReferenceHandler : ReferenceHandler {
    public virtual ReferenceResolver CreateResolver();
    internal virtual ReferenceResolver CreateResolver(bool writing);
}
internal class System.Text.Json.Serialization.PreserveReferenceResolver : ReferenceResolver {
    private UInt32 _referenceCount;
    private Dictionary`2<string, object> _referenceIdToObjectMap;
    private Dictionary`2<object, string> _objectToReferenceIdMap;
    public PreserveReferenceResolver(bool writing);
    public virtual void AddReference(string referenceId, object value);
    public virtual string GetReference(object value, Boolean& alreadyExists);
    public virtual object ResolveReference(string referenceId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.ReferenceHandler : object {
    [CompilerGeneratedAttribute]
private static ReferenceHandler <Preserve>k__BackingField;
    public static ReferenceHandler Preserve { get; }
    private static ReferenceHandler();
    [CompilerGeneratedAttribute]
public static ReferenceHandler get_Preserve();
    public abstract virtual ReferenceResolver CreateResolver();
    internal virtual ReferenceResolver CreateResolver(bool writing);
}
public class System.Text.Json.Serialization.ReferenceHandler`1 : ReferenceHandler {
    [NullableContextAttribute("1")]
public virtual ReferenceResolver CreateResolver();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.ReferenceResolver : object {
    public abstract virtual void AddReference(string referenceId, object value);
    public abstract virtual string GetReference(object value, Boolean& alreadyExists);
    public abstract virtual object ResolveReference(string referenceId);
}
internal class System.Text.Json.Serialization.ReflectionEmitMemberAccessor : MemberAccessor {
    public virtual ConstructorDelegate CreateConstructor(Type type);
    public virtual ParameterizedConstructorDelegate`1<T> CreateParameterizedConstructor(ConstructorInfo constructor);
    private static DynamicMethod CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    private static DynamicMethod CreateParameterizedConstructor(ConstructorInfo constructor, Type parameterType1, Type parameterType2, Type parameterType3, Type parameterType4);
    public virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    private static DynamicMethod CreateAddMethodDelegate(Type collectionType);
    public virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    private static DynamicMethod CreateImmutableEnumerableCreateRangeDelegate(Type collectionType, Type elementType, Type enumerableType);
    public virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    private static DynamicMethod CreateImmutableDictionaryCreateRangeDelegate(Type collectionType, Type keyType, Type valueType, Type enumerableType);
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    private static DynamicMethod CreatePropertyGetter(PropertyInfo propertyInfo, Type runtimePropertyType);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    private static DynamicMethod CreatePropertySetter(PropertyInfo propertyInfo, Type runtimePropertyType);
    public virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    private static DynamicMethod CreateFieldGetter(FieldInfo fieldInfo, Type runtimeFieldType);
    public virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
    private static DynamicMethod CreateFieldSetter(FieldInfo fieldInfo, Type runtimeFieldType);
    private static DynamicMethod CreateGetterMethod(string memberName, Type memberType);
    private static DynamicMethod CreateSetterMethod(string memberName, Type memberType);
    private static T CreateDelegate(DynamicMethod method);
}
internal class System.Text.Json.Serialization.ReflectionMemberAccessor : MemberAccessor {
    public virtual ConstructorDelegate CreateConstructor(Type type);
    public virtual ParameterizedConstructorDelegate`1<T> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual ParameterizedConstructorDelegate`5<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor(ConstructorInfo constructor);
    public virtual Action`2<TCollection, object> CreateAddMethodDelegate();
    public virtual Func`2<IEnumerable`1<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate();
    public virtual Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate();
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    public virtual Func`2<object, TProperty> CreateFieldGetter(FieldInfo fieldInfo);
    public virtual Action`2<object, TProperty> CreateFieldSetter(FieldInfo fieldInfo);
}
internal enum System.Text.Json.StackFrameObjectState : Enum {
    public byte value__;
    public static StackFrameObjectState None;
    public static StackFrameObjectState StartToken;
    public static StackFrameObjectState ReadAheadNameOrEndObject;
    public static StackFrameObjectState ReadNameOrEndObject;
    public static StackFrameObjectState ReadAheadIdValue;
    public static StackFrameObjectState ReadAheadRefValue;
    public static StackFrameObjectState ReadIdValue;
    public static StackFrameObjectState ReadRefValue;
    public static StackFrameObjectState ReadAheadRefEndObject;
    public static StackFrameObjectState ReadRefEndObject;
    public static StackFrameObjectState ReadAheadValuesName;
    public static StackFrameObjectState ReadValuesName;
    public static StackFrameObjectState ReadAheadValuesStartArray;
    public static StackFrameObjectState ReadValuesStartArray;
    public static StackFrameObjectState PropertyValue;
    public static StackFrameObjectState CreatedObject;
    public static StackFrameObjectState ReadElements;
    public static StackFrameObjectState EndToken;
    public static StackFrameObjectState EndTokenValidation;
}
internal enum System.Text.Json.StackFramePropertyState : Enum {
    public byte value__;
    public static StackFramePropertyState None;
    public static StackFramePropertyState ReadName;
    public static StackFramePropertyState Name;
    public static StackFramePropertyState ReadValue;
    public static StackFramePropertyState ReadValueIsEnd;
    public static StackFramePropertyState TryRead;
}
internal static class System.Text.Json.ThrowHelper : object {
    public static string ExceptionSourceValueToRethrowAsJsonException;
    [DoesNotReturnAttribute]
public static void ThrowOutOfMemoryException_BufferMaximumSizeExceeded(UInt32 capacity);
    public static ArgumentOutOfRangeException GetArgumentOutOfRangeException_MaxDepthMustBePositive(string parameterName);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(string parameterName, string message);
    public static ArgumentOutOfRangeException GetArgumentOutOfRangeException_CommentEnumMustBeInRange(string parameterName);
    private static ArgumentException GetArgumentException(string message);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(string message);
    public static InvalidOperationException GetInvalidOperationException_CallFlushFirst(int _buffered);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_PropertyNameTooLarge(int tokenLength);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_ValueTooLarge(int tokenLength);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_ValueNotSupported();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NeedLargerSpan();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<byte> propertyName, int currentDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(int currentDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(string message);
    private static InvalidOperationException GetInvalidOperationException(string message);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DepthNonZeroOrEmptyJson(int currentDepth);
    private static InvalidOperationException GetInvalidOperationException(int currentDepth);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<char> propertyName, int currentDepth);
    public static InvalidOperationException GetInvalidOperationException_ExpectedNumber(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedBoolean(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedString(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedStringComparison(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedComment(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_CannotSkipOnPartial();
    private static InvalidOperationException GetInvalidOperationException(string message, JsonTokenType tokenType);
    private static InvalidOperationException GetInvalidOperationException(JsonTokenType tokenType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonTokenType actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(JsonValueKind expectedType, JsonValueKind actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonValueKind actualType);
    [DoesNotReturnAttribute]
public static void ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    public static JsonException GetJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    private static bool IsPrintable(byte value);
    internal static string GetPrintableString(byte value);
    private static string GetResourceString(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, string characters);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidCommentValue();
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidUTF8(ReadOnlySpan`1<byte> value);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_InvalidUTF16(int charAsInt);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ReadInvalidUTF16(int charAsInt);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ReadInvalidUTF16();
    public static InvalidOperationException GetInvalidOperationException_ReadInvalidUTF8(DecoderFallbackException innerException);
    public static ArgumentException GetArgumentException_ReadInvalidUTF16(EncoderFallbackException innerException);
    public static InvalidOperationException GetInvalidOperationException(string message, Exception innerException);
    public static InvalidOperationException GetInvalidOperationException(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    private static string GetResourceString(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    public static FormatException GetFormatException();
    public static FormatException GetFormatException(NumericType numericType);
    public static FormatException GetFormatException(DataType dateType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedChar(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowArgumentException_DeserializeWrongType(Type type, object value);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_SerializationNotSupported(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ConstructorMaxOf64Parameters(ConstructorInfo constructorInfo, Type type);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type keyType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidCastException_DeserializeUnableToAssignValue(Type typeOfValue, Type declaredType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_DeserializeUnableToAssignNull(Type declaredType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializationConverterRead(JsonConverter converter);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializationConverterWrite(JsonConverter converter);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_SerializerCycleDetected(int maxDepth);
    [DoesNotReturnAttribute]
public static void ThrowJsonException(string message);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_CannotSerializeInvalidType(Type type, Type parentClassType, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterNotCompatible(Type converterType, Type type);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(Type classType, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(Type classTypeAttributeIsOn, MemberInfo memberInfo, Type typeToConvert);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerOptionsImmutable();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerPropertyNameConflict(Type type, JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerPropertyNameNull(Type parentType, JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NamingPolicyReturnNull(JsonNamingPolicy namingPolicy);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsNull(Type converterType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type parentType, string parameterName, string firstMatchName, string secondMatchName, ConstructorInfo constructorInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(ConstructorInfo constructorInfo, Type parentType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(MemberInfo memberInfo, Type classType, ConstructorInfo constructorInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_JsonIncludeOnNonPublicInvalid(MemberInfo memberInfo, Type parentType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_IgnoreConditionOnValueTypeInvalid(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_ConverterCanConvertNullableRedundant(Type runtimePropertyType, JsonConverter jsonConverter);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotHonored(ReadOnlySpan`1<byte> propertyName, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(ReadStack& state, JsonReaderException ex);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(ReadStack& state, Utf8JsonReader& reader, Exception ex);
    public static void AddJsonExceptionInformation(ReadStack& state, Utf8JsonReader& reader, JsonException ex);
    [DoesNotReturnAttribute]
public static void ReThrowWithPath(WriteStack& state, Exception ex);
    public static void AddJsonExceptionInformation(WriteStack& state, JsonException ex);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateAttribute(Type attribute, Type classType, MemberInfo memberInfo);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType, Type attribute);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(Type type, JsonPropertyInfo jsonPropertyInfo);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException(ReadStack& state, Utf8JsonReader& reader, NotSupportedException ex);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException(WriteStack& state, NotSupportedException ex);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_DeserializeNoConstructor(Type type, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowNotSupportedException_CannotPopulateCollection(Type type, Utf8JsonReader& reader, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValuesInvalidToken(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceNotFound(string id);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValueWasNotString(JsonTokenType tokenType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataValueWasNotString(JsonValueKind valueKind);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataIdIsNotFirstProperty(ReadOnlySpan`1<byte> propertyName, ReadStack& state);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataMissingIdBeforeValues(ReadStack& state, ReadOnlySpan`1<byte> propertyName);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(ReadOnlySpan`1<byte> propertyName, ReadStack& state, Utf8JsonReader& reader);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataDuplicateIdFound(string id);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataInvalidReferenceToValueType(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataPreservedArrayInvalidProperty(ReadStack& state, Type propertyType, Utf8JsonReader& reader);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataPreservedArrayValuesNotFound(ReadStack& state, Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowJsonException_MetadataCannotParsePreservedObjectIntoImmutable(Type propertyType);
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException_MetadataReferenceOfTypeCannotBeAssignedToType(string referenceId, Type currentType, Type typeToConvert);
    [DoesNotReturnAttribute]
internal static void ThrowUnexpectedMetadataException(ReadOnlySpan`1<byte> propertyName, Utf8JsonReader& reader, ReadStack& state);
}
[ExtensionAttribute]
internal static class System.Text.Json.TypeExtensions : object {
    [ExtensionAttribute]
public static bool IsNullableValueType(Type type);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static bool IsAssignableFromInternal(Type type, Type from);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.Utf8JsonReader : ValueType {
    private ReadOnlySpan`1<byte> _buffer;
    private bool _isFinalBlock;
    private bool _isInputSequence;
    private long _lineNumber;
    private long _bytePositionInLine;
    private int _consumed;
    private bool _inObject;
    private bool _isNotPrimitive;
    internal char _numberFormat;
    private JsonTokenType _tokenType;
    private JsonTokenType _previousTokenType;
    private JsonReaderOptions _readerOptions;
    private BitStack _bitStack;
    private long _totalConsumed;
    private bool _isLastSegment;
    internal bool _stringHasEscaping;
    private bool _isMultiSegment;
    private bool _trailingCommaBeforeComment;
    private SequencePosition _nextPosition;
    private SequencePosition _currentPosition;
    private ReadOnlySequence`1<byte> _sequence;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<byte> <ValueSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TokenStartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <ValueSequence>k__BackingField;
    private bool IsLastSpan { get; }
    internal ReadOnlySequence`1<byte> OriginalSequence { get; }
    internal ReadOnlySpan`1<byte> OriginalSpan { get; }
    public ReadOnlySpan`1<byte> ValueSpan { get; private set; }
    public long BytesConsumed { get; }
    public long TokenStartIndex { get; private set; }
    public int CurrentDepth { get; }
    internal bool IsInArray { get; }
    public JsonTokenType TokenType { get; }
    public bool HasValueSequence { get; private set; }
    public bool IsFinalBlock { get; }
    public ReadOnlySequence`1<byte> ValueSequence { get; private set; }
    public SequencePosition Position { get; }
    public JsonReaderState CurrentState { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    [NullableAttribute("1")]
private string DebugTokenType { get; }
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, JsonReaderOptions options);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, JsonReaderOptions options);
    private bool get_IsLastSpan();
    internal ReadOnlySequence`1<byte> get_OriginalSequence();
    internal ReadOnlySpan`1<byte> get_OriginalSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<byte> get_ValueSpan();
    [CompilerGeneratedAttribute]
private void set_ValueSpan(ReadOnlySpan`1<byte> value);
    public long get_BytesConsumed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TokenStartIndex();
    [CompilerGeneratedAttribute]
private void set_TokenStartIndex(long value);
    public int get_CurrentDepth();
    internal bool get_IsInArray();
    public JsonTokenType get_TokenType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValueSequence();
    [CompilerGeneratedAttribute]
private void set_HasValueSequence(bool value);
    public bool get_IsFinalBlock();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_ValueSequence();
    [CompilerGeneratedAttribute]
private void set_ValueSequence(ReadOnlySequence`1<byte> value);
    public SequencePosition get_Position();
    public JsonReaderState get_CurrentState();
    public bool Read();
    public void Skip();
    private void SkipHelper();
    public bool TrySkip();
    private bool TrySkipHelper();
    public bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    [NullableContextAttribute("2")]
public bool ValueTextEquals(string text);
    private bool TextEqualsHelper(ReadOnlySpan`1<byte> otherUtf8Text);
    public bool ValueTextEquals(ReadOnlySpan`1<char> text);
    private bool CompareToSequence(ReadOnlySpan`1<byte> other);
    private bool UnescapeAndCompare(ReadOnlySpan`1<byte> other);
    private bool UnescapeSequenceAndCompare(ReadOnlySpan`1<byte> other);
    private static bool IsTokenTypeString(JsonTokenType tokenType);
    private bool MatchNotPossible(int charTextLength);
    private bool MatchNotPossibleSequence(int charTextLength);
    private void StartObject();
    private void EndObject();
    private void StartArray();
    private void EndArray();
    private void UpdateBitStackOnEndToken();
    private bool ReadSingleSegment();
    private bool HasMoreData();
    private bool HasMoreData(ExceptionResource resource);
    private bool ReadFirstToken(byte first);
    private void SkipWhiteSpace();
    private bool ConsumeValue(byte marker);
    private bool ConsumeLiteral(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteral(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private void ThrowInvalidLiteral(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumber();
    private bool ConsumePropertyName();
    private bool ConsumeString();
    private bool ConsumeStringAndValidate(ReadOnlySpan`1<byte> data, int idx);
    private bool ValidateHexDigits(ReadOnlySpan`1<byte> data, int idx);
    private bool TryGetNumber(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSign(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeZero(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeIntegerDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeSign(ReadOnlySpan`1& data, Int32& i);
    private bool ConsumeNextTokenOrRollback(byte marker);
    private ConsumeTokenResult ConsumeNextToken(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentToken();
    private bool SkipAllComments(Byte& marker);
    private bool SkipAllComments(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkipped(byte marker);
    private bool SkipComment();
    private bool SkipSingleLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private int FindLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private void ThrowOnDangerousLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private bool SkipMultiLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private bool ConsumeComment();
    private bool ConsumeSingleLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private bool ConsumeMultiLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private string get_DebuggerDisplay();
    private string get_DebugTokenType();
    private ReadOnlySpan`1<byte> GetUnescapedSpan();
    private bool ReadMultiSegment();
    private bool ValidateStateAtEndOfData();
    private bool HasMoreDataMultiSegment();
    private bool HasMoreDataMultiSegment(ExceptionResource resource);
    private bool GetNextSpan();
    private bool ReadFirstTokenMultiSegment(byte first);
    private void SkipWhiteSpaceMultiSegment();
    private bool ConsumeValueMultiSegment(byte marker);
    private bool ConsumeLiteralMultiSegment(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteralMultiSegment(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal, Int32& consumed);
    private int FindMismatch(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private JsonException GetInvalidLiteralMultiSegment(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumberMultiSegment();
    private bool ConsumePropertyNameMultiSegment();
    private bool ConsumeStringMultiSegment();
    private bool ConsumeStringNextSegment();
    private bool ConsumeStringAndValidateMultiSegment(ReadOnlySpan`1<byte> data, int idx);
    private void RollBackState(PartialStateForRollback& state, bool isError);
    private bool TryGetNumberMultiSegment(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeZeroMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeIntegerDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private bool ConsumeNextTokenOrRollbackMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentTokenMultiSegment();
    private bool SkipAllCommentsMultiSegment(Byte& marker);
    private bool SkipAllCommentsMultiSegment(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(byte marker);
    private bool SkipOrConsumeCommentMultiSegmentWithRollback();
    private bool SkipCommentMultiSegment(Int32& tailBytesToIgnore);
    private bool SkipSingleLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& tailBytesToSkip);
    private int FindLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private void ThrowOnDangerousLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private bool SkipMultiLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer);
    private PartialStateForRollback CaptureState();
    [NullableContextAttribute("2")]
public string GetString();
    [NullableContextAttribute("1")]
public string GetComment();
    public bool GetBoolean();
    [NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    public byte GetByte();
    internal byte GetByteWithQuotes();
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    internal sbyte GetSByteWithQuotes();
    public short GetInt16();
    internal short GetInt16WithQuotes();
    public int GetInt32();
    internal int GetInt32WithQuotes();
    public long GetInt64();
    internal long GetInt64WithQuotes();
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    internal ushort GetUInt16WithQuotes();
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    internal UInt32 GetUInt32WithQuotes();
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    internal ulong GetUInt64WithQuotes();
    public float GetSingle();
    internal float GetSingleWithQuotes();
    internal float GetSingleFloatingPointConstant();
    public double GetDouble();
    internal double GetDoubleWithQuotes();
    internal double GetDoubleFloatingPointConstant();
    public decimal GetDecimal();
    internal decimal GetDecimalWithQuotes();
    public DateTime GetDateTime();
    internal DateTime GetDateTimeNoValidation();
    public DateTimeOffset GetDateTimeOffset();
    internal DateTimeOffset GetDateTimeOffsetNoValidation();
    public Guid GetGuid();
    internal Guid GetGuidNoValidation();
    [NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    public bool TryGetByte(Byte& value);
    internal bool TryGetByteCore(Byte& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    internal bool TryGetSByteCore(SByte& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt16(Int16& value);
    internal bool TryGetInt16Core(Int16& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt32(Int32& value);
    internal bool TryGetInt32Core(Int32& value, ReadOnlySpan`1<byte> span);
    public bool TryGetInt64(Int64& value);
    internal bool TryGetInt64Core(Int64& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    internal bool TryGetUInt16Core(UInt16& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    internal bool TryGetUInt32Core(UInt32& value, ReadOnlySpan`1<byte> span);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    internal bool TryGetUInt64Core(UInt64& value, ReadOnlySpan`1<byte> span);
    public bool TryGetSingle(Single& value);
    public bool TryGetDouble(Double& value);
    public bool TryGetDecimal(Decimal& value);
    public bool TryGetDateTime(DateTime& value);
    internal bool TryGetDateTimeCore(DateTime& value);
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    internal bool TryGetDateTimeOffsetCore(DateTimeOffset& value);
    public bool TryGetGuid(Guid& value);
    internal bool TryGetGuidCore(Guid& value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.Utf8JsonWriter : object {
    private static int s_newLineLength;
    private static int DefaultGrowthSize;
    private static int InitialGrowthSize;
    private IBufferWriter`1<byte> _output;
    private Stream _stream;
    private ArrayBufferWriter`1<byte> _arrayBufferWriter;
    private Memory`1<byte> _memory;
    private bool _inObject;
    private JsonTokenType _tokenType;
    private BitStack _bitStack;
    private int _currentDepth;
    private JsonWriterOptions _options;
    [CompilerGeneratedAttribute]
private int <BytesPending>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesCommitted>k__BackingField;
    private static Char[] s_singleLineCommentDelimiter;
    public int BytesPending { get; private set; }
    public long BytesCommitted { get; private set; }
    public JsonWriterOptions Options { get; }
    private int Indentation { get; }
    public int CurrentDepth { get; }
    [NullableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private static ReadOnlySpan`1<byte> SingleLineCommentDelimiterUtf8 { get; }
    [NullableContextAttribute("1")]
public Utf8JsonWriter(IBufferWriter`1<byte> bufferWriter, JsonWriterOptions options);
    [NullableContextAttribute("1")]
public Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options);
    private static Utf8JsonWriter();
    [CompilerGeneratedAttribute]
public int get_BytesPending();
    [CompilerGeneratedAttribute]
private void set_BytesPending(int value);
    [CompilerGeneratedAttribute]
public long get_BytesCommitted();
    [CompilerGeneratedAttribute]
private void set_BytesCommitted(long value);
    public JsonWriterOptions get_Options();
    private int get_Indentation();
    public int get_CurrentDepth();
    public void Reset();
    [NullableContextAttribute("1")]
public void Reset(Stream utf8Json);
    [NullableContextAttribute("1")]
public void Reset(IBufferWriter`1<byte> bufferWriter);
    private void ResetHelper();
    private void CheckNotDisposed();
    public void Flush();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<DisposeAsync>d__35")]
public sealed virtual ValueTask DisposeAsync();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<FlushAsync>d__36")]
public Task FlushAsync(CancellationToken cancellationToken);
    public void WriteStartArray();
    public void WriteStartObject();
    private void WriteStart(byte token);
    private void WriteStartMinimized(byte token);
    private void WriteStartSlow(byte token);
    private void ValidateStart();
    private void WriteStartIndented(byte token);
    public void WriteStartArray(JsonEncodedText propertyName);
    public void WriteStartObject(JsonEncodedText propertyName);
    private void WriteStartHelper(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    public void WriteStartArray(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteStartObject(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStartEscape(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, byte token, int firstEscapeIndexProp);
    [NullableContextAttribute("1")]
public void WriteStartArray(string propertyName);
    [NullableContextAttribute("1")]
public void WriteStartObject(string propertyName);
    public void WriteStartArray(ReadOnlySpan`1<char> propertyName);
    public void WriteStartObject(ReadOnlySpan`1<char> propertyName);
    private void WriteStartEscape(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<char> propertyName, byte token, int firstEscapeIndexProp);
    public void WriteEndArray();
    public void WriteEndObject();
    private void WriteEnd(byte token);
    private void WriteEndMinimized(byte token);
    private void WriteEndSlow(byte token);
    private void ValidateEnd(byte token);
    private void WriteEndIndented(byte token);
    private void WriteNewLine(Span`1<byte> output);
    private void UpdateBitStackOnStart(byte token);
    private void Grow(int requiredSize);
    private void FirstCallToGetMemory(int requiredSize);
    private void SetFlagToAddListSeparatorBeforeNextItem();
    private string get_DebuggerDisplay();
    public void WriteBase64String(JsonEncodedText propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(string propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64ByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteString(JsonEncodedText propertyName, DateTime value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    internal void WritePropertyName(DateTime value);
    public void WriteString(JsonEncodedText propertyName, DateTimeOffset value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    internal void WritePropertyName(DateTimeOffset value);
    public void WriteNumber(JsonEncodedText propertyName, decimal value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    internal void WritePropertyName(decimal value);
    public void WriteNumber(JsonEncodedText propertyName, double value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    internal void WritePropertyName(double value);
    public void WriteNumber(JsonEncodedText propertyName, float value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    internal void WritePropertyName(float value);
    internal void WriteNumber(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    public void WriteString(JsonEncodedText propertyName, Guid value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    internal void WritePropertyName(Guid value);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<char> propertyName);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<byte> utf8PropertyName);
    private void ValidateDepth();
    private void ValidateWritingProperty();
    private void ValidateWritingProperty(byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void TranscodeAndWrite(ReadOnlySpan`1<char> escapedPropertyName, Span`1<byte> output);
    public void WriteNull(JsonEncodedText propertyName);
    internal void WriteNullSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WriteLiteralHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    [NullableContextAttribute("1")]
public void WriteNull(string propertyName);
    public void WriteNull(ReadOnlySpan`1<char> propertyName);
    public void WriteNull(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteBoolean(JsonEncodedText propertyName, bool value);
    [NullableContextAttribute("1")]
public void WriteBoolean(string propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<char> propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<byte> utf8PropertyName, bool value);
    private void WriteLiteralEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralSection(ReadOnlySpan`1<byte> escapedPropertyNameSection, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    internal void WritePropertyName(bool value);
    public void WriteNumber(JsonEncodedText propertyName, long value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    public void WriteNumber(JsonEncodedText propertyName, int value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, int value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    internal void WritePropertyName(int value);
    internal void WritePropertyName(long value);
    public void WritePropertyName(JsonEncodedText propertyName);
    internal void WritePropertyNameSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WritePropertyNameHelper(ReadOnlySpan`1<byte> utf8PropertyName);
    [NullableContextAttribute("1")]
public void WritePropertyName(string propertyName);
    public void WritePropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    public void WritePropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WritePropertyNameUnescaped(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    private void WriteStringPropertyNameSection(ReadOnlySpan`1<byte> escapedPropertyNameSection);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    public void WriteString(JsonEncodedText propertyName, JsonEncodedText value);
    private void WriteStringHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, JsonEncodedText value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, string value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    [NullableContextAttribute("2")]
public void WriteString(JsonEncodedText propertyName, string value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(string propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(string propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, string value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, string value);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndex);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, ulong value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, UInt32 value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, UInt32 value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    internal void WritePropertyName(UInt32 value);
    internal void WritePropertyName(ulong value);
    public void WriteBase64StringValue(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> get_SingleLineCommentDelimiterUtf8();
    [NullableContextAttribute("1")]
public void WriteCommentValue(string value);
    public void WriteCommentValue(ReadOnlySpan`1<char> value);
    private void WriteCommentByOptions(ReadOnlySpan`1<char> value);
    private void WriteCommentMinimized(ReadOnlySpan`1<char> value);
    private void WriteCommentIndented(ReadOnlySpan`1<char> value);
    public void WriteCommentValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(DateTime value);
    private void WriteStringValueMinimized(DateTime value);
    private void WriteStringValueIndented(DateTime value);
    public void WriteStringValue(DateTimeOffset value);
    private void WriteStringValueMinimized(DateTimeOffset value);
    private void WriteStringValueIndented(DateTimeOffset value);
    public void WriteNumberValue(decimal value);
    private void WriteNumberValueMinimized(decimal value);
    private void WriteNumberValueIndented(decimal value);
    internal void WriteNumberValueAsString(decimal value);
    public void WriteNumberValue(double value);
    private void WriteNumberValueMinimized(double value);
    private void WriteNumberValueIndented(double value);
    private static bool TryFormatDouble(double value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValueAsString(double value);
    internal void WriteFloatingPointConstant(double value);
    public void WriteNumberValue(float value);
    private void WriteNumberValueMinimized(float value);
    private void WriteNumberValueIndented(float value);
    private static bool TryFormatSingle(float value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValueAsString(float value);
    internal void WriteFloatingPointConstant(float value);
    internal void WriteNumberValue(ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberValueMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteNumberValueIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(Guid value);
    private void WriteStringValueMinimized(Guid value);
    private void WriteStringValueIndented(Guid value);
    private void ValidateWritingValue();
    private void Base64EncodeAndWrite(ReadOnlySpan`1<byte> bytes, Span`1<byte> output, int encodingLength);
    public void WriteNullValue();
    public void WriteBooleanValue(bool value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteNumberValue(int value);
    public void WriteNumberValue(long value);
    private void WriteNumberValueMinimized(long value);
    private void WriteNumberValueIndented(long value);
    internal void WriteNumberValueAsString(long value);
    public void WriteStringValue(JsonEncodedText value);
    [NullableContextAttribute("2")]
public void WriteStringValue(string value);
    public void WriteStringValue(ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<char> value, int firstEscapeIndexVal);
    public void WriteStringValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal);
    internal void WriteNumberValueAsStringUnescaped(ReadOnlySpan`1<byte> utf8Value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(ulong value);
    private void WriteNumberValueMinimized(ulong value);
    private void WriteNumberValueIndented(ulong value);
    internal void WriteNumberValueAsString(ulong value);
}
[DebuggerDisplayAttribute("Path:{PropertyPath()} Current: ClassType.{Current.JsonClassInfo.ClassType}, {Current.JsonClassInfo.Type.Name}")]
internal class System.Text.Json.WriteStack : ValueType {
    private int _continuationCount;
    private int _count;
    private List`1<WriteStackFrame> _previous;
    public WriteStackFrame Current;
    public int FlushThreshold;
    public ReferenceResolver ReferenceResolver;
    public bool SupportContinuation;
    public bool IsContinuation { get; }
    public bool get_IsContinuation();
    private void AddCurrent();
    public JsonConverter Initialize(Type type, JsonSerializerOptions options, bool supportContinuation);
    public void Push();
    public void Pop(bool success);
    public string PropertyPath();
    [CompilerGeneratedAttribute]
internal static void <PropertyPath>g__AppendStackFrame|13_0(StringBuilder sb, WriteStackFrame& frame);
    [CompilerGeneratedAttribute]
internal static void <PropertyPath>g__AppendPropertyName|13_1(StringBuilder sb, string propertyName);
}
[DebuggerDisplayAttribute("ClassType.{JsonClassInfo.ClassType}, {JsonClassInfo.Type.Name}")]
internal class System.Text.Json.WriteStackFrame : ValueType {
    public IEnumerator CollectionEnumerator;
    public JsonPropertyInfo DeclaredJsonPropertyInfo;
    public bool IgnoreDictionaryKeyPolicy;
    public JsonClassInfo JsonClassInfo;
    public int OriginalDepth;
    public bool ProcessedStartToken;
    public bool ProcessedEndToken;
    public StackFramePropertyState PropertyState;
    public int EnumeratorIndex;
    public string JsonPropertyNameAsString;
    public MetadataPropertyName MetadataPropertyName;
    public JsonPropertyInfo PolymorphicJsonPropertyInfo;
    public Nullable`1<JsonNumberHandling> NumberHandling;
    public void EndDictionaryElement();
    public void EndProperty();
    public JsonPropertyInfo GetPolymorphicJsonPropertyInfo();
    public JsonConverter InitializeReEntry(Type type, JsonSerializerOptions options, string propertyName);
    public void Reset();
}
