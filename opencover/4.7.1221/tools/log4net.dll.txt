public class log4net.Appender.AdoNetAppender : BufferingAppenderSkeleton {
    protected ArrayList m_parameters;
    private SecurityContext m_securityContext;
    private IDbConnection m_dbConnection;
    private string m_connectionString;
    private string m_appSettingsKey;
    private string m_connectionStringName;
    private string m_connectionType;
    private string m_commandText;
    private CommandType m_commandType;
    private bool m_useTransactions;
    private bool m_reconnectOnError;
    private static Type declaringType;
    public string ConnectionString { get; public set; }
    public string AppSettingsKey { get; public set; }
    public string ConnectionStringName { get; public set; }
    public string ConnectionType { get; public set; }
    public string CommandText { get; public set; }
    public CommandType CommandType { get; public set; }
    public bool UseTransactions { get; public set; }
    public SecurityContext SecurityContext { get; public set; }
    public bool ReconnectOnError { get; public set; }
    protected IDbConnection Connection { get; protected set; }
    private static AdoNetAppender();
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_AppSettingsKey();
    public void set_AppSettingsKey(string value);
    public string get_ConnectionStringName();
    public void set_ConnectionStringName(string value);
    public string get_ConnectionType();
    public void set_ConnectionType(string value);
    public string get_CommandText();
    public void set_CommandText(string value);
    public CommandType get_CommandType();
    public void set_CommandType(CommandType value);
    public bool get_UseTransactions();
    public void set_UseTransactions(bool value);
    public SecurityContext get_SecurityContext();
    public void set_SecurityContext(SecurityContext value);
    public bool get_ReconnectOnError();
    public void set_ReconnectOnError(bool value);
    protected IDbConnection get_Connection();
    protected void set_Connection(IDbConnection value);
    public virtual void ActivateOptions();
    protected virtual void OnClose();
    protected virtual void SendBuffer(LoggingEvent[] events);
    public void AddParameter(AdoNetAppenderParameter parameter);
    protected virtual void SendBuffer(IDbTransaction dbTran, LoggingEvent[] events);
    protected virtual string GetLogStatement(LoggingEvent logEvent);
    protected virtual IDbConnection CreateConnection(Type connectionType, string connectionString);
    protected virtual string ResolveConnectionString(String& connectionStringContext);
    protected virtual Type ResolveConnectionType();
    private void InitializeDatabaseConnection();
    private void DiposeConnection();
}
public class log4net.Appender.AdoNetAppenderParameter : object {
    private string m_parameterName;
    private DbType m_dbType;
    private bool m_inferType;
    private byte m_precision;
    private byte m_scale;
    private int m_size;
    private IRawLayout m_layout;
    public string ParameterName { get; public set; }
    public DbType DbType { get; public set; }
    public byte Precision { get; public set; }
    public byte Scale { get; public set; }
    public int Size { get; public set; }
    public IRawLayout Layout { get; public set; }
    public string get_ParameterName();
    public void set_ParameterName(string value);
    public DbType get_DbType();
    public void set_DbType(DbType value);
    public byte get_Precision();
    public void set_Precision(byte value);
    public byte get_Scale();
    public void set_Scale(byte value);
    public int get_Size();
    public void set_Size(int value);
    public IRawLayout get_Layout();
    public void set_Layout(IRawLayout value);
    public virtual void Prepare(IDbCommand command);
    public virtual void FormatValue(IDbCommand command, LoggingEvent loggingEvent);
}
public class log4net.Appender.AnsiColorTerminalAppender : AppenderSkeleton {
    public static string ConsoleOut;
    public static string ConsoleError;
    private bool m_writeToErrorStream;
    private LevelMapping m_levelMapping;
    private static string PostEventCodes;
    public string Target { get; public set; }
    protected bool RequiresLayout { get; }
    public virtual string get_Target();
    public virtual void set_Target(string value);
    public void AddMapping(LevelColors mapping);
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    public virtual void ActivateOptions();
}
[DefaultMemberAttribute("Item")]
public class log4net.Appender.AppenderCollection : object {
    private static int DEFAULT_CAPACITY;
    private IAppender[] m_array;
    private int m_count;
    private int m_version;
    public static AppenderCollection EmptyCollection;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public IAppender Item { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public int Capacity { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public AppenderCollection(int capacity);
    public AppenderCollection(AppenderCollection c);
    public AppenderCollection(IAppender[] a);
    public AppenderCollection(ICollection col);
    protected internal AppenderCollection(Tag tag);
    private static AppenderCollection();
    public static AppenderCollection ReadOnly(AppenderCollection list);
    public virtual int get_Count();
    public virtual void CopyTo(IAppender[] array);
    public virtual void CopyTo(IAppender[] array, int start);
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual IAppender get_Item(int index);
    public virtual void set_Item(int index, IAppender value);
    public virtual int Add(IAppender item);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(IAppender item);
    public virtual int IndexOf(IAppender item);
    public virtual void Insert(int index, IAppender item);
    public virtual void Remove(IAppender item);
    public virtual void RemoveAt(int index);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual IAppenderCollectionEnumerator GetEnumerator();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int AddRange(AppenderCollection x);
    public virtual int AddRange(IAppender[] x);
    public virtual int AddRange(ICollection col);
    public virtual void TrimToSize();
    public virtual IAppender[] ToArray();
    private void ValidateIndex(int i);
    private void ValidateIndex(int i, bool allowEqualEnd);
    private void EnsureCapacity(int min);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int start);
    private sealed virtual override object System.Collections.IList.get_Item(int i);
    private sealed virtual override void System.Collections.IList.set_Item(int i, object value);
    private sealed virtual override int System.Collections.IList.Add(object x);
    private sealed virtual override bool System.Collections.IList.Contains(object x);
    private sealed virtual override int System.Collections.IList.IndexOf(object x);
    private sealed virtual override void System.Collections.IList.Insert(int pos, object x);
    private sealed virtual override void System.Collections.IList.Remove(object x);
    private sealed virtual override void System.Collections.IList.RemoveAt(int pos);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class log4net.Appender.AppenderSkeleton : object {
    private ILayout m_layout;
    private string m_name;
    private Level m_threshold;
    private IErrorHandler m_errorHandler;
    private IFilter m_headFilter;
    private IFilter m_tailFilter;
    private bool m_closed;
    private bool m_recursiveGuard;
    private ReusableStringWriter m_renderWriter;
    private static int c_renderBufferSize;
    private static int c_renderBufferMaxCapacity;
    private static Type declaringType;
    public Level Threshold { get; public set; }
    public IErrorHandler ErrorHandler { get; public set; }
    public IFilter FilterHead { get; }
    public ILayout Layout { get; public set; }
    public string Name { get; public set; }
    protected bool RequiresLayout { get; }
    private static AppenderSkeleton();
    protected virtual override void Finalize();
    public Level get_Threshold();
    public void set_Threshold(Level value);
    public virtual IErrorHandler get_ErrorHandler();
    public virtual void set_ErrorHandler(IErrorHandler value);
    public virtual IFilter get_FilterHead();
    public virtual ILayout get_Layout();
    public virtual void set_Layout(ILayout value);
    public virtual void ActivateOptions();
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public sealed virtual void Close();
    public sealed virtual void DoAppend(LoggingEvent loggingEvent);
    public sealed virtual void DoAppend(LoggingEvent[] loggingEvents);
    protected virtual bool FilterEvent(LoggingEvent loggingEvent);
    public virtual void AddFilter(IFilter filter);
    public virtual void ClearFilters();
    protected virtual bool IsAsSevereAsThreshold(Level level);
    protected virtual void OnClose();
    protected abstract virtual void Append(LoggingEvent loggingEvent);
    protected virtual void Append(LoggingEvent[] loggingEvents);
    protected virtual bool PreAppendCheck();
    protected string RenderLoggingEvent(LoggingEvent loggingEvent);
    protected void RenderLoggingEvent(TextWriter writer, LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    public virtual bool Flush(int millisecondsTimeout);
}
public class log4net.Appender.AspNetTraceAppender : AppenderSkeleton {
    private PatternLayout m_category;
    protected bool RequiresLayout { get; }
    public PatternLayout Category { get; public set; }
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    public PatternLayout get_Category();
    public void set_Category(PatternLayout value);
}
public abstract class log4net.Appender.BufferingAppenderSkeleton : AppenderSkeleton {
    private static int DEFAULT_BUFFER_SIZE;
    private int m_bufferSize;
    private CyclicBuffer m_cb;
    private ITriggeringEventEvaluator m_evaluator;
    private bool m_lossy;
    private ITriggeringEventEvaluator m_lossyEvaluator;
    private FixFlags m_fixFlags;
    private bool m_eventMustBeFixed;
    public bool Lossy { get; public set; }
    public int BufferSize { get; public set; }
    public ITriggeringEventEvaluator Evaluator { get; public set; }
    public ITriggeringEventEvaluator LossyEvaluator { get; public set; }
    [ObsoleteAttribute("Use Fix property")]
public bool OnlyFixPartialEventData { get; public set; }
    public FixFlags Fix { get; public set; }
    protected BufferingAppenderSkeleton(bool eventMustBeFixed);
    public bool get_Lossy();
    public void set_Lossy(bool value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public ITriggeringEventEvaluator get_Evaluator();
    public void set_Evaluator(ITriggeringEventEvaluator value);
    public ITriggeringEventEvaluator get_LossyEvaluator();
    public void set_LossyEvaluator(ITriggeringEventEvaluator value);
    public virtual bool get_OnlyFixPartialEventData();
    public virtual void set_OnlyFixPartialEventData(bool value);
    public virtual FixFlags get_Fix();
    public virtual void set_Fix(FixFlags value);
    public virtual bool Flush(int millisecondsTimeout);
    public virtual void Flush();
    public virtual void Flush(bool flushLossyBuffer);
    public virtual void ActivateOptions();
    protected virtual void OnClose();
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual void SendFromBuffer(LoggingEvent firstLoggingEvent, CyclicBuffer buffer);
    protected abstract virtual void SendBuffer(LoggingEvent[] events);
}
public class log4net.Appender.BufferingForwardingAppender : BufferingAppenderSkeleton {
    private AppenderAttachedImpl m_appenderAttachedImpl;
    public AppenderCollection Appenders { get; }
    protected virtual void OnClose();
    protected virtual void SendBuffer(LoggingEvent[] events);
    public virtual void AddAppender(IAppender newAppender);
    public virtual AppenderCollection get_Appenders();
    public virtual IAppender GetAppender(string name);
    public virtual void RemoveAllAppenders();
    public virtual IAppender RemoveAppender(IAppender appender);
    public virtual IAppender RemoveAppender(string name);
}
public class log4net.Appender.ColoredConsoleAppender : AppenderSkeleton {
    private static Char[] s_windowsNewline;
    public static string ConsoleOut;
    public static string ConsoleError;
    private bool m_writeToErrorStream;
    private LevelMapping m_levelMapping;
    private StreamWriter m_consoleOutputWriter;
    private static UInt32 STD_OUTPUT_HANDLE;
    private static UInt32 STD_ERROR_HANDLE;
    public string Target { get; public set; }
    protected bool RequiresLayout { get; }
    [ObsoleteAttribute("Instead use the default constructor and set the Layout property")]
public ColoredConsoleAppender(ILayout layout);
    [ObsoleteAttribute("Instead use the default constructor and set the Layout & Target properties")]
public ColoredConsoleAppender(ILayout layout, bool writeToErrorStream);
    private static ColoredConsoleAppender();
    public virtual string get_Target();
    public virtual void set_Target(string value);
    public void AddMapping(LevelColors mapping);
    [SecuritySafeCriticalAttribute]
protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    [SecuritySafeCriticalAttribute]
public virtual void ActivateOptions();
    private static int GetConsoleOutputCP();
    private static bool SetConsoleTextAttribute(IntPtr consoleHandle, ushort attributes);
    private static bool GetConsoleScreenBufferInfo(IntPtr consoleHandle, CONSOLE_SCREEN_BUFFER_INFO& bufferInfo);
    private static IntPtr GetStdHandle(UInt32 type);
}
public class log4net.Appender.ConsoleAppender : AppenderSkeleton {
    public static string ConsoleOut;
    public static string ConsoleError;
    private bool m_writeToErrorStream;
    public string Target { get; public set; }
    protected bool RequiresLayout { get; }
    [ObsoleteAttribute("Instead use the default constructor and set the Layout property")]
public ConsoleAppender(ILayout layout);
    [ObsoleteAttribute("Instead use the default constructor and set the Layout & Target properties")]
public ConsoleAppender(ILayout layout, bool writeToErrorStream);
    public virtual string get_Target();
    public virtual void set_Target(string value);
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
}
public class log4net.Appender.DebugAppender : AppenderSkeleton {
    private bool m_immediateFlush;
    private PatternLayout m_category;
    public bool ImmediateFlush { get; public set; }
    public PatternLayout Category { get; public set; }
    protected bool RequiresLayout { get; }
    [ObsoleteAttribute("Instead use the default constructor and set the Layout property")]
public DebugAppender(ILayout layout);
    public bool get_ImmediateFlush();
    public void set_ImmediateFlush(bool value);
    public PatternLayout get_Category();
    public void set_Category(PatternLayout value);
    public virtual bool Flush(int millisecondsTimeout);
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
}
public class log4net.Appender.EventLogAppender : AppenderSkeleton {
    private string m_logName;
    private string m_applicationName;
    private string m_machineName;
    private LevelMapping m_levelMapping;
    private SecurityContext m_securityContext;
    private int m_eventId;
    private short m_category;
    private static Type declaringType;
    private static int MAX_EVENTLOG_MESSAGE_SIZE_DEFAULT;
    private static int MAX_EVENTLOG_MESSAGE_SIZE_VISTA_OR_NEWER;
    private static int MAX_EVENTLOG_MESSAGE_SIZE;
    public string LogName { get; public set; }
    public string ApplicationName { get; public set; }
    public string MachineName { get; public set; }
    public SecurityContext SecurityContext { get; public set; }
    public int EventId { get; public set; }
    public short Category { get; public set; }
    protected bool RequiresLayout { get; }
    [ObsoleteAttribute("Instead use the default constructor and set the Layout property")]
public EventLogAppender(ILayout layout);
    private static EventLogAppender();
    public string get_LogName();
    public void set_LogName(string value);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public void AddMapping(Level2EventLogEntryType mapping);
    public SecurityContext get_SecurityContext();
    public void set_SecurityContext(SecurityContext value);
    public int get_EventId();
    public void set_EventId(int value);
    public short get_Category();
    public void set_Category(short value);
    public virtual void ActivateOptions();
    private static void CreateEventSource(string source, string logName, string machineName);
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    protected virtual EventLogEntryType GetEntryType(Level level);
    private static int GetMaxEventLogMessageSize();
}
public class log4net.Appender.FileAppender : TextWriterAppender {
    private bool m_appendToFile;
    private string m_fileName;
    private Encoding m_encoding;
    private SecurityContext m_securityContext;
    private LockingStream m_stream;
    private LockingModelBase m_lockingModel;
    private static Type declaringType;
    public string File { get; public set; }
    public bool AppendToFile { get; public set; }
    public Encoding Encoding { get; public set; }
    public SecurityContext SecurityContext { get; public set; }
    public LockingModelBase LockingModel { get; public set; }
    [ObsoleteAttribute("Instead use the default constructor and set the Layout, File & AppendToFile properties")]
public FileAppender(ILayout layout, string filename, bool append);
    [ObsoleteAttribute("Instead use the default constructor and set the Layout & File properties")]
public FileAppender(ILayout layout, string filename);
    private static FileAppender();
    public virtual string get_File();
    public virtual void set_File(string value);
    public bool get_AppendToFile();
    public void set_AppendToFile(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public SecurityContext get_SecurityContext();
    public void set_SecurityContext(SecurityContext value);
    public LockingModelBase get_LockingModel();
    public void set_LockingModel(LockingModelBase value);
    public virtual void ActivateOptions();
    protected virtual void Reset();
    protected virtual void OnClose();
    protected virtual void PrepareWriter();
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual void Append(LoggingEvent[] loggingEvents);
    protected virtual void WriteFooter();
    protected virtual void WriteHeader();
    protected virtual void CloseWriter();
    protected void CloseFile();
    protected virtual void SafeOpenFile(string fileName, bool append);
    protected virtual void OpenFile(string fileName, bool append);
    protected virtual void SetQWForFiles(Stream fileStream);
    protected virtual void SetQWForFiles(TextWriter writer);
    protected static string ConvertToFullPath(string path);
}
public class log4net.Appender.ForwardingAppender : AppenderSkeleton {
    private AppenderAttachedImpl m_appenderAttachedImpl;
    public AppenderCollection Appenders { get; }
    protected virtual void OnClose();
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual void Append(LoggingEvent[] loggingEvents);
    public virtual void AddAppender(IAppender newAppender);
    public virtual AppenderCollection get_Appenders();
    public virtual IAppender GetAppender(string name);
    public virtual void RemoveAllAppenders();
    public virtual IAppender RemoveAppender(IAppender appender);
    public virtual IAppender RemoveAppender(string name);
}
public interface log4net.Appender.IAppender {
    public string Name { get; public set; }
    public abstract virtual void Close();
    public abstract virtual void DoAppend(LoggingEvent loggingEvent);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public interface log4net.Appender.IBulkAppender {
    public abstract virtual void DoAppend(LoggingEvent[] loggingEvents);
}
public interface log4net.Appender.IFlushable {
    public abstract virtual bool Flush(int millisecondsTimeout);
}
public class log4net.Appender.LocalSyslogAppender : AppenderSkeleton {
    private SyslogFacility m_facility;
    private string m_identity;
    private IntPtr m_handleToIdentity;
    private LevelMapping m_levelMapping;
    public string Identity { get; public set; }
    public SyslogFacility Facility { get; public set; }
    protected bool RequiresLayout { get; }
    public string get_Identity();
    public void set_Identity(string value);
    public SyslogFacility get_Facility();
    public void set_Facility(SyslogFacility value);
    public void AddMapping(LevelSeverity mapping);
    [SecuritySafeCriticalAttribute]
public virtual void ActivateOptions();
    [SecuritySafeCriticalAttribute]
protected virtual void Append(LoggingEvent loggingEvent);
    [SecuritySafeCriticalAttribute]
protected virtual void OnClose();
    protected virtual bool get_RequiresLayout();
    protected virtual SyslogSeverity GetSeverity(Level level);
    private static int GeneratePriority(SyslogFacility facility, SyslogSeverity severity);
    private static void openlog(IntPtr ident, int option, SyslogFacility facility);
    private static void syslog(int priority, string format, string message);
    private static void closelog();
}
public class log4net.Appender.ManagedColoredConsoleAppender : AppenderSkeleton {
    public static string ConsoleOut;
    public static string ConsoleError;
    private bool m_writeToErrorStream;
    private LevelMapping m_levelMapping;
    public string Target { get; public set; }
    protected bool RequiresLayout { get; }
    public virtual string get_Target();
    public virtual void set_Target(string value);
    public void AddMapping(LevelColors mapping);
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    public virtual void ActivateOptions();
}
public class log4net.Appender.MemoryAppender : AppenderSkeleton {
    protected ArrayList m_eventsList;
    protected FixFlags m_fixFlags;
    [ObsoleteAttribute("Use Fix property")]
public bool OnlyFixPartialEventData { get; public set; }
    public FixFlags Fix { get; public set; }
    public virtual LoggingEvent[] GetEvents();
    public virtual bool get_OnlyFixPartialEventData();
    public virtual void set_OnlyFixPartialEventData(bool value);
    public virtual FixFlags get_Fix();
    public virtual void set_Fix(FixFlags value);
    protected virtual void Append(LoggingEvent loggingEvent);
    public virtual void Clear();
    public virtual LoggingEvent[] PopAllEvents();
}
public class log4net.Appender.NetSendAppender : AppenderSkeleton {
    private string m_server;
    private string m_sender;
    private string m_recipient;
    private SecurityContext m_securityContext;
    public string Sender { get; public set; }
    public string Recipient { get; public set; }
    public string Server { get; public set; }
    public SecurityContext SecurityContext { get; public set; }
    protected bool RequiresLayout { get; }
    public string get_Sender();
    public void set_Sender(string value);
    public string get_Recipient();
    public void set_Recipient(string value);
    public string get_Server();
    public void set_Server(string value);
    public SecurityContext get_SecurityContext();
    public void set_SecurityContext(SecurityContext value);
    public virtual void ActivateOptions();
    [SecuritySafeCriticalAttribute]
protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    protected static int NetMessageBufferSend(string serverName, string msgName, string fromName, string buffer, int bufferSize);
}
public class log4net.Appender.OutputDebugStringAppender : AppenderSkeleton {
    protected bool RequiresLayout { get; }
    [SecuritySafeCriticalAttribute]
protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    protected static void OutputDebugString(string message);
}
public class log4net.Appender.RemoteSyslogAppender : UdpAppender {
    private static int DefaultSyslogPort;
    private SyslogFacility m_facility;
    private PatternLayout m_identity;
    private LevelMapping m_levelMapping;
    private static int c_renderBufferSize;
    private static int c_renderBufferMaxCapacity;
    public PatternLayout Identity { get; public set; }
    public SyslogFacility Facility { get; public set; }
    public PatternLayout get_Identity();
    public void set_Identity(PatternLayout value);
    public SyslogFacility get_Facility();
    public void set_Facility(SyslogFacility value);
    public void AddMapping(LevelSeverity mapping);
    protected virtual void Append(LoggingEvent loggingEvent);
    public virtual void ActivateOptions();
    protected virtual SyslogSeverity GetSeverity(Level level);
    public static int GeneratePriority(SyslogFacility facility, SyslogSeverity severity);
}
public class log4net.Appender.RemotingAppender : BufferingAppenderSkeleton {
    private string m_sinkUrl;
    private IRemoteLoggingSink m_sinkObj;
    private int m_queuedCallbackCount;
    private ManualResetEvent m_workQueueEmptyEvent;
    public string Sink { get; public set; }
    public string get_Sink();
    public void set_Sink(string value);
    [SecuritySafeCriticalAttribute]
public virtual void ActivateOptions();
    protected virtual void SendBuffer(LoggingEvent[] events);
    protected virtual void OnClose();
    public virtual bool Flush(int millisecondsTimeout);
    private void BeginAsyncSend();
    private void EndAsyncSend();
    private void SendBufferCallback(object state);
}
public class log4net.Appender.RollingFileAppender : FileAppender {
    private static Type declaringType;
    private IDateTime m_dateTime;
    private string m_datePattern;
    private string m_scheduledFilename;
    private DateTime m_nextCheck;
    private DateTime m_now;
    private RollPoint m_rollPoint;
    private long m_maxFileSize;
    private int m_maxSizeRollBackups;
    private int m_curSizeRollBackups;
    private int m_countDirection;
    private RollingMode m_rollingStyle;
    private bool m_rollDate;
    private bool m_rollSize;
    private bool m_staticLogFileName;
    private bool m_preserveLogFileNameExtension;
    private string m_baseFileName;
    private Mutex m_mutexForRolling;
    private static DateTime s_date1970;
    public IDateTime DateTimeStrategy { get; public set; }
    public string DatePattern { get; public set; }
    public int MaxSizeRollBackups { get; public set; }
    public long MaxFileSize { get; public set; }
    public string MaximumFileSize { get; public set; }
    public int CountDirection { get; public set; }
    public RollingMode RollingStyle { get; public set; }
    public bool PreserveLogFileNameExtension { get; public set; }
    public bool StaticLogFileName { get; public set; }
    private static RollingFileAppender();
    protected virtual override void Finalize();
    public IDateTime get_DateTimeStrategy();
    public void set_DateTimeStrategy(IDateTime value);
    public string get_DatePattern();
    public void set_DatePattern(string value);
    public int get_MaxSizeRollBackups();
    public void set_MaxSizeRollBackups(int value);
    public long get_MaxFileSize();
    public void set_MaxFileSize(long value);
    public string get_MaximumFileSize();
    public void set_MaximumFileSize(string value);
    public int get_CountDirection();
    public void set_CountDirection(int value);
    public RollingMode get_RollingStyle();
    public void set_RollingStyle(RollingMode value);
    public bool get_PreserveLogFileNameExtension();
    public void set_PreserveLogFileNameExtension(bool value);
    public bool get_StaticLogFileName();
    public void set_StaticLogFileName(bool value);
    protected virtual void SetQWForFiles(TextWriter writer);
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual void Append(LoggingEvent[] loggingEvents);
    protected virtual void AdjustFileBeforeAppend();
    protected virtual void OpenFile(string fileName, bool append);
    protected string GetNextOutputFileName(string fileName);
    private void DetermineCurSizeRollBackups();
    private string GetWildcardPatternForFile(string baseFileName);
    private ArrayList GetExistingFiles(string baseFilePath);
    private void RollOverIfDateBoundaryCrossing();
    protected void ExistingInit();
    private void InitializeFromOneFile(string baseFile, string curFileName);
    private int GetBackUpIndex(string curFileName);
    private void InitializeRollBackups(string baseFile, ArrayList arrayFiles);
    private RollPoint ComputeCheckPeriod(string datePattern);
    public virtual void ActivateOptions();
    private string CombinePath(string path1, string path2);
    protected void RollOverTime(bool fileIsOpen);
    protected void RollFile(string fromFile, string toFile);
    protected bool FileExists(string path);
    protected void DeleteFile(string fileName);
    protected void RollOverSize();
    protected void RollOverRenameFiles(string baseFileName);
    protected DateTime NextCheckDate(DateTime currentDateTime, RollPoint rollPoint);
}
public class log4net.Appender.SmtpAppender : BufferingAppenderSkeleton {
    private string m_to;
    private string m_cc;
    private string m_bcc;
    private string m_from;
    private string m_subject;
    private string m_smtpHost;
    private Encoding m_subjectEncoding;
    private Encoding m_bodyEncoding;
    private SmtpAuthentication m_authentication;
    private string m_username;
    private string m_password;
    private int m_port;
    private MailPriority m_mailPriority;
    private bool m_enableSsl;
    private string m_replyTo;
    private static Char[] ADDRESS_DELIMITERS;
    public string To { get; public set; }
    public string Cc { get; public set; }
    public string Bcc { get; public set; }
    public string From { get; public set; }
    public string Subject { get; public set; }
    public string SmtpHost { get; public set; }
    [ObsoleteAttribute("Use the BufferingAppenderSkeleton Fix methods")]
public bool LocationInfo { get; public set; }
    public SmtpAuthentication Authentication { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public int Port { get; public set; }
    public MailPriority Priority { get; public set; }
    public bool EnableSsl { get; public set; }
    public string ReplyTo { get; public set; }
    public Encoding SubjectEncoding { get; public set; }
    public Encoding BodyEncoding { get; public set; }
    protected bool RequiresLayout { get; }
    private static SmtpAppender();
    public string get_To();
    public void set_To(string value);
    public string get_Cc();
    public void set_Cc(string value);
    public string get_Bcc();
    public void set_Bcc(string value);
    public string get_From();
    public void set_From(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_SmtpHost();
    public void set_SmtpHost(string value);
    public bool get_LocationInfo();
    public void set_LocationInfo(bool value);
    public SmtpAuthentication get_Authentication();
    public void set_Authentication(SmtpAuthentication value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public int get_Port();
    public void set_Port(int value);
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public string get_ReplyTo();
    public void set_ReplyTo(string value);
    public Encoding get_SubjectEncoding();
    public void set_SubjectEncoding(Encoding value);
    public Encoding get_BodyEncoding();
    public void set_BodyEncoding(Encoding value);
    protected virtual void SendBuffer(LoggingEvent[] events);
    protected virtual bool get_RequiresLayout();
    protected virtual void SendEmail(string messageBody);
    private static string MaybeTrimSeparators(string s);
}
public class log4net.Appender.SmtpPickupDirAppender : BufferingAppenderSkeleton {
    private string m_to;
    private string m_from;
    private string m_subject;
    private string m_pickupDir;
    private string m_fileExtension;
    private SecurityContext m_securityContext;
    public string To { get; public set; }
    public string From { get; public set; }
    public string Subject { get; public set; }
    public string PickupDir { get; public set; }
    public string FileExtension { get; public set; }
    public SecurityContext SecurityContext { get; public set; }
    protected bool RequiresLayout { get; }
    public string get_To();
    public void set_To(string value);
    public string get_From();
    public void set_From(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_PickupDir();
    public void set_PickupDir(string value);
    public string get_FileExtension();
    public void set_FileExtension(string value);
    public SecurityContext get_SecurityContext();
    public void set_SecurityContext(SecurityContext value);
    protected virtual void SendBuffer(LoggingEvent[] events);
    public virtual void ActivateOptions();
    protected virtual bool get_RequiresLayout();
    protected static string ConvertToFullPath(string path);
}
public class log4net.Appender.TelnetAppender : AppenderSkeleton {
    private SocketHandler m_handler;
    private int m_listeningPort;
    private static Type declaringType;
    public int Port { get; public set; }
    protected bool RequiresLayout { get; }
    private static TelnetAppender();
    public int get_Port();
    public void set_Port(int value);
    protected virtual void OnClose();
    protected virtual bool get_RequiresLayout();
    public virtual void ActivateOptions();
    protected virtual void Append(LoggingEvent loggingEvent);
}
public class log4net.Appender.TextWriterAppender : AppenderSkeleton {
    private QuietTextWriter m_qtw;
    private bool m_immediateFlush;
    private static Type declaringType;
    public bool ImmediateFlush { get; public set; }
    public TextWriter Writer { get; public set; }
    public IErrorHandler ErrorHandler { get; public set; }
    protected bool RequiresLayout { get; }
    protected QuietTextWriter QuietWriter { get; protected set; }
    [ObsoleteAttribute("Instead use the default constructor and set the Layout & Writer properties")]
public TextWriterAppender(ILayout layout, Stream os);
    [ObsoleteAttribute("Instead use the default constructor and set the Layout & Writer properties")]
public TextWriterAppender(ILayout layout, TextWriter writer);
    private static TextWriterAppender();
    public bool get_ImmediateFlush();
    public void set_ImmediateFlush(bool value);
    public virtual TextWriter get_Writer();
    public virtual void set_Writer(TextWriter value);
    protected virtual bool PreAppendCheck();
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual void Append(LoggingEvent[] loggingEvents);
    protected virtual void OnClose();
    public virtual IErrorHandler get_ErrorHandler();
    public virtual void set_ErrorHandler(IErrorHandler value);
    protected virtual bool get_RequiresLayout();
    protected virtual void WriteFooterAndCloseWriter();
    protected virtual void CloseWriter();
    protected virtual void Reset();
    protected virtual void WriteFooter();
    protected virtual void WriteHeader();
    protected virtual void PrepareWriter();
    protected QuietTextWriter get_QuietWriter();
    protected void set_QuietWriter(QuietTextWriter value);
    public virtual bool Flush(int millisecondsTimeout);
}
public class log4net.Appender.TraceAppender : AppenderSkeleton {
    private bool m_immediateFlush;
    private PatternLayout m_category;
    public bool ImmediateFlush { get; public set; }
    public PatternLayout Category { get; public set; }
    protected bool RequiresLayout { get; }
    [ObsoleteAttribute("Instead use the default constructor and set the Layout property")]
public TraceAppender(ILayout layout);
    public bool get_ImmediateFlush();
    public void set_ImmediateFlush(bool value);
    public PatternLayout get_Category();
    public void set_Category(PatternLayout value);
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    public virtual bool Flush(int millisecondsTimeout);
}
public class log4net.Appender.UdpAppender : AppenderSkeleton {
    private IPAddress m_remoteAddress;
    private int m_remotePort;
    private IPEndPoint m_remoteEndPoint;
    private int m_localPort;
    private UdpClient m_client;
    private Encoding m_encoding;
    public IPAddress RemoteAddress { get; public set; }
    public int RemotePort { get; public set; }
    public int LocalPort { get; public set; }
    public Encoding Encoding { get; public set; }
    protected UdpClient Client { get; protected set; }
    protected IPEndPoint RemoteEndPoint { get; protected set; }
    protected bool RequiresLayout { get; }
    public IPAddress get_RemoteAddress();
    public void set_RemoteAddress(IPAddress value);
    public int get_RemotePort();
    public void set_RemotePort(int value);
    public int get_LocalPort();
    public void set_LocalPort(int value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    protected UdpClient get_Client();
    protected void set_Client(UdpClient value);
    protected IPEndPoint get_RemoteEndPoint();
    protected void set_RemoteEndPoint(IPEndPoint value);
    public virtual void ActivateOptions();
    protected virtual void Append(LoggingEvent loggingEvent);
    protected virtual bool get_RequiresLayout();
    protected virtual void OnClose();
    protected virtual void InitializeClientConnection();
}
[AttributeUsageAttribute("1")]
[ObsoleteAttribute("Use AliasRepositoryAttribute instead of AliasDomainAttribute")]
public class log4net.Config.AliasDomainAttribute : AliasRepositoryAttribute {
    public AliasDomainAttribute(string name);
}
[AttributeUsageAttribute("1")]
public class log4net.Config.AliasRepositoryAttribute : Attribute {
    private string m_name;
    public string Name { get; public set; }
    public AliasRepositoryAttribute(string name);
    public string get_Name();
    public void set_Name(string value);
}
public class log4net.Config.BasicConfigurator : object {
    private static Type declaringType;
    private static BasicConfigurator();
    public static ICollection Configure();
    public static ICollection Configure(IAppender[] appenders);
    public static ICollection Configure(IAppender appender);
    public static ICollection Configure(ILoggerRepository repository);
    public static ICollection Configure(ILoggerRepository repository, IAppender appender);
    public static ICollection Configure(ILoggerRepository repository, IAppender[] appenders);
    private static void InternalConfigure(ILoggerRepository repository, IAppender[] appenders);
}
[AttributeUsageAttribute("1")]
public abstract class log4net.Config.ConfiguratorAttribute : Attribute {
    private int m_priority;
    protected ConfiguratorAttribute(int priority);
    public abstract virtual void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository);
    public sealed virtual int CompareTo(object obj);
}
[AttributeUsageAttribute("1")]
[ObsoleteAttribute("Use RepositoryAttribute instead of DomainAttribute")]
public class log4net.Config.DomainAttribute : RepositoryAttribute {
    public DomainAttribute(string name);
}
[ObsoleteAttribute("Use XmlConfigurator instead of DOMConfigurator")]
public class log4net.Config.DOMConfigurator : object {
    [ObsoleteAttribute("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
public static void Configure();
    [ObsoleteAttribute("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
public static void Configure(ILoggerRepository repository);
    [ObsoleteAttribute("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
public static void Configure(XmlElement element);
    [ObsoleteAttribute("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
public static void Configure(ILoggerRepository repository, XmlElement element);
    [ObsoleteAttribute("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
public static void Configure(FileInfo configFile);
    [ObsoleteAttribute("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
public static void Configure(Stream configStream);
    [ObsoleteAttribute("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
public static void Configure(ILoggerRepository repository, FileInfo configFile);
    [ObsoleteAttribute("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
public static void Configure(ILoggerRepository repository, Stream configStream);
    [ObsoleteAttribute("Use XmlConfigurator.ConfigureAndWatch instead of DOMConfigurator.ConfigureAndWatch")]
public static void ConfigureAndWatch(FileInfo configFile);
    [ObsoleteAttribute("Use XmlConfigurator.ConfigureAndWatch instead of DOMConfigurator.ConfigureAndWatch")]
public static void ConfigureAndWatch(ILoggerRepository repository, FileInfo configFile);
}
[AttributeUsageAttribute("1")]
[ObsoleteAttribute("Use XmlConfiguratorAttribute instead of DOMConfiguratorAttribute")]
public class log4net.Config.DOMConfiguratorAttribute : XmlConfiguratorAttribute {
}
public class log4net.Config.Log4NetConfigurationSectionHandler : object {
    public sealed virtual object Create(object parent, object configContext, XmlNode section);
}
[AttributeUsageAttribute("1")]
public class log4net.Config.PluginAttribute : Attribute {
    private string m_typeName;
    private Type m_type;
    public Type Type { get; public set; }
    public string TypeName { get; public set; }
    public PluginAttribute(string typeName);
    public PluginAttribute(Type type);
    public Type get_Type();
    public void set_Type(Type value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public sealed virtual IPlugin CreatePlugin();
    public virtual string ToString();
}
[AttributeUsageAttribute("1")]
public class log4net.Config.RepositoryAttribute : Attribute {
    private string m_name;
    private Type m_repositoryType;
    public string Name { get; public set; }
    public Type RepositoryType { get; public set; }
    public RepositoryAttribute(string name);
    public string get_Name();
    public void set_Name(string value);
    public Type get_RepositoryType();
    public void set_RepositoryType(Type value);
}
[AttributeUsageAttribute("1")]
public class log4net.Config.SecurityContextProviderAttribute : ConfiguratorAttribute {
    private Type m_providerType;
    private static Type declaringType;
    public Type ProviderType { get; public set; }
    public SecurityContextProviderAttribute(Type providerType);
    private static SecurityContextProviderAttribute();
    public Type get_ProviderType();
    public void set_ProviderType(Type value);
    public virtual void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository);
}
public class log4net.Config.XmlConfigurator : object {
    private static Hashtable m_repositoryName2ConfigAndWatchHandler;
    private static Type declaringType;
    private static XmlConfigurator();
    public static ICollection Configure(ILoggerRepository repository);
    private static void InternalConfigure(ILoggerRepository repository);
    public static ICollection Configure();
    public static ICollection Configure(XmlElement element);
    public static ICollection Configure(FileInfo configFile);
    public static ICollection Configure(Uri configUri);
    public static ICollection Configure(Stream configStream);
    public static ICollection Configure(ILoggerRepository repository, XmlElement element);
    public static ICollection Configure(ILoggerRepository repository, FileInfo configFile);
    private static void InternalConfigure(ILoggerRepository repository, FileInfo configFile);
    public static ICollection Configure(ILoggerRepository repository, Uri configUri);
    private static void InternalConfigure(ILoggerRepository repository, Uri configUri);
    public static ICollection Configure(ILoggerRepository repository, Stream configStream);
    private static void InternalConfigure(ILoggerRepository repository, Stream configStream);
    public static ICollection ConfigureAndWatch(FileInfo configFile);
    public static ICollection ConfigureAndWatch(ILoggerRepository repository, FileInfo configFile);
    private static void InternalConfigureAndWatch(ILoggerRepository repository, FileInfo configFile);
    private static void InternalConfigureFromXml(ILoggerRepository repository, XmlElement element);
}
[AttributeUsageAttribute("1")]
public class log4net.Config.XmlConfiguratorAttribute : ConfiguratorAttribute {
    private string m_configFile;
    private string m_configFileExtension;
    private bool m_configureAndWatch;
    private static Type declaringType;
    public string ConfigFile { get; public set; }
    public string ConfigFileExtension { get; public set; }
    public bool Watch { get; public set; }
    private static XmlConfiguratorAttribute();
    public string get_ConfigFile();
    public void set_ConfigFile(string value);
    public string get_ConfigFileExtension();
    public void set_ConfigFileExtension(string value);
    public bool get_Watch();
    public void set_Watch(bool value);
    public virtual void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository);
    private void ConfigureFromFile(Assembly sourceAssembly, ILoggerRepository targetRepository);
    private void ConfigureFromFile(ILoggerRepository targetRepository, FileInfo configFile);
    private void ConfigureFromUri(Assembly sourceAssembly, ILoggerRepository targetRepository);
}
public class log4net.Core.CompactRepositorySelector : object {
    private static string DefaultRepositoryName;
    private Hashtable m_name2repositoryMap;
    private Type m_defaultRepositoryType;
    [CompilerGeneratedAttribute]
private LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;
    private static Type declaringType;
    public CompactRepositorySelector(Type defaultRepositoryType);
    private static CompactRepositorySelector();
    [CompilerGeneratedAttribute]
private void add_m_loggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_m_loggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
    public sealed virtual ILoggerRepository GetRepository(Assembly assembly);
    public sealed virtual ILoggerRepository GetRepository(string repositoryName);
    public sealed virtual ILoggerRepository CreateRepository(Assembly assembly, Type repositoryType);
    public sealed virtual ILoggerRepository CreateRepository(string repositoryName, Type repositoryType);
    public sealed virtual bool ExistsRepository(string repositoryName);
    public sealed virtual ILoggerRepository[] GetAllRepositories();
    public sealed virtual void add_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
    public sealed virtual void remove_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
    protected virtual void OnLoggerRepositoryCreatedEvent(ILoggerRepository repository);
}
public class log4net.Core.DefaultRepositorySelector : object {
    private static Type declaringType;
    private static string DefaultRepositoryName;
    private Hashtable m_name2repositoryMap;
    private Hashtable m_assembly2repositoryMap;
    private Hashtable m_alias2repositoryMap;
    private Type m_defaultRepositoryType;
    [CompilerGeneratedAttribute]
private LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;
    public DefaultRepositorySelector(Type defaultRepositoryType);
    private static DefaultRepositorySelector();
    public sealed virtual void add_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
    public sealed virtual void remove_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
    public sealed virtual ILoggerRepository GetRepository(Assembly repositoryAssembly);
    public sealed virtual ILoggerRepository GetRepository(string repositoryName);
    public sealed virtual ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType);
    public ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType, string repositoryName, bool readAssemblyAttributes);
    public sealed virtual ILoggerRepository CreateRepository(string repositoryName, Type repositoryType);
    public sealed virtual bool ExistsRepository(string repositoryName);
    public sealed virtual ILoggerRepository[] GetAllRepositories();
    public void AliasRepository(string repositoryAlias, ILoggerRepository repositoryTarget);
    protected virtual void OnLoggerRepositoryCreatedEvent(ILoggerRepository repository);
    private void GetInfoForAssembly(Assembly assembly, String& repositoryName, Type& repositoryType);
    private void ConfigureRepository(Assembly assembly, ILoggerRepository repository);
    private void LoadPlugins(Assembly assembly, ILoggerRepository repository);
    private void LoadAliases(Assembly assembly, ILoggerRepository repository);
    [CompilerGeneratedAttribute]
private void add_m_loggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_m_loggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
}
public enum log4net.Core.ErrorCode : Enum {
    public int value__;
    public static ErrorCode GenericFailure;
    public static ErrorCode WriteFailure;
    public static ErrorCode FlushFailure;
    public static ErrorCode CloseFailure;
    public static ErrorCode FileOpenFailure;
    public static ErrorCode MissingLayout;
    public static ErrorCode AddressParseFailure;
}
public class log4net.Core.ExceptionEvaluator : object {
    private Type m_type;
    private bool m_triggerOnSubclass;
    public Type ExceptionType { get; public set; }
    public bool TriggerOnSubclass { get; public set; }
    public ExceptionEvaluator(Type exType, bool triggerOnSubClass);
    public Type get_ExceptionType();
    public void set_ExceptionType(Type value);
    public bool get_TriggerOnSubclass();
    public void set_TriggerOnSubclass(bool value);
    public sealed virtual bool IsTriggeringEvent(LoggingEvent loggingEvent);
}
[FlagsAttribute]
public enum log4net.Core.FixFlags : Enum {
    public int value__;
    [ObsoleteAttribute("Replaced by composite Properties")]
public static FixFlags Mdc;
    public static FixFlags Ndc;
    public static FixFlags Message;
    public static FixFlags ThreadName;
    public static FixFlags LocationInfo;
    public static FixFlags UserName;
    public static FixFlags Domain;
    public static FixFlags Identity;
    public static FixFlags Exception;
    public static FixFlags Properties;
    public static FixFlags None;
    public static FixFlags All;
    public static FixFlags Partial;
}
public interface log4net.Core.IAppenderAttachable {
    public AppenderCollection Appenders { get; }
    public abstract virtual void AddAppender(IAppender appender);
    public abstract virtual AppenderCollection get_Appenders();
    public abstract virtual IAppender GetAppender(string name);
    public abstract virtual void RemoveAllAppenders();
    public abstract virtual IAppender RemoveAppender(IAppender appender);
    public abstract virtual IAppender RemoveAppender(string name);
}
public interface log4net.Core.IErrorHandler {
    public abstract virtual void Error(string message, Exception e, ErrorCode errorCode);
    public abstract virtual void Error(string message, Exception e);
    public abstract virtual void Error(string message);
}
public interface log4net.Core.IFixingRequired {
    public abstract virtual object GetFixedObject();
}
public interface log4net.Core.ILogger {
    public string Name { get; }
    public ILoggerRepository Repository { get; }
    public abstract virtual string get_Name();
    public abstract virtual void Log(Type callerStackBoundaryDeclaringType, Level level, object message, Exception exception);
    public abstract virtual void Log(LoggingEvent logEvent);
    public abstract virtual bool IsEnabledFor(Level level);
    public abstract virtual ILoggerRepository get_Repository();
}
public interface log4net.Core.ILoggerWrapper {
    public ILogger Logger { get; }
    public abstract virtual ILogger get_Logger();
}
public interface log4net.Core.IOptionHandler {
    public abstract virtual void ActivateOptions();
}
public interface log4net.Core.IRepositorySelector {
    public abstract virtual ILoggerRepository GetRepository(Assembly assembly);
    public abstract virtual ILoggerRepository GetRepository(string repositoryName);
    public abstract virtual ILoggerRepository CreateRepository(Assembly assembly, Type repositoryType);
    public abstract virtual ILoggerRepository CreateRepository(string repositoryName, Type repositoryType);
    public abstract virtual bool ExistsRepository(string repositoryName);
    public abstract virtual ILoggerRepository[] GetAllRepositories();
    [CompilerGeneratedAttribute]
public abstract virtual void add_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LoggerRepositoryCreatedEvent(LoggerRepositoryCreationEventHandler value);
}
public interface log4net.Core.ITriggeringEventEvaluator {
    public abstract virtual bool IsTriggeringEvent(LoggingEvent loggingEvent);
}
public class log4net.Core.Level : object {
    public static Level Off;
    public static Level Log4Net_Debug;
    public static Level Emergency;
    public static Level Fatal;
    public static Level Alert;
    public static Level Critical;
    public static Level Severe;
    public static Level Error;
    public static Level Warn;
    public static Level Notice;
    public static Level Info;
    public static Level Debug;
    public static Level Fine;
    public static Level Trace;
    public static Level Finer;
    public static Level Verbose;
    public static Level Finest;
    public static Level All;
    private int m_levelValue;
    private string m_levelName;
    private string m_levelDisplayName;
    public string Name { get; }
    public int Value { get; }
    public string DisplayName { get; }
    public Level(int level, string levelName, string displayName);
    public Level(int level, string levelName);
    private static Level();
    public string get_Name();
    public int get_Value();
    public string get_DisplayName();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object r);
    public static bool op_GreaterThan(Level l, Level r);
    public static bool op_LessThan(Level l, Level r);
    public static bool op_GreaterThanOrEqual(Level l, Level r);
    public static bool op_LessThanOrEqual(Level l, Level r);
    public static bool op_Equality(Level l, Level r);
    public static bool op_Inequality(Level l, Level r);
    public static int Compare(Level l, Level r);
}
[DefaultMemberAttribute("Item")]
public class log4net.Core.LevelCollection : object {
    private static int DEFAULT_CAPACITY;
    private Level[] m_array;
    private int m_count;
    private int m_version;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public Level Item { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public int Capacity { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public LevelCollection(int capacity);
    public LevelCollection(LevelCollection c);
    public LevelCollection(Level[] a);
    public LevelCollection(ICollection col);
    protected internal LevelCollection(Tag tag);
    public static LevelCollection ReadOnly(LevelCollection list);
    public virtual int get_Count();
    public virtual void CopyTo(Level[] array);
    public virtual void CopyTo(Level[] array, int start);
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual Level get_Item(int index);
    public virtual void set_Item(int index, Level value);
    public virtual int Add(Level item);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(Level item);
    public virtual int IndexOf(Level item);
    public virtual void Insert(int index, Level item);
    public virtual void Remove(Level item);
    public virtual void RemoveAt(int index);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual ILevelCollectionEnumerator GetEnumerator();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int AddRange(LevelCollection x);
    public virtual int AddRange(Level[] x);
    public virtual int AddRange(ICollection col);
    public virtual void TrimToSize();
    private void ValidateIndex(int i);
    private void ValidateIndex(int i, bool allowEqualEnd);
    private void EnsureCapacity(int min);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int start);
    private sealed virtual override object System.Collections.IList.get_Item(int i);
    private sealed virtual override void System.Collections.IList.set_Item(int i, object value);
    private sealed virtual override int System.Collections.IList.Add(object x);
    private sealed virtual override bool System.Collections.IList.Contains(object x);
    private sealed virtual override int System.Collections.IList.IndexOf(object x);
    private sealed virtual override void System.Collections.IList.Insert(int pos, object x);
    private sealed virtual override void System.Collections.IList.Remove(object x);
    private sealed virtual override void System.Collections.IList.RemoveAt(int pos);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class log4net.Core.LevelEvaluator : object {
    private Level m_threshold;
    public Level Threshold { get; public set; }
    public LevelEvaluator(Level threshold);
    public Level get_Threshold();
    public void set_Threshold(Level value);
    public sealed virtual bool IsTriggeringEvent(LoggingEvent loggingEvent);
}
[DefaultMemberAttribute("Item")]
public class log4net.Core.LevelMap : object {
    private Hashtable m_mapName2Level;
    public Level Item { get; }
    public LevelCollection AllLevels { get; }
    public void Clear();
    public Level get_Item(string name);
    public void Add(string name, int value);
    public void Add(string name, int value, string displayName);
    public void Add(Level level);
    public LevelCollection get_AllLevels();
    public Level LookupWithDefault(Level defaultLevel);
}
public class log4net.Core.LocationInfo : object {
    private string m_className;
    private string m_fileName;
    private string m_lineNumber;
    private string m_methodName;
    private string m_fullInfo;
    private StackFrameItem[] m_stackFrames;
    private static Type declaringType;
    private static string NA;
    public string ClassName { get; }
    public string FileName { get; }
    public string LineNumber { get; }
    public string MethodName { get; }
    public string FullInfo { get; }
    public StackFrameItem[] StackFrames { get; }
    public LocationInfo(Type callerStackBoundaryDeclaringType);
    public LocationInfo(string className, string methodName, string fileName, string lineNumber);
    private static LocationInfo();
    public string get_ClassName();
    public string get_FileName();
    public string get_LineNumber();
    public string get_MethodName();
    public string get_FullInfo();
    public StackFrameItem[] get_StackFrames();
}
public class log4net.Core.LogException : ApplicationException {
    public LogException(string message);
    public LogException(string message, Exception innerException);
    protected LogException(SerializationInfo info, StreamingContext context);
}
public class log4net.Core.LoggerManager : object {
    private static Type declaringType;
    private static IRepositorySelector s_repositorySelector;
    public static IRepositorySelector RepositorySelector { get; public set; }
    private static LoggerManager();
    private static void RegisterAppDomainEvents();
    [ObsoleteAttribute("Use GetRepository instead of GetLoggerRepository")]
public static ILoggerRepository GetLoggerRepository(string repository);
    [ObsoleteAttribute("Use GetRepository instead of GetLoggerRepository")]
public static ILoggerRepository GetLoggerRepository(Assembly repositoryAssembly);
    public static ILoggerRepository GetRepository(string repository);
    public static ILoggerRepository GetRepository(Assembly repositoryAssembly);
    public static ILogger Exists(string repository, string name);
    public static ILogger Exists(Assembly repositoryAssembly, string name);
    public static ILogger[] GetCurrentLoggers(string repository);
    public static ILogger[] GetCurrentLoggers(Assembly repositoryAssembly);
    public static ILogger GetLogger(string repository, string name);
    public static ILogger GetLogger(Assembly repositoryAssembly, string name);
    public static ILogger GetLogger(string repository, Type type);
    public static ILogger GetLogger(Assembly repositoryAssembly, Type type);
    public static void Shutdown();
    public static void ShutdownRepository(string repository);
    public static void ShutdownRepository(Assembly repositoryAssembly);
    public static void ResetConfiguration(string repository);
    public static void ResetConfiguration(Assembly repositoryAssembly);
    [ObsoleteAttribute("Use CreateRepository instead of CreateDomain")]
public static ILoggerRepository CreateDomain(string repository);
    public static ILoggerRepository CreateRepository(string repository);
    [ObsoleteAttribute("Use CreateRepository instead of CreateDomain")]
public static ILoggerRepository CreateDomain(string repository, Type repositoryType);
    public static ILoggerRepository CreateRepository(string repository, Type repositoryType);
    [ObsoleteAttribute("Use CreateRepository instead of CreateDomain")]
public static ILoggerRepository CreateDomain(Assembly repositoryAssembly, Type repositoryType);
    public static ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType);
    public static ILoggerRepository[] GetAllRepositories();
    public static IRepositorySelector get_RepositorySelector();
    public static void set_RepositorySelector(IRepositorySelector value);
    private static string GetVersionInfo();
    private static void OnDomainUnload(object sender, EventArgs e);
    private static void OnProcessExit(object sender, EventArgs e);
}
public class log4net.Core.LoggerRepositoryCreationEventArgs : EventArgs {
    private ILoggerRepository m_repository;
    public ILoggerRepository LoggerRepository { get; }
    public LoggerRepositoryCreationEventArgs(ILoggerRepository repository);
    public ILoggerRepository get_LoggerRepository();
}
public class log4net.Core.LoggerRepositoryCreationEventHandler : MulticastDelegate {
    public LoggerRepositoryCreationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LoggerRepositoryCreationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, LoggerRepositoryCreationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class log4net.Core.LoggerWrapperImpl : object {
    private ILogger m_logger;
    public ILogger Logger { get; }
    protected LoggerWrapperImpl(ILogger logger);
    public virtual ILogger get_Logger();
}
public class log4net.Core.LoggingEvent : object {
    private static Type declaringType;
    private LoggingEventData m_data;
    private CompositeProperties m_compositeProperties;
    private PropertiesDictionary m_eventProperties;
    private Type m_callerStackBoundaryDeclaringType;
    private object m_message;
    private Exception m_thrownException;
    private ILoggerRepository m_repository;
    private FixFlags m_fixFlags;
    private bool m_cacheUpdatable;
    public static string HostNameProperty;
    public static string IdentityProperty;
    public static string UserNameProperty;
    public static DateTime StartTime { get; }
    public static DateTime StartTimeUtc { get; }
    public Level Level { get; }
    public DateTime TimeStamp { get; }
    public DateTime TimeStampUtc { get; }
    public string LoggerName { get; }
    public LocationInfo LocationInformation { get; }
    public object MessageObject { get; }
    public Exception ExceptionObject { get; }
    public ILoggerRepository Repository { get; }
    public string RenderedMessage { get; }
    public string ThreadName { get; }
    public string UserName { get; }
    public string Identity { get; }
    public string Domain { get; }
    public PropertiesDictionary Properties { get; }
    public FixFlags Fix { get; public set; }
    public LoggingEvent(Type callerStackBoundaryDeclaringType, ILoggerRepository repository, string loggerName, Level level, object message, Exception exception);
    public LoggingEvent(Type callerStackBoundaryDeclaringType, ILoggerRepository repository, LoggingEventData data, FixFlags fixedData);
    public LoggingEvent(Type callerStackBoundaryDeclaringType, ILoggerRepository repository, LoggingEventData data);
    public LoggingEvent(LoggingEventData data);
    protected LoggingEvent(SerializationInfo info, StreamingContext context);
    private static LoggingEvent();
    public static DateTime get_StartTime();
    public static DateTime get_StartTimeUtc();
    public Level get_Level();
    public DateTime get_TimeStamp();
    public DateTime get_TimeStampUtc();
    public string get_LoggerName();
    public LocationInfo get_LocationInformation();
    public object get_MessageObject();
    public Exception get_ExceptionObject();
    public ILoggerRepository get_Repository();
    internal void EnsureRepository(ILoggerRepository repository);
    public string get_RenderedMessage();
    public void WriteRenderedMessage(TextWriter writer);
    public string get_ThreadName();
    public string get_UserName();
    private static string TryGetCurrentUserName();
    public string get_Identity();
    public string get_Domain();
    public PropertiesDictionary get_Properties();
    public FixFlags get_Fix();
    public void set_Fix(FixFlags value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public LoggingEventData GetLoggingEventData();
    public LoggingEventData GetLoggingEventData(FixFlags fixFlags);
    [ObsoleteAttribute("Use GetExceptionString instead")]
public string GetExceptionStrRep();
    public string GetExceptionString();
    [ObsoleteAttribute("Use Fix property")]
public void FixVolatileData();
    [ObsoleteAttribute("Use Fix property")]
public void FixVolatileData(bool fastButLoose);
    protected void FixVolatileData(FixFlags flags);
    private void CreateCompositeProperties();
    private void CacheProperties();
    public object LookupProperty(string key);
    public PropertiesDictionary GetProperties();
}
public class log4net.Core.LoggingEventData : ValueType {
    public string LoggerName;
    public Level Level;
    public string Message;
    public string ThreadName;
    [ObsoleteAttribute("Prefer using TimeStampUtc, since local time can be ambiguous in time zones with daylight savings time.")]
public DateTime TimeStamp;
    private DateTime _timeStampUtc;
    public LocationInfo LocationInfo;
    public string UserName;
    public string Identity;
    public string ExceptionString;
    public string Domain;
    public PropertiesDictionary Properties;
    public DateTime TimeStampUtc { get; public set; }
    public DateTime get_TimeStampUtc();
    public void set_TimeStampUtc(DateTime value);
}
public class log4net.Core.LogImpl : LoggerWrapperImpl {
    private static Type ThisDeclaringType;
    private Level m_levelDebug;
    private Level m_levelInfo;
    private Level m_levelWarn;
    private Level m_levelError;
    private Level m_levelFatal;
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public LogImpl(ILogger logger);
    private static LogImpl();
    protected virtual void ReloadLevels(ILoggerRepository repository);
    public virtual void Debug(object message);
    public virtual void Debug(object message, Exception exception);
    public virtual void DebugFormat(string format, Object[] args);
    public virtual void DebugFormat(string format, object arg0);
    public virtual void DebugFormat(string format, object arg0, object arg1);
    public virtual void DebugFormat(string format, object arg0, object arg1, object arg2);
    public virtual void DebugFormat(IFormatProvider provider, string format, Object[] args);
    public virtual void Info(object message);
    public virtual void Info(object message, Exception exception);
    public virtual void InfoFormat(string format, Object[] args);
    public virtual void InfoFormat(string format, object arg0);
    public virtual void InfoFormat(string format, object arg0, object arg1);
    public virtual void InfoFormat(string format, object arg0, object arg1, object arg2);
    public virtual void InfoFormat(IFormatProvider provider, string format, Object[] args);
    public virtual void Warn(object message);
    public virtual void Warn(object message, Exception exception);
    public virtual void WarnFormat(string format, Object[] args);
    public virtual void WarnFormat(string format, object arg0);
    public virtual void WarnFormat(string format, object arg0, object arg1);
    public virtual void WarnFormat(string format, object arg0, object arg1, object arg2);
    public virtual void WarnFormat(IFormatProvider provider, string format, Object[] args);
    public virtual void Error(object message);
    public virtual void Error(object message, Exception exception);
    public virtual void ErrorFormat(string format, Object[] args);
    public virtual void ErrorFormat(string format, object arg0);
    public virtual void ErrorFormat(string format, object arg0, object arg1);
    public virtual void ErrorFormat(string format, object arg0, object arg1, object arg2);
    public virtual void ErrorFormat(IFormatProvider provider, string format, Object[] args);
    public virtual void Fatal(object message);
    public virtual void Fatal(object message, Exception exception);
    public virtual void FatalFormat(string format, Object[] args);
    public virtual void FatalFormat(string format, object arg0);
    public virtual void FatalFormat(string format, object arg0, object arg1);
    public virtual void FatalFormat(string format, object arg0, object arg1, object arg2);
    public virtual void FatalFormat(IFormatProvider provider, string format, Object[] args);
    public virtual bool get_IsDebugEnabled();
    public virtual bool get_IsInfoEnabled();
    public virtual bool get_IsWarnEnabled();
    public virtual bool get_IsErrorEnabled();
    public virtual bool get_IsFatalEnabled();
    private void LoggerRepositoryConfigurationChanged(object sender, EventArgs e);
}
public class log4net.Core.MethodItem : object {
    private string m_name;
    private String[] m_parameters;
    private static Type declaringType;
    private static string NA;
    public string Name { get; }
    public String[] Parameters { get; }
    public MethodItem(string name);
    public MethodItem(string name, String[] parameters);
    public MethodItem(MethodBase methodBase);
    private static MethodItem();
    private static String[] GetMethodParameterNames(MethodBase methodBase);
    public string get_Name();
    public String[] get_Parameters();
}
public abstract class log4net.Core.SecurityContext : object {
    public abstract virtual IDisposable Impersonate(object state);
}
public class log4net.Core.SecurityContextProvider : object {
    private static SecurityContextProvider s_defaultProvider;
    public static SecurityContextProvider DefaultProvider { get; public set; }
    private static SecurityContextProvider();
    public static SecurityContextProvider get_DefaultProvider();
    public static void set_DefaultProvider(SecurityContextProvider value);
    public virtual SecurityContext CreateSecurityContext(object consumer);
}
public class log4net.Core.StackFrameItem : object {
    private string m_lineNumber;
    private string m_fileName;
    private string m_className;
    private string m_fullInfo;
    private MethodItem m_method;
    private static Type declaringType;
    private static string NA;
    public string ClassName { get; }
    public string FileName { get; }
    public string LineNumber { get; }
    public MethodItem Method { get; }
    public string FullInfo { get; }
    public StackFrameItem(StackFrame frame);
    private static StackFrameItem();
    public string get_ClassName();
    public string get_FileName();
    public string get_LineNumber();
    public MethodItem get_Method();
    public string get_FullInfo();
}
public class log4net.Core.TimeEvaluator : object {
    private int m_interval;
    private DateTime m_lastTimeUtc;
    private static int DEFAULT_INTERVAL;
    public int Interval { get; public set; }
    public TimeEvaluator(int interval);
    public int get_Interval();
    public void set_Interval(int value);
    public sealed virtual bool IsTriggeringEvent(LoggingEvent loggingEvent);
}
public class log4net.Core.WrapperCreationHandler : MulticastDelegate {
    public WrapperCreationHandler(object object, IntPtr method);
    public virtual ILoggerWrapper Invoke(ILogger logger);
    public virtual IAsyncResult BeginInvoke(ILogger logger, AsyncCallback callback, object object);
    public virtual ILoggerWrapper EndInvoke(IAsyncResult result);
}
public class log4net.Core.WrapperMap : object {
    private Hashtable m_repositories;
    private WrapperCreationHandler m_createWrapperHandler;
    private LoggerRepositoryShutdownEventHandler m_shutdownHandler;
    protected Hashtable Repositories { get; }
    public WrapperMap(WrapperCreationHandler createWrapperHandler);
    public virtual ILoggerWrapper GetWrapper(ILogger logger);
    protected Hashtable get_Repositories();
    protected virtual ILoggerWrapper CreateNewWrapperObject(ILogger logger);
    protected virtual void RepositoryShutdown(ILoggerRepository repository);
    private void ILoggerRepository_Shutdown(object sender, EventArgs e);
}
public class log4net.DateFormatter.AbsoluteTimeDateFormatter : object {
    public static string AbsoluteTimeDateFormat;
    public static string DateAndTimeDateFormat;
    public static string Iso8601TimeDateFormat;
    private static long s_lastTimeToTheSecond;
    private static StringBuilder s_lastTimeBuf;
    private static Hashtable s_lastTimeStrings;
    private static AbsoluteTimeDateFormatter();
    protected virtual void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer);
    public virtual void FormatDate(DateTime dateToFormat, TextWriter writer);
}
public class log4net.DateFormatter.DateTimeDateFormatter : AbsoluteTimeDateFormatter {
    private DateTimeFormatInfo m_dateTimeFormatInfo;
    protected virtual void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer);
}
public interface log4net.DateFormatter.IDateFormatter {
    public abstract virtual void FormatDate(DateTime dateToFormat, TextWriter writer);
}
public class log4net.DateFormatter.Iso8601DateFormatter : AbsoluteTimeDateFormatter {
    protected virtual void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer);
}
public class log4net.DateFormatter.SimpleDateFormatter : object {
    private string m_formatString;
    public SimpleDateFormatter(string format);
    public virtual void FormatDate(DateTime dateToFormat, TextWriter writer);
}
public class log4net.Filter.DenyAllFilter : FilterSkeleton {
    public virtual FilterDecision Decide(LoggingEvent loggingEvent);
}
public enum log4net.Filter.FilterDecision : Enum {
    public int value__;
    public static FilterDecision Deny;
    public static FilterDecision Neutral;
    public static FilterDecision Accept;
}
public abstract class log4net.Filter.FilterSkeleton : object {
    private IFilter m_next;
    public IFilter Next { get; public set; }
    public virtual void ActivateOptions();
    public abstract virtual FilterDecision Decide(LoggingEvent loggingEvent);
    public sealed virtual IFilter get_Next();
    public sealed virtual void set_Next(IFilter value);
}
public interface log4net.Filter.IFilter {
    public IFilter Next { get; public set; }
    public abstract virtual FilterDecision Decide(LoggingEvent loggingEvent);
    public abstract virtual IFilter get_Next();
    public abstract virtual void set_Next(IFilter value);
}
public class log4net.Filter.LevelMatchFilter : FilterSkeleton {
    private bool m_acceptOnMatch;
    private Level m_levelToMatch;
    public bool AcceptOnMatch { get; public set; }
    public Level LevelToMatch { get; public set; }
    public bool get_AcceptOnMatch();
    public void set_AcceptOnMatch(bool value);
    public Level get_LevelToMatch();
    public void set_LevelToMatch(Level value);
    public virtual FilterDecision Decide(LoggingEvent loggingEvent);
}
public class log4net.Filter.LevelRangeFilter : FilterSkeleton {
    private bool m_acceptOnMatch;
    private Level m_levelMin;
    private Level m_levelMax;
    public bool AcceptOnMatch { get; public set; }
    public Level LevelMin { get; public set; }
    public Level LevelMax { get; public set; }
    public bool get_AcceptOnMatch();
    public void set_AcceptOnMatch(bool value);
    public Level get_LevelMin();
    public void set_LevelMin(Level value);
    public Level get_LevelMax();
    public void set_LevelMax(Level value);
    public virtual FilterDecision Decide(LoggingEvent loggingEvent);
}
public class log4net.Filter.LoggerMatchFilter : FilterSkeleton {
    private bool m_acceptOnMatch;
    private string m_loggerToMatch;
    public bool AcceptOnMatch { get; public set; }
    public string LoggerToMatch { get; public set; }
    public bool get_AcceptOnMatch();
    public void set_AcceptOnMatch(bool value);
    public string get_LoggerToMatch();
    public void set_LoggerToMatch(string value);
    public virtual FilterDecision Decide(LoggingEvent loggingEvent);
}
public class log4net.Filter.MdcFilter : PropertyFilter {
}
public class log4net.Filter.NdcFilter : PropertyFilter {
}
public class log4net.Filter.PropertyFilter : StringMatchFilter {
    private string m_key;
    public string Key { get; public set; }
    public string get_Key();
    public void set_Key(string value);
    public virtual FilterDecision Decide(LoggingEvent loggingEvent);
}
public class log4net.Filter.StringMatchFilter : FilterSkeleton {
    protected bool m_acceptOnMatch;
    protected string m_stringToMatch;
    protected string m_stringRegexToMatch;
    protected Regex m_regexToMatch;
    public bool AcceptOnMatch { get; public set; }
    public string StringToMatch { get; public set; }
    public string RegexToMatch { get; public set; }
    public virtual void ActivateOptions();
    public bool get_AcceptOnMatch();
    public void set_AcceptOnMatch(bool value);
    public string get_StringToMatch();
    public void set_StringToMatch(string value);
    public string get_RegexToMatch();
    public void set_RegexToMatch(string value);
    public virtual FilterDecision Decide(LoggingEvent loggingEvent);
}
public class log4net.GlobalContext : object {
    private static GlobalContextProperties s_properties;
    public static GlobalContextProperties Properties { get; }
    private static GlobalContext();
    public static GlobalContextProperties get_Properties();
}
public interface log4net.ILog {
    public bool IsDebugEnabled { get; }
    public bool IsInfoEnabled { get; }
    public bool IsWarnEnabled { get; }
    public bool IsErrorEnabled { get; }
    public bool IsFatalEnabled { get; }
    public abstract virtual void Debug(object message);
    public abstract virtual void Debug(object message, Exception exception);
    public abstract virtual void DebugFormat(string format, Object[] args);
    public abstract virtual void DebugFormat(string format, object arg0);
    public abstract virtual void DebugFormat(string format, object arg0, object arg1);
    public abstract virtual void DebugFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void DebugFormat(IFormatProvider provider, string format, Object[] args);
    public abstract virtual void Info(object message);
    public abstract virtual void Info(object message, Exception exception);
    public abstract virtual void InfoFormat(string format, Object[] args);
    public abstract virtual void InfoFormat(string format, object arg0);
    public abstract virtual void InfoFormat(string format, object arg0, object arg1);
    public abstract virtual void InfoFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void InfoFormat(IFormatProvider provider, string format, Object[] args);
    public abstract virtual void Warn(object message);
    public abstract virtual void Warn(object message, Exception exception);
    public abstract virtual void WarnFormat(string format, Object[] args);
    public abstract virtual void WarnFormat(string format, object arg0);
    public abstract virtual void WarnFormat(string format, object arg0, object arg1);
    public abstract virtual void WarnFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void WarnFormat(IFormatProvider provider, string format, Object[] args);
    public abstract virtual void Error(object message);
    public abstract virtual void Error(object message, Exception exception);
    public abstract virtual void ErrorFormat(string format, Object[] args);
    public abstract virtual void ErrorFormat(string format, object arg0);
    public abstract virtual void ErrorFormat(string format, object arg0, object arg1);
    public abstract virtual void ErrorFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void ErrorFormat(IFormatProvider provider, string format, Object[] args);
    public abstract virtual void Fatal(object message);
    public abstract virtual void Fatal(object message, Exception exception);
    public abstract virtual void FatalFormat(string format, Object[] args);
    public abstract virtual void FatalFormat(string format, object arg0);
    public abstract virtual void FatalFormat(string format, object arg0, object arg1);
    public abstract virtual void FatalFormat(string format, object arg0, object arg1, object arg2);
    public abstract virtual void FatalFormat(IFormatProvider provider, string format, Object[] args);
    public abstract virtual bool get_IsDebugEnabled();
    public abstract virtual bool get_IsInfoEnabled();
    public abstract virtual bool get_IsWarnEnabled();
    public abstract virtual bool get_IsErrorEnabled();
    public abstract virtual bool get_IsFatalEnabled();
}
public class log4net.Layout.DynamicPatternLayout : PatternLayout {
    private PatternString m_headerPatternString;
    private PatternString m_footerPatternString;
    public string Header { get; public set; }
    public string Footer { get; public set; }
    public DynamicPatternLayout(string pattern);
    public virtual string get_Header();
    public virtual void set_Header(string value);
    public virtual string get_Footer();
    public virtual void set_Footer(string value);
}
public class log4net.Layout.ExceptionLayout : LayoutSkeleton {
    public virtual void ActivateOptions();
    public virtual void Format(TextWriter writer, LoggingEvent loggingEvent);
}
public interface log4net.Layout.ILayout {
    public string ContentType { get; }
    public string Header { get; }
    public string Footer { get; }
    public bool IgnoresException { get; }
    public abstract virtual void Format(TextWriter writer, LoggingEvent loggingEvent);
    public abstract virtual string get_ContentType();
    public abstract virtual string get_Header();
    public abstract virtual string get_Footer();
    public abstract virtual bool get_IgnoresException();
}
[TypeConverterAttribute("log4net.Layout.RawLayoutConverter")]
public interface log4net.Layout.IRawLayout {
    public abstract virtual object Format(LoggingEvent loggingEvent);
}
public class log4net.Layout.Layout2RawLayoutAdapter : object {
    private ILayout m_layout;
    public Layout2RawLayoutAdapter(ILayout layout);
    public virtual object Format(LoggingEvent loggingEvent);
}
public abstract class log4net.Layout.LayoutSkeleton : object {
    private string m_header;
    private string m_footer;
    private bool m_ignoresException;
    public string ContentType { get; }
    public string Header { get; public set; }
    public string Footer { get; public set; }
    public bool IgnoresException { get; public set; }
    public abstract virtual void ActivateOptions();
    public abstract virtual void Format(TextWriter writer, LoggingEvent loggingEvent);
    public string Format(LoggingEvent loggingEvent);
    public virtual string get_ContentType();
    public virtual string get_Header();
    public virtual void set_Header(string value);
    public virtual string get_Footer();
    public virtual void set_Footer(string value);
    public virtual bool get_IgnoresException();
    public virtual void set_IgnoresException(bool value);
}
internal class log4net.Layout.Pattern.AppDomainPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.AspNetCachePatternConverter : AspNetPatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext);
}
internal class log4net.Layout.Pattern.AspNetContextPatternConverter : AspNetPatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext);
}
internal abstract class log4net.Layout.Pattern.AspNetPatternLayoutConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
    protected abstract virtual void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext);
}
internal class log4net.Layout.Pattern.AspNetRequestPatternConverter : AspNetPatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext);
}
internal class log4net.Layout.Pattern.AspNetSessionPatternConverter : AspNetPatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent, HttpContext httpContext);
}
internal class log4net.Layout.Pattern.DatePatternConverter : PatternLayoutConverter {
    protected IDateFormatter m_dateFormatter;
    private static Type declaringType;
    private static DatePatternConverter();
    public sealed virtual void ActivateOptions();
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.ExceptionPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.FileLocationPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.FullLocationPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.IdentityPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.LevelPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.LineLocationPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.LoggerPatternConverter : NamedPatternConverter {
    protected virtual string GetFullyQualifiedName(LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.MessagePatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.MethodLocationPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
public abstract class log4net.Layout.Pattern.NamedPatternConverter : PatternLayoutConverter {
    private int m_precision;
    private static Type declaringType;
    private static string DOT;
    private static NamedPatternConverter();
    public sealed virtual void ActivateOptions();
    protected abstract virtual string GetFullyQualifiedName(LoggingEvent loggingEvent);
    protected sealed virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.NdcPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
public abstract class log4net.Layout.Pattern.PatternLayoutConverter : PatternConverter {
    private bool m_ignoresException;
    public bool IgnoresException { get; public set; }
    public virtual bool get_IgnoresException();
    public virtual void set_IgnoresException(bool value);
    protected abstract virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Layout.Pattern.PropertyPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.RelativeTimePatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
    private static long TimeDifferenceInMillis(DateTime start, DateTime end);
}
internal class log4net.Layout.Pattern.StackTraceDetailPatternConverter : StackTracePatternConverter {
    private static Type declaringType;
    private static StackTraceDetailPatternConverter();
    internal virtual string GetMethodInformation(MethodItem method);
}
internal class log4net.Layout.Pattern.StackTracePatternConverter : PatternLayoutConverter {
    private int m_stackFrameLevel;
    private static Type declaringType;
    private static StackTracePatternConverter();
    public sealed virtual void ActivateOptions();
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
    internal virtual string GetMethodInformation(MethodItem method);
}
internal class log4net.Layout.Pattern.ThreadPatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.TypeNamePatternConverter : NamedPatternConverter {
    protected virtual string GetFullyQualifiedName(LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.UserNamePatternConverter : PatternLayoutConverter {
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
internal class log4net.Layout.Pattern.UtcDatePatternConverter : DatePatternConverter {
    private static Type declaringType;
    private static UtcDatePatternConverter();
    protected virtual void Convert(TextWriter writer, LoggingEvent loggingEvent);
}
public class log4net.Layout.PatternLayout : LayoutSkeleton {
    public static string DefaultConversionPattern;
    public static string DetailConversionPattern;
    private static Hashtable s_globalRulesRegistry;
    private string m_pattern;
    private PatternConverter m_head;
    private Hashtable m_instanceRulesRegistry;
    public string ConversionPattern { get; public set; }
    private static PatternLayout();
    public PatternLayout(string pattern);
    public string get_ConversionPattern();
    public void set_ConversionPattern(string value);
    protected virtual PatternParser CreatePatternParser(string pattern);
    public virtual void ActivateOptions();
    public virtual void Format(TextWriter writer, LoggingEvent loggingEvent);
    public void AddConverter(ConverterInfo converterInfo);
    public void AddConverter(string name, Type type);
}
public class log4net.Layout.RawLayoutConverter : object {
    public sealed virtual bool CanConvertFrom(Type sourceType);
    public sealed virtual object ConvertFrom(object source);
}
public class log4net.Layout.RawPropertyLayout : object {
    private string m_key;
    public string Key { get; public set; }
    public string get_Key();
    public void set_Key(string value);
    public virtual object Format(LoggingEvent loggingEvent);
}
public class log4net.Layout.RawTimeStampLayout : object {
    public virtual object Format(LoggingEvent loggingEvent);
}
public class log4net.Layout.RawUtcTimeStampLayout : object {
    public virtual object Format(LoggingEvent loggingEvent);
}
public class log4net.Layout.SimpleLayout : LayoutSkeleton {
    public virtual void ActivateOptions();
    public virtual void Format(TextWriter writer, LoggingEvent loggingEvent);
}
public class log4net.Layout.XmlLayout : XmlLayoutBase {
    private string m_prefix;
    private string m_elmEvent;
    private string m_elmMessage;
    private string m_elmData;
    private string m_elmProperties;
    private string m_elmException;
    private string m_elmLocation;
    private bool m_base64Message;
    private bool m_base64Properties;
    private static string PREFIX;
    private static string ELM_EVENT;
    private static string ELM_MESSAGE;
    private static string ELM_PROPERTIES;
    private static string ELM_GLOBAL_PROPERTIES;
    private static string ELM_DATA;
    private static string ELM_EXCEPTION;
    private static string ELM_LOCATION;
    private static string ATTR_LOGGER;
    private static string ATTR_TIMESTAMP;
    private static string ATTR_LEVEL;
    private static string ATTR_THREAD;
    private static string ATTR_DOMAIN;
    private static string ATTR_IDENTITY;
    private static string ATTR_USERNAME;
    private static string ATTR_CLASS;
    private static string ATTR_METHOD;
    private static string ATTR_FILE;
    private static string ATTR_LINE;
    private static string ATTR_NAME;
    private static string ATTR_VALUE;
    public string Prefix { get; public set; }
    public bool Base64EncodeMessage { get; public set; }
    public bool Base64EncodeProperties { get; public set; }
    public XmlLayout(bool locationInfo);
    public string get_Prefix();
    public void set_Prefix(string value);
    public bool get_Base64EncodeMessage();
    public void set_Base64EncodeMessage(bool value);
    public bool get_Base64EncodeProperties();
    public void set_Base64EncodeProperties(bool value);
    public virtual void ActivateOptions();
    protected virtual void FormatXml(XmlWriter writer, LoggingEvent loggingEvent);
}
public abstract class log4net.Layout.XmlLayoutBase : LayoutSkeleton {
    private bool m_locationInfo;
    private string m_invalidCharReplacement;
    public bool LocationInfo { get; public set; }
    public string InvalidCharReplacement { get; public set; }
    public string ContentType { get; }
    protected XmlLayoutBase(bool locationInfo);
    public bool get_LocationInfo();
    public void set_LocationInfo(bool value);
    public string get_InvalidCharReplacement();
    public void set_InvalidCharReplacement(string value);
    public virtual void ActivateOptions();
    public virtual string get_ContentType();
    public virtual void Format(TextWriter writer, LoggingEvent loggingEvent);
    protected abstract virtual void FormatXml(XmlWriter writer, LoggingEvent loggingEvent);
}
public class log4net.Layout.XmlLayoutSchemaLog4j : XmlLayoutBase {
    private static DateTime s_date1970;
    public string Version { get; public set; }
    public XmlLayoutSchemaLog4j(bool locationInfo);
    private static XmlLayoutSchemaLog4j();
    public string get_Version();
    public void set_Version(string value);
    protected virtual void FormatXml(XmlWriter writer, LoggingEvent loggingEvent);
}
public class log4net.LogicalThreadContext : object {
    private static LogicalThreadContextProperties s_properties;
    private static LogicalThreadContextStacks s_stacks;
    public static LogicalThreadContextProperties Properties { get; }
    public static LogicalThreadContextStacks Stacks { get; }
    private static LogicalThreadContext();
    public static LogicalThreadContextProperties get_Properties();
    public static LogicalThreadContextStacks get_Stacks();
}
public class log4net.LogManager : object {
    private static WrapperMap s_wrapperMap;
    private static LogManager();
    public static ILog Exists(string name);
    public static ILog[] GetCurrentLoggers();
    public static ILog GetLogger(string name);
    public static ILog Exists(string repository, string name);
    public static ILog Exists(Assembly repositoryAssembly, string name);
    public static ILog[] GetCurrentLoggers(string repository);
    public static ILog[] GetCurrentLoggers(Assembly repositoryAssembly);
    public static ILog GetLogger(string repository, string name);
    public static ILog GetLogger(Assembly repositoryAssembly, string name);
    public static ILog GetLogger(Type type);
    public static ILog GetLogger(string repository, Type type);
    public static ILog GetLogger(Assembly repositoryAssembly, Type type);
    public static void Shutdown();
    public static void ShutdownRepository();
    public static void ShutdownRepository(string repository);
    public static void ShutdownRepository(Assembly repositoryAssembly);
    public static void ResetConfiguration();
    public static void ResetConfiguration(string repository);
    public static void ResetConfiguration(Assembly repositoryAssembly);
    [ObsoleteAttribute("Use GetRepository instead of GetLoggerRepository")]
public static ILoggerRepository GetLoggerRepository();
    [ObsoleteAttribute("Use GetRepository instead of GetLoggerRepository")]
public static ILoggerRepository GetLoggerRepository(string repository);
    [ObsoleteAttribute("Use GetRepository instead of GetLoggerRepository")]
public static ILoggerRepository GetLoggerRepository(Assembly repositoryAssembly);
    public static ILoggerRepository GetRepository();
    public static ILoggerRepository GetRepository(string repository);
    public static ILoggerRepository GetRepository(Assembly repositoryAssembly);
    [ObsoleteAttribute("Use CreateRepository instead of CreateDomain")]
public static ILoggerRepository CreateDomain(Type repositoryType);
    public static ILoggerRepository CreateRepository(Type repositoryType);
    [ObsoleteAttribute("Use CreateRepository instead of CreateDomain")]
public static ILoggerRepository CreateDomain(string repository);
    public static ILoggerRepository CreateRepository(string repository);
    [ObsoleteAttribute("Use CreateRepository instead of CreateDomain")]
public static ILoggerRepository CreateDomain(string repository, Type repositoryType);
    public static ILoggerRepository CreateRepository(string repository, Type repositoryType);
    [ObsoleteAttribute("Use CreateRepository instead of CreateDomain")]
public static ILoggerRepository CreateDomain(Assembly repositoryAssembly, Type repositoryType);
    public static ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType);
    public static ILoggerRepository[] GetAllRepositories();
    public static bool Flush(int millisecondsTimeout);
    private static ILog WrapLogger(ILogger logger);
    private static ILog[] WrapLoggers(ILogger[] loggers);
    private static ILoggerWrapper WrapperCreationHandler(ILogger logger);
}
public class log4net.MDC : object {
    public static string Get(string key);
    public static void Set(string key, string value);
    public static void Remove(string key);
    public static void Clear();
}
public class log4net.NDC : object {
    public static int Depth { get; }
    public static int get_Depth();
    public static void Clear();
    public static Stack CloneStack();
    public static void Inherit(Stack stack);
    public static string Pop();
    public static IDisposable Push(string message);
    public static IDisposable PushFormat(string messageFormat, Object[] args);
    public static void Remove();
    public static void SetMaxDepth(int maxDepth);
}
public class log4net.ObjectRenderer.DefaultRenderer : object {
    public sealed virtual void RenderObject(RendererMap rendererMap, object obj, TextWriter writer);
    private void RenderArray(RendererMap rendererMap, Array array, TextWriter writer);
    private void RenderEnumerator(RendererMap rendererMap, IEnumerator enumerator, TextWriter writer);
    private void RenderDictionaryEntry(RendererMap rendererMap, DictionaryEntry entry, TextWriter writer);
}
public interface log4net.ObjectRenderer.IObjectRenderer {
    public abstract virtual void RenderObject(RendererMap rendererMap, object obj, TextWriter writer);
}
public class log4net.ObjectRenderer.RendererMap : object {
    private static Type declaringType;
    private Hashtable m_map;
    private Hashtable m_cache;
    private static IObjectRenderer s_defaultRenderer;
    public IObjectRenderer DefaultRenderer { get; }
    private static RendererMap();
    public string FindAndRender(object obj);
    public void FindAndRender(object obj, TextWriter writer);
    public IObjectRenderer Get(object obj);
    public IObjectRenderer Get(Type type);
    private IObjectRenderer SearchTypeAndInterfaces(Type type);
    public IObjectRenderer get_DefaultRenderer();
    public void Clear();
    public void Put(Type typeToRender, IObjectRenderer renderer);
}
public interface log4net.Plugin.IPlugin {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void Attach(ILoggerRepository repository);
    public abstract virtual void Shutdown();
}
public interface log4net.Plugin.IPluginFactory {
    public abstract virtual IPlugin CreatePlugin();
}
[DefaultMemberAttribute("Item")]
public class log4net.Plugin.PluginCollection : object {
    private static int DEFAULT_CAPACITY;
    private IPlugin[] m_array;
    private int m_count;
    private int m_version;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public IPlugin Item { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public int Capacity { get; public set; }
    private object System.Collections.IList.Item { get; private set; }
    public PluginCollection(int capacity);
    public PluginCollection(PluginCollection c);
    public PluginCollection(IPlugin[] a);
    public PluginCollection(ICollection col);
    protected internal PluginCollection(Tag tag);
    public static PluginCollection ReadOnly(PluginCollection list);
    public virtual int get_Count();
    public virtual void CopyTo(IPlugin[] array);
    public virtual void CopyTo(IPlugin[] array, int start);
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual IPlugin get_Item(int index);
    public virtual void set_Item(int index, IPlugin value);
    public virtual int Add(IPlugin item);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(IPlugin item);
    public virtual int IndexOf(IPlugin item);
    public virtual void Insert(int index, IPlugin item);
    public virtual void Remove(IPlugin item);
    public virtual void RemoveAt(int index);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual IPluginCollectionEnumerator GetEnumerator();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int AddRange(PluginCollection x);
    public virtual int AddRange(IPlugin[] x);
    public virtual int AddRange(ICollection col);
    public virtual void TrimToSize();
    private void ValidateIndex(int i);
    private void ValidateIndex(int i, bool allowEqualEnd);
    private void EnsureCapacity(int min);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int start);
    private sealed virtual override object System.Collections.IList.get_Item(int i);
    private sealed virtual override void System.Collections.IList.set_Item(int i, object value);
    private sealed virtual override int System.Collections.IList.Add(object x);
    private sealed virtual override bool System.Collections.IList.Contains(object x);
    private sealed virtual override int System.Collections.IList.IndexOf(object x);
    private sealed virtual override void System.Collections.IList.Insert(int pos, object x);
    private sealed virtual override void System.Collections.IList.Remove(object x);
    private sealed virtual override void System.Collections.IList.RemoveAt(int pos);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class log4net.Plugin.PluginMap : object {
    private Hashtable m_mapName2Plugin;
    private ILoggerRepository m_repository;
    public IPlugin Item { get; }
    public PluginCollection AllPlugins { get; }
    public PluginMap(ILoggerRepository repository);
    public IPlugin get_Item(string name);
    public PluginCollection get_AllPlugins();
    public void Add(IPlugin plugin);
    public void Remove(IPlugin plugin);
}
public abstract class log4net.Plugin.PluginSkeleton : object {
    private string m_name;
    private ILoggerRepository m_repository;
    public string Name { get; public set; }
    protected ILoggerRepository LoggerRepository { get; protected set; }
    protected PluginSkeleton(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual void Attach(ILoggerRepository repository);
    public virtual void Shutdown();
    protected virtual ILoggerRepository get_LoggerRepository();
    protected virtual void set_LoggerRepository(ILoggerRepository value);
}
public class log4net.Plugin.RemoteLoggingServerPlugin : PluginSkeleton {
    private RemoteLoggingSinkImpl m_sink;
    private string m_sinkUri;
    private static Type declaringType;
    public string SinkUri { get; public set; }
    public RemoteLoggingServerPlugin(string sinkUri);
    private static RemoteLoggingServerPlugin();
    public virtual string get_SinkUri();
    public virtual void set_SinkUri(string value);
    [SecuritySafeCriticalAttribute]
public virtual void Attach(ILoggerRepository repository);
    [SecuritySafeCriticalAttribute]
public virtual void Shutdown();
}
public class log4net.Repository.ConfigurationChangedEventArgs : EventArgs {
    private ICollection configurationMessages;
    public ICollection ConfigurationMessages { get; }
    public ConfigurationChangedEventArgs(ICollection configurationMessages);
    public ICollection get_ConfigurationMessages();
}
internal class log4net.Repository.Hierarchy.DefaultLoggerFactory : object {
    public sealed virtual Logger CreateLogger(ILoggerRepository repository, string name);
}
public class log4net.Repository.Hierarchy.Hierarchy : LoggerRepositorySkeleton {
    private ILoggerFactory m_defaultFactory;
    private Hashtable m_ht;
    private Logger m_root;
    private bool m_emittedNoAppenderWarning;
    [CompilerGeneratedAttribute]
private LoggerCreationEventHandler m_loggerCreatedEvent;
    private static Type declaringType;
    public bool EmittedNoAppenderWarning { get; public set; }
    public Logger Root { get; }
    public ILoggerFactory LoggerFactory { get; public set; }
    public Hierarchy(PropertiesDictionary properties);
    public Hierarchy(ILoggerFactory loggerFactory);
    public Hierarchy(PropertiesDictionary properties, ILoggerFactory loggerFactory);
    private static Hierarchy();
    public void add_LoggerCreatedEvent(LoggerCreationEventHandler value);
    public void remove_LoggerCreatedEvent(LoggerCreationEventHandler value);
    public bool get_EmittedNoAppenderWarning();
    public void set_EmittedNoAppenderWarning(bool value);
    public Logger get_Root();
    public ILoggerFactory get_LoggerFactory();
    public void set_LoggerFactory(ILoggerFactory value);
    public virtual ILogger Exists(string name);
    public virtual ILogger[] GetCurrentLoggers();
    public virtual ILogger GetLogger(string name);
    public virtual void Shutdown();
    public virtual void ResetConfiguration();
    public virtual void Log(LoggingEvent logEvent);
    public virtual IAppender[] GetAppenders();
    private static void CollectAppender(ArrayList appenderList, IAppender appender);
    private static void CollectAppenders(ArrayList appenderList, IAppenderAttachable container);
    private sealed virtual override void log4net.Repository.IBasicRepositoryConfigurator.Configure(IAppender appender);
    private sealed virtual override void log4net.Repository.IBasicRepositoryConfigurator.Configure(IAppender[] appenders);
    protected void BasicRepositoryConfigure(IAppender[] appenders);
    private sealed virtual override void log4net.Repository.IXmlRepositoryConfigurator.Configure(XmlElement element);
    protected void XmlRepositoryConfigure(XmlElement element);
    public bool IsDisabled(Level level);
    public void Clear();
    public Logger GetLogger(string name, ILoggerFactory factory);
    protected virtual void OnLoggerCreationEvent(Logger logger);
    private void UpdateParents(Logger log);
    private static void UpdateChildren(ProvisionNode pn, Logger log);
    internal void AddLevel(LevelEntry levelEntry);
    internal void AddProperty(PropertyEntry propertyEntry);
    [CompilerGeneratedAttribute]
private void add_m_loggerCreatedEvent(LoggerCreationEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_m_loggerCreatedEvent(LoggerCreationEventHandler value);
}
public interface log4net.Repository.Hierarchy.ILoggerFactory {
    public abstract virtual Logger CreateLogger(ILoggerRepository repository, string name);
}
public abstract class log4net.Repository.Hierarchy.Logger : object {
    private static Type declaringType;
    private string m_name;
    private Level m_level;
    private Logger m_parent;
    private Hierarchy m_hierarchy;
    private AppenderAttachedImpl m_appenderAttachedImpl;
    private bool m_additive;
    private ReaderWriterLock m_appenderLock;
    public Logger Parent { get; public set; }
    public bool Additivity { get; public set; }
    public Level EffectiveLevel { get; }
    public Hierarchy Hierarchy { get; public set; }
    public Level Level { get; public set; }
    public AppenderCollection Appenders { get; }
    public string Name { get; }
    public ILoggerRepository Repository { get; }
    protected Logger(string name);
    private static Logger();
    public virtual Logger get_Parent();
    public virtual void set_Parent(Logger value);
    public virtual bool get_Additivity();
    public virtual void set_Additivity(bool value);
    public virtual Level get_EffectiveLevel();
    public virtual Hierarchy get_Hierarchy();
    public virtual void set_Hierarchy(Hierarchy value);
    public virtual Level get_Level();
    public virtual void set_Level(Level value);
    public virtual void AddAppender(IAppender newAppender);
    public virtual AppenderCollection get_Appenders();
    public virtual IAppender GetAppender(string name);
    public virtual void RemoveAllAppenders();
    public virtual IAppender RemoveAppender(IAppender appender);
    public virtual IAppender RemoveAppender(string name);
    public virtual string get_Name();
    public virtual void Log(Type callerStackBoundaryDeclaringType, Level level, object message, Exception exception);
    public virtual void Log(LoggingEvent logEvent);
    public virtual bool IsEnabledFor(Level level);
    public sealed virtual ILoggerRepository get_Repository();
    protected virtual void CallAppenders(LoggingEvent loggingEvent);
    public virtual void CloseNestedAppenders();
    public virtual void Log(Level level, object message, Exception exception);
    protected virtual void ForcedLog(Type callerStackBoundaryDeclaringType, Level level, object message, Exception exception);
    protected virtual void ForcedLog(LoggingEvent logEvent);
}
public class log4net.Repository.Hierarchy.LoggerCreationEventArgs : EventArgs {
    private Logger m_log;
    public Logger Logger { get; }
    public LoggerCreationEventArgs(Logger log);
    public Logger get_Logger();
}
public class log4net.Repository.Hierarchy.LoggerCreationEventHandler : MulticastDelegate {
    public LoggerCreationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LoggerCreationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, LoggerCreationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class log4net.Repository.Hierarchy.LoggerKey : object {
    private string m_name;
    private int m_hashCache;
    internal LoggerKey(string name);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class log4net.Repository.Hierarchy.ProvisionNode : ArrayList {
    internal ProvisionNode(Logger log);
}
public class log4net.Repository.Hierarchy.RootLogger : Logger {
    private static Type declaringType;
    public Level EffectiveLevel { get; }
    public Level Level { get; public set; }
    public RootLogger(Level level);
    private static RootLogger();
    public virtual Level get_EffectiveLevel();
    public virtual Level get_Level();
    public virtual void set_Level(Level value);
}
public class log4net.Repository.Hierarchy.XmlHierarchyConfigurator : object {
    private static string CONFIGURATION_TAG;
    private static string RENDERER_TAG;
    private static string APPENDER_TAG;
    private static string APPENDER_REF_TAG;
    private static string PARAM_TAG;
    private static string CATEGORY_TAG;
    private static string PRIORITY_TAG;
    private static string LOGGER_TAG;
    private static string NAME_ATTR;
    private static string TYPE_ATTR;
    private static string VALUE_ATTR;
    private static string ROOT_TAG;
    private static string LEVEL_TAG;
    private static string REF_ATTR;
    private static string ADDITIVITY_ATTR;
    private static string THRESHOLD_ATTR;
    private static string CONFIG_DEBUG_ATTR;
    private static string INTERNAL_DEBUG_ATTR;
    private static string EMIT_INTERNAL_DEBUG_ATTR;
    private static string CONFIG_UPDATE_MODE_ATTR;
    private static string RENDERING_TYPE_ATTR;
    private static string RENDERED_TYPE_ATTR;
    private static string INHERITED;
    private Hashtable m_appenderBag;
    private Hierarchy m_hierarchy;
    private static Type declaringType;
    private bool HasCaseInsensitiveEnvironment { get; }
    public XmlHierarchyConfigurator(Hierarchy hierarchy);
    private static XmlHierarchyConfigurator();
    public void Configure(XmlElement element);
    protected IAppender FindAppenderByReference(XmlElement appenderRef);
    protected IAppender ParseAppender(XmlElement appenderElement);
    protected void ParseLogger(XmlElement loggerElement);
    protected void ParseRoot(XmlElement rootElement);
    protected void ParseChildrenOfLoggerElement(XmlElement catElement, Logger log, bool isRoot);
    protected void ParseRenderer(XmlElement element);
    protected void ParseLevel(XmlElement element, Logger log, bool isRoot);
    protected void SetParameter(XmlElement element, object target);
    private bool HasAttributesOrElements(XmlElement element);
    private static bool IsTypeConstructible(Type type);
    private MethodInfo FindMethodInfo(Type targetType, string name);
    protected object ConvertStringTo(Type type, string value);
    protected object CreateObjectFromXml(XmlElement element, Type defaultTargetType, Type typeConstraint);
    private bool get_HasCaseInsensitiveEnvironment();
    private IDictionary CreateCaseInsensitiveWrapper(IDictionary dict);
}
public interface log4net.Repository.IBasicRepositoryConfigurator {
    public abstract virtual void Configure(IAppender appender);
    public abstract virtual void Configure(IAppender[] appenders);
}
public interface log4net.Repository.ILoggerRepository {
    public string Name { get; public set; }
    public RendererMap RendererMap { get; }
    public PluginMap PluginMap { get; }
    public LevelMap LevelMap { get; }
    public Level Threshold { get; public set; }
    public bool Configured { get; public set; }
    public ICollection ConfigurationMessages { get; public set; }
    public PropertiesDictionary Properties { get; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual RendererMap get_RendererMap();
    public abstract virtual PluginMap get_PluginMap();
    public abstract virtual LevelMap get_LevelMap();
    public abstract virtual Level get_Threshold();
    public abstract virtual void set_Threshold(Level value);
    public abstract virtual ILogger Exists(string name);
    public abstract virtual ILogger[] GetCurrentLoggers();
    public abstract virtual ILogger GetLogger(string name);
    public abstract virtual void Shutdown();
    public abstract virtual void ResetConfiguration();
    public abstract virtual void Log(LoggingEvent logEvent);
    public abstract virtual bool get_Configured();
    public abstract virtual void set_Configured(bool value);
    public abstract virtual ICollection get_ConfigurationMessages();
    public abstract virtual void set_ConfigurationMessages(ICollection value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ShutdownEvent(LoggerRepositoryShutdownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ShutdownEvent(LoggerRepositoryShutdownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConfigurationReset(LoggerRepositoryConfigurationResetEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConfigurationReset(LoggerRepositoryConfigurationResetEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConfigurationChanged(LoggerRepositoryConfigurationChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConfigurationChanged(LoggerRepositoryConfigurationChangedEventHandler value);
    public abstract virtual PropertiesDictionary get_Properties();
    public abstract virtual IAppender[] GetAppenders();
}
public interface log4net.Repository.IXmlRepositoryConfigurator {
    public abstract virtual void Configure(XmlElement element);
}
public class log4net.Repository.LoggerRepositoryConfigurationChangedEventHandler : MulticastDelegate {
    public LoggerRepositoryConfigurationChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class log4net.Repository.LoggerRepositoryConfigurationResetEventHandler : MulticastDelegate {
    public LoggerRepositoryConfigurationResetEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class log4net.Repository.LoggerRepositoryShutdownEventHandler : MulticastDelegate {
    public LoggerRepositoryShutdownEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class log4net.Repository.LoggerRepositorySkeleton : object {
    private string m_name;
    private RendererMap m_rendererMap;
    private PluginMap m_pluginMap;
    private LevelMap m_levelMap;
    private Level m_threshold;
    private bool m_configured;
    private ICollection m_configurationMessages;
    [CompilerGeneratedAttribute]
private LoggerRepositoryShutdownEventHandler m_shutdownEvent;
    [CompilerGeneratedAttribute]
private LoggerRepositoryConfigurationResetEventHandler m_configurationResetEvent;
    [CompilerGeneratedAttribute]
private LoggerRepositoryConfigurationChangedEventHandler m_configurationChangedEvent;
    private PropertiesDictionary m_properties;
    private static Type declaringType;
    public string Name { get; public set; }
    public Level Threshold { get; public set; }
    public RendererMap RendererMap { get; }
    public PluginMap PluginMap { get; }
    public LevelMap LevelMap { get; }
    public bool Configured { get; public set; }
    public ICollection ConfigurationMessages { get; public set; }
    public PropertiesDictionary Properties { get; }
    protected LoggerRepositorySkeleton(PropertiesDictionary properties);
    private static LoggerRepositorySkeleton();
    [CompilerGeneratedAttribute]
private void add_m_shutdownEvent(LoggerRepositoryShutdownEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_m_shutdownEvent(LoggerRepositoryShutdownEventHandler value);
    [CompilerGeneratedAttribute]
private void add_m_configurationResetEvent(LoggerRepositoryConfigurationResetEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_m_configurationResetEvent(LoggerRepositoryConfigurationResetEventHandler value);
    [CompilerGeneratedAttribute]
private void add_m_configurationChangedEvent(LoggerRepositoryConfigurationChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_m_configurationChangedEvent(LoggerRepositoryConfigurationChangedEventHandler value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual Level get_Threshold();
    public virtual void set_Threshold(Level value);
    public virtual RendererMap get_RendererMap();
    public virtual PluginMap get_PluginMap();
    public virtual LevelMap get_LevelMap();
    public abstract virtual ILogger Exists(string name);
    public abstract virtual ILogger[] GetCurrentLoggers();
    public abstract virtual ILogger GetLogger(string name);
    public virtual void Shutdown();
    public virtual void ResetConfiguration();
    public abstract virtual void Log(LoggingEvent logEvent);
    public virtual bool get_Configured();
    public virtual void set_Configured(bool value);
    public virtual ICollection get_ConfigurationMessages();
    public virtual void set_ConfigurationMessages(ICollection value);
    public sealed virtual void add_ShutdownEvent(LoggerRepositoryShutdownEventHandler value);
    public sealed virtual void remove_ShutdownEvent(LoggerRepositoryShutdownEventHandler value);
    public sealed virtual void add_ConfigurationReset(LoggerRepositoryConfigurationResetEventHandler value);
    public sealed virtual void remove_ConfigurationReset(LoggerRepositoryConfigurationResetEventHandler value);
    public sealed virtual void add_ConfigurationChanged(LoggerRepositoryConfigurationChangedEventHandler value);
    public sealed virtual void remove_ConfigurationChanged(LoggerRepositoryConfigurationChangedEventHandler value);
    public sealed virtual PropertiesDictionary get_Properties();
    public abstract virtual IAppender[] GetAppenders();
    private void AddBuiltinLevels();
    public virtual void AddRenderer(Type typeToRender, IObjectRenderer rendererInstance);
    protected virtual void OnShutdown(EventArgs e);
    protected virtual void OnConfigurationReset(EventArgs e);
    protected virtual void OnConfigurationChanged(EventArgs e);
    public void RaiseConfigurationChanged(EventArgs e);
    private static int GetWaitTime(DateTime startTimeUtc, int millisecondsTimeout);
    public sealed virtual bool Flush(int millisecondsTimeout);
}
public class log4net.ThreadContext : object {
    private static ThreadContextProperties s_properties;
    private static ThreadContextStacks s_stacks;
    public static ThreadContextProperties Properties { get; }
    public static ThreadContextStacks Stacks { get; }
    private static ThreadContext();
    public static ThreadContextProperties get_Properties();
    public static ThreadContextStacks get_Stacks();
}
public class log4net.Util.AppenderAttachedImpl : object {
    private AppenderCollection m_appenderList;
    private IAppender[] m_appenderArray;
    private static Type declaringType;
    public AppenderCollection Appenders { get; }
    private static AppenderAttachedImpl();
    public int AppendLoopOnAppenders(LoggingEvent loggingEvent);
    public int AppendLoopOnAppenders(LoggingEvent[] loggingEvents);
    private static void CallAppend(IAppender appender, LoggingEvent[] loggingEvents);
    public sealed virtual void AddAppender(IAppender newAppender);
    public sealed virtual AppenderCollection get_Appenders();
    public sealed virtual IAppender GetAppender(string name);
    public sealed virtual void RemoveAllAppenders();
    public sealed virtual IAppender RemoveAppender(IAppender appender);
    public sealed virtual IAppender RemoveAppender(string name);
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.CompositeProperties : object {
    private PropertiesDictionary m_flattened;
    private ArrayList m_nestedProperties;
    public object Item { get; }
    public object get_Item(string key);
    public void Add(ReadOnlyPropertiesDictionary properties);
    public PropertiesDictionary Flatten();
}
[DefaultMemberAttribute("Item")]
public abstract class log4net.Util.ContextPropertiesBase : object {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string key);
    public abstract virtual void set_Item(string key, object value);
}
public class log4net.Util.ConverterInfo : object {
    private string m_name;
    private Type m_type;
    private PropertiesDictionary properties;
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public PropertiesDictionary Properties { get; }
    public string get_Name();
    public void set_Name(string value);
    public Type get_Type();
    public void set_Type(Type value);
    public void AddProperty(PropertyEntry entry);
    public PropertiesDictionary get_Properties();
}
public class log4net.Util.CountingQuietTextWriter : QuietTextWriter {
    private long m_countBytes;
    public long Count { get; public set; }
    public CountingQuietTextWriter(TextWriter writer, IErrorHandler errorHandler);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string str);
    public long get_Count();
    public void set_Count(long value);
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.CyclicBuffer : object {
    private LoggingEvent[] m_events;
    private int m_first;
    private int m_last;
    private int m_numElems;
    private int m_maxSize;
    public LoggingEvent Item { get; }
    public int MaxSize { get; }
    public int Length { get; }
    public CyclicBuffer(int maxSize);
    public LoggingEvent Append(LoggingEvent loggingEvent);
    public LoggingEvent PopOldest();
    public LoggingEvent[] PopAll();
    public void Clear();
    public LoggingEvent get_Item(int i);
    public int get_MaxSize();
    public int get_Length();
}
public class log4net.Util.EmptyCollection : object {
    private static EmptyCollection s_instance;
    public static EmptyCollection Instance { get; }
    public bool IsSynchronized { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    private static EmptyCollection();
    public static EmptyCollection get_Instance();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.EmptyDictionary : object {
    private static EmptyDictionary s_instance;
    public static EmptyDictionary Instance { get; }
    public bool IsSynchronized { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    private static EmptyDictionary();
    public static EmptyDictionary get_Instance();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
}
public class log4net.Util.FormattingInfo : object {
    private int m_min;
    private int m_max;
    private bool m_leftAlign;
    public int Min { get; public set; }
    public int Max { get; public set; }
    public bool LeftAlign { get; public set; }
    public FormattingInfo(int min, int max, bool leftAlign);
    public int get_Min();
    public void set_Min(int value);
    public int get_Max();
    public void set_Max(int value);
    public bool get_LeftAlign();
    public void set_LeftAlign(bool value);
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.GlobalContextProperties : ContextPropertiesBase {
    private ReadOnlyPropertiesDictionary modreq(System.Runtime.CompilerServices.IsVolatile) m_readOnlyProperties;
    private object m_syncRoot;
    public object Item { get; public set; }
    public virtual object get_Item(string key);
    public virtual void set_Item(string key, object value);
    public void Remove(string key);
    public void Clear();
    internal ReadOnlyPropertiesDictionary GetReadOnlyProperties();
}
[ExtensionAttribute]
public static class log4net.Util.ILogExtensions : object {
    private static Type declaringType;
    private static ILogExtensions();
    [ExtensionAttribute]
public static void DebugExt(ILog logger, Func`1<object> callback);
    [ExtensionAttribute]
public static void DebugExt(ILog logger, Func`1<object> callback, Exception exception);
    [ExtensionAttribute]
public static void DebugExt(ILog logger, object message);
    [ExtensionAttribute]
public static void DebugExt(ILog logger, object message, Exception exception);
    [ExtensionAttribute]
public static void DebugFormatExt(ILog logger, string format, object arg0);
    [ExtensionAttribute]
public static void DebugFormatExt(ILog logger, string format, Object[] args);
    [ExtensionAttribute]
public static void DebugFormatExt(ILog logger, IFormatProvider provider, string format, Object[] args);
    [ExtensionAttribute]
public static void DebugFormatExt(ILog logger, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void DebugFormatExt(ILog logger, string format, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static void InfoExt(ILog logger, Func`1<object> callback);
    [ExtensionAttribute]
public static void InfoExt(ILog logger, Func`1<object> callback, Exception exception);
    [ExtensionAttribute]
public static void InfoExt(ILog logger, object message);
    [ExtensionAttribute]
public static void InfoExt(ILog logger, object message, Exception exception);
    [ExtensionAttribute]
public static void InfoFormatExt(ILog logger, string format, object arg0);
    [ExtensionAttribute]
public static void InfoFormatExt(ILog logger, string format, Object[] args);
    [ExtensionAttribute]
public static void InfoFormatExt(ILog logger, IFormatProvider provider, string format, Object[] args);
    [ExtensionAttribute]
public static void InfoFormatExt(ILog logger, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void InfoFormatExt(ILog logger, string format, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static void WarnExt(ILog logger, Func`1<object> callback);
    [ExtensionAttribute]
public static void WarnExt(ILog logger, Func`1<object> callback, Exception exception);
    [ExtensionAttribute]
public static void WarnExt(ILog logger, object message);
    [ExtensionAttribute]
public static void WarnExt(ILog logger, object message, Exception exception);
    [ExtensionAttribute]
public static void WarnFormatExt(ILog logger, string format, object arg0);
    [ExtensionAttribute]
public static void WarnFormatExt(ILog logger, string format, Object[] args);
    [ExtensionAttribute]
public static void WarnFormatExt(ILog logger, IFormatProvider provider, string format, Object[] args);
    [ExtensionAttribute]
public static void WarnFormatExt(ILog logger, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void WarnFormatExt(ILog logger, string format, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static void ErrorExt(ILog logger, Func`1<object> callback);
    [ExtensionAttribute]
public static void ErrorExt(ILog logger, Func`1<object> callback, Exception exception);
    [ExtensionAttribute]
public static void ErrorExt(ILog logger, object message);
    [ExtensionAttribute]
public static void ErrorExt(ILog logger, object message, Exception exception);
    [ExtensionAttribute]
public static void ErrorFormatExt(ILog logger, string format, object arg0);
    [ExtensionAttribute]
public static void ErrorFormatExt(ILog logger, string format, Object[] args);
    [ExtensionAttribute]
public static void ErrorFormatExt(ILog logger, IFormatProvider provider, string format, Object[] args);
    [ExtensionAttribute]
public static void ErrorFormatExt(ILog logger, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void ErrorFormatExt(ILog logger, string format, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static void FatalExt(ILog logger, Func`1<object> callback);
    [ExtensionAttribute]
public static void FatalExt(ILog logger, Func`1<object> callback, Exception exception);
    [ExtensionAttribute]
public static void FatalExt(ILog logger, object message);
    [ExtensionAttribute]
public static void FatalExt(ILog logger, object message, Exception exception);
    [ExtensionAttribute]
public static void FatalFormatExt(ILog logger, string format, object arg0);
    [ExtensionAttribute]
public static void FatalFormatExt(ILog logger, string format, Object[] args);
    [ExtensionAttribute]
public static void FatalFormatExt(ILog logger, IFormatProvider provider, string format, Object[] args);
    [ExtensionAttribute]
public static void FatalFormatExt(ILog logger, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void FatalFormatExt(ILog logger, string format, object arg0, object arg1, object arg2);
}
public class log4net.Util.LevelMapping : object {
    private Hashtable m_entriesMap;
    private LevelMappingEntry[] m_entries;
    public void Add(LevelMappingEntry entry);
    public LevelMappingEntry Lookup(Level level);
    public sealed virtual void ActivateOptions();
}
public abstract class log4net.Util.LevelMappingEntry : object {
    private Level m_level;
    public Level Level { get; public set; }
    public Level get_Level();
    public void set_Level(Level value);
    public virtual void ActivateOptions();
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.LogicalThreadContextProperties : ContextPropertiesBase {
    private static string c_SlotName;
    private bool m_disabled;
    private static Type declaringType;
    public object Item { get; public set; }
    private static LogicalThreadContextProperties();
    public virtual object get_Item(string key);
    public virtual void set_Item(string key, object value);
    public void Remove(string key);
    public void Clear();
    internal PropertiesDictionary GetProperties(bool create);
    [SecuritySafeCriticalAttribute]
private static PropertiesDictionary GetLogicalProperties();
    [SecuritySafeCriticalAttribute]
private static void SetLogicalProperties(PropertiesDictionary properties);
}
public class log4net.Util.LogicalThreadContextStack : object {
    private Stack m_stack;
    private string m_propertyKey;
    private TwoArgAction`2<string, LogicalThreadContextStack> m_registerNew;
    public int Count { get; }
    internal Stack InternalStack { get; internal set; }
    internal LogicalThreadContextStack(string propertyKey, TwoArgAction`2<string, LogicalThreadContextStack> registerNew);
    public int get_Count();
    public void Clear();
    public string Pop();
    public IDisposable Push(string message);
    internal string GetFullMessage();
    internal Stack get_InternalStack();
    internal void set_InternalStack(Stack value);
    public virtual string ToString();
    private sealed virtual override object log4net.Core.IFixingRequired.GetFixedObject();
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.LogicalThreadContextStacks : object {
    private LogicalThreadContextProperties m_properties;
    private static Type declaringType;
    public LogicalThreadContextStack Item { get; }
    internal LogicalThreadContextStacks(LogicalThreadContextProperties properties);
    private static LogicalThreadContextStacks();
    public LogicalThreadContextStack get_Item(string key);
    private void registerNew(string stackName, LogicalThreadContextStack stack);
}
public class log4net.Util.LogLog : object {
    [CompilerGeneratedAttribute]
private static LogReceivedEventHandler LogReceived;
    private Type source;
    private DateTime timeStampUtc;
    private string prefix;
    private string message;
    private Exception exception;
    private static bool s_debugEnabled;
    private static bool s_quietMode;
    private static bool s_emitInternalMessages;
    private static string PREFIX;
    private static string ERR_PREFIX;
    private static string WARN_PREFIX;
    public Type Source { get; }
    public DateTime TimeStamp { get; }
    public DateTime TimeStampUtc { get; }
    public string Prefix { get; }
    public string Message { get; }
    public Exception Exception { get; }
    public static bool InternalDebugging { get; public set; }
    public static bool QuietMode { get; public set; }
    public static bool EmitInternalMessages { get; public set; }
    public static bool IsDebugEnabled { get; }
    public static bool IsWarnEnabled { get; }
    public static bool IsErrorEnabled { get; }
    public LogLog(Type source, string prefix, string message, Exception exception);
    private static LogLog();
    [CompilerGeneratedAttribute]
public static void add_LogReceived(LogReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_LogReceived(LogReceivedEventHandler value);
    public Type get_Source();
    public DateTime get_TimeStamp();
    public DateTime get_TimeStampUtc();
    public string get_Prefix();
    public string get_Message();
    public Exception get_Exception();
    public virtual string ToString();
    public static bool get_InternalDebugging();
    public static void set_InternalDebugging(bool value);
    public static bool get_QuietMode();
    public static void set_QuietMode(bool value);
    public static bool get_EmitInternalMessages();
    public static void set_EmitInternalMessages(bool value);
    public static void OnLogReceived(Type source, string prefix, string message, Exception exception);
    public static bool get_IsDebugEnabled();
    public static void Debug(Type source, string message);
    public static void Debug(Type source, string message, Exception exception);
    public static bool get_IsWarnEnabled();
    public static void Warn(Type source, string message);
    public static void Warn(Type source, string message, Exception exception);
    public static bool get_IsErrorEnabled();
    public static void Error(Type source, string message);
    public static void Error(Type source, string message, Exception exception);
    private static void EmitOutLine(string message);
    private static void EmitErrorLine(string message);
}
public class log4net.Util.LogReceivedEventArgs : EventArgs {
    private LogLog loglog;
    public LogLog LogLog { get; }
    public LogReceivedEventArgs(LogLog loglog);
    public LogLog get_LogLog();
}
public class log4net.Util.LogReceivedEventHandler : MulticastDelegate {
    public LogReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object source, LogReceivedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object source, LogReceivedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class log4net.Util.NativeError : object {
    private int m_number;
    private string m_message;
    public int Number { get; }
    public string Message { get; }
    private NativeError(int number, string message);
    public int get_Number();
    public string get_Message();
    [SecuritySafeCriticalAttribute]
public static NativeError GetLastError();
    public static NativeError GetError(int number);
    [SecuritySafeCriticalAttribute]
public static string GetErrorMessage(int messageId);
    public virtual string ToString();
    private static int FormatMessage(int dwFlags, IntPtr& lpSource, int dwMessageId, int dwLanguageId, String& lpBuffer, int nSize, IntPtr Arguments);
}
public class log4net.Util.NullDictionaryEnumerator : object {
    private static NullDictionaryEnumerator s_instance;
    public static NullDictionaryEnumerator Instance { get; }
    public object Current { get; }
    public object Key { get; }
    public object Value { get; }
    public DictionaryEntry Entry { get; }
    private static NullDictionaryEnumerator();
    public static NullDictionaryEnumerator get_Instance();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
    public sealed virtual DictionaryEntry get_Entry();
}
public class log4net.Util.NullEnumerator : object {
    private static NullEnumerator s_instance;
    public static NullEnumerator Instance { get; }
    public object Current { get; }
    private static NullEnumerator();
    public static NullEnumerator get_Instance();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class log4net.Util.NullSecurityContext : SecurityContext {
    public static NullSecurityContext Instance;
    private static NullSecurityContext();
    public virtual IDisposable Impersonate(object state);
}
public class log4net.Util.OnlyOnceErrorHandler : object {
    private DateTime m_enabledDateUtc;
    private bool m_firstTime;
    private string m_message;
    private Exception m_exception;
    private ErrorCode m_errorCode;
    private string m_prefix;
    private static Type declaringType;
    public bool IsEnabled { get; }
    public DateTime EnabledDate { get; }
    public DateTime EnabledDateUtc { get; }
    public string ErrorMessage { get; }
    public Exception Exception { get; }
    public ErrorCode ErrorCode { get; }
    public OnlyOnceErrorHandler(string prefix);
    private static OnlyOnceErrorHandler();
    public void Reset();
    public sealed virtual void Error(string message, Exception e, ErrorCode errorCode);
    public virtual void FirstError(string message, Exception e, ErrorCode errorCode);
    public sealed virtual void Error(string message, Exception e);
    public sealed virtual void Error(string message);
    public bool get_IsEnabled();
    public DateTime get_EnabledDate();
    public DateTime get_EnabledDateUtc();
    public string get_ErrorMessage();
    public Exception get_Exception();
    public ErrorCode get_ErrorCode();
}
public class log4net.Util.OptionConverter : object {
    private static Type declaringType;
    private static string DELIM_START;
    private static char DELIM_STOP;
    private static int DELIM_START_LEN;
    private static int DELIM_STOP_LEN;
    private static OptionConverter();
    public static bool ToBoolean(string argValue, bool defaultValue);
    public static long ToFileSize(string argValue, long defaultValue);
    public static object ConvertStringTo(Type target, string txt);
    public static bool CanConvertTypeTo(Type sourceType, Type targetType);
    public static object ConvertTypeTo(object sourceInstance, Type targetType);
    public static object InstantiateByClassName(string className, Type superClass, object defaultValue);
    public static string SubstituteVariables(string value, IDictionary props);
    private static object ParseEnum(Type enumType, string value, bool ignoreCase);
}
public abstract class log4net.Util.PatternConverter : object {
    private static String[] SPACES;
    private PatternConverter m_next;
    private int m_min;
    private int m_max;
    private bool m_leftAlign;
    private string m_option;
    private ReusableStringWriter m_formatWriter;
    private static int c_renderBufferSize;
    private static int c_renderBufferMaxCapacity;
    private PropertiesDictionary properties;
    public PatternConverter Next { get; }
    public FormattingInfo FormattingInfo { get; public set; }
    public string Option { get; public set; }
    public PropertiesDictionary Properties { get; public set; }
    private static PatternConverter();
    public virtual PatternConverter get_Next();
    public virtual FormattingInfo get_FormattingInfo();
    public virtual void set_FormattingInfo(FormattingInfo value);
    public virtual string get_Option();
    public virtual void set_Option(string value);
    protected abstract virtual void Convert(TextWriter writer, object state);
    public virtual PatternConverter SetNext(PatternConverter patternConverter);
    public virtual void Format(TextWriter writer, object state);
    protected static void SpacePad(TextWriter writer, int length);
    protected static void WriteDictionary(TextWriter writer, ILoggerRepository repository, IDictionary value);
    protected static void WriteDictionary(TextWriter writer, ILoggerRepository repository, IDictionaryEnumerator value);
    protected static void WriteObject(TextWriter writer, ILoggerRepository repository, object value);
    public PropertiesDictionary get_Properties();
    public void set_Properties(PropertiesDictionary value);
}
public class log4net.Util.PatternParser : object {
    private static char ESCAPE_CHAR;
    private PatternConverter m_head;
    private PatternConverter m_tail;
    private string m_pattern;
    private Hashtable m_patternConverters;
    private static Type declaringType;
    public Hashtable PatternConverters { get; }
    public PatternParser(string pattern);
    private static PatternParser();
    public PatternConverter Parse();
    public Hashtable get_PatternConverters();
    private String[] BuildCache();
    private void ParseInternal(string pattern, String[] matches);
    private void ProcessLiteral(string text);
    private void ProcessConverter(string converterName, string option, FormattingInfo formattingInfo);
    private void AddConverter(PatternConverter pc);
}
public class log4net.Util.PatternString : object {
    private static Hashtable s_globalRulesRegistry;
    private string m_pattern;
    private PatternConverter m_head;
    private Hashtable m_instanceRulesRegistry;
    public string ConversionPattern { get; public set; }
    private static PatternString();
    public PatternString(string pattern);
    public string get_ConversionPattern();
    public void set_ConversionPattern(string value);
    public virtual void ActivateOptions();
    private PatternParser CreatePatternParser(string pattern);
    public void Format(TextWriter writer);
    public string Format();
    public void AddConverter(ConverterInfo converterInfo);
    public void AddConverter(string name, Type type);
}
internal class log4net.Util.PatternStringConverters.AppDomainPatternConverter : PatternConverter {
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.AppSettingPatternConverter : PatternConverter {
    private static Hashtable _appSettingsHashTable;
    private static IDictionary AppSettingsDictionary { get; }
    private static IDictionary get_AppSettingsDictionary();
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.DatePatternConverter : PatternConverter {
    protected IDateFormatter m_dateFormatter;
    private static Type declaringType;
    private static DatePatternConverter();
    public sealed virtual void ActivateOptions();
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.EnvironmentFolderPathPatternConverter : PatternConverter {
    private static Type declaringType;
    private static EnvironmentFolderPathPatternConverter();
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.EnvironmentPatternConverter : PatternConverter {
    private static Type declaringType;
    private static EnvironmentPatternConverter();
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.IdentityPatternConverter : PatternConverter {
    private static Type declaringType;
    private static IdentityPatternConverter();
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.LiteralPatternConverter : PatternConverter {
    public virtual PatternConverter SetNext(PatternConverter pc);
    public virtual void Format(TextWriter writer, object state);
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.NewLinePatternConverter : LiteralPatternConverter {
    public sealed virtual void ActivateOptions();
}
internal class log4net.Util.PatternStringConverters.ProcessIdPatternConverter : PatternConverter {
    private static Type declaringType;
    private static ProcessIdPatternConverter();
    [SecuritySafeCriticalAttribute]
protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.PropertyPatternConverter : PatternConverter {
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.RandomStringPatternConverter : PatternConverter {
    private static Random s_random;
    private int m_length;
    private static Type declaringType;
    private static RandomStringPatternConverter();
    public sealed virtual void ActivateOptions();
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.UserNamePatternConverter : PatternConverter {
    private static Type declaringType;
    private static UserNamePatternConverter();
    protected virtual void Convert(TextWriter writer, object state);
}
internal class log4net.Util.PatternStringConverters.UtcDatePatternConverter : DatePatternConverter {
    private static Type declaringType;
    private static UtcDatePatternConverter();
    protected virtual void Convert(TextWriter writer, object state);
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.PropertiesDictionary : ReadOnlyPropertiesDictionary {
    public object Item { get; public set; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public PropertiesDictionary(ReadOnlyPropertiesDictionary propertiesDictionary);
    private PropertiesDictionary(SerializationInfo info, StreamingContext context);
    public virtual object get_Item(string key);
    public virtual void set_Item(string key, object value);
    public void Remove(string key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    public virtual void Clear();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class log4net.Util.PropertyEntry : object {
    private string m_key;
    private object m_value;
    public string Key { get; public set; }
    public object Value { get; public set; }
    public string get_Key();
    public void set_Key(string value);
    public object get_Value();
    public void set_Value(object value);
    public virtual string ToString();
}
public class log4net.Util.ProtectCloseTextWriter : TextWriterAdapter {
    public ProtectCloseTextWriter(TextWriter writer);
    public void Attach(TextWriter writer);
    public virtual void Close();
}
public class log4net.Util.QuietTextWriter : TextWriterAdapter {
    private IErrorHandler m_errorHandler;
    private bool m_closed;
    public IErrorHandler ErrorHandler { get; public set; }
    public bool Closed { get; }
    public QuietTextWriter(TextWriter writer, IErrorHandler errorHandler);
    public IErrorHandler get_ErrorHandler();
    public void set_ErrorHandler(IErrorHandler value);
    public bool get_Closed();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual void Close();
}
public class log4net.Util.ReaderWriterLock : object {
    private ReaderWriterLockSlim m_lock;
    public void AcquireReaderLock();
    public void ReleaseReaderLock();
    public void AcquireWriterLock();
    public void ReleaseWriterLock();
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.ReadOnlyPropertiesDictionary : object {
    private Hashtable m_hashtable;
    public object Item { get; public set; }
    protected Hashtable InnerHashtable { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public int Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ReadOnlyPropertiesDictionary(ReadOnlyPropertiesDictionary propertiesDictionary);
    protected ReadOnlyPropertiesDictionary(SerializationInfo info, StreamingContext context);
    public String[] GetKeys();
    public virtual object get_Item(string key);
    public virtual void set_Item(string key, object value);
    public bool Contains(string key);
    protected Hashtable get_InnerHashtable();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    public virtual void Clear();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual int get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class log4net.Util.ReusableStringWriter : StringWriter {
    public ReusableStringWriter(IFormatProvider formatProvider);
    protected virtual void Dispose(bool disposing);
    public void Reset(int maxCapacity, int defaultSize);
}
public class log4net.Util.SystemInfo : object {
    private static string DEFAULT_NULL_TEXT;
    private static string DEFAULT_NOT_AVAILABLE_TEXT;
    public static Type[] EmptyTypes;
    private static Type declaringType;
    private static string s_hostName;
    private static string s_appFriendlyName;
    private static string s_nullText;
    private static string s_notAvailableText;
    private static DateTime s_processStartTimeUtc;
    public static string NewLine { get; }
    public static string ApplicationBaseDirectory { get; }
    public static string ConfigurationFileLocation { get; }
    public static string EntryAssemblyLocation { get; }
    public static int CurrentThreadId { get; }
    public static string HostName { get; }
    public static string ApplicationFriendlyName { get; }
    [ObsoleteAttribute("Use ProcessStartTimeUtc and convert to local time if needed.")]
public static DateTime ProcessStartTime { get; }
    public static DateTime ProcessStartTimeUtc { get; }
    public static string NullText { get; public set; }
    public static string NotAvailableText { get; public set; }
    private static SystemInfo();
    public static string get_NewLine();
    public static string get_ApplicationBaseDirectory();
    public static string get_ConfigurationFileLocation();
    public static string get_EntryAssemblyLocation();
    public static int get_CurrentThreadId();
    public static string get_HostName();
    public static string get_ApplicationFriendlyName();
    public static DateTime get_ProcessStartTime();
    public static DateTime get_ProcessStartTimeUtc();
    public static string get_NullText();
    public static void set_NullText(string value);
    public static string get_NotAvailableText();
    public static void set_NotAvailableText(string value);
    public static string AssemblyLocationInfo(Assembly myAssembly);
    public static string AssemblyQualifiedName(Type type);
    public static string AssemblyShortName(Assembly myAssembly);
    public static string AssemblyFileName(Assembly myAssembly);
    public static Type GetTypeFromString(Type relativeType, string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetTypeFromString(string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetTypeFromString(Assembly relativeAssembly, string typeName, bool throwOnError, bool ignoreCase);
    public static Guid NewGuid();
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string parameterName, object actualValue, string message);
    public static bool TryParse(string s, Int32& val);
    public static bool TryParse(string s, Int64& val);
    public static bool TryParse(string s, Int16& val);
    public static string GetAppSetting(string key);
    public static string ConvertToFullPath(string path);
    public static Hashtable CreateCaseInsensitiveHashtable();
    public static bool EqualsIgnoringCase(string a, string b);
}
public class log4net.Util.SystemStringFormat : object {
    private IFormatProvider m_provider;
    private string m_format;
    private Object[] m_args;
    private static Type declaringType;
    public SystemStringFormat(IFormatProvider provider, string format, Object[] args);
    private static SystemStringFormat();
    public virtual string ToString();
    private static string StringFormat(IFormatProvider provider, string format, Object[] args);
    private static string StringFormatError(Exception formatException, string format, Object[] args);
    private static void RenderArray(Array array, StringBuilder buffer);
    private static void RenderObject(object obj, StringBuilder buffer);
}
public abstract class log4net.Util.TextWriterAdapter : TextWriter {
    private TextWriter m_writer;
    protected TextWriter Writer { get; protected set; }
    public Encoding Encoding { get; }
    public IFormatProvider FormatProvider { get; }
    public string NewLine { get; public set; }
    protected TextWriterAdapter(TextWriter writer);
    protected TextWriter get_Writer();
    protected void set_Writer(TextWriter value);
    public virtual Encoding get_Encoding();
    public virtual IFormatProvider get_FormatProvider();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.ThreadContextProperties : ContextPropertiesBase {
    [ThreadStaticAttribute]
private static PropertiesDictionary _dictionary;
    public object Item { get; public set; }
    public virtual object get_Item(string key);
    public virtual void set_Item(string key, object value);
    public void Remove(string key);
    public String[] GetKeys();
    public void Clear();
    internal PropertiesDictionary GetProperties(bool create);
}
public class log4net.Util.ThreadContextStack : object {
    private Stack m_stack;
    public int Count { get; }
    internal Stack InternalStack { get; internal set; }
    public int get_Count();
    public void Clear();
    public string Pop();
    public IDisposable Push(string message);
    internal string GetFullMessage();
    internal Stack get_InternalStack();
    internal void set_InternalStack(Stack value);
    public virtual string ToString();
    private sealed virtual override object log4net.Core.IFixingRequired.GetFixedObject();
}
[DefaultMemberAttribute("Item")]
public class log4net.Util.ThreadContextStacks : object {
    private ContextPropertiesBase m_properties;
    private static Type declaringType;
    public ThreadContextStack Item { get; }
    internal ThreadContextStacks(ContextPropertiesBase properties);
    private static ThreadContextStacks();
    public ThreadContextStack get_Item(string key);
}
public class log4net.Util.Transform : object {
    private static string CDATA_END;
    private static string CDATA_UNESCAPABLE_TOKEN;
    private static Regex INVALIDCHARS;
    private static Transform();
    public static void WriteEscapedXmlString(XmlWriter writer, string textData, string invalidCharReplacement);
    public static string MaskXmlInvalidCharacters(string textData, string mask);
    private static int CountSubstrings(string text, string substring);
}
public class log4net.Util.TwoArgAction`2 : MulticastDelegate {
    public TwoArgAction`2(object object, IntPtr method);
    public virtual void Invoke(T1 t1, T2 t2);
    public virtual IAsyncResult BeginInvoke(T1 t1, T2 t2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class log4net.Util.TypeConverters.BooleanConverter : object {
    public sealed virtual bool CanConvertFrom(Type sourceType);
    public sealed virtual object ConvertFrom(object source);
}
public class log4net.Util.TypeConverters.ConversionNotSupportedException : ApplicationException {
    public ConversionNotSupportedException(string message);
    public ConversionNotSupportedException(string message, Exception innerException);
    protected ConversionNotSupportedException(SerializationInfo info, StreamingContext context);
    public static ConversionNotSupportedException Create(Type destinationType, object sourceValue);
    public static ConversionNotSupportedException Create(Type destinationType, object sourceValue, Exception innerException);
}
public class log4net.Util.TypeConverters.ConverterRegistry : object {
    private static Type declaringType;
    private static Hashtable s_type2converter;
    private static ConverterRegistry();
    public static void AddConverter(Type destinationType, object converter);
    public static void AddConverter(Type destinationType, Type converterType);
    public static IConvertTo GetConvertTo(Type sourceType, Type destinationType);
    public static IConvertFrom GetConvertFrom(Type destinationType);
    private static object GetConverterFromAttribute(Type destinationType);
    private static object CreateConverterInstance(Type converterType);
}
internal class log4net.Util.TypeConverters.EncodingConverter : object {
    public sealed virtual bool CanConvertFrom(Type sourceType);
    public sealed virtual object ConvertFrom(object source);
}
public interface log4net.Util.TypeConverters.IConvertFrom {
    public abstract virtual bool CanConvertFrom(Type sourceType);
    public abstract virtual object ConvertFrom(object source);
}
public interface log4net.Util.TypeConverters.IConvertTo {
    public abstract virtual bool CanConvertTo(Type targetType);
    public abstract virtual object ConvertTo(object source, Type targetType);
}
internal class log4net.Util.TypeConverters.IPAddressConverter : object {
    private static Char[] validIpAddressChars;
    private static IPAddressConverter();
    public sealed virtual bool CanConvertFrom(Type sourceType);
    public sealed virtual object ConvertFrom(object source);
}
internal class log4net.Util.TypeConverters.PatternLayoutConverter : object {
    public sealed virtual bool CanConvertFrom(Type sourceType);
    public sealed virtual object ConvertFrom(object source);
}
internal class log4net.Util.TypeConverters.PatternStringConverter : object {
    public sealed virtual bool CanConvertTo(Type targetType);
    public sealed virtual object ConvertTo(object source, Type targetType);
    public sealed virtual bool CanConvertFrom(Type sourceType);
    public sealed virtual object ConvertFrom(object source);
}
internal class log4net.Util.TypeConverters.TypeConverter : object {
    public sealed virtual bool CanConvertFrom(Type sourceType);
    public sealed virtual object ConvertFrom(object source);
}
[AttributeUsageAttribute("1044")]
public class log4net.Util.TypeConverters.TypeConverterAttribute : Attribute {
    private string m_typeName;
    public string ConverterTypeName { get; public set; }
    public TypeConverterAttribute(string typeName);
    public TypeConverterAttribute(Type converterType);
    public string get_ConverterTypeName();
    public void set_ConverterTypeName(string value);
}
public class log4net.Util.WindowsSecurityContext : SecurityContext {
    private ImpersonationMode m_impersonationMode;
    private string m_userName;
    private string m_domainName;
    private string m_password;
    private WindowsIdentity m_identity;
    public ImpersonationMode Credentials { get; public set; }
    public string UserName { get; public set; }
    public string DomainName { get; public set; }
    unknown string Password {public set; }
    public ImpersonationMode get_Credentials();
    public void set_Credentials(ImpersonationMode value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_DomainName();
    public void set_DomainName(string value);
    public void set_Password(string value);
    public sealed virtual void ActivateOptions();
    public virtual IDisposable Impersonate(object state);
    [SecuritySafeCriticalAttribute]
private static WindowsIdentity LogonUser(string userName, string domainName, string password);
    private static bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, int dwLogonType, int dwLogonProvider, IntPtr& phToken);
    private static bool CloseHandle(IntPtr handle);
    private static bool DuplicateToken(IntPtr ExistingTokenHandle, int SECURITY_IMPERSONATION_LEVEL, IntPtr& DuplicateTokenHandle);
}
