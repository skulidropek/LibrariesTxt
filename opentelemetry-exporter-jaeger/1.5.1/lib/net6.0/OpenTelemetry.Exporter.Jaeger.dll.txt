[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Configuration.EnvironmentVariables.EnvironmentVariablesConfigurationProvider : ConfigurationProvider {
    private string _prefix;
    private string _normalizedPrefix;
    [NullableContextAttribute("2")]
public EnvironmentVariablesConfigurationProvider(string prefix);
    public virtual void Load();
    public virtual string ToString();
    internal void Load(IDictionary envVariables);
    private void AddIfNormalizedKeyMatchesPrefix(Dictionary`2<string, string> data, string normalizedKey, string value);
    private static string Normalize(string key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Configuration.EnvironmentVariables.EnvironmentVariablesConfigurationSource : object {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public string Prefix { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [NullableContextAttribute("1")]
public sealed virtual IConfigurationProvider Build(IConfigurationBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.Configuration.EnvironmentVariablesExtensions : object {
    [ExtensionAttribute]
public static IConfigurationBuilder AddEnvironmentVariables(IConfigurationBuilder configurationBuilder);
    [ExtensionAttribute]
public static IConfigurationBuilder AddEnvironmentVariables(IConfigurationBuilder configurationBuilder, string prefix);
    [ExtensionAttribute]
public static IConfigurationBuilder AddEnvironmentVariables(IConfigurationBuilder builder, Action`1<EnvironmentVariablesConfigurationSource> configureSource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Options.DelegatingOptionsFactory`1 : object {
    private Func`3<IConfiguration, string, TOptions> optionsFactoryFunc;
    private IConfiguration configuration;
    private IConfigureOptions`1[] _setups;
    private IPostConfigureOptions`1[] _postConfigures;
    private IValidateOptions`1[] _validations;
    public DelegatingOptionsFactory`1(Func`3<IConfiguration, string, TOptions> optionsFactoryFunc, IConfiguration configuration, IEnumerable`1<IConfigureOptions`1<TOptions>> setups, IEnumerable`1<IPostConfigureOptions`1<TOptions>> postConfigures, IEnumerable`1<IValidateOptions`1<TOptions>> validations);
    public sealed virtual TOptions Create(string name);
}
internal class OpenTelemetry.Exporter.Jaeger.Implementation.Batch : object {
    [CompilerGeneratedAttribute]
private Byte[] <BatchBeginMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpanCountPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <BatchEndMessage>k__BackingField;
    public Byte[] BatchBeginMessage { get; }
    public int SpanCountPosition { get; public set; }
    public Byte[] BatchEndMessage { get; }
    public int MinimumMessageSize { get; }
    public Batch(Process process, TProtocol protocol);
    [CompilerGeneratedAttribute]
public Byte[] get_BatchBeginMessage();
    [CompilerGeneratedAttribute]
public int get_SpanCountPosition();
    [CompilerGeneratedAttribute]
public void set_SpanCountPosition(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_BatchEndMessage();
    public int get_MinimumMessageSize();
    private static Byte[] GenerateBeginMessage(Process process, TProtocol oprot, Int32& spanCountPosition);
    private static Byte[] GenerateEndMessage(TProtocol oprot);
}
internal class OpenTelemetry.Exporter.Jaeger.Implementation.EmitBatchArgs : object {
    [CompilerGeneratedAttribute]
private Byte[] <EmitBatchArgsBeginMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SeqIdPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EmitBatchArgsEndMessage>k__BackingField;
    public Byte[] EmitBatchArgsBeginMessage { get; }
    public int SeqIdPosition { get; }
    public Byte[] EmitBatchArgsEndMessage { get; }
    public int MinimumMessageSize { get; }
    public EmitBatchArgs(TProtocol protocol);
    [CompilerGeneratedAttribute]
public Byte[] get_EmitBatchArgsBeginMessage();
    [CompilerGeneratedAttribute]
public int get_SeqIdPosition();
    [CompilerGeneratedAttribute]
public Byte[] get_EmitBatchArgsEndMessage();
    public int get_MinimumMessageSize();
    private static Byte[] GenerateBeginMessage(TProtocol oprot, Int32& seqIdPosition);
    private static Byte[] GenerateEndMessage(TProtocol oprot);
}
internal interface OpenTelemetry.Exporter.Jaeger.Implementation.IJaegerClient {
    public bool Connected { get; }
    public abstract virtual bool get_Connected();
    public abstract virtual void Connect();
    public abstract virtual void Close();
    public abstract virtual int Send(Byte[] buffer, int offset, int count);
}
[IsReadOnlyAttribute]
internal class OpenTelemetry.Exporter.Jaeger.Implementation.Int128 : ValueType {
    public static Int128 Empty;
    private static int SpanIdBytes;
    private static int TraceIdBytes;
    [CompilerGeneratedAttribute]
private long <High>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Low>k__BackingField;
    public long High { get; }
    public long Low { get; }
    public Int128(ActivitySpanId spanId);
    public Int128(ActivityTraceId traceId);
    [CompilerGeneratedAttribute]
public long get_High();
    [CompilerGeneratedAttribute]
public long get_Low();
}
[ExtensionAttribute]
internal static class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerActivityExtensions : object {
    internal static string JaegerErrorFlagTagName;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1970;
    private static long UnixEpochTicks;
    private static long TicksPerMicrosecond;
    private static long UnixEpochMicroseconds;
    [ExtensionAttribute]
public static JaegerSpan ToJaegerSpan(Activity activity);
    [ExtensionAttribute]
public static PooledList`1<JaegerSpanRef> ToJaegerSpanRefs(Activity activity);
    [ExtensionAttribute]
public static PooledList`1<JaegerLog> ToJaegerLogs(Activity activity);
    [ExtensionAttribute]
public static JaegerLog ToJaegerLog(ActivityEvent& timedEvent);
    [ExtensionAttribute]
public static JaegerSpanRef ToJaegerSpanRef(ActivityLink& link);
    [ExtensionAttribute]
public static long ToEpochMicroseconds(DateTime utcDateTime);
    [ExtensionAttribute]
public static long ToEpochMicroseconds(DateTimeOffset timestamp);
}
[EventSourceAttribute]
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerExporterEventSource : EventSource {
    public static JaegerExporterEventSource Log;
    private static JaegerExporterEventSource();
    [NonEventAttribute]
public void FailedExport(Exception ex);
    [EventAttribute("1")]
public void FailedExport(string exception);
}
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerExporterException : Exception {
    public JaegerExporterException(string message, Exception originalException);
}
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerHttpClient : object {
    private static MediaTypeHeaderValue ContentTypeHeader;
    private Uri endpoint;
    private HttpClient httpClient;
    private bool disposed;
    public bool Connected { get; }
    public JaegerHttpClient(Uri endpoint, HttpClient httpClient);
    private static JaegerHttpClient();
    public sealed virtual bool get_Connected();
    public sealed virtual void Close();
    public sealed virtual void Connect();
    public sealed virtual void Dispose();
    public sealed virtual int Send(Byte[] buffer, int offset, int count);
}
[IsReadOnlyAttribute]
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerLog : ValueType {
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private PooledList`1<JaegerTag> <Fields>k__BackingField;
    public long Timestamp { get; }
    public PooledList`1<JaegerTag> Fields { get; }
    public JaegerLog(long timestamp, PooledList`1& fields);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
public PooledList`1<JaegerTag> get_Fields();
    public sealed virtual void Write(TProtocol oprot);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerSpan : ValueType {
    [CompilerGeneratedAttribute]
private string <PeerServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TraceIdLow>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TraceIdHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SpanId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ParentSpanId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private PooledList`1<JaegerSpanRef> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private PooledList`1<JaegerTag> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private PooledList`1<JaegerLog> <Logs>k__BackingField;
    public string PeerServiceName { get; }
    public long TraceIdLow { get; }
    public long TraceIdHigh { get; }
    public long SpanId { get; }
    public long ParentSpanId { get; }
    public string OperationName { get; }
    public PooledList`1<JaegerSpanRef> References { get; }
    public int Flags { get; }
    public long StartTime { get; }
    public long Duration { get; }
    public PooledList`1<JaegerTag> Tags { get; }
    public PooledList`1<JaegerLog> Logs { get; }
    public JaegerSpan(string peerServiceName, long traceIdLow, long traceIdHigh, long spanId, long parentSpanId, string operationName, int flags, long startTime, long duration, PooledList`1& references, PooledList`1& tags, PooledList`1& logs);
    [CompilerGeneratedAttribute]
public string get_PeerServiceName();
    [CompilerGeneratedAttribute]
public long get_TraceIdLow();
    [CompilerGeneratedAttribute]
public long get_TraceIdHigh();
    [CompilerGeneratedAttribute]
public long get_SpanId();
    [CompilerGeneratedAttribute]
public long get_ParentSpanId();
    [CompilerGeneratedAttribute]
public string get_OperationName();
    [CompilerGeneratedAttribute]
public PooledList`1<JaegerSpanRef> get_References();
    [CompilerGeneratedAttribute]
public int get_Flags();
    [CompilerGeneratedAttribute]
public long get_StartTime();
    [CompilerGeneratedAttribute]
public long get_Duration();
    [CompilerGeneratedAttribute]
public PooledList`1<JaegerTag> get_Tags();
    [CompilerGeneratedAttribute]
public PooledList`1<JaegerLog> get_Logs();
    public sealed virtual void Write(TProtocol oprot);
    public void Return();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerSpanRef : ValueType {
    [CompilerGeneratedAttribute]
private JaegerSpanRefType <RefType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TraceIdLow>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TraceIdHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SpanId>k__BackingField;
    public JaegerSpanRefType RefType { get; }
    public long TraceIdLow { get; }
    public long TraceIdHigh { get; }
    public long SpanId { get; }
    public JaegerSpanRef(JaegerSpanRefType refType, long traceIdLow, long traceIdHigh, long spanId);
    [CompilerGeneratedAttribute]
public JaegerSpanRefType get_RefType();
    [CompilerGeneratedAttribute]
public long get_TraceIdLow();
    [CompilerGeneratedAttribute]
public long get_TraceIdHigh();
    [CompilerGeneratedAttribute]
public long get_SpanId();
    public sealed virtual void Write(TProtocol oprot);
    public virtual string ToString();
}
internal enum OpenTelemetry.Exporter.Jaeger.Implementation.JaegerSpanRefType : Enum {
    public int value__;
    public static JaegerSpanRefType CHILD_OF;
    public static JaegerSpanRefType FOLLOWS_FROM;
}
[IsReadOnlyAttribute]
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerTag : ValueType {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private JaegerTagType <VType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VStr>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <VDouble>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <VBool>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <VLong>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <VBinary>k__BackingField;
    public string Key { get; }
    public JaegerTagType VType { get; }
    public string VStr { get; }
    public Nullable`1<double> VDouble { get; }
    public Nullable`1<bool> VBool { get; }
    public Nullable`1<long> VLong { get; }
    public Byte[] VBinary { get; }
    public JaegerTag(string key, JaegerTagType vType, string vStr, Nullable`1<double> vDouble, Nullable`1<bool> vBool, Nullable`1<long> vLong, Byte[] vBinary);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public JaegerTagType get_VType();
    [CompilerGeneratedAttribute]
public string get_VStr();
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_VDouble();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_VBool();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_VLong();
    [CompilerGeneratedAttribute]
public Byte[] get_VBinary();
    public sealed virtual void Write(TProtocol oprot);
    public virtual string ToString();
}
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerTagTransformer : TagTransformer`1<JaegerTag> {
    [CompilerGeneratedAttribute]
private static JaegerTagTransformer <Instance>k__BackingField;
    public static JaegerTagTransformer Instance { get; }
    private static JaegerTagTransformer();
    [CompilerGeneratedAttribute]
public static JaegerTagTransformer get_Instance();
    protected virtual JaegerTag TransformIntegralTag(string key, long value);
    protected virtual JaegerTag TransformFloatingPointTag(string key, double value);
    protected virtual JaegerTag TransformBooleanTag(string key, bool value);
    protected virtual JaegerTag TransformStringTag(string key, string value);
    protected virtual JaegerTag TransformArrayTag(string key, Array array);
}
internal enum OpenTelemetry.Exporter.Jaeger.Implementation.JaegerTagType : Enum {
    public int value__;
    public static JaegerTagType STRING;
    public static JaegerTagType DOUBLE;
    public static JaegerTagType BOOL;
    public static JaegerTagType LONG;
    public static JaegerTagType BINARY;
}
internal class OpenTelemetry.Exporter.Jaeger.Implementation.JaegerUdpClient : object {
    private string host;
    private int port;
    private UdpClient client;
    private bool disposed;
    public bool Connected { get; }
    public JaegerUdpClient(string host, int port);
    public sealed virtual bool get_Connected();
    public sealed virtual void Close();
    public sealed virtual void Connect();
    public sealed virtual int Send(Byte[] buffer, int offset, int count);
    public sealed virtual void Dispose();
}
internal class OpenTelemetry.Exporter.Jaeger.Implementation.Process : object {
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JaegerTag> <Tags>k__BackingField;
    public string ServiceName { get; public set; }
    public Dictionary`2<string, JaegerTag> Tags { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
public void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JaegerTag> get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(Dictionary`2<string, JaegerTag> value);
    public virtual string ToString();
    public void Write(TProtocol oprot);
}
public class OpenTelemetry.Exporter.JaegerExporter : BaseExporter`1<Activity> {
    internal UInt32 NumberOfSpansInCurrentBatch;
    private Byte[] uInt32Storage;
    private int maxPayloadSizeInBytes;
    private IJaegerClient client;
    private TProtocol batchWriter;
    private TProtocol spanWriter;
    private bool sendUsingEmitBatchArgs;
    private int minimumBatchSizeInBytes;
    private int currentBatchSizeInBytes;
    private int spanStartPosition;
    private UInt32 sequenceId;
    private bool disposed;
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private EmitBatchArgs <EmitBatchArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private Batch <Batch>k__BackingField;
    internal Process Process { get; }
    internal EmitBatchArgs EmitBatchArgs { get; private set; }
    internal Batch Batch { get; private set; }
    public JaegerExporter(JaegerExporterOptions options);
    internal JaegerExporter(JaegerExporterOptions options, TProtocolFactory protocolFactory, IJaegerClient client);
    [CompilerGeneratedAttribute]
internal Process get_Process();
    [CompilerGeneratedAttribute]
internal EmitBatchArgs get_EmitBatchArgs();
    [CompilerGeneratedAttribute]
private void set_EmitBatchArgs(EmitBatchArgs value);
    [CompilerGeneratedAttribute]
internal Batch get_Batch();
    [CompilerGeneratedAttribute]
private void set_Batch(Batch value);
    public virtual ExportResult Export(Batch`1& modreq(System.Runtime.InteropServices.InAttribute) activityBatch);
    internal void SetResourceAndInitializeBatch(Resource resource);
    internal void AppendSpan(JaegerSpan jaegerSpan);
    internal void SendCurrentBatch();
    protected virtual void Dispose(bool disposing);
    private void WriteUInt32AtPosition(int position, UInt32 value);
    private void ResetBatch();
}
public class OpenTelemetry.Exporter.JaegerExporterOptions : object {
    internal static int DefaultMaxPayloadSizeInBytes;
    internal static string OTelProtocolEnvVarKey;
    internal static string OTelAgentHostEnvVarKey;
    internal static string OTelAgentPortEnvVarKey;
    internal static string OTelEndpointEnvVarKey;
    internal static string DefaultJaegerEndpoint;
    internal static Func`1<HttpClient> DefaultHttpClientFactory;
    [CompilerGeneratedAttribute]
private JaegerExportProtocol <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AgentHost>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AgentPort>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxPayloadSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private ExportProcessorType <ExportProcessorType>k__BackingField;
    [CompilerGeneratedAttribute]
private BatchExportProcessorOptions`1<Activity> <BatchExportProcessorOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<HttpClient> <HttpClientFactory>k__BackingField;
    public JaegerExportProtocol Protocol { get; public set; }
    public string AgentHost { get; public set; }
    public int AgentPort { get; public set; }
    public Uri Endpoint { get; public set; }
    public Nullable`1<int> MaxPayloadSizeInBytes { get; public set; }
    public ExportProcessorType ExportProcessorType { get; public set; }
    public BatchExportProcessorOptions`1<Activity> BatchExportProcessorOptions { get; public set; }
    public Func`1<HttpClient> HttpClientFactory { get; public set; }
    internal JaegerExporterOptions(IConfiguration configuration, BatchExportActivityProcessorOptions defaultBatchOptions);
    private static JaegerExporterOptions();
    [CompilerGeneratedAttribute]
public JaegerExportProtocol get_Protocol();
    [CompilerGeneratedAttribute]
public void set_Protocol(JaegerExportProtocol value);
    [CompilerGeneratedAttribute]
public string get_AgentHost();
    [CompilerGeneratedAttribute]
public void set_AgentHost(string value);
    [CompilerGeneratedAttribute]
public int get_AgentPort();
    [CompilerGeneratedAttribute]
public void set_AgentPort(int value);
    [CompilerGeneratedAttribute]
public Uri get_Endpoint();
    [CompilerGeneratedAttribute]
public void set_Endpoint(Uri value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxPayloadSizeInBytes();
    [CompilerGeneratedAttribute]
public void set_MaxPayloadSizeInBytes(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public ExportProcessorType get_ExportProcessorType();
    [CompilerGeneratedAttribute]
public void set_ExportProcessorType(ExportProcessorType value);
    [CompilerGeneratedAttribute]
public BatchExportProcessorOptions`1<Activity> get_BatchExportProcessorOptions();
    [CompilerGeneratedAttribute]
public void set_BatchExportProcessorOptions(BatchExportProcessorOptions`1<Activity> value);
    [CompilerGeneratedAttribute]
public Func`1<HttpClient> get_HttpClientFactory();
    [CompilerGeneratedAttribute]
public void set_HttpClientFactory(Func`1<HttpClient> value);
}
internal static class OpenTelemetry.Exporter.JaegerExporterProtocolParser : object {
    public static bool TryParse(string value, JaegerExportProtocol& result);
}
public enum OpenTelemetry.Exporter.JaegerExportProtocol : Enum {
    public byte value__;
    public static JaegerExportProtocol UdpCompactThrift;
    public static JaegerExportProtocol HttpBinaryThrift;
}
internal static class OpenTelemetry.Exporter.PeerServiceResolver : object {
    [NullableAttribute("1")]
private static Dictionary`2<string, int> PeerServiceKeyResolutionDictionary;
    private static PeerServiceResolver();
    public static void InspectTag(T& state, string key, string value);
    public static void InspectTag(T& state, string key, long value);
    public static void Resolve(T& state, String& peerServiceName, Boolean& addAsTag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class OpenTelemetry.Internal.ConfigurationExtensions : object {
    [ExtensionAttribute]
public static bool TryGetStringValue(IConfiguration configuration, string key, String& value);
    [ExtensionAttribute]
public static bool TryGetUriValue(IConfiguration configuration, string key, Uri& value);
    [ExtensionAttribute]
public static bool TryGetIntValue(IConfiguration configuration, string key, Int32& value);
    [ExtensionAttribute]
public static bool TryGetValue(IConfiguration configuration, string key, TryParseFunc`1<T> tryParseFunc, T& value);
    [ExtensionAttribute]
public static IServiceCollection RegisterOptionsFactory(IServiceCollection services, Func`2<IConfiguration, T> optionsFactoryFunc);
    [ExtensionAttribute]
public static IServiceCollection RegisterOptionsFactory(IServiceCollection services, Func`4<IServiceProvider, IConfiguration, string, T> optionsFactoryFunc);
}
[ExtensionAttribute]
internal static class OpenTelemetry.Internal.ExceptionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToInvariantString(Exception exception);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class OpenTelemetry.Internal.Guard : object {
    [DebuggerHiddenAttribute]
public static void ThrowIfNull(object value, string paramName);
    [DebuggerHiddenAttribute]
public static void ThrowIfNullOrEmpty(string value, string paramName);
    [DebuggerHiddenAttribute]
public static void ThrowIfNullOrWhitespace(string value, string paramName);
    [NullableContextAttribute("1")]
[DebuggerHiddenAttribute]
public static void ThrowIfZero(int value, string message, string paramName);
    [DebuggerHiddenAttribute]
public static void ThrowIfInvalidTimeout(int value, string paramName);
    [DebuggerHiddenAttribute]
public static void ThrowIfOutOfRange(int value, string paramName, int min, int max, string minName, string maxName, string message);
    [DebuggerHiddenAttribute]
public static void ThrowIfOutOfRange(double value, string paramName, double min, double max, string minName, string maxName, string message);
    [DebuggerHiddenAttribute]
public static T ThrowIfNotOfType(object value, string paramName);
    [NullableContextAttribute("1")]
[DebuggerHiddenAttribute]
private static void Range(T value, string paramName, T min, T max, string minName, string maxName, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EventSourceAttribute]
internal class OpenTelemetry.Internal.OpenTelemetrySdkEventSource : EventSource {
    public static OpenTelemetrySdkEventSource Log;
    private static OpenTelemetrySdkEventSource();
    [NonEventAttribute]
public void SpanProcessorException(string evnt, Exception ex);
    [NonEventAttribute]
public void MetricObserverCallbackException(Exception exception);
    [NonEventAttribute]
public void MetricReaderException(string methodName, Exception ex);
    [NonEventAttribute]
public void ActivityStarted(Activity activity);
    [NonEventAttribute]
public void ActivityStopped(Activity activity);
    [NonEventAttribute]
public void SelfDiagnosticsFileCreateException(string logDirectory, Exception ex);
    [NonEventAttribute]
public void TracerProviderException(string evnt, Exception ex);
    [NonEventAttribute]
public void MeterProviderException(string methodName, Exception ex);
    [NonEventAttribute]
public void DroppedExportProcessorItems(string exportProcessorName, string exporterName, long droppedCount);
    [NonEventAttribute]
public void LoggerParseStateException(Exception exception);
    [NonEventAttribute]
public void LoggerProviderException(string methodName, Exception ex);
    [NullableContextAttribute("2")]
[NonEventAttribute]
public void LoggerProcessStateSkipped();
    [EventAttribute("4")]
public void SpanProcessorException(string evnt, string ex);
    [EventAttribute("8")]
public void InvalidArgument(string methodName, string argumentName, string issue);
    [EventAttribute("16")]
public void ObservableInstrumentCallbackException(string exception);
    [EventAttribute("24")]
public void ActivityStarted(string name, string id);
    [EventAttribute("25")]
public void ActivityStopped(string name, string id);
    [EventAttribute("26")]
public void SelfDiagnosticsFileCreateException(string logDirectory, string exception);
    [EventAttribute("28")]
public void TracerProviderException(string evnt, string ex);
    [EventAttribute("31")]
public void NoDroppedExportProcessorItems(string exportProcessorName, string exporterName);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[EventAttribute("32")]
public void ExistsDroppedExportProcessorItems(string exportProcessorName, string exporterName, long droppedCount);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[EventAttribute("33")]
public void MetricInstrumentIgnored(string instrumentName, string meterName, string reason, string fix);
    [EventAttribute("34")]
public void MetricReaderException(string methodName, string ex);
    [EventAttribute("35")]
public void MeterProviderException(string methodName, string ex);
    [EventAttribute("36")]
public void MeasurementDropped(string instrumentName, string reason, string fix);
    [EventAttribute("37")]
public void ProviderDisposed(string providerName);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[EventAttribute("38")]
public void DuplicateMetricInstrument(string instrumentName, string meterName, string reason, string fix);
    [EventAttribute("39")]
public void MeterProviderSdkEvent(string message);
    [EventAttribute("40")]
public void MetricReaderEvent(string message);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[EventAttribute("41")]
public void MetricViewIgnored(string instrumentName, string meterName, string reason, string fix);
    [EventAttribute("42")]
public void UnsupportedAttributeType(string type, string key);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[EventAttribute("43")]
public void ProcessorForceFlushInvoked(string processorType, bool result);
    [EventAttribute("44")]
public void OpenTelemetryLoggerProviderEvent(string message);
    [EventAttribute("45")]
public void OpenTelemetryLoggerProviderForceFlushInvoked(int timeoutMilliseconds);
    [EventAttribute("46")]
public void TracerProviderSdkEvent(string message);
    [EventAttribute("47")]
public void InvalidEnvironmentVariable(string key, string value);
    [EventAttribute("48")]
public void LoggerParseStateException(string type, string error);
    [EventAttribute("49")]
public void LoggerProviderSdkEvent(string message);
    [EventAttribute("50")]
public void LoggerProviderException(string methodName, string ex);
    [EventAttribute("51")]
public void LoggerProcessStateSkipped(string type, string reason);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class OpenTelemetry.Internal.PooledList`1 : ValueType {
    private static int lastAllocatedSize;
    private T[] buffer;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T& Item { get; }
    private PooledList`1(T[] buffer, int count);
    private static PooledList`1();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public T& get_Item(int index);
    public static PooledList`1<T> Create();
    public static void Add(PooledList`1& list, T item);
    public static void Clear(PooledList`1& list);
    public void Return();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class OpenTelemetry.Internal.StatusHelper : object {
    public static string UnsetStatusCodeTagValue;
    public static string OkStatusCodeTagValue;
    public static string ErrorStatusCodeTagValue;
    [NullableContextAttribute("2")]
public static string GetTagValueForStatusCode(StatusCode statusCode);
    [NullableContextAttribute("2")]
public static Nullable`1<StatusCode> GetStatusCodeForTagValue(string statusCodeTagValue);
    [NullableContextAttribute("2")]
public static bool TryGetStatusCodeForTagValue(string statusCodeTagValue, StatusCode& statusCode);
}
internal abstract class OpenTelemetry.Internal.TagTransformer`1 : object {
    public bool TryTransformTag(KeyValuePair`2<string, object> tag, T& result, Nullable`1<int> maxLength);
    protected abstract virtual T TransformIntegralTag(string key, long value);
    protected abstract virtual T TransformFloatingPointTag(string key, double value);
    protected abstract virtual T TransformBooleanTag(string key, bool value);
    protected abstract virtual T TransformStringTag(string key, string value);
    protected abstract virtual T TransformArrayTag(string key, Array array);
    private static string TruncateString(string value, Nullable`1<int> maxLength);
    private T TransformArrayTagInternal(string key, Array array, Nullable`1<int> maxStringValueLength);
    private T ConvertToStringArrayThenTransformArrayTag(string key, Array array, Nullable`1<int> maxStringValueLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class OpenTelemetry.Resources.ResourceSemanticConventions : object {
    public static string AttributeServiceName;
    public static string AttributeServiceNamespace;
    public static string AttributeServiceInstance;
    public static string AttributeServiceVersion;
    public static string AttributeTelemetrySdkName;
    public static string AttributeTelemetrySdkLanguage;
    public static string AttributeTelemetrySdkVersion;
    public static string AttributeContainerName;
    public static string AttributeContainerImage;
    public static string AttributeContainerTag;
    public static string AttributeFaasName;
    public static string AttributeFaasId;
    public static string AttributeFaasVersion;
    public static string AttributeFaasInstance;
    public static string AttributeK8sCluster;
    public static string AttributeK8sNamespace;
    public static string AttributeK8sPod;
    public static string AttributeK8sDeployment;
    public static string AttributeHostHostname;
    public static string AttributeHostId;
    public static string AttributeHostName;
    public static string AttributeHostType;
    public static string AttributeHostImageName;
    public static string AttributeHostImageId;
    public static string AttributeHostImageVersion;
    public static string AttributeProcessId;
    public static string AttributeProcessExecutableName;
    public static string AttributeProcessExecutablePath;
    public static string AttributeProcessCommand;
    public static string AttributeProcessCommandLine;
    public static string AttributeProcessUsername;
    public static string AttributeCloudProvider;
    public static string AttributeCloudAccount;
    public static string AttributeCloudRegion;
    public static string AttributeCloudZone;
    public static string AttributeComponent;
}
[ExtensionAttribute]
internal static class OpenTelemetry.Trace.ActivityHelperExtensions : object {
    [ExtensionAttribute]
public static bool TryGetStatus(Activity activity, StatusCode& statusCode, String& statusDescription);
    [ExtensionAttribute]
public static object GetTagValue(Activity activity, string tagName);
    [ExtensionAttribute]
public static bool TryCheckFirstTag(Activity activity, string tagName, Object& tagValue);
}
[ExtensionAttribute]
public static class OpenTelemetry.Trace.JaegerExporterHelperExtensions : object {
    [ExtensionAttribute]
public static TracerProviderBuilder AddJaegerExporter(TracerProviderBuilder builder);
    [ExtensionAttribute]
public static TracerProviderBuilder AddJaegerExporter(TracerProviderBuilder builder, Action`1<JaegerExporterOptions> configure);
    [ExtensionAttribute]
public static TracerProviderBuilder AddJaegerExporter(TracerProviderBuilder builder, string name, Action`1<JaegerExporterOptions> configure);
    private static BaseProcessor`1<Activity> BuildJaegerExporterProcessor(JaegerExporterOptions options, IServiceProvider serviceProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class OpenTelemetry.Trace.SemanticConventions : object {
    public static string AttributeNetTransport;
    public static string AttributeNetPeerIp;
    public static string AttributeNetPeerPort;
    public static string AttributeNetPeerName;
    public static string AttributeNetHostIp;
    public static string AttributeNetHostPort;
    public static string AttributeNetHostName;
    public static string AttributeEnduserId;
    public static string AttributeEnduserRole;
    public static string AttributeEnduserScope;
    public static string AttributePeerService;
    public static string AttributeHttpMethod;
    public static string AttributeHttpUrl;
    public static string AttributeHttpTarget;
    public static string AttributeHttpHost;
    public static string AttributeHttpScheme;
    public static string AttributeHttpStatusCode;
    public static string AttributeHttpStatusText;
    public static string AttributeHttpFlavor;
    public static string AttributeHttpServerName;
    public static string AttributeHttpRoute;
    public static string AttributeHttpClientIP;
    public static string AttributeHttpUserAgent;
    public static string AttributeHttpRequestContentLength;
    public static string AttributeHttpRequestContentLengthUncompressed;
    public static string AttributeHttpResponseContentLength;
    public static string AttributeHttpResponseContentLengthUncompressed;
    public static string AttributeDbSystem;
    public static string AttributeDbConnectionString;
    public static string AttributeDbUser;
    public static string AttributeDbMsSqlInstanceName;
    public static string AttributeDbJdbcDriverClassName;
    public static string AttributeDbName;
    public static string AttributeDbStatement;
    public static string AttributeDbOperation;
    public static string AttributeDbInstance;
    public static string AttributeDbUrl;
    public static string AttributeDbCassandraKeyspace;
    public static string AttributeDbHBaseNamespace;
    public static string AttributeDbRedisDatabaseIndex;
    public static string AttributeDbMongoDbCollection;
    public static string AttributeRpcSystem;
    public static string AttributeRpcService;
    public static string AttributeRpcMethod;
    public static string AttributeRpcGrpcStatusCode;
    public static string AttributeMessageType;
    public static string AttributeMessageId;
    public static string AttributeMessageCompressedSize;
    public static string AttributeMessageUncompressedSize;
    public static string AttributeFaasTrigger;
    public static string AttributeFaasExecution;
    public static string AttributeFaasDocumentCollection;
    public static string AttributeFaasDocumentOperation;
    public static string AttributeFaasDocumentTime;
    public static string AttributeFaasDocumentName;
    public static string AttributeFaasTime;
    public static string AttributeFaasCron;
    public static string AttributeMessagingSystem;
    public static string AttributeMessagingDestination;
    public static string AttributeMessagingDestinationKind;
    public static string AttributeMessagingTempDestination;
    public static string AttributeMessagingProtocol;
    public static string AttributeMessagingProtocolVersion;
    public static string AttributeMessagingUrl;
    public static string AttributeMessagingMessageId;
    public static string AttributeMessagingConversationId;
    public static string AttributeMessagingPayloadSize;
    public static string AttributeMessagingPayloadCompressedSize;
    public static string AttributeMessagingOperation;
    public static string AttributeExceptionEventName;
    public static string AttributeExceptionType;
    public static string AttributeExceptionMessage;
    public static string AttributeExceptionStacktrace;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class OpenTelemetry.Trace.SpanAttributeConstants : object {
    public static string StatusCodeKey;
    public static string StatusDescriptionKey;
    public static string DatabaseStatementTypeKey;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
internal class Thrift.Protocol.Entities.TField : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ID>k__BackingField;
    public string Name { get; public set; }
    public TType Type { get; public set; }
    public short ID { get; public set; }
    public TField(string name, TType type, short id);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public short get_ID();
    [CompilerGeneratedAttribute]
public void set_ID(short value);
}
internal class Thrift.Protocol.Entities.TList : ValueType {
    [CompilerGeneratedAttribute]
private TType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public TType ElementType { get; public set; }
    public int Count { get; public set; }
    public TList(TType elementType, int count);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TType get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(TType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
}
internal class Thrift.Protocol.Entities.TMap : ValueType {
    [CompilerGeneratedAttribute]
private TType <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private TType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public TType KeyType { get; public set; }
    public TType ValueType { get; public set; }
    public int Count { get; public set; }
    public TMap(TType keyType, TType valueType, int count);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TType get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(TType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TType get_ValueType();
    [CompilerGeneratedAttribute]
public void set_ValueType(TType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
}
internal class Thrift.Protocol.Entities.TMessage : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TMessageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SeqID>k__BackingField;
    public string Name { get; public set; }
    public TMessageType Type { get; public set; }
    public int SeqID { get; public set; }
    public TMessage(string name, TMessageType type, int seqid);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TMessageType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TMessageType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_SeqID();
    [CompilerGeneratedAttribute]
public void set_SeqID(int value);
}
internal enum Thrift.Protocol.Entities.TMessageType : Enum {
    public int value__;
    public static TMessageType Call;
    public static TMessageType Reply;
    public static TMessageType Exception;
    public static TMessageType Oneway;
}
internal class Thrift.Protocol.Entities.TSet : ValueType {
    [CompilerGeneratedAttribute]
private TType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public TType ElementType { get; public set; }
    public int Count { get; public set; }
    public TSet(TType elementType, int count);
    public TSet(TList list);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TType get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(TType value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
}
internal class Thrift.Protocol.Entities.TStruct : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public TStruct(string name);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal enum Thrift.Protocol.Entities.TType : Enum {
    public byte value__;
    public static TType Stop;
    public static TType Void;
    public static TType Bool;
    public static TType Byte;
    public static TType Double;
    public static TType I16;
    public static TType I32;
    public static TType I64;
    public static TType String;
    public static TType Struct;
    public static TType Map;
    public static TType Set;
    public static TType List;
}
internal class Thrift.Protocol.TBinaryProtocol : TProtocol {
    private static UInt32 VersionMask;
    private static UInt32 Version1;
    private bool StrictRead;
    private bool StrictWrite;
    private Byte[] PreAllocatedBuffer;
    private static TStruct AnonymousStruct;
    private static TField StopField;
    public TBinaryProtocol(int initialCapacity);
    public TBinaryProtocol(bool strictRead, bool strictWrite, int initialCapacity);
    private static TBinaryProtocol();
    public virtual void WriteMessageBegin(TMessage message);
    public virtual void WriteMessageBegin(TMessage message, Int32& seqIdPosition);
    public virtual void WriteMessageEnd();
    public virtual void WriteStructBegin(TStruct struct);
    public virtual void WriteStructEnd();
    public virtual void WriteFieldBegin(TField field);
    public virtual void WriteFieldEnd();
    public virtual void WriteFieldStop();
    public virtual void WriteListBegin(TList list);
    public virtual void WriteListBegin(TList list, Int32& countPosition);
    public virtual void WriteListEnd();
    public virtual void WriteBool(bool b);
    public virtual void WriteByte(sbyte b);
    public virtual void WriteI16(short i16);
    public virtual int WriteUI32(UInt32 ui32, Span`1<byte> buffer);
    public virtual void WriteI32(int i32);
    public virtual void WriteI64(long i64);
    public virtual void WriteDouble(double d);
    public virtual void WriteBinary(ReadOnlySpan`1<byte> bytes);
    public virtual void WriteBinary(Byte[] bytes, int offset, int count);
}
internal class Thrift.Protocol.TCompactProtocol : TProtocol {
    private static byte ProtocolId;
    private static byte Version;
    private static byte VersionMask;
    private static byte TypeMask;
    private static byte TypeBits;
    private static int TypeShiftAmount;
    private static TStruct AnonymousStruct;
    private static TField StopField;
    private static byte NoTypeOverride;
    private static Byte[] TTypeToCompactType;
    private static TType[] CompactTypeToTType;
    private Stack`1<short> _lastField;
    private Nullable`1<TField> _booleanField;
    private short _lastFieldId;
    private Byte[] PreAllocatedBuffer;
    private VarInt PreAllocatedVarInt;
    private Byte[] EmptyUInt32Buffer;
    public TCompactProtocol(int initialCapacity);
    private static TCompactProtocol();
    public virtual void Reset();
    public virtual void WriteMessageBegin(TMessage message);
    public virtual void WriteMessageBegin(TMessage message, Int32& seqIdPosition);
    public virtual void WriteMessageEnd();
    public virtual void WriteStructBegin(TStruct struct);
    public virtual void WriteStructEnd();
    private void WriteFieldBeginInternal(TField field, byte fieldType);
    public virtual void WriteFieldBegin(TField field);
    public virtual void WriteFieldEnd();
    public virtual void WriteFieldStop();
    public virtual void WriteListBegin(TList list);
    public virtual void WriteListBegin(TList list, Int32& countPosition);
    public virtual void WriteListEnd();
    public virtual void WriteBool(bool b);
    public virtual void WriteByte(sbyte b);
    public virtual void WriteI16(short i16);
    private static void Int32ToVarInt(UInt32 n, VarInt& varint);
    public virtual void WriteI32(int i32);
    public virtual int WriteUI32(UInt32 ui32, Span`1<byte> buffer);
    private static void Int64ToVarInt(ulong n, VarInt& varint);
    public virtual void WriteI64(long i64);
    public virtual void WriteDouble(double d);
    public virtual void WriteBinary(ReadOnlySpan`1<byte> bytes);
    public virtual void WriteBinary(Byte[] bytes, int offset, int count);
    private static byte GetCompactType(TType ttype);
    private static ulong LongToZigzag(long n);
    private static UInt32 IntToZigzag(int n);
    private static void FixedLongToBytes(long n, Byte[] buf, int off);
}
internal abstract class Thrift.Protocol.TProtocol : object {
    public static int DefaultRecursionDepth;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private MemoryStream <Transport>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecursionDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecursionLimit>k__BackingField;
    protected MemoryStream Transport { get; }
    protected int RecursionDepth { get; protected set; }
    protected int RecursionLimit { get; protected set; }
    public ArraySegment`1<byte> WrittenData { get; }
    public int Position { get; public set; }
    public int Length { get; }
    protected TProtocol(int initialCapacity);
    [CompilerGeneratedAttribute]
protected MemoryStream get_Transport();
    [CompilerGeneratedAttribute]
protected int get_RecursionDepth();
    [CompilerGeneratedAttribute]
protected void set_RecursionDepth(int value);
    [CompilerGeneratedAttribute]
protected int get_RecursionLimit();
    [CompilerGeneratedAttribute]
protected void set_RecursionLimit(int value);
    public ArraySegment`1<byte> get_WrittenData();
    public int get_Position();
    public void set_Position(int value);
    public int get_Length();
    public void Clear(int offset);
    public virtual void Reset();
    public sealed virtual void Dispose();
    public void IncrementRecursionDepth();
    public void DecrementRecursionDepth();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void WriteMessageBegin(TMessage message);
    public abstract virtual void WriteMessageBegin(TMessage message, Int32& seqIdPosition);
    public abstract virtual void WriteMessageEnd();
    public abstract virtual void WriteStructBegin(TStruct struct);
    public abstract virtual void WriteStructEnd();
    public abstract virtual void WriteFieldBegin(TField field);
    public abstract virtual void WriteFieldEnd();
    public abstract virtual void WriteFieldStop();
    public abstract virtual void WriteListBegin(TList list);
    public abstract virtual void WriteListBegin(TList list, Int32& countPosition);
    public abstract virtual void WriteListEnd();
    public abstract virtual void WriteBool(bool b);
    public abstract virtual void WriteByte(sbyte b);
    public abstract virtual void WriteI16(short i16);
    public abstract virtual void WriteI32(int i32);
    public abstract virtual int WriteUI32(UInt32 ui32, Span`1<byte> buffer);
    public abstract virtual void WriteI64(long i64);
    public abstract virtual void WriteDouble(double d);
    public virtual void WriteString(string s);
    public abstract virtual void WriteBinary(ReadOnlySpan`1<byte> bytes);
    public abstract virtual void WriteBinary(Byte[] bytes, int offset, int count);
    public void WriteRaw(Byte[] bytes);
    public void WriteRaw(Byte[] bytes, int offset, int count);
    public void WriteRaw(ArraySegment`1<byte> bytes);
}
internal class Thrift.Protocol.TProtocolException : TException {
    public static int UNKNOWN;
    public static int INVALID_DATA;
    public static int NEGATIVE_SIZE;
    public static int SIZE_LIMIT;
    public static int BAD_VERSION;
    public static int NOT_IMPLEMENTED;
    public static int DEPTH_LIMIT;
    protected int Type;
    public TProtocolException(int type, Exception inner);
    public TProtocolException(int type, string message, Exception inner);
    public TProtocolException(string message, Exception inner);
    public int GetExceptionType();
}
internal abstract class Thrift.Protocol.TProtocolFactory : object {
    public abstract virtual TProtocol GetProtocol(int initialCapacity);
}
internal interface Thrift.Protocol.TUnionBase {
    public abstract virtual void Write(TProtocol tProtocol);
}
internal class Thrift.TException : Exception {
    public TException(string message, Exception inner);
}
