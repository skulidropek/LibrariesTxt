[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Configuration.EnvironmentVariables.EnvironmentVariablesConfigurationProvider : ConfigurationProvider {
    private string _prefix;
    private string _normalizedPrefix;
    [NullableContextAttribute("2")]
public EnvironmentVariablesConfigurationProvider(string prefix);
    public virtual void Load();
    public virtual string ToString();
    internal void Load(IDictionary envVariables);
    private void AddIfNormalizedKeyMatchesPrefix(Dictionary`2<string, string> data, string normalizedKey, string value);
    private static string Normalize(string key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Configuration.EnvironmentVariables.EnvironmentVariablesConfigurationSource : object {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public string Prefix { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [NullableContextAttribute("1")]
public sealed virtual IConfigurationProvider Build(IConfigurationBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.Configuration.EnvironmentVariablesExtensions : object {
    [ExtensionAttribute]
public static IConfigurationBuilder AddEnvironmentVariables(IConfigurationBuilder configurationBuilder);
    [ExtensionAttribute]
public static IConfigurationBuilder AddEnvironmentVariables(IConfigurationBuilder configurationBuilder, string prefix);
    [ExtensionAttribute]
public static IConfigurationBuilder AddEnvironmentVariables(IConfigurationBuilder builder, Action`1<EnvironmentVariablesConfigurationSource> configureSource);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Extensions.Configuration.IConfigurationExtensionsLogger {
    public abstract virtual void LogInvalidConfigurationValue(string key, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.Configuration.OpenTelemetryConfigurationExtensions : object {
    [ExtensionAttribute]
public static bool TryGetStringValue(IConfiguration configuration, string key, String& value);
    [ExtensionAttribute]
public static bool TryGetUriValue(IConfiguration configuration, IConfigurationExtensionsLogger logger, string key, Uri& value);
    [ExtensionAttribute]
public static bool TryGetIntValue(IConfiguration configuration, IConfigurationExtensionsLogger logger, string key, Int32& value);
    [ExtensionAttribute]
public static bool TryGetBoolValue(IConfiguration configuration, IConfigurationExtensionsLogger logger, string key, Boolean& value);
    [ExtensionAttribute]
public static bool TryGetValue(IConfiguration configuration, IConfigurationExtensionsLogger logger, string key, TryParseFunc`1<T> tryParseFunc, T& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.DependencyInjection.DelegatingOptionsFactoryServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection RegisterOptionsFactory(IServiceCollection services, Func`2<IConfiguration, T> optionsFactoryFunc);
    [ExtensionAttribute]
public static IServiceCollection RegisterOptionsFactory(IServiceCollection services, Func`4<IServiceProvider, IConfiguration, string, T> optionsFactoryFunc);
    [ExtensionAttribute]
public static IServiceCollection DisableOptionsReloading(IServiceCollection services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.DependencyInjection.ProviderBuilderServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddOpenTelemetryLoggerProviderBuilderServices(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddOpenTelemetryMeterProviderBuilderServices(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddOpenTelemetryTracerProviderBuilderServices(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddOpenTelemetrySharedProviderBuilderServices(IServiceCollection services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.Diagnostics.Metrics.OpenTelemetryMetricsBuilderExtensions : object {
    [ExtensionAttribute]
public static IMetricsBuilder UseOpenTelemetry(IMetricsBuilder metricsBuilder);
    [ExtensionAttribute]
public static IMetricsBuilder UseOpenTelemetry(IMetricsBuilder metricsBuilder, Action`1<MeterProviderBuilder> configure);
    internal static void RegisterMetricsListener(IServiceCollection services, Action`1<MeterProviderBuilder> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.Logging.OpenTelemetryLoggingExtensions : object {
    [ExtensionAttribute]
public static ILoggingBuilder AddOpenTelemetry(ILoggingBuilder builder);
    [ExtensionAttribute]
public static ILoggingBuilder AddOpenTelemetry(ILoggingBuilder builder, Action`1<OpenTelemetryLoggerOptions> configure);
    [ExtensionAttribute]
internal static ILoggingBuilder UseOpenTelemetry(ILoggingBuilder builder);
    [ExtensionAttribute]
internal static ILoggingBuilder UseOpenTelemetry(ILoggingBuilder builder, Action`1<LoggerProviderBuilder> configure);
    [ExtensionAttribute]
internal static ILoggingBuilder UseOpenTelemetry(ILoggingBuilder builder, Action`1<LoggerProviderBuilder> configureBuilder, Action`1<OpenTelemetryLoggerOptions> configureOptions);
    private static ILoggingBuilder AddOpenTelemetryInternal(ILoggingBuilder builder, Action`1<LoggerProviderBuilder> configureBuilder, Action`1<OpenTelemetryLoggerOptions> configureOptions);
    [CompilerGeneratedAttribute]
internal static void <AddOpenTelemetryInternal>g__RegisterLoggerProviderOptions|5_2(IServiceCollection services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Options.DelegatingOptionsFactory`1 : object {
    private Func`3<IConfiguration, string, TOptions> optionsFactoryFunc;
    private IConfiguration configuration;
    private IConfigureOptions`1[] _setups;
    private IPostConfigureOptions`1[] _postConfigures;
    private IValidateOptions`1[] _validations;
    public DelegatingOptionsFactory`1(Func`3<IConfiguration, string, TOptions> optionsFactoryFunc, IConfiguration configuration, IEnumerable`1<IConfigureOptions`1<TOptions>> setups, IEnumerable`1<IPostConfigureOptions`1<TOptions>> postConfigures, IEnumerable`1<IValidateOptions`1<TOptions>> validations);
    public sealed virtual TOptions Create(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Options.SingletonOptionsManager`1 : object {
    private TOptions instance;
    public TOptions CurrentValue { get; }
    public TOptions Value { get; }
    public SingletonOptionsManager`1(IOptions`1<TOptions> options);
    public sealed virtual TOptions get_CurrentValue();
    public sealed virtual TOptions get_Value();
    public sealed virtual TOptions Get(string name);
    [NullableContextAttribute("2")]
public sealed virtual IDisposable OnChange(Action`2<TOptions, string> listener);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class OpenTelemetry.BaseExporter`1 : object {
    private int shutdownCount;
    [CompilerGeneratedAttribute]
private BaseProvider <ParentProvider>k__BackingField;
    public BaseProvider ParentProvider { get; internal set; }
    [CompilerGeneratedAttribute]
public BaseProvider get_ParentProvider();
    [CompilerGeneratedAttribute]
internal void set_ParentProvider(BaseProvider value);
    public abstract virtual ExportResult Export(Batch`1& modreq(System.Runtime.InteropServices.InAttribute) batch);
    public bool ForceFlush(int timeoutMilliseconds);
    public bool Shutdown(int timeoutMilliseconds);
    public sealed virtual void Dispose();
    protected virtual bool OnForceFlush(int timeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class OpenTelemetry.BaseExportProcessor`1 : BaseProcessor`1<T> {
    protected BaseExporter`1<T> exporter;
    private string friendlyTypeName;
    private bool disposed;
    internal BaseExporter`1<T> Exporter { get; }
    protected BaseExportProcessor`1(BaseExporter`1<T> exporter);
    internal BaseExporter`1<T> get_Exporter();
    public virtual string ToString();
    public sealed virtual void OnStart(T data);
    public virtual void OnEnd(T data);
    internal virtual void SetParentProvider(BaseProvider parentProvider);
    protected abstract virtual void OnExport(T data);
    protected virtual bool OnForceFlush(int timeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class OpenTelemetry.BaseProcessor`1 : object {
    private string typeName;
    private int shutdownCount;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BaseProvider <ParentProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PipelineWeight>k__BackingField;
    [NullableAttribute("2")]
public BaseProvider ParentProvider { get; private set; }
    internal int PipelineWeight { get; internal set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BaseProvider get_ParentProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ParentProvider(BaseProvider value);
    [CompilerGeneratedAttribute]
internal int get_PipelineWeight();
    [CompilerGeneratedAttribute]
internal void set_PipelineWeight(int value);
    public virtual void OnStart(T data);
    public virtual void OnEnd(T data);
    public bool ForceFlush(int timeoutMilliseconds);
    public bool Shutdown(int timeoutMilliseconds);
    public sealed virtual void Dispose();
    public virtual string ToString();
    internal virtual void SetParentProvider(BaseProvider parentProvider);
    protected virtual bool OnForceFlush(int timeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class OpenTelemetry.Batch`1 : ValueType {
    [NullableAttribute("2")]
private T item;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private CircularBuffer`1<T> circularBuffer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] items;
    private long targetCount;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public long Count { get; }
    public Batch`1(T[] items, int count);
    internal Batch`1(T item);
    internal Batch`1(CircularBuffer`1<T> circularBuffer, int maxSize);
    [CompilerGeneratedAttribute]
public long get_Count();
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class OpenTelemetry.BatchActivityExportProcessor : BatchExportProcessor`1<Activity> {
    public BatchActivityExportProcessor(BaseExporter`1<Activity> exporter, int maxQueueSize, int scheduledDelayMilliseconds, int exporterTimeoutMilliseconds, int maxExportBatchSize);
    public virtual void OnEnd(Activity data);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class OpenTelemetry.BatchExportProcessor`1 : BaseExportProcessor`1<T> {
    internal static int DefaultMaxQueueSize;
    internal static int DefaultScheduledDelayMilliseconds;
    internal static int DefaultExporterTimeoutMilliseconds;
    internal static int DefaultMaxExportBatchSize;
    internal int MaxExportBatchSize;
    internal int ScheduledDelayMilliseconds;
    internal int ExporterTimeoutMilliseconds;
    private CircularBuffer`1<T> circularBuffer;
    private Thread exporterThread;
    private AutoResetEvent exportTrigger;
    private ManualResetEvent dataExportedNotification;
    private ManualResetEvent shutdownTrigger;
    private long shutdownDrainTarget;
    private long droppedCount;
    private bool disposed;
    internal long DroppedCount { get; }
    internal long ReceivedCount { get; }
    internal long ProcessedCount { get; }
    protected BatchExportProcessor`1(BaseExporter`1<T> exporter, int maxQueueSize, int scheduledDelayMilliseconds, int exporterTimeoutMilliseconds, int maxExportBatchSize);
    internal long get_DroppedCount();
    internal long get_ReceivedCount();
    internal long get_ProcessedCount();
    internal bool TryExport(T data);
    protected virtual void OnExport(T data);
    protected virtual bool OnForceFlush(int timeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
    private void ExporterProc();
}
public class OpenTelemetry.BatchExportProcessorOptions`1 : object {
    [CompilerGeneratedAttribute]
private int <MaxQueueSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ScheduledDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExporterTimeoutMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxExportBatchSize>k__BackingField;
    public int MaxQueueSize { get; public set; }
    public int ScheduledDelayMilliseconds { get; public set; }
    public int ExporterTimeoutMilliseconds { get; public set; }
    public int MaxExportBatchSize { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxQueueSize();
    [CompilerGeneratedAttribute]
public void set_MaxQueueSize(int value);
    [CompilerGeneratedAttribute]
public int get_ScheduledDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_ScheduledDelayMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_ExporterTimeoutMilliseconds();
    [CompilerGeneratedAttribute]
public void set_ExporterTimeoutMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_MaxExportBatchSize();
    [CompilerGeneratedAttribute]
public void set_MaxExportBatchSize(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class OpenTelemetry.BatchLogRecordExportProcessor : BatchExportProcessor`1<LogRecord> {
    public BatchLogRecordExportProcessor(BaseExporter`1<LogRecord> exporter, int maxQueueSize, int scheduledDelayMilliseconds, int exporterTimeoutMilliseconds, int maxExportBatchSize);
    public virtual void OnEnd(LogRecord data);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class OpenTelemetry.CompositeProcessor`1 : BaseProcessor`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal DoublyLinkedListNode<T> Head;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private DoublyLinkedListNode<T> tail;
    private bool disposed;
    public CompositeProcessor`1(IEnumerable`1<BaseProcessor`1<T>> processors);
    public CompositeProcessor`1<T> AddProcessor(BaseProcessor`1<T> processor);
    public virtual void OnEnd(T data);
    public virtual void OnStart(T data);
    internal virtual void SetParentProvider(BaseProvider parentProvider);
    internal IReadOnlyList`1<BaseProcessor`1<T>> ToReadOnlyList();
    protected virtual bool OnForceFlush(int timeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
}
public enum OpenTelemetry.ExportProcessorType : Enum {
    public int value__;
    public static ExportProcessorType Simple;
    public static ExportProcessorType Batch;
}
public enum OpenTelemetry.ExportResult : Enum {
    public int value__;
    public static ExportResult Success;
    public static ExportResult Failure;
}
[ExtensionAttribute]
internal static class OpenTelemetry.Internal.AssemblyVersionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetPackageVersion(Assembly assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Internal.CircularBuffer`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] trait;
    private long head;
    private long tail;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    public int Capacity { get; }
    public int Count { get; }
    public long AddedCount { get; }
    public long RemovedCount { get; }
    public CircularBuffer`1(int capacity);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    public int get_Count();
    public long get_AddedCount();
    public long get_RemovedCount();
    public bool Add(T value);
    public bool TryAdd(T value, int maxSpinCount);
    public T Read();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Internal.InstrumentationScopeLogger : Logger {
    private static ConcurrentDictionary`2<string, InstrumentationScopeLogger> Cache;
    [CompilerGeneratedAttribute]
private static InstrumentationScopeLogger <Default>k__BackingField;
    public static InstrumentationScopeLogger Default { get; }
    private InstrumentationScopeLogger(string name);
    private static InstrumentationScopeLogger();
    [CompilerGeneratedAttribute]
public static InstrumentationScopeLogger get_Default();
    public static InstrumentationScopeLogger GetInstrumentationScopeLoggerForName(string name);
    public virtual void EmitLog(LogRecordData& modreq(System.Runtime.InteropServices.InAttribute) data, LogRecordAttributeList& modreq(System.Runtime.InteropServices.InAttribute) attributes);
}
internal static class OpenTelemetry.Internal.InterlockedHelper : object {
    public static void Add(Double& location, double value);
    public static double Read(Double& location);
    private static void AddRare(Double& location, double value, double currentValue);
}
internal static class OpenTelemetry.Internal.MathHelper : object {
    [NullableAttribute("1")]
private static Byte[] LeadingZeroLookupTable;
    private static MathHelper();
    public static int LeadingZero8(byte value);
    public static int LeadingZero16(short value);
    public static int LeadingZero32(int value);
    public static int LeadingZero64(long value);
    public static int PositiveModulo32(int value, int divisor);
    public static long PositiveModulo64(long value, long divisor);
    public static bool IsFinite(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EventSourceAttribute]
internal class OpenTelemetry.Internal.OpenTelemetrySdkEventSource : EventSource {
    public static OpenTelemetrySdkEventSource Log;
    private static OpenTelemetrySdkEventSource();
    [NonEventAttribute]
public void SpanProcessorException(string evnt, Exception ex);
    [NonEventAttribute]
public void MetricObserverCallbackException(Exception exception);
    [NonEventAttribute]
public void MetricReaderException(string methodName, Exception ex);
    [NonEventAttribute]
public void ActivityStarted(Activity activity);
    [NonEventAttribute]
public void ActivityStopped(Activity activity);
    [NonEventAttribute]
public void SelfDiagnosticsFileCreateException(string logDirectory, Exception ex);
    [NonEventAttribute]
public void TracerProviderException(string evnt, Exception ex);
    [NonEventAttribute]
public void MeterProviderException(string methodName, Exception ex);
    [NonEventAttribute]
public void DroppedExportProcessorItems(string exportProcessorName, string exporterName, long droppedCount);
    [NonEventAttribute]
public void LoggerParseStateException(Exception exception);
    [NonEventAttribute]
public void LoggerProviderException(string methodName, Exception ex);
    [NullableContextAttribute("2")]
[NonEventAttribute]
public void LoggerProcessStateSkipped();
    [NonEventAttribute]
public void MetricViewException(string source, Exception ex);
    [EventAttribute("4")]
public void SpanProcessorException(string evnt, string ex);
    [EventAttribute("8")]
public void InvalidArgument(string methodName, string argumentName, string issue);
    [EventAttribute("16")]
public void ObservableInstrumentCallbackException(string exception);
    [EventAttribute("24")]
public void ActivityStarted(string name, string id);
    [EventAttribute("25")]
public void ActivityStopped(string name, string id);
    [EventAttribute("26")]
public void SelfDiagnosticsFileCreateException(string logDirectory, string exception);
    [EventAttribute("28")]
public void TracerProviderException(string evnt, string ex);
    [EventAttribute("31")]
public void NoDroppedExportProcessorItems(string exportProcessorName, string exporterName);
    [EventAttribute("32")]
public void ExistsDroppedExportProcessorItems(string exportProcessorName, string exporterName, long droppedCount);
    [EventAttribute("33")]
public void MetricInstrumentIgnored(string instrumentName, string meterName, string reason, string fix);
    [EventAttribute("34")]
public void MetricReaderException(string methodName, string ex);
    [EventAttribute("35")]
public void MeterProviderException(string methodName, string ex);
    [EventAttribute("36")]
public void MeasurementDropped(string instrumentName, string reason, string fix);
    [EventAttribute("37")]
public void ProviderDisposed(string providerName);
    [EventAttribute("38")]
public void DuplicateMetricInstrument(string instrumentName, string meterName, string reason, string fix);
    [EventAttribute("39")]
public void MeterProviderSdkEvent(string message);
    [EventAttribute("40")]
public void MetricReaderEvent(string message);
    [EventAttribute("41")]
public void MetricViewIgnored(string instrumentName, string meterName, string reason, string fix);
    [EventAttribute("43")]
public void ProcessorForceFlushInvoked(string processorType, bool result);
    [EventAttribute("44")]
public void OpenTelemetryLoggerProviderEvent(string message);
    [EventAttribute("45")]
public void OpenTelemetryLoggerProviderForceFlushInvoked(int timeoutMilliseconds);
    [EventAttribute("46")]
public void TracerProviderSdkEvent(string message);
    [EventAttribute("47")]
public void InvalidConfigurationValue(string key, string value);
    [EventAttribute("48")]
public void LoggerParseStateException(string type, string error);
    [EventAttribute("49")]
public void LoggerProviderSdkEvent(string message);
    [EventAttribute("50")]
public void LoggerProviderException(string methodName, string ex);
    [EventAttribute("51")]
public void LoggerProcessStateSkipped(string type, string reason);
    [EventAttribute("52")]
public void MetricInstrumentDeactivated(string instrumentName, string meterName);
    [EventAttribute("53")]
public void MetricInstrumentRemoved(string instrumentName, string meterName);
    [EventAttribute("54")]
public void TracesSamplerConfigInvalid(string configValue);
    [EventAttribute("55")]
public void TracesSamplerArgConfigInvalid(string configValue);
    [EventAttribute("56")]
public void MetricViewException(string source, string ex);
    private sealed virtual override void Microsoft.Extensions.Configuration.IConfigurationExtensionsLogger.LogInvalidConfigurationValue(string key, string value);
}
internal class OpenTelemetry.Internal.SelfDiagnostics : object {
    [NullableAttribute("1")]
private static SelfDiagnostics Instance;
    [NullableAttribute("1")]
private SelfDiagnosticsConfigRefresher configRefresher;
    private static SelfDiagnostics();
    public static void EnsureInitialized();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Internal.SelfDiagnosticsConfigParser : object {
    public static string ConfigFileName;
    private static int FileSizeLowerLimit;
    private static int FileSizeUpperLimit;
    private static int ConfigBufferSize;
    private static Regex LogDirectoryRegex;
    private static Regex FileSizeRegex;
    private static Regex LogLevelRegex;
    [NullableAttribute("2")]
private Byte[] configBuffer;
    private static SelfDiagnosticsConfigParser();
    [NullableContextAttribute("2")]
public bool TryGetConfiguration(String& logDirectory, Int32& fileSizeInKB, EventLevel& logLevel);
    internal static bool TryParseLogDirectory(string configJson, String& logDirectory);
    internal static bool TryParseFileSize(string configJson, Int32& fileSizeInKB);
    internal static bool TryParseLogLevel(string configJson, String& logLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Internal.SelfDiagnosticsConfigRefresher : object {
    public static Byte[] MessageOnNewFile;
    private static int ConfigurationUpdatePeriodMilliSeconds;
    private CancellationTokenSource cancellationTokenSource;
    private Task worker;
    private SelfDiagnosticsConfigParser configParser;
    private ThreadLocal`1<MemoryMappedFile> memoryMappedFileCache;
    private ThreadLocal`1<MemoryMappedViewStream> viewStream;
    private bool disposedValue;
    [NullableAttribute("2")]
private SelfDiagnosticsEventListener eventListener;
    [NullableAttribute("2")]
private FileStream modreq(System.Runtime.CompilerServices.IsVolatile) underlyingFileStreamForMemoryMappedFile;
    [NullableAttribute("2")]
private MemoryMappedFile modreq(System.Runtime.CompilerServices.IsVolatile) memoryMappedFile;
    [NullableAttribute("2")]
private string logDirectory;
    private int logFileSize;
    private long logFilePosition;
    private EventLevel logEventLevel;
    private static SelfDiagnosticsConfigRefresher();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
public virtual bool TryGetLogStream(int byteCount, Stream& stream, Int32& availableByteCount);
    [AsyncStateMachineAttribute("OpenTelemetry.Internal.SelfDiagnosticsConfigRefresher/<Worker>d__18")]
private Task Worker(CancellationToken cancellationToken);
    private void UpdateMemoryMappedFileFromConfiguration();
    private void CloseLogFile();
    private void OpenLogFile(string newLogDirectory, int newFileSize);
    private void Dispose(bool disposing);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Task <.ctor>b__15_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Internal.SelfDiagnosticsEventListener : EventListener {
    private static int BUFFERSIZE;
    private static string EventSourceNamePrefix;
    private object lockObj;
    private EventLevel logLevel;
    private SelfDiagnosticsConfigRefresher configRefresher;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadLocal`1<Byte[]> writeBuffer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<EventSource> eventSourcesBeforeConstructor;
    private bool disposedValue;
    public SelfDiagnosticsEventListener(EventLevel logLevel, SelfDiagnosticsConfigRefresher configRefresher);
    public virtual void Dispose();
    internal static int EncodeInBuffer(string str, bool isParameter, Byte[] buffer, int position);
    [NullableContextAttribute("2")]
internal void WriteEvent(string eventMessage, ReadOnlyCollection`1<object> payload);
    internal int DateTimeGetBytes(DateTime datetime, Byte[] bytes, int byteIndex);
    protected virtual void OnEventSourceCreated(EventSource eventSource);
    protected virtual void OnEventWritten(EventWrittenEventArgs eventData);
    private void Dispose(bool disposing);
}
internal static class OpenTelemetry.Internal.ThreadSafeRandom : object {
    [NullableAttribute("1")]
private static Random GlobalRandom;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static Random localRandom;
    private static ThreadSafeRandom();
    public static int Next(int min, int max);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class OpenTelemetry.Logs.BatchExportLogRecordProcessorOptions : BatchExportProcessorOptions`1<LogRecord> {
    internal static string MaxQueueSizeEnvVarKey;
    internal static string MaxExportBatchSizeEnvVarKey;
    internal static string ExporterTimeoutEnvVarKey;
    internal static string ScheduledDelayEnvVarKey;
    internal BatchExportLogRecordProcessorOptions(IConfiguration configuration);
}
[NullableContextAttribute("1")]
internal interface OpenTelemetry.Logs.ILogRecordPool {
    public abstract virtual LogRecord Rent();
    public abstract virtual void Return(LogRecord logRecord);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Logs.LoggerProviderBuilderBase : LoggerProviderBuilder {
    private bool allowBuild;
    private LoggerProviderServiceCollectionBuilder innerBuilder;
    [NullableAttribute("2")]
private LoggerProvider OpenTelemetry.Logs.ILoggerProviderBuilder.Provider { get; }
    internal LoggerProviderBuilderBase(IServiceCollection services);
    [NullableContextAttribute("2")]
private sealed virtual override LoggerProvider OpenTelemetry.Logs.ILoggerProviderBuilder.get_Provider();
    public virtual LoggerProviderBuilder AddInstrumentation(Func`1<TInstrumentation> instrumentationFactory);
    private sealed virtual override LoggerProviderBuilder OpenTelemetry.Logs.ILoggerProviderBuilder.ConfigureServices(Action`1<IServiceCollection> configure);
    private sealed virtual override LoggerProviderBuilder OpenTelemetry.Logs.IDeferredLoggerProviderBuilder.Configure(Action`2<IServiceProvider, LoggerProviderBuilder> configure);
    internal LoggerProvider Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.Logs.LoggerProviderBuilderExtensions : object {
    [ExtensionAttribute]
public static LoggerProviderBuilder SetResourceBuilder(LoggerProviderBuilder loggerProviderBuilder, ResourceBuilder resourceBuilder);
    [ExtensionAttribute]
public static LoggerProviderBuilder ConfigureResource(LoggerProviderBuilder loggerProviderBuilder, Action`1<ResourceBuilder> configure);
    [ExtensionAttribute]
public static LoggerProviderBuilder AddProcessor(LoggerProviderBuilder loggerProviderBuilder, BaseProcessor`1<LogRecord> processor);
    [ExtensionAttribute]
public static LoggerProviderBuilder AddProcessor(LoggerProviderBuilder loggerProviderBuilder);
    [ExtensionAttribute]
public static LoggerProviderBuilder AddProcessor(LoggerProviderBuilder loggerProviderBuilder, Func`2<IServiceProvider, BaseProcessor`1<LogRecord>> implementationFactory);
    [ExtensionAttribute]
public static LoggerProvider Build(LoggerProviderBuilder loggerProviderBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Logs.LoggerProviderBuilderSdk : LoggerProviderBuilder {
    private static string DefaultInstrumentationVersion;
    private IServiceProvider serviceProvider;
    [NullableAttribute("2")]
private LoggerProviderSdk loggerProvider;
    [CompilerGeneratedAttribute]
private List`1<InstrumentationRegistration> <Instrumentation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ResourceBuilder <ResourceBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BaseProcessor`1<LogRecord>> <Processors>k__BackingField;
    public List`1<InstrumentationRegistration> Instrumentation { get; }
    [NullableAttribute("2")]
public ResourceBuilder ResourceBuilder { get; private set; }
    [NullableAttribute("2")]
public LoggerProvider Provider { get; }
    public List`1<BaseProcessor`1<LogRecord>> Processors { get; }
    public LoggerProviderBuilderSdk(IServiceProvider serviceProvider);
    [CompilerGeneratedAttribute]
public List`1<InstrumentationRegistration> get_Instrumentation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ResourceBuilder get_ResourceBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ResourceBuilder(ResourceBuilder value);
    [NullableContextAttribute("2")]
public sealed virtual LoggerProvider get_Provider();
    [CompilerGeneratedAttribute]
public List`1<BaseProcessor`1<LogRecord>> get_Processors();
    public void RegisterProvider(LoggerProviderSdk loggerProvider);
    public virtual LoggerProviderBuilder AddInstrumentation(Func`1<TInstrumentation> instrumentationFactory);
    public LoggerProviderBuilder ConfigureResource(Action`1<ResourceBuilder> configure);
    public LoggerProviderBuilder SetResourceBuilder(ResourceBuilder resourceBuilder);
    public LoggerProviderBuilder AddProcessor(BaseProcessor`1<LogRecord> processor);
    public LoggerProviderBuilder ConfigureBuilder(Action`2<IServiceProvider, LoggerProviderBuilder> configure);
    public sealed virtual LoggerProviderBuilder ConfigureServices(Action`1<IServiceCollection> configure);
    private sealed virtual override LoggerProviderBuilder OpenTelemetry.Logs.IDeferredLoggerProviderBuilder.Configure(Action`2<IServiceProvider, LoggerProviderBuilder> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.Logs.LoggerProviderExtensions : object {
    [ExtensionAttribute]
public static LoggerProvider AddProcessor(LoggerProvider provider, BaseProcessor`1<LogRecord> processor);
    [ExtensionAttribute]
public static bool ForceFlush(LoggerProvider provider, int timeoutMilliseconds);
    [ExtensionAttribute]
public static bool Shutdown(LoggerProvider provider, int timeoutMilliseconds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Logs.LoggerProviderSdk : LoggerProvider {
    internal IServiceProvider ServiceProvider;
    [NullableAttribute("2")]
internal IDisposable OwnedServiceProvider;
    internal bool Disposed;
    internal int ShutdownCount;
    private List`1<object> instrumentations;
    [NullableAttribute("2")]
private ILogRecordPool threadStaticPool;
    [CompilerGeneratedAttribute]
private Resource <Resource>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private BaseProcessor`1<LogRecord> <Processor>k__BackingField;
    public Resource Resource { get; }
    public List`1<object> Instrumentations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public BaseProcessor`1<LogRecord> Processor { get; private set; }
    public ILogRecordPool LogRecordPool { get; }
    public LoggerProviderSdk(IServiceProvider serviceProvider, bool ownsServiceProvider);
    [CompilerGeneratedAttribute]
public Resource get_Resource();
    public List`1<object> get_Instrumentations();
    [CompilerGeneratedAttribute]
public BaseProcessor`1<LogRecord> get_Processor();
    [CompilerGeneratedAttribute]
private void set_Processor(BaseProcessor`1<LogRecord> value);
    public ILogRecordPool get_LogRecordPool();
    public void AddProcessor(BaseProcessor`1<LogRecord> processor);
    public bool ForceFlush(int timeoutMilliseconds);
    public bool Shutdown(int timeoutMilliseconds);
    public bool ContainsBatchProcessor(BaseProcessor`1<LogRecord> processor);
    [NullableContextAttribute("2")]
internal virtual bool TryCreateLogger(string name, Logger& logger);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Logs.LoggerSdk : Logger {
    private LoggerProviderSdk loggerProvider;
    public LoggerSdk(LoggerProviderSdk loggerProvider, string name);
    public virtual void EmitLog(LogRecordData& modreq(System.Runtime.InteropServices.InAttribute) data, LogRecordAttributeList& modreq(System.Runtime.InteropServices.InAttribute) attributes);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class OpenTelemetry.Logs.LogRecord : object {
    internal LogRecordData Data;
    internal LogRecordILoggerData ILoggerData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyList`1<KeyValuePair`2<string, object>> AttributeData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<KeyValuePair`2<string, object>> AttributeStorage;
    internal List`1<object> ScopeStorage;
    internal LogRecordSource Source;
    internal int PoolReferenceCount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`2<object, List`1<object>> AddScopeToBufferedList;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Logger <Logger>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public ActivityTraceId TraceId { get; public set; }
    public ActivitySpanId SpanId { get; public set; }
    public ActivityTraceFlags TraceFlags { get; public set; }
    public string TraceState { get; public set; }
    public string CategoryName { get; public set; }
    public LogLevel LogLevel { get; public set; }
    public EventId EventId { get; public set; }
    public string FormattedMessage { get; public set; }
    public string Body { get; public set; }
    [ObsoleteAttribute("State cannot be accessed safely outside of an ILogger.Log call stack. Use Attributes instead to safely access the data attached to a LogRecord. State will be removed in a future version.")]
public object State { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ObsoleteAttribute("Use Attributes instead. StateValues will be removed in a future version.")]
public IReadOnlyList`1<KeyValuePair`2<string, object>> StateValues { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<KeyValuePair`2<string, object>> Attributes { get; public set; }
    public Exception Exception { get; public set; }
    internal string SeverityText { get; internal set; }
    internal Nullable`1<LogRecordSeverity> Severity { get; internal set; }
    [NullableAttribute("1")]
internal Logger Logger { get; internal set; }
    [ObsoleteAttribute("Call LogRecordPool.Rent instead.")]
internal LogRecord(IExternalScopeProvider scopeProvider, DateTime timestamp, string categoryName, LogLevel logLevel, EventId eventId, string formattedMessage, object state, Exception exception, IReadOnlyList`1<KeyValuePair`2<string, object>> stateValues);
    private static LogRecord();
    public DateTime get_Timestamp();
    public void set_Timestamp(DateTime value);
    public ActivityTraceId get_TraceId();
    public void set_TraceId(ActivityTraceId value);
    public ActivitySpanId get_SpanId();
    public void set_SpanId(ActivitySpanId value);
    public ActivityTraceFlags get_TraceFlags();
    public void set_TraceFlags(ActivityTraceFlags value);
    public string get_TraceState();
    public void set_TraceState(string value);
    public string get_CategoryName();
    public void set_CategoryName(string value);
    public LogLevel get_LogLevel();
    public void set_LogLevel(LogLevel value);
    public EventId get_EventId();
    public void set_EventId(EventId value);
    public string get_FormattedMessage();
    public void set_FormattedMessage(string value);
    public string get_Body();
    public void set_Body(string value);
    public object get_State();
    public void set_State(object value);
    public IReadOnlyList`1<KeyValuePair`2<string, object>> get_StateValues();
    public void set_StateValues(IReadOnlyList`1<KeyValuePair`2<string, object>> value);
    public IReadOnlyList`1<KeyValuePair`2<string, object>> get_Attributes();
    public void set_Attributes(IReadOnlyList`1<KeyValuePair`2<string, object>> value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    internal string get_SeverityText();
    internal void set_SeverityText(string value);
    internal Nullable`1<LogRecordSeverity> get_Severity();
    internal void set_Severity(Nullable`1<LogRecordSeverity> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal Logger get_Logger();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal void set_Logger(Logger value);
    [NullableContextAttribute("1")]
public void ForEachScope(Action`2<LogRecordScope, TState> callback, TState state);
    internal LogRecordData& GetDataRef();
    internal void ResetReferenceCount();
    internal void AddReference();
    internal int RemoveReference();
    internal void Buffer();
    [NullableContextAttribute("1")]
internal LogRecord Copy();
    private void BufferLogAttributes();
    private void BufferLogScopes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Logs.LogRecordExportProcessorOptions : object {
    private BatchExportLogRecordProcessorOptions batchExportProcessorOptions;
    [CompilerGeneratedAttribute]
private ExportProcessorType <ExportProcessorType>k__BackingField;
    public ExportProcessorType ExportProcessorType { get; public set; }
    public BatchExportLogRecordProcessorOptions BatchExportProcessorOptions { get; public set; }
    internal LogRecordExportProcessorOptions(BatchExportLogRecordProcessorOptions defaultBatchExportLogRecordProcessorOptions);
    [CompilerGeneratedAttribute]
public ExportProcessorType get_ExportProcessorType();
    [CompilerGeneratedAttribute]
public void set_ExportProcessorType(ExportProcessorType value);
    public BatchExportLogRecordProcessorOptions get_BatchExportProcessorOptions();
    public void set_BatchExportProcessorOptions(BatchExportLogRecordProcessorOptions value);
}
internal static class OpenTelemetry.Logs.LogRecordPoolHelper : object {
    public static int DefaultMaxNumberOfAttributes;
    public static int DefaultMaxNumberOfScopes;
    [NullableContextAttribute("1")]
public static void Clear(LogRecord logRecord);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class OpenTelemetry.Logs.LogRecordScope : ValueType {
    [CompilerGeneratedAttribute]
private object <Scope>k__BackingField;
    public object Scope { get; }
    internal LogRecordScope(object scope);
    [CompilerGeneratedAttribute]
public object get_Scope();
    public Enumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Logs.LogRecordSharedPool : object {
    public static int DefaultMaxPoolSize;
    public static LogRecordSharedPool Current;
    public int Capacity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LogRecord[] pool;
    private long rentIndex;
    private long returnIndex;
    public int Count { get; }
    private LogRecordSharedPool(int capacity);
    private static LogRecordSharedPool();
    public int get_Count();
    public static void Resize(int capacity);
    public sealed virtual LogRecord Rent();
    public sealed virtual void Return(LogRecord logRecord);
    [NullableContextAttribute("2")]
private bool TryRentCoreRare(long rentSnapshot, LogRecord& logRecord);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Logs.LogRecordThreadStaticPool : object {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
public static LogRecord Storage;
    [CompilerGeneratedAttribute]
private static LogRecordThreadStaticPool <Instance>k__BackingField;
    public static LogRecordThreadStaticPool Instance { get; }
    private static LogRecordThreadStaticPool();
    [CompilerGeneratedAttribute]
public static LogRecordThreadStaticPool get_Instance();
    public sealed virtual LogRecord Rent();
    public sealed virtual void Return(LogRecord logRecord);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Logs.OpenTelemetryLogger : object {
    private static String[] LogLevels;
    private LoggerProviderSdk provider;
    private OpenTelemetryLoggerOptions options;
    private InstrumentationScopeLogger instrumentationScope;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IExternalScopeProvider <ScopeProvider>k__BackingField;
    [NullableAttribute("2")]
internal IExternalScopeProvider ScopeProvider { get; internal set; }
    internal OpenTelemetryLogger(LoggerProviderSdk provider, OpenTelemetryLoggerOptions options, string categoryName);
    private static OpenTelemetryLogger();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IExternalScopeProvider get_ScopeProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ScopeProvider(IExternalScopeProvider value);
    [NullableContextAttribute("2")]
public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual IDisposable BeginScope(TState state);
    internal static void SetLogRecordSeverityFields(LogRecordData& logRecordData, LogLevel logLevel);
    internal static IReadOnlyList`1<KeyValuePair`2<string, object>> ProcessState(LogRecord logRecord, LogRecordILoggerData& iLoggerData, TState& state, bool includeAttributes, bool parseStateValues);
    [NullableContextAttribute("2")]
private static bool TryGetOriginalFormatFromAttributes(IReadOnlyList`1<KeyValuePair`2<string, object>> attributes, String& originalFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Logs.OpenTelemetryLoggerOptions : object {
    internal List`1<Func`2<IServiceProvider, BaseProcessor`1<LogRecord>>> ProcessorFactories;
    [NullableAttribute("2")]
internal ResourceBuilder ResourceBuilder;
    [CompilerGeneratedAttribute]
private bool <IncludeFormattedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParseStateValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTraceState>k__BackingField;
    public bool IncludeFormattedMessage { get; public set; }
    public bool IncludeScopes { get; public set; }
    public bool ParseStateValues { get; public set; }
    internal bool IncludeAttributes { get; internal set; }
    internal bool IncludeTraceState { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_IncludeFormattedMessage();
    [CompilerGeneratedAttribute]
public void set_IncludeFormattedMessage(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeScopes();
    [CompilerGeneratedAttribute]
public void set_IncludeScopes(bool value);
    [CompilerGeneratedAttribute]
public bool get_ParseStateValues();
    [CompilerGeneratedAttribute]
public void set_ParseStateValues(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IncludeAttributes();
    [CompilerGeneratedAttribute]
internal void set_IncludeAttributes(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IncludeTraceState();
    [CompilerGeneratedAttribute]
internal void set_IncludeTraceState(bool value);
    public OpenTelemetryLoggerOptions AddProcessor(BaseProcessor`1<LogRecord> processor);
    public OpenTelemetryLoggerOptions AddProcessor(Func`2<IServiceProvider, BaseProcessor`1<LogRecord>> implementationFactory);
    public OpenTelemetryLoggerOptions SetResourceBuilder(ResourceBuilder resourceBuilder);
    internal OpenTelemetryLoggerOptions Copy();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ProviderAliasAttribute("OpenTelemetry")]
public class OpenTelemetry.Logs.OpenTelemetryLoggerProvider : BaseProvider {
    internal LoggerProvider Provider;
    private bool ownsProvider;
    private Hashtable loggers;
    private bool disposed;
    [CompilerGeneratedAttribute]
private OpenTelemetryLoggerOptions <Options>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IExternalScopeProvider <ScopeProvider>k__BackingField;
    internal OpenTelemetryLoggerOptions Options { get; }
    [NullableAttribute("2")]
internal IExternalScopeProvider ScopeProvider { get; private set; }
    private static OpenTelemetryLoggerProvider();
    public OpenTelemetryLoggerProvider(IOptionsMonitor`1<OpenTelemetryLoggerOptions> options);
    internal OpenTelemetryLoggerProvider(LoggerProvider loggerProvider, OpenTelemetryLoggerOptions options, bool disposeProvider);
    [CompilerGeneratedAttribute]
internal OpenTelemetryLoggerOptions get_Options();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IExternalScopeProvider get_ScopeProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ScopeProvider(IExternalScopeProvider value);
    private sealed virtual override void Microsoft.Extensions.Logging.ISupportExternalScope.SetScopeProvider(IExternalScopeProvider scopeProvider);
    public sealed virtual ILogger CreateLogger(string categoryName);
    protected virtual void Dispose(bool disposing);
}
public enum OpenTelemetry.Metrics.AggregationTemporality : Enum {
    public byte value__;
    public static AggregationTemporality Cumulative;
    public static AggregationTemporality Delta;
}
internal enum OpenTelemetry.Metrics.AggregationType : Enum {
    public int value__;
    public static AggregationType Invalid;
    public static AggregationType LongSumIncomingDelta;
    public static AggregationType LongSumIncomingCumulative;
    public static AggregationType DoubleSumIncomingDelta;
    public static AggregationType DoubleSumIncomingCumulative;
    public static AggregationType LongGauge;
    public static AggregationType DoubleGauge;
    public static AggregationType HistogramWithBuckets;
    public static AggregationType HistogramWithMinMaxBuckets;
    public static AggregationType Histogram;
    public static AggregationType HistogramWithMinMax;
    public static AggregationType Base2ExponentialHistogram;
    public static AggregationType Base2ExponentialHistogramWithMinMax;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.AggregatorStore : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal HashSet`1<string> TagKeysInteresting;
    internal bool OutputDelta;
    internal bool OutputDeltaWithUnusedMetricPointReclaimEnabled;
    internal int NumberOfMetricPoints;
    internal bool EmitOverflowAttribute;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ConcurrentDictionary`2<Tags, LookupData> TagsToMetricPointIndexDictionaryDelta;
    [NullableAttribute("2")]
internal Func`1<ExemplarReservoir> ExemplarReservoirFactory;
    internal long DroppedMeasurements;
    private static ExemplarFilterType DefaultExemplarFilter;
    private static string MetricPointCapHitFixMessage;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Comparison`1<KeyValuePair`2<string, object>> DimensionComparisonDelegate;
    private object lockZeroTags;
    private object lockOverflowTag;
    private int tagsKeysInterestingCount;
    [NullableAttribute("2")]
private Queue`1<int> availableMetricPoints;
    private ConcurrentDictionary`2<Tags, int> tagsToMetricPointIndexDictionary;
    private string name;
    private string metricPointCapHitMessage;
    private MetricPoint[] metricPoints;
    private Int32[] currentMetricPointBatch;
    private AggregationType aggType;
    private Double[] histogramBounds;
    private int exponentialHistogramMaxSize;
    private int exponentialHistogramMaxScale;
    private UpdateLongDelegate updateLongCallback;
    private UpdateDoubleDelegate updateDoubleCallback;
    private ExemplarFilterType exemplarFilter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<KeyValuePair`2[], int, int> lookupAggregatorStore;
    private int metricPointIndex;
    private int batchSize;
    private int metricCapHitMessageLogged;
    private bool zeroTagMetricPointInitialized;
    private bool overflowTagMetricPointInitialized;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartTimeExclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <EndTimeInclusive>k__BackingField;
    internal DateTimeOffset StartTimeExclusive { get; private set; }
    internal DateTimeOffset EndTimeInclusive { get; private set; }
    internal Double[] HistogramBounds { get; }
    [NullableContextAttribute("2")]
internal AggregatorStore(MetricStreamIdentity metricStreamIdentity, AggregationType aggType, AggregationTemporality temporality, int cardinalityLimit, bool emitOverflowAttribute, bool shouldReclaimUnusedMetricPoints, Nullable`1<ExemplarFilterType> exemplarFilter, Func`1<ExemplarReservoir> exemplarReservoirFactory);
    private static AggregatorStore();
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_StartTimeExclusive();
    [CompilerGeneratedAttribute]
private void set_StartTimeExclusive(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_EndTimeInclusive();
    [CompilerGeneratedAttribute]
private void set_EndTimeInclusive(DateTimeOffset value);
    internal Double[] get_HistogramBounds();
    internal bool IsExemplarEnabled();
    internal void Update(long value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    internal void Update(double value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    internal int Snapshot();
    internal void SnapshotDelta(int indexSnapshot);
    internal void SnapshotDeltaWithMetricPointReclaim();
    internal void SnapshotCumulative(int indexSnapshot);
    internal MetricPointsAccessor GetMetricPoints();
    private static Double[] FindDefaultHistogramBounds(MetricStreamIdentity& metricStreamIdentity);
    private void TakeMetricPointSnapshot(MetricPoint& metricPoint, bool outputDelta);
    private void ReclaimMetricPoint(MetricPoint& metricPoint, int metricPointIndex);
    private void InitializeZeroTagPointIfNotInitialized();
    private void InitializeOverflowTagPointIfNotInitialized();
    private int LookupAggregatorStore(KeyValuePair`2[] tagKeysAndValues, int length);
    private int LookupAggregatorStoreForDeltaWithReclaim(KeyValuePair`2[] tagKeysAndValues, int length);
    [NullableContextAttribute("2")]
private bool TryGetAvailableMetricPointRare(Tags givenTags, Tags sortedTags, int length, LookupData& lookupData, Boolean& newMetricPointCreated);
    private int RemoveStaleEntriesAndGetAvailableMetricPointRare(LookupData lookupData, int length);
    private void UpdateLong(long value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private void UpdateLongCustomTags(long value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private void UpdateLongMetricPoint(int metricPointIndex, long value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private void UpdateDouble(double value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private void UpdateDoubleCustomTags(double value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private void UpdateDoubleMetricPoint(int metricPointIndex, double value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private int FindMetricAggregatorsDefault(ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private int FindMetricAggregatorsCustomTag(ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
}
internal class OpenTelemetry.Metrics.AlignedHistogramBucketExemplarReservoir : FixedSizeExemplarReservoir {
    public AlignedHistogramBucketExemplarReservoir(int numberOfBuckets);
    public virtual void Offer(ExemplarMeasurement`1& modreq(System.Runtime.InteropServices.InAttribute) measurement);
    public virtual void Offer(ExemplarMeasurement`1& modreq(System.Runtime.InteropServices.InAttribute) measurement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.Base2ExponentialBucketHistogram : object {
    internal double RunningSum;
    internal double SnapshotSum;
    internal double RunningMin;
    internal double SnapshotMin;
    internal double RunningMax;
    internal double SnapshotMax;
    internal ExponentialHistogramData SnapshotExponentialHistogramData;
    private int scale;
    private double scalingFactor;
    [CompilerGeneratedAttribute]
private CircularBufferBuckets <PositiveBuckets>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ZeroCount>k__BackingField;
    [CompilerGeneratedAttribute]
private CircularBufferBuckets <NegativeBuckets>k__BackingField;
    internal int Scale { get; internal set; }
    internal double ScalingFactor { get; }
    internal CircularBufferBuckets PositiveBuckets { get; }
    internal long ZeroCount { get; private set; }
    internal CircularBufferBuckets NegativeBuckets { get; }
    public Base2ExponentialBucketHistogram(int maxBuckets, int scale);
    internal int get_Scale();
    internal void set_Scale(int value);
    internal double get_ScalingFactor();
    [CompilerGeneratedAttribute]
internal CircularBufferBuckets get_PositiveBuckets();
    [CompilerGeneratedAttribute]
internal long get_ZeroCount();
    [CompilerGeneratedAttribute]
private void set_ZeroCount(long value);
    [CompilerGeneratedAttribute]
internal CircularBufferBuckets get_NegativeBuckets();
    public int MapToIndex(double value);
    public void Record(double value);
    internal void Reset();
    internal void Snapshot();
    internal ExponentialHistogramData GetExponentialHistogramData();
    internal Base2ExponentialBucketHistogram Copy();
}
public class OpenTelemetry.Metrics.Base2ExponentialBucketHistogramConfiguration : HistogramConfiguration {
    private int maxSize;
    private int maxScale;
    public int MaxSize { get; public set; }
    public int MaxScale { get; public set; }
    public int get_MaxSize();
    public void set_MaxSize(int value);
    public int get_MaxScale();
    public void set_MaxScale(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.BaseExportingMetricReader : MetricReader {
    protected BaseExporter`1<Metric> exporter;
    private ExportModes supportedExportModes;
    private string exportCalledMessage;
    private string exportSucceededMessage;
    private string exportFailedMessage;
    private bool disposed;
    internal BaseExporter`1<Metric> Exporter { get; }
    protected ExportModes SupportedExportModes { get; }
    public BaseExportingMetricReader(BaseExporter`1<Metric> exporter);
    internal BaseExporter`1<Metric> get_Exporter();
    protected ExportModes get_SupportedExportModes();
    internal virtual void SetParentProvider(BaseProvider parentProvider);
    internal virtual bool ProcessMetrics(Batch`1& modreq(System.Runtime.InteropServices.InAttribute) metrics, int timeoutMilliseconds);
    protected virtual bool OnCollect(int timeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__6_0(int timeoutMilliseconds);
}
[DefaultMemberAttribute("Item")]
internal class OpenTelemetry.Metrics.CircularBufferBuckets : object {
    [NullableAttribute("2")]
private Int64[] trait;
    private int begin;
    private int end;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    public int Capacity { get; }
    public int Offset { get; }
    public int Size { get; }
    public long Item { get; }
    public CircularBufferBuckets(int capacity);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    public int get_Offset();
    public int get_Size();
    public long get_Item(int index);
    public int TryIncrement(int index, long value);
    public void ScaleDown(int level);
    internal void Reset();
    [NullableContextAttribute("1")]
internal void Copy(Int64[] dst);
    private int ModuloIndex(int value);
    [CompilerGeneratedAttribute]
internal static int <TryIncrement>g__CalculateScaleReduction|13_0(int begin, int end, int capacity);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <ScaleDown>g__ScaleDownInternal|14_0(Int64[] array, UInt32 offset, int begin, int end, UInt32 capacity);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <ScaleDown>g__AdjustPosition|14_1(Int64[] array, UInt32 src, UInt32 dst, UInt32 size, UInt32 capacity);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <ScaleDown>g__Consolidate|14_2(Int64[] array, UInt32 src, UInt32 dst);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <ScaleDown>g__Exchange|14_3(Int64[] array, UInt32 src, UInt32 dst);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <ScaleDown>g__Move|14_4(Int64[] array, UInt32 src, UInt32 dst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.CompositeMetricReader : MetricReader {
    public DoublyLinkedListNode Head;
    private DoublyLinkedListNode tail;
    private bool disposed;
    private int count;
    public CompositeMetricReader(IEnumerable`1<MetricReader> readers);
    public CompositeMetricReader AddReader(MetricReader reader);
    public Enumerator GetEnumerator();
    internal virtual bool ProcessMetrics(Batch`1& modreq(System.Runtime.InteropServices.InAttribute) metrics, int timeoutMilliseconds);
    protected virtual bool OnCollect(int timeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
    internal virtual List`1<Metric> AddMetricWithNoViews(Instrument instrument);
    internal virtual List`1<Metric> AddMetricWithViews(Instrument instrument, List`1<MetricStreamConfiguration> metricStreamConfigs);
}
public class OpenTelemetry.Metrics.Exemplar : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal HashSet`1<string> ViewDefinedTagKeys;
    private static ReadOnlyFilteredTagCollection Empty;
    private int tagCount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyValuePair`2[] tagStorage;
    private MetricPointValueStorage valueStorage;
    private int isCriticalSectionOccupied;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityTraceId <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivitySpanId <SpanId>k__BackingField;
    public DateTimeOffset Timestamp { get; private set; }
    public ActivityTraceId TraceId { get; private set; }
    public ActivitySpanId SpanId { get; private set; }
    public long LongValue { get; private set; }
    public double DoubleValue { get; private set; }
    public ReadOnlyFilteredTagCollection FilteredTags { get; }
    private static Exemplar();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(DateTimeOffset value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ActivityTraceId get_TraceId();
    [CompilerGeneratedAttribute]
private void set_TraceId(ActivityTraceId value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ActivitySpanId get_SpanId();
    [CompilerGeneratedAttribute]
private void set_SpanId(ActivitySpanId value);
    [IsReadOnlyAttribute]
public long get_LongValue();
    private void set_LongValue(long value);
    [IsReadOnlyAttribute]
public double get_DoubleValue();
    private void set_DoubleValue(double value);
    [IsReadOnlyAttribute]
public ReadOnlyFilteredTagCollection get_FilteredTags();
    internal void Update(ExemplarMeasurement`1& measurement);
    internal void Reset();
    [IsReadOnlyAttribute]
internal bool IsUpdated();
    internal void Collect(Exemplar& destination, bool reset);
    [IsReadOnlyAttribute]
internal void Copy(Exemplar& destination);
    private void StoreRawTags(ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    private void AcquireLockRare();
}
public enum OpenTelemetry.Metrics.ExemplarFilterType : Enum {
    public int value__;
    public static ExemplarFilterType AlwaysOff;
    public static ExemplarFilterType AlwaysOn;
    public static ExemplarFilterType TraceBased;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
internal class OpenTelemetry.Metrics.ExemplarMeasurement`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlySpan`1<KeyValuePair`2<string, object>> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExplicitBucketHistogramBucketIndex>k__BackingField;
    public T Value { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<KeyValuePair`2<string, object>> Tags { get; }
    internal int ExplicitBucketHistogramBucketIndex { get; }
    internal ExemplarMeasurement`1(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    internal ExemplarMeasurement`1(T value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, int explicitBucketHistogramIndex);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public ReadOnlySpan`1<KeyValuePair`2<string, object>> get_Tags();
    [CompilerGeneratedAttribute]
internal int get_ExplicitBucketHistogramBucketIndex();
}
internal abstract class OpenTelemetry.Metrics.ExemplarReservoir : object {
    [CompilerGeneratedAttribute]
private bool <ResetOnCollect>k__BackingField;
    public bool ResetOnCollect { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_ResetOnCollect();
    [CompilerGeneratedAttribute]
private void set_ResetOnCollect(bool value);
    public abstract virtual void Offer(ExemplarMeasurement`1& modreq(System.Runtime.InteropServices.InAttribute) measurement);
    public abstract virtual void Offer(ExemplarMeasurement`1& modreq(System.Runtime.InteropServices.InAttribute) measurement);
    public abstract virtual ReadOnlyExemplarCollection Collect();
    [NullableContextAttribute("1")]
internal virtual void Initialize(AggregatorStore aggregatorStore);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.ExplicitBucketHistogramConfiguration : HistogramConfiguration {
    [CompilerGeneratedAttribute]
private Double[] <CopiedBoundaries>k__BackingField;
    public Double[] Boundaries { get; public set; }
    internal Double[] CopiedBoundaries { get; private set; }
    public Double[] get_Boundaries();
    public void set_Boundaries(Double[] value);
    [CompilerGeneratedAttribute]
internal Double[] get_CopiedBoundaries();
    [CompilerGeneratedAttribute]
private void set_CopiedBoundaries(Double[] value);
    [NullableContextAttribute("1")]
private static bool IsSortedAndDistinct(Double[] values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.ExponentialHistogramBuckets : object {
    private Int64[] buckets;
    private int size;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int Offset { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    public Enumerator GetEnumerator();
    internal void SnapshotBuckets(CircularBufferBuckets buckets);
    internal ExponentialHistogramBuckets Copy();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.ExponentialHistogramData : object {
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ZeroCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ExponentialHistogramBuckets <PositiveBuckets>k__BackingField;
    [CompilerGeneratedAttribute]
private ExponentialHistogramBuckets <NegativeBuckets>k__BackingField;
    public int Scale { get; internal set; }
    public long ZeroCount { get; internal set; }
    public ExponentialHistogramBuckets PositiveBuckets { get; private set; }
    internal ExponentialHistogramBuckets NegativeBuckets { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Scale();
    [CompilerGeneratedAttribute]
internal void set_Scale(int value);
    [CompilerGeneratedAttribute]
public long get_ZeroCount();
    [CompilerGeneratedAttribute]
internal void set_ZeroCount(long value);
    [CompilerGeneratedAttribute]
public ExponentialHistogramBuckets get_PositiveBuckets();
    [CompilerGeneratedAttribute]
private void set_PositiveBuckets(ExponentialHistogramBuckets value);
    [CompilerGeneratedAttribute]
internal ExponentialHistogramBuckets get_NegativeBuckets();
    [CompilerGeneratedAttribute]
private void set_NegativeBuckets(ExponentialHistogramBuckets value);
    internal ExponentialHistogramData Copy();
}
[FlagsAttribute]
public enum OpenTelemetry.Metrics.ExportModes : Enum {
    public byte value__;
    public static ExportModes Push;
    public static ExportModes Pull;
}
[AttributeUsageAttribute("4")]
public class OpenTelemetry.Metrics.ExportModesAttribute : Attribute {
    private ExportModes supportedExportModes;
    public ExportModes Supported { get; }
    public ExportModesAttribute(ExportModes supported);
    public ExportModes get_Supported();
}
internal abstract class OpenTelemetry.Metrics.FixedSizeExemplarReservoir : ExemplarReservoir {
    [NullableAttribute("1")]
private Exemplar[] runningExemplars;
    [NullableAttribute("1")]
private Exemplar[] snapshotExemplars;
    [CompilerGeneratedAttribute]
private int <Capacity>k__BackingField;
    public int Capacity { get; }
    protected FixedSizeExemplarReservoir(int capacity);
    [CompilerGeneratedAttribute]
public int get_Capacity();
    public sealed virtual ReadOnlyExemplarCollection Collect();
    [NullableContextAttribute("1")]
internal sealed virtual void Initialize(AggregatorStore aggregatorStore);
    internal void UpdateExemplar(int exemplarIndex, ExemplarMeasurement`1& measurement);
    protected virtual void OnCollected();
    protected void UpdateExemplar(int exemplarIndex, ExemplarMeasurement`1& measurement);
    protected void UpdateExemplar(int exemplarIndex, ExemplarMeasurement`1& measurement);
}
[IsReadOnlyAttribute]
public class OpenTelemetry.Metrics.HistogramBucket : ValueType {
    [CompilerGeneratedAttribute]
private double <ExplicitBound>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BucketCount>k__BackingField;
    public double ExplicitBound { get; }
    public long BucketCount { get; }
    internal HistogramBucket(double explicitBound, long bucketCount);
    [CompilerGeneratedAttribute]
public double get_ExplicitBound();
    [CompilerGeneratedAttribute]
public long get_BucketCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.HistogramBuckets : object {
    internal static int DefaultBoundaryCountForBinarySearch;
    [NullableAttribute("2")]
internal Double[] ExplicitBounds;
    internal HistogramBucketValues[] BucketCounts;
    internal double RunningSum;
    internal double SnapshotSum;
    internal double RunningMin;
    internal double SnapshotMin;
    internal double RunningMax;
    internal double SnapshotMax;
    [NullableAttribute("2")]
private BucketLookupNode bucketLookupTreeRoot;
    private Func`2<double, int> findHistogramBucketIndex;
    [NullableContextAttribute("2")]
internal HistogramBuckets(Double[] explicitBounds);
    public Enumerator GetEnumerator();
    internal HistogramBuckets Copy();
    internal int FindBucketIndex(double value);
    internal int FindBucketIndexBinary(double value);
    internal int FindBucketIndexLinear(double value);
    internal void Snapshot(bool outputDelta);
    [CompilerGeneratedAttribute]
internal static BucketLookupNode <.ctor>g__ConstructBalancedBST|11_0(Double[] values, int min, int max);
}
public class OpenTelemetry.Metrics.HistogramConfiguration : MetricStreamConfiguration {
    [CompilerGeneratedAttribute]
private bool <RecordMinMax>k__BackingField;
    public bool RecordMinMax { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RecordMinMax();
    [CompilerGeneratedAttribute]
public void set_RecordMinMax(bool value);
}
[NullableContextAttribute("2")]
public interface OpenTelemetry.Metrics.IPullMetricExporter {
    public Func`2<int, bool> Collect { get; public set; }
    public abstract virtual Func`2<int, bool> get_Collect();
    public abstract virtual void set_Collect(Func`2<int, bool> value);
}
internal class OpenTelemetry.Metrics.LookupData : object {
    public bool DeferredReclaim;
    public int Index;
    public Tags SortedTags;
    public Tags GivenTags;
    public LookupData(int index, Tags& sortedTags, Tags& givenTags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.MeterProviderBuilderBase : MeterProviderBuilder {
    private bool allowBuild;
    private MeterProviderServiceCollectionBuilder innerBuilder;
    [NullableAttribute("2")]
private MeterProvider OpenTelemetry.Metrics.IMeterProviderBuilder.Provider { get; }
    internal MeterProviderBuilderBase(IServiceCollection services);
    [NullableContextAttribute("2")]
private sealed virtual override MeterProvider OpenTelemetry.Metrics.IMeterProviderBuilder.get_Provider();
    public virtual MeterProviderBuilder AddInstrumentation(Func`1<TInstrumentation> instrumentationFactory);
    public virtual MeterProviderBuilder AddMeter(String[] names);
    private sealed virtual override MeterProviderBuilder OpenTelemetry.Metrics.IMeterProviderBuilder.ConfigureServices(Action`1<IServiceCollection> configure);
    private sealed virtual override MeterProviderBuilder OpenTelemetry.Metrics.IDeferredMeterProviderBuilder.Configure(Action`2<IServiceProvider, MeterProviderBuilder> configure);
    internal MeterProvider InvokeBuild();
    protected MeterProvider Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.Metrics.MeterProviderBuilderExtensions : object {
    [ExtensionAttribute]
public static MeterProviderBuilder AddReader(MeterProviderBuilder meterProviderBuilder, MetricReader reader);
    [ExtensionAttribute]
public static MeterProviderBuilder AddReader(MeterProviderBuilder meterProviderBuilder);
    [ExtensionAttribute]
public static MeterProviderBuilder AddReader(MeterProviderBuilder meterProviderBuilder, Func`2<IServiceProvider, MetricReader> implementationFactory);
    [ExtensionAttribute]
public static MeterProviderBuilder AddView(MeterProviderBuilder meterProviderBuilder, string instrumentName, string name);
    [ExtensionAttribute]
public static MeterProviderBuilder AddView(MeterProviderBuilder meterProviderBuilder, string instrumentName, MetricStreamConfiguration metricStreamConfiguration);
    [ExtensionAttribute]
public static MeterProviderBuilder AddView(MeterProviderBuilder meterProviderBuilder, Func`2<Instrument, MetricStreamConfiguration> viewConfig);
    [ExtensionAttribute]
public static MeterProviderBuilder SetMaxMetricStreams(MeterProviderBuilder meterProviderBuilder, int maxMetricStreams);
    [ExtensionAttribute]
public static MeterProviderBuilder SetMaxMetricPointsPerMetricStream(MeterProviderBuilder meterProviderBuilder, int maxMetricPointsPerMetricStream);
    [ExtensionAttribute]
public static MeterProviderBuilder SetResourceBuilder(MeterProviderBuilder meterProviderBuilder, ResourceBuilder resourceBuilder);
    [ExtensionAttribute]
public static MeterProviderBuilder ConfigureResource(MeterProviderBuilder meterProviderBuilder, Action`1<ResourceBuilder> configure);
    [ExtensionAttribute]
public static MeterProvider Build(MeterProviderBuilder meterProviderBuilder);
    [ExtensionAttribute]
public static MeterProviderBuilder SetExemplarFilter(MeterProviderBuilder meterProviderBuilder, ExemplarFilterType exemplarFilter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.MeterProviderBuilderSdk : MeterProviderBuilder {
    public static int DefaultMetricLimit;
    public static int DefaultCardinalityLimit;
    private static string DefaultInstrumentationVersion;
    private IServiceProvider serviceProvider;
    [NullableAttribute("2")]
private MeterProviderSdk meterProvider;
    [CompilerGeneratedAttribute]
private static Regex <InstrumentNameRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<InstrumentationRegistration> <Instrumentation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ResourceBuilder <ResourceBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ExemplarFilterType> <ExemplarFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MetricReader> <Readers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <MeterSources>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<Func`2<Instrument, MetricStreamConfiguration>> <ViewConfigs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetricLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CardinalityLimit>k__BackingField;
    public static Regex InstrumentNameRegex { get; public set; }
    public List`1<InstrumentationRegistration> Instrumentation { get; }
    [NullableAttribute("2")]
public ResourceBuilder ResourceBuilder { get; private set; }
    public Nullable`1<ExemplarFilterType> ExemplarFilter { get; private set; }
    [NullableAttribute("2")]
public MeterProvider Provider { get; }
    public List`1<MetricReader> Readers { get; }
    public List`1<string> MeterSources { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<Func`2<Instrument, MetricStreamConfiguration>> ViewConfigs { get; }
    public int MetricLimit { get; private set; }
    public int CardinalityLimit { get; private set; }
    public MeterProviderBuilderSdk(IServiceProvider serviceProvider);
    private static MeterProviderBuilderSdk();
    [CompilerGeneratedAttribute]
public static Regex get_InstrumentNameRegex();
    [CompilerGeneratedAttribute]
public static void set_InstrumentNameRegex(Regex value);
    [CompilerGeneratedAttribute]
public List`1<InstrumentationRegistration> get_Instrumentation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ResourceBuilder get_ResourceBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ResourceBuilder(ResourceBuilder value);
    [CompilerGeneratedAttribute]
public Nullable`1<ExemplarFilterType> get_ExemplarFilter();
    [CompilerGeneratedAttribute]
private void set_ExemplarFilter(Nullable`1<ExemplarFilterType> value);
    [NullableContextAttribute("2")]
public sealed virtual MeterProvider get_Provider();
    [CompilerGeneratedAttribute]
public List`1<MetricReader> get_Readers();
    [CompilerGeneratedAttribute]
public List`1<string> get_MeterSources();
    [CompilerGeneratedAttribute]
public List`1<Func`2<Instrument, MetricStreamConfiguration>> get_ViewConfigs();
    [CompilerGeneratedAttribute]
public int get_MetricLimit();
    [CompilerGeneratedAttribute]
private void set_MetricLimit(int value);
    [CompilerGeneratedAttribute]
public int get_CardinalityLimit();
    [CompilerGeneratedAttribute]
private void set_CardinalityLimit(int value);
    public static bool IsValidInstrumentName(string instrumentName);
    public static bool IsValidViewName(string customViewName);
    public void RegisterProvider(MeterProviderSdk meterProvider);
    public virtual MeterProviderBuilder AddInstrumentation(Func`1<TInstrumentation> instrumentationFactory);
    public MeterProviderBuilder AddInstrumentation(string instrumentationName, string instrumentationVersion, object instrumentation);
    public MeterProviderBuilder ConfigureResource(Action`1<ResourceBuilder> configure);
    public MeterProviderBuilder SetResourceBuilder(ResourceBuilder resourceBuilder);
    public MeterProviderBuilder SetExemplarFilter(ExemplarFilterType exemplarFilter);
    public virtual MeterProviderBuilder AddMeter(String[] names);
    public MeterProviderBuilder AddReader(MetricReader reader);
    public MeterProviderBuilder AddView(Func`2<Instrument, MetricStreamConfiguration> viewConfig);
    public MeterProviderBuilder SetMetricLimit(int metricLimit);
    public MeterProviderBuilder SetDefaultCardinalityLimit(int cardinalityLimit);
    public MeterProviderBuilder ConfigureBuilder(Action`2<IServiceProvider, MeterProviderBuilder> configure);
    public sealed virtual MeterProviderBuilder ConfigureServices(Action`1<IServiceCollection> configure);
    private sealed virtual override MeterProviderBuilder OpenTelemetry.Metrics.IDeferredMeterProviderBuilder.Configure(Action`2<IServiceProvider, MeterProviderBuilder> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.Metrics.MeterProviderExtensions : object {
    [ExtensionAttribute]
public static bool ForceFlush(MeterProvider provider, int timeoutMilliseconds);
    [ExtensionAttribute]
public static bool Shutdown(MeterProvider provider, int timeoutMilliseconds);
    [ExtensionAttribute]
internal static bool TryFindExporter(MeterProvider provider, T& exporter);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryFindExporter>g__TryFindExporter|2_0(MetricReader reader, T& exporter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.MeterProviderSdk : MeterProvider {
    internal static string EmitOverFlowAttributeConfigKey;
    internal static string ReclaimUnusedMetricPointsConfigKey;
    internal static string ExemplarFilterConfigKey;
    internal static string ExemplarFilterHistogramsConfigKey;
    internal IServiceProvider ServiceProvider;
    [NullableAttribute("2")]
internal IDisposable OwnedServiceProvider;
    internal int ShutdownCount;
    internal bool Disposed;
    internal bool EmitOverflowAttribute;
    internal bool ReclaimUnusedMetricPoints;
    internal Nullable`1<ExemplarFilterType> ExemplarFilter;
    internal Nullable`1<ExemplarFilterType> ExemplarFilterForHistograms;
    [NullableAttribute("2")]
internal Action OnCollectObservableInstruments;
    private List`1<object> instrumentations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Func`2<Instrument, MetricStreamConfiguration>> viewConfigs;
    private object collectLock;
    private MeterListener listener;
    [NullableAttribute("2")]
private MetricReader reader;
    [NullableAttribute("2")]
private CompositeMetricReader compositeMetricReader;
    private Func`2<Instrument, bool> shouldListenTo;
    [CompilerGeneratedAttribute]
private Resource <Resource>k__BackingField;
    internal Resource Resource { get; }
    internal List`1<object> Instrumentations { get; }
    [NullableAttribute("2")]
internal MetricReader Reader { get; }
    internal int ViewCount { get; }
    internal MeterProviderSdk(IServiceProvider serviceProvider, bool ownsServiceProvider);
    [CompilerGeneratedAttribute]
internal Resource get_Resource();
    internal List`1<object> get_Instrumentations();
    [NullableContextAttribute("2")]
internal MetricReader get_Reader();
    internal int get_ViewCount();
    internal static void MeasurementsCompleted(Instrument instrument, object state);
    internal static void MeasurementRecordedLong(Instrument instrument, long value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, object state);
    internal static void MeasurementRecordedDouble(Instrument instrument, double value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, object state);
    internal object InstrumentPublished(Instrument instrument, bool listeningIsManagedExternally);
    internal void CollectObservableInstruments();
    internal bool OnForceFlush(int timeoutMilliseconds);
    internal bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
    private void ApplySpecificationConfigurationKeys(IConfiguration configuration);
    [CompilerGeneratedAttribute]
private void <.ctor>b__20_1(Instrument instrument, MeterListener listener);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <ApplySpecificationConfigurationKeys>g__TryParseExemplarFilterFromConfigurationValue|38_0(string configValue, Nullable`1& exemplarFilter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.Metric : object {
    internal static int DefaultExponentialHistogramMaxBuckets;
    internal static int DefaultExponentialHistogramMaxScale;
    internal static Double[] DefaultHistogramBounds;
    internal static Double[] DefaultHistogramBoundsShortSeconds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HashSet`1<ValueTuple`2<string, string>> DefaultHistogramBoundShortMappings;
    internal static Double[] DefaultHistogramBoundsLongSeconds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HashSet`1<ValueTuple`2<string, string>> DefaultHistogramBoundLongMappings;
    internal AggregatorStore AggregatorStore;
    [CompilerGeneratedAttribute]
private MetricType <MetricType>k__BackingField;
    [CompilerGeneratedAttribute]
private AggregationTemporality <Temporality>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStreamIdentity <InstrumentIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Active>k__BackingField;
    public MetricType MetricType { get; private set; }
    public AggregationTemporality Temporality { get; private set; }
    public string Name { get; }
    public string Description { get; }
    public string Unit { get; }
    public string MeterName { get; }
    public string MeterVersion { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> MeterTags { get; }
    internal MetricStreamIdentity InstrumentIdentity { get; private set; }
    internal bool Active { get; internal set; }
    [NullableContextAttribute("2")]
internal Metric(MetricStreamIdentity instrumentIdentity, AggregationTemporality temporality, int cardinalityLimit, bool emitOverflowAttribute, bool shouldReclaimUnusedMetricPoints, Nullable`1<ExemplarFilterType> exemplarFilter, Func`1<ExemplarReservoir> exemplarReservoirFactory);
    private static Metric();
    [CompilerGeneratedAttribute]
public MetricType get_MetricType();
    [CompilerGeneratedAttribute]
private void set_MetricType(MetricType value);
    [CompilerGeneratedAttribute]
public AggregationTemporality get_Temporality();
    [CompilerGeneratedAttribute]
private void set_Temporality(AggregationTemporality value);
    public string get_Name();
    public string get_Description();
    public string get_Unit();
    public string get_MeterName();
    public string get_MeterVersion();
    public IEnumerable`1<KeyValuePair`2<string, object>> get_MeterTags();
    [CompilerGeneratedAttribute]
internal MetricStreamIdentity get_InstrumentIdentity();
    [CompilerGeneratedAttribute]
private void set_InstrumentIdentity(MetricStreamIdentity value);
    [CompilerGeneratedAttribute]
internal bool get_Active();
    [CompilerGeneratedAttribute]
internal void set_Active(bool value);
    public MetricPointsAccessor GetMetricPoints();
    internal void UpdateLong(long value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    internal void UpdateDouble(double value, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags);
    internal int Snapshot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.MetricPoint : ValueType {
    internal int ReferenceCount;
    private static int DefaultSimpleReservoirPoolSize;
    private AggregatorStore aggregatorStore;
    private AggregationType aggType;
    [NullableAttribute("2")]
private MetricPointOptionalComponents mpComponents;
    private MetricPointValueStorage runningValue;
    private MetricPointValueStorage snapshotValue;
    private MetricPointValueStorage deltaLastValue;
    [CompilerGeneratedAttribute]
private ReadOnlyTagCollection <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricPointStatus <MetricPointStatus>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private LookupData <LookupData>k__BackingField;
    public ReadOnlyTagCollection Tags { get; }
    public DateTimeOffset StartTime { get; }
    public DateTimeOffset EndTime { get; }
    internal MetricPointStatus MetricPointStatus { get; private set; }
    [NullableAttribute("2")]
internal LookupData LookupData { get; private set; }
    internal bool IsInitialized { get; }
    internal MetricPoint(AggregatorStore aggregatorStore, AggregationType aggType, KeyValuePair`2[] tagKeysAndValues, Double[] histogramExplicitBounds, int exponentialHistogramMaxSize, int exponentialHistogramMaxScale, LookupData lookupData);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlyTagCollection get_Tags();
    [IsReadOnlyAttribute]
public DateTimeOffset get_StartTime();
    [IsReadOnlyAttribute]
public DateTimeOffset get_EndTime();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal MetricPointStatus get_MetricPointStatus();
    [CompilerGeneratedAttribute]
private void set_MetricPointStatus(MetricPointStatus value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal LookupData get_LookupData();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_LookupData(LookupData value);
    [IsReadOnlyAttribute]
internal bool get_IsInitialized();
    [IsReadOnlyAttribute]
public long GetSumLong();
    [IsReadOnlyAttribute]
public double GetSumDouble();
    [IsReadOnlyAttribute]
public long GetGaugeLastValueLong();
    [IsReadOnlyAttribute]
public double GetGaugeLastValueDouble();
    [IsReadOnlyAttribute]
public long GetHistogramCount();
    [IsReadOnlyAttribute]
public double GetHistogramSum();
    [IsReadOnlyAttribute]
public HistogramBuckets GetHistogramBuckets();
    public ExponentialHistogramData GetExponentialHistogramData();
    [IsReadOnlyAttribute]
public bool TryGetHistogramMinMaxValues(Double& min, Double& max);
    [IsReadOnlyAttribute]
public bool TryGetExemplars(ReadOnlyExemplarCollection& exemplars);
    [IsReadOnlyAttribute]
internal MetricPoint Copy();
    internal void Update(long number);
    internal void UpdateWithExemplar(long number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    internal void Update(double number);
    internal void UpdateWithExemplar(double number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    internal void TakeSnapshot(bool outputDelta);
    internal void TakeSnapshotWithExemplar(bool outputDelta);
    internal void NullifyMetricPointState();
    private void UpdateHistogram(double number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    private void UpdateHistogramWithMinMax(double number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    private void UpdateHistogramWithBuckets(double number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    private void UpdateHistogramWithBucketsAndMinMax(double number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    private void UpdateBase2ExponentialHistogram(double number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    private void UpdateBase2ExponentialHistogramWithMinMax(double number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    [IsReadOnlyAttribute]
private void UpdateExemplar(long number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar);
    [IsReadOnlyAttribute]
private void UpdateExemplar(double number, ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, bool offerExemplar, int explicitBucketHistogramBucketIndex);
    private void CompleteUpdate();
    private void CompleteUpdateWithoutMeasurement();
    [IsReadOnlyAttribute]
private void ThrowNotSupportedMetricTypeException(string methodName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.MetricPointOptionalComponents : object {
    public HistogramBuckets HistogramBuckets;
    public Base2ExponentialBucketHistogram Base2ExponentialBucketHistogram;
    public ExemplarReservoir ExemplarReservoir;
    public ReadOnlyExemplarCollection Exemplars;
    private int isCriticalSectionOccupied;
    [NullableContextAttribute("1")]
public MetricPointOptionalComponents Copy();
    public void AcquireLock();
    public void ReleaseLock();
    private void AcquireLockRare();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class OpenTelemetry.Metrics.MetricPointsAccessor : ValueType {
    private MetricPoint[] metricsPoints;
    private Int32[] metricPointsToProcess;
    private long targetCount;
    internal MetricPointsAccessor(MetricPoint[] metricsPoints, Int32[] metricPointsToProcess, long targetCount);
    public Enumerator GetEnumerator();
}
internal enum OpenTelemetry.Metrics.MetricPointStatus : Enum {
    public int value__;
    public static MetricPointStatus NoCollectPending;
    public static MetricPointStatus CollectPending;
}
internal class OpenTelemetry.Metrics.MetricPointValueStorage : ValueType {
    public long AsLong;
    public double AsDouble;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class OpenTelemetry.Metrics.MetricReader : object {
    private static MetricReaderTemporalityPreference MetricReaderTemporalityPreferenceUnspecified;
    private static Func`2<Type, AggregationTemporality> CumulativeTemporalityPreferenceFunc;
    private static Func`2<Type, AggregationTemporality> MonotonicDeltaTemporalityPreferenceFunc;
    private object newTaskLock;
    private object onCollectLock;
    private TaskCompletionSource`1<bool> shutdownTcs;
    private MetricReaderTemporalityPreference temporalityPreference;
    private Func`2<Type, AggregationTemporality> temporalityFunc;
    private int shutdownCount;
    [NullableAttribute("2")]
private TaskCompletionSource`1<bool> collectionTcs;
    [NullableAttribute("2")]
private BaseProvider parentProvider;
    private HashSet`1<string> metricStreamNames;
    private ConcurrentDictionary`2<MetricStreamIdentity, Metric> instrumentIdentityToMetric;
    private object instrumentCreationLock;
    private int metricLimit;
    private int cardinalityLimit;
    [NullableAttribute("2")]
private Metric[] metrics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Metric[] metricsCurrentBatch;
    private int metricIndex;
    private bool emitOverflowAttribute;
    private bool reclaimUnusedMetricPoints;
    private Nullable`1<ExemplarFilterType> exemplarFilter;
    private Nullable`1<ExemplarFilterType> exemplarFilterForHistograms;
    public MetricReaderTemporalityPreference TemporalityPreference { get; public set; }
    private static MetricReader();
    public MetricReaderTemporalityPreference get_TemporalityPreference();
    public void set_TemporalityPreference(MetricReaderTemporalityPreference value);
    public bool Collect(int timeoutMilliseconds);
    public bool Shutdown(int timeoutMilliseconds);
    public sealed virtual void Dispose();
    internal virtual void SetParentProvider(BaseProvider parentProvider);
    internal virtual bool ProcessMetrics(Batch`1& modreq(System.Runtime.InteropServices.InAttribute) metrics, int timeoutMilliseconds);
    protected virtual bool OnCollect(int timeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
    internal static void DeactivateMetric(Metric metric);
    internal AggregationTemporality GetAggregationTemporality(Type instrumentType);
    internal virtual List`1<Metric> AddMetricWithNoViews(Instrument instrument);
    internal virtual List`1<Metric> AddMetricWithViews(Instrument instrument, List`1<MetricStreamConfiguration> metricStreamConfigs);
    internal void ApplyParentProviderSettings(int metricLimit, int cardinalityLimit, bool emitOverflowAttribute, bool reclaimUnusedMetricPoints, Nullable`1<ExemplarFilterType> exemplarFilter, Nullable`1<ExemplarFilterType> exemplarFilterForHistograms);
    [NullableContextAttribute("2")]
private bool TryGetExistingMetric(MetricStreamIdentity& metricStreamIdentity, Metric& existingMetric);
    private void CreateOrUpdateMetricStreamRegistration(MetricStreamIdentity& metricStreamIdentity);
    private Batch`1<Metric> GetMetricsBatch();
    [NullableContextAttribute("2")]
private void RemoveMetric(Metric& metric);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.MetricReaderOptions : object {
    private PeriodicExportingMetricReaderOptions periodicExportingMetricReaderOptions;
    [CompilerGeneratedAttribute]
private MetricReaderTemporalityPreference <TemporalityPreference>k__BackingField;
    public MetricReaderTemporalityPreference TemporalityPreference { get; public set; }
    public PeriodicExportingMetricReaderOptions PeriodicExportingMetricReaderOptions { get; public set; }
    internal MetricReaderOptions(PeriodicExportingMetricReaderOptions defaultPeriodicExportingMetricReaderOptions);
    [CompilerGeneratedAttribute]
public MetricReaderTemporalityPreference get_TemporalityPreference();
    [CompilerGeneratedAttribute]
public void set_TemporalityPreference(MetricReaderTemporalityPreference value);
    public PeriodicExportingMetricReaderOptions get_PeriodicExportingMetricReaderOptions();
    public void set_PeriodicExportingMetricReaderOptions(PeriodicExportingMetricReaderOptions value);
}
public enum OpenTelemetry.Metrics.MetricReaderTemporalityPreference : Enum {
    public int value__;
    public static MetricReaderTemporalityPreference Cumulative;
    public static MetricReaderTemporalityPreference Delta;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.MetricState : object {
    public Action CompleteMeasurement;
    public RecordMeasurementAction`1<long> RecordMeasurementLong;
    public RecordMeasurementAction`1<double> RecordMeasurementDouble;
    private MetricState(Action completeMeasurement, RecordMeasurementAction`1<long> recordMeasurementLong, RecordMeasurementAction`1<double> recordMeasurementDouble);
    public static MetricState BuildForSingleMetric(Metric metric);
    public static MetricState BuildForMetricList(List`1<Metric> metrics);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.MetricStreamConfiguration : object {
    private string name;
    private Nullable`1<int> cardinalityLimit;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static MetricStreamConfiguration <Drop>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<ExemplarReservoir> <ExemplarReservoirFactory>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <CopiedTagKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ViewId>k__BackingField;
    [NullableAttribute("1")]
public static MetricStreamConfiguration Drop { get; }
    public string Name { get; public set; }
    public string Description { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] TagKeys { get; public set; }
    internal Nullable`1<int> CardinalityLimit { get; internal set; }
    internal Func`1<ExemplarReservoir> ExemplarReservoirFactory { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] CopiedTagKeys { get; private set; }
    internal Nullable`1<int> ViewId { get; internal set; }
    private static MetricStreamConfiguration();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static MetricStreamConfiguration get_Drop();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public String[] get_TagKeys();
    public void set_TagKeys(String[] value);
    internal Nullable`1<int> get_CardinalityLimit();
    internal void set_CardinalityLimit(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
internal Func`1<ExemplarReservoir> get_ExemplarReservoirFactory();
    [CompilerGeneratedAttribute]
internal void set_ExemplarReservoirFactory(Func`1<ExemplarReservoir> value);
    [CompilerGeneratedAttribute]
internal String[] get_CopiedTagKeys();
    [CompilerGeneratedAttribute]
private void set_CopiedTagKeys(String[] value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_ViewId();
    [CompilerGeneratedAttribute]
internal void set_ViewId(Nullable`1<int> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class OpenTelemetry.Metrics.MetricStreamIdentity : ValueType {
    private static StringArrayEqualityComparer StringArrayComparer;
    private int hashCode;
    [CompilerGeneratedAttribute]
private string <MeterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MeterVersion>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <MeterTags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstrumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Unit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <InstrumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ViewId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetricStreamName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <TagKeys>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Double[] <HistogramBucketBounds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExponentialHistogramMaxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExponentialHistogramMaxScale>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HistogramRecordMinMax>k__BackingField;
    public string MeterName { get; }
    public string MeterVersion { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> MeterTags { get; }
    public string InstrumentName { get; }
    public string Unit { get; }
    public string Description { get; }
    public Type InstrumentType { get; }
    public Nullable`1<int> ViewId { get; }
    public string MetricStreamName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] TagKeys { get; }
    [NullableAttribute("2")]
public Double[] HistogramBucketBounds { get; }
    public int ExponentialHistogramMaxSize { get; }
    public int ExponentialHistogramMaxScale { get; }
    public bool HistogramRecordMinMax { get; }
    public bool IsHistogram { get; }
    public MetricStreamIdentity(Instrument instrument, MetricStreamConfiguration metricStreamConfiguration);
    private static MetricStreamIdentity();
    [CompilerGeneratedAttribute]
public string get_MeterName();
    [CompilerGeneratedAttribute]
public string get_MeterVersion();
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_MeterTags();
    [CompilerGeneratedAttribute]
public string get_InstrumentName();
    [CompilerGeneratedAttribute]
public string get_Unit();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public Type get_InstrumentType();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ViewId();
    [CompilerGeneratedAttribute]
public string get_MetricStreamName();
    [CompilerGeneratedAttribute]
public String[] get_TagKeys();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Double[] get_HistogramBucketBounds();
    [CompilerGeneratedAttribute]
public int get_ExponentialHistogramMaxSize();
    [CompilerGeneratedAttribute]
public int get_ExponentialHistogramMaxScale();
    [CompilerGeneratedAttribute]
public bool get_HistogramRecordMinMax();
    public bool get_IsHistogram();
    public static bool op_Equality(MetricStreamIdentity metricIdentity1, MetricStreamIdentity metricIdentity2);
    public static bool op_Inequality(MetricStreamIdentity metricIdentity1, MetricStreamIdentity metricIdentity2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MetricStreamIdentity other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
private static bool HistogramBoundsEqual(Double[] bounds1, Double[] bounds2);
}
[FlagsAttribute]
public enum OpenTelemetry.Metrics.MetricType : Enum {
    public byte value__;
    public static MetricType LongSum;
    public static MetricType DoubleSum;
    public static MetricType LongGauge;
    public static MetricType DoubleGauge;
    public static MetricType Histogram;
    public static MetricType ExponentialHistogram;
    public static MetricType LongSumNonMonotonic;
    public static MetricType DoubleSumNonMonotonic;
}
[ExtensionAttribute]
public static class OpenTelemetry.Metrics.MetricTypeExtensions : object {
    internal static MetricType METRIC_TYPE_MASK;
    internal static MetricType METRIC_TYPE_MONOTONIC_SUM;
    internal static MetricType METRIC_TYPE_GAUGE;
    internal static MetricType METRIC_TYPE_HISTOGRAM;
    internal static MetricType METRIC_TYPE_NON_MONOTONIC_SUM;
    internal static MetricType POINT_KIND_MASK;
    internal static MetricType POINT_KIND_I1;
    internal static MetricType POINT_KIND_U1;
    internal static MetricType POINT_KIND_I2;
    internal static MetricType POINT_KIND_U2;
    internal static MetricType POINT_KIND_I4;
    internal static MetricType POINT_KIND_U4;
    internal static MetricType POINT_KIND_I8;
    internal static MetricType POINT_KIND_U8;
    internal static MetricType POINT_KIND_R4;
    internal static MetricType POINT_KIND_R8;
    [ExtensionAttribute]
public static bool IsSum(MetricType self);
    [ExtensionAttribute]
public static bool IsGauge(MetricType self);
    [ExtensionAttribute]
public static bool IsHistogram(MetricType self);
    [ExtensionAttribute]
public static bool IsDouble(MetricType self);
    [ExtensionAttribute]
public static bool IsLong(MetricType self);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.OpenTelemetryMetricsListener : object {
    private MeterProviderSdk meterProviderSdk;
    [NullableAttribute("2")]
private IObservableInstrumentsSource observableInstrumentsSource;
    public string Name { get; }
    public OpenTelemetryMetricsListener(MeterProvider meterProvider);
    public sealed virtual string get_Name();
    public sealed virtual void Dispose();
    public sealed virtual MeasurementHandlers GetMeasurementHandlers();
    public sealed virtual bool InstrumentPublished(Instrument instrument, Object& userState);
    public sealed virtual void MeasurementsCompleted(Instrument instrument, object userState);
    public sealed virtual void Initialize(IObservableInstrumentsSource source);
    private void OnCollectObservableInstruments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.PeriodicExportingMetricReader : BaseExportingMetricReader {
    internal static int DefaultExportIntervalMilliseconds;
    internal static int DefaultExportTimeoutMilliseconds;
    internal int ExportIntervalMilliseconds;
    internal int ExportTimeoutMilliseconds;
    private Thread exporterThread;
    private AutoResetEvent exportTrigger;
    private ManualResetEvent shutdownTrigger;
    private bool disposed;
    public PeriodicExportingMetricReader(BaseExporter`1<Metric> exporter, int exportIntervalMilliseconds, int exportTimeoutMilliseconds);
    protected virtual bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
    private void ExporterProc();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Metrics.PeriodicExportingMetricReaderOptions : object {
    internal static string OTelMetricExportIntervalEnvVarKey;
    internal static string OTelMetricExportTimeoutEnvVarKey;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExportIntervalMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExportTimeoutMilliseconds>k__BackingField;
    public Nullable`1<int> ExportIntervalMilliseconds { get; public set; }
    public Nullable`1<int> ExportTimeoutMilliseconds { get; public set; }
    internal PeriodicExportingMetricReaderOptions(IConfiguration configuration);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExportIntervalMilliseconds();
    [CompilerGeneratedAttribute]
public void set_ExportIntervalMilliseconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExportTimeoutMilliseconds();
    [CompilerGeneratedAttribute]
public void set_ExportTimeoutMilliseconds(Nullable`1<int> value);
}
internal class OpenTelemetry.Metrics.PullMetricScope : object {
    [NullableAttribute("1")]
private static RuntimeContextSlot`1<bool> Slot;
    private bool previousValue;
    private bool disposed;
    internal static bool IsPullAllowed { get; }
    internal PullMetricScope(bool value);
    private static PullMetricScope();
    internal static bool get_IsPullAllowed();
    [NullableContextAttribute("1")]
public static IDisposable Begin(bool value);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class OpenTelemetry.Metrics.ReadOnlyExemplarCollection : ValueType {
    internal static ReadOnlyExemplarCollection Empty;
    private Exemplar[] exemplars;
    internal int MaximumCount { get; }
    internal ReadOnlyExemplarCollection(Exemplar[] exemplars);
    private static ReadOnlyExemplarCollection();
    internal int get_MaximumCount();
    public Enumerator GetEnumerator();
    internal ReadOnlyExemplarCollection Copy();
    internal IReadOnlyList`1<Exemplar> ToReadOnlyList();
}
internal class OpenTelemetry.Metrics.SimpleFixedSizeExemplarReservoir : FixedSizeExemplarReservoir {
    private static int DefaultMeasurementState;
    private int measurementState;
    public SimpleFixedSizeExemplarReservoir(int poolSize);
    public virtual void Offer(ExemplarMeasurement`1& modreq(System.Runtime.InteropServices.InAttribute) measurement);
    public virtual void Offer(ExemplarMeasurement`1& modreq(System.Runtime.InteropServices.InAttribute) measurement);
    protected virtual void OnCollected();
    private void Offer(ExemplarMeasurement`1& measurement);
}
internal class OpenTelemetry.Metrics.StringArrayEqualityComparer : object {
    public sealed virtual bool Equals(String[] strings1, String[] strings2);
    [NullableContextAttribute("1")]
public sealed virtual int GetHashCode(String[] strings);
}
[IsReadOnlyAttribute]
internal class OpenTelemetry.Metrics.Tags : ValueType {
    public static Tags EmptyTags;
    private int hashCode;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private KeyValuePair`2[] <KeyValuePairs>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2[] KeyValuePairs { get; }
    public Tags(KeyValuePair`2[] keyValuePairs);
    private static Tags();
    [CompilerGeneratedAttribute]
public KeyValuePair`2[] get_KeyValuePairs();
    public static bool op_Equality(Tags tag1, Tags tag2);
    public static bool op_Inequality(Tags tag1, Tags tag2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Tags other);
    public virtual int GetHashCode();
    private static int ComputeHashCode(KeyValuePair`2[] keyValuePairs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Metrics.ThreadStaticStorage : object {
    internal static int MaxTagCacheSize;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static ThreadStaticStorage storage;
    private TagStorage[] primaryTagStorage;
    private TagStorage[] secondaryTagStorage;
    internal static ThreadStaticStorage GetStorage();
    internal void SplitToKeysAndValues(ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, int tagLength, KeyValuePair`2[]& tagKeysAndValues);
    internal void SplitToKeysAndValues(ReadOnlySpan`1<KeyValuePair`2<string, object>> tags, int tagLength, HashSet`1<string> tagKeysInteresting, KeyValuePair`2[]& tagKeysAndValues, Int32& actualLength);
    internal void CloneKeysAndValues(KeyValuePair`2[] inputTagKeysAndValues, int tagLength, KeyValuePair`2[]& clonedTagKeysAndValues);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.OpenTelemetryBuilderSdkExtensions : object {
    [ExtensionAttribute]
public static IOpenTelemetryBuilder ConfigureResource(IOpenTelemetryBuilder builder, Action`1<ResourceBuilder> configure);
    [ExtensionAttribute]
public static IOpenTelemetryBuilder WithMetrics(IOpenTelemetryBuilder builder);
    [ExtensionAttribute]
public static IOpenTelemetryBuilder WithMetrics(IOpenTelemetryBuilder builder, Action`1<MeterProviderBuilder> configure);
    [ExtensionAttribute]
public static IOpenTelemetryBuilder WithTracing(IOpenTelemetryBuilder builder);
    [ExtensionAttribute]
public static IOpenTelemetryBuilder WithTracing(IOpenTelemetryBuilder builder, Action`1<TracerProviderBuilder> configure);
    [ExtensionAttribute]
public static IOpenTelemetryBuilder WithLogging(IOpenTelemetryBuilder builder);
    [ExtensionAttribute]
public static IOpenTelemetryBuilder WithLogging(IOpenTelemetryBuilder builder, Action`1<LoggerProviderBuilder> configure);
    [ExtensionAttribute]
public static IOpenTelemetryBuilder WithLogging(IOpenTelemetryBuilder builder, Action`1<LoggerProviderBuilder> configureBuilder, Action`1<OpenTelemetryLoggerOptions> configureOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.ProviderExtensions : object {
    [ExtensionAttribute]
public static Resource GetResource(BaseProvider baseProvider);
    [ExtensionAttribute]
public static Resource GetDefaultResource(BaseProvider baseProvider);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static IServiceProvider GetServiceProvider(BaseProvider baseProvider);
}
[IsReadOnlyAttribute]
public class OpenTelemetry.ReadOnlyFilteredTagCollection : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> excludedKeys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyValuePair`2[] tags;
    private int count;
    internal int MaximumCount { get; }
    internal ReadOnlyFilteredTagCollection(HashSet`1<string> excludedKeys, KeyValuePair`2[] tags, int count);
    internal int get_MaximumCount();
    public Enumerator GetEnumerator();
    internal IReadOnlyList`1<KeyValuePair`2<string, object>> ToReadOnlyList();
}
[IsReadOnlyAttribute]
public class OpenTelemetry.ReadOnlyTagCollection : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal KeyValuePair`2[] KeyAndValues;
    public int Count { get; }
    internal ReadOnlyTagCollection(KeyValuePair`2[] keyAndValues);
    public int get_Count();
    public Enumerator GetEnumerator();
}
[NullableContextAttribute("1")]
public interface OpenTelemetry.Resources.IResourceDetector {
    public abstract virtual Resource Detect();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Resources.OtelEnvResourceDetector : object {
    public static string EnvVarKey;
    private static char AttributeListSplitter;
    private static char AttributeKeyValueSplitter;
    private IConfiguration configuration;
    public OtelEnvResourceDetector(IConfiguration configuration);
    public sealed virtual Resource Detect();
    private static IEnumerable`1<KeyValuePair`2<string, object>> ParseResourceAttributes(string resourceAttributes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Resources.OtelServiceNameEnvVarDetector : object {
    public static string EnvVarKey;
    private IConfiguration configuration;
    public OtelServiceNameEnvVarDetector(IConfiguration configuration);
    public sealed virtual Resource Detect();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Resources.Resource : object {
    [CompilerGeneratedAttribute]
private static Resource <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <Attributes>k__BackingField;
    public static Resource Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Attributes { get; }
    public Resource(IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    private static Resource();
    [CompilerGeneratedAttribute]
public static Resource get_Empty();
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_Attributes();
    public Resource Merge(Resource other);
    private static KeyValuePair`2<string, object> SanitizeAttribute(KeyValuePair`2<string, object> attribute);
    private static object SanitizeValue(object value, string keyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Resources.ResourceBuilder : object {
    internal List`1<IResourceDetector> ResourceDetectors;
    private static Resource DefaultResource;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IServiceProvider <ServiceProvider>k__BackingField;
    [NullableAttribute("2")]
internal IServiceProvider ServiceProvider { get; internal set; }
    private static ResourceBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IServiceProvider get_ServiceProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ServiceProvider(IServiceProvider value);
    public static ResourceBuilder CreateDefault();
    public static ResourceBuilder CreateEmpty();
    public ResourceBuilder Clear();
    public Resource Build();
    public ResourceBuilder AddDetector(IResourceDetector resourceDetector);
    public ResourceBuilder AddDetector(Func`2<IServiceProvider, IResourceDetector> resourceDetectorFactory);
    internal ResourceBuilder AddDetectorInternal(Func`2<IServiceProvider, IResourceDetector> resourceDetectorFactory);
    internal ResourceBuilder AddResource(Resource resource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.Resources.ResourceBuilderExtensions : object {
    private static string InstanceId;
    [CompilerGeneratedAttribute]
private static Resource <TelemetryResource>k__BackingField;
    private static Resource TelemetryResource { get; }
    private static ResourceBuilderExtensions();
    [CompilerGeneratedAttribute]
private static Resource get_TelemetryResource();
    [ExtensionAttribute]
public static ResourceBuilder AddService(ResourceBuilder resourceBuilder, string serviceName, string serviceNamespace, string serviceVersion, bool autoGenerateServiceInstanceId, string serviceInstanceId);
    [ExtensionAttribute]
public static ResourceBuilder AddTelemetrySdk(ResourceBuilder resourceBuilder);
    [ExtensionAttribute]
public static ResourceBuilder AddAttributes(ResourceBuilder resourceBuilder, IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    [ExtensionAttribute]
public static ResourceBuilder AddEnvironmentVariableDetector(ResourceBuilder resourceBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class OpenTelemetry.Resources.ResourceSemanticConventions : object {
    public static string AttributeServiceName;
    public static string AttributeServiceNamespace;
    public static string AttributeServiceInstance;
    public static string AttributeServiceVersion;
    public static string AttributeTelemetrySdkName;
    public static string AttributeTelemetrySdkLanguage;
    public static string AttributeTelemetrySdkVersion;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class OpenTelemetry.Sdk : object {
    [CompilerGeneratedAttribute]
private static string <InformationalVersion>k__BackingField;
    public static bool SuppressInstrumentation { get; }
    internal static string InformationalVersion { get; }
    private static Sdk();
    public static bool get_SuppressInstrumentation();
    [CompilerGeneratedAttribute]
internal static string get_InformationalVersion();
    public static void SetDefaultTextMapPropagator(TextMapPropagator textMapPropagator);
    public static MeterProviderBuilder CreateMeterProviderBuilder();
    public static TracerProviderBuilder CreateTracerProviderBuilder();
    internal static LoggerProviderBuilder CreateLoggerProviderBuilder();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class OpenTelemetry.SimpleActivityExportProcessor : SimpleExportProcessor`1<Activity> {
    public SimpleActivityExportProcessor(BaseExporter`1<Activity> exporter);
    public virtual void OnEnd(Activity data);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class OpenTelemetry.SimpleExportProcessor`1 : BaseExportProcessor`1<T> {
    private object syncObject;
    protected SimpleExportProcessor`1(BaseExporter`1<T> exporter);
    protected virtual void OnExport(T data);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class OpenTelemetry.SimpleLogRecordExportProcessor : SimpleExportProcessor`1<LogRecord> {
    public SimpleLogRecordExportProcessor(BaseExporter`1<LogRecord> exporter);
}
public class OpenTelemetry.SuppressInstrumentationScope : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static RuntimeContextSlot`1<SuppressInstrumentationScope> Slot;
    [NullableAttribute("2")]
private SuppressInstrumentationScope previousScope;
    private bool disposed;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    internal static bool IsSuppressed { get; }
    internal int Depth { get; private set; }
    internal SuppressInstrumentationScope(bool value);
    private static SuppressInstrumentationScope();
    internal static bool get_IsSuppressed();
    [CompilerGeneratedAttribute]
internal int get_Depth();
    [CompilerGeneratedAttribute]
private void set_Depth(int value);
    [NullableContextAttribute("1")]
public static IDisposable Begin(bool value);
    public static int Enter();
    public sealed virtual void Dispose();
    internal static int IncrementIfTriggered();
    internal static int DecrementIfTriggered();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Trace.ActivityExportProcessorOptions : object {
    private BatchExportActivityProcessorOptions batchExportProcessorOptions;
    [CompilerGeneratedAttribute]
private ExportProcessorType <ExportProcessorType>k__BackingField;
    public ExportProcessorType ExportProcessorType { get; public set; }
    public BatchExportActivityProcessorOptions BatchExportProcessorOptions { get; public set; }
    internal ActivityExportProcessorOptions(BatchExportActivityProcessorOptions defaultBatchExportActivityProcessorOptions);
    [CompilerGeneratedAttribute]
public ExportProcessorType get_ExportProcessorType();
    [CompilerGeneratedAttribute]
public void set_ExportProcessorType(ExportProcessorType value);
    public BatchExportActivityProcessorOptions get_BatchExportProcessorOptions();
    public void set_BatchExportProcessorOptions(BatchExportActivityProcessorOptions value);
}
public class OpenTelemetry.Trace.AlwaysOffSampler : Sampler {
    public virtual SamplingResult ShouldSample(SamplingParameters& modreq(System.Runtime.InteropServices.InAttribute) samplingParameters);
}
public class OpenTelemetry.Trace.AlwaysOnSampler : Sampler {
    public virtual SamplingResult ShouldSample(SamplingParameters& modreq(System.Runtime.InteropServices.InAttribute) samplingParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class OpenTelemetry.Trace.BatchExportActivityProcessorOptions : BatchExportProcessorOptions`1<Activity> {
    internal static string MaxQueueSizeEnvVarKey;
    internal static string MaxExportBatchSizeEnvVarKey;
    internal static string ExporterTimeoutEnvVarKey;
    internal static string ScheduledDelayEnvVarKey;
    internal BatchExportActivityProcessorOptions(IConfiguration configuration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class OpenTelemetry.Trace.ExceptionProcessor : BaseProcessor`1<Activity> {
    private static string ExceptionPointersKey;
    private Func`1<IntPtr> fnGetExceptionPointers;
    public virtual void OnStart(Activity activity);
    public virtual void OnEnd(Activity activity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Trace.ParentBasedSampler : Sampler {
    private Sampler rootSampler;
    private Sampler remoteParentSampled;
    private Sampler remoteParentNotSampled;
    private Sampler localParentSampled;
    private Sampler localParentNotSampled;
    public ParentBasedSampler(Sampler rootSampler);
    [NullableContextAttribute("2")]
public ParentBasedSampler(Sampler rootSampler, Sampler remoteParentSampled, Sampler remoteParentNotSampled, Sampler localParentSampled, Sampler localParentNotSampled);
    public virtual SamplingResult ShouldSample(SamplingParameters& modreq(System.Runtime.InteropServices.InAttribute) samplingParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class OpenTelemetry.Trace.Sampler : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; protected set; }
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
protected void set_Description(string value);
    public abstract virtual SamplingResult ShouldSample(SamplingParameters& modreq(System.Runtime.InteropServices.InAttribute) samplingParameters);
}
public enum OpenTelemetry.Trace.SamplingDecision : Enum {
    public int value__;
    public static SamplingDecision Drop;
    public static SamplingDecision RecordOnly;
    public static SamplingDecision RecordAndSample;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class OpenTelemetry.Trace.SamplingParameters : ValueType {
    [CompilerGeneratedAttribute]
private ActivityContext <ParentContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityTraceId <TraceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ActivityKind <Kind>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <Tags>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ActivityLink> <Links>k__BackingField;
    public ActivityContext ParentContext { get; }
    public ActivityTraceId TraceId { get; }
    public string Name { get; }
    public ActivityKind Kind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Tags { get; }
    [NullableAttribute("2")]
public IEnumerable`1<ActivityLink> Links { get; }
    public SamplingParameters(ActivityContext parentContext, ActivityTraceId traceId, string name, ActivityKind kind, IEnumerable`1<KeyValuePair`2<string, object>> tags, IEnumerable`1<ActivityLink> links);
    [CompilerGeneratedAttribute]
public ActivityContext get_ParentContext();
    [CompilerGeneratedAttribute]
public ActivityTraceId get_TraceId();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ActivityKind get_Kind();
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_Tags();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IEnumerable`1<ActivityLink> get_Links();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class OpenTelemetry.Trace.SamplingResult : ValueType {
    [CompilerGeneratedAttribute]
private SamplingDecision <Decision>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<KeyValuePair`2<string, object>> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TraceStateString>k__BackingField;
    public SamplingDecision Decision { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Attributes { get; }
    public string TraceStateString { get; }
    public SamplingResult(SamplingDecision decision);
    public SamplingResult(bool isSampled);
    public SamplingResult(SamplingDecision decision, IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    public SamplingResult(SamplingDecision decision, string traceStateString);
    public SamplingResult(SamplingDecision decision, IEnumerable`1<KeyValuePair`2<string, object>> attributes, string traceStateString);
    [CompilerGeneratedAttribute]
public SamplingDecision get_Decision();
    [CompilerGeneratedAttribute]
public IEnumerable`1<KeyValuePair`2<string, object>> get_Attributes();
    [CompilerGeneratedAttribute]
public string get_TraceStateString();
    public static bool op_Equality(SamplingResult decision1, SamplingResult decision2);
    public static bool op_Inequality(SamplingResult decision1, SamplingResult decision2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SamplingResult other);
}
public class OpenTelemetry.Trace.TraceIdRatioBasedSampler : Sampler {
    private long idUpperBound;
    private double probability;
    public TraceIdRatioBasedSampler(double probability);
    public virtual SamplingResult ShouldSample(SamplingParameters& modreq(System.Runtime.InteropServices.InAttribute) samplingParameters);
    private static long GetLowerLong(ReadOnlySpan`1<byte> bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class OpenTelemetry.Trace.TracerProviderBuilderBase : TracerProviderBuilder {
    private bool allowBuild;
    private TracerProviderServiceCollectionBuilder innerBuilder;
    [NullableAttribute("2")]
private TracerProvider OpenTelemetry.Trace.ITracerProviderBuilder.Provider { get; }
    internal TracerProviderBuilderBase(IServiceCollection services);
    [NullableContextAttribute("2")]
private sealed virtual override TracerProvider OpenTelemetry.Trace.ITracerProviderBuilder.get_Provider();
    public virtual TracerProviderBuilder AddInstrumentation(Func`1<TInstrumentation> instrumentationFactory);
    public virtual TracerProviderBuilder AddSource(String[] names);
    public virtual TracerProviderBuilder AddLegacySource(string operationName);
    private sealed virtual override TracerProviderBuilder OpenTelemetry.Trace.ITracerProviderBuilder.ConfigureServices(Action`1<IServiceCollection> configure);
    private sealed virtual override TracerProviderBuilder OpenTelemetry.Trace.IDeferredTracerProviderBuilder.Configure(Action`2<IServiceProvider, TracerProviderBuilder> configure);
    internal TracerProvider InvokeBuild();
    protected TracerProviderBuilder AddInstrumentation(string instrumentationName, string instrumentationVersion, Func`1<object> instrumentationFactory);
    protected TracerProvider Build();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.Trace.TracerProviderBuilderExtensions : object {
    [ExtensionAttribute]
public static TracerProviderBuilder SetErrorStatusOnException(TracerProviderBuilder tracerProviderBuilder, bool enabled);
    [ExtensionAttribute]
public static TracerProviderBuilder SetSampler(TracerProviderBuilder tracerProviderBuilder, Sampler sampler);
    [ExtensionAttribute]
public static TracerProviderBuilder SetSampler(TracerProviderBuilder tracerProviderBuilder);
    [ExtensionAttribute]
public static TracerProviderBuilder SetSampler(TracerProviderBuilder tracerProviderBuilder, Func`2<IServiceProvider, Sampler> implementationFactory);
    [ExtensionAttribute]
public static TracerProviderBuilder SetResourceBuilder(TracerProviderBuilder tracerProviderBuilder, ResourceBuilder resourceBuilder);
    [ExtensionAttribute]
public static TracerProviderBuilder ConfigureResource(TracerProviderBuilder tracerProviderBuilder, Action`1<ResourceBuilder> configure);
    [ExtensionAttribute]
public static TracerProviderBuilder AddProcessor(TracerProviderBuilder tracerProviderBuilder, BaseProcessor`1<Activity> processor);
    [ExtensionAttribute]
public static TracerProviderBuilder AddProcessor(TracerProviderBuilder tracerProviderBuilder);
    [ExtensionAttribute]
public static TracerProviderBuilder AddProcessor(TracerProviderBuilder tracerProviderBuilder, Func`2<IServiceProvider, BaseProcessor`1<Activity>> implementationFactory);
    [ExtensionAttribute]
public static TracerProvider Build(TracerProviderBuilder tracerProviderBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Trace.TracerProviderBuilderSdk : TracerProviderBuilder {
    private static string DefaultInstrumentationVersion;
    private IServiceProvider serviceProvider;
    [NullableAttribute("2")]
private TracerProviderSdk tracerProvider;
    [CompilerGeneratedAttribute]
private List`1<InstrumentationRegistration> <Instrumentation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ResourceBuilder <ResourceBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BaseProcessor`1<Activity>> <Processors>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <LegacyActivityOperationNames>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Sampler <Sampler>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExceptionProcessorEnabled>k__BackingField;
    public List`1<InstrumentationRegistration> Instrumentation { get; }
    [NullableAttribute("2")]
public ResourceBuilder ResourceBuilder { get; private set; }
    [NullableAttribute("2")]
public TracerProvider Provider { get; }
    public List`1<BaseProcessor`1<Activity>> Processors { get; }
    public List`1<string> Sources { get; }
    public HashSet`1<string> LegacyActivityOperationNames { get; }
    [NullableAttribute("2")]
public Sampler Sampler { get; private set; }
    public bool ExceptionProcessorEnabled { get; private set; }
    public TracerProviderBuilderSdk(IServiceProvider serviceProvider);
    [CompilerGeneratedAttribute]
public List`1<InstrumentationRegistration> get_Instrumentation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ResourceBuilder get_ResourceBuilder();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ResourceBuilder(ResourceBuilder value);
    [NullableContextAttribute("2")]
public sealed virtual TracerProvider get_Provider();
    [CompilerGeneratedAttribute]
public List`1<BaseProcessor`1<Activity>> get_Processors();
    [CompilerGeneratedAttribute]
public List`1<string> get_Sources();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_LegacyActivityOperationNames();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Sampler get_Sampler();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Sampler(Sampler value);
    [CompilerGeneratedAttribute]
public bool get_ExceptionProcessorEnabled();
    [CompilerGeneratedAttribute]
private void set_ExceptionProcessorEnabled(bool value);
    public void RegisterProvider(TracerProviderSdk tracerProvider);
    public virtual TracerProviderBuilder AddInstrumentation(Func`1<TInstrumentation> instrumentationFactory);
    public TracerProviderBuilder AddInstrumentation(string instrumentationName, string instrumentationVersion, object instrumentation);
    public TracerProviderBuilder ConfigureResource(Action`1<ResourceBuilder> configure);
    public TracerProviderBuilder SetResourceBuilder(ResourceBuilder resourceBuilder);
    public virtual TracerProviderBuilder AddLegacySource(string operationName);
    public virtual TracerProviderBuilder AddSource(String[] names);
    public TracerProviderBuilder AddProcessor(BaseProcessor`1<Activity> processor);
    public TracerProviderBuilder SetSampler(Sampler sampler);
    public TracerProviderBuilder SetErrorStatusOnException(bool enabled);
    public TracerProviderBuilder ConfigureBuilder(Action`2<IServiceProvider, TracerProviderBuilder> configure);
    public sealed virtual TracerProviderBuilder ConfigureServices(Action`1<IServiceCollection> configure);
    public void AddExceptionProcessorIfEnabled(IEnumerable`1& processors);
    private sealed virtual override TracerProviderBuilder OpenTelemetry.Trace.IDeferredTracerProviderBuilder.Configure(Action`2<IServiceProvider, TracerProviderBuilder> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class OpenTelemetry.Trace.TracerProviderExtensions : object {
    [ExtensionAttribute]
public static TracerProvider AddProcessor(TracerProvider provider, BaseProcessor`1<Activity> processor);
    [ExtensionAttribute]
public static bool ForceFlush(TracerProvider provider, int timeoutMilliseconds);
    [ExtensionAttribute]
public static bool Shutdown(TracerProvider provider, int timeoutMilliseconds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class OpenTelemetry.Trace.TracerProviderSdk : TracerProvider {
    internal static string TracesSamplerConfigKey;
    internal static string TracesSamplerArgConfigKey;
    internal IServiceProvider ServiceProvider;
    [NullableAttribute("2")]
internal IDisposable OwnedServiceProvider;
    internal int ShutdownCount;
    internal bool Disposed;
    private List`1<object> instrumentations;
    private ActivityListener listener;
    private Sampler sampler;
    private Action`1<Activity> getRequestedDataAction;
    private bool supportLegacyActivity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BaseProcessor`1<Activity> processor;
    [CompilerGeneratedAttribute]
private Resource <Resource>k__BackingField;
    internal Resource Resource { get; }
    internal List`1<object> Instrumentations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal BaseProcessor`1<Activity> Processor { get; }
    internal Sampler Sampler { get; }
    internal TracerProviderSdk(IServiceProvider serviceProvider, bool ownsServiceProvider);
    [CompilerGeneratedAttribute]
internal Resource get_Resource();
    internal List`1<object> get_Instrumentations();
    internal BaseProcessor`1<Activity> get_Processor();
    internal Sampler get_Sampler();
    internal TracerProviderSdk AddProcessor(BaseProcessor`1<Activity> processor);
    internal bool OnForceFlush(int timeoutMilliseconds);
    internal bool OnShutdown(int timeoutMilliseconds);
    protected virtual void Dispose(bool disposing);
    private static Sampler GetSampler(IConfiguration configuration, Sampler stateSampler);
    private static double ReadTraceIdRatio(IConfiguration configuration);
    [NullableContextAttribute("0")]
private static ActivitySamplingResult ComputeActivitySamplingResult(ActivityCreationOptions`1& options, Sampler sampler);
    private static ActivitySamplingResult PropagateOrIgnoreData(ActivityContext& parentContext);
    private void RunGetRequestedDataAlwaysOnSampler(Activity activity);
    private void RunGetRequestedDataAlwaysOffSampler(Activity activity);
    private void RunGetRequestedDataOtherSampler(Activity activity);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_1(Activity activity);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_2(Activity activity);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ActivitySamplingResult <.ctor>b__12_5(ActivityCreationOptions`1& options);
}
internal static class OpenTelemetry.WildcardHelper : object {
    [NullableContextAttribute("2")]
public static bool ContainsWildcard(string value);
    [NullableContextAttribute("1")]
public static Regex GetWildcardRegex(IEnumerable`1<string> patterns);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
