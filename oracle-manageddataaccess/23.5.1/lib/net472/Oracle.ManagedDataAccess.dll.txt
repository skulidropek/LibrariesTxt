internal class a : object {
    private static int a;
    private string b;
    private static a();
    internal static void a(UInt16[] A_0, int A_1, Byte[] A_2, int A_3);
    internal static void a(Byte[] A_0, int A_1, UInt16[] A_2, int A_3);
    internal static void c(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, UInt16[] A_3, int A_4);
    private static int e(UInt16[] A_0, int A_1);
    private static int b(int A_0);
    private static int a(Byte[] A_0, int A_1);
    private static int d(UInt16[] A_0, int A_1);
    private static int a(int A_0);
    private static void c(UInt16[] A_0, int A_1, int A_2);
    private static void c(UInt16[] A_0, int A_1);
    private static void b(UInt16[] A_0, int A_1);
    private static void d(UInt16[] A_0, UInt16[] A_1, int A_2);
    private static int b(UInt16[] A_0, int A_1, int A_2);
    private static ushort a(UInt16[] A_0, int A_1, ushort A_2, UInt16[] A_3, int A_4, int A_5);
    private static void b(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, int A_3, int A_4);
    private static void c(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, int A_3);
    private static void a(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, int A_3, int A_4);
    private static void c(UInt16[] A_0, UInt16[] A_1, int A_2);
    private static void a(UInt16[] A_0, int A_1);
    private static void b(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, UInt16[] A_3, int A_4);
    private static void b(UInt16[] A_0, UInt16[] A_1, int A_2);
    private static void a(UInt16[] A_0, int A_1, int A_2);
    private static void b(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, UInt16[] A_3, UInt16[] A_4, int A_5);
    private static void b(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, int A_3);
    private static void a(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, UInt16[] A_3, int A_4);
    private static void a(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, int A_3, int A_4, int A_5);
    private static void a(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, UInt16[] A_3, UInt16[] A_4, int A_5);
    private static int a(UInt16[] A_0, UInt16[] A_1, int A_2);
    private static void a(UInt16[] A_0, UInt16[] A_1, UInt16[] A_2, int A_3);
}
internal class b : object {
    private int a;
    private int b;
    private int c;
    private int d;
    private bool e;
    private string f;
    private void a();
    internal byte b();
    internal ushort c();
    internal void a(Byte[] A_0, int A_1);
}
internal class c : object {
    private static int b;
    private Int64[] c;
    private Int64[] d;
    private Byte[] e;
    private Byte[] f;
    private static Byte[] g;
    private string h;
    private static c();
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2);
    private sealed virtual override void b();
    private sealed virtual override int a(Byte[] A_0, int A_1);
    private sealed virtual override void b(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
    private void a(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
    private long d(long A_0, long A_1, long A_2);
    private long c(long A_0, long A_1, long A_2);
    private long b(long A_0, long A_1, long A_2);
    private long a(long A_0, long A_1, long A_2);
    private long a(long A_0, int A_1);
    private long d(long A_0, long A_1, long A_2, long A_3, long A_4, int A_5, long A_6);
    private long c(long A_0, long A_1, long A_2, long A_3, long A_4, int A_5, long A_6);
    private long b(long A_0, long A_1, long A_2, long A_3, long A_4, int A_5, long A_6);
    private long a(long A_0, long A_1, long A_2, long A_3, long A_4, int A_5, long A_6);
    private void a(Byte[] A_0, int A_1, Byte[] A_2, int A_3);
    private void a(Byte[] A_0, Byte[] A_1, int A_2, int A_3);
    internal void c();
    private void a(Byte[] A_0, int A_1, Int64[] A_2, int A_3);
    private void a(Int64[] A_0, Byte[] A_1, int A_2);
    private void a(Int64[] A_0, Int64[] A_1);
    public sealed virtual int a();
    internal void b(Byte[] A_0, int A_1, int A_2);
    internal int b(Byte[] A_0, int A_1);
}
internal class d : object {
    private static int b;
    private static int c;
    private UInt32[] d;
    private long e;
    private UInt32[] f;
    private static UInt32 g;
    private static UInt32 h;
    private static UInt32 i;
    private static UInt32 j;
    private string k;
    private static d();
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2);
    private sealed virtual override void c();
    private sealed virtual override int a(Byte[] A_0, int A_1);
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
    public sealed virtual int a();
    private void a(byte A_0);
    internal void b(Byte[] A_0, int A_1, int A_2);
    internal void d();
    internal int b(Byte[] A_0, int A_1);
    private void b();
    private void a(UInt32[] A_0);
    private void d(UInt32[] A_0, UInt32[] A_1, UInt32 A_2, UInt32 A_3, UInt32 A_4, UInt32 A_5, UInt32 A_6, int A_7);
    private void c(UInt32[] A_0, UInt32[] A_1, UInt32 A_2, UInt32 A_3, UInt32 A_4, UInt32 A_5, UInt32 A_6, int A_7);
    private void b(UInt32[] A_0, UInt32[] A_1, UInt32 A_2, UInt32 A_3, UInt32 A_4, UInt32 A_5, UInt32 A_6, int A_7);
    private void a(UInt32[] A_0, UInt32[] A_1, UInt32 A_2, UInt32 A_3, UInt32 A_4, UInt32 A_5, UInt32 A_6, int A_7);
    internal void b(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
}
[ComVisibleAttribute("False")]
[AttributeUsageAttribute("1")]
public class DotfuscatorAttribute : Attribute {
    private string a;
    private int c;
    public string A { get; }
    public int C { get; }
    public DotfuscatorAttribute(string a, int c);
    public string a();
    public int c();
}
internal class e : object {
    private SHA384 b;
    private bool c;
    private ArraySegment`1<byte> d;
    private string e;
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2);
    private sealed virtual override void b();
    private sealed virtual override int a(Byte[] A_0, int A_1);
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
    public sealed virtual int a();
    private void a(byte A_0);
    internal void b(Byte[] A_0, int A_1, int A_2);
    internal void c();
    internal int b(Byte[] A_0, int A_1);
    internal void b(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
}
internal class f : object {
    private SHA512 b;
    private bool c;
    private ArraySegment`1<byte> d;
    private string e;
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2);
    private sealed virtual override void b();
    private sealed virtual override int a(Byte[] A_0, int A_1);
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
    public sealed virtual int a();
    private void a(byte A_0);
    internal void b(Byte[] A_0, int A_1, int A_2);
    internal void c();
    internal int b(Byte[] A_0, int A_1);
    internal void b(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
}
internal interface g {
    public abstract virtual int a();
    public abstract virtual void b();
    public abstract virtual void b(Byte[] A_0, int A_1, int A_2);
    public abstract virtual int b(Byte[] A_0, int A_1);
    public abstract virtual void b(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
}
internal class h : object {
    private SHA256 b;
    private bool c;
    private ArraySegment`1<byte> d;
    private string e;
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2);
    private sealed virtual override void b();
    private sealed virtual override int a(Byte[] A_0, int A_1);
    private sealed virtual override void a(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
    public sealed virtual int a();
    private void a(byte A_0);
    internal void b(Byte[] A_0, int A_1, int A_2);
    internal void c();
    internal int b(Byte[] A_0, int A_1);
    internal void b(Byte[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, Byte[]& A_5);
}
[CompilerGeneratedAttribute]
internal class i : object {
    internal static l a;
    internal static l b;
    internal static g c;
    internal static l d;
    internal static j e;
    internal static l f;
    internal static l g;
    internal static h h;
    internal static b i;
    internal static l j;
    internal static b k;
    internal static b l;
    internal static int m;
    internal static h n;
    internal static int o;
    internal static j p;
    internal static j q;
    internal static d r;
    internal static l s;
    internal static l t;
    internal static long u;
    internal static e v;
    internal static f w;
    internal static j x;
    internal static l y;
    internal static c z;
    internal static e aa;
    internal static j ab;
    internal static j ac;
    internal static a ad;
    internal static l ae;
    internal static m af;
    internal static j ag;
    internal static int ah;
    internal static k ai;
    internal static i aj;
    internal static j ak;
    internal static l al;
    internal static a am;
    internal static a an;
    internal static j ao;
    internal static l ap;
    internal static a aq;
    internal static j ar;
    private string as;
}
internal interface Oracle.DerAsn1Types.IOracleDerAsn1TaggedType {
    public int TagValue { get; public set; }
    public abstract virtual int get_TagValue();
    public abstract virtual void set_TagValue(int value);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1BitString : OracleDerAsn1PrimitiveType {
    protected int m_vUnusedBits;
    internal int UnusedBits { get; internal set; }
    internal OracleDerAsn1Length Length { get; }
    internal int get_UnusedBits();
    internal void set_UnusedBits(int value);
    internal virtual OracleDerAsn1Length get_Length();
    internal virtual void Read(MemoryStream ms);
    internal virtual void Write(MemoryStream ms);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1ConstructedContextSpecificType : OracleDerAsn1ConstructedType {
    protected int m_vTagValue;
    public int TagValue { get; public set; }
    public sealed virtual int get_TagValue();
    public sealed virtual void set_TagValue(int value);
}
internal abstract class Oracle.DerAsn1Types.OracleDerAsn1ConstructedType : OracleDerAsn1Type {
    protected List`1<OracleDerAsn1Type> m_vItems;
    internal List`1<OracleDerAsn1Type> Items { get; }
    internal OracleDerAsn1Length Length { get; }
    internal OracleDerAsn1ConstructedType(OracleDerAsn1TypeTag typeTag, List`1<OracleDerAsn1Type> items);
    internal OracleDerAsn1ConstructedType(OracleDerAsn1TypeTag typeTag);
    internal List`1<OracleDerAsn1Type> get_Items();
    internal virtual OracleDerAsn1Length get_Length();
    internal virtual void Read(MemoryStream ms);
    internal virtual void Write(MemoryStream ms);
    internal T GetItemAs(int index);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1Exception : Exception {
    internal OracleDerAsn1Exception(string message);
    internal OracleDerAsn1Exception(string message, Exception innerException);
    [SecuritySafeCriticalAttribute]
protected OracleDerAsn1Exception(SerializationInfo info, StreamingContext context);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1Integer : OracleDerAsn1PrimitiveType {
    private Nullable`1<ulong> m_vULongValue;
    internal ulong ULongValue { get; }
    internal ulong get_ULongValue();
    internal virtual void Read(MemoryStream ms);
    internal virtual void Write(MemoryStream ms);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1Length : object {
    private Nullable`1<long> m_vLength;
    internal Nullable`1<long> Length { get; }
    internal OracleDerAsn1Length(long length);
    internal Nullable`1<long> get_Length();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static OracleDerAsn1Length op_Implicit(long length);
    public static long op_Implicit(OracleDerAsn1Length value);
    internal void Write(MemoryStream ms);
    internal void Read(MemoryStream ms);
    internal static OracleDerAsn1Length ReadLength(MemoryStream ms);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1Null : OracleDerAsn1PrimitiveType {
}
internal class Oracle.DerAsn1Types.OracleDerAsn1ObjectIdentifier : OracleDerAsn1PrimitiveType {
    internal static string s_cOid_PBES2;
    internal static string s_cOid_PBKDF2;
    internal static string s_cOid_RSA_DES_EDE3_CBC;
    internal static string s_cOid_AES128_CBC2;
    internal static string s_cOid_AES128_ECB;
    internal static string s_cOid_AES128_OFB;
    internal static string s_cOid_AES128_CFB;
    internal static string s_cOid_RC2_CBC;
    internal static string s_cOid_DES_CBC;
    internal static string s_cOid_DES_CFB;
    internal static string s_cOid_DES_OFB;
    internal static string s_cOid_DES_EDE;
    internal static string s_cOid_DES_ECB;
    internal static string s_cOid_ECC_CURVE_P256;
    internal static string s_cOid_ECC_CURVE_P384;
    internal static string s_cOid_ECC_CURVE_P521;
    internal static string s_cOid_ECC_PUBLIC_KEY;
    internal static string s_cOid_RSA_RSA;
    internal static string s_cOid_PRIME_FIELD;
    internal static string s_cOid_CHARACTERISTIC2_FIELD;
    protected string m_vOID;
    internal string OID { get; }
    internal string get_OID();
    public virtual string ToString();
    private string GetNextNalue(Byte[] ba, Int32& startPos);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1OctetString : OracleDerAsn1PrimitiveType {
}
internal class Oracle.DerAsn1Types.OracleDerAsn1PrimitiveContextSpecificType : OracleDerAsn1PrimitiveType {
    protected int m_vTagValue;
    public int TagValue { get; public set; }
    public sealed virtual int get_TagValue();
    public sealed virtual void set_TagValue(int value);
}
internal abstract class Oracle.DerAsn1Types.OracleDerAsn1PrimitiveType : OracleDerAsn1Type {
    protected Byte[] m_vValue;
    internal Byte[] Value { get; }
    internal OracleDerAsn1Length Length { get; }
    internal OracleDerAsn1PrimitiveType(OracleDerAsn1TypeTag typeTag, Byte[] value);
    internal OracleDerAsn1PrimitiveType(OracleDerAsn1TypeTag typeTag);
    internal Byte[] get_Value();
    internal virtual OracleDerAsn1Length get_Length();
    internal virtual void Read(MemoryStream ms);
    internal virtual void Write(MemoryStream ms);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1Sequence : OracleDerAsn1ConstructedType {
}
internal abstract class Oracle.DerAsn1Types.OracleDerAsn1Type : object {
    [CompilerGeneratedAttribute]
private OracleDerAsn1TypeTag <Tag>k__BackingField;
    protected OracleDerAsn1Length m_vLength;
    protected Nullable`1<long> m_vTotalLength;
    internal OracleDerAsn1TypeTag Tag { get; }
    internal OracleDerAsn1Length Length { get; }
    internal Nullable`1<long> TotalLength { get; }
    internal bool IsPrimitive { get; }
    internal OracleDerAsn1Type(OracleDerAsn1TypeTag typeTag, long len);
    protected OracleDerAsn1Type(OracleDerAsn1TypeTag typeTag);
    [CompilerGeneratedAttribute]
internal OracleDerAsn1TypeTag get_Tag();
    internal virtual OracleDerAsn1Length get_Length();
    internal virtual Nullable`1<long> get_TotalLength();
    internal bool get_IsPrimitive();
    protected long ComputeLengthEncodingLength(long length);
    internal abstract virtual void Read(MemoryStream ms);
    internal abstract virtual void Write(MemoryStream ms);
}
internal class Oracle.DerAsn1Types.OracleDerAsn1TypeBuilder : object {
    internal static OracleDerAsn1Type BuildType(byte tag);
    internal static OracleDerAsn1Type Read(MemoryStream ms);
}
internal enum Oracle.DerAsn1Types.OracleDerAsn1TypeClass : Enum {
    public byte value__;
    public static OracleDerAsn1TypeClass UNIVERSAL;
    public static OracleDerAsn1TypeClass APPLICATION;
    public static OracleDerAsn1TypeClass CONTEXTSPECIFIC;
    public static OracleDerAsn1TypeClass PRIVATE;
}
internal enum Oracle.DerAsn1Types.OracleDerAsn1TypeEncodedForm : Enum {
    public byte value__;
    public static OracleDerAsn1TypeEncodedForm PRIMITIVE;
    public static OracleDerAsn1TypeEncodedForm CONSTRUCTED;
}
internal enum Oracle.DerAsn1Types.OracleDerAsn1TypeTag : Enum {
    public byte value__;
    public static OracleDerAsn1TypeTag NONE;
    public static OracleDerAsn1TypeTag BOOLEAN;
    public static OracleDerAsn1TypeTag INTEGER;
    public static OracleDerAsn1TypeTag BITSTRING;
    public static OracleDerAsn1TypeTag OCTETSTRING;
    public static OracleDerAsn1TypeTag NULL;
    public static OracleDerAsn1TypeTag OBJECTIDENTIFIER;
    public static OracleDerAsn1TypeTag OBJECTDESCRIPTOR;
    public static OracleDerAsn1TypeTag INSTANCEOF_EXTERNAL;
    public static OracleDerAsn1TypeTag REAL;
    public static OracleDerAsn1TypeTag ENUMERATED;
    public static OracleDerAsn1TypeTag EMBEDDEDPDV;
    public static OracleDerAsn1TypeTag UTF8STRING;
    public static OracleDerAsn1TypeTag RELATIVEOID;
    public static OracleDerAsn1TypeTag NUMERICSTRING;
    public static OracleDerAsn1TypeTag PRINTABLESTRING;
    public static OracleDerAsn1TypeTag TELETEXSTRING;
    public static OracleDerAsn1TypeTag VIDEOTEXSTRING;
    public static OracleDerAsn1TypeTag IA5STRING;
    public static OracleDerAsn1TypeTag UTCTIME;
    public static OracleDerAsn1TypeTag GENERALIZEDTIME;
    public static OracleDerAsn1TypeTag GRAPHICSTRING;
    public static OracleDerAsn1TypeTag VISIBLESTRING;
    public static OracleDerAsn1TypeTag GENERALSTRING;
    public static OracleDerAsn1TypeTag UNIVERSALSTRING;
    public static OracleDerAsn1TypeTag CHARACTERSTRING;
    public static OracleDerAsn1TypeTag BMPSTRING;
    public static OracleDerAsn1TypeTag SEQUENCE;
    public static OracleDerAsn1TypeTag SET;
}
internal class Oracle.ManagedDataAccess.Client.BatchUpdateHelper : object {
    private OracleCommand m_batchCommand;
    private StringBuilder m_batchCmdTextBuilder;
    private StringBuilder m_tempStringBuilder;
    private ArrayList m_paramArrayArray;
    private Hashtable m_usedParameterNames;
    private static Regex m_parserRegEx;
    private static string m_strDeclareBlock;
    private static string m_strExceptionBlock;
    private static string m_strRowCountBlock;
    private static string m_outParamAssignmentBlock;
    private OracleParameter m_prmRowsModified;
    private OracleParameter m_prmErrCodesArray;
    private OracleParameter m_prmErrMsgArray;
    private OracleParameter m_prmRowsMdArray;
    private int m_lastNumUsed;
    private int m_batchSizeCounter;
    private static string m_plsqlBlockPrefix;
    private static string m_plsqlBlockSuffix;
    private static string m_bindPrmPrefix;
    private static string m_commandSuffix;
    private static string COLON;
    private static int m_bindParameterMarkerGroup;
    internal OracleCommand BatchUpdateCommand { get; }
    private static BatchUpdateHelper();
    internal OracleCommand get_BatchUpdateCommand();
    internal void InitializeBUC();
    internal void FinalizeBUC();
    internal int AddCommand(OracleCommand command);
    internal OracleParameter GetBatchedParameter(int cmdIdentifier, int paramIndex);
    private OracleParameter[] CloneParameters(OracleParameterCollection parameters, object traceObj);
    private void ParseCommandText(OracleCommand command, OracleParameter[] parameters);
    private void ParseStoredProcedure(OracleCommand command, OracleParameter[] paramArray);
    private OracleParameter GetReturnValueParam(OracleParameter[] paramArray, object traceObj);
}
internal static class Oracle.ManagedDataAccess.Client.ClientVersion : object {
    internal static string VersionString;
    internal static string Name;
    internal static Version ClientVersionInfo;
    private static ClientVersion();
}
internal static class Oracle.ManagedDataAccess.Client.ConAttrib : object {
    public static string DataSrc;
    public static string DBAPriv;
    public static string Enlist;
    public static string Lifetime;
    public static string PoolInc;
    public static string PoolDec;
    public static string MaxPool;
    public static string MinPool;
    public static string Passw;
    public static string Persist;
    public static string Pooling;
    public static string Timeout;
    public static string Timeout2;
    public static string UserID;
    public static string ProxyUsr;
    public static string ProxyPassw;
    public static string ValidCon;
    public static string StmtCache;
    public static string StmtCachePurge;
    public static string GridCR;
    public static string GridRLB;
    public static string MetaPool;
    public static string CtxConn;
    public static string SelfTuning;
    public static string PSPE;
    public static string TnsAdmin;
    public static string WalletLocation;
    public static string ApplicationContinuity;
    public static string TokenAuth;
    public static string TokenLocation;
    public static string PoolReg;
    internal static String[] ConAttribWhiteList;
    internal static String[] ConAttribBlackList;
    private static ConAttrib();
}
internal class Oracle.ManagedDataAccess.Client.CounterData : object {
    private long m_counter;
    public long Value { get; }
    public CounterData(long value);
    public long get_Value();
    public void Increment();
    public void IncrementBy(int value);
    public void Decrement();
}
internal enum Oracle.ManagedDataAccess.Client.CounterType : Enum {
    public int value__;
    public static CounterType Counts;
    public static CounterType RatePerSecond;
}
internal enum Oracle.ManagedDataAccess.Client.CustomTypeCode : Enum {
    public int value__;
    public static CustomTypeCode Unknown;
    public static CustomTypeCode Byte;
    public static CustomTypeCode Bytes;
    public static CustomTypeCode Chars;
    public static CustomTypeCode DateTime;
    public static CustomTypeCode Decimal;
    public static CustomTypeCode Double;
    public static CustomTypeCode Int16;
    public static CustomTypeCode Int32;
    public static CustomTypeCode Int64;
    public static CustomTypeCode Single;
    public static CustomTypeCode String;
    public static CustomTypeCode TimeSpan;
    public static CustomTypeCode Char;
    public static CustomTypeCode SByte;
    public static CustomTypeCode UInt16;
    public static CustomTypeCode UInt32;
    public static CustomTypeCode UInt64;
    public static CustomTypeCode ByteNullable;
    public static CustomTypeCode BytesNullable;
    public static CustomTypeCode CharsNullable;
    public static CustomTypeCode DateTimeNullable;
    public static CustomTypeCode DecimalNullable;
    public static CustomTypeCode DoubleNullable;
    public static CustomTypeCode Int16Nullable;
    public static CustomTypeCode Int32Nullable;
    public static CustomTypeCode Int64Nullable;
    public static CustomTypeCode SingleNullable;
    public static CustomTypeCode TimeSpanNullable;
    public static CustomTypeCode CharNullable;
    public static CustomTypeCode SByteNullable;
    public static CustomTypeCode UInt16Nullable;
    public static CustomTypeCode UInt32Nullable;
    public static CustomTypeCode UInt64Nullable;
    public static CustomTypeCode OracleBFile;
    public static CustomTypeCode OracleBinary;
    public static CustomTypeCode OracleBlob;
    public static CustomTypeCode OracleClob;
    public static CustomTypeCode OracleDate;
    public static CustomTypeCode OracleDecimal;
    public static CustomTypeCode OracleIntervalDS;
    public static CustomTypeCode OracleIntervalYM;
    public static CustomTypeCode OracleRef;
    public static CustomTypeCode OracleString;
    public static CustomTypeCode OracleTimeStamp;
    public static CustomTypeCode OracleTimeStampLTZ;
    public static CustomTypeCode OracleTimeStampTZ;
    public static CustomTypeCode OracleXmlType;
    public static CustomTypeCode Udt;
    public static CustomTypeCode UdtJsonVal;
}
internal enum Oracle.ManagedDataAccess.Client.DeqOptsInfo : Enum {
    public int value__;
    public static DeqOptsInfo None;
    public static DeqOptsInfo ConsumerName;
    public static DeqOptsInfo Correlation;
    public static DeqOptsInfo DeliveryMode;
    public static DeqOptsInfo DequeueMode;
    public static DeqOptsInfo MessageId;
    public static DeqOptsInfo NavigationMode;
    public static DeqOptsInfo Visibility;
    public static DeqOptsInfo Wait;
    public static DeqOptsInfo All;
}
internal class Oracle.ManagedDataAccess.Client.DeriveParamInfo : object {
    public int m_paramCount;
    public int m_allocCount;
    public Int32[] m_arrayBindSize;
    public OracleCollectionType[] m_oraCollType;
    public ParameterDirection[] m_direction;
    public OracleDbType[] m_oraDbType;
    public String[] m_paramName;
    public Int32[] m_size;
    public String[] m_typeName;
    internal long m_lastUsedCount;
    public DeriveParamInfo(int allocCount);
}
internal enum Oracle.ManagedDataAccess.Client.EnqOptsInfo : Enum {
    public int value__;
    public static EnqOptsInfo None;
    public static EnqOptsInfo DeliveryMode;
    public static EnqOptsInfo Visibility;
    public static EnqOptsInfo All;
}
internal interface Oracle.ManagedDataAccess.Client.IReplayBase {
    public abstract virtual void PulginNewObject(object newObject);
}
internal enum Oracle.ManagedDataAccess.Client.NotificationDefaults : Enum {
    public int value__;
    public static NotificationDefaults GroupingInterval;
    public static NotificationDefaults Timeout;
}
internal class Oracle.ManagedDataAccess.Client.ODPType : object {
    public static Type OraBinary;
    public static Type OraString;
    public static Type OraBFile;
    public static Type OraBlob;
    public static Type OraClob;
    public static Type OraJson;
    public static Type OraVector;
    public static Type OraDecimal;
    public static Type OraDate;
    public static Type OraTimeStamp;
    public static Type OraTimeStampTZ;
    public static Type OraTimeStampLTZ;
    public static Type OraIntervalDS;
    public static Type OraIntervalYM;
    public static Type OraRefCursor;
    public static Type OraXmlType;
    public static Type OraBoolean;
    public static Type OraRef;
    private static ODPType();
}
public class Oracle.ManagedDataAccess.Client.OnChangeEventHandler : MulticastDelegate {
    public OnChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OracleNotificationEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, OracleNotificationEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Oracle.ManagedDataAccess.Client.OnsConfigMode : Enum {
    public int value__;
    public static OnsConfigMode Unspecified;
    public static OnsConfigMode local;
    public static OnsConfigMode remote;
}
public class Oracle.ManagedDataAccess.Client.OracleAccessToken : object {
    internal static string DEF_TOKEN_PATH_FRAG;
    internal static string DEF_TOKEN_FILE_NAME;
    internal static string DEF_PRIV_KEY_FILE_NAME;
    private static long BUFFER_TIME_BEFORE_EXPIRY;
    private static int WAIT_TIME_BEFORE_READING_FILES;
    private static int MAX_ACCCESSTOKEN_LENGTH;
    internal static MethodInfo parseDBToken_m;
    internal int m_pmHashCode;
    internal RSACryptoServiceProvider m_rsaCryptoSigner;
    internal OracleOpaqueString m_opaqueDBToken;
    internal OracleOpaqueString m_opaquePrivateKey;
    internal OracleTokenAuth m_tokenAuth;
    internal OraclePasswordAuth m_passwAuth;
    private FileSystemWatcher m_DBTokenFileWatcher;
    private FileSystemWatcher m_privateKeyFileWatcher;
    internal object m_lock;
    internal OracleRefreshAccessTokenEventHandler m_refreshDBTokenHandler;
    internal string m_subUserInDBToken;
    internal DateTimeOffset m_dbExpTimeInUTC;
    internal bool m_bTokenParsed;
    internal Timer m_timer;
    internal bool m_bTimerStarted;
    internal bool m_bCreatedForInternalUse;
    internal bool m_bCreatedFromTokenLocation;
    internal string m_tokenLocation;
    public OracleAccessToken(Char[] dbToken, Char[] privateKey);
    public OracleAccessToken(Char[] token);
    internal OracleAccessToken(string token, DateTimeOffset tokenExpiryTimeinUtc);
    internal OracleAccessToken(bool bCreatedFromTokenLocation, string tokenLocation, OracleTokenAuth tokenAuth);
    internal OracleAccessToken(string ociIamUrl, string ociTenancy, string ociCompartment, string ociDatabase, string userId, OracleOpaqueString opaquePassw);
    private static OracleAccessToken();
    public static void ParseDBToken(Char[] dbToken, String& subUserInDBToken, DateTimeOffset& dbTokenExpTimeInUtc, String& jwkValueInDBToken);
    public void add_RefreshAccessToken(OracleRefreshAccessTokenEventHandler value);
    public void remove_RefreshAccessToken(OracleRefreshAccessTokenEventHandler value);
    internal static string DeriveDefaultDirectory();
    internal void GetTokenAuthFieldValues(MarshallingEngine marshallingEngine, Byte[]& dbTokenBytes, Byte[]& authHeader, Byte[]& authSignature);
    internal OracleOpaqueString ReadPrivateKeyFromFile();
    internal OracleOpaqueString ReadTokenFromFile();
    internal static Byte[] GenerateAuthHeader(MarshallingEngine marshallingEngine);
    internal Byte[] SignHeader(Byte[] header, RSACryptoServiceProvider rsaSigner);
    private void FileDeletedNotification(object sender, FileSystemEventArgs e);
    private void PrivateKeyFileChangedNotification(object sender, FileSystemEventArgs e);
    private void DBTokenFileChangedNotification(object sender, FileSystemEventArgs e);
    internal void ReadNewTokenAndPrivateKeyFiles(string fullPath);
    internal Byte[] GetDBTokenBytes(OracleOpaqueString opaqueToken, MarshallingEngine marshallingEngine);
    private DateTime FromUnixTime(long unixDateTime);
    internal static bool IsExpired(DateTimeOffset dbExpTimeInUTC);
    internal long CalculateTokenExpiryTime();
    internal void StartTokenRefreshTimer();
    internal void ResetTokenRefreshTimer();
    internal void StartOrResetTokenRefreshTimer();
    internal void StopTokenRefreshTimer();
    internal void TokenExpiryCallback(object state);
    internal bool ValidateRefreshEventArgs(OracleRefreshAccessTokenEventArgs eventArgs);
}
public enum Oracle.ManagedDataAccess.Client.OracleAllowedLogonVersionClient : Enum {
    public int value__;
    public static OracleAllowedLogonVersionClient Version8;
    public static OracleAllowedLogonVersionClient Version9;
    public static OracleAllowedLogonVersionClient Version10;
    public static OracleAllowedLogonVersionClient Version11;
    public static OracleAllowedLogonVersionClient Version12;
    public static OracleAllowedLogonVersionClient Version12a;
}
public class Oracle.ManagedDataAccess.Client.OracleAQAgent : object {
    internal string m_name;
    internal string m_address;
    public string Name { get; }
    public string Address { get; }
    private static OracleAQAgent();
    public OracleAQAgent(string name);
    public OracleAQAgent(string name, string address);
    public string get_Name();
    public string get_Address();
}
public enum Oracle.ManagedDataAccess.Client.OracleAQDequeueMode : Enum {
    public int value__;
    public static OracleAQDequeueMode Browse;
    public static OracleAQDequeueMode Locked;
    public static OracleAQDequeueMode Remove;
    public static OracleAQDequeueMode RemoveNoData;
}
public class Oracle.ManagedDataAccess.Client.OracleAQDequeueOptions : object {
    internal OracleAQDequeueMode m_dequeueMode;
    internal OracleAQNavigationMode m_navigationMode;
    internal OracleAQVisibilityMode m_visibility;
    internal int m_wait;
    internal OracleAQMessageDeliveryMode m_deliveryMode;
    internal string m_consumerName;
    internal Byte[] m_messageId;
    internal string m_correlation;
    internal bool m_providerSpecificType;
    internal string m_condition;
    internal string m_transformation;
    internal bool m_retrieveMessageId;
    internal int m_maxBufferLength;
    public OracleAQDequeueMode DequeueMode { get; public set; }
    public OracleAQNavigationMode NavigationMode { get; public set; }
    public OracleAQMessageDeliveryMode DeliveryMode { get; public set; }
    public OracleAQVisibilityMode Visibility { get; public set; }
    public int Wait { get; public set; }
    public Byte[] MessageId { get; public set; }
    public string Correlation { get; public set; }
    public string ConsumerName { get; public set; }
    public bool ProviderSpecificType { get; public set; }
    private static OracleAQDequeueOptions();
    public OracleAQDequeueMode get_DequeueMode();
    public void set_DequeueMode(OracleAQDequeueMode value);
    public OracleAQNavigationMode get_NavigationMode();
    public void set_NavigationMode(OracleAQNavigationMode value);
    public OracleAQMessageDeliveryMode get_DeliveryMode();
    public void set_DeliveryMode(OracleAQMessageDeliveryMode value);
    public OracleAQVisibilityMode get_Visibility();
    public void set_Visibility(OracleAQVisibilityMode value);
    public int get_Wait();
    public void set_Wait(int value);
    public Byte[] get_MessageId();
    public void set_MessageId(Byte[] value);
    public string get_Correlation();
    public void set_Correlation(string value);
    public string get_ConsumerName();
    public void set_ConsumerName(string value);
    public bool get_ProviderSpecificType();
    public void set_ProviderSpecificType(bool value);
    public sealed virtual object Clone();
}
public class Oracle.ManagedDataAccess.Client.OracleAQEnqueueOptions : object {
    internal OracleAQVisibilityMode m_visibility;
    internal OracleAQMessageDeliveryMode m_deliveryMode;
    private static bool retrieveMsgId;
    internal string m_transformation;
    public OracleAQVisibilityMode Visibility { get; public set; }
    public OracleAQMessageDeliveryMode DeliveryMode { get; public set; }
    private static OracleAQEnqueueOptions();
    public OracleAQVisibilityMode get_Visibility();
    public void set_Visibility(OracleAQVisibilityMode value);
    public OracleAQMessageDeliveryMode get_DeliveryMode();
    public void set_DeliveryMode(OracleAQMessageDeliveryMode value);
    public sealed virtual object Clone();
    internal void setRetrieveMessageId(bool retrieveIt);
    internal bool getRetrieveMessageId();
}
public class Oracle.ManagedDataAccess.Client.OracleAQMessage : object {
    internal object m_payload;
    internal OracleAQMessageDeliveryMode m_deliveryMode;
    internal int m_deqAttempts;
    internal string m_correlation;
    internal string m_exceptionQueue;
    internal int m_expiration;
    internal int m_delay;
    internal OracleAQAgent[] m_recipients;
    internal OracleAQAgent m_senderId;
    internal string m_transactionGroup;
    internal Byte[] m_messageId;
    internal DateTime m_enqueueTime;
    internal OracleAQMessageState m_state;
    internal int m_priority;
    internal Byte[] m_originalMessageId;
    internal bool m_msgPropsModified;
    internal int version;
    internal Byte[] m_PreviousQueueMessageId;
    internal int m_payloadType;
    internal Byte[] m_payloadInBytes;
    internal OracleXmlType m_payLoadXMLType;
    internal string m_payloadJson;
    internal object m_payloadUdt;
    internal string m_udtTypeName;
    internal int m_shardNum;
    internal static int TOID_LENGTH;
    internal static Byte[] RAW_TOID;
    internal static Byte[] XMLTYPE_TOID;
    internal static Byte[] ANYDATA_TOID;
    internal static Byte[] JSON_TOID;
    internal static int KOIDFLEN;
    public int DequeueAttempts { get; }
    public string Correlation { get; public set; }
    public Byte[] OriginalMessageId { get; }
    public OracleAQMessageDeliveryMode DeliveryMode { get; }
    public int Delay { get; public set; }
    public string ExceptionQueue { get; public set; }
    public int Expiration { get; public set; }
    public int Priority { get; public set; }
    public OracleAQAgent[] Recipients { get; public set; }
    public string TransactionGroup { get; }
    public Byte[] MessageId { get; }
    public DateTime EnqueueTime { get; }
    public int ShardNum { get; public set; }
    public OracleAQMessageState State { get; }
    public object Payload { get; public set; }
    public OracleAQAgent SenderId { get; public set; }
    public Byte[] PreviousQueueMessageId { get; public set; }
    private static OracleAQMessage();
    public OracleAQMessage(object payload);
    public int get_DequeueAttempts();
    public string get_Correlation();
    public void set_Correlation(string value);
    public Byte[] get_OriginalMessageId();
    public OracleAQMessageDeliveryMode get_DeliveryMode();
    public int get_Delay();
    public void set_Delay(int value);
    public string get_ExceptionQueue();
    public void set_ExceptionQueue(string value);
    public int get_Expiration();
    public void set_Expiration(int value);
    public int get_Priority();
    public void set_Priority(int value);
    public OracleAQAgent[] get_Recipients();
    public void set_Recipients(OracleAQAgent[] value);
    public string get_TransactionGroup();
    public Byte[] get_MessageId();
    public DateTime get_EnqueueTime();
    public int get_ShardNum();
    public void set_ShardNum(int value);
    public OracleAQMessageState get_State();
    public object get_Payload();
    public void set_Payload(object value);
    public OracleAQAgent get_SenderId();
    public void set_SenderId(OracleAQAgent value);
    public Byte[] get_PreviousQueueMessageId();
    public void set_PreviousQueueMessageId(Byte[] value);
    internal int getPayloadVersion();
    internal static bool CompareToid(Byte[] toid, Byte[] toid2);
}
public class Oracle.ManagedDataAccess.Client.OracleAQMessageAvailableEventArgs : object {
    internal object m_payload;
    internal string m_queueName;
    internal string m_consumerName;
    internal Byte[][] m_messageId;
    internal string m_correlation;
    internal int m_delay;
    internal string m_exceptionQueue;
    internal int m_expiration;
    internal int m_priority;
    internal DateTime m_enqueueTime;
    internal OracleAQMessageState m_state;
    internal OracleAQMessageDeliveryMode m_deliveryMode;
    internal OracleAQAgent m_senderId;
    internal Byte[] m_originalMessageId;
    internal OracleAQNotificationType m_notificationType;
    internal int m_availableMessages;
    internal OracleAQQueue m_queue;
    internal OracleConnection m_connection;
    public string QueueName { get; }
    public OracleAQQueue Queue { get; }
    public object Payload { get; }
    public string ConsumerName { get; }
    public Byte[][] MessageId { get; }
    public string Correlation { get; }
    public int Delay { get; }
    public string ExceptionQueue { get; }
    public int Expiration { get; }
    public int Priority { get; }
    public DateTime EnqueueTime { get; }
    public OracleAQMessageState State { get; }
    public OracleAQMessageDeliveryMode DeliveryMode { get; }
    public OracleAQAgent SenderId { get; }
    public Byte[] OriginalMessageId { get; }
    public OracleAQNotificationType NotificationType { get; }
    public int AvailableMessages { get; }
    public string get_QueueName();
    public OracleAQQueue get_Queue();
    public object get_Payload();
    public string get_ConsumerName();
    public Byte[][] get_MessageId();
    public string get_Correlation();
    public int get_Delay();
    public string get_ExceptionQueue();
    public int get_Expiration();
    public int get_Priority();
    public DateTime get_EnqueueTime();
    public OracleAQMessageState get_State();
    public OracleAQMessageDeliveryMode get_DeliveryMode();
    public OracleAQAgent get_SenderId();
    public Byte[] get_OriginalMessageId();
    public OracleAQNotificationType get_NotificationType();
    public int get_AvailableMessages();
}
public enum Oracle.ManagedDataAccess.Client.OracleAQMessageDeliveryMode : Enum {
    public int value__;
    public static OracleAQMessageDeliveryMode Persistent;
    public static OracleAQMessageDeliveryMode Buffered;
    public static OracleAQMessageDeliveryMode PersistentOrBuffered;
}
public enum Oracle.ManagedDataAccess.Client.OracleAQMessageState : Enum {
    public int value__;
    public static OracleAQMessageState Ready;
    public static OracleAQMessageState Waiting;
    public static OracleAQMessageState Processed;
    public static OracleAQMessageState Expired;
}
public enum Oracle.ManagedDataAccess.Client.OracleAQMessageType : Enum {
    public int value__;
    public static OracleAQMessageType Raw;
    public static OracleAQMessageType Udt;
    public static OracleAQMessageType Xml;
    public static OracleAQMessageType Json;
}
public enum Oracle.ManagedDataAccess.Client.OracleAQNavigationMode : Enum {
    public int value__;
    public static OracleAQNavigationMode FirstMessage;
    public static OracleAQNavigationMode NextMessage;
    public static OracleAQNavigationMode NextTransaction;
    public static OracleAQNavigationMode FirstMessageMultiGroup;
    public static OracleAQNavigationMode NextMessageMultiGroup;
}
public enum Oracle.ManagedDataAccess.Client.OracleAQNotificationGroupingType : Enum {
    public int value__;
    public static OracleAQNotificationGroupingType Summary;
    public static OracleAQNotificationGroupingType Last;
}
public enum Oracle.ManagedDataAccess.Client.OracleAQNotificationType : Enum {
    public int value__;
    public static OracleAQNotificationType Regular;
    public static OracleAQNotificationType Timeout;
    public static OracleAQNotificationType Group;
}
public class Oracle.ManagedDataAccess.Client.OracleAQQueue : object {
    internal OracleConnection m_connection;
    private bool m_disposed;
    protected string m_name;
    private int m_teqRegIdFromServer;
    private Byte[][] m_teqMessageId;
    private bool m_isTEQNotification;
    private string m_udtTypeName;
    private OracleAQMessageType m_messageType;
    private OracleAQEnqueueOptions m_aqEnqOptions;
    private OracleAQDequeueOptions m_aqDeqOptions;
    private object m_lockObj;
    private OracleNotificationRequest m_NTFNReq;
    private String[] m_notificationConsumers;
    internal EventWrapper m_eventWrapper;
    private OracleAQQueueImpl m_aQQueueImpl;
    internal static int LISTEN_FOREVER;
    internal string m_guid;
    internal OracleDependencyImpl m_orclDependencyImpl;
    private static string SQL_GetShardedInfoFromUserQueues;
    private bool m_isTeqSet;
    private bool m_useCIC;
    internal string m_queueName;
    public OracleConnection Connection { get; public set; }
    public string Name { get; }
    public string UdtTypeName { get; public set; }
    public String[] NotificationConsumers { get; public set; }
    public OracleAQMessageType MessageType { get; public set; }
    public OracleAQEnqueueOptions EnqueueOptions { get; public set; }
    public OracleAQDequeueOptions DequeueOptions { get; public set; }
    public OracleNotificationRequest Notification { get; }
    public OracleAQQueue(string name);
    public OracleAQQueue(string name, OracleConnection con);
    public OracleAQQueue(string name, OracleConnection con, OracleAQMessageType messageType);
    public OracleAQQueue(string name, OracleConnection con, OracleAQMessageType messageType, string udtTypeName);
    private OracleAQQueue(string name, OracleConnection con, OracleAQMessageType messageType, string udtTypeName, bool checkConnReference);
    public OracleConnection get_Connection();
    public void set_Connection(OracleConnection value);
    public string get_Name();
    public string get_UdtTypeName();
    public void set_UdtTypeName(string value);
    public String[] get_NotificationConsumers();
    public void set_NotificationConsumers(String[] value);
    public OracleAQMessageType get_MessageType();
    public void set_MessageType(OracleAQMessageType value);
    public OracleAQEnqueueOptions get_EnqueueOptions();
    public void set_EnqueueOptions(OracleAQEnqueueOptions value);
    public OracleAQDequeueOptions get_DequeueOptions();
    public void set_DequeueOptions(OracleAQDequeueOptions value);
    public OracleNotificationRequest get_Notification();
    public void add_MessageAvailable(OracleAQMessageAvailableEventHandler value);
    public void remove_MessageAvailable(OracleAQMessageAvailableEventHandler value);
    public void Enqueue(OracleAQMessage msg);
    public void Enqueue(OracleAQMessage msg, OracleAQEnqueueOptions aqEnqOptions);
    public int EnqueueArray(OracleAQMessage[] messages);
    public int EnqueueArray(OracleAQMessage[] messages, OracleAQEnqueueOptions aqEnqOptions);
    public OracleAQMessage Dequeue();
    public OracleAQMessage Dequeue(OracleAQDequeueOptions aqDeqOptions);
    public OracleAQMessage[] DequeueArray(int dequeueCount);
    public OracleAQMessage[] DequeueArray(int dequeueCount, OracleAQDequeueOptions aqDeqOptions);
    public string Listen(String[] listenConsumers);
    public string Listen(String[] listenConsumers, int waitTime);
    public static OracleAQAgent Listen(OracleConnection con, OracleAQAgent[] listenConsumers);
    public static OracleAQAgent Listen(OracleConnection con, OracleAQAgent[] listenConsumers, int waitTime);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private void SubscriptionRegister();
    private void SubscriptionUnRegister();
    public void AcknowledgeTxEventQNotification(OracleTxEventQNotificationDirective directive);
    private void AckTEQNotification(NotificationRegistrationDetails registration, Byte[][] lastMessageIDs, short directiveValue);
    internal static void SetAQNotificationDetails(object notifInfoObj);
    internal bool UseClientInitatedConnection();
}
public enum Oracle.ManagedDataAccess.Client.OracleAQVisibilityMode : Enum {
    public int value__;
    public static OracleAQVisibilityMode Immediate;
    public static OracleAQVisibilityMode OnCommit;
}
public class Oracle.ManagedDataAccess.Client.OracleBulkCopy : object {
    private int m_batchSize;
    private OracleBulkCopyOptions m_bulkCopyOptions;
    private int m_timeout;
    private OracleBulkCopyColumnMappingCollection m_columnMappings;
    private OracleConnection m_connection;
    private string m_destinationTableName;
    private string m_destinationPartitionName;
    private string m_destinationSchemaName;
    private int m_notifyAfter;
    private bool m_ownConnection;
    private bool m_insideRowsCopiedEvent;
    private bool m_fetchMeta;
    private DataTable m_destinationtableMetaData;
    private OracleRowsCopiedEventHandler m_rowsCopiedEventHandler;
    private bool m_disposed;
    private bool m_timeElapsed;
    private static int DEFAULT_TIMEOUT;
    private static int ONE_SECOND;
    private OracleBulkCopyImpl m_bulkCopyImpl;
    [DefaultValueAttribute("0")]
public int BatchSize { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public OracleBulkCopyOptions BulkCopyOptions { get; public set; }
    [DefaultValueAttribute("30")]
public int BulkCopyTimeout { get; public set; }
    public OracleBulkCopyColumnMappingCollection ColumnMappings { get; }
    public OracleConnection Connection { get; }
    public string DestinationTableName { get; public set; }
    public string DestinationPartitionName { get; public set; }
    public string DestinationSchemaName { get; public set; }
    [DefaultValueAttribute("0")]
public int NotifyAfter { get; public set; }
    internal bool TimeElapsed { get; }
    public OracleBulkCopy(OracleConnection connection);
    public OracleBulkCopy(string connectionString);
    public OracleBulkCopy(OracleConnection connection, OracleBulkCopyOptions copyOptions);
    public OracleBulkCopy(string connectionString, OracleBulkCopyOptions copyOptions);
    protected virtual override void Finalize();
    public void Close();
    public sealed virtual void Dispose();
    public void WriteToServer(DataRow[] rows);
    public void WriteToServer(DataTable table);
    public void WriteToServer(IDataReader reader);
    public void WriteToServer(DataTable table, DataRowState rowState);
    public void WriteToServer(OracleRefCursor refCursor);
    public int get_BatchSize();
    public void set_BatchSize(int value);
    public OracleBulkCopyOptions get_BulkCopyOptions();
    public void set_BulkCopyOptions(OracleBulkCopyOptions value);
    public int get_BulkCopyTimeout();
    public void set_BulkCopyTimeout(int value);
    public OracleBulkCopyColumnMappingCollection get_ColumnMappings();
    public OracleConnection get_Connection();
    public string get_DestinationTableName();
    public void set_DestinationTableName(string value);
    public string get_DestinationPartitionName();
    public void set_DestinationPartitionName(string value);
    public string get_DestinationSchemaName();
    public void set_DestinationSchemaName(string value);
    public int get_NotifyAfter();
    public void set_NotifyAfter(int value);
    public void add_OracleRowsCopied(OracleRowsCopiedEventHandler value);
    public void remove_OracleRowsCopied(OracleRowsCopiedEventHandler value);
    private void Dispose(bool disposing);
    internal bool get_TimeElapsed();
    internal bool IsBulkCopyOption(OracleBulkCopyOptions copyOption);
    private DataTable GetDestinationTableMetaData();
    private OracleBulkCopyColumnMappingCollection CreateInternalColumnMappings(IBulkCopyDataSource dataSource);
    private bool IsBulkCopySuccess(BulkCopyResult result);
    private bool IsUserAbort(BulkCopyResult result);
    private bool IsBulkCopyAllRowsLoaded(BulkCopyResult result);
    private bool IsBulkCopyTimeout(BulkCopyResult result);
    private void WriteDataSourceToServer(IBulkCopyDataSource dataSource);
    private void ValidateConnection();
    internal bool FireRowsCopiedEvent(long rowsCopied);
    internal void OnRowsCopied(OracleRowsCopiedEventArgs eventArgs);
    private void OnTimeElapsed(object source, ElapsedEventArgs e);
}
public class Oracle.ManagedDataAccess.Client.OracleBulkCopyColumnMapping : object {
    internal string m_destinationColumnName;
    internal string m_sourceColumnName;
    internal int m_destinationColumnOrdinal;
    internal int m_sourceColumnOrdinal;
    public string DestinationColumn { get; public set; }
    public int DestinationOrdinal { get; public set; }
    public string SourceColumn { get; public set; }
    public int SourceOrdinal { get; public set; }
    private static OracleBulkCopyColumnMapping();
    public OracleBulkCopyColumnMapping(int sourceColumnOrdinal, int destinationOrdinal);
    public OracleBulkCopyColumnMapping(int sourceColumnOrdinal, string destinationColumn);
    public OracleBulkCopyColumnMapping(string sourceColumn, int destinationOrdinal);
    public OracleBulkCopyColumnMapping(string sourceColumn, string destinationColumn);
    internal OracleBulkCopyColumnMapping Clone();
    public sealed virtual int CompareTo(object obj);
    public string get_DestinationColumn();
    public void set_DestinationColumn(string value);
    public int get_DestinationOrdinal();
    public void set_DestinationOrdinal(int value);
    public string get_SourceColumn();
    public void set_SourceColumn(string value);
    public int get_SourceOrdinal();
    public void set_SourceOrdinal(int value);
}
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Client.OracleBulkCopyColumnMappingCollection : CollectionBase {
    private bool m_bulkCopyInProgress;
    public OracleBulkCopyColumnMapping Item { get; public set; }
    internal bool BulkCopyInProgress { get; internal set; }
    private static OracleBulkCopyColumnMappingCollection();
    public OracleBulkCopyColumnMapping Add(OracleBulkCopyColumnMapping bulkCopyColumnMapping);
    public OracleBulkCopyColumnMapping Add(int sourceColumnIndex, int destinationColumnIndex);
    public OracleBulkCopyColumnMapping Add(int sourceColumnIndex, string destinationColumn);
    public OracleBulkCopyColumnMapping Add(string sourceColumn, int destinationColumnIndex);
    public OracleBulkCopyColumnMapping Add(string sourceColumn, string destinationColumn);
    public void Clear();
    public bool Contains(OracleBulkCopyColumnMapping value);
    public void CopyTo(OracleBulkCopyColumnMapping[] array, int index);
    public int IndexOf(OracleBulkCopyColumnMapping value);
    public void Insert(int index, OracleBulkCopyColumnMapping value);
    public void Remove(OracleBulkCopyColumnMapping value);
    public void RemoveAt(int index);
    public OracleBulkCopyColumnMapping get_Item(int index);
    public void set_Item(int index, OracleBulkCopyColumnMapping value);
    internal bool get_BulkCopyInProgress();
    internal void set_BulkCopyInProgress(bool value);
    internal void CreateDefaultColumnMapping(int columnCount);
    internal void Sort();
    internal bool ValidateCollection();
    internal static bool IsEmpty(string str);
}
[FlagsAttribute]
public enum Oracle.ManagedDataAccess.Client.OracleBulkCopyOptions : Enum {
    public int value__;
    public static OracleBulkCopyOptions Default;
    public static OracleBulkCopyOptions UseInternalTransaction;
    public static OracleBulkCopyOptions NotifyAllRowsProcessed;
}
internal class Oracle.ManagedDataAccess.Client.OracleChunkEventArgs : EventArgs {
    private static DateTimeFormatInfo s_dfi;
    private string m_eventType;
    private string m_chunk;
    private string m_instance;
    private string m_database;
    private string m_databaseDomain;
    private OracleChunkEventStatus m_status;
    private string m_newChunk;
    private string m_toChunk;
    private long m_hash;
    private int m_priority;
    private String[] m_keys;
    private String[] m_splitVals;
    private DateTime m_timestamp;
    private TimeSpan m_timezone;
    private DateTimeOffset m_dateTimeOffset;
    private long m_lowerHashBoundary;
    private long m_higherHashBoundary;
    public string EventType { get; }
    public string Chunk { get; }
    public string Instance { get; }
    public string Database { get; }
    public string DatabaseDomain { get; }
    public OracleChunkEventStatus Status { get; }
    public string NewChunk { get; }
    public string ToChunk { get; }
    public String[] ShardingKeys { get; }
    public String[] SplitVals { get; }
    public long Hash { get; }
    public int Priority { get; }
    public DateTime TimeStamp { get; }
    public TimeSpan TimeZone { get; }
    public DateTimeOffset DateTimeOffset { get; }
    public long LowerHashBoundary { get; }
    public long HigherHashBoundary { get; }
    private static OracleChunkEventArgs();
    internal OracleChunkEventArgs(string eventType, string chunk, string instance, string database, string databaseDomain, string status, string newChunk, string toChunk, string hash, string priority, String[] keys, String[] splitValues, string timestamp, string timezone, string lowerHashBoundary, string higherHashBoundary, object traceObj);
    public string get_EventType();
    public string get_Chunk();
    public string get_Instance();
    public string get_Database();
    public string get_DatabaseDomain();
    public OracleChunkEventStatus get_Status();
    public string get_NewChunk();
    public string get_ToChunk();
    public String[] get_ShardingKeys();
    public String[] get_SplitVals();
    public long get_Hash();
    public int get_Priority();
    public DateTime get_TimeStamp();
    public TimeSpan get_TimeZone();
    public DateTimeOffset get_DateTimeOffset();
    public long get_LowerHashBoundary();
    public long get_HigherHashBoundary();
}
public enum Oracle.ManagedDataAccess.Client.OracleChunkEventStatus : Enum {
    public int value__;
    public static OracleChunkEventStatus ReadOnly;
    public static OracleChunkEventStatus Up;
    public static OracleChunkEventStatus Down;
    public static OracleChunkEventStatus Split;
    public static OracleChunkEventStatus Add;
    public static OracleChunkEventStatus Drop;
    public static OracleChunkEventStatus Merge;
    public static OracleChunkEventStatus AddValues;
    public static OracleChunkEventStatus DropValues;
    public static OracleChunkEventStatus Invalidate;
    public static OracleChunkEventStatus Pset_Split;
    public static OracleChunkEventStatus New_Pset;
}
public class Oracle.ManagedDataAccess.Client.OracleClientFactory : DbProviderFactory {
    public static OracleClientFactory Instance;
    public bool CanCreateDataSourceEnumerator { get; }
    private static OracleClientFactory();
    public virtual bool get_CanCreateDataSourceEnumerator();
    public virtual DbCommand CreateCommand();
    public virtual DbCommandBuilder CreateCommandBuilder();
    public virtual DbConnection CreateConnection();
    public virtual DbConnectionStringBuilder CreateConnectionStringBuilder();
    public virtual DbDataAdapter CreateDataAdapter();
    public virtual DbDataSourceEnumerator CreateDataSourceEnumerator();
    public virtual DbParameter CreateParameter();
    public virtual CodeAccessPermission CreatePermission(PermissionState state);
}
public enum Oracle.ManagedDataAccess.Client.OracleCollectionType : Enum {
    public int value__;
    public static OracleCollectionType None;
    public static OracleCollectionType PLSQLAssociativeArray;
}
[DesignerAttribute("Oracle.VsDevTools.OracleVSGCommandDesigner, Oracle.VsDevTools, Version=4.122.1.0, Culture=neutral, PublicKeyToken=89b483f429c47342, processorArchitecture=MSIL", "System.ComponentModel.Design.IDesigner")]
[DesignerAttribute("Oracle.VsDevTools.OracleVSGCommandDesigner, Oracle.VsDevTools, Version=4.122.1.0, Culture=neutral, PublicKeyToken=89b483f429c47342, processorArchitecture=MSIL", "System.ComponentModel.Design.IDesigner")]
[ToolboxBitmapAttribute("resfinder", "Oracle.ManagedDataAccess.src.Client.Icons.OracleCommandToolBox_hc.bmp")]
public class Oracle.ManagedDataAccess.Client.OracleCommand : DbCommand {
    private static string s_ExecuteNonQuery;
    private static string s_ExecuteReader;
    private static string s_ExecuteStream;
    private static string s_ExecuteXmlReader;
    private static string s_ExecuteScalar;
    internal static int m_internalInitialJSONFS;
    internal static int m_rowsToFetch;
    internal OracleCommandImpl m_commandImpl;
    internal OracleConnection m_connection;
    internal bool m_disposed;
    internal bool m_bCanRecordNewCall;
    internal bool m_bApplicationSQL;
    internal bool m_isFromEF;
    private bool m_bBindByName_setByCmd;
    private bool m_bCommandTimeout_setByCmd;
    private bool m_bFetchSize_setByCmd;
    internal static OracleActivitySource OracleActivitySource;
    private bool m_bACEnabledOnCommand;
    private static short MI_ExecuteNonQuery;
    private static short MI_ExecuteReader;
    private static short MI_ExecuteReader_1Arg;
    private static short MI_ExecuteScalar;
    private static short MI_Cancel;
    private static short MI_ExecuteStream;
    private static short MI_ExecuteToStream;
    private static short MI_ExecuteXmlReader;
    private static int numMethods;
    private static MethodInfo[] s_miArray;
    private string m_commandText { get; private set; }
    private string m_pooledCmdText { get; private set; }
    private CommandType m_commandType { get; private set; }
    private OracleDataReader m_cachedReader { get; private set; }
    private bool m_cmdTxtModified { get; private set; }
    private int m_rowsAffected { get; private set; }
    private bool m_designTimeVisible { get; private set; }
    private int m_commandTimeout { get; private set; }
    private OracleParameterCollection m_parameters { get; private set; }
    internal bool m_modified { get; internal set; }
    internal int m_initialLongFS { get; internal set; }
    internal int m_clientInitialLOBFS { get; internal set; }
    private UpdateRowSource m_updatedRowSource { get; private set; }
    private bool m_bExecuteInProgress { get; private set; }
    internal OracleNotificationRequest m_NTFNReq { get; internal set; }
    internal bool m_NTFNAutoEnlist { get; internal set; }
    internal OracleRefCursor[] m_implicitRefCursors { get; internal set; }
    internal bool m_returnPSTypes { get; internal set; }
    private Type[] m_expectedColumnTypes { get; private set; }
    private bool m_addRowId { get; private set; }
    private bool m_addToStatementCache { get; private set; }
    private int m_arrayBindCount { get; private set; }
    private bool m_bBindByName { get; private set; }
    private long m_fetchSize { get; private set; }
    private OracleXmlCommandType m_xmlCommandType { get; private set; }
    private OracleXmlQueryProperties m_xmlQueryProperties { get; private set; }
    private OracleXmlSaveProperties m_xmlSaveProperties { get; private set; }
    private WeakReference m_lastReaderWeakRef { get; private set; }
    internal Type[] ExpectedColumnTypes { get; internal set; }
    [DefaultValueAttribute("False")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
public bool AddRowid { get; public set; }
    [CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
[DefaultValueAttribute("True")]
public bool AddToStatementCache { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("0")]
public int ArrayBindCount { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public Int64[] ArrayBindRowsAffected { get; }
    [DefaultValueAttribute("False")]
[DescriptionAttribute("")]
[CategoryAttribute("Behavior")]
public bool BindByName { get; public set; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("False")]
[CategoryAttribute("Behavior")]
public bool FetchSqlId { get; public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("")]
public string SqlId { get; }
    [DefaultValueAttribute("False")]
[DescriptionAttribute("")]
[CategoryAttribute("Behavior")]
public bool UseEdmMapping { get; public set; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public string CommandText { get; public set; }
    [DefaultValueAttribute("0")]
[BrowsableAttribute("False")]
public int CommandTimeout { get; public set; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public CommandType CommandType { get; public set; }
    [DefaultValueAttribute("")]
[DescriptionAttribute("")]
[CategoryAttribute("Data")]
public OracleRefCursor[] ImplicitRefCursors { get; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public OracleXmlCommandType XmlCommandType { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public OracleXmlQueryProperties XmlQueryProperties { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public OracleXmlSaveProperties XmlSaveProperties { get; public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Behavior")]
[DefaultValueAttribute("")]
public OracleConnection Connection { get; public set; }
    protected DbConnection DbConnection { get; protected set; }
    protected DbTransaction DbTransaction { get; protected set; }
    [BrowsableAttribute("False")]
public OracleTransaction Transaction { get; public set; }
    [DesignOnlyAttribute("True")]
[DefaultValueAttribute("True")]
[BrowsableAttribute("False")]
public bool DesignTimeVisible { get; public set; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("131072")]
public long FetchSize { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("0")]
public long RowSize { get; }
    [DefaultValueAttribute("0")]
[DescriptionAttribute("")]
public int InitialLOBFetchSize { get; public set; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("0")]
public int InitialLONGFetchSize { get; public set; }
    public UpdateRowSource UpdatedRowSource { get; public set; }
    protected DbParameterCollection DbParameterCollection { get; }
    [DescriptionAttribute("")]
[DesignerSerializationVisibilityAttribute("2")]
[CategoryAttribute("Data")]
public OracleParameterCollection Parameters { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public OracleNotificationRequest Notification { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("True")]
public bool NotificationAutoEnlist { get; public set; }
    private static OracleCommand();
    public OracleCommand(string cmdText);
    public OracleCommand(string cmdText, OracleConnection conn);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteNonQueryInternalAsync>d__0")]
internal ValueTask`1<int> ExecuteNonQueryInternalAsync(bool bAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteReaderInternalAsync>d__1")]
internal ValueTask`1<OracleDataReader> ExecuteReaderInternalAsync(bool requery, bool fillRequest, CommandBehavior behavior, bool bAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteScalarInternalAsync>d__2")]
internal ValueTask`1<object> ExecuteScalarInternalAsync(bool bAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteXmlReaderInternalAsync>d__3")]
internal ValueTask`1<XmlReader> ExecuteXmlReaderInternalAsync(bool bAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteXmlQueryAsync>d__4")]
private ValueTask`1<OracleClob> ExecuteXmlQueryAsync(bool wantResult, bool bAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteXmlSaveAsync>d__5")]
private ValueTask`1<int> ExecuteXmlSaveAsync(bool bAsync, CancellationToken cancellationToken);
    private string get_m_commandText();
    private void set_m_commandText(string value);
    private string get_m_pooledCmdText();
    private void set_m_pooledCmdText(string value);
    private CommandType get_m_commandType();
    private void set_m_commandType(CommandType value);
    private OracleDataReader get_m_cachedReader();
    private void set_m_cachedReader(OracleDataReader value);
    private bool get_m_cmdTxtModified();
    private void set_m_cmdTxtModified(bool value);
    private int get_m_rowsAffected();
    private void set_m_rowsAffected(int value);
    private bool get_m_designTimeVisible();
    private void set_m_designTimeVisible(bool value);
    private int get_m_commandTimeout();
    private void set_m_commandTimeout(int value);
    private OracleParameterCollection get_m_parameters();
    private void set_m_parameters(OracleParameterCollection value);
    internal bool get_m_modified();
    internal void set_m_modified(bool value);
    internal int get_m_initialLongFS();
    internal void set_m_initialLongFS(int value);
    internal int get_m_clientInitialLOBFS();
    internal void set_m_clientInitialLOBFS(int value);
    private UpdateRowSource get_m_updatedRowSource();
    private void set_m_updatedRowSource(UpdateRowSource value);
    private bool get_m_bExecuteInProgress();
    private void set_m_bExecuteInProgress(bool value);
    internal OracleNotificationRequest get_m_NTFNReq();
    internal void set_m_NTFNReq(OracleNotificationRequest value);
    internal bool get_m_NTFNAutoEnlist();
    internal void set_m_NTFNAutoEnlist(bool value);
    internal OracleRefCursor[] get_m_implicitRefCursors();
    internal void set_m_implicitRefCursors(OracleRefCursor[] value);
    internal bool get_m_returnPSTypes();
    internal void set_m_returnPSTypes(bool value);
    private Type[] get_m_expectedColumnTypes();
    private void set_m_expectedColumnTypes(Type[] value);
    private bool get_m_addRowId();
    private void set_m_addRowId(bool value);
    private bool get_m_addToStatementCache();
    private void set_m_addToStatementCache(bool value);
    private int get_m_arrayBindCount();
    private void set_m_arrayBindCount(int value);
    private bool get_m_bBindByName();
    private void set_m_bBindByName(bool value);
    private long get_m_fetchSize();
    private void set_m_fetchSize(long value);
    private OracleXmlCommandType get_m_xmlCommandType();
    private void set_m_xmlCommandType(OracleXmlCommandType value);
    private OracleXmlQueryProperties get_m_xmlQueryProperties();
    private void set_m_xmlQueryProperties(OracleXmlQueryProperties value);
    private OracleXmlSaveProperties get_m_xmlSaveProperties();
    private void set_m_xmlSaveProperties(OracleXmlSaveProperties value);
    private WeakReference get_m_lastReaderWeakRef();
    private void set_m_lastReaderWeakRef(WeakReference value);
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    internal void SetConnectionForReplayOnClonedInstance(OracleConnection connection);
    internal OracleCommand DeepCloneForReplay();
    internal Type[] get_ExpectedColumnTypes();
    internal void set_ExpectedColumnTypes(Type[] value);
    public bool get_AddRowid();
    public void set_AddRowid(bool value);
    public bool get_AddToStatementCache();
    public void set_AddToStatementCache(bool value);
    public int get_ArrayBindCount();
    public void set_ArrayBindCount(int value);
    public Int64[] get_ArrayBindRowsAffected();
    public bool get_BindByName();
    public void set_BindByName(bool value);
    public bool get_FetchSqlId();
    public void set_FetchSqlId(bool value);
    public string get_SqlId();
    public bool get_UseEdmMapping();
    public void set_UseEdmMapping(bool value);
    public virtual string get_CommandText();
    public virtual void set_CommandText(string value);
    public virtual int get_CommandTimeout();
    public virtual void set_CommandTimeout(int value);
    public virtual CommandType get_CommandType();
    public virtual void set_CommandType(CommandType value);
    public OracleRefCursor[] get_ImplicitRefCursors();
    public OracleXmlCommandType get_XmlCommandType();
    public void set_XmlCommandType(OracleXmlCommandType value);
    public OracleXmlQueryProperties get_XmlQueryProperties();
    public void set_XmlQueryProperties(OracleXmlQueryProperties value);
    public OracleXmlSaveProperties get_XmlSaveProperties();
    public void set_XmlSaveProperties(OracleXmlSaveProperties value);
    public OracleConnection get_Connection();
    public void set_Connection(OracleConnection value);
    protected virtual DbConnection get_DbConnection();
    protected virtual void set_DbConnection(DbConnection value);
    protected virtual DbTransaction get_DbTransaction();
    protected virtual void set_DbTransaction(DbTransaction value);
    public OracleTransaction get_Transaction();
    public void set_Transaction(OracleTransaction value);
    public virtual bool get_DesignTimeVisible();
    public virtual void set_DesignTimeVisible(bool value);
    public long get_FetchSize();
    public void set_FetchSize(long value);
    public long get_RowSize();
    public int get_InitialLOBFetchSize();
    public void set_InitialLOBFetchSize(int value);
    public int get_InitialLONGFetchSize();
    public void set_InitialLONGFetchSize(int value);
    public virtual UpdateRowSource get_UpdatedRowSource();
    public virtual void set_UpdatedRowSource(UpdateRowSource value);
    protected virtual DbParameterCollection get_DbParameterCollection();
    public OracleParameterCollection get_Parameters();
    public OracleNotificationRequest get_Notification();
    public void set_Notification(OracleNotificationRequest value);
    public bool get_NotificationAutoEnlist();
    public void set_NotificationAutoEnlist(bool value);
    public virtual void Cancel();
    public sealed virtual object Clone();
    protected virtual DbParameter CreateDbParameter();
    protected virtual DbDataReader ExecuteDbDataReader(CommandBehavior behavior);
    public OracleParameter CreateParameter();
    protected virtual void Dispose(bool disposing);
    private void BuildCommandText();
    private OracleParameter GetReturnValueParam();
    private void DoPreExecuteProcessing(OracleDependencyImpl orclDependencyImpl, bool bXmlQuerySave);
    internal void CancelAsyncCommandExecution();
    public virtual Task`1<int> ExecuteNonQueryAsync(CancellationToken cancellationToken);
    public Task`1<OracleDataReader> ExecuteReaderAsync();
    public Task`1<OracleDataReader> ExecuteReaderAsync(CommandBehavior behavior);
    public Task`1<OracleDataReader> ExecuteReaderAsync(CancellationToken cancellationToken);
    public Task`1<OracleDataReader> ExecuteReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
    protected virtual Task`1<DbDataReader> ExecuteDbDataReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
    public virtual Task`1<object> ExecuteScalarAsync(CancellationToken cancellationToken);
    public Task`1<XmlReader> ExecuteXmlReaderAsync();
    public Task`1<XmlReader> ExecuteXmlReaderAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteReaderAsyncHelper>d__228")]
internal ValueTask`1<OracleDataReader> ExecuteReaderAsyncHelper(bool requery, bool fillRequest, CommandBehavior behavior, CancellationToken cancellationToken, string callingMethodName);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteNonQueryAsyncHelper>d__229")]
internal ValueTask`1<int> ExecuteNonQueryAsyncHelper(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteScalarAsyncHelper>d__230")]
internal ValueTask`1<object> ExecuteScalarAsyncHelper(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleCommand/<ExecuteXmlReaderAsyncHelper>d__231")]
internal ValueTask`1<XmlReader> ExecuteXmlReaderAsyncHelper(CancellationToken cancellationToken, string callingMethodName);
    private void PutStatementInCache();
    public virtual int ExecuteNonQuery();
    internal SQLMetaData DoDescribeSelectQuery(Int32& hiddenColumnCount);
    public OracleDataReader ExecuteReader();
    public OracleDataReader ExecuteReader(CommandBehavior behavior);
    public virtual object ExecuteScalar();
    public Stream ExecuteStream();
    public void ExecuteToStream(Stream outputStream);
    public XmlReader ExecuteXmlReader();
    public virtual void Prepare();
    private Timer SetupCommandTimeoutCallback();
    private void CommandTimeoutCallback(object state);
    private void PopulateSubscriptionInfo(OracleDependencyImpl& orclDependencyImpl);
    private void AddRefCursorParamToParamColl(RefCursorInfo cursorInfo);
    private String[] GetPlsqlOutput();
    private void ValidateStatePriorToExecution();
    private OracleCommandImpl GetInitializedCommandImpl();
    internal int ExecuteNonQueryInternal(bool bAsync);
    internal OracleDataReader ExecuteReaderInternal(bool requery, bool fillRequest, CommandBehavior behavior, bool bAsync);
    internal object ExecuteScalarInternal(bool bAsync);
    internal XmlReader ExecuteXmlReaderInternal(bool bAsync);
    private OracleClob ExecuteXmlQuery(bool wantResult, bool bAsync);
    private int ExecuteXmlSave(bool bAsync);
}
[ToolboxBitmapAttribute("resfinder", "Oracle.ManagedDataAccess.src.Client.Icons.OracleCommandBuilderToolBox_hc.bmp")]
public class Oracle.ManagedDataAccess.Client.OracleCommandBuilder : DbCommandBuilder {
    private bool m_caseSensitive;
    private OracleRowUpdatingEventHandler m_handler;
    private OracleCommand m_deleteCmd;
    private OracleCommand m_insertCmd;
    private OracleCommand m_updateCmd;
    private ArrayList m_cachedInsertParams;
    private ArrayList m_cachedUpdateParams;
    private ArrayList m_cachedDeleteParams;
    private bool m_disposed;
    private static object m_dpLock;
    private static OracleCommand m_dpCommand;
    private static OracleParameter[] m_dpCommandParams;
    private bool m_ODTDesignMode;
    private static int m_sMaxParamNameLen;
    private static string QUOTE;
    private static string SCHEMA_SEPERATOR;
    private SQLMetaData m_sqlMetaData;
    private int m_numberOfHiddenColumns;
    private object m_traceObj;
    internal bool m_bCanRecordNewCall;
    private static int NO_OF_PARAMS;
    private static int NAME_IN;
    private static int PARAM_COUNT_IN;
    private static int PARAM_COUNT_OUT;
    private static int PARAM_NAME_OUT;
    private static int DIRECTION_OUT;
    private static int ORADBTYPE_OUT;
    private static int SIZE_OUT;
    private static int TYPE_NAME_OUT;
    private static int POSITION_OUT;
    private static int DATA_LEVEL_OUT;
    private static int ASSOC_TYPE_OUT;
    private static int ASSOC_TYPE_NAME_OUT;
    private static int ASSOC_TYPE_SIZE_OUT;
    private static int PLSQL_TYPE_NAME_OUT;
    private static int TYPE_SUBNAME_OUT;
    private static int MAX_ARG_NAME_LENGTH;
    private static int FIRST_FETCH_COUNT;
    private static string DP_COMMAND_TEXT_12202_N_ABOVE;
    private static string DP_COMMAND_TEXT_TILL_12201;
    private bool ODTDesignMode { get; private set; }
    [DefaultValueAttribute("True")]
[DescriptionAttribute("")]
public bool CaseSensitive { get; public set; }
    [DefaultValueAttribute("")]
[DescriptionAttribute("")]
public OracleDataAdapter DataAdapter { get; public set; }
    [DefaultValueAttribute(""")]
public string QuoteSuffix { get; public set; }
    [DefaultValueAttribute(".")]
public string SchemaSeparator { get; public set; }
    [DefaultValueAttribute(""")]
public string QuotePrefix { get; public set; }
    public CatalogLocation CatalogLocation { get; public set; }
    public string CatalogSeparator { get; public set; }
    public OracleCommandBuilder(OracleDataAdapter dataAdapter);
    private static OracleCommandBuilder();
    private bool get_ODTDesignMode();
    private void set_ODTDesignMode(bool value);
    public static void DeriveParameters(OracleCommand command);
    private static void PopulateDeriveParamInfoFromDpCommandExecution(DeriveParamInfo& deriveParamInfo, OracleCommand cmd, bool isDB12202nAbove, String[] paramNameArray, Int32[] directionArray, Int32[] oraDbTypeArray, Int32[] sizeArray, String[] typeNameArray, Int32[] positionArray, Int32[] dataLevelOutArray, Int32[] assocTypeArray, String[] assocTypeNameArray, Int32[] assocTypeSizeArray, String[] plsqlTypeNameArray, String[] typeSubNameArray);
    private static void SetUpDpCommand(OracleCommand command);
    private static void PopulateCommandParamsFromDeriveParamInfo(OracleCommand command, DeriveParamInfo deriveParamInfo);
    internal void SetConnectionForReplayOnClonedInstance(OracleConnection connection);
    internal OracleCommandBuilder DeepCloneForReplay();
    public OracleCommand GetDeleteCommand(bool useColumnsForParameterNames);
    public OracleCommand GetInsertCommand(bool useColumnsForParameterNames);
    public OracleCommand GetUpdateCommand(bool useColumnsForParameterNames);
    internal OracleCommand GetInsertCommand(DataRow row);
    internal OracleCommand GetUpdateCommand(DataRow row);
    private bool CheckDataTable(DataTable table);
    private void SetParam(string colName, OracleDbType colType, DataRowVersion version, object value, OracleParameter param);
    private void CheckPrimaryKey();
    private void CheckPrimaryKey(DataRow row);
    private OracleDbType GetColumnType(int col);
    private OracleDbType GetColumnType(DataColumn col);
    private string GetSchemaName();
    private string GetSchemaName(DataTable table);
    private string GetBaseTableName();
    private string GetBaseTableName(bool caseSensitive);
    private string GetBaseTableName(DataTable table);
    private string GetBaseTableName(DataTable table, bool caseSensitive);
    private string GetUdtTypeName(int col);
    private string GetUdtTypeName(DataColumn col);
    private int FindBaseColumnOrdinal(DataColumn col);
    public OracleCommand GetDeleteCommand();
    private bool FillSchemaMetaData();
    internal OracleCommand GetDeleteCommand(DataRow row);
    public OracleCommand GetInsertCommand();
    public OracleCommand GetUpdateCommand();
    public virtual string QuoteIdentifier(string unquotedIdentifier);
    public virtual string UnquoteIdentifier(string quotedIdentifier);
    public virtual void RefreshSchema();
    protected virtual void ApplyParameterInfo(DbParameter parameter, DataRow row, StatementType statementType, bool whereClause);
    private bool IsOraLOB(OracleDbType colType);
    private bool IsOraLONG(OracleDbType colType);
    private bool IsOraXmlType(OracleDbType colType);
    private bool IsOraUDT(OracleDbType colType);
    private bool IsOraJson(OracleDbType colType);
    private bool IsOraVector(OracleDbType colType);
    private bool IsRowOrigValueNull(DataRow row, DataColumn col);
    private string GenerateParameterName(string prefix, int srcColumnLen, string srcColumn, int paramId);
    private OracleParameter CreateParams(string paramName, string colName, OracleDbType colType, DataRowVersion version, object value);
    protected virtual DbCommand InitializeCommand(DbCommand command);
    protected virtual string GetParameterName(int parameterOrdinal);
    protected virtual string GetParameterName(string parameterName);
    protected virtual string GetParameterPlaceholder(int parameterOrdinal);
    protected virtual DataTable GetSchemaTable(DbCommand srcCommand);
    protected virtual void SetRowUpdatingHandler(DbDataAdapter adapter);
    public bool get_CaseSensitive();
    public void set_CaseSensitive(bool value);
    public OracleDataAdapter get_DataAdapter();
    public void set_DataAdapter(OracleDataAdapter value);
    public virtual string get_QuoteSuffix();
    public virtual void set_QuoteSuffix(string value);
    public virtual string get_SchemaSeparator();
    public virtual void set_SchemaSeparator(string value);
    public virtual string get_QuotePrefix();
    public virtual void set_QuotePrefix(string value);
    public virtual CatalogLocation get_CatalogLocation();
    public virtual void set_CatalogLocation(CatalogLocation value);
    public virtual string get_CatalogSeparator();
    public virtual void set_CatalogSeparator(string value);
    private void RowUpdating(object src, OracleRowUpdatingEventArgs arg);
    private string GetColumnName(DataColumn col, bool baseColumn);
    private string GetColumnName(int col, bool baseColumn);
    private string GetColumnName(int col, bool baseColumn, bool caseSensitive);
    private string GetColumnName(DataColumn col, bool baseColumn, bool caseSensitive);
    protected virtual void Dispose(bool disposing);
    private bool IsRowCurrentValueNull(DataRow row, DataColumn col);
    private bool IsColumnModified(DataRow row, DataColumn col);
}
public static class Oracle.ManagedDataAccess.Client.OracleConfiguration : object {
    internal static object s_syncObj;
    internal static bool bConfigureAwait;
    internal static bool m_bIsWindows;
    internal static SqlNetOraConfig SNOConfig;
    private static Hashtable LdapCP;
    private static Hashtable SqlnCP;
    internal static HashSet`1<UrlProviderType> m_enabledConfigProviders;
    private static OracleDataSourceCollection s_orclDataSources;
    private static OraclePoolNameCollection s_orclPoolNameCollection;
    private static string s_program;
    private static bool fromCID;
    internal static Hashtable propertySetByOcfg;
    internal static string s_walletLocation;
    internal static string DIRECTORY_SERVERS;
    internal static string DIRECTORY_SERVER_TYPE;
    internal static string DEFAULT_ADMIN_CONTEXT;
    private static OracleOnsServerCollection s_onsServers;
    public static OracleDataSourceCollection OracleDataSources { get; }
    public static OraclePoolNameCollection PoolNames { get; }
    internal static string CIDProgram { get; }
    internal static string SessionProgram { get; }
    public static string Program { get; public set; }
    public static int DefaultSDUSize { get; public set; }
    public static int CommandTimeout { get; public set; }
    public static int DbNotificationPort { get; public set; }
    public static string DbNotificationAddress { get; public set; }
    public static bool UseClientInitiatedCQN { get; public set; }
    public static bool TAFUsePooledConnections { get; public set; }
    public static bool BindByName { get; public set; }
    public static bool GetDecimalRetainTrailingZeros { get; public set; }
    public static int FetchSize { get; public set; }
    public static int MaxStatementCacheSize { get; public set; }
    public static bool SelfTuning { get; public set; }
    public static int StatementCacheSize { get; public set; }
    public static bool Pipelining { get; public set; }
    public static long PerformanceCounters { get; public set; }
    public static bool SuppressErrorURL { get; public set; }
    public static bool MapVectorColumnAsClob { get; public set; }
    public static string TnsAdmin { get; public set; }
    public static string OraDebugJdwp { get; public set; }
    public static string LdapAdmin { get; public set; }
    public static OracleTokenAuth TokenAuthentication { get; public set; }
    public static string TokenLocation { get; public set; }
    public static OraclePasswordAuth PasswordAuthentication { get; public set; }
    public static string OciIamUrl { get; public set; }
    public static string OciTenancy { get; public set; }
    public static string OciCompartment { get; public set; }
    public static string OciDatabase { get; public set; }
    public static string OciConfigurationFile { get; public set; }
    public static string OciProfile { get; public set; }
    public static string ServiceRelocationConnectionTimeout { get; public set; }
    public static string ChunkMigrationConnectionTimeout { get; public set; }
    public static string TraceFileLocation { get; public set; }
    public static int TraceLevel { get; public set; }
    public static int TraceOption { get; public set; }
    public static int TraceFileMaxSize { get; public set; }
    public static bool HAEvents { get; public set; }
    public static bool LoadBalancing { get; public set; }
    public static string DrcpConnectionClass { get; public set; }
    public static string DatabaseEditionName { get; public set; }
    public static string ConfigurationProviders { get; public set; }
    public static bool SSLServerDNMatch { get; public set; }
    public static string SSLVersion { get; public set; }
    public static string SSLCertificateThumbprint { get; public set; }
    public static string SqlNetAuthenticationServices { get; public set; }
    public static string SqlNetEncryptionTypesClient { get; public set; }
    public static string SqlNetEncryptionClient { get; public set; }
    public static string SqlNetCryptoChecksumTypesClient { get; public set; }
    public static string SqlNetCryptoChecksumClient { get; public set; }
    public static bool SqlNetAllowWeakCrypto { get; public set; }
    public static bool SqlNetWalletOverride { get; public set; }
    unknown static OracleAllowedLogonVersionClient SqlNetAllowedLogonVersionClient {public set; }
    unknown static OracleDatabaseCharset DatabaseCharset {public set; }
    unknown static OracleDatabaseNCharset DatabaseNCharset {public set; }
    public static string NamesDirectoryPath { get; public set; }
    public static bool NamesLdapAuthenticateBind { get; public set; }
    public static string NamesLdapAuthenticateBindMethod { get; public set; }
    public static int NamesLdapConnTimeout { get; public set; }
    public static bool OpenTelemetryTracing { get; public set; }
    public static string WalletLocation { get; public set; }
    public static int TcpConnectTimeout { get; public set; }
    public static bool DisableOOB { get; public set; }
    public static bool TcpNoDelay { get; public set; }
    public static int SendBufferSize { get; public set; }
    public static int ReceiveBufferSize { get; public set; }
    [ObsoleteAttribute("This property will soon be deprecated. Use DirectoryServerType instead.")]
public static string DirectoryType { get; public set; }
    public static string DirectoryServerType { get; public set; }
    public static string DefaultAdminContext { get; public set; }
    public static string DirectoryServers { get; public set; }
    public static string OnsConfigFile { get; public set; }
    public static OnsConfigMode OnsMode { get; public set; }
    public static string OnsProtocol { get; public set; }
    public static string OnsWalletLocation { get; public set; }
    public static OracleOnsServerCollection OracleOnsServers { get; }
    public static string SqlNetURI { get; public set; }
    public static string SqlNetCloudUser { get; public set; }
    public static string ConnectionIdPrefix { get; public set; }
    public static bool SuppressGetDecimalInvalidCastException { get; public set; }
    private static OracleConfiguration();
    internal static void HandleSet(Hashtable theParams, string propName, string paramName, object value, bool checknull, bool fromJsonConfig);
    internal static void DumpInfo();
    public static OracleDataSourceCollection get_OracleDataSources();
    public static OraclePoolNameCollection get_PoolNames();
    private static void SetDefaultProgram();
    internal static string get_CIDProgram();
    internal static string get_SessionProgram();
    public static string get_Program();
    public static void set_Program(string value);
    public static int get_DefaultSDUSize();
    public static void set_DefaultSDUSize(int value);
    public static int get_CommandTimeout();
    public static void set_CommandTimeout(int value);
    public static int get_DbNotificationPort();
    public static void set_DbNotificationPort(int value);
    public static string get_DbNotificationAddress();
    public static void set_DbNotificationAddress(string value);
    public static bool get_UseClientInitiatedCQN();
    public static void set_UseClientInitiatedCQN(bool value);
    public static bool get_TAFUsePooledConnections();
    public static void set_TAFUsePooledConnections(bool value);
    public static bool get_BindByName();
    public static void set_BindByName(bool value);
    public static bool get_GetDecimalRetainTrailingZeros();
    public static void set_GetDecimalRetainTrailingZeros(bool value);
    public static int get_FetchSize();
    public static void set_FetchSize(int value);
    public static int get_MaxStatementCacheSize();
    public static void set_MaxStatementCacheSize(int value);
    public static bool get_SelfTuning();
    public static void set_SelfTuning(bool value);
    public static int get_StatementCacheSize();
    public static void set_StatementCacheSize(int value);
    public static bool get_Pipelining();
    public static void set_Pipelining(bool value);
    public static long get_PerformanceCounters();
    public static void set_PerformanceCounters(long value);
    public static bool get_SuppressErrorURL();
    public static void set_SuppressErrorURL(bool value);
    public static bool get_MapVectorColumnAsClob();
    public static void set_MapVectorColumnAsClob(bool value);
    public static string get_TnsAdmin();
    public static void set_TnsAdmin(string value);
    public static string get_OraDebugJdwp();
    public static void set_OraDebugJdwp(string value);
    public static string get_LdapAdmin();
    public static void set_LdapAdmin(string value);
    public static OracleTokenAuth get_TokenAuthentication();
    public static void set_TokenAuthentication(OracleTokenAuth value);
    public static string get_TokenLocation();
    public static void set_TokenLocation(string value);
    public static OraclePasswordAuth get_PasswordAuthentication();
    public static void set_PasswordAuthentication(OraclePasswordAuth value);
    public static string get_OciIamUrl();
    public static void set_OciIamUrl(string value);
    public static string get_OciTenancy();
    public static void set_OciTenancy(string value);
    public static string get_OciCompartment();
    public static void set_OciCompartment(string value);
    public static string get_OciDatabase();
    public static void set_OciDatabase(string value);
    public static string get_OciConfigurationFile();
    public static void set_OciConfigurationFile(string value);
    public static string get_OciProfile();
    public static void set_OciProfile(string value);
    public static string get_ServiceRelocationConnectionTimeout();
    public static void set_ServiceRelocationConnectionTimeout(string value);
    public static string get_ChunkMigrationConnectionTimeout();
    public static void set_ChunkMigrationConnectionTimeout(string value);
    public static string get_TraceFileLocation();
    public static void set_TraceFileLocation(string value);
    public static int get_TraceLevel();
    public static void set_TraceLevel(int value);
    public static int get_TraceOption();
    public static void set_TraceOption(int value);
    public static int get_TraceFileMaxSize();
    public static void set_TraceFileMaxSize(int value);
    public static bool get_HAEvents();
    public static void set_HAEvents(bool value);
    public static bool get_LoadBalancing();
    public static void set_LoadBalancing(bool value);
    public static string get_DrcpConnectionClass();
    public static void set_DrcpConnectionClass(string value);
    public static string get_DatabaseEditionName();
    public static void set_DatabaseEditionName(string value);
    public static string get_ConfigurationProviders();
    public static void set_ConfigurationProviders(string value);
    public static bool get_SSLServerDNMatch();
    public static void set_SSLServerDNMatch(bool value);
    public static string get_SSLVersion();
    public static void set_SSLVersion(string value);
    public static string get_SSLCertificateThumbprint();
    public static void set_SSLCertificateThumbprint(string value);
    public static string get_SqlNetAuthenticationServices();
    public static void set_SqlNetAuthenticationServices(string value);
    public static string get_SqlNetEncryptionTypesClient();
    public static void set_SqlNetEncryptionTypesClient(string value);
    public static string get_SqlNetEncryptionClient();
    public static void set_SqlNetEncryptionClient(string value);
    public static string get_SqlNetCryptoChecksumTypesClient();
    public static void set_SqlNetCryptoChecksumTypesClient(string value);
    public static string get_SqlNetCryptoChecksumClient();
    public static void set_SqlNetCryptoChecksumClient(string value);
    public static bool get_SqlNetAllowWeakCrypto();
    public static void set_SqlNetAllowWeakCrypto(bool value);
    public static bool get_SqlNetWalletOverride();
    public static void set_SqlNetWalletOverride(bool value);
    public static void set_SqlNetAllowedLogonVersionClient(OracleAllowedLogonVersionClient value);
    public static void set_DatabaseCharset(OracleDatabaseCharset value);
    public static void set_DatabaseNCharset(OracleDatabaseNCharset value);
    internal static string ConvertALVEnumToString(OracleAllowedLogonVersionClient alvc);
    public static string get_NamesDirectoryPath();
    public static void set_NamesDirectoryPath(string value);
    public static bool get_NamesLdapAuthenticateBind();
    public static void set_NamesLdapAuthenticateBind(bool value);
    public static string get_NamesLdapAuthenticateBindMethod();
    public static void set_NamesLdapAuthenticateBindMethod(string value);
    public static int get_NamesLdapConnTimeout();
    public static void set_NamesLdapConnTimeout(int value);
    public static bool get_OpenTelemetryTracing();
    public static void set_OpenTelemetryTracing(bool value);
    public static string get_WalletLocation();
    public static void set_WalletLocation(string value);
    public static int get_TcpConnectTimeout();
    public static void set_TcpConnectTimeout(int value);
    public static bool get_DisableOOB();
    public static void set_DisableOOB(bool value);
    public static bool get_TcpNoDelay();
    public static void set_TcpNoDelay(bool value);
    public static int get_SendBufferSize();
    public static void set_SendBufferSize(int value);
    public static int get_ReceiveBufferSize();
    public static void set_ReceiveBufferSize(int value);
    public static string get_DirectoryType();
    public static void set_DirectoryType(string value);
    public static string get_DirectoryServerType();
    public static void set_DirectoryServerType(string value);
    public static string get_DefaultAdminContext();
    public static void set_DefaultAdminContext(string value);
    public static string get_DirectoryServers();
    public static void set_DirectoryServers(string value);
    public static string get_OnsConfigFile();
    public static void set_OnsConfigFile(string value);
    public static OnsConfigMode get_OnsMode();
    public static void set_OnsMode(OnsConfigMode value);
    public static string get_OnsProtocol();
    public static void set_OnsProtocol(string value);
    public static string get_OnsWalletLocation();
    public static void set_OnsWalletLocation(string value);
    public static OracleOnsServerCollection get_OracleOnsServers();
    internal static string GetPropertyFromONSConfig(string ONSConfigFile, string onsConfigProperty);
    private static String[] GetName(StreamReader strmRdr, String& leftover);
    private static string GetValue(StreamReader strmRdr, string leftover);
    internal static void ProcessSRCT(string value, OracleConnectionInternal connectionInternal);
    internal static void ProcessCMCT(string value, OracleConnectionInternal connectionInternal);
    internal static string GetProviderLocation();
    internal static void ParseConfigurationProviders(string configProviders);
    internal static void AddProviderType(string providerType, HashSet`1<UrlProviderType> providerTypes);
    public static string get_SqlNetURI();
    public static void set_SqlNetURI(string value);
    public static string get_SqlNetCloudUser();
    public static void set_SqlNetCloudUser(string value);
    public static string get_ConnectionIdPrefix();
    public static void set_ConnectionIdPrefix(string value);
    public static bool get_SuppressGetDecimalInvalidCastException();
    public static void set_SuppressGetDecimalInvalidCastException(bool value);
    public static void AddOracleTypesDeserialization();
    internal static void EnableOpenTelemetry(OracleDataProviderInstrumentationOptions configureInstrumentationOptions);
}
public class Oracle.ManagedDataAccess.Client.OracleConfigurationProvider : object {
    internal int m_id;
    internal string m_providerName;
    internal static Char[] trimChars;
    internal static string AZURE_CONFIG_NAME;
    internal static int AZURE_CONFIG_VALUE;
    internal static string OCI_CONFIG_NAME;
    internal static int OCI_CONFIG_VALUE;
    internal static string AZURE_VAULT_NAME;
    internal static int AZURE_VAULT_VALUE;
    internal static string OCI_VAULT_NAME;
    internal static int OCI_VAULT_VALUE;
    internal static string FILE_CONFIG_NAME;
    internal static int FILE_CONFIG_VALUE;
    internal static string ALL_NAME;
    internal static int ALL_VALUE;
    internal static string NONE_NAME;
    internal static int NONE_VALUE;
    public static OracleConfigurationProvider Azure;
    public static OracleConfigurationProvider OCIObject;
    public static OracleConfigurationProvider File;
    public static OracleConfigurationProvider AzureVault;
    public static OracleConfigurationProvider OCIVault;
    public static OracleConfigurationProvider All;
    public static OracleConfigurationProvider None;
    public string ProviderName { get; }
    public int Id { get; }
    private OracleConfigurationProvider(int id, string providerName);
    private static OracleConfigurationProvider();
    public string get_ProviderName();
    public int get_Id();
    internal static string GetProviderName(UrlProviderType providerType);
    public static OracleConfigurationProvider op_BitwiseOr(OracleConfigurationProvider left, OracleConfigurationProvider right);
    public static string op_Implicit(OracleConfigurationProvider configurationProvider);
    public sealed virtual int CompareTo(object other);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ToolboxBitmapAttribute("resfinder", "Oracle.ManagedDataAccess.src.Client.Icons.OracleConnectionToolBox_hc.bmp")]
[DefaultEventAttribute("InfoMessage")]
public class Oracle.ManagedDataAccess.Client.OracleConnection : DbConnection {
    internal OracleConnectionInternal m_delegate;
    internal bool m_bCanRecordNewCall;
    internal bool m_bPrelimAuthSession;
    internal bool m_bMustCallRollback;
    internal bool m_bConnectionFailedOver;
    internal OracleTAFMode m_tafMode;
    private static string METADATA_COLLECTION;
    private static string DATA_TYPES;
    private static string RESTRICTIONS;
    private static string RESERVED_WORDS;
    private static string DATA_SOURCE_INFORMATION;
    private static string ORCL_COMMAND;
    private static string DATA_TABLE;
    internal static string ODP_NAME;
    internal static string s_getLTXIDstatus;
    internal OracleFailoverEventHandler m_failoverEventHandler;
    internal static OracleHAEventHandler m_haEventHandler;
    internal StateChangeEventHandler m_stateChangeEventHandler;
    internal OracleInfoMessageEventHandler m_infoMessageEventHandler;
    internal OracleConnectionOpenEventHandler m_conOpenEventHandler;
    private static short MI_BeginTransaction;
    private static short MI_BeginTransaction_1Arg;
    private static short MI_Commit;
    private static short MI_Rollback;
    private static short MI_Rollback_1Arg;
    private static short MI_Save;
    private static short MI_SetIsolationLevel;
    private static int numMethods;
    private static MethodInfo[] s_miArray;
    internal static bool m_bAtLeastOneConOpen { get; internal set; }
    public static bool IsAvailable { get; }
    internal OracleConnectionImpl m_oracleConnectionImpl { get; internal set; }
    internal OracleLogicalTransaction OracleLogicalTransaction { get; }
    internal OraclePermission m_orclPermission { get; }
    internal ConnectionString m_cs { get; }
    internal ConnectionState m_connectionState { get; internal set; }
    internal OracleTransaction m_oraTransaction { get; internal set; }
    internal int m_majorVersion { get; }
    internal int m_minorVersion { get; }
    internal bool m_isDb10gR2OrHigher { get; }
    internal bool m_isDb11gR1OrHigher { get; }
    internal bool m_isDb12cR1OrHigher { get; }
    internal string m_serverVersion { get; internal set; }
    internal string ShardingKeyB64 { get; }
    internal string SuperShardingKeyB64 { get; }
    internal string m_shardingChunk { get; internal set; }
    internal int m_shardingChunkId { get; internal set; }
    internal String[] m_shardingInstances { get; internal set; }
    internal InstanceInfo[] m_shardingInstanceInfos { get; internal set; }
    internal OracleOpaqueString m_opaquePassw { get; }
    internal OracleOpaqueString m_opaqueProxyPassw { get; }
    internal OracleOpaqueString m_opaqueNewPassw { get; }
    internal OracleCredential m_orclCredential { get; internal set; }
    internal bool m_passwValidated { get; internal set; }
    internal bool m_disposed { get; internal set; }
    internal bool bIgnoreLogicalTransaction { get; internal set; }
    internal bool bConnectionforTxnStatus { get; internal set; }
    internal string m_criteriaConnCls { get; internal set; }
    internal string m_criteriaPdbName { get; internal set; }
    internal string m_criteriaServiceName { get; internal set; }
    internal string m_criteriaEdition { get; }
    internal string m_criteriaTag { get; }
    internal byte m_bCriteriaDrcpPurityNew { get; internal set; }
    internal bool m_serviceSwitchRequested { get; }
    internal bool m_fromMTS { get; internal set; }
    internal string m_pdbName { get; internal set; }
    internal string m_serviceName { get; internal set; }
    internal string m_userProvidedConEditionName { get; internal set; }
    internal UInt32[] m_criteriaIds { get; }
    internal bool m_bBestMatchPRHasAllMustCrit { get; internal set; }
    internal bool m_bfoundPRMatchingAllCrit { get; internal set; }
    internal bool m_bNewConCreated { get; internal set; }
    internal bool m_bCriteriaPrelimAuthSession { get; }
    internal string m_chunkMigrationConTimeout { get; }
    internal string m_TNS_ADMIN { get; }
    internal string m_Wallet_Location { get; }
    internal string m_SSLCerticateThumbprint { get; }
    internal string m_SqlNetAuthenticationServices { get; }
    internal bool m_SqlnetWalletOverride { get; }
    internal bool m_AllowCertSelectionUI { get; }
    internal bool m_UseHourOffsetForUnsupportedTimezone { get; }
    internal int m_SDU { get; }
    internal IsolationLevel m_isolationLevel { get; }
    internal bool m_isIsolationLevelSet { get; }
    internal bool m_autoCommit { get; }
    internal OracleTokenAuth m_tokenAuth { get; }
    internal string m_tokenLocation { get; }
    internal OraclePasswordAuth m_passwAuth { get; }
    internal string m_ociIamUrl { get; }
    internal string m_ociTenancy { get; }
    internal string m_ociCompartment { get; }
    internal string m_ociDatabase { get; }
    internal AbstractTokenAuthentication m_tokenConfiguration { get; }
    internal bool m_bTokenConfiguration_setByApp { get; }
    internal bool m_bStartupShutdown { get; internal set; }
    internal bool m_bChunkMigrationConnectionTimeout_setByApp { get; }
    internal bool m_bFromConfigCMCT { get; }
    internal int m_cmctOffset { get; }
    internal bool m_bTimeoutInCMCT { get; }
    internal bool m_bDrcpConnectionClass_setByApp { get; }
    internal bool m_bUserProvidedConEditionName_setByApp { get; }
    internal bool m_bBindByName_setByApp { get; }
    internal bool m_bCommandTimeout_setByApp { get; }
    internal bool m_bFetchSize_setByApp { get; }
    internal bool m_bPipelining_setByApp { get; }
    internal bool m_bMaxStatementCacheSize_setByApp { get; }
    internal bool m_MaxStatementCacheSize_IsUserDefined { get; }
    internal bool m_bServiceRelocationConnectionTimeout_setByApp { get; }
    internal bool m_bFromConfigSRCT { get; }
    internal int m_srctOffset { get; }
    internal bool m_bDrainTimeoutInSRCT { get; }
    internal bool m_bUseClientInitiatedCQN_setByApp { get; }
    internal bool m_bSingleSessionProxyConReplacement { get; internal set; }
    internal ITokenAuthenticationProvider m_tokenProvider { get; }
    [CategoryAttribute("Data")]
[BrowsableAttribute("False")]
[DescriptionAttribute("")]
[DefaultValueAttribute("")]
public OracleAccessToken AccessToken { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public OracleTokenAuth TokenAuthentication { get; public set; }
    [DefaultValueAttribute("")]
public string TokenLocation { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public OraclePasswordAuth PasswordAuthentication { get; public set; }
    [DefaultValueAttribute("")]
public string OciIamUrl { get; public set; }
    [DefaultValueAttribute("")]
public string OciTenancy { get; public set; }
    [DefaultValueAttribute("")]
public string OciCompartment { get; public set; }
    [DefaultValueAttribute("")]
public string OciDatabase { get; public set; }
    internal UrlProviderType ConnStrProviderType { get; }
    internal bool IsStandardConnStrType { get; }
    internal bool IsUrlConnStrType { get; }
    internal UrlConnInfo UrlConnInfo { get; }
    internal ProviderUrl ConnStrUrl { get; }
    public bool IsInTransaction { get; }
    public string Database { get; }
    [DescriptionAttribute("")]
[BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public static string ProviderName { get; }
    public static string ProviderVersion { get; }
    public static string ProviderNuGetVersion { get; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("")]
public string DataSource { get; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("")]
[BrowsableAttribute("False")]
public string ServerVersion { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[BrowsableAttribute("False")]
[DescriptionAttribute("")]
public ConnectionState State { get; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("0")]
[BrowsableAttribute("False")]
public int StatementCacheSize { get; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("")]
[DefaultValueAttribute("")]
unknown string ModuleName {public set; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
unknown string ActionName {public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("")]
unknown string ClientId {public set; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
unknown string ClientInfo {public set; }
    unknown OracleTAFMode TAFMode {public set; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("")]
[DefaultValueAttribute("")]
public string ServiceName { get; public set; }
    [DefaultValueAttribute("")]
[DescriptionAttribute("")]
[CategoryAttribute("Data")]
public string PDBName { get; public set; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public string DatabaseEditionName { get; public set; }
    [DefaultValueAttribute("False")]
[DescriptionAttribute("")]
[CategoryAttribute("Behavior")]
public bool SwitchedConnection { get; }
    public string WalletLocation { get; public set; }
    public string TnsAdmin { get; public set; }
    public bool AutoCommit { get; public set; }
    [CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
[DefaultValueAttribute("False")]
public bool UseHourOffsetForUnsupportedTimezone { get; public set; }
    protected DbProviderFactory DbProviderFactory { get; }
    public OracleShardingKey ShardingKey { get; }
    public OracleShardingKey SuperShardingKey { get; }
    public string SSLCertificateThumbprint { get; public set; }
    public string SqlNetAuthenticationServices { get; public set; }
    public string NamesDirectoryPath { get; public set; }
    public bool SqlnetWalletOverride { get; public set; }
    unknown OracleAllowedLogonVersionClient SqlNetAllowedLogonVersionClient {public set; }
    public bool AllowCertificateSelectionUI { get; public set; }
    public bool KeepAlive { get; public set; }
    public int KeepAliveTime { get; public set; }
    public int KeepAliveInterval { get; public set; }
    unknown int SDU {public set; }
    unknown OracleDatabaseCharset DatabaseCharset {public set; }
    unknown OracleDatabaseNCharset DatabaseNCharset {public set; }
    public string ConnectionId { get; }
    internal object TraceObj { get; }
    internal string m_connectionIdPrefix { get; }
    unknown string ConnectionIdPrefix {public set; }
    [DefaultValueAttribute("15")]
[BrowsableAttribute("False")]
[DescriptionAttribute("")]
public int ConnectionTimeout { get; }
    [EditorAttribute("Oracle.VsDevTools.OracleVSGConnStringEditor, Oracle.VsDevTools, Version=4.122.1.0, Culture=neutral, PublicKeyToken=89b483f429c47342, processorArchitecture=MSIL", "System.Drawing.Design.UITypeEditor")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("")]
public string ConnectionString { get; public set; }
    public string ChunkMigrationConnectionTimeout { get; public set; }
    [BrowsableAttribute("False")]
public OracleCredential Credential { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
public OracleDRCPPurity DRCPPurity { get; public set; }
    [DefaultValueAttribute("")]
[DescriptionAttribute("")]
[CategoryAttribute("Behavior")]
public string DRCPConnectionClass { get; public set; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("")]
[CategoryAttribute("Data")]
public string DatabaseName { get; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public string InstanceName { get; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("")]
public string DatabaseDomainName { get; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public string HostName { get; }
    [DefaultValueAttribute("False")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
public bool BindByName { get; public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("0")]
public int CommandTimeout { get; public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("131072")]
public long FetchSize { get; public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("200")]
[DescriptionAttribute("")]
public int MaxStatementCacheSize { get; public set; }
    [CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
[DefaultValueAttribute("False")]
public bool Pipelining { get; public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Behavior")]
[DefaultValueAttribute("90")]
public string ServiceRelocationConnectionTimeout { get; public set; }
    [DefaultValueAttribute("False")]
[CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
public bool UseClientInitiatedCQN { get; public set; }
    [CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
[DefaultValueAttribute("True")]
public bool RemoteConfigurationFiltering { get; public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Behavior")]
[DefaultValueAttribute("False")]
public bool SuppressGetDecimalInvalidCastException { get; public set; }
    private static OracleConnection();
    public OracleConnection(string connectionString);
    public OracleConnection(string connectionString, OracleCredential orclCredential);
    internal static bool get_m_bAtLeastOneConOpen();
    internal static void set_m_bAtLeastOneConOpen(bool value);
    internal static void OnHAEvent(object state);
    public static bool get_IsAvailable();
    public void add_ConnectionOpen(OracleConnectionOpenEventHandler value);
    public void remove_ConnectionOpen(OracleConnectionOpenEventHandler value);
    public void add_InfoMessage(OracleInfoMessageEventHandler value);
    public void remove_InfoMessage(OracleInfoMessageEventHandler value);
    public static void add_HAEvent(OracleHAEventHandler value);
    public static void remove_HAEvent(OracleHAEventHandler value);
    public void add_Failover(OracleFailoverEventHandler value);
    public void remove_Failover(OracleFailoverEventHandler value);
    public virtual void add_StateChange(StateChangeEventHandler value);
    public virtual void remove_StateChange(StateChangeEventHandler value);
    internal OracleConnectionImpl get_m_oracleConnectionImpl();
    internal void set_m_oracleConnectionImpl(OracleConnectionImpl value);
    internal OracleLogicalTransaction get_OracleLogicalTransaction();
    internal OraclePermission get_m_orclPermission();
    internal ConnectionString get_m_cs();
    internal ConnectionState get_m_connectionState();
    internal void set_m_connectionState(ConnectionState value);
    internal OracleTransaction get_m_oraTransaction();
    internal void set_m_oraTransaction(OracleTransaction value);
    internal int get_m_majorVersion();
    internal int get_m_minorVersion();
    internal bool get_m_isDb10gR2OrHigher();
    internal bool get_m_isDb11gR1OrHigher();
    internal bool get_m_isDb12cR1OrHigher();
    internal string get_m_serverVersion();
    internal void set_m_serverVersion(string value);
    internal string get_ShardingKeyB64();
    internal string get_SuperShardingKeyB64();
    internal string get_m_shardingChunk();
    internal void set_m_shardingChunk(string value);
    internal int get_m_shardingChunkId();
    internal void set_m_shardingChunkId(int value);
    internal String[] get_m_shardingInstances();
    internal void set_m_shardingInstances(String[] value);
    internal InstanceInfo[] get_m_shardingInstanceInfos();
    internal void set_m_shardingInstanceInfos(InstanceInfo[] value);
    internal OracleOpaqueString get_m_opaquePassw();
    internal OracleOpaqueString get_m_opaqueProxyPassw();
    internal OracleOpaqueString get_m_opaqueNewPassw();
    internal OracleCredential get_m_orclCredential();
    internal void set_m_orclCredential(OracleCredential value);
    internal bool get_m_passwValidated();
    internal void set_m_passwValidated(bool value);
    internal bool get_m_disposed();
    internal void set_m_disposed(bool value);
    internal bool get_bIgnoreLogicalTransaction();
    internal void set_bIgnoreLogicalTransaction(bool value);
    internal bool get_bConnectionforTxnStatus();
    internal void set_bConnectionforTxnStatus(bool value);
    internal string get_m_criteriaConnCls();
    internal void set_m_criteriaConnCls(string value);
    internal string get_m_criteriaPdbName();
    internal void set_m_criteriaPdbName(string value);
    internal string get_m_criteriaServiceName();
    internal void set_m_criteriaServiceName(string value);
    internal string get_m_criteriaEdition();
    internal string get_m_criteriaTag();
    internal byte get_m_bCriteriaDrcpPurityNew();
    internal void set_m_bCriteriaDrcpPurityNew(byte value);
    internal bool get_m_serviceSwitchRequested();
    internal bool get_m_fromMTS();
    internal void set_m_fromMTS(bool value);
    internal string get_m_pdbName();
    internal void set_m_pdbName(string value);
    internal string get_m_serviceName();
    internal void set_m_serviceName(string value);
    internal string get_m_userProvidedConEditionName();
    internal void set_m_userProvidedConEditionName(string value);
    internal UInt32[] get_m_criteriaIds();
    internal bool get_m_bBestMatchPRHasAllMustCrit();
    internal void set_m_bBestMatchPRHasAllMustCrit(bool value);
    internal bool get_m_bfoundPRMatchingAllCrit();
    internal void set_m_bfoundPRMatchingAllCrit(bool value);
    internal bool get_m_bNewConCreated();
    internal void set_m_bNewConCreated(bool value);
    internal bool get_m_bCriteriaPrelimAuthSession();
    internal string get_m_chunkMigrationConTimeout();
    internal string get_m_TNS_ADMIN();
    internal string get_m_Wallet_Location();
    internal string get_m_SSLCerticateThumbprint();
    internal string get_m_SqlNetAuthenticationServices();
    internal bool get_m_SqlnetWalletOverride();
    internal bool get_m_AllowCertSelectionUI();
    internal bool get_m_UseHourOffsetForUnsupportedTimezone();
    internal int get_m_SDU();
    internal IsolationLevel get_m_isolationLevel();
    internal bool get_m_isIsolationLevelSet();
    internal bool get_m_autoCommit();
    internal OracleTokenAuth get_m_tokenAuth();
    internal string get_m_tokenLocation();
    internal OraclePasswordAuth get_m_passwAuth();
    internal string get_m_ociIamUrl();
    internal string get_m_ociTenancy();
    internal string get_m_ociCompartment();
    internal string get_m_ociDatabase();
    internal AbstractTokenAuthentication get_m_tokenConfiguration();
    internal bool get_m_bTokenConfiguration_setByApp();
    internal bool get_m_bStartupShutdown();
    internal void set_m_bStartupShutdown(bool value);
    internal bool get_m_bChunkMigrationConnectionTimeout_setByApp();
    internal bool get_m_bFromConfigCMCT();
    internal int get_m_cmctOffset();
    internal bool get_m_bTimeoutInCMCT();
    internal bool get_m_bDrcpConnectionClass_setByApp();
    internal bool get_m_bUserProvidedConEditionName_setByApp();
    internal bool get_m_bBindByName_setByApp();
    internal bool get_m_bCommandTimeout_setByApp();
    internal bool get_m_bFetchSize_setByApp();
    internal bool get_m_bPipelining_setByApp();
    internal bool get_m_bMaxStatementCacheSize_setByApp();
    internal bool get_m_MaxStatementCacheSize_IsUserDefined();
    internal bool get_m_bServiceRelocationConnectionTimeout_setByApp();
    internal bool get_m_bFromConfigSRCT();
    internal int get_m_srctOffset();
    internal bool get_m_bDrainTimeoutInSRCT();
    internal bool get_m_bUseClientInitiatedCQN_setByApp();
    internal bool get_m_bSingleSessionProxyConReplacement();
    internal void set_m_bSingleSessionProxyConReplacement(bool value);
    public void OpenWithNewToken(Char[] dbToken, Char[] privateKey);
    internal void OpenWithNewClientSecret(SecureString clientSecret);
    internal ITokenAuthenticationProvider get_m_tokenProvider();
    public void OpenWithNewToken(Char[] token);
    public OracleAccessToken get_AccessToken();
    public void set_AccessToken(OracleAccessToken value);
    public OracleTokenAuth get_TokenAuthentication();
    public void set_TokenAuthentication(OracleTokenAuth value);
    public string get_TokenLocation();
    public void set_TokenLocation(string value);
    public OraclePasswordAuth get_PasswordAuthentication();
    public void set_PasswordAuthentication(OraclePasswordAuth value);
    public string get_OciIamUrl();
    public void set_OciIamUrl(string value);
    public string get_OciTenancy();
    public void set_OciTenancy(string value);
    public string get_OciCompartment();
    public void set_OciCompartment(string value);
    public string get_OciDatabase();
    public void set_OciDatabase(string value);
    internal void SetTokenAuthenticationDependencies(ITokenAuthenticationProvider tokenAuthenticationProvider, AbstractTokenAuthentication tokenConfiguration);
    internal OracleTokenAuth GetTokenAuthenticationInternal(ConnectionOption connOption);
    internal string GetTokenLocationInternal(ConnectionOption connOption);
    internal OraclePasswordAuth GetPasswAuthenticationInternal(ConnectionOption connOption);
    internal string GetOCIIamUrlInternal(ConnectionOption connOption);
    internal string GetOCITenancyInternal(ConnectionOption connOption);
    internal string GetOciCompartmentInternal(ConnectionOption connOption);
    internal string GetOciDatabaseInternal(ConnectionOption connOption);
    internal string GetOciConfigurationFileInternal(ConnectionOption connOption);
    internal string GetOciProfileInternal(ConnectionOption connOption);
    internal UrlProviderType get_ConnStrProviderType();
    internal bool get_IsStandardConnStrType();
    internal bool get_IsUrlConnStrType();
    internal UrlConnInfo get_UrlConnInfo();
    internal ProviderUrl get_ConnStrUrl();
    internal bool CanReturnBestMatchingPR();
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    protected virtual override void Finalize();
    public bool get_IsInTransaction();
    public virtual string get_Database();
    public static string get_ProviderName();
    public static string get_ProviderVersion();
    public static string get_ProviderNuGetVersion();
    public virtual string get_DataSource();
    public virtual string get_ServerVersion();
    public virtual ConnectionState get_State();
    public int get_StatementCacheSize();
    public void set_ModuleName(string value);
    public void set_ActionName(string value);
    public void set_ClientId(string value);
    public void set_ClientInfo(string value);
    public void set_TAFMode(OracleTAFMode value);
    public string get_ServiceName();
    public void set_ServiceName(string value);
    public string get_PDBName();
    public void set_PDBName(string value);
    public string get_DatabaseEditionName();
    public void set_DatabaseEditionName(string value);
    public bool get_SwitchedConnection();
    public string get_WalletLocation();
    public void set_WalletLocation(string value);
    public string get_TnsAdmin();
    public void set_TnsAdmin(string value);
    public bool get_AutoCommit();
    public void set_AutoCommit(bool value);
    public bool get_UseHourOffsetForUnsupportedTimezone();
    public void set_UseHourOffsetForUnsupportedTimezone(bool value);
    public virtual void ChangeDatabase(string databaseName);
    public void FlushCache();
    public sealed virtual object Clone();
    public virtual DataTable GetSchema();
    public virtual DataTable GetSchema(string collectionName);
    public virtual DataTable GetSchema(string collectionName, String[] restrictionsArray);
    public virtual void EnlistTransaction(Transaction transaction);
    public void EnlistDistributedTransaction(ITransaction itrans);
    public void PurgeStatementCache();
    public OracleGlobalization GetSessionInfo();
    public void GetSessionInfo(OracleGlobalization oraGlob);
    public void SetSessionInfo(OracleGlobalization oraGlob);
    public void SetShardingKey(OracleShardingKey shardingKey);
    public void SetShardingKey(OracleShardingKey shardingKey, OracleShardingKey superShardingKey);
    public void Commit();
    public void Rollback();
    public void Rollback(string savePointName);
    public void Save(string savePointName);
    public void SetIsolationLevel(IsolationLevel isolationLevel);
    public static void ClearAllPools();
    public static void ClearPool(OracleConnection conn);
    public static void UnregisterCloudConfigNotification(OracleConnection con);
    public static void ClearInteractiveTokenCache();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    protected virtual void OnStateChange(StateChangeEventArgs eventArgs);
    protected virtual DbProviderFactory get_DbProviderFactory();
    public virtual void Open();
    internal int InvokeTAFCallback(OracleFailoverType foType, OracleFailoverEvent foEvent);
    internal void HandleTAF(object methodInfo);
    public virtual Task OpenAsync(CancellationToken cancellationToken);
    public void OpenWithNewPassword(string newPassword);
    public Task OpenWithNewPasswordAsync(string newPassword);
    public Task OpenWithNewPasswordAsync(string newPassword, CancellationToken cancellationToken);
    public void OpenWithNewPassword(SecureString secureNewPassword);
    public Task OpenWithNewPasswordAsync(SecureString secureNewPassword);
    public Task OpenWithNewPasswordAsync(SecureString secureNewPassword, CancellationToken cancellationToken);
    public void BeginRequest();
    public void EndRequest();
    public void DisableReplay();
    internal bool CheckImplicitRequestBoundary();
    internal void SetDatabaseSessionState(DatabaseSessionState dbSessionState);
    protected virtual DbTransaction BeginDbTransaction(IsolationLevel isolationLevel);
    protected virtual DbCommand CreateDbCommand();
    public OracleCommand CreateCommand();
    public OracleTransaction BeginTransaction();
    public OracleTransaction BeginTransaction(IsolationLevel isolationLevel);
    public OracleShardingKey get_ShardingKey();
    public OracleShardingKey get_SuperShardingKey();
    public string get_SSLCertificateThumbprint();
    public void set_SSLCertificateThumbprint(string value);
    public string get_SqlNetAuthenticationServices();
    public void set_SqlNetAuthenticationServices(string value);
    public string get_NamesDirectoryPath();
    public void set_NamesDirectoryPath(string value);
    public bool get_SqlnetWalletOverride();
    public void set_SqlnetWalletOverride(bool value);
    public void set_SqlNetAllowedLogonVersionClient(OracleAllowedLogonVersionClient value);
    public bool get_AllowCertificateSelectionUI();
    public void set_AllowCertificateSelectionUI(bool value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public int get_KeepAliveTime();
    public void set_KeepAliveTime(int value);
    public int get_KeepAliveInterval();
    public void set_KeepAliveInterval(int value);
    public void set_SDU(int value);
    public void set_DatabaseCharset(OracleDatabaseCharset value);
    public void set_DatabaseNCharset(OracleDatabaseNCharset value);
    public string get_ConnectionId();
    internal object get_TraceObj();
    internal string get_m_connectionIdPrefix();
    public void set_ConnectionIdPrefix(string value);
    public virtual int get_ConnectionTimeout();
    public virtual string get_ConnectionString();
    public virtual void set_ConnectionString(string value);
    public string get_ChunkMigrationConnectionTimeout();
    public void set_ChunkMigrationConnectionTimeout(string value);
    public OracleCredential get_Credential();
    public void set_Credential(OracleCredential value);
    public OracleDRCPPurity get_DRCPPurity();
    public void set_DRCPPurity(OracleDRCPPurity value);
    public string get_DRCPConnectionClass();
    public void set_DRCPConnectionClass(string value);
    public string get_DatabaseName();
    public string get_InstanceName();
    public string get_DatabaseDomainName();
    public string get_HostName();
    public bool get_BindByName();
    public void set_BindByName(bool value);
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public long get_FetchSize();
    public void set_FetchSize(long value);
    public int get_MaxStatementCacheSize();
    public void set_MaxStatementCacheSize(int value);
    public bool get_Pipelining();
    public void set_Pipelining(bool value);
    public string get_ServiceRelocationConnectionTimeout();
    public void set_ServiceRelocationConnectionTimeout(string value);
    public bool get_UseClientInitiatedCQN();
    public void set_UseClientInitiatedCQN(bool value);
    public bool get_RemoteConfigurationFiltering();
    public void set_RemoteConfigurationFiltering(bool value);
    public bool get_SuppressGetDecimalInvalidCastException();
    public void set_SuppressGetDecimalInvalidCastException(bool value);
    internal static string Dump();
    internal static string Dump(string txnid);
    internal static bool ACEnabled(OracleConnection connection);
    internal void CheckForWarnings(object source);
    internal UDTNamedType GetUDTTypeFromCache(string schemaName, string typeName);
    internal UDTSQLName GetUDTSQLNameFromCache(Byte[] toid);
    internal UDTNamedType AddUDTTypeToCache(UDTNamedType udtType);
    internal void GetUDTTypeMetaData(UDTNamedType udtType);
}
[DefaultEventAttribute("InfoMessage")]
[ToolboxBitmapAttribute("resfinder", "Oracle.ManagedDataAccess.src.Client.Icons.OracleConnectionToolBox_hc.bmp")]
internal class Oracle.ManagedDataAccess.Client.OracleConnectionInternal : object {
    private static string s_OpenAsync;
    private static string s_Open;
    private static string s_Close;
    private static string METADATA_COLLECTION;
    private static string DATA_TYPES;
    private static string RESTRICTIONS;
    private static string RESERVED_WORDS;
    private static string DATA_SOURCE_INFORMATION;
    private static string ORCL_COMMAND;
    private static string DATA_TABLE;
    internal static string ODP_NAME;
    internal static string s_getLTXIDstatus;
    internal static short MIN_DBVER_FOR_CIC_BASED_CQN;
    internal OracleConnection m_proxy;
    internal static bool m_bAtLeastOneConOpen;
    private static object s_syncObj;
    internal object m_activityForOpen;
    internal object m_activityForClose;
    private static string s_TnsAdminOld;
    internal OraclePermission m_orclPermission;
    internal int m_config_values;
    internal string m_TNS_ADMIN;
    internal string m_Wallet_Location;
    internal ConnectionString m_cs;
    internal string m_originalConnectionString;
    internal OracleConnectionImpl m_oracleConnectionImpl;
    internal ConnectionState m_connectionState;
    internal OracleTransaction m_oraTransaction;
    internal string m_serverVersion;
    internal bool m_bDoNotEnlist;
    internal ConnectionReplacement m_connReplacement;
    internal OracleLogicalTransaction m_logicalTransaction;
    internal bool m_bE2EMetricsChangedByClient;
    internal ConnectionString pmCS;
    internal bool m_bKeepAlive;
    internal int m_keepAliveTime;
    internal int m_keepAliveInterval;
    internal string m_NamesDirectoryPath;
    internal bool m_SqlnetWalletOverride;
    internal bool m_AllowCertSelectionUI;
    internal string m_SSLCertificateThumbprint;
    internal string m_SqlNetAuthenticationServices;
    internal int m_SDU;
    internal OracleDatabaseCharset m_dbCharset;
    internal OracleDatabaseNCharset m_dbNCharset;
    internal OracleAllowedLogonVersionClient m_SqlnetAllowedLogonVersionClient;
    internal bool m_bALVCSetByApp;
    internal string m_chunkMigrationConTimeout;
    internal bool m_bFromConfigCMCT;
    internal int m_cmctOffset;
    internal bool m_bTimeoutInCMCT;
    internal bool m_bChunkMigrationConnectionTimeout_setByApp;
    internal bool m_bBindByName_setByApp;
    internal bool m_bCommandTimeout_setByApp;
    internal bool m_bFetchSize_setByApp;
    internal bool m_bMaxStatementCacheSize_setByApp;
    internal bool m_bPipelining_setByApp;
    internal bool m_bServiceRelocationConnectionTimeout_setByApp;
    internal bool m_bUseClientInitiatedCQN_setByApp;
    internal bool m_bBindByName;
    internal int m_commandTimeout;
    internal long m_fetchSize;
    internal int m_maxStatementCacheSize;
    internal bool m_bMaxStatementCacheSize_IsUserDefined;
    internal bool m_bPipelining;
    internal string m_serviceRelocationTimeout;
    internal bool m_bFromConfigSRCT;
    internal int m_srctOffset;
    internal bool m_bDrainTimeoutInSRCT;
    internal bool m_bUseClientInitiatedCQN;
    internal string m_shardingChunk;
    internal int m_shardingChunkId;
    internal String[] m_shardingInstances;
    internal InstanceInfo[] m_shardingInstanceInfos;
    internal bool m_bIsTnsAdminSet;
    internal bool m_bIsWalletLocationSet;
    internal bool m_bIsNamesDirectoryPathSet;
    internal bool m_bStartupShutdown;
    internal bool m_bIsSSLCertificateThumbprintSet;
    internal bool m_bIsSqlNetAuthenticationServicesSet;
    internal bool bIgnoreLogicalTransaction;
    internal bool bConnectionforTxnStatus;
    internal DataSet m_metaDataCollectionDS;
    internal bool m_passwValidated;
    internal bool m_csModified;
    internal bool m_disposed;
    internal OracleOpaqueString m_opaquePassw;
    internal OracleOpaqueString m_opaqueProxyPassw;
    internal OracleOpaqueString m_opaqueNewPassw;
    internal OracleCredential m_orclCredential;
    internal OracleAccessToken m_accessToken;
    internal OracleTokenAuth m_tokenAuth;
    internal string m_tokenLocation;
    internal OracleAccessToken m_newAccessToken;
    internal OracleOpaqueString m_newClientSecret;
    internal bool m_bTokenAuth_setByApp;
    internal bool m_bTokenLocation_setByApp;
    internal OraclePasswordAuth m_passwAuth;
    internal string m_ociIamUrl;
    internal string m_ociTenancy;
    internal string m_ociCompartment;
    internal string m_ociDatabase;
    internal bool m_bPasswAuth_setByApp;
    internal bool m_bOciIamUrl_setByApp;
    internal bool m_bOciTenancy_setByApp;
    internal bool m_bOciCompartment_setByApp;
    internal bool m_bOciDatabase_setByApp;
    internal UrlProviderType m_connStrProviderType;
    internal UrlConnInfo m_urlConnInfo;
    internal Byte[] m_SSLWalletBytes;
    internal OracleAccessToken m_accessTokenFromUrl;
    internal bool m_bRemoteConfigurationFiltering;
    internal bool m_bRemoteConfigurationFiltering_setByApp;
    [CompilerGeneratedAttribute]
private ITokenAuthenticationProvider <TokenProvider>k__BackingField;
    internal AbstractTokenAuthentication m_tokenConfiguration;
    internal bool m_bTokenConfiguration_setByApp;
    internal bool m_isDb10gR2OrHigher;
    internal bool m_isDb11gR1OrHigher;
    internal bool m_isDb12cR1OrHigher;
    private int m_statementCacheSizeSnapshot;
    private int m_connectionTimeout;
    private string m_dataSource;
    private int m_implId;
    private int m_sessionId;
    private string m_id;
    internal string m_pdbName;
    internal string m_serviceName;
    private string m_appEdition;
    internal string m_userProvidedConEditionName;
    internal bool m_bUserProvidedConEditionName_setByApp;
    internal string m_drcpConnectionClass;
    internal bool m_bDrcpConnectionClass_setByApp;
    internal string m_drcpTagName;
    internal OracleDRCPPurity m_drcpPurity;
    internal bool m_isPuritySet;
    internal static bool m_enableDRCP;
    internal bool m_bDRCPUseMultitag;
    internal string m_drcpPLSQLCallback;
    internal bool m_UseHourOffsetForUnsupportedTimezone;
    internal IsolationLevel m_isolationLevel;
    internal bool m_isIsolationLevelSet;
    internal bool m_autoCommit;
    internal bool m_IsInTransaction;
    internal string m_criteriaConnCls;
    internal string m_criteriaPdbName;
    internal string m_criteriaServiceName;
    internal string m_criteriaEdition;
    internal string m_criteriaTag;
    internal bool m_bCriteriaMatchAnyTag;
    internal byte m_bCriteriaDrcpPurityNew;
    internal int m_criteriaDrcpEnabled;
    internal UInt32[] m_criteriaIds;
    internal bool m_bBestMatchPRHasAllMustCrit;
    internal bool m_bBestMatchingPRHasReqTag;
    internal bool m_bfoundPRMatchingAllCrit;
    internal bool m_bNewConCreated;
    internal bool m_bCriteriaPrelimAuthSession;
    internal bool m_serviceSwitchRequested;
    internal bool m_fromMTS;
    internal bool m_bSingleSessionProxyConReplacement;
    internal static string m_sProviderVersion;
    internal static string m_sProviderName;
    internal static string m_sProviderNuGetVersion;
    internal string m_connectionIdPrefix;
    internal bool m_bConnectionIdPrefix_setByApp;
    internal OracleShardingKey m_shardKey;
    internal OracleShardingKey m_shardGroupKey;
    internal string m_ShardingKeyB64;
    internal string m_SuperShardingKeyB64;
    internal bool m_bConDeadAndReplacementConCreated;
    internal bool m_bSuppressGetDecimalInvalidCastException;
    internal bool m_bAsyncOpenInProgress;
    internal ITokenAuthenticationProvider TokenProvider { get; internal set; }
    internal string SessionId { get; }
    internal string InstanceBranch { get; }
    internal string TnsAdminInternal { get; }
    internal string WalletLocationInternal { get; }
    internal bool MaxStatementCacheSize_IsUserDefined { get; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("")]
[DefaultValueAttribute("")]
internal static string ProviderName { get; }
    public string TnsAdmin { get; public set; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public string WalletLocation { get; public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("Select the SSL Certificate via thumbprint.")]
public string SSLCertificateThumbprint { get; public set; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("Set the connection specific SqlNet.Authentication_Services")]
[DefaultValueAttribute("")]
public string SqlNetAuthenticationServices { get; public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("Set the connection specific Names.directory_path")]
public string NamesDirectoryPath { get; public set; }
    [DescriptionAttribute("Set the connection specific sqlnet.allowed_logon_version_client")]
[DefaultValueAttribute("")]
[CategoryAttribute("Data")]
unknown OracleAllowedLogonVersionClient SqlNetAllowedLogonVersionClient {internal set; }
    [DescriptionAttribute("Set the connection specific Sqlnet.Wallet_Override")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("False")]
public bool SqlnetWalletOverride { get; public set; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("Get negotiated SDU. Only valid after connection is opened, and before closing.")]
[DefaultValueAttribute("0")]
public int NegotiatedSDU { get; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("Set the SDU for the connection. Only settable one time for Connection Pool.")]
[DefaultValueAttribute("0")]
unknown int SDU {public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DescriptionAttribute("Set database charset for the connection. Only settable one time for Connection Pool.")]
unknown OracleDatabaseCharset DatabaseCharset {public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[DescriptionAttribute("Set database ncharset for the connection. Only settable one time for Connection Pool.")]
unknown OracleDatabaseNCharset DatabaseNCharset {public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("Whether to allow the SSL Certificate selection UI")]
public bool AllowCertificateSelectionUI { get; public set; }
    [DefaultValueAttribute("False")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public bool KeepAlive { get; public set; }
    [DefaultValueAttribute("60")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public int KeepAliveTime { get; public set; }
    [DefaultValueAttribute("6")]
[DescriptionAttribute("")]
[CategoryAttribute("Data")]
public int KeepAliveInterval { get; public set; }
    public string ChunkMigrationConnectionTimeout { get; public set; }
    public bool BindByName { get; public set; }
    public int CommandTimeout { get; public set; }
    public long FetchSize { get; public set; }
    public int MaxStatementCacheSize { get; public set; }
    public bool Pipelining { get; public set; }
    public string ServiceRelocationConnectionTimeout { get; public set; }
    public bool UseClientInitiatedCQN { get; public set; }
    public bool RemoteConfigurationFiltering { get; public set; }
    public string ConnectionString { get; public set; }
    public ConnectionState State { get; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("")]
[CategoryAttribute("Data")]
unknown string ModuleName {public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("")]
unknown string ActionName {public set; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("")]
[CategoryAttribute("Data")]
unknown string ClientId {public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("")]
unknown string ClientInfo {public set; }
    public int ConnectionTimeout { get; }
    public string Database { get; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("")]
public string DatabaseName { get; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("")]
public string DatabaseDomainName { get; }
    [DefaultValueAttribute("")]
[DescriptionAttribute("")]
[CategoryAttribute("Data")]
public string HostName { get; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public string InstanceName { get; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public string ServiceName { get; public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("")]
public string DatabaseEditionName { get; public set; }
    public string DataSource { get; }
    public static bool IsAvailable { get; }
    public string ServerVersion { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[DescriptionAttribute("")]
internal static string ProviderVersion { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
[DescriptionAttribute("")]
internal static string ProviderNuGetVersion { get; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("0")]
[DescriptionAttribute("")]
public int StatementCacheSize { get; }
    internal OracleLogicalTransaction OracleLogicalTransaction { get; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("")]
[DescriptionAttribute("")]
public string DRCPConnectionClass { get; public set; }
    public OracleDRCPPurity DRCPPurity { get; public set; }
    [CategoryAttribute("Behavior")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("")]
public bool UseHourOffsetForUnsupportedTimezone { get; public set; }
    internal OracleShardingKey ShardingKey { get; }
    internal OracleShardingKey SuperShardingKey { get; }
    internal string ShardingKeyB64 { get; }
    internal string SuperShardingKeyB64 { get; }
    internal string ConnectionId { get; }
    internal object TraceObj { get; }
    internal DbProviderFactory DbProviderFactory { get; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[DescriptionAttribute("")]
public string PDBName { get; public set; }
    [CategoryAttribute("Behavior")]
[DescriptionAttribute("")]
[DefaultValueAttribute("False")]
public bool SwitchedConnection { get; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[BrowsableAttribute("False")]
[DescriptionAttribute("")]
public OracleCredential Credential { get; public set; }
    [DefaultValueAttribute("")]
[DescriptionAttribute("")]
[BrowsableAttribute("False")]
[CategoryAttribute("Data")]
public OracleAccessToken AccessToken { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public OracleTokenAuth TokenAuthentication { get; public set; }
    [DefaultValueAttribute("")]
public string TokenLocation { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public OraclePasswordAuth PasswAuthentication { get; public set; }
    [DefaultValueAttribute("")]
public string OciIamUrl { get; public set; }
    [DefaultValueAttribute("")]
public string OciTenancy { get; public set; }
    [DefaultValueAttribute("")]
public string OciCompartment { get; public set; }
    [DefaultValueAttribute("")]
public string OciDatabase { get; public set; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("")]
[BrowsableAttribute("False")]
[DescriptionAttribute("")]
public AbstractTokenAuthentication TokenConfiguration { get; public set; }
    internal UrlProviderType ConnStrType { get; }
    internal UrlConnInfo UrlConnInfo { get; }
    internal bool IsUrlConnStrType { get; }
    internal bool IsStandardConnStrType { get; }
    public bool AutoCommit { get; public set; }
    public bool IsInTransaction { get; }
    [CategoryAttribute("Data")]
[DefaultValueAttribute("False")]
[DescriptionAttribute("")]
public bool SuppressGetDecimalInvalidCastException { get; public set; }
    internal int m_majorVersion { get; }
    internal int m_minorVersion { get; }
    public OracleConnectionInternal(string connectionString);
    public OracleConnectionInternal(string connectionString, OracleCredential orclCredential);
    private static OracleConnectionInternal();
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleConnectionInternal/<OpenInternalAsync>d__0")]
internal ValueTask OpenInternalAsync(bool bAsync);
    [CompilerGeneratedAttribute]
internal ITokenAuthenticationProvider get_TokenProvider();
    [CompilerGeneratedAttribute]
internal void set_TokenProvider(ITokenAuthenticationProvider value);
    internal bool CanReturnBestMatchingPR();
    protected virtual override void Finalize();
    internal static string Dump();
    internal static string Dump(string txnid);
    internal string get_SessionId();
    internal string get_InstanceBranch();
    internal string get_TnsAdminInternal();
    internal string get_WalletLocationInternal();
    internal bool get_MaxStatementCacheSize_IsUserDefined();
    internal static string get_ProviderName();
    public string get_TnsAdmin();
    public void set_TnsAdmin(string value);
    public string get_WalletLocation();
    public void set_WalletLocation(string value);
    public string get_SSLCertificateThumbprint();
    public void set_SSLCertificateThumbprint(string value);
    public string get_SqlNetAuthenticationServices();
    public void set_SqlNetAuthenticationServices(string value);
    public string get_NamesDirectoryPath();
    public void set_NamesDirectoryPath(string value);
    internal void set_SqlNetAllowedLogonVersionClient(OracleAllowedLogonVersionClient value);
    public bool get_SqlnetWalletOverride();
    public void set_SqlnetWalletOverride(bool value);
    public int get_NegotiatedSDU();
    public void set_SDU(int value);
    public void set_DatabaseCharset(OracleDatabaseCharset value);
    public void set_DatabaseNCharset(OracleDatabaseNCharset value);
    public bool get_AllowCertificateSelectionUI();
    public void set_AllowCertificateSelectionUI(bool value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public int get_KeepAliveTime();
    public void set_KeepAliveTime(int value);
    public int get_KeepAliveInterval();
    public void set_KeepAliveInterval(int value);
    public string get_ChunkMigrationConnectionTimeout();
    public void set_ChunkMigrationConnectionTimeout(string value);
    public bool get_BindByName();
    public void set_BindByName(bool value);
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public long get_FetchSize();
    public void set_FetchSize(long value);
    public int get_MaxStatementCacheSize();
    public void set_MaxStatementCacheSize(int value);
    public bool get_Pipelining();
    public void set_Pipelining(bool value);
    public string get_ServiceRelocationConnectionTimeout();
    public void set_ServiceRelocationConnectionTimeout(string value);
    public bool get_UseClientInitiatedCQN();
    public void set_UseClientInitiatedCQN(bool value);
    public bool get_RemoteConfigurationFiltering();
    public void set_RemoteConfigurationFiltering(bool value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public ConnectionState get_State();
    public void set_ModuleName(string value);
    public void set_ActionName(string value);
    public void set_ClientId(string value);
    public void set_ClientInfo(string value);
    public int get_ConnectionTimeout();
    public string get_Database();
    public string get_DatabaseName();
    public string get_DatabaseDomainName();
    public string get_HostName();
    public string get_InstanceName();
    public string get_ServiceName();
    public void set_ServiceName(string value);
    public string get_DatabaseEditionName();
    public void set_DatabaseEditionName(string value);
    public string get_DataSource();
    public static bool get_IsAvailable();
    public string get_ServerVersion();
    internal static string get_ProviderVersion();
    internal static string get_ProviderNuGetVersion();
    public int get_StatementCacheSize();
    internal OracleLogicalTransaction get_OracleLogicalTransaction();
    public string get_DRCPConnectionClass();
    public void set_DRCPConnectionClass(string value);
    public OracleDRCPPurity get_DRCPPurity();
    public void set_DRCPPurity(OracleDRCPPurity value);
    public bool get_UseHourOffsetForUnsupportedTimezone();
    public void set_UseHourOffsetForUnsupportedTimezone(bool value);
    internal OracleShardingKey get_ShardingKey();
    internal OracleShardingKey get_SuperShardingKey();
    internal string get_ShardingKeyB64();
    internal string get_SuperShardingKeyB64();
    internal string get_ConnectionId();
    internal object get_TraceObj();
    internal DbProviderFactory get_DbProviderFactory();
    public string get_PDBName();
    public void set_PDBName(string value);
    public bool get_SwitchedConnection();
    public OracleCredential get_Credential();
    public void set_Credential(OracleCredential value);
    public void OpenWithNewToken(Char[] dbToken, Char[] privateKey);
    public void OpenWithNewClientSecret(SecureString newSecureClientSecret);
    public void OpenWithNewToken(Char[] token);
    public OracleAccessToken get_AccessToken();
    public void set_AccessToken(OracleAccessToken value);
    public OracleTokenAuth get_TokenAuthentication();
    public void set_TokenAuthentication(OracleTokenAuth value);
    public string get_TokenLocation();
    public void set_TokenLocation(string value);
    public OraclePasswordAuth get_PasswAuthentication();
    public void set_PasswAuthentication(OraclePasswordAuth value);
    public string get_OciIamUrl();
    public void set_OciIamUrl(string value);
    public string get_OciTenancy();
    public void set_OciTenancy(string value);
    public string get_OciCompartment();
    public void set_OciCompartment(string value);
    public string get_OciDatabase();
    public void set_OciDatabase(string value);
    public AbstractTokenAuthentication get_TokenConfiguration();
    public void set_TokenConfiguration(AbstractTokenAuthentication value);
    internal OracleTokenAuth GetTokenAuthenticationInternal(ConnectionOption connOption);
    internal string GetTokenLocationInternal(ConnectionOption connOption);
    internal OraclePasswordAuth GetPasswordAuthenticationInternal(ConnectionOption connOption);
    internal string GetOCIIamUrlInternal(ConnectionOption connOption);
    internal string GetOCITenancyInternal(ConnectionOption connOption);
    internal string GetOciCompartmentInternal(ConnectionOption connOption);
    internal string GetOciDatabaseInternal(ConnectionOption connOption);
    internal string GetOciConfigurationFileInternal(ConnectionOption connOption);
    internal string GetOciProfileInternal(ConnectionOption connOption);
    internal UrlProviderType get_ConnStrType();
    internal UrlConnInfo get_UrlConnInfo();
    internal bool get_IsUrlConnStrType();
    internal bool get_IsStandardConnStrType();
    internal void PopulateConnPropertiesFromConfig(bool bOverride);
    public bool get_AutoCommit();
    public void set_AutoCommit(bool value);
    public bool get_IsInTransaction();
    public bool get_SuppressGetDecimalInvalidCastException();
    public void set_SuppressGetDecimalInvalidCastException(bool value);
    public void BeginRequest();
    public void EndRequest();
    internal void EndRequest(bool bImplicit);
    public void DisableReplay();
    internal bool CheckImplicitRequestBoundary();
    internal bool HasNoOpenHandles();
    internal void SetDatabaseSessionState(DatabaseSessionState dbSessionState);
    public void FlushCache();
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleConnectionInternal/<OpenAsync>d__402")]
public Task OpenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleConnectionInternal/<OpenAsyncHelper>d__403")]
internal Task OpenAsyncHelper(CancellationToken cancellationToken);
    public Task OpenWithNewPasswordAsync(string newPassw);
    public Task OpenWithNewPasswordAsync(string newPassw, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleConnectionInternal/<OpenWithNewPasswordAsyncHelper>d__406")]
internal Task OpenWithNewPasswordAsyncHelper(string newPassw, CancellationToken cancellationToken);
    public Task OpenWithNewPasswordAsync(SecureString secureNewPassw);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleConnectionInternal/<OpenWithNewPasswordAsync>d__408")]
public Task OpenWithNewPasswordAsync(SecureString secureNewPassw, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleConnectionInternal/<OpenWithNewPasswordAsyncHelper>d__409")]
internal Task OpenWithNewPasswordAsyncHelper(SecureString secureNewPassw, CancellationToken cancellationToken);
    public void Open();
    internal void OpenInternal(bool bAsync);
    public void OpenWithNewPassword(string newPassw);
    public void OpenWithNewPassword(SecureString secureNewPassw);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleConnectionInternal/<OpenWithNewPasswordInternal>d__414")]
private ValueTask OpenWithNewPasswordInternal(OracleOpaqueString secureNewPassw, bool isOpaqueStringOverload, bool bAsync);
    internal OracleConnection GetConnectionForFailover(DateTime requestStartTime, bool bForTAF);
    internal OracleConnection GetFailoverConnection(bool bOpenConnection, bool bDoNotEnlist, ConnectionReplacement connReplacement);
    internal static void ValidateConnectionStateBeforeRoundtrip(OracleConnection conn);
    internal OracleTransaction BeginTransaction();
    public OracleTransaction BeginTransaction(IsolationLevel isolationLevel);
    public void ChangeDatabase(string pdbName);
    private void ResetAllCriteria();
    public void Close();
    public OracleCommand CreateCommand();
    public object Clone();
    public OracleGlobalization GetSessionInfo();
    public void GetSessionInfo(OracleGlobalization oraGlob);
    public void SetSessionInfo(OracleGlobalization oraGlob);
    public void PurgeStatementCache();
    public DataTable GetSchema();
    public DataTable GetSchema(string collectionName);
    public DataTable GetSchema(string collectionName, String[] restrictionsArray);
    public void EnlistDistributedTransaction(ITransaction itrans);
    public void EnlistTransaction(Transaction transaction);
    public static void ClearAllPools();
    public static void ClearPool(OracleConnection conn);
    public static void UnregisterCloudConfigNotification(OracleConnection con);
    internal static void ClearInteractiveTokenCache();
    public void SetShardingKey(OracleShardingKey shardingKey);
    public void SetShardingKey(OracleShardingKey shardingKey, OracleShardingKey superShardingKey);
    internal void Commit(CallHistoryRecord callHistoryRecord);
    public void Rollback(CallHistoryRecord callHistoryRecord);
    public void Rollback(CallHistoryRecord callHistoryRecord, string savePointName);
    public void Save(CallHistoryRecord callHistoryRecord, string savePointName);
    internal void SetIsolationLevel(IsolationLevel isolationLevel, CallHistoryRecord callHistoryRecord);
    internal DbTransaction BeginDbTransaction(IsolationLevel isolationLevel);
    internal void Dispose(bool disposing);
    internal DbCommand CreateDbCommand();
    internal void OnStateChange(StateChangeEventArgs eventArgs);
    internal void OnConnectionOpen(OracleConnectionOpenEventArgs eventArgs);
    internal static void OnHAEvent(object state);
    internal int get_m_majorVersion();
    internal int get_m_minorVersion();
    private void PopulateSupportedDataRows(DataTable dt, string collectionName, string normalizedDBVersion);
    private void LoadMetaDataXmlDS();
    private string NormalizeDBVersion(string str);
    private bool SupportedInCurrentVersion(DataRow row, string normalizedDBVersion);
    private int ComparenormalizedDBVersions(string normalizedDBVersion, string xmlnormalizedDBVersion);
    internal OracleTransaction GetTransaction();
    internal void InitializeOrclPermission(string connString);
    internal void RaiseStateChange(ConnectionState originalState, ConnectionState currentState);
    internal void OnInfoMessage(object obj, int errCode, string warningMsg);
    internal UDTNamedType GetUDTTypeFromCache(string schemaName, string typeName);
    internal UDTNamedType GetUDTTypeFromCache(UDTSQLName sqlName);
    internal UDTSQLName GetUDTSQLNameFromCache(Byte[] toid);
    internal UDTNamedType AddUDTTypeToCache(UDTNamedType udtType);
    internal void GetUDTTypeMetaData(UDTNamedType udtType);
    internal void CheckForWarnings(object source);
}
public class Oracle.ManagedDataAccess.Client.OracleConnectionOpenEventArgs : EventArgs {
    private OracleConnection m_connection;
    internal OracleConnectionOpenReason m_reason;
    public OracleConnection Connection { get; }
    public OracleConnectionOpenReason ConnectionOpenReason { get; }
    internal OracleConnectionOpenEventArgs(OracleConnection connection);
    internal OracleConnectionOpenEventArgs(OracleConnection connection, OracleConnectionOpenReason reason);
    public OracleConnection get_Connection();
    public OracleConnectionOpenReason get_ConnectionOpenReason();
}
public class Oracle.ManagedDataAccess.Client.OracleConnectionOpenEventHandler : MulticastDelegate {
    public OracleConnectionOpenEventHandler(object object, IntPtr method);
    public virtual void Invoke(OracleConnectionOpenEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(OracleConnectionOpenEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Oracle.ManagedDataAccess.Client.OracleConnectionOpenReason : Enum {
    public int value__;
    public static OracleConnectionOpenReason SoftConnect;
    public static OracleConnectionOpenReason HardConnect;
}
[DefaultPropertyAttribute("DataSource")]
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Client.OracleConnectionStringBuilder : DbConnectionStringBuilder {
    private Dictionary`2<string, object> KeyValuePairList;
    private Dictionary`2<string, bool> IsSetKeyValuePairList;
    private static Hashtable m_boolMapping;
    private static Hashtable m_defaultValues;
    [DisplayNameAttribute("Proxy User")]
public string ProxyUserId { get; public set; }
    [DisplayNameAttribute("Proxy Password")]
public string ProxyPassword { get; public set; }
    [DisplayNameAttribute("DBA Privilege")]
public string DBAPrivilege { get; public set; }
    [DisplayNameAttribute("User ID")]
public string UserID { get; public set; }
    [DisplayNameAttribute("Data Source")]
public string DataSource { get; public set; }
    [PasswordPropertyTextAttribute("True")]
[DisplayNameAttribute("Password")]
public string Password { get; public set; }
    [DisplayNameAttribute("Max Pool Size")]
public int MaxPoolSize { get; public set; }
    [DisplayNameAttribute("Min Pool Size")]
public int MinPoolSize { get; public set; }
    [DisplayNameAttribute("Increment pool size")]
public int IncrPoolSize { get; public set; }
    [DisplayNameAttribute("Decrement pool size")]
public int DecrPoolSize { get; public set; }
    [DisplayNameAttribute("Connection Life Time")]
public int ConnectionLifeTime { get; public set; }
    [DisplayNameAttribute("Statement Cache Size")]
public int StatementCacheSize { get; public set; }
    [DisplayNameAttribute("Self Tuning")]
public bool SelfTuning { get; public set; }
    [DisplayNameAttribute("Connection Timeout")]
public int ConnectionTimeout { get; public set; }
    [DisplayNameAttribute("Persist Security Info")]
public bool PersistSecurityInfo { get; public set; }
    [DisplayNameAttribute("Enlist")]
public string Enlist { get; public set; }
    [DisplayNameAttribute("metadata pooling")]
public bool MetadataPooling { get; public set; }
    [DisplayNameAttribute("Pooling")]
public bool Pooling { get; public set; }
    [DisplayNameAttribute("Application Continuity")]
public bool ApplicationContinuity { get; public set; }
    [DisplayNameAttribute("Validate Connection")]
public bool ValidateConnection { get; public set; }
    [DisplayNameAttribute("Statement Cache Purge")]
public bool StatementCachePurge { get; public set; }
    [DisplayNameAttribute("HAEvents")]
public bool HAEvents { get; public set; }
    [DisplayNameAttribute("Load Balancing")]
public bool LoadBalancing { get; public set; }
    [DisplayNameAttribute("Context Connection")]
public bool ContextConnection { get; public set; }
    [DisplayNameAttribute("PromotableTransaction")]
public string PromotableTransaction { get; public set; }
    [DisplayNameAttribute("TnsAdmin")]
public string TnsAdmin { get; public set; }
    [DisplayNameAttribute("WalletLocation")]
public string WalletLocation { get; public set; }
    [DisplayNameAttribute("TokenAuthentication")]
public OracleTokenAuth TokenAuthentication { get; public set; }
    [DisplayNameAttribute("TokenLocation")]
public string TokenLocation { get; public set; }
    public bool IsFixedSize { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object Item { get; public set; }
    private static OracleConnectionStringBuilder();
    public OracleConnectionStringBuilder(string connectionString);
    internal static bool ConvertStringToBool(string key, string keyValue);
    private void SetProperty(string keyword, object value);
    private void ResetValues();
    private void Initialize();
    private void SetValueToBaseAndList(string keyword, object value);
    internal bool IsConnectionStringAttributeSet(string keyName);
    public string get_ProxyUserId();
    public void set_ProxyUserId(string value);
    public string get_ProxyPassword();
    public void set_ProxyPassword(string value);
    public string get_DBAPrivilege();
    public void set_DBAPrivilege(string value);
    public string get_UserID();
    public void set_UserID(string value);
    public string get_DataSource();
    public void set_DataSource(string value);
    public string get_Password();
    public void set_Password(string value);
    public int get_MaxPoolSize();
    public void set_MaxPoolSize(int value);
    public int get_MinPoolSize();
    public void set_MinPoolSize(int value);
    public int get_IncrPoolSize();
    public void set_IncrPoolSize(int value);
    public int get_DecrPoolSize();
    public void set_DecrPoolSize(int value);
    public int get_ConnectionLifeTime();
    public void set_ConnectionLifeTime(int value);
    public int get_StatementCacheSize();
    public void set_StatementCacheSize(int value);
    public bool get_SelfTuning();
    public void set_SelfTuning(bool value);
    public int get_ConnectionTimeout();
    public void set_ConnectionTimeout(int value);
    public bool get_PersistSecurityInfo();
    public void set_PersistSecurityInfo(bool value);
    public string get_Enlist();
    public void set_Enlist(string value);
    public bool get_MetadataPooling();
    public void set_MetadataPooling(bool value);
    public bool get_Pooling();
    public void set_Pooling(bool value);
    public bool get_ApplicationContinuity();
    public void set_ApplicationContinuity(bool value);
    public bool get_ValidateConnection();
    public void set_ValidateConnection(bool value);
    public bool get_StatementCachePurge();
    public void set_StatementCachePurge(bool value);
    public bool get_HAEvents();
    public void set_HAEvents(bool value);
    public bool get_LoadBalancing();
    public void set_LoadBalancing(bool value);
    public bool get_ContextConnection();
    public void set_ContextConnection(bool value);
    public string get_PromotableTransaction();
    public void set_PromotableTransaction(string value);
    public string get_TnsAdmin();
    public void set_TnsAdmin(string value);
    public string get_WalletLocation();
    public void set_WalletLocation(string value);
    public OracleTokenAuth get_TokenAuthentication();
    public void set_TokenAuthentication(OracleTokenAuth value);
    public string get_TokenLocation();
    public void set_TokenLocation(string value);
    public virtual bool get_IsFixedSize();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual object get_Item(string keyword);
    public virtual void set_Item(string keyword, object value);
    public virtual void Clear();
    public virtual bool ContainsKey(string keyword);
    public virtual bool Remove(string keyword);
    public virtual bool TryGetValue(string keyword, Object& value);
    protected virtual void GetProperties(Hashtable propertyDescriptors);
}
internal static class Oracle.ManagedDataAccess.Client.OracleCounterUtility : object {
    public static string CreateInstanceName(string appDomain, string poolName, string dbInstanceName);
    public static String[] CreateInstanceHierarchyNames(string pfcInstanceName);
    private static string ConstructFieldName(string fieldName, int lengthLimit);
}
public class Oracle.ManagedDataAccess.Client.OracleCredential : object {
    internal OracleOpaqueString m_opaquePassw;
    internal string m_userId;
    internal OracleOpaqueString m_opaqueProxyPassw;
    internal string m_proxyUserId;
    internal OracleDBAPrivilege m_dbaPrivilege;
    internal bool m_bInternalUse;
    internal bool m_bUserIdSet;
    internal bool m_bPasswSet;
    internal bool m_bProxyUserIdSet;
    internal bool m_bProxyPasswSet;
    public string UserId { get; }
    public SecureString Password { get; }
    public string ProxyUserId { get; }
    public SecureString ProxyPassword { get; }
    public OracleDBAPrivilege DBAPrivilege { get; }
    public OracleCredential(string userId, SecureString securePassword);
    public OracleCredential(string userId, SecureString securePassword, OracleDBAPrivilege dbaPrivilege);
    public OracleCredential(string userId, SecureString securePassword, string proxyUserId, SecureString secureProxyPassword);
    internal OracleCredential(OracleOpaqueString opaquePassw, OracleOpaqueString opaqueProxyPassw);
    public string get_UserId();
    public SecureString get_Password();
    public string get_ProxyUserId();
    public SecureString get_ProxyPassword();
    public OracleDBAPrivilege get_DBAPrivilege();
}
[DefaultEventAttribute("RowUpdated")]
[DesignerAttribute("Oracle.VsDevTools.OracleVSGDataAdapterWizard, Oracle.VsDevTools, Version=4.122.1.0, Culture=neutral, PublicKeyToken=89b483f429c47342, processorArchitecture=MSIL", "System.ComponentModel.Design.IDesigner")]
[ToolboxBitmapAttribute("resfinder", "Oracle.ManagedDataAccess.src.Client.Icons.OracleDataAdapterToolBox_hc.bmp")]
public class Oracle.ManagedDataAccess.Client.OracleDataAdapter : DbDataAdapter {
    private OracleCommand m_selectCommand;
    private OracleCommand m_insertCommand;
    private OracleCommand m_updateCommand;
    private OracleCommand m_deleteCommand;
    private bool m_requery;
    internal bool m_bAdapterUpdateStarted;
    private static object EventRowUpdated;
    private static object EventRowUpdating;
    internal int m_updateBatchSize;
    private BatchUpdateHelper m_batchUpdateHelper;
    private bool m_bGBRAInvoked;
    private Array m_errorCodesArray;
    private Array m_errMsgsArray;
    private Array m_rowsModArray;
    internal bool m_bSuppressGetDecimalInvalidCastException;
    private bool m_bSuppressDecimalException_set;
    internal CallHistoryRecord m_currentCHR;
    private static short MI_Fill_DT;
    private static short MIFill_DS;
    private static short MI_Fill_DS_2Arg;
    private static short MI_Fill_DS_4Arg;
    private static short MI_Fill_DT_3Arg;
    private static short MI_Fill_DS_ORC_2Arg;
    private static short MI_Fill_DT_ORC_2Arg;
    private static short MI_Fill_DS_ORC_3Arg;
    private static short MI_Fill_DS_ORC_5Arg;
    private static short MI_FillSchema_DS_2Arg;
    private static short MI_FillSchema_DS_3Arg;
    private static short MI_FillSchema_DT_2Arg;
    private static short MI_Update_DT;
    private static short MI_Update_DR;
    private static short MI_Update_DS;
    private static short MI_Update_DS_2Arg;
    private static short MI_GetFillParameters;
    private static short MI_OnRowUpdating;
    private static int numMethods;
    private static MethodInfo[] s_miArray;
    private bool m_bCanRecordNewCall;
    [DescriptionAttribute("")]
[CategoryAttribute("Update")]
[DefaultValueAttribute("")]
public OracleCommand DeleteCommand { get; public set; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("")]
[CategoryAttribute("Update")]
public OracleCommand InsertCommand { get; public set; }
    [DefaultValueAttribute("True")]
[DescriptionAttribute("")]
[CategoryAttribute("Fill")]
public bool Requery { get; public set; }
    [CategoryAttribute("Mapping")]
[DescriptionAttribute("")]
public Hashtable SafeMapping { get; }
    [DefaultValueAttribute("")]
[DescriptionAttribute("")]
[CategoryAttribute("Fill")]
public OracleCommand SelectCommand { get; public set; }
    private IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; private set; }
    private IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; private set; }
    private IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; private set; }
    private IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; private set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Update")]
[DefaultValueAttribute("")]
public OracleCommand UpdateCommand { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool SuppressGetDecimalInvalidCastException { get; public set; }
    [DefaultValueAttribute("1")]
public int UpdateBatchSize { get; public set; }
    private static OracleDataAdapter();
    public OracleDataAdapter(OracleCommand selectCommand);
    public OracleDataAdapter(string selectCommandText, OracleConnection selectConnection);
    public OracleDataAdapter(string selectCommandText, string selectConnectionString);
    public OracleCommand get_DeleteCommand();
    public void set_DeleteCommand(OracleCommand value);
    public OracleCommand get_InsertCommand();
    public void set_InsertCommand(OracleCommand value);
    public bool get_Requery();
    public void set_Requery(bool value);
    public Hashtable get_SafeMapping();
    public OracleCommand get_SelectCommand();
    public void set_SelectCommand(OracleCommand value);
    private sealed virtual override IDbCommand System.Data.IDbDataAdapter.get_DeleteCommand();
    private sealed virtual override void System.Data.IDbDataAdapter.set_DeleteCommand(IDbCommand value);
    private sealed virtual override IDbCommand System.Data.IDbDataAdapter.get_InsertCommand();
    private sealed virtual override void System.Data.IDbDataAdapter.set_InsertCommand(IDbCommand value);
    private sealed virtual override IDbCommand System.Data.IDbDataAdapter.get_SelectCommand();
    private sealed virtual override void System.Data.IDbDataAdapter.set_SelectCommand(IDbCommand value);
    private sealed virtual override IDbCommand System.Data.IDbDataAdapter.get_UpdateCommand();
    private sealed virtual override void System.Data.IDbDataAdapter.set_UpdateCommand(IDbCommand value);
    public OracleCommand get_UpdateCommand();
    public void set_UpdateCommand(OracleCommand value);
    public bool get_SuppressGetDecimalInvalidCastException();
    public void set_SuppressGetDecimalInvalidCastException(bool value);
    public void add_RowUpdating(OracleRowUpdatingEventHandler value);
    public void remove_RowUpdating(OracleRowUpdatingEventHandler value);
    public void add_RowUpdated(OracleRowUpdatedEventHandler value);
    public void remove_RowUpdated(OracleRowUpdatedEventHandler value);
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    public int Fill(DataTable dataTable);
    public virtual int Fill(DataSet dataSet);
    public int Fill(DataSet dataSet, int startRecord, int maxRecords, string srcTable);
    public int Fill(DataSet dataSet, string srcTable);
    public int Fill(int startRecord, int maxRecords, DataTable[] dataTables);
    public DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType, string srcTable);
    public virtual DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType);
    public DataTable FillSchema(DataTable dataTable, SchemaType schemaType);
    public virtual IDataParameter[] GetFillParameters();
    public int Update(DataRow[] dataRows);
    public int Update(DataSet dataSet, string srcTable);
    public int Update(DataTable dataTable);
    public virtual int Update(DataSet dataSet);
    internal void SetConnectionForReplayOnClonedInstance(OracleConnection connection);
    internal OracleDataAdapter DeepCloneForReplay();
    public int Fill(DataSet dataSet, OracleRefCursor refCursor);
    protected virtual int Fill(DataSet dataSet, string srcTable, IDataReader dataReader, int startRecord, int maxRecords);
    public int Fill(DataTable dataTable, OracleRefCursor refCursor);
    protected virtual int Fill(DataTable[] dataTables, int startRecord, int maxRecords, IDbCommand command, CommandBehavior behavior);
    private void FillingExtendedProperties(DataTable dataTable, DataTable schemaTable, OracleDataReader oraDataReader);
    private void FillingExtendedPropertiesHelper(DataTable dataTable, DataTable schemaTable, DataTableMapping dtm, OracleDataReader oraDataReader);
    public int Fill(DataSet dataSet, string srcTable, OracleRefCursor refCursor);
    protected virtual int Fill(DataTable dataTable, IDataReader dataReader);
    protected virtual int Fill(DataTable dataTable, IDbCommand command, CommandBehavior behavior);
    public int Fill(DataSet dataSet, int startRecord, int maxRecords, string srcTable, OracleRefCursor refCursor);
    protected virtual int Fill(DataSet dataSet, int startRecord, int maxRecords, string srcTable, IDbCommand command, CommandBehavior behavior);
    protected virtual DataTable FillSchema(DataTable dataTable, SchemaType schemaType, IDbCommand command, CommandBehavior behavior);
    protected virtual DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType, IDbCommand command, string srcTable, CommandBehavior behavior);
    protected virtual int Update(DataRow[] dataRows, DataTableMapping tableMapping);
    protected virtual RowUpdatedEventArgs CreateRowUpdatedEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
    protected virtual RowUpdatingEventArgs CreateRowUpdatingEvent(DataRow dataRow, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
    protected virtual void OnRowUpdating(RowUpdatingEventArgs value);
    protected virtual void OnRowUpdated(RowUpdatedEventArgs value);
    public virtual int get_UpdateBatchSize();
    public virtual void set_UpdateBatchSize(int value);
    protected virtual void InitializeBatching();
    protected virtual int AddToBatch(IDbCommand command);
    protected virtual void ClearBatch();
    protected virtual IDataParameter GetBatchedParameter(int commandIdentifier, int parameterIndex);
    protected virtual int ExecuteBatch();
    protected virtual void TerminateBatching();
    protected virtual bool GetBatchedRecordsAffected(int commandIdentifier, Int32& recordsAffected, Exception& error);
    protected virtual void Dispose(bool disposing);
}
public class Oracle.ManagedDataAccess.Client.OracleDatabase : object {
    private OracleConnection m_con;
    private OracleCommand m_cmd;
    internal OracleCredential m_orclCredential;
    private bool m_disposed;
    private bool m_bCloseDismountAndFinalize;
    private OracleDatabaseImpl m_databaseImpl;
    public string ServerVersion { get; }
    public OracleDatabase(string connectionString);
    public OracleDatabase(string connectionString, OracleCredential orclCredential);
    internal void Open();
    public void Startup();
    public void Startup(OracleDBStartupMode startupMode, bool bMountAndOpen);
    public void Shutdown();
    public void Shutdown(OracleDBShutdownMode shutdownMode, bool bCloseDismountAndFinalize);
    public void ExecuteNonQuery(string sql);
    public string get_ServerVersion();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    internal void Dispose(bool disposing);
}
public enum Oracle.ManagedDataAccess.Client.OracleDatabaseCharset : Enum {
    public int value__;
    public static OracleDatabaseCharset UTF8;
    public static OracleDatabaseCharset AL32UTF8;
    public static OracleDatabaseCharset AR8ADOS710;
    public static OracleDatabaseCharset AR8ADOS720;
    public static OracleDatabaseCharset AR8APTEC715;
    public static OracleDatabaseCharset AR8ARABICMACS;
    public static OracleDatabaseCharset AR8ASMO8X;
    public static OracleDatabaseCharset AR8EBCDIC420S;
    public static OracleDatabaseCharset AR8EBCDICX;
    public static OracleDatabaseCharset AR8ISO8859P6;
    public static OracleDatabaseCharset AR8MSWIN1256;
    public static OracleDatabaseCharset AR8MUSSAD768;
    public static OracleDatabaseCharset AR8NAFITHA711;
    public static OracleDatabaseCharset AR8NAFITHA721;
    public static OracleDatabaseCharset AR8SAKHR706;
    public static OracleDatabaseCharset AR8SAKHR707;
    public static OracleDatabaseCharset AZ8ISO8859P9E;
    public static OracleDatabaseCharset BG8MSWIN;
    public static OracleDatabaseCharset BG8PC437S;
    public static OracleDatabaseCharset BLT8CP921;
    public static OracleDatabaseCharset BLT8EBCDIC1112;
    public static OracleDatabaseCharset BLT8EBCDIC1112S;
    public static OracleDatabaseCharset BLT8ISO8859P13;
    public static OracleDatabaseCharset BLT8MSWIN1257;
    public static OracleDatabaseCharset BLT8PC775;
    public static OracleDatabaseCharset BN8BSCII;
    public static OracleDatabaseCharset CDN8PC863;
    public static OracleDatabaseCharset CE8BS2000;
    public static OracleDatabaseCharset CEL8ISO8859P14;
    public static OracleDatabaseCharset CL8BS2000;
    public static OracleDatabaseCharset CL8EBCDIC1025;
    public static OracleDatabaseCharset CL8EBCDIC1025C;
    public static OracleDatabaseCharset CL8EBCDIC1025R;
    public static OracleDatabaseCharset CL8EBCDIC1025S;
    public static OracleDatabaseCharset CL8EBCDIC1025X;
    public static OracleDatabaseCharset CL8EBCDIC1158;
    public static OracleDatabaseCharset CL8EBCDIC1158R;
    public static OracleDatabaseCharset CL8ISO8859P5;
    public static OracleDatabaseCharset CL8ISOIR111;
    public static OracleDatabaseCharset CL8KOI8R;
    public static OracleDatabaseCharset CL8KOI8U;
    public static OracleDatabaseCharset CL8MACCYRILLICS;
    public static OracleDatabaseCharset CL8MSWIN1251;
    public static OracleDatabaseCharset D8BS2000;
    public static OracleDatabaseCharset D8EBCDIC1141;
    public static OracleDatabaseCharset D8EBCDIC273;
    public static OracleDatabaseCharset DK8BS2000;
    public static OracleDatabaseCharset DK8EBCDIC1142;
    public static OracleDatabaseCharset DK8EBCDIC277;
    public static OracleDatabaseCharset E8BS2000;
    public static OracleDatabaseCharset EE8BS2000;
    public static OracleDatabaseCharset EE8EBCDIC870;
    public static OracleDatabaseCharset EE8EBCDIC870C;
    public static OracleDatabaseCharset EE8EBCDIC870S;
    public static OracleDatabaseCharset EE8ISO8859P2;
    public static OracleDatabaseCharset EE8MACCES;
    public static OracleDatabaseCharset EE8MACCROATIANS;
    public static OracleDatabaseCharset EE8MSWIN1250;
    public static OracleDatabaseCharset EE8PC852;
    public static OracleDatabaseCharset EEC8EUROASCI;
    public static OracleDatabaseCharset EEC8EUROPA3;
    public static OracleDatabaseCharset EL8DEC;
    public static OracleDatabaseCharset EL8EBCDIC423R;
    public static OracleDatabaseCharset EL8EBCDIC875;
    public static OracleDatabaseCharset EL8EBCDIC875R;
    public static OracleDatabaseCharset EL8EBCDIC875S;
    public static OracleDatabaseCharset EL8GCOS7;
    public static OracleDatabaseCharset EL8ISO8859P7;
    public static OracleDatabaseCharset EL8MACGREEKS;
    public static OracleDatabaseCharset EL8MSWIN1253;
    public static OracleDatabaseCharset EL8PC437S;
    public static OracleDatabaseCharset EL8PC851;
    public static OracleDatabaseCharset EL8PC869;
    public static OracleDatabaseCharset ET8MSWIN923;
    public static OracleDatabaseCharset F8BS2000;
    public static OracleDatabaseCharset F8EBCDIC1147;
    public static OracleDatabaseCharset F8EBCDIC297;
    public static OracleDatabaseCharset HU8ABMOD;
    public static OracleDatabaseCharset HU8CWI2;
    public static OracleDatabaseCharset I8EBCDIC1144;
    public static OracleDatabaseCharset I8EBCDIC280;
    public static OracleDatabaseCharset IN8ISCII;
    public static OracleDatabaseCharset IS8PC861;
    public static OracleDatabaseCharset IW8EBCDIC1086;
    public static OracleDatabaseCharset IW8EBCDIC424;
    public static OracleDatabaseCharset IW8EBCDIC424S;
    public static OracleDatabaseCharset IW8ISO8859P8;
    public static OracleDatabaseCharset IW8MACHEBREWS;
    public static OracleDatabaseCharset IW8MSWIN1255;
    public static OracleDatabaseCharset IW8PC1507;
    public static OracleDatabaseCharset JA16DBCS;
    public static OracleDatabaseCharset JA16EBCDIC930;
    public static OracleDatabaseCharset JA16EUC;
    public static OracleDatabaseCharset JA16EUCTILDE;
    public static OracleDatabaseCharset JA16SJIS;
    public static OracleDatabaseCharset JA16SJISTILDE;
    public static OracleDatabaseCharset JA16VMS;
    public static OracleDatabaseCharset KO16DBCS;
    public static OracleDatabaseCharset KO16KSC5601;
    public static OracleDatabaseCharset KO16KSCCS;
    public static OracleDatabaseCharset KO16MSWIN949;
    public static OracleDatabaseCharset LA8ISO6937;
    public static OracleDatabaseCharset LA8PASSPORT;
    public static OracleDatabaseCharset LT8MSWIN921;
    public static OracleDatabaseCharset LT8PC772;
    public static OracleDatabaseCharset LT8PC774;
    public static OracleDatabaseCharset LV8PC1117;
    public static OracleDatabaseCharset LV8PC8LR;
    public static OracleDatabaseCharset LV8RST104090;
    public static OracleDatabaseCharset N8PC865;
    public static OracleDatabaseCharset NE8ISO8859P10;
    public static OracleDatabaseCharset NEE8ISO8859P4;
    public static OracleDatabaseCharset RU8BESTA;
    public static OracleDatabaseCharset RU8PC855;
    public static OracleDatabaseCharset RU8PC866;
    public static OracleDatabaseCharset S8BS2000;
    public static OracleDatabaseCharset S8EBCDIC1143;
    public static OracleDatabaseCharset S8EBCDIC278;
    public static OracleDatabaseCharset SE8ISO8859P3;
    public static OracleDatabaseCharset TH8MACTHAI;
    public static OracleDatabaseCharset TH8TISASCII;
    public static OracleDatabaseCharset TH8TISEBCDIC;
    public static OracleDatabaseCharset TH8TISEBCDICS;
    public static OracleDatabaseCharset TIMESTEN8;
    public static OracleDatabaseCharset TR8DEC;
    public static OracleDatabaseCharset TR8EBCDIC1026;
    public static OracleDatabaseCharset TR8EBCDIC1026S;
    public static OracleDatabaseCharset TR8MACTURKISHS;
    public static OracleDatabaseCharset TR8MSWIN1254;
    public static OracleDatabaseCharset TR8PC857;
    public static OracleDatabaseCharset US7ASCII;
    public static OracleDatabaseCharset US8BS2000;
    public static OracleDatabaseCharset US8ICL;
    public static OracleDatabaseCharset US8PC437;
    public static OracleDatabaseCharset VN8MSWIN1258;
    public static OracleDatabaseCharset VN8VN3;
    public static OracleDatabaseCharset WE8BS2000;
    public static OracleDatabaseCharset WE8BS2000E;
    public static OracleDatabaseCharset WE8BS2000L5;
    public static OracleDatabaseCharset WE8DEC;
    public static OracleDatabaseCharset WE8DG;
    public static OracleDatabaseCharset WE8EBCDIC1047;
    public static OracleDatabaseCharset WE8EBCDIC1047E;
    public static OracleDatabaseCharset WE8EBCDIC1140;
    public static OracleDatabaseCharset WE8EBCDIC1140C;
    public static OracleDatabaseCharset WE8EBCDIC1145;
    public static OracleDatabaseCharset WE8EBCDIC1146;
    public static OracleDatabaseCharset WE8EBCDIC1148;
    public static OracleDatabaseCharset WE8EBCDIC1148C;
    public static OracleDatabaseCharset WE8EBCDIC284;
    public static OracleDatabaseCharset WE8EBCDIC285;
    public static OracleDatabaseCharset WE8EBCDIC37;
    public static OracleDatabaseCharset WE8EBCDIC37C;
    public static OracleDatabaseCharset WE8EBCDIC500;
    public static OracleDatabaseCharset WE8EBCDIC500C;
    public static OracleDatabaseCharset WE8EBCDIC871;
    public static OracleDatabaseCharset WE8EBCDIC924;
    public static OracleDatabaseCharset WE8GCOS7;
    public static OracleDatabaseCharset WE8ICL;
    public static OracleDatabaseCharset WE8ISO8859P1;
    public static OracleDatabaseCharset WE8ISO8859P15;
    public static OracleDatabaseCharset WE8ISO8859P9;
    public static OracleDatabaseCharset WE8MACROMAN8;
    public static OracleDatabaseCharset WE8MSWIN1252;
    public static OracleDatabaseCharset WE8NCR4970;
    public static OracleDatabaseCharset WE8NEXTSTEP;
    public static OracleDatabaseCharset WE8PC850;
    public static OracleDatabaseCharset WE8PC858;
    public static OracleDatabaseCharset WE8PC860;
    public static OracleDatabaseCharset WE8ROMAN8;
    public static OracleDatabaseCharset ZHS16CGB231280;
    public static OracleDatabaseCharset ZHS16DBCS;
    public static OracleDatabaseCharset ZHS16GBK;
    public static OracleDatabaseCharset ZHS32GB18030;
    public static OracleDatabaseCharset ZHT16BIG5;
    public static OracleDatabaseCharset ZHT16CCDC;
    public static OracleDatabaseCharset ZHT16DBCS;
    public static OracleDatabaseCharset ZHT16DBT;
    public static OracleDatabaseCharset ZHT16HKSCS;
    public static OracleDatabaseCharset ZHT16HKSCS31;
    public static OracleDatabaseCharset ZHT16MSWIN950;
    public static OracleDatabaseCharset ZHT32EUC;
    public static OracleDatabaseCharset ZHT32SOPS;
    public static OracleDatabaseCharset ZHT32TRIS;
}
public enum Oracle.ManagedDataAccess.Client.OracleDatabaseNCharset : Enum {
    public int value__;
    public static OracleDatabaseNCharset UTF8;
    public static OracleDatabaseNCharset AL16UTF16;
}
[JsonConverterAttribute("Oracle.ManagedDataAccess.Client.OracleDateReaderJsonConverter")]
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Client.OracleDataReader : DbDataReader {
    private static string s_Read;
    internal OracleDataReaderImpl m_readerImpl;
    internal OracleConnection m_connection;
    private bool m_bclosed;
    private bool m_bDisposed;
    internal bool m_bCanRecordNewCall;
    internal CallHistoryRecord m_chr;
    private bool m_bACEnabledOnReader;
    private bool m_bForRefCursorToJsonString;
    private static short MI_Read;
    private static short MI_GetValue;
    private static short MI_GetValues;
    private static short MI_GetString;
    private static short MI_GetChars;
    private static short MI_GetBytes;
    private static short MI_GetOracleBinary;
    private static short MI_GetOracleBFile;
    private static short MI_GetOracleBlob;
    private static short MI_GetOracleBlobForUpdate_1Arg;
    private static short MI_GetOracleBlobForUpdate_2Arg;
    private static short MI_GetOracleClob;
    private static short MI_GetOracleClobForUpdate_1Arg;
    private static short MI_GetOracleClobForUpdate_2Arg;
    private static short MI_GetOracleString;
    private static short MI_GetOracleValue;
    private static short MI_GetOracleValues;
    private static short MI_GetProviderSpecificValue;
    private static short MI_GetProviderSpecificValues;
    private static short MI_NextResult;
    private static short MI_Close;
    private static short MI_Dispose;
    private static short MI_FetchSize;
    private static short MI_SuppressGetDecimalInvalidCastException;
    private static int numMethods;
    private static MethodInfo[] s_miArray;
    internal object m_invokingInstanceWrapper;
    internal bool m_bGCInvokedDestructor;
    private bool m_bAsyncCallInProgress;
    private long m_fetchSize { get; private set; }
    private int m_maxRowSize { get; private set; }
    private int m_initialLongFetchSize { get; private set; }
    private CommandBehavior m_commandBehavior { get; private set; }
    internal OracleRefCursor m_refCursor { get; internal set; }
    private int m_recordsAffected { get; private set; }
    private bool m_bBeginingOfFile { get; private set; }
    internal bool m_bEndOfFile { get; internal set; }
    private int m_fieldCount { get; private set; }
    private bool m_bDoneReadOne { get; private set; }
    private bool m_bHasRows { get; private set; }
    internal int m_internalRowCounter { get; internal set; }
    private string m_commandText { get; private set; }
    private CommandType m_commandType { get; private set; }
    internal bool m_returnPSTypes { get; internal set; }
    internal string m_storedProcName { get; internal set; }
    private DataTable m_dataTableEx { get; private set; }
    private DataTable m_dataTable { get; private set; }
    private SqlStatementType m_sqlStatementType { get; private set; }
    private bool m_noMoreResults { get; private set; }
    private bool m_fillReader { get; private set; }
    private ArrayList m_dataTableList { get; private set; }
    private bool m_bInternalCall { get; private set; }
    internal Type[] m_expectedColumnTypes { get; internal set; }
    internal bool m_isFromEF { get; internal set; }
    internal bool m_isFromEFCore { get; internal set; }
    internal bool m_bMapNumberToBoolean { get; internal set; }
    internal int m_edmMappingMaxBOOL { get; internal set; }
    internal bool m_bMapNumberToByte { get; internal set; }
    internal int m_edmMappingMaxBYTE { get; internal set; }
    internal int m_edmMappingMaxINT16 { get; internal set; }
    internal int m_edmMappingMaxINT32 { get; internal set; }
    internal int m_edmMappingMaxINT64 { get; internal set; }
    private Object[] m_LobImplCache { get; private set; }
    private int m_RowNumber { get; private set; }
    private Int64[] m_LastCachedRowNumber { get; private set; }
    internal ArrayList m_tempLobFromCurrentFetch { get; internal set; }
    private TimeSpan m_LocalTimeAdjustment { get; private set; }
    internal OracleBlobImpl m_tempOraBlobImpl { get; internal set; }
    internal OracleClobImpl m_tempOraClobImpl { get; internal set; }
    internal object m_dataTablesReferenceForFill { get; internal set; }
    private int m_currentDataTableIndex { get; private set; }
    private DataTable m_currentDataTableForFill { get; private set; }
    internal bool m_bUseDataSetAsDupStore { get; internal set; }
    private int m_initialRowCnt { get; private set; }
    private bool m_isRowAddedToDatatable { get; private set; }
    internal int m_numExplicitBoundRefCursors { get; internal set; }
    private object m_lockDataReader { get; private set; }
    internal bool m_bSuppressGetDecimalInvalidCastException { get; internal set; }
    private NumberFormatInfo m_nfi { get; private set; }
    private string m_formatNumericCharacters { get; private set; }
    private string m_formatTimeStamp { get; private set; }
    private string m_formatTimeStampTZ { get; private set; }
    private string m_formatDate { get; private set; }
    public int Depth { get; }
    public long FetchSize { get; public set; }
    public int FieldCount { get; }
    public bool HasRows { get; }
    public int VisibleFieldCount { get; }
    public int HiddenFieldCount { get; }
    public int InitialLONGFetchSize { get; }
    public int InitialLOBFetchSize { get; }
    public bool IsClosed { get; }
    public object Item { get; }
    public object Item { get; }
    public int RecordsAffected { get; }
    internal int CurrentRow { get; }
    public long RowSize { get; }
    internal bool IsFillReader { get; internal set; }
    internal ArrayList SchemaTables { get; }
    internal OracleRefCursor RefCursor { get; internal set; }
    public bool UseEdmMapping { get; }
    public bool SuppressGetDecimalInvalidCastException { get; public set; }
    private static OracleDataReader();
    internal OracleDataReader(OracleDataReaderImpl readerImpl, OracleConnection connection, long fetchSize, long clientInitialLOBFS, long internalInitialLOBFS, long internalInitialJSONFS, int initialLongFetchSize, int recordsAffected, string commandText, SqlStatementType sqlStatementType, Nullable`1<CommandType> commandType, CommandBehavior behavior);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleDataReader/<GetValueInternalAsync>d__0")]
private ValueTask`1<object> GetValueInternalAsync(int i, bool bAsync, CallHistoryRecord chr, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleDataReader/<ReadInternalAsync>d__1")]
internal ValueTask`1<bool> ReadInternalAsync(bool bAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleDataReader/<GetLongRawDataAsync>d__2")]
internal ValueTask`1<ReaderGetLongRawData_RefAndOutParamArgCtx> GetLongRawDataAsync(OracleConnection connection, int currentRow, int columnIndex, long fieldOffset, ReaderGetLongRawData_RefAndOutParamArgCtx readerGLRD_refOutCtx, int bufferOffset, int length, bool bAllocateBuffer, bool bAsync, CallHistoryRecord chr);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleDataReader/<GetLongAccessorToFetchMoreDataAsync>d__3")]
private ValueTask`1<ReaderGetLongAccessorToFetchMoreData_RefAndOutParamArgCtx> GetLongAccessorToFetchMoreDataAsync(OracleConnection connection, int length, ReaderGetLongAccessorToFetchMoreData_RefAndOutParamArgCtx refOutCtx, bool bAsync, CallHistoryRecord chr);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleDataReader/<ExecuteQueryToFetchLongDataAsync>d__4")]
internal ValueTask`1<ExecuteQueryToFetchLongData_OutCtx> ExecuteQueryToFetchLongDataAsync(OracleConnection connection, int currentRow, int columnIndex, int length, ExecuteQueryToFetchLongData_OutCtx outCtx, bool bAsync, CallHistoryRecord chr);
    private long get_m_fetchSize();
    private void set_m_fetchSize(long value);
    private int get_m_maxRowSize();
    private void set_m_maxRowSize(int value);
    private int get_m_initialLongFetchSize();
    private void set_m_initialLongFetchSize(int value);
    private CommandBehavior get_m_commandBehavior();
    private void set_m_commandBehavior(CommandBehavior value);
    internal OracleRefCursor get_m_refCursor();
    internal void set_m_refCursor(OracleRefCursor value);
    private int get_m_recordsAffected();
    private void set_m_recordsAffected(int value);
    private bool get_m_bBeginingOfFile();
    private void set_m_bBeginingOfFile(bool value);
    internal bool get_m_bEndOfFile();
    internal void set_m_bEndOfFile(bool value);
    private int get_m_fieldCount();
    private void set_m_fieldCount(int value);
    private bool get_m_bDoneReadOne();
    private void set_m_bDoneReadOne(bool value);
    private bool get_m_bHasRows();
    private void set_m_bHasRows(bool value);
    internal int get_m_internalRowCounter();
    internal void set_m_internalRowCounter(int value);
    private string get_m_commandText();
    private void set_m_commandText(string value);
    private CommandType get_m_commandType();
    private void set_m_commandType(CommandType value);
    internal bool get_m_returnPSTypes();
    internal void set_m_returnPSTypes(bool value);
    internal string get_m_storedProcName();
    internal void set_m_storedProcName(string value);
    private DataTable get_m_dataTableEx();
    private void set_m_dataTableEx(DataTable value);
    private DataTable get_m_dataTable();
    private void set_m_dataTable(DataTable value);
    private SqlStatementType get_m_sqlStatementType();
    private void set_m_sqlStatementType(SqlStatementType value);
    private bool get_m_noMoreResults();
    private void set_m_noMoreResults(bool value);
    private bool get_m_fillReader();
    private void set_m_fillReader(bool value);
    private ArrayList get_m_dataTableList();
    private void set_m_dataTableList(ArrayList value);
    private bool get_m_bInternalCall();
    private void set_m_bInternalCall(bool value);
    internal Type[] get_m_expectedColumnTypes();
    internal void set_m_expectedColumnTypes(Type[] value);
    internal bool get_m_isFromEF();
    internal void set_m_isFromEF(bool value);
    internal bool get_m_isFromEFCore();
    internal void set_m_isFromEFCore(bool value);
    internal bool get_m_bMapNumberToBoolean();
    internal void set_m_bMapNumberToBoolean(bool value);
    internal int get_m_edmMappingMaxBOOL();
    internal void set_m_edmMappingMaxBOOL(int value);
    internal bool get_m_bMapNumberToByte();
    internal void set_m_bMapNumberToByte(bool value);
    internal int get_m_edmMappingMaxBYTE();
    internal void set_m_edmMappingMaxBYTE(int value);
    internal int get_m_edmMappingMaxINT16();
    internal void set_m_edmMappingMaxINT16(int value);
    internal int get_m_edmMappingMaxINT32();
    internal void set_m_edmMappingMaxINT32(int value);
    internal int get_m_edmMappingMaxINT64();
    internal void set_m_edmMappingMaxINT64(int value);
    private Object[] get_m_LobImplCache();
    private void set_m_LobImplCache(Object[] value);
    private int get_m_RowNumber();
    private void set_m_RowNumber(int value);
    private Int64[] get_m_LastCachedRowNumber();
    private void set_m_LastCachedRowNumber(Int64[] value);
    internal ArrayList get_m_tempLobFromCurrentFetch();
    internal void set_m_tempLobFromCurrentFetch(ArrayList value);
    private TimeSpan get_m_LocalTimeAdjustment();
    private void set_m_LocalTimeAdjustment(TimeSpan value);
    internal OracleBlobImpl get_m_tempOraBlobImpl();
    internal void set_m_tempOraBlobImpl(OracleBlobImpl value);
    internal OracleClobImpl get_m_tempOraClobImpl();
    internal void set_m_tempOraClobImpl(OracleClobImpl value);
    internal object get_m_dataTablesReferenceForFill();
    internal void set_m_dataTablesReferenceForFill(object value);
    private int get_m_currentDataTableIndex();
    private void set_m_currentDataTableIndex(int value);
    private DataTable get_m_currentDataTableForFill();
    private void set_m_currentDataTableForFill(DataTable value);
    internal bool get_m_bUseDataSetAsDupStore();
    internal void set_m_bUseDataSetAsDupStore(bool value);
    private int get_m_initialRowCnt();
    private void set_m_initialRowCnt(int value);
    private bool get_m_isRowAddedToDatatable();
    private void set_m_isRowAddedToDatatable(bool value);
    internal int get_m_numExplicitBoundRefCursors();
    internal void set_m_numExplicitBoundRefCursors(int value);
    private object get_m_lockDataReader();
    private void set_m_lockDataReader(object value);
    internal bool get_m_bSuppressGetDecimalInvalidCastException();
    internal void set_m_bSuppressGetDecimalInvalidCastException(bool value);
    private NumberFormatInfo get_m_nfi();
    private void set_m_nfi(NumberFormatInfo value);
    private string get_m_formatNumericCharacters();
    private void set_m_formatNumericCharacters(string value);
    private string get_m_formatTimeStamp();
    private void set_m_formatTimeStamp(string value);
    private string get_m_formatTimeStampTZ();
    private void set_m_formatTimeStampTZ(string value);
    private string get_m_formatDate();
    private void set_m_formatDate(string value);
    internal void OnClose();
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    protected virtual override void Finalize();
    public virtual int get_Depth();
    public long get_FetchSize();
    public void set_FetchSize(long value);
    public virtual int get_FieldCount();
    public virtual bool get_HasRows();
    public virtual int get_VisibleFieldCount();
    public int get_HiddenFieldCount();
    public int get_InitialLONGFetchSize();
    public int get_InitialLOBFetchSize();
    public virtual bool get_IsClosed();
    public virtual object get_Item(string columnName);
    public virtual object get_Item(int i);
    public virtual int get_RecordsAffected();
    internal int get_CurrentRow();
    public long get_RowSize();
    internal bool get_IsFillReader();
    internal void set_IsFillReader(bool value);
    internal ArrayList get_SchemaTables();
    internal OracleRefCursor get_RefCursor();
    internal void set_RefCursor(OracleRefCursor value);
    public bool get_UseEdmMapping();
    public bool get_SuppressGetDecimalInvalidCastException();
    public void set_SuppressGetDecimalInvalidCastException(bool value);
    public virtual void Close();
    public void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual short GetInt16(int i);
    public virtual int GetInt32(int i);
    public virtual long GetInt64(int i);
    public virtual decimal GetDecimal(int i);
    public virtual double GetDouble(int i);
    public virtual float GetFloat(int i);
    public virtual string GetString(int i);
    internal void CheckVectorType(int i);
    public OracleDbType GetVectorNumericFormat(int i);
    public OracleDbType GetVectorNumericFormat(string columnName);
    public Single[] GetFloatArray(int i);
    public Single[] GetFloatArray(string columnName);
    public Double[] GetDoubleArray(int i);
    public Double[] GetDoubleArray(string columnName);
    public Int16[] GetInt16Array(int i);
    public Int16[] GetInt16Array(string columnName);
    internal string GetStringInternal(int i, CallHistoryRecord chr);
    private string GetNumberString(int i);
    private string GetDateTimeString(int i);
    private string GetIntervalString(int i);
    private string GetRefCursorString(int i);
    public TimeSpan GetTimeSpan(int i);
    public virtual bool GetBoolean(int i);
    public OracleBoolean GetOracleBoolean(int i);
    public virtual byte GetByte(int i);
    public virtual long GetBytes(int i, long fieldOffset, Byte[] buffer, int bufferOffset, int length);
    internal long GetBytesInternal(int i, long fieldOffset, Byte[] buffer, int bufferOffset, int length, bool bThrowException, CallHistoryRecord chr);
    public virtual char GetChar(int i);
    public virtual long GetChars(int i, long fieldOffset, Char[] buffer, int bufferOffset, int length);
    public virtual DateTime GetDateTime(int i);
    public DateTimeOffset GetDateTimeOffset(int i);
    public virtual Guid GetGuid(int i);
    public DbDataReader GetData(int i);
    public virtual string GetDataTypeName(int i);
    public virtual IEnumerator GetEnumerator();
    public virtual Type GetFieldType(int i);
    public virtual string GetName(int i);
    public OracleBinary GetOracleBinary(int i);
    internal OracleBinary GetOracleBinaryInternal(int i, CallHistoryRecord chr);
    public OracleBFile GetOracleBFile(int i);
    internal OracleBFile GetOracleBFileInternal(int i, CallHistoryRecord chr);
    public OracleBlob GetOracleBlob(int i);
    internal OracleBlob GetOracleBlobInternal(int i, CallHistoryRecord chr);
    public OracleBlob GetOracleBlobForUpdate(int i);
    public OracleBlob GetOracleBlobForUpdate(int i, int wait);
    public OracleClob GetOracleClob(int i);
    internal OracleClob GetOracleClobInternal(int i, CallHistoryRecord chr);
    public OracleClob GetOracleClobForUpdate(int i);
    public OracleClob GetOracleClobForUpdate(int i, int wait);
    public OracleDate GetOracleDate(int i);
    public OracleDecimal GetOracleDecimal(int i);
    public OracleIntervalDS GetOracleIntervalDS(int i);
    public OracleIntervalYM GetOracleIntervalYM(int i);
    public OracleString GetOracleString(int i);
    internal OracleString GetOracleStringInternal(int i, CallHistoryRecord chr);
    public OracleTimeStamp GetOracleTimeStamp(int i);
    public OracleTimeStampLTZ GetOracleTimeStampLTZ(int i);
    public OracleTimeStampTZ GetOracleTimeStampTZ(int i);
    public OracleXmlType GetOracleXmlType(int i);
    public OracleRef GetOracleRef(int i);
    public OracleRefCursor GetOracleRefCursor(int i);
    public OracleDataReader GetOracleDataReader(int i);
    public object GetOracleValue(int i);
    internal object GetOracleValueInternal(int i, CallHistoryRecord chr);
    public int GetOracleValues(Object[] values);
    internal int GetOracleValuesInternal(Object[] values, CallHistoryRecord chr);
    public virtual int GetOrdinal(string name);
    public virtual Type GetProviderSpecificFieldType(int ordinal);
    public virtual object GetProviderSpecificValue(int ordinal);
    public virtual int GetProviderSpecificValues(Object[] values);
    public virtual DataTable GetSchemaTable();
    internal DataTable GetSchemaTableEx();
    private DataTable GetSchemaTableCopy(DataTable& dataTable, bool isFromEx);
    private void RetrieveSchemaTable(DataTable& dataTable, bool isFromEx);
    private void PopulateMetaData(bool tryGetPKInfo);
    public virtual object GetValue(int i);
    public virtual int GetValues(Object[] values);
    public XmlReader GetXmlReader(int i);
    public virtual bool IsDBNull(int i);
    public virtual bool NextResult();
    public virtual Task`1<bool> IsDBNullAsync(int i, CancellationToken cancellationToken);
    public virtual Task`1<bool> NextResultAsync(CancellationToken cancellationToken);
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    internal void CancelAsyncOperation();
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleDataReader/<ReadAsyncHelper>d__339")]
internal ValueTask`1<bool> ReadAsyncHelper(CancellationToken cancellationToken);
    public virtual Task`1<T> GetFieldValueAsync(int ordinal, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleDataReader/<GetFieldValueAsyncHelper>d__341`1")]
internal ValueTask`1<T> GetFieldValueAsyncHelper(int ordinal, CancellationToken cancellationToken);
    public virtual bool Read();
    private bool SkipReadCalls(List`1<List`1<GetPSCallsState>> readCalls);
    internal void RelRefOnAllTempLobs();
    internal void ProcessAnyTempLOBs(int rowNumber);
    internal void ReleaseUDTInsts(int rowNumber, bool bClose);
    internal object GetCustomObject(int i, UDTNamedType udtType);
    internal object GetCustomObject(int i);
    internal string GetUDTJsonString(int i);
    internal string GetRefHexString(int i);
    internal void ToJsonString(Utf8JsonWriter writer);
    private OracleDbType GetOraDbType(int i);
    private bool IsCorruptible(OraType oraType);
    internal DataTable GetMinSchemaTable();
    private object ChangeType(object sourceValue, Type targetType);
    internal string GetLongData(OracleConnection connection, int currentRow, int columnIndex, int length, CallHistoryRecord chr);
    internal Byte[] GetOracleLobForUpdate(int i, int wait, CallHistoryRecord chr);
    internal void GetEdmMappingConfigValues();
    internal void PopulateExpectedTypes();
    private object GetValueInternal(int i, bool bAsync, CallHistoryRecord chr);
    internal bool ReadInternal(bool bAsync);
    internal ReaderGetLongRawData_RefAndOutParamArgCtx GetLongRawData(OracleConnection connection, int currentRow, int columnIndex, long fieldOffset, ReaderGetLongRawData_RefAndOutParamArgCtx readerGLRD_refOutCtx, int bufferOffset, int length, bool bAllocateBuffer, bool bAsync, CallHistoryRecord chr);
    private ReaderGetLongAccessorToFetchMoreData_RefAndOutParamArgCtx GetLongAccessorToFetchMoreData(OracleConnection connection, int length, ReaderGetLongAccessorToFetchMoreData_RefAndOutParamArgCtx refOutCtx, bool bAsync, CallHistoryRecord chr);
    internal ExecuteQueryToFetchLongData_OutCtx ExecuteQueryToFetchLongData(OracleConnection connection, int currentRow, int columnIndex, int length, ExecuteQueryToFetchLongData_OutCtx outCtx, bool bAsync, CallHistoryRecord chr);
}
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Client.OracleDataSourceCollection : object {
    internal static object s_syncObj;
    public int Count { get; }
    public string Item { get; public set; }
    private static OracleDataSourceCollection();
    public void Add(string tnsName, string tnsDescriptor);
    public void Remove(string tnsName);
    public int get_Count();
    public string get_Item(string tnsName);
    public void set_Item(string tnsName, string value);
}
public class Oracle.ManagedDataAccess.Client.OracleDataSourceEnumerator : DbDataSourceEnumerator {
    private static string DATA_SOURCE;
    private static string INSTANCE_NAME;
    private static string SERVER_NAME;
    private static string SERVICE_NAME;
    private static string PROTOCOL;
    private static string PORT;
    public virtual DataTable GetDataSources();
    private void HandleDescription(NVPair descriptionNV, string tnsAlias, DataTable& dataSrcTab);
    private void PopulateAddress(NVPair addressNV, DataRow& newRow);
    private void PopulateConnectData(NVPair connectDataNV, DataRow& newRow);
}
internal class Oracle.ManagedDataAccess.Client.OracleDateReaderJsonConverter : JsonConverter`1<OracleDataReader> {
    public virtual OracleDataReader Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, OracleDataReader reader, JsonSerializerOptions options);
}
public enum Oracle.ManagedDataAccess.Client.OracleDBAPrivilege : Enum {
    public int value__;
    public static OracleDBAPrivilege None;
    public static OracleDBAPrivilege SYSDBA;
    public static OracleDBAPrivilege SYSOPER;
    public static OracleDBAPrivilege SYSASM;
    public static OracleDBAPrivilege SYSBACKUP;
    public static OracleDBAPrivilege SYSDG;
    public static OracleDBAPrivilege SYSKM;
    public static OracleDBAPrivilege SYSRAC;
}
public enum Oracle.ManagedDataAccess.Client.OracleDBShutdownMode : Enum {
    public int value__;
    public static OracleDBShutdownMode Default;
    public static OracleDBShutdownMode Transactional;
    public static OracleDBShutdownMode TransactionalLocal;
    public static OracleDBShutdownMode Immediate;
    public static OracleDBShutdownMode Abort;
    public static OracleDBShutdownMode Final;
}
public enum Oracle.ManagedDataAccess.Client.OracleDBStartupMode : Enum {
    public int value__;
    public static OracleDBStartupMode NoRestriction;
    public static OracleDBStartupMode Force;
    public static OracleDBStartupMode Restrict;
}
public enum Oracle.ManagedDataAccess.Client.OracleDbType : Enum {
    public int value__;
    public static OracleDbType BFile;
    public static OracleDbType Blob;
    public static OracleDbType Byte;
    public static OracleDbType Char;
    public static OracleDbType Clob;
    public static OracleDbType Date;
    public static OracleDbType Decimal;
    public static OracleDbType Double;
    public static OracleDbType Long;
    public static OracleDbType LongRaw;
    public static OracleDbType Int16;
    public static OracleDbType Int32;
    public static OracleDbType Int64;
    public static OracleDbType IntervalDS;
    public static OracleDbType IntervalYM;
    public static OracleDbType NClob;
    public static OracleDbType NChar;
    public static OracleDbType NVarchar2;
    public static OracleDbType Raw;
    public static OracleDbType RefCursor;
    public static OracleDbType Single;
    public static OracleDbType TimeStamp;
    public static OracleDbType TimeStampLTZ;
    public static OracleDbType TimeStampTZ;
    public static OracleDbType Varchar2;
    public static OracleDbType XmlType;
    public static OracleDbType Array;
    public static OracleDbType Object;
    public static OracleDbType Ref;
    public static OracleDbType BinaryDouble;
    public static OracleDbType BinaryFloat;
    public static OracleDbType Boolean;
    public static OracleDbType Json;
    public static OracleDbType ArrayAsJson;
    public static OracleDbType ObjectAsJson;
    public static OracleDbType Vector;
    public static OracleDbType Vector_Int8;
    public static OracleDbType Vector_Float32;
    public static OracleDbType Vector_Float64;
}
public class Oracle.ManagedDataAccess.Client.OracleDependency : object {
    internal OracleDependencyImpl m_orclDependencyImpl;
    private static Hashtable s_depTable;
    private static long m_staticRegistrationId;
    internal string m_guid;
    internal string m_dataSource;
    internal string m_userName;
    private bool m_bHasChanges;
    internal OracleRowidInfo m_OracleRowidInfo;
    internal bool m_bQueryBasedNTFN;
    private object m_syncObject;
    private static string m_defaultHostName;
    private static string m_defaultDomainName;
    internal static Hashtable s_serverIdToClientIdMap;
    [CompilerGeneratedAttribute]
private OnChangeEventHandler OnChange;
    public static int Port { get; public set; }
    public static string Address { get; public set; }
    public string DataSource { get; }
    public bool HasChanges { get; }
    public string Id { get; }
    private long InvalidationString { get; }
    public bool IsEnabled { get; }
    public bool QueryBasedNotification { get; public set; }
    public OracleRowidInfo RowidInfo { get; public set; }
    public ArrayList RegisteredResources { get; }
    public ArrayList RegisteredQueryIDs { get; }
    public string UserName { get; }
    private static OracleDependency();
    public OracleDependency(OracleCommand cmd);
    public OracleDependency(OracleCommand cmd, bool isNotifiedOnce, long timeout, bool isPersistent);
    public static int get_Port();
    public static void set_Port(int value);
    public static string get_Address();
    public static void set_Address(string value);
    public static OracleDependency GetOracleDependency(string guid);
    public string get_DataSource();
    public bool get_HasChanges();
    public string get_Id();
    private long get_InvalidationString();
    public bool get_IsEnabled();
    public bool get_QueryBasedNotification();
    public void set_QueryBasedNotification(bool value);
    public OracleRowidInfo get_RowidInfo();
    public void set_RowidInfo(OracleRowidInfo value);
    public ArrayList get_RegisteredResources();
    public ArrayList get_RegisteredQueryIDs();
    public string get_UserName();
    [CompilerGeneratedAttribute]
public void add_OnChange(OnChangeEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OnChange(OnChangeEventHandler value);
    public void AddCommandDependency(OracleCommand cmd);
    public void RemoveRegistration(OracleConnection conn);
    public void FiredEvent(OracleNotificationEventArgs e);
    internal void SetRegisterInfo(string username, string dataSource, OracleNotificationRequest ntfnReq);
    internal static OracleDependency GetOracleDependencyFromNTFNId(long id);
    internal static void SetNotificationDetails(object notifInfoObj);
    internal static long GetNextClientRegistrationId();
}
public class Oracle.ManagedDataAccess.Client.OracleError : object {
    private string m_dataSource;
    private string m_procedure;
    private string m_message;
    private int m_number;
    private int m_parseErrorOffset;
    private int m_arrayBindIndex;
    private bool m_isRecoverable;
    public string DataSource { get; }
    public string Message { get; }
    public int Number { get; }
    public int ParseErrorOffset { get; }
    public string Procedure { get; }
    public string Source { get; }
    public int ArrayBindIndex { get; }
    internal bool IsRecoverable { get; }
    internal OracleError(int errNumber, int parseErrorOffset, string dataSrc, string procedure, string errMsg);
    internal OracleError(int errNumber, string dataSrc, string procedure, string errMsg, int arrayBindIndex);
    private bool IsErrorRecoverable(int errcode);
    public string get_DataSource();
    public string get_Message();
    public int get_Number();
    public int get_ParseErrorOffset();
    public string get_Procedure();
    public string get_Source();
    public int get_ArrayBindIndex();
    internal bool get_IsRecoverable();
}
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Client.OracleErrorCollection : ArrayList {
    public OracleError Item { get; public set; }
    public OracleError get_Item(int index);
    public void set_Item(int index, OracleError value);
}
public class Oracle.ManagedDataAccess.Client.OracleException : DbException {
    private OracleErrorCollection m_errors;
    internal OracleLogicalTransaction m_OracleLogicalTransaction;
    public OracleLogicalTransaction OracleLogicalTransaction { get; }
    public OracleErrorCollection Errors { get; }
    public string DataSource { get; }
    public string Message { get; }
    public string Procedure { get; }
    public string Source { get; }
    public int Number { get; }
    public bool IsRecoverable { get; }
    internal OracleException(OracleErrorCollection oec);
    internal OracleException(NetworkException inner);
    internal OracleException(int errCode, string dataSrc, string procedure, string errMsg, int parseErrorOffset);
    internal OracleException(int errCode, string dataSrc, string procedure, string errMsg, Exception innerException);
    private OracleException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public OracleLogicalTransaction get_OracleLogicalTransaction();
    public OracleErrorCollection get_Errors();
    public string get_DataSource();
    public virtual string get_Message();
    public string get_Procedure();
    public virtual string get_Source();
    public int get_Number();
    public bool get_IsRecoverable();
    internal void AddBindErrorToCollection(int errCode, string dataSrc, string procedure, string errMsg, int arrayBindIndex);
    internal static void HandleError(OracleTraceLevel level, OracleTraceTag tag, OracleTraceClassName className, OracleTraceFuncName funcName, Exception ex, OracleLogicalTransaction oracleLogicalTransaction);
    internal static void HandleError(OracleTraceLevel level, OracleTraceTag tag, OracleTraceClassName className, OracleTraceFuncName funcName, object traceObj, Exception ex, OracleLogicalTransaction oracleLogicalTransaction);
}
public enum Oracle.ManagedDataAccess.Client.OracleFailoverEvent : Enum {
    public int value__;
    public static OracleFailoverEvent End;
    public static OracleFailoverEvent Abort;
    public static OracleFailoverEvent Reauth;
    public static OracleFailoverEvent Begin;
    public static OracleFailoverEvent Error;
}
public class Oracle.ManagedDataAccess.Client.OracleFailoverEventArgs : EventArgs {
    private OracleConnection m_FailoverCtx;
    private OracleFailoverType m_FailoverType;
    private OracleFailoverEvent m_FailoverEvent;
    public OracleFailoverType FailoverType { get; }
    public OracleFailoverEvent FailoverEvent { get; }
    internal OracleFailoverEventArgs(OracleConnection conn, OracleFailoverType fo_type, OracleFailoverEvent fo_event);
    public OracleFailoverType get_FailoverType();
    public OracleFailoverEvent get_FailoverEvent();
}
public class Oracle.ManagedDataAccess.Client.OracleFailoverEventHandler : MulticastDelegate {
    public OracleFailoverEventHandler(object object, IntPtr method);
    public virtual OracleFailoverReturnCode Invoke(object sender, OracleFailoverEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, OracleFailoverEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual OracleFailoverReturnCode EndInvoke(IAsyncResult result);
}
internal enum Oracle.ManagedDataAccess.Client.OracleFailoverMethod : Enum {
    public int value__;
    public static OracleFailoverMethod Basic;
    public static OracleFailoverMethod PreConnect;
}
public enum Oracle.ManagedDataAccess.Client.OracleFailoverRestore : Enum {
    public int value__;
    public static OracleFailoverRestore NONE;
    public static OracleFailoverRestore LEVEL1;
}
internal enum Oracle.ManagedDataAccess.Client.OracleFailoverRestoreInternal : Enum {
    public int value__;
    public static OracleFailoverRestoreInternal NONE;
    public static OracleFailoverRestoreInternal LEVEL1;
    public static OracleFailoverRestoreInternal AUTO;
    public static OracleFailoverRestoreInternal LEVEL2;
}
public enum Oracle.ManagedDataAccess.Client.OracleFailoverReturnCode : Enum {
    public int value__;
    public static OracleFailoverReturnCode Retry;
    public static OracleFailoverReturnCode Success;
}
public enum Oracle.ManagedDataAccess.Client.OracleFailoverType : Enum {
    public int value__;
    public static OracleFailoverType None;
    public static OracleFailoverType Session;
}
internal enum Oracle.ManagedDataAccess.Client.OracleFailoverTypeInternal : Enum {
    public int value__;
    public static OracleFailoverTypeInternal None;
    public static OracleFailoverTypeInternal Session;
    public static OracleFailoverTypeInternal Select;
    public static OracleFailoverTypeInternal Transactional;
    public static OracleFailoverTypeInternal Auto;
}
public class Oracle.ManagedDataAccess.Client.OracleGlobalization : object {
    private bool m_disposed;
    internal OracleGlobalizationImpl m_oracleGlobalizationImpl;
    public string Calendar { get; public set; }
    public string Comparison { get; public set; }
    public string Currency { get; public set; }
    public string DateFormat { get; public set; }
    public string DateLanguage { get; public set; }
    public string DualCurrency { get; public set; }
    public string ISOCurrency { get; public set; }
    public string Language { get; public set; }
    public string LengthSemantics { get; public set; }
    public bool NCharConversionException { get; public set; }
    public string NumericCharacters { get; public set; }
    public string Sort { get; public set; }
    public string Territory { get; public set; }
    public string TimeStampFormat { get; public set; }
    public string TimeStampTZFormat { get; public set; }
    public string TimeZone { get; public set; }
    internal string TimeFormat { get; internal set; }
    internal string TimeTZFormat { get; internal set; }
    internal OracleGlobalization(OracleGlobalizationImpl oracleGlobImpl);
    public string get_Calendar();
    public void set_Calendar(string value);
    public string get_Comparison();
    public void set_Comparison(string value);
    public string get_Currency();
    public void set_Currency(string value);
    public string get_DateFormat();
    public void set_DateFormat(string value);
    public string get_DateLanguage();
    public void set_DateLanguage(string value);
    public string get_DualCurrency();
    public void set_DualCurrency(string value);
    public string get_ISOCurrency();
    public void set_ISOCurrency(string value);
    public string get_Language();
    public void set_Language(string value);
    public string get_LengthSemantics();
    public void set_LengthSemantics(string value);
    public bool get_NCharConversionException();
    public void set_NCharConversionException(bool value);
    public string get_NumericCharacters();
    public void set_NumericCharacters(string value);
    public string get_Sort();
    public void set_Sort(string value);
    public string get_Territory();
    public void set_Territory(string value);
    public string get_TimeStampFormat();
    public void set_TimeStampFormat(string value);
    public string get_TimeStampTZFormat();
    public void set_TimeStampTZFormat(string value);
    public string get_TimeZone();
    public void set_TimeZone(string value);
    internal string get_TimeFormat();
    internal void set_TimeFormat(string value);
    internal string get_TimeTZFormat();
    internal void set_TimeTZFormat(string value);
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
}
public class Oracle.ManagedDataAccess.Client.OracleHAEventArgs : EventArgs {
    private OracleHAEventSource m_source;
    private OracleHAEventStatus m_status;
    private string m_service;
    private string m_database;
    private string m_databaseDomain;
    private string m_host;
    private string m_instance;
    private string m_reason;
    private DateTime m_time;
    private int m_drain_timeout;
    internal bool m_bFireHADotNetEvent;
    public OracleHAEventSource Source { get; }
    public OracleHAEventStatus Status { get; }
    public string ServiceName { get; }
    public string DatabaseName { get; }
    public string DatabaseDomainName { get; }
    public string HostName { get; }
    public string InstanceName { get; }
    public string Reason { get; }
    public DateTime Time { get; }
    public int DrainTimeout { get; }
    internal OracleHAEventArgs(OracleHAEventSource source, OracleHAEventStatus status, string service, string database, string databaseDomain, string instance, string host, string reason, DateTime time, int drain_timeout);
    public OracleHAEventSource get_Source();
    public OracleHAEventStatus get_Status();
    public string get_ServiceName();
    public string get_DatabaseName();
    public string get_DatabaseDomainName();
    public string get_HostName();
    public string get_InstanceName();
    public string get_Reason();
    public DateTime get_Time();
    public int get_DrainTimeout();
}
public class Oracle.ManagedDataAccess.Client.OracleHAEventHandler : MulticastDelegate {
    public OracleHAEventHandler(object object, IntPtr method);
    public virtual void Invoke(OracleHAEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(OracleHAEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Oracle.ManagedDataAccess.Client.OracleHAEventSource : Enum {
    public int value__;
    public static OracleHAEventSource Instance;
    public static OracleHAEventSource Database;
    public static OracleHAEventSource Node;
    public static OracleHAEventSource Service;
    public static OracleHAEventSource ServiceMember;
}
public enum Oracle.ManagedDataAccess.Client.OracleHAEventStatus : Enum {
    public int value__;
    public static OracleHAEventStatus Down;
    public static OracleHAEventStatus Up;
}
public enum Oracle.ManagedDataAccess.Client.OracleIdentityType : Enum {
    public int value__;
    public static OracleIdentityType GeneratedAlways;
    public static OracleIdentityType GeneratedByDefaultOnNull;
    public static OracleIdentityType GeneratedByDefault;
}
public class Oracle.ManagedDataAccess.Client.OracleInfoMessageEventArgs : EventArgs {
    private OracleErrorCollection m_oraErrors;
    private string m_message;
    private string m_source;
    public OracleErrorCollection Errors { get; }
    public string Message { get; }
    public string Source { get; }
    internal OracleInfoMessageEventArgs(OracleErrorCollection oraErrors, object traceObj);
    public OracleErrorCollection get_Errors();
    public string get_Message();
    public string get_Source();
    public virtual string ToString();
}
public class Oracle.ManagedDataAccess.Client.OracleInfoMessageEventHandler : MulticastDelegate {
    public OracleInfoMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OracleInfoMessageEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, OracleInfoMessageEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Oracle.ManagedDataAccess.Client.OracleLogicalTransaction : object {
    internal OracleConnection m_connection;
    internal Nullable`1<bool> bDistributed;
    internal OracleConnection m_connforTxnStatus;
    internal Byte[] m_ltxId;
    private string m_conString;
    private Nullable`1<bool> m_bCommitted;
    private Nullable`1<bool> m_bUserCallCompleted;
    private bool m_disposed;
    public Nullable`1<bool> Committed { get; }
    public Nullable`1<bool> UserCallCompleted { get; }
    public string ConnectionString { get; }
    public Byte[] LogicalTransactionId { get; }
    internal OracleLogicalTransaction(OracleConnection connection, Byte[] ltxId);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public static void GetOutcome(string constring, Byte[] ltxid, Nullable`1& bCommitted, Nullable`1& bUserCallCompleted);
    internal void GetOutcome(OracleConnection con);
    internal void GetOutcome();
    public Nullable`1<bool> get_Committed();
    public Nullable`1<bool> get_UserCallCompleted();
    public string get_ConnectionString();
    public Byte[] get_LogicalTransactionId();
}
internal class Oracle.ManagedDataAccess.Client.OracleMetricsCollection : object {
    private static Meter Meter;
    private static OracleMetricsInstrument[] m_countersList;
    private static IDictionary`2<string, long> numberOfActiveConnectionPools;
    private static IDictionary`2<string, long> numberOfInactiveConnectionPools;
    private static IDictionary`2<string, long> numberOfActiveConnectionPoolGroups;
    private static IDictionary`2<string, long> numberOfInactiveConnectionPoolGroups;
    private static IDictionary`2<string, long> numberOfActiveConnections;
    private static IDictionary`2<string, long> numberOfFreeConnections;
    private static IDictionary`2<string, long> numberOfPooledConnections;
    private static IDictionary`2<string, long> numberOfNonPooledConnections;
    private static IDictionary`2<string, long> numberOfActiveHardConnections;
    private static IDictionary`2<string, long> numberOfActiveSoftConnections;
    private static OracleMetricsCollection();
    internal static bool IsCounterEnabled(CounterIndex iCounter);
    internal static void Increment(CounterIndex iCounter, string poolName, string dbInstanceName);
    internal static void Decrement(CounterIndex iCounter, string poolName, string dbInstanceName);
    private static String[] CreateCounterLevel(CounterIndex iCount, string pfcInstanceName);
    private static String[] CreateLevelNames(string pfcInstanceName);
    private static void InitializeCounters();
    internal static IDictionary`2<string, long> GetNumActiveConnectionPools();
    internal static IDictionary`2<string, long> GetNumInActiveConnectionPools();
    internal static IDictionary`2<string, long> GetNumActiveConnectionPoolsGroups();
    internal static IDictionary`2<string, long> GetNumInactiveConnectionPoolsGroups();
    internal static IDictionary`2<string, long> GetNumberOfActiveConnections();
    internal static IDictionary`2<string, long> GetNumberOfFreeConnections();
    internal static IDictionary`2<string, long> GetNumberOfPooledConnections();
    internal static IDictionary`2<string, long> GetNumberOfNonPooledConnections();
    internal static IDictionary`2<string, long> GetNumberOfActiveHardConnections();
    internal static IDictionary`2<string, long> GetNumberOfActiveSoftConnections();
}
internal class Oracle.ManagedDataAccess.Client.OracleMetricsInstrument : object {
    private ObservableInstrument`1<long> m_instrument;
    private Dictionary`2<string, CounterData> counterLevels;
    private object lockObject;
    private Func`1<IDictionary`2<string, long>> m_valuesProvider;
    public bool Enabled { get; }
    public OracleMetricsInstrument(string name, Meter meter, CounterType counterType, string description, Func`1<IDictionary`2<string, long>> valuesProvider);
    public bool get_Enabled();
    public void AddCounterLevel(string levelName);
    public bool DoesLevelExists(string levelName);
    public void Increment(String[] levels);
    public void IncrementBy(string level, int value);
    public void Decrement(String[] levels);
    private IEnumerable`1<Measurement`1<long>> GetMeasurements();
}
public class Oracle.ManagedDataAccess.Client.OracleNotificationEventArgs : EventArgs {
    internal NotificationDetails m_notificationDetails;
    internal AQNotificationDetails m_aqNotificationDetails;
    internal bool m_bInfoNotPopulated;
    public OracleNotificationInfo Info { get; }
    public OracleNotificationSource Source { get; }
    public OracleNotificationType Type { get; }
    public String[] ResourceNames { get; }
    public DataTable Details { get; }
    internal List`1<long> QueryIdList { get; }
    internal OracleNotificationEventArgs(NotificationDetails notifDetails);
    internal OracleNotificationEventArgs(AQNotificationDetails notifDetails);
    public OracleNotificationInfo get_Info();
    public OracleNotificationSource get_Source();
    public OracleNotificationType get_Type();
    public String[] get_ResourceNames();
    public DataTable get_Details();
    internal OracleNotificationEventArgs Clone();
    internal List`1<long> get_QueryIdList();
}
public enum Oracle.ManagedDataAccess.Client.OracleNotificationInfo : Enum {
    public int value__;
    public static OracleNotificationInfo Insert;
    public static OracleNotificationInfo Delete;
    public static OracleNotificationInfo Update;
    public static OracleNotificationInfo Startup;
    public static OracleNotificationInfo Shutdown;
    public static OracleNotificationInfo Shutdown_any;
    public static OracleNotificationInfo Alter;
    public static OracleNotificationInfo Drop;
    public static OracleNotificationInfo End;
    public static OracleNotificationInfo Error;
}
public class Oracle.ManagedDataAccess.Client.OracleNotificationRequest : object {
    internal static Hashtable s_idTable;
    internal static bool s_bDefIsNotifiedOnce;
    internal static int s_DefRegTimeout;
    internal static bool s_bDefIsPersistent;
    internal static string s_ChangedNotificationName;
    internal long m_id;
    internal string m_service;
    internal bool m_bIsNotifiedOnce;
    internal bool m_bIsPersistent;
    internal long m_timeout;
    internal bool m_bGroupingNotificationEnabled;
    internal OracleAQNotificationGroupingType m_groupingType;
    internal int m_groupingInterval;
    internal long Id { get; }
    public bool IsNotifiedOnce { get; public set; }
    public bool IsPersistent { get; public set; }
    private string Service { get; }
    public bool GroupingNotificationEnabled { get; public set; }
    public OracleAQNotificationGroupingType GroupingType { get; public set; }
    public int GroupingInterval { get; public set; }
    public long Timeout { get; public set; }
    internal OracleNotificationRequest(string service, OracleDependencyImpl orclDependencyImpl);
    internal OracleNotificationRequest(bool isNotifiedOnce, long timeout, bool isPersistent, bool groupingNotificationEnabled, OracleAQNotificationGroupingType groupingType, int groupingInterval);
    private static OracleNotificationRequest();
    internal long get_Id();
    public bool get_IsNotifiedOnce();
    public void set_IsNotifiedOnce(bool value);
    public bool get_IsPersistent();
    public void set_IsPersistent(bool value);
    private string get_Service();
    public bool get_GroupingNotificationEnabled();
    public void set_GroupingNotificationEnabled(bool value);
    public OracleAQNotificationGroupingType get_GroupingType();
    public void set_GroupingType(OracleAQNotificationGroupingType value);
    public int get_GroupingInterval();
    public void set_GroupingInterval(int value);
    public long get_Timeout();
    public void set_Timeout(long value);
}
public enum Oracle.ManagedDataAccess.Client.OracleNotificationSource : Enum {
    public int value__;
    public static OracleNotificationSource Data;
    public static OracleNotificationSource Database;
    public static OracleNotificationSource Object;
    public static OracleNotificationSource Subscription;
}
public enum Oracle.ManagedDataAccess.Client.OracleNotificationType : Enum {
    public int value__;
    public static OracleNotificationType Change;
    public static OracleNotificationType Subscribe;
    public static OracleNotificationType Query;
}
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Client.OracleOnsServerCollection : object {
    private static object s_syncObj;
    internal static Hashtable s_userCopyOfEntries;
    public int Count { get; }
    public string Item { get; public set; }
    private static OracleOnsServerCollection();
    public void Add(string serverName, string attributes);
    public void Remove(string serverName);
    public int get_Count();
    public string get_Item(string serverName);
    public void set_Item(string serverName, string value);
    private void AddServer(string serverName, string attributes);
}
[TypeConverterAttribute("Oracle.ManagedDataAccess.Client.OracleParameterTypeConverter")]
public class Oracle.ManagedDataAccess.Client.OracleParameter : DbParameter {
    internal string m_paramName;
    private string m_sourceColumn;
    private DbType m_dbType;
    private bool m_nullable;
    private object m_value;
    internal PrmEnumType m_enumType;
    private int m_offset;
    internal ParameterDirection m_direction;
    internal int m_bindElemCnt;
    internal int m_maxNoOfArrayElements;
    internal OracleDbType m_oraDbType;
    internal OraType m_oraType;
    internal int m_maxSize;
    internal bool m_modified;
    private DataRowVersion m_sourceVersion;
    private bool m_bSetDbType;
    internal int m_characterSetId;
    internal byte m_charSetForm;
    internal OracleCollectionType m_collType;
    internal bool m_disposed;
    internal int m_maxBytesToBeWrittenOrRead;
    internal int m_maxCharsToBeWrittenOrRead;
    internal bool m_bArrayBind;
    internal bool m_bDuplicateBind;
    private Int32[] m_maxArrayBindSize;
    private Boolean[] m_nullIndicatorsForArrayBind;
    private bool m_IsValueNull;
    internal OracleParameterCollection m_collRef;
    internal OracleParameterImpl m_paramImpl;
    internal string m_paramPosOrName;
    internal bool m_bOracleDbTypeExSet;
    internal bool m_bReturnDateTimeOffset;
    internal string m_udtTypeName;
    internal UDTNamedType m_udtTypeMetaData;
    private bool m_sourceColumnNullMapping;
    internal object m_originalInputValue;
    internal bool m_bByteSemantics;
    private static int MaxOraDbType;
    private static int MinOraDbType;
    private static int DataThresholdSizeForCLOB;
    private static int DataThresholdSizeForBLOB;
    internal static byte MaxScale;
    internal static sbyte MinScale;
    internal static int InvalidSize;
    unknown bool DuplicateBind {internal set; }
    [DefaultValueAttribute("False")]
public bool SkipConversionToLocalTime { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public Int32[] ArrayBindSize { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("")]
public OracleParameterStatus[] ArrayBindStatus { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[BrowsableAttribute("False")]
public OracleCollectionType CollectionType { get; public set; }
    [DesignerSerializationVisibilityAttribute("1")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public DbType DbType { get; public set; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("")]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public ParameterDirection Direction { get; public set; }
    [DescriptionAttribute("")]
[DefaultValueAttribute("False")]
[CategoryAttribute("Data")]
public bool IsNullable { get; public set; }
    [BrowsableAttribute("False")]
[DefaultValueAttribute("0")]
public int Offset { get; public set; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("")]
public OracleDbType OracleDbType { get; public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[BrowsableAttribute("False")]
[DesignerSerializationVisibilityAttribute("0")]
[DbProviderSpecificTypePropertyAttribute("True")]
public OracleDbType OracleDbTypeEx { get; public set; }
    [DefaultValueAttribute("")]
public string ParameterName { get; public set; }
    [DefaultValueAttribute("0")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public byte Precision { get; public set; }
    [DefaultValueAttribute("0")]
[DescriptionAttribute("")]
[CategoryAttribute("Data")]
public byte Scale { get; public set; }
    unknown int MaxCharsToBeWrittenOrRead {private set; }
    unknown int MaxBytesToBeWrittenOrRead {private set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("0")]
public int Size { get; public set; }
    [DescriptionAttribute("")]
[CategoryAttribute("Data")]
[DefaultValueAttribute("")]
public string SourceColumn { get; public set; }
    [DefaultValueAttribute("False")]
public bool SourceColumnNullMapping { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public DataRowVersion SourceVersion { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
[BrowsableAttribute("False")]
public OracleParameterStatus Status { get; public set; }
    [CategoryAttribute("Data")]
[DescriptionAttribute("")]
[DefaultValueAttribute("")]
public string UdtTypeName { get; public set; }
    [DefaultValueAttribute("")]
[CategoryAttribute("Data")]
[DescriptionAttribute("")]
public object Value { get; public set; }
    public OracleParameter(string parameterName, OracleDbType oraType);
    public OracleParameter(string parameterName, object obj);
    public OracleParameter(string parameterName, OracleDbType type, ParameterDirection direction);
    public OracleParameter(string parameterName, OracleDbType type, int size);
    public OracleParameter(string parameterName, OracleDbType type, int size, string srcColumn);
    public OracleParameter(string parameterName, OracleDbType type, object obj, ParameterDirection direction);
    internal OracleParameter(string parameterName, OracleDbType type, int size, string srcColumn, DataRowVersion version, object obj);
    public OracleParameter(string parameterName, OracleDbType type, int size, object obj, ParameterDirection direction);
    public OracleParameter(string parameterName, OracleDbType oraType, int size, ParameterDirection direction, bool isNullable, byte precision, byte scale, string srcColumn, DataRowVersion srcVersion, object obj);
    internal OracleParameter(DbType type, ParameterDirection direction, bool isNullable, int offSet, OracleDbType oraDbType, string paramName, byte precision, byte scale, int size, string srcColumn, DataRowVersion srcVersion, OracleParameterStatus paramStatus, object obj, bool bSetDbType, PrmEnumType enumType, bool modified, string udtTypeName);
    internal OracleParameter DeepCloneForReplay();
    internal void set_DuplicateBind(bool value);
    public bool get_SkipConversionToLocalTime();
    public void set_SkipConversionToLocalTime(bool value);
    public Int32[] get_ArrayBindSize();
    public void set_ArrayBindSize(Int32[] value);
    public OracleParameterStatus[] get_ArrayBindStatus();
    public void set_ArrayBindStatus(OracleParameterStatus[] value);
    public OracleCollectionType get_CollectionType();
    public void set_CollectionType(OracleCollectionType value);
    public virtual DbType get_DbType();
    public virtual void set_DbType(DbType value);
    public virtual ParameterDirection get_Direction();
    public virtual void set_Direction(ParameterDirection value);
    public virtual bool get_IsNullable();
    public virtual void set_IsNullable(bool value);
    public int get_Offset();
    public void set_Offset(int value);
    public OracleDbType get_OracleDbType();
    public void set_OracleDbType(OracleDbType value);
    public OracleDbType get_OracleDbTypeEx();
    public void set_OracleDbTypeEx(OracleDbType value);
    public virtual string get_ParameterName();
    public virtual void set_ParameterName(string value);
    public byte get_Precision();
    public void set_Precision(byte value);
    public byte get_Scale();
    public void set_Scale(byte value);
    private void set_MaxCharsToBeWrittenOrRead(int value);
    private void set_MaxBytesToBeWrittenOrRead(int value);
    private bool ShouldSerializeDbType();
    private bool ShouldSerializeOracleDbType();
    public virtual int get_Size();
    public virtual void set_Size(int value);
    public virtual string get_SourceColumn();
    public virtual void set_SourceColumn(string value);
    public virtual bool get_SourceColumnNullMapping();
    public virtual void set_SourceColumnNullMapping(bool value);
    public virtual DataRowVersion get_SourceVersion();
    public virtual void set_SourceVersion(DataRowVersion value);
    public OracleParameterStatus get_Status();
    public void set_Status(OracleParameterStatus value);
    public string get_UdtTypeName();
    public void set_UdtTypeName(string value);
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    public virtual void ResetDbType();
    public void ResetOracleDbType();
    public virtual string ToString();
    private int GetBindingSize_Char(int idx);
    private int GetBindingSize_Raw(int idx);
    private int GetBindingSize(int bufferLength, int idx);
    internal void SetSize(int size);
    internal static bool IsElemType(Type type, object value, int index);
    internal void PreBindFree();
    internal void PreBind(OracleConnectionImpl connImpl, ColumnDescribeInfo cachedParamMetadata, Boolean& bMetadataModified, int arrayBindCount, ColumnDescribeInfo& paramMetaData, Object& paramValue, bool isEFSelectStatement, SqlStatementType stmtType);
    private bool IsProviderSpecificNullValue(object value);
    internal void SetNullIndicators();
    internal bool IsBindNullValue();
    internal bool IsArrayBindNullValue(int index);
    internal void SetArrayContext(int arrayBindCount);
    private void PreBind_Char(OracleConnectionImpl connImpl, SqlStatementType stmtType);
    private void PreBind_BDouble();
    private void PreBind_BFloat();
    private void PreBind_Int32();
    private void PreBind_Int64();
    private void PreBind_Double();
    private void PreBind_Single();
    private void PreBind_Decimal();
    private void PreBind_Date();
    private void PreBind_TimeStamp();
    private void PreBind_TimeStampLTZ(OracleConnectionImpl connImpl);
    private void PreBind_TimeStampTZ(OracleConnectionImpl connImpl);
    private void PreBind_IntervalDS();
    private void PreBind_IntervalYM();
    private void PreBind_Raw();
    private void PreBind_Clob(OracleConnectionImpl connImpl, bool isEFSelectStatement, SqlStatementType stmtType);
    private void PreBind_BFile(OracleConnectionImpl connImpl);
    private void PreBind_Blob(OracleConnectionImpl connImpl, bool isEFSelectStatement);
    private void PreBind_Json(OracleConnectionImpl connImpl);
    private void PreBind_Vector(OracleConnectionImpl connImpl);
    private UDTNamedType GetUDTType(OracleConnection conn);
    private void PreBind_UDT(OracleConnection conn);
    internal void PostBind_UDT(OracleConnection connection, Accessor bindAccessor);
    internal void PostBind_UDTAsJson(OracleConnection connection, Accessor bindAccessor);
    private void PreBind_Ref(OracleConnection conn);
    internal void PostBind_Ref(OracleConnection conn, Accessor bindAccessor);
    private void PreBind_XmlType(OracleConnectionImpl connImpl);
    private void PreBind_Cursor(OracleConnectionImpl connImpl);
    private void PreBind_Boolean();
    internal void PostBind_Boolean(Accessor bindAccessor);
    internal void PostBind_Char(OracleConnectionImpl connImpl, Accessor bindAccessor, Char[] charArrayFromPooler);
    internal void PostBind_RefCursor(OracleConnection connection, Accessor bindAccessor, long fetchSize, OracleIntervalDS sessionTimeZone, string commandText, string paramPosOrName, long longFetchSize, long clientInitialLOBFS, long internalInitialLOBFS, long internalInitialJSONFS, Int64[] scnFromExecution, bool bIsFromEF, bool bCallFromExecuteReader);
    internal void PostBind_Lob(OracleConnection connection, Accessor bindAccessor);
    internal void PostBind_Json(OracleConnection connection, Accessor bindAccessor);
    internal void PostBind_Vector(OracleConnection connection, Accessor bindAccessor);
    internal void PostBind_TimeStamp(Accessor bindAccessor);
    internal void PostBind_TimeStampLTZ(OracleConnectionImpl connImpl, Accessor bindAccessor);
    internal void PostBind_TimeStampTZ(OracleConnectionImpl connImpl, Accessor bindAccessor);
    internal void PostBind_Raw(Accessor bindAccessor);
    internal void PostBind_Int32(Accessor bindAccessor);
    internal void PostBind_Int64(object bindAccessor);
    internal void PostBind_Decimal(Accessor bindAccessor, bool bSuppressGetDecimalInvalidCastException);
    internal void PostBind_Single(Accessor bindAccessor);
    internal void PostBind_BinaryFloat(Accessor bindAccessor);
    internal void PostBind_BinaryDouble(Accessor bindAccessor);
    internal void PostBind_Double(Accessor bindAccessor);
    internal void PostBind_Date(Accessor bindAccessor);
    internal void PostBind_IntervalDS(Accessor bindAccessor);
    internal void PostBind_IntervalYM(Accessor bindAccessor);
    internal void PostBind_XmlType(OracleConnection connection, Accessor bindAccessor);
}
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Client.OracleParameterCollection : DbParameterCollection {
    internal ArrayList m_array;
    private Hashtable m_htCaseSensitiveColl;
    private Hashtable m_htNameToParamColl;
    private ArrayList m_reAddParamNameList;
    internal bool m_isParamListUpdated;
    internal bool m_isHashTablePopulated;
    public OracleParameter Item { get; public set; }
    public OracleParameter Item { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal OracleParameterCollection(ArrayList array);
    public OracleParameter get_Item(string name);
    public void set_Item(string name, OracleParameter value);
    public OracleParameter get_Item(int index);
    public void set_Item(int index, OracleParameter value);
    public virtual bool Contains(string parameterName);
    public virtual int IndexOf(string parameterName);
    public virtual void RemoveAt(string parameterName);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual int Add(object obj);
    public OracleParameter Add(OracleParameter param);
    public OracleParameter Add(string name, object val);
    public OracleParameter Add(string name, OracleDbType dbType);
    public OracleParameter Add(string name, OracleDbType dbType, ParameterDirection direction);
    public OracleParameter Add(string name, OracleDbType dbType, object val, ParameterDirection dir);
    public OracleParameter Add(string name, OracleDbType dbType, int size, object val, ParameterDirection dir);
    public OracleParameter Add(string name, OracleDbType dbType, int size);
    public OracleParameter Add(string name, OracleDbType dbType, int size, string srcColumn);
    public OracleParameter Add(string name, OracleDbType dbType, int size, ParameterDirection dir, bool isNullable, byte precision, byte scale, string srcColumn, DataRowVersion version, object val);
    public virtual void Clear();
    public virtual bool Contains(object item);
    public virtual int IndexOf(object obj);
    public virtual void Insert(int index, object obj);
    public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void CopyTo(Array array, int index);
    public virtual IEnumerator GetEnumerator();
    public virtual void AddRange(Array paramArray);
    protected virtual DbParameter GetParameter(int index);
    protected virtual DbParameter GetParameter(string parameterName);
    protected virtual void SetParameter(int index, DbParameter value);
    protected virtual void SetParameter(string parameterName, DbParameter value);
    internal void AddNoCheck(OracleParameter prm);
    internal void OnChangeOfList(string paramName, string rename);
    internal void PopulateHashtable();
    internal void UpdateHashTableOnChange();
    private int FindParamByName(string name);
    internal int FindLastParamByName(string name);
}
public enum Oracle.ManagedDataAccess.Client.OracleParameterStatus : Enum {
    public int value__;
    public static OracleParameterStatus Success;
    public static OracleParameterStatus NullFetched;
    public static OracleParameterStatus NullInsert;
    public static OracleParameterStatus Truncation;
}
public class Oracle.ManagedDataAccess.Client.OracleParameterTypeConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum Oracle.ManagedDataAccess.Client.OraclePasswordAuth : Enum {
    public int value__;
    public static OraclePasswordAuth PasswordVerifier;
    public static OraclePasswordAuth OciToken;
    public static OraclePasswordAuth AzureToken;
}
internal class Oracle.ManagedDataAccess.Client.OraclePerfCounter : object {
    private bool m_isDisposed;
    public PerformanceCounter m_counter;
    public OraclePerfCounter m_higherLevelCounter;
    internal OraclePerfCounter(string counterName, string perfCounterInstanceName);
    internal OraclePerfCounter(string counterName);
    public long IncrementBy(int value);
    public long Increment();
    public long Decrement();
    public void Dispose();
}
internal static class Oracle.ManagedDataAccess.Client.OraclePerfCounterCollection : object {
    private static Dictionary`2[] m_countersList;
    private static String[] m_counterNames;
    private static object syncLock;
    private static OraclePerfCounterCollection();
    public static void Initialize();
    internal static OraclePerfCounter Increment(CounterIndex iCounter, string poolName, string dbInstanceName);
    private static string CreateInstanceName(string appDomain, string poolName, string dbInstanceName);
    private static string ConstructFieldName(string fieldName, int lengthLimit);
    internal static OraclePerfCounter IncrementBy(CounterIndex iCounter, int value, string poolName, string dbInstanceName);
    internal static OraclePerfCounter Decrement(CounterIndex iCounter, string poolName, string dbInstanceName);
    private static OraclePerfCounter CreatePerformanceCounters(CounterIndex iCount, string pfcInstanceName);
    private static void Dispose();
    private static void HookToDomainUnloadOrProcessExitEvent();
    private static void DomainUnloadOrProcessExit(object sender, EventArgs e);
    private static void InitializePerformanceCounters();
}
internal class Oracle.ManagedDataAccess.Client.OraclePerfCounterConfiguration : object {
    private static bool CreateCounters(String[] args);
    private static bool DeleteCounters(String[] args);
    private static void CreateCounterDataList(CounterCreationDataCollection& list);
}
internal static class Oracle.ManagedDataAccess.Client.OraclePerfParams : object {
    internal static byte MAX_COUNTERS;
    internal static string HARD_CONNECTS_PER_SECOND;
    internal static string HARD_DISCONNECTS_PER_SECOND;
    internal static string SOFT_CONNECTS_PER_SECOND;
    internal static string SOFT_DISCONNECTS_PER_SECOND;
    internal static string NUMBER_OF_ACTIVE_CONNECTION_POOLS;
    internal static string NUMBER_OF_INACTIVE_CONNECTION_POOLS;
    internal static string NUMBER_OF_ACTIVE_CONNECTIONS;
    internal static string NUMBER_OF_FREE_CONNECTIONS;
    internal static string NUMBER_OF_POOLED_CONNECTIONS;
    internal static string NUMBER_OF_NON_POOLED_CONNECTIONS;
    internal static string NUMBER_OF_RECLAIMED_CONNECTIONS;
    internal static string NUMBER_OF_STASIS_CONNECTIONS;
    internal static string METER_SOURCE_NAME;
    internal static string METRICS_PREFIX;
    internal static string METRICS_HARD_CONNECTS;
    internal static string METRICS_HARD_DISCONNECTS;
    internal static string METRICS_SOFT_CONNECTS;
    internal static string METRICS_SOFT_DISCONNECTS;
    internal static string METRICS_NUMBER_OF_ACTIVE_CONNECTION_POOLS;
    internal static string METRICS_NUMBER_OF_INACTIVE_CONNECTION_POOLS;
    internal static string METRICS_NUMBER_OF_ACTIVE_CONNECTIONS;
    internal static string METRICS_NUMBER_OF_FREE_CONNECTIONS;
    internal static string METRICS_NUMBER_OF_POOLED_CONNECTIONS;
    internal static string METRICS_NUMBER_OF_NON_POOLED_CONNECTIONS;
    internal static string METRICS_NUMBER_OF_RECLAIMED_CONNECTIONS;
    internal static string METRICS_NUMBER_OF_ACTIVE_HARD_CONNECTIONS;
    internal static string METRICS_NUMBER_OF_ACTIVE_SOFT_CONNECTIONS;
    internal static string METRICS_NUMBER_OF_ACTIVE_CONNECTION_POOL_GROUPS;
    internal static string METRICS_NUMBER_OF_INACTIVE_CONNECTION_POOL_GROUPS;
    internal static int LENGTH_OF_APPDOMAIN_NAME;
    internal static int LENGTH_OF_POOL_NAME;
    internal static int LENGTH_OF_INSTANCE_NAME;
    internal static string CATEGORY_NAME;
    internal static string m_appDomainPfcInstanceName;
    private static OraclePerfParams();
}
public class Oracle.ManagedDataAccess.Client.OraclePermission : DBDataPermission {
    internal static bool m_startTracing;
    private OraclePermission(OraclePermission permission);
    internal OraclePermission(OraclePermissionAttribute attrib);
    public OraclePermission(PermissionState state);
    public sealed virtual IPermission Copy();
    public virtual bool IsSubsetOf(IPermission target);
    internal void Clear();
    private string EliminatePasswordValue(string conString);
    public virtual void Add(string connStr, string keyRestrict, KeyRestrictionBehavior behavior);
}
[AttributeUsageAttribute("109")]
public class Oracle.ManagedDataAccess.Client.OraclePermissionAttribute : DBDataPermissionAttribute {
    public OraclePermissionAttribute(SecurityAction action);
    public virtual IPermission CreatePermission();
}
public class Oracle.ManagedDataAccess.Client.OraclePoolNameCollection : object {
    internal static object s_syncObj;
    private static OraclePoolNameCollection();
    public void Add(string poolName, string passwordLessConnectionString);
    public void Remove(string poolName);
}
internal class Oracle.ManagedDataAccess.Client.OracleRecoverableException : DbException {
    private OracleException m_actualEx;
    internal OracleRecoverableException(OracleException ex);
}
public class Oracle.ManagedDataAccess.Client.OracleRefreshAccessTokenEventArgs : EventArgs {
    internal OracleOpaqueString m_refreshedDbToken;
    internal OracleOpaqueString m_refreshedPrivateKey;
    internal OracleOpaqueString m_refreshedToken;
    private OracleAccessToken m_accessToken;
    unknown Char[] DbToken {public set; }
    unknown Char[] PrivateKey {public set; }
    unknown Char[] Token {public set; }
    internal OracleRefreshAccessTokenEventArgs(OracleAccessToken accessToken);
    public void set_DbToken(Char[] value);
    public void set_PrivateKey(Char[] value);
    public void set_Token(Char[] value);
}
public class Oracle.ManagedDataAccess.Client.OracleRefreshAccessTokenEventHandler : MulticastDelegate {
    public OracleRefreshAccessTokenEventHandler(object object, IntPtr method);
    public virtual void Invoke(OracleRefreshAccessTokenEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(OracleRefreshAccessTokenEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Oracle.ManagedDataAccess.Client.OracleRowidInfo : Enum {
    public int value__;
    public static OracleRowidInfo Default;
    public static OracleRowidInfo Include;
    public static OracleRowidInfo Exclude;
}
public class Oracle.ManagedDataAccess.Client.OracleRowsCopiedEventArgs : EventArgs {
    private bool m_abort;
    private long m_rowsCopied;
    public bool Abort { get; public set; }
    public long RowsCopied { get; }
    private static OracleRowsCopiedEventArgs();
    public OracleRowsCopiedEventArgs(long rowsCopied);
    public bool get_Abort();
    public void set_Abort(bool value);
    public long get_RowsCopied();
}
public class Oracle.ManagedDataAccess.Client.OracleRowsCopiedEventHandler : MulticastDelegate {
    public OracleRowsCopiedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OracleRowsCopiedEventArgs eventArgs);
    public virtual IAsyncResult BeginInvoke(object sender, OracleRowsCopiedEventArgs eventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Oracle.ManagedDataAccess.Client.OracleRowUpdatedEventArgs : RowUpdatedEventArgs {
    public OracleCommand Command { get; }
    public OracleRowUpdatedEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
    public OracleCommand get_Command();
}
public class Oracle.ManagedDataAccess.Client.OracleRowUpdatedEventHandler : MulticastDelegate {
    public OracleRowUpdatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OracleRowUpdatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OracleRowUpdatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Oracle.ManagedDataAccess.Client.OracleRowUpdatingEventArgs : RowUpdatingEventArgs {
    public OracleCommand Command { get; public set; }
    protected IDbCommand BaseCommand { get; protected set; }
    public OracleRowUpdatingEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
    public OracleCommand get_Command();
    public void set_Command(OracleCommand value);
    protected virtual IDbCommand get_BaseCommand();
    protected virtual void set_BaseCommand(IDbCommand value);
}
public class Oracle.ManagedDataAccess.Client.OracleRowUpdatingEventHandler : MulticastDelegate {
    public OracleRowUpdatingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OracleRowUpdatingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OracleRowUpdatingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Oracle.ManagedDataAccess.Client.OracleShardingKey : object {
    internal OracleShardingKeyImpl m_shardingKeyImpl;
    internal OracleShardingKeyImpl ShardingKeyInternal { get; internal set; }
    internal bool IsSuperShardingKey { get; internal set; }
    public OracleShardingKey(OracleDbType oracleDbType, object data);
    internal void Init();
    internal OracleShardingKeyImpl get_ShardingKeyInternal();
    internal void set_ShardingKeyInternal(OracleShardingKeyImpl value);
    internal bool get_IsSuperShardingKey();
    internal void set_IsSuperShardingKey(bool value);
    public void SetShardingKey(OracleDbType oracleDbType, object data);
    internal void Build();
    internal string EncodeKeyinB64Format();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Oracle.ManagedDataAccess.Client.OracleStringResourceManager : object {
    private static string RESOURCE_NAME_PREFIX;
    private static string RESOURCE_NAME_PREFIX_WITH_DOT;
    private static string RESOURCE_NAME_SUFFIX;
    private static string RESOURCE_NAME_SUFFIX_WITH_DOT;
    private static char DOT;
    private static string DFEAULT_RESOURCE_NAME;
    private static string DEFAULT_MESSAGE_NUMBER;
    private static Dictionary`2<string, ResourceSet> m_CultureToResourceStringMap;
    private static OracleStringResourceManager();
    internal static string GetString(string key, CultureInfo culture);
    private static string GetResourceStringForCultureName(string key, string cultureName);
    private static void ExtractEmbeddedResourceStringsForCultureName(string name);
    [IteratorStateMachineAttribute("Oracle.ManagedDataAccess.Client.OracleStringResourceManager/<NextMatchingNonInvariantCulture>d__12")]
[ExtensionAttribute]
private static IEnumerable`1<string> NextMatchingNonInvariantCulture(CultureInfo culture);
    internal static string GetErrorMesg(int errorcode, String[] args);
    internal static string GetErrorMesg(string component, int errorcode, String[] args);
    internal static string GetErrorMesgWithErrCode(int errorcode, String[] args);
}
public class Oracle.ManagedDataAccess.Client.OracleTAFMode : object {
    internal OracleFailoverType m_failoverType;
    internal OracleFailoverRestore m_failoverRestore;
    internal int m_failoverRetries;
    internal int m_failoverDelay;
    public OracleFailoverType FailoverType { get; }
    public OracleFailoverRestore FailoverRestore { get; }
    public int FailoverRetries { get; }
    public int FailoverDelay { get; }
    public OracleTAFMode(OracleFailoverType failoverType, OracleFailoverRestore failoverRestore);
    public OracleTAFMode(OracleFailoverType failoverType, OracleFailoverRestore failoverRestore, int failoverRetries, int failoverDelay);
    public OracleFailoverType get_FailoverType();
    public OracleFailoverRestore get_FailoverRestore();
    public int get_FailoverRetries();
    public int get_FailoverDelay();
}
public enum Oracle.ManagedDataAccess.Client.OracleTokenAuth : Enum {
    public int value__;
    public static OracleTokenAuth Disabled;
    public static OracleTokenAuth OciToken;
    public static OracleTokenAuth OAuth;
    public static OracleTokenAuth OciApiKey;
    public static OracleTokenAuth OciInstancePrincipal;
    public static OracleTokenAuth OciDelegationToken;
    public static OracleTokenAuth OciInteractive;
    public static OracleTokenAuth OciDefault;
    public static OracleTokenAuth OciResourcePrincipal;
    public static OracleTokenAuth AzureDefault;
    public static OracleTokenAuth AzureServicePrincipal;
    public static OracleTokenAuth AzureManagedIdentity;
    public static OracleTokenAuth AzureInteractive;
    public static OracleTokenAuth AzureDeviceCode;
}
public class Oracle.ManagedDataAccess.Client.OracleTransaction : DbTransaction {
    internal OracleTransaction m_proxy;
    internal OracleTransactionImpl m_oracleTransactionImpl;
    internal OracleConnection m_connection;
    internal bool m_completed;
    internal bool m_bClosed;
    private object m_traceObj;
    internal bool m_bCanRecordNewCall;
    internal object m_invokingInstanceWrapper;
    private IsolationLevel m_isolationLevel { get; private set; }
    public OracleConnection Connection { get; }
    public IsolationLevel IsolationLevel { get; }
    internal bool Completed { get; }
    protected DbConnection DbConnection { get; }
    internal OracleTransaction(OracleConnection con, IsolationLevel isolationLevel);
    private IsolationLevel get_m_isolationLevel();
    private void set_m_isolationLevel(IsolationLevel value);
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    public OracleConnection get_Connection();
    public virtual IsolationLevel get_IsolationLevel();
    internal bool get_Completed();
    protected virtual DbConnection get_DbConnection();
    public virtual void Commit();
    public virtual void Rollback();
    public void Rollback(string savepointName);
    public void Save(string savepointName);
    internal void ConnectionClose();
    public void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public enum Oracle.ManagedDataAccess.Client.OracleTxEventQNotificationDirective : Enum {
    public int value__;
    public static OracleTxEventQNotificationDirective Commit;
    public static OracleTxEventQNotificationDirective Rollback;
}
internal static class Oracle.ManagedDataAccess.Client.OracleTypeMapper : object {
    public static Hashtable m_OraToOraDb;
    public static Hashtable m_OraToNET;
    internal static string VARCHAR2;
    internal static string NVARCHAR2;
    internal static string NUMBER;
    internal static string LONG;
    internal static string DATE;
    internal static string RAW;
    internal static string LONG_RAW;
    internal static string ROWID;
    internal static string CHAR;
    internal static string NCHAR;
    internal static string BINARY_FLOAT;
    internal static string BINARY_DOUBLE;
    internal static string UDT;
    internal static string REF;
    internal static string CLOB;
    internal static string NCLOB;
    internal static string BLOB;
    internal static string BFILE;
    internal static string TIMESTAMP;
    internal static string TIMESTAMP_WITH_TIME_ZONE;
    internal static string INTERVAL_YEAR_TO_MONTH;
    internal static string INTERVAL_DAY_TO_SECOND;
    internal static string UROWID;
    internal static string TIMESTAMP_WITH_LOCAL_TIME_ZONE;
    internal static string XML;
    internal static int ORACLEDBTYPE_MINVAL;
    internal static int ORACLEDBTYPE_ENUM_COUNT;
    internal static String[] m_OraDbToOraNative;
    private static OracleTypeMapper();
}
public enum Oracle.ManagedDataAccess.Client.OracleUdtFetchOption : Enum {
    public int value__;
    public static OracleUdtFetchOption Cache;
    public static OracleUdtFetchOption TransactionCache;
    public static OracleUdtFetchOption Server;
}
public enum Oracle.ManagedDataAccess.Client.OracleUdtStatus : Enum {
    public int value__;
    public static OracleUdtStatus Null;
    public static OracleUdtStatus NotNull;
}
public enum Oracle.ManagedDataAccess.Client.OracleXmlCommandType : Enum {
    public int value__;
    public static OracleXmlCommandType None;
    public static OracleXmlCommandType Query;
    public static OracleXmlCommandType Insert;
    public static OracleXmlCommandType Update;
    public static OracleXmlCommandType Delete;
}
public class Oracle.ManagedDataAccess.Client.OracleXmlQueryProperties : object {
    private int m_maxRows;
    private string m_rootTag;
    private string m_rowTag;
    private string m_xslt;
    private string m_xsltParams;
    public int MaxRows { get; public set; }
    public string RootTag { get; public set; }
    public string RowTag { get; public set; }
    public string Xslt { get; public set; }
    public string XsltParams { get; public set; }
    public int get_MaxRows();
    public void set_MaxRows(int value);
    public string get_RootTag();
    public void set_RootTag(string value);
    public string get_RowTag();
    public void set_RowTag(string value);
    public string get_Xslt();
    public void set_Xslt(string value);
    public string get_XsltParams();
    public void set_XsltParams(string value);
    public sealed virtual object Clone();
}
public class Oracle.ManagedDataAccess.Client.OracleXmlSaveProperties : object {
    private String[] m_keyColumnsList;
    private string m_rowTag;
    private string m_table;
    private String[] m_updateColumnsList;
    private string m_xslt;
    private string m_xsltParams;
    public String[] KeyColumnsList { get; public set; }
    public string RowTag { get; public set; }
    public string Table { get; public set; }
    public String[] UpdateColumnsList { get; public set; }
    public string Xslt { get; public set; }
    public string XsltParams { get; public set; }
    public String[] get_KeyColumnsList();
    public void set_KeyColumnsList(String[] value);
    public string get_RowTag();
    public void set_RowTag(string value);
    public string get_Table();
    public void set_Table(string value);
    public String[] get_UpdateColumnsList();
    public void set_UpdateColumnsList(String[] value);
    public string get_Xslt();
    public void set_Xslt(string value);
    public string get_XsltParams();
    public void set_XsltParams(string value);
    public sealed virtual object Clone();
}
internal class Oracle.ManagedDataAccess.Client.OraDb_DbTypeTable : object {
    internal static Hashtable s_table;
    internal static Int32[] dbTypeToOracleDbTypeMapping;
    internal static Int32[] oraTypeToOracleDbTypeMapping;
    private static OraDb_DbTypeTable();
    internal static void InsertTableEntries();
    internal static OracleDbType ConvertNumberToOraDbType(int precision, int scale);
}
internal enum Oracle.ManagedDataAccess.Client.OraSqlCS : Enum {
    public byte value__;
    public static OraSqlCS SQLCS_IMPLICIT;
    public static OraSqlCS SQLCS_NCHAR;
    public static OraSqlCS SQLCS_EXPLICIT;
    public static OraSqlCS SQLCS_FLEXIBLE;
    public static OraSqlCS SQLCS_LIT_NULL;
}
internal enum Oracle.ManagedDataAccess.Client.PrmEnumType : Enum {
    public int value__;
    public static PrmEnumType NOTSET;
    public static PrmEnumType VALUE;
    public static PrmEnumType DBTYPE;
    public static PrmEnumType ORADBTYPE;
}
internal class Oracle.ManagedDataAccess.Client.RegAndConfigRdr : ConfigBaseClass {
    public static DataTable GetRefCursorInfoForSP(string configFileAlongWithFullPath, string schemaName, string storedProcName);
    internal virtual void setudtmapping(Hashtable& s_mapUdtNameToMappingObj);
}
internal class Oracle.ManagedDataAccess.Client.ResourceStringConstants : object {
    internal static int ORA_FIELD_NOT_FOUND;
    internal static int TYP_ERR_INVALID_PREC;
    internal static int TYP_ERR_INVALID_SCALE;
    internal static int TYP_ERR_TRUNCATE;
    internal static int TNS_LSNR_FAILED_TO_START;
    internal static int TNS_LSNR_RCVD_NO_CONN_DATA;
    internal static int TNS_LSNR_NO_SID_IN_CONN_DATA;
    internal static int TNS_LSNR_SID_NOT_KWN_IN_CONN_DESC;
    internal static int TNS_LSNR_CMND_NOT_RSVLD;
    internal static int TNS_LSNR_FAILED_TO_REDIRECT_CLNT_TO_SRVC;
    internal static int TNS_DB_LACKS_RESOURCES;
    internal static int TNS_SRVC_HANDLER_NOT_ACCEPTING_CONN;
    internal static int TNS_SRVC_HANDLER_REG_FOR_DIFF_PROT;
    internal static int TNS_LSNR_SERVICE_NOT_KWN_IN_CONN_DESC;
    internal static int TNS_LSNR_NO_HANDLER_FOR_PRES;
    internal static int TNS_LSNR_NO_FIND_AVLBL_HANDLER_PROT_STACK;
    internal static int TNS_LSNR_CANT_HAND_OFF_CLNT_CONN;
    internal static int TNS_NO_APP_SRVC_HANDLER_FND;
    internal static int TNS_LSNR_CLDNT_FIND_AVLBL_HANDLER_FOR_RQSTD_SRVR;
    internal static int TNS_LSNR_DSNT_KNOW_OF_INST_RQSTD_INC_CONN_DESC;
    internal static int TNS_LSNR_CLDNT_FIND_AVLBL_INST_GIVEN_INSTACNE_ROLE;
    internal static int TNS_LSNR_CLDNT_FND_INST_APP_FOR_CLNT_CONN;
    internal static int TNS_LSNR_CLDNT_RESOLVE_HANDLER_NAME;
    internal static int TNS_LSNR_NOT_RCVD_CLNT_RQST_IN_ALLOWED_TIME;
    internal static int TNS_LSNR_ALL_INSTNCS_IN_RESTRCTED_MODE;
    internal static int TNS_LSNR_ALL_INSTNCS_IN_RESTRCTED_MODE_OR_BLCKNG_CONNS;
    internal static int TNS_LSNR_ALL_INSTNCS_BLCKNG_CONNS;
    internal static int TNS_CONN_RQST_REJCTD_FILTERING_ISSUES;
    internal static int ORA_INVALID_USER_ID_ERR;
    internal static int ORA_INVALID_PASSW_ERR;
    internal static int ORA_CANNOT_INSERT_NULL_ERR;
    internal static int ORA_AUTH_PROTOCOL_ERROR;
    internal static int ORA_EXECUTION_CANCELLED;
    internal static int INSUFFICIENT_PRIVILEGES;
    internal static int ORA_INVALID_OPER_FOR_CHNF;
    internal static int ORA_EDITION_DOES_NOT_EXIST;
    internal static int ORA_VBL_INVALID_OPERATION;
    internal static int ORA_RDO_LOB_INVALID_OPERATION;
    internal static int ORA_INVALID_TOKEN;
    internal static int ORA_EXPIRED_TOKEN;
    internal static int ORA_INVALID_PRIVATEKEY;
    internal static int ORA_INVALID_TOKEN_AUTH_OR_PASSW_AUTH;
    internal static int ORA_INVALID_TOKEN_ENTRA_ID;
    internal static int ORA_INVALID_CLIENT_AUTH_PROTOCOL;
    internal static int TTC_INT_PROTOCOL_ERR;
    internal static int TTC_FATAL_TTC_PROTOCOL_ERR;
    internal static int TTC_BUF_OVERFLOW;
    internal static int TTC_BUF_UNDERFLOW;
    internal static int TTC_BREAK_RECVD;
    internal static int TTC_EOF_COMM;
    internal static int TTC_NOT_CONNECTED;
    internal static int TTC_INVALID_BUF_LEN;
    internal static int TTC_INT_ERROR;
    internal static int TTC_CLI_SVR_PROTO_VIOLATION;
    internal static int TTC_PGBK_FUN_ERR;
    internal static int TTC_CONN_LOST;
    internal static int TTC_INBND_CONN_TIMEOUT;
    internal static int TTC_PROTO_INT_ERROR;
    internal static int TTC_REQ_CBK_NOT_REG;
    internal static int TTC_PKG_PROC_CREATD_WITH_WRNS;
    internal static int TTC_PLSQL_CMPLR_WRN;
    internal static int TTC_AGG_FUN_NULL_VALUES;
    internal static int VECTOR_STRING_INCORRECT_FORMAT;
    internal static int VECTOR_STRING_IMPROPER_FORMAT;
    internal static int UDT_META_INVALID_TDS;
    internal static int UDT_META_UNEXPECTED_TDS_VALUE;
    internal static int UDT_META_CANNOT_GET_TYPENAME_FROM_PARENT;
    internal static int UDT_META_CANNOT_GET_COLL_ELEMENTNAME;
    internal static int UDT_META_CANNOT_GET_ATTR_INFO;
    internal static int UDT_META_UNEXPECTED_METADATA;
    internal static int UDT_IMAGE_NOT_81_FORMAT;
    internal static int UDT_IMAGE_NO_PREFIX_SEGEMENT;
    internal static int UDT_IMAGE_CANNOT_HANDLE_PREFIX;
    internal static int UDT_IMAGE_INVALID_LEN;
    internal static int UDT_IMAGE_INVALID_FLAG;
    internal static int UDT_IMAGE_INVALID_VERSION;
    internal static int UDT_IMAGE_NOT_SUPPORTED;
    internal static int UDT_IMPL_ERROR;
    internal static int CON_TIMEOUT_EXCEEDED;
    internal static int CON_CLOSED;
    internal static int CON_INVALID_ISO_LEVEL;
    internal static int CON_STR_NOT_UPDATABLE;
    internal static int CON_REOPENED;
    internal static int CON_ALREADY_OPEN;
    internal static int CON_ALREADY_TXNED;
    internal static int CON_STR_NOT_WELL_FORMED;
    internal static int CON_STR_INVALID_ATTRIB;
    internal static int CON_STR_INVALID_VALUE;
    internal static int CON_DIFFERENT_CONNECTIONS;
    internal static int CON_POOLED_TIMEOUT_EXCEEDED;
    internal static int CON_TXN_NOT_DISPOSED;
    internal static int CON_FEATURE_NOT_AVAILABLE;
    internal static int CON_SERVICE_RELOCATION_TIMEOUT;
    internal static int CON_GS_COLL_NOT_DEFINED;
    internal static int CON_GS_COLL_NOT_SUPPORTED;
    internal static int CON_GS_MORE_RESTRICTIONS;
    internal static int CON_GS_QUERY_FAILED;
    internal static int CON_GS_NO_POPULATION_STRING;
    internal static int CON_GS_NO_METADATA_STREAM;
    internal static int CON_GS_NO_CUSTOM_FILE;
    internal static int CON_CURRENTLY_IN_TRANSACTION;
    internal static int CON_CURRENTLY_IN_DISTRIBUTED_TRANSACTION;
    internal static int CON_CURRENTLY_IN_EXPLICIT_TRANSACTION;
    internal static int CON_MTS_ENLIST_FAIL;
    internal static int MTS_INVALID_CONFIG_VALUES;
    internal static int PRM_INVALID_BIND;
    internal static int ODP_INVALID_VALUE;
    internal static int PRMCOL_ALREADY_ADDED;
    internal static int CMD_TYPE_NOT_SUPPORTED;
    internal static int DR_NULL_COL_DATA;
    internal static int DR_INV_COL_NAME;
    internal static int DR_INV_COL_INDEX;
    internal static int DR_INV_DATA_REQ;
    internal static int DR_NO_READ_CALLED;
    internal static int DAC_PK_REQUIRED;
    internal static int DA_FORWARD_ONLY;
    internal static int DA_BU_BIND_VIOLATION;
    internal static int BLR_MULTITABLE_DS;
    internal static int BLR_NO_PRIMARYKEY;
    internal static int ODP_NOT_SUPPORTED;
    internal static int BLR_PRM_NOT_SUPPORTED;
    internal static int LOB_BFILE_ALREADY_OPEN;
    internal static int OBJECT_CLOSED;
    internal static int EVEN_VALUE_PARAM_REQUIRED;
    internal static int TYP_COMPARE_COLLATION;
    internal static int TYP_NULLVALUE;
    internal static int NTFN_CMD_ALREADY_EXIST;
    internal static int NTFN_LISTENER_ALREADY_STARTED;
    internal static int NTFN_REG_NOTVALID;
    internal static int NTFN_PORT_NOT_AVAILABLE;
    internal static int BC_OPER_IN_PROGRESS;
    internal static int BC_INV_COL_MAPPINGS;
    internal static int BC_INV_OPER_INSIDE_EVENT;
    internal static int BC_OPER_ABORT;
    internal static int BC_OPER_TIMEOUT;
    internal static int PC_DESC_CATEGORY;
    internal static int PC_DESC_HARDCONNECTS;
    internal static int PC_DESC_HARDDISCONNECTS;
    internal static int PC_DESC_SOFTCONNECTS;
    internal static int PC_DESC_SOFTDISCONNECTS;
    internal static int PC_DESC_ACTIVECONNPOOLS;
    internal static int PC_DESC_ACTIVECONNS;
    internal static int PC_DESC_FREECONNS;
    internal static int PC_DESC_INACTIVECONNPOOLS;
    internal static int PC_DESC_NONPOOLEDCONNS;
    internal static int PC_DESC_POOLEDCONNS;
    internal static int PC_DESC_RECLAIMEDCONNS;
    internal static int PC_DESC_STASISCONNS;
    internal static int UDT_INV_CUSTOM_TYPE_MAPPING;
    internal static int UDT_INV_CUSTOM_TYPE;
    internal static int UDT_TYPE_CONVERSION_NOTSUPPORTED;
    internal static int UDT_TYPE_MAPPING_NOTSPECIFIED;
    internal static int INT_ERR;
    internal static int ONS_HOST_PORT_PARSE_ERROR;
    internal static int ONS_NO_VALID_HOST_PORT_VALUES;
    internal static int ONS_BAD_FORMAT_OF_NODES;
    internal static int ONS_WRONG_SERVER_NODES_CONFIG;
    internal static int ONS_SUBSCR_TIMED_OUT;
    internal static int ONS_SUBSCR_FAILED;
    internal static int ONS_NO_NODE_LISTS;
    internal static int ONS_NO_PORT_FOUND;
    internal static int ONS_FILE_NOT_EXIST;
    internal static int XML_NOT_SUPPORTED_IMAGE_TYPE;
    internal static int XML_TYPE_BINARY_INTERNAL_ERROR;
    internal static int UDT_ERROR_MESSAGE;
    internal static int MT_INVALID_OPTION_ERR;
    internal static int MT_OPTION_NOT_SET_ERR;
    internal static int MT_INVALID_OPER_ERR_OPEN;
    internal static int MT_INVALID_OPER_ERR_CLOSE;
    internal static int MT_CONN_NOT_ESTABLISHED;
    internal static int DRCP_SESSION_TAG_LENGTH_EXCEEDED;
    internal static int DRCP_PROXY_NOT_AUTHORIZED_AS_CLIENT;
    internal static int DRCP_PROPERTY_NOT_SUPPORTED_ERR;
    internal static int PASSW_READONLY;
    internal static int CON_STR_ATTRIBS_NOT_ALLOWED;
    internal static int INVALID_OPER_CREDENTIAL_SET;
    internal static int INVALID_OPER_CREDENTIAL_NOT_SET;
    internal static int CANNOT_MODIFY_ORACONFIG;
    internal static int SHARDING_NULL_KEY;
    internal static int SHARDING_UNSUPPORTED_KEY_TYPE;
    internal static int SHARDING_INVALID_KEY_VALUE;
    internal static int SHARDING_INVALID_KEY_TYPE;
    internal static int SHARDING_INVALID_TOPOLOGY;
    internal static int YEAR_OUT_OF_RANGE;
    internal static int FAIL_CONV_TO_UNICODE;
    internal static int FAIL_CONV_TO_BYTES;
    internal static int EF_LINQ_EDMFUNC_NO_DIRECT_CALL;
    internal static int CON_IAM_PROP_CONFLICT;
    internal static int CON_IAM_ACC_TOKEN_NOT_SET;
    internal static int CON_IAM_TOKEN_AUTH_ENABLED;
    internal static int CON_IAM_INVALID_CONSTRING;
    internal static int CON_IAM_TLS_NOT_ENABLED;
    internal static int CON_IAM_SERVER_DN_MATCH_NOT_ENABLED;
    internal static int CON_SSO_TOKEN_AUTH_CONFIG_INVALID;
    internal static int CONFIG_INVALID_SECRET;
    internal static int CONFIG_INVALID_SECRET_URL;
    internal static int CONFIG_INVALID_URL_PARAMETER;
    internal static int NTFN_ACK_NOT_VALID;
    internal static int URL_INVALID;
    internal static int CONFIG_CHANGE_NOTIF_REG_FAILED;
    internal static int VECTOR_VERSION_NOT_SUPPORTED;
    private static ResourceStringConstants();
}
public enum Oracle.ManagedDataAccess.OpenTelemetry.EnableOpenCloseTracing : Enum {
    public int value__;
    public static EnableOpenCloseTracing None;
    public static EnableOpenCloseTracing HardOpenCloseOnly;
    public static EnableOpenCloseTracing AllOpenClose;
}
internal class Oracle.ManagedDataAccess.OpenTelemetry.OracleActivitySource : object {
    internal static ActivitySource m_Source;
    [CompilerGeneratedAttribute]
private bool <SetDbStatementForStoredProcedure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetDbStatementForText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableConnectionLevelAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstrumentOracleDataReaderRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecordException>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDBRoundTripTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private EnableOpenCloseTracing <EnableOpenCloseTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireApplicationRootSpanCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddDBInfoToDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableSqlIdTracing>k__BackingField;
    internal bool SetDbStatementForStoredProcedure { get; internal set; }
    internal bool SetDbStatementForText { get; internal set; }
    internal bool EnableConnectionLevelAttributes { get; internal set; }
    internal bool InstrumentOracleDataReaderRead { get; internal set; }
    internal bool RecordException { get; internal set; }
    internal bool EnableDBRoundTripTracing { get; internal set; }
    internal EnableOpenCloseTracing EnableOpenCloseTracing { get; internal set; }
    internal bool RequireApplicationRootSpanCreation { get; internal set; }
    internal bool AddDBInfoToDisplayName { get; internal set; }
    internal bool EnableSqlIdTracing { get; internal set; }
    private static OracleActivitySource();
    [CompilerGeneratedAttribute]
internal bool get_SetDbStatementForStoredProcedure();
    [CompilerGeneratedAttribute]
internal void set_SetDbStatementForStoredProcedure(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SetDbStatementForText();
    [CompilerGeneratedAttribute]
internal void set_SetDbStatementForText(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EnableConnectionLevelAttributes();
    [CompilerGeneratedAttribute]
internal void set_EnableConnectionLevelAttributes(bool value);
    [CompilerGeneratedAttribute]
internal bool get_InstrumentOracleDataReaderRead();
    [CompilerGeneratedAttribute]
internal void set_InstrumentOracleDataReaderRead(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RecordException();
    [CompilerGeneratedAttribute]
internal void set_RecordException(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EnableDBRoundTripTracing();
    [CompilerGeneratedAttribute]
internal void set_EnableDBRoundTripTracing(bool value);
    [CompilerGeneratedAttribute]
internal EnableOpenCloseTracing get_EnableOpenCloseTracing();
    [CompilerGeneratedAttribute]
internal void set_EnableOpenCloseTracing(EnableOpenCloseTracing value);
    [CompilerGeneratedAttribute]
internal bool get_RequireApplicationRootSpanCreation();
    [CompilerGeneratedAttribute]
internal void set_RequireApplicationRootSpanCreation(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AddDBInfoToDisplayName();
    [CompilerGeneratedAttribute]
internal void set_AddDBInfoToDisplayName(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EnableSqlIdTracing();
    [CompilerGeneratedAttribute]
internal void set_EnableSqlIdTracing(bool value);
    internal object SpanStart(string activityDisplayName, OracleConnectionImpl connImpl, string sqlStatement, string statementType, ConnectionString cs, object parentActivity);
    internal object SpanStart(string activityDisplayName, OracleCommand command);
    internal object SpanStart(string activityDisplayName, OracleConnectionImpl connImpl, OracleCommandImpl command);
    internal object SpanStart(string activityDisplayName, OracleConnectionImpl connImpl, OracleCommandImpl command, ConnectionString cs, object parentActivity);
    internal void SpanStop(Object& activity, string dbname, string hostname, Nullable`1<int> port, string sqlid, Nullable`1<int> rows_affected);
    internal void SetException(Object& activity, Exception ex);
    internal void SetNullToCurrentActivity();
}
public class Oracle.ManagedDataAccess.OpenTelemetry.OracleDataProviderInstrumentationOptions : object {
    [CompilerGeneratedAttribute]
private bool <SetDbStatementForStoredProcedure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetDbStatementForText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableConnectionLevelAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstrumentOracleDataReaderRead>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecordException>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDBRoundTripTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireApplicationRootSpanCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private EnableOpenCloseTracing <EnableOpenCloseTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddDBInfoToDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableSqlIdTracing>k__BackingField;
    public bool SetDbStatementForStoredProcedure { get; public set; }
    public bool SetDbStatementForText { get; public set; }
    public bool EnableConnectionLevelAttributes { get; public set; }
    public bool InstrumentOracleDataReaderRead { get; public set; }
    public bool RecordException { get; public set; }
    public bool EnableDBRoundTripTracing { get; public set; }
    public bool RequireApplicationRootSpanCreation { get; public set; }
    public EnableOpenCloseTracing EnableOpenCloseTracing { get; public set; }
    public bool AddDBInfoToDisplayName { get; public set; }
    public bool EnableSqlIdTracing { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SetDbStatementForStoredProcedure();
    [CompilerGeneratedAttribute]
public void set_SetDbStatementForStoredProcedure(bool value);
    [CompilerGeneratedAttribute]
public bool get_SetDbStatementForText();
    [CompilerGeneratedAttribute]
public void set_SetDbStatementForText(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableConnectionLevelAttributes();
    [CompilerGeneratedAttribute]
public void set_EnableConnectionLevelAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_InstrumentOracleDataReaderRead();
    [CompilerGeneratedAttribute]
public void set_InstrumentOracleDataReaderRead(bool value);
    [CompilerGeneratedAttribute]
public bool get_RecordException();
    [CompilerGeneratedAttribute]
public void set_RecordException(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableDBRoundTripTracing();
    [CompilerGeneratedAttribute]
public void set_EnableDBRoundTripTracing(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireApplicationRootSpanCreation();
    [CompilerGeneratedAttribute]
public void set_RequireApplicationRootSpanCreation(bool value);
    [CompilerGeneratedAttribute]
public EnableOpenCloseTracing get_EnableOpenCloseTracing();
    [CompilerGeneratedAttribute]
public void set_EnableOpenCloseTracing(EnableOpenCloseTracing value);
    [CompilerGeneratedAttribute]
public bool get_AddDBInfoToDisplayName();
    [CompilerGeneratedAttribute]
public void set_AddDBInfoToDisplayName(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableSqlIdTracing();
    [CompilerGeneratedAttribute]
public void set_EnableSqlIdTracing(bool value);
}
internal class Oracle.ManagedDataAccess.ServiceObjects.AQUsingDbmsAQ : object {
    private static int E_SIZE_IN;
    private static int L_AGENT_NAME_LIST_IN;
    private static int L_AGENT_ADDR_LIST_IN;
    private static int L_WAIT_IN;
    private static int L_AGENTNAME_OUT;
    private static int L_AGENTADDRESS_OUT;
    internal static object m_aqCommandLock;
    private static Queue`1<OracleCommand> m_aqCommandCache;
    private static string AQ_LISTEN_COMMAND_TEXT;
    private static AQUsingDbmsAQ();
    internal static OracleAQAgent ListenInfoFromDbmsAQCommandExecution(OracleConnection connection, OracleAQAgent[] agents, int waitTime);
}
internal enum Oracle.ManagedDataAccess.Types.CompareNullEnum : Enum {
    public int value__;
    public static CompareNullEnum BothNull;
    public static CompareNullEnum FirstNullOnly;
    public static CompareNullEnum SecondNullOnly;
    public static CompareNullEnum BothNotNull;
}
internal static class Oracle.ManagedDataAccess.Types.CoreFunctions : object {
    internal static Int32[] ldidom;
    private static CoreFunctions();
    internal static bool IsLeapYear(int y);
    internal static int Cal2Days(int y, int m, int d);
    internal static int DateToJulianDays(int year, int month, int day);
}
internal static class Oracle.ManagedDataAccess.Types.DateTimeConv : object {
    internal static DateTime GetDateTime(Byte[] byteRep, OracleDbType oraType, int offset, int length);
    internal static DateTime GetDateTime(Byte[] byteRep, OraType oraType, int offset, int length);
    internal static DateTime ToDateTime(Byte[] byteRep, bool isNotTimeStampTZ, int offset, int length);
    internal static string ToString(Byte[] byteRep, int offset, int length, string format);
    internal static string ToString(Byte[] byteRep, bool bCopyData, TSType tsType, string format, int dataOffset, int dataLength, bool addTZOffset);
    internal static string nlsFormatToText(int year, int month, int day, int hour, int min, int sec, int nanos, bool am, string zone, string format, int hoursTZ, int minutesTZ);
}
internal static class Oracle.ManagedDataAccess.Types.DateTimeStringUtilities : object {
    private static char ZERO;
    private static int DATE_TOKEN;
    private static int TIME_TOKEN;
    private static int REGION_TOKEN;
    private static int TOKEN_COUNT;
    private static Char[] space;
    private static Char[] slash;
    private static Char[] colon;
    private static Char[] dot;
    private static DateTimeStringUtilities();
    internal static string ToString(int year, int month, int day, int hours, int minutes, int seconds, int nanos, string region);
    internal static void FromString(string stringRep, Int32& year, Int32& month, Int32& day, Int32& hours, Int32& minutes, Int32& seconds, Int32& nanos, String& region, bool expectNoRegion, bool expectNoNanos);
}
internal static class Oracle.ManagedDataAccess.Types.DecimalConv : object {
    internal static int LNXBASE;
    internal static int LNXSGNBT;
    internal static int LNXEXPMX;
    internal static byte LNXEXPBS;
    internal static OracleDecimal m_sOracleDecimalWith29Precision;
    private static Char[] exponent;
    private static Char[] dot;
    private static string ZERO;
    private static string INFINITY;
    internal static int MAX_BYTEREP_LENGTH;
    private static int POSITIVE_OFFSET;
    private static int NEGATIVE_OFFSET;
    private static byte NEGATIVE_BYTE_TERMINATOR;
    private static byte MAX_EXPONENT;
    private static byte BASE100EXP;
    private static int ORANUM_MAX_EXP;
    private static int ORANUM_MIN_EXP;
    private static int ORANUM_POS_BASE;
    private static int ORANUM_NEG_BASE;
    private static int ORANUM_MAX_DIGITS;
    private static DecimalConv();
    internal static int GetPrecision(Byte[] bytes, int dataPos, int length);
    private static decimal GetDecimal(Byte[] bytes, int dataPos, int length);
    internal static decimal GetDecimal(Byte[] bytes, int dataPos, int length, bool bSuppressOverflowException);
    internal static void GetBytes(decimal dec, Byte[]& bytes);
    internal static Byte[] BigIntegerToBytes(BigInteger bInt);
    internal static Byte[] FromString(string stringRep, Boolean& isPositive, Boolean& isZero, Boolean& isInfinity, Boolean& hasDecimalPoint);
    internal static string ToString(Byte[] bytes, char decimalSeparator);
}
internal static class Oracle.ManagedDataAccess.Types.InternalTypes : object {
    internal static string NullStr;
    internal static CompareNullEnum CompareNull(bool b1Null, bool b2Null);
}
internal static class Oracle.ManagedDataAccess.Types.Interval : object {
    internal static int MaxYears;
    internal static int TotalMaxYears;
    internal static byte MaxMonths;
    internal static long TotalMaxMonths;
    internal static int MaxDays;
    internal static double TotalMaxDays;
    internal static byte MaxHours;
    internal static double TotalMaxHours;
    internal static byte MaxMinutes;
    internal static double TotalMaxMinutes;
    internal static byte MaxSeconds;
    internal static double TotalMaxSeconds;
    internal static double MaxMilliseconds;
    internal static double TotalMaxMilliseconds;
    internal static int MaxFSeconds;
    internal static int MinYears;
    internal static int TotalMinYears;
    internal static short MinMonths;
    internal static long TotalMinMonths;
    internal static int MinDays;
    internal static double TotalMinDays;
    internal static short MinHours;
    internal static double TotalMinHours;
    internal static short MinMinutes;
    internal static double TotalMinMinutes;
    internal static short MinSeconds;
    internal static double TotalMinSeconds;
    internal static double MinMilliseconds;
    internal static double TotalMinMilliseconds;
    internal static int MinFSeconds;
    internal static byte MonthsPerYear;
    internal static byte MaxYearPrec;
    internal static byte MaxDayPrec;
    internal static byte MaxFSecondPrec;
    internal static byte MinYearPrec;
    internal static byte MinDayPrec;
    internal static byte MinFSecondPrec;
    internal static byte MaxSingleDigit;
    internal static int HoursPerDay;
    internal static int MinutesPerDay;
    internal static int SecondsPerDay;
    internal static double FractionSecsPerDay;
    internal static bool IsValidYears(int years);
    internal static bool IsValidMonths(int months);
    internal static bool IsValidYMMonths(long ymMonths);
    internal static bool IsValidYM(int years, int months);
    internal static bool IsValidDays(int days);
    internal static bool IsValidHours(int hours);
    internal static bool IsValidMinutes(int minutes);
    internal static bool IsValidSeconds(int seconds);
    internal static bool IsValidNanoseconds(int nanoseconds);
    internal static bool IsValidDS(int days, int hours, int minutes, int seconds, int nanoseconds);
}
public interface Oracle.ManagedDataAccess.Types.INullable {
    public bool IsNull { get; }
    public abstract virtual bool get_IsNull();
}
public interface Oracle.ManagedDataAccess.Types.IOracleArrayTypeFactory {
    public abstract virtual Array CreateArray(int numElems);
    public abstract virtual Array CreateStatusArray(int numElems);
}
public interface Oracle.ManagedDataAccess.Types.IOracleCustomType {
    public abstract virtual void FromCustomObject(OracleConnection con, object udt);
    public abstract virtual void ToCustomObject(OracleConnection con, object udt);
}
public interface Oracle.ManagedDataAccess.Types.IOracleCustomTypeFactory {
    public abstract virtual IOracleCustomType CreateObject();
}
internal class Oracle.ManagedDataAccess.Types.Number : object {
    internal static byte ExpOffset;
    internal static byte MaxByteValue;
    internal static byte HighBitValue;
    internal static byte PosExpOffset;
    internal static byte NegExpOffset;
    internal static byte PosDigitOffset;
    internal static byte NegDigitOffset;
    internal static byte NegTrailingByte;
    internal static byte ZeroBytesLen;
    internal static byte ZeroBytesExp;
    internal static byte NumLen;
    internal static byte LENINDEX;
    internal static byte EXPINDEX;
    internal static byte DIGITINDEX;
    internal static byte Base;
    internal static byte ExpBase;
    internal static byte MaxDigitsLen;
    internal static byte MaxScale;
    internal static short MinScale;
    internal static byte MaxPrecision;
    internal static byte BinaryFloatLength;
    internal static byte BinaryDoubleLength;
    internal static byte NEGATIVE_BYTE_TERMINATOR;
}
internal enum Oracle.ManagedDataAccess.Types.NumberType : Enum {
    public int value__;
    public static NumberType INT;
    public static NumberType REAL;
    public static NumberType PINF;
    public static NumberType NINF;
    public static NumberType NAN;
}
[AttributeUsageAttribute("384")]
public class Oracle.ManagedDataAccess.Types.OracleArrayMappingAttribute : Attribute {
    private static OracleArrayMappingAttribute();
}
public class Oracle.ManagedDataAccess.Types.OracleBFile : Stream {
    internal OracleBFileImpl m_bfileImpl;
    internal OracleConnection m_connection;
    internal bool m_isTemporaryLob;
    private OracleCommand m_command;
    private string m_directoryName;
    private bool m_fileExists;
    private string m_fileName;
    private long m_length;
    private long m_position;
    internal bool m_isEmpty;
    private bool m_isFileOpen;
    private bool m_bNotNull;
    private bool m_bClosed;
    private bool m_bDisposed;
    private object lockBFile;
    internal object m_invokingInstanceWrapper;
    internal bool m_bGCInvokedDestructor;
    public static long MaxSize;
    public static OracleBFile Null;
    internal bool m_bCanRecordNewCall;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public Byte[] Value { get; }
    public long Position { get; public set; }
    public bool IsNull { get; }
    public OracleConnection Connection { get; }
    public string DirectoryName { get; public set; }
    public bool FileExists { get; }
    public string FileName { get; public set; }
    public bool IsEmpty { get; }
    public bool IsOpen { get; }
    public OracleBFile(OracleConnection con);
    public OracleBFile(OracleConnection connection, string directoryName, string fileName);
    internal OracleBFile(OracleConnection connection, Byte[] lobLocator);
    private static OracleBFile();
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<ReadInternalAsync>d__0")]
private ValueTask`1<int> ReadInternalAsync(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<GetLengthAsync>d__1")]
internal ValueTask`1<long> GetLengthAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToInternalAsync>d__2")]
private ValueTask`1<long> CopyToInternalAsync(long src_offset, OracleBlob obj, long dst_offset, long amount, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToInternalAsync>d__3")]
private ValueTask`1<long> CopyToInternalAsync(long src_offset, OracleClob obj, long dst_offset, long amount, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    protected virtual override void Finalize();
    private void Init(OracleConnection connection, string directoryName, string fileName);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public Byte[] get_Value();
    internal Byte[] GetValueInternal(CallHistoryRecord currentCHR);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public sealed virtual bool get_IsNull();
    public OracleConnection get_Connection();
    public virtual void Flush();
    public string get_DirectoryName();
    public void set_DirectoryName(string value);
    public bool get_FileExists();
    public string get_FileName();
    public void set_FileName(string value);
    public bool get_IsEmpty();
    public bool get_IsOpen();
    public long Search(Byte[] val, long offset, long nth);
    internal Byte[] GetValue(CallHistoryRecord currentCHR);
    internal Byte[] GetLobLocator();
    internal void SetLobLocator(Byte[] lobLocator, bool bTempLob);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public bool IsEqual(OracleBFile obj);
    public void OpenFile();
    internal void OpenFileInternal(CallHistoryRecord currentCHR);
    public virtual int Read(Byte[] buffer, int offset, int count);
    internal void CancelAsyncCommandExecution();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<ReadAsyncHelper>d__74")]
internal ValueTask`1<int> ReadAsyncHelper(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsync>d__76")]
public Task`1<long> CopyToAsync(OracleBlob obj);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsync>d__77")]
public Task`1<long> CopyToAsync(OracleBlob obj, long dst_offset);
    public Task`1<long> CopyToAsync(long src_offset, OracleBlob obj, long dst_offset, long amount);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsync>d__79")]
public Task`1<long> CopyToAsync(OracleBlob obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsync>d__80")]
public Task`1<long> CopyToAsync(OracleBlob obj, long dst_offset, CancellationToken cancellationToken);
    public Task`1<long> CopyToAsync(long src_offset, OracleBlob obj, long dst_offset, long amount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsyncHelper>d__82")]
internal ValueTask`1<long> CopyToAsyncHelper(long src_offset, OracleBlob obj, long dst_offset, long amount, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsync>d__83")]
public Task`1<long> CopyToAsync(OracleClob obj);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsync>d__84")]
public Task`1<long> CopyToAsync(OracleClob obj, long dst_offset);
    public Task`1<long> CopyToAsync(long src_offset, OracleClob obj, long dst_offset, long amount);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsync>d__86")]
public Task`1<long> CopyToAsync(OracleClob obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsync>d__87")]
public Task`1<long> CopyToAsync(OracleClob obj, long dst_offset, CancellationToken cancellationToken);
    public Task`1<long> CopyToAsync(long src_offset, OracleClob obj, long dst_offset, long amount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBFile/<CopyToAsyncHelper>d__89")]
internal ValueTask`1<long> CopyToAsyncHelper(long src_offset, OracleClob obj, long dst_offset, long amount, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void CloseFile();
    internal void CloseFileInternal(CallHistoryRecord currentCHR);
    public int Compare(long src_offset, OracleBFile obj, long dst_offset, long amount);
    public long CopyTo(OracleBlob obj);
    public long CopyTo(OracleBlob obj, long dst_offset);
    public long CopyTo(OracleClob obj);
    public long CopyTo(OracleClob obj, long dst_offset);
    public long CopyTo(long src_offset, OracleBlob obj, long dst_offset, long amount);
    public long CopyTo(long src_offset, OracleClob obj, long dst_offset, long amount);
    public sealed virtual object Clone();
    public virtual void Close();
    internal void ConnectionClose();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void GetDFNames(CallHistoryRecord currentCHR);
    internal void SetDFNames(CallHistoryRecord currentCHR);
    internal long GetLengthInternal(CallHistoryRecord currentCHR);
    private int ReadInternal(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR);
    internal long GetLength(CallHistoryRecord currentCHR, bool bAsync);
    private long CopyToInternal(long src_offset, OracleBlob obj, long dst_offset, long amount, bool bAsync, CallHistoryRecord currentCHR);
    private long CopyToInternal(long src_offset, OracleClob obj, long dst_offset, long amount, bool bAsync, CallHistoryRecord currentCHR);
}
[XmlSchemaProviderAttribute("GetXsdType")]
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Types.OracleBinary : ValueType {
    internal Byte[] m_value;
    private bool m_bNotNull;
    public static OracleBinary Null;
    public bool IsNull { get; }
    public int Length { get; }
    public byte Item { get; }
    public Byte[] Value { get; }
    public OracleBinary(Byte[] data);
    internal OracleBinary(Byte[] data, bool bCopy);
    public sealed virtual bool get_IsNull();
    public int get_Length();
    public byte get_Item(int index);
    public Byte[] get_Value();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static OracleBinary Concat(OracleBinary value1, OracleBinary value2);
    public static bool Equals(OracleBinary value1, OracleBinary value2);
    public static bool GreaterThan(OracleBinary value1, OracleBinary value2);
    public static bool GreaterThanOrEqual(OracleBinary value1, OracleBinary value2);
    public static bool LessThan(OracleBinary value1, OracleBinary value2);
    public static bool LessThanOrEqual(OracleBinary value1, OracleBinary value2);
    public static bool NotEquals(OracleBinary value1, OracleBinary value2);
    public static bool op_Equality(OracleBinary value1, OracleBinary value2);
    public static bool op_GreaterThan(OracleBinary value1, OracleBinary value2);
    public static bool op_GreaterThanOrEqual(OracleBinary value1, OracleBinary value2);
    public static bool op_LessThan(OracleBinary value1, OracleBinary value2);
    public static bool op_LessThanOrEqual(OracleBinary value1, OracleBinary value2);
    public static bool op_Inequality(OracleBinary value1, OracleBinary value2);
    public static OracleBinary op_Addition(OracleBinary value1, OracleBinary value2);
    public static Byte[] op_Explicit(OracleBinary value1);
    public static OracleBinary op_Implicit(Byte[] value1);
}
public class Oracle.ManagedDataAccess.Types.OracleBlob : Stream {
    internal OracleBlobImpl m_blobImpl;
    internal OracleConnection m_connection;
    private OracleCommand m_command;
    private bool m_bNotNull;
    private bool m_isInChunkWriteMode;
    private long m_position;
    internal bool m_bClosed;
    internal bool m_bDisposed;
    private object m_lock;
    private object lockBlob;
    internal OracleBlobImpl m_inOutBlobToBeRefRefed;
    internal object m_invokingInstanceWrapper;
    internal bool m_bGCInvokedDestructor;
    public static long MaxSize;
    public static OracleBlob Null;
    internal bool m_bCanRecordNewCall;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool IsInChunkWriteMode { get; }
    public bool IsTemporary { get; }
    public long Length { get; }
    public int OptimumChunkSize { get; }
    public long Position { get; public set; }
    public bool IsNull { get; }
    public OracleConnection Connection { get; }
    public bool IsEmpty { get; }
    public Byte[] Value { get; }
    public OracleBlob(OracleConnection connection);
    public OracleBlob(OracleConnection connection, bool bCaching);
    internal OracleBlob(OracleConnection connection, Byte[] lobLocator);
    internal OracleBlob(OracleConnection connection, OracleBlobImpl blobImpl);
    private OracleBlob(char dummy);
    private static OracleBlob();
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<GetLengthAsync>d__0")]
internal ValueTask`1<long> GetLengthAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<ReadInternalAsync>d__1")]
private ValueTask`1<int> ReadInternalAsync(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<WriteInternalAsync>d__2")]
private ValueTask WriteInternalAsync(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<CopyToInternalAsync>d__3")]
private ValueTask`1<long> CopyToInternalAsync(long src_offset, OracleBlob obj, long dst_offset, long amount, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<CreateTempLobAsync>d__4")]
internal ValueTask CreateTempLobAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<CreateDeepCopyAsync>d__5")]
internal ValueTask CreateDeepCopyAsync(bool bAsync, CallHistoryRecord currentCHR);
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    internal void Init(OracleConnection connection, bool bCaching);
    protected virtual override void Finalize();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public bool get_IsInChunkWriteMode();
    internal bool GetIsTemporary(CallHistoryRecord currentCHR);
    public bool get_IsTemporary();
    public virtual long get_Length();
    public int get_OptimumChunkSize();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public sealed virtual bool get_IsNull();
    public OracleConnection get_Connection();
    public bool get_IsEmpty();
    public Byte[] get_Value();
    internal Byte[] GetLobLocator();
    internal void SetLobLocator(Byte[] lobLocator, bool bTempLob);
    public bool IsEqual(OracleBlob obj);
    public long Erase();
    internal long Erase(long offset, long amount, CallHistoryRecord currentCHR);
    public long Erase(long offset, long amount);
    public virtual void Flush();
    public long Search(Byte[] val, long offset, long nth);
    internal long SeekInternal(long offset, SeekOrigin origin, CallHistoryRecord currentCHR);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public void BeginChunkWrite();
    internal void EndChunkWriteInternal(CallHistoryRecord currentCHR);
    public void EndChunkWrite();
    public virtual int Read(Byte[] buffer, int offset, int count);
    internal void CancelAsyncCommandExecution();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<ReadAsyncHelper>d__73")]
internal ValueTask`1<int> ReadAsyncHelper(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<WriteAsyncHelper>d__75")]
internal ValueTask WriteAsyncHelper(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<CopyToAsync>d__76")]
public Task`1<long> CopyToAsync(OracleBlob obj);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<CopyToAsync>d__77")]
public Task`1<long> CopyToAsync(OracleBlob obj, long dst_offset);
    public Task`1<long> CopyToAsync(long src_offset, OracleBlob obj, long dst_offset, long amount);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<CopyToAsync>d__79")]
public Task`1<long> CopyToAsync(OracleBlob obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<CopyToAsync>d__80")]
public Task`1<long> CopyToAsync(OracleBlob obj, long dst_offset, CancellationToken cancellationToken);
    public Task`1<long> CopyToAsync(long src_offset, OracleBlob obj, long dst_offset, long amount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleBlob/<CopyToAsyncHelper>d__82")]
internal ValueTask`1<long> CopyToAsyncHelper(long src_offset, OracleBlob obj, long dst_offset, long amount, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void Append(OracleBlob obj);
    public void Append(Byte[] buffer, int offset, int count);
    public sealed virtual object Clone();
    public virtual void Close();
    internal void ConnectionClose();
    public int Compare(long src_offset, OracleBlob obj, long dst_offset, long amount);
    public long CopyTo(OracleBlob obj);
    public long CopyTo(OracleBlob obj, long dst_offset);
    public long CopyTo(long src_offset, OracleBlob obj, long dst_offset, long amount);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal int GetOptimumChunkSize(CallHistoryRecord currentCHR);
    internal long GetLength(CallHistoryRecord currentCHR, bool bAsync);
    private int ReadInternal(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR);
    private void WriteInternal(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR);
    private long CopyToInternal(long src_offset, OracleBlob obj, long dst_offset, long amount, bool bAsync, CallHistoryRecord currentCHR);
    internal void CreateTempLob(CallHistoryRecord currentCHR, bool bAsync);
    internal void CreateDeepCopy(bool bAsync, CallHistoryRecord currentCHR);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class Oracle.ManagedDataAccess.Types.OracleBoolean : ValueType {
    public static OracleBoolean False;
    public static OracleBoolean True;
    public static OracleBoolean Null;
    public static OracleBoolean One;
    public static OracleBoolean Zero;
    private bool m_valueBool;
    private byte m_valueByte;
    private bool m_bNotNull;
    public bool IsTrue { get; }
    public bool IsFalse { get; }
    public byte ByteValue { get; }
    public bool IsNull { get; }
    public bool Value { get; }
    private static OracleBoolean();
    public OracleBoolean(bool value);
    public OracleBoolean(int value);
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public bool get_IsTrue();
    public bool get_IsFalse();
    public byte get_ByteValue();
    public sealed virtual bool get_IsNull();
    public bool get_Value();
    public sealed virtual int CompareTo(object obj);
    public int CompareTo(OracleBoolean value);
    public virtual bool Equals(object obj);
    public static OracleBoolean Equals(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean NotEquals(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean And(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean Or(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean Xor(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean OnesComplement(OracleBoolean value1);
    public static OracleBoolean GreaterThan(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean GreaterThanOrEquals(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean LessThan(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean LessThanOrEquals(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean Parse(string str);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static OracleBoolean op_BitwiseAnd(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_BitwiseOr(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_Equality(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_Inequality(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_ExclusiveOr(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_LogicalNot(OracleBoolean value1);
    public static OracleBoolean op_OnesComplement(OracleBoolean value1);
    public static bool op_True(OracleBoolean value1);
    public static bool op_False(OracleBoolean value1);
    public static OracleBoolean op_GreaterThan(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_LessThan(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_GreaterThanOrEqual(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_LessThanOrEqual(OracleBoolean value1, OracleBoolean value2);
    public static OracleBoolean op_Implicit(bool value1);
    public static bool op_Explicit(OracleBoolean value1);
    public static OracleBoolean op_Explicit(byte value1);
    public static OracleBoolean op_Explicit(decimal value1);
    public static OracleBoolean op_Explicit(double value1);
    public static OracleBoolean op_Explicit(short value1);
    public static OracleBoolean op_Explicit(int value1);
    public static OracleBoolean op_Explicit(long value1);
    public static OracleBoolean op_Explicit(float value1);
    public static OracleBoolean op_Explicit(string value1);
}
public class Oracle.ManagedDataAccess.Types.OracleClob : Stream {
    internal OracleClobImpl m_clobImpl;
    internal OracleConnection m_connection;
    private OracleCommand m_command;
    private bool m_bNotNull;
    private bool m_isInChunkWriteMode;
    private long m_position;
    internal bool m_bClosed;
    internal bool m_bDisposed;
    private object m_lock;
    private object lockClob;
    internal OracleClobImpl m_inOutClobToBeRefRefed;
    internal object m_invokingInstanceWrapper;
    internal bool m_bGCInvokedDestructor;
    public static long MaxSize;
    public static OracleClob Null;
    internal bool m_bCanRecordNewCall;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsNull { get; }
    public int OptimumChunkSize { get; }
    public OracleConnection Connection { get; }
    public bool IsEmpty { get; }
    public bool IsNClob { get; }
    public bool IsInChunkWriteMode { get; }
    public bool IsTemporary { get; }
    public string Value { get; }
    public OracleClob(OracleConnection con);
    public OracleClob(OracleConnection con, bool bCaching, bool bNClob);
    internal OracleClob(OracleConnection con, bool bInternalCall);
    internal OracleClob(OracleConnection connection, Byte[] lobLocator, bool bNClob, bool bCaching);
    internal OracleClob(OracleConnection connection, OracleClobImpl clobImpl);
    private static OracleClob();
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<GetLengthAsync>d__0")]
internal ValueTask`1<long> GetLengthAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<ReadInternalAsync>d__1")]
internal ValueTask`1<int> ReadInternalAsync(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<ReadInternalAsync>d__2")]
internal ValueTask`1<int> ReadInternalAsync(Char[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<WriteInternalAsync>d__3")]
private ValueTask WriteInternalAsync(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<WriteInternalAsync>d__4")]
private ValueTask WriteInternalAsync(Char[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<CopyToInternalAsync>d__5")]
private ValueTask`1<long> CopyToInternalAsync(long src_offset, OracleClob obj, long dst_offset, long amount, bool bAsync, CallHistoryRecord currentCHR, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<CreateTempLobAsync>d__6")]
internal ValueTask CreateTempLobAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<CreateDeepCopyAsync>d__7")]
internal ValueTask CreateDeepCopyAsync(bool bAsync, CallHistoryRecord currentCHR);
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    private void Init(OracleConnection connection, bool bCaching, bool bNClob);
    protected virtual override void Finalize();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal void SetPositionInternal(long value, CallHistoryRecord currentCHR);
    public sealed virtual bool get_IsNull();
    public int get_OptimumChunkSize();
    public OracleConnection get_Connection();
    public bool get_IsEmpty();
    public bool get_IsNClob();
    public bool get_IsInChunkWriteMode();
    public bool get_IsTemporary();
    public string get_Value();
    internal Byte[] GetLobLocator();
    internal void SetLobLocator(Byte[] lobLocator, bool bTempLob);
    public virtual void Flush();
    public bool IsEqual(OracleClob obj);
    public long Search(Byte[] val, long offset, long nth);
    public long Search(Char[] val, long offset, long nth);
    internal long SeekInternal(long offset, SeekOrigin origin, CallHistoryRecord currentCHR);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    internal void CancelAsyncCommandExecution();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<ReadAsyncHelper>d__73")]
internal ValueTask`1<int> ReadAsyncHelper(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    public Task`1<int> ReadAsync(Char[] buffer, int offset, int count);
    public Task`1<int> ReadAsync(Char[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<ReadAsyncHelper>d__76")]
internal ValueTask`1<int> ReadAsyncHelper(Char[] buffer, int offset, int count, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<WriteAsyncHelper>d__78")]
internal ValueTask WriteAsyncHelper(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    public Task WriteAsync(Char[] buffer, int offset, int count);
    public Task WriteAsync(Char[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<WriteAsyncHelper>d__81")]
internal ValueTask WriteAsyncHelper(Char[] buffer, int offset, int count, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<CopyToAsync>d__82")]
public Task`1<long> CopyToAsync(OracleClob obj);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<CopyToAsync>d__83")]
public Task`1<long> CopyToAsync(OracleClob obj, long dst_offset);
    public Task`1<long> CopyToAsync(long src_offset, OracleClob obj, long dst_offset, long amount);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<CopyToAsync>d__85")]
public Task`1<long> CopyToAsync(OracleClob obj, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<CopyToAsync>d__86")]
public Task`1<long> CopyToAsync(OracleClob obj, long dst_offset, CancellationToken cancellationToken);
    public Task`1<long> CopyToAsync(long src_offset, OracleClob obj, long dst_offset, long amount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleClob/<CopyToAsyncHelper>d__88")]
internal ValueTask`1<long> CopyToAsyncHelper(long src_offset, OracleClob obj, long dst_offset, long amount, CancellationToken cancellationToken, CallHistoryRecord currentCHR);
    public int Read(Char[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void Write(Char[] buffer, int offset, int count);
    public void Append(OracleClob obj);
    internal void AppendInternal(Byte[] buffer, int offset, int count, CallHistoryRecord chr);
    public void Append(Byte[] buffer, int offset, int count);
    internal void AppendInternal(Char[] buffer, int offset, int count, CallHistoryRecord chr);
    public void Append(Char[] buffer, int offset, int count);
    public void BeginChunkWrite();
    internal void EndChunkWriteInternal(CallHistoryRecord currentCHR);
    public void EndChunkWrite();
    public long Erase();
    internal long EraseInternal(long offset, long amount, CallHistoryRecord currentCHR);
    public long Erase(long offset, long amount);
    public sealed virtual object Clone();
    public virtual void Close();
    internal void ConnectionClose();
    public int Compare(long src_offset, OracleClob obj, long dst_offset, long amount);
    public long CopyTo(OracleClob obj);
    public long CopyTo(OracleClob obj, long dst_offset);
    public long CopyTo(long src_offset, OracleClob obj, long dst_offset, long amount);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal int GetOptimumChunkSize(CallHistoryRecord currentCHR);
    internal long GetLength(CallHistoryRecord currentCHR, bool bAsync);
    internal int ReadInternal(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR);
    internal int ReadInternal(Char[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR);
    private void WriteInternal(Byte[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR);
    private void WriteInternal(Char[] buffer, int offset, int count, bool bAsync, CallHistoryRecord currentCHR);
    private long CopyToInternal(long src_offset, OracleClob obj, long dst_offset, long amount, bool bAsync, CallHistoryRecord currentCHR);
    internal void CreateTempLob(CallHistoryRecord currentCHR, bool bAsync);
    internal void CreateDeepCopy(bool bAsync, CallHistoryRecord currentCHR);
}
[AttributeUsageAttribute("12")]
public class Oracle.ManagedDataAccess.Types.OracleCustomTypeMappingAttribute : Attribute {
    internal string m_udtTypeName;
    public string UdtTypeName { get; }
    private static OracleCustomTypeMappingAttribute();
    public OracleCustomTypeMappingAttribute(string udtTypeName);
    public string get_UdtTypeName();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class Oracle.ManagedDataAccess.Types.OracleDate : ValueType {
    private bool m_bNotNull;
    internal Byte[] m_byteRepresentation;
    private int m_year;
    private int m_month;
    private int m_day;
    private int m_hour;
    private int m_minute;
    private int m_second;
    internal static byte MaxArrSize;
    internal static byte YEAR;
    internal static byte MONTH;
    internal static byte DAY;
    internal static byte HOUR;
    internal static byte MINUTE;
    internal static byte SECOND;
    public static OracleDate MaxValue;
    public static OracleDate MinValue;
    public static OracleDate Null;
    public Byte[] BinData { get; }
    public bool IsNull { get; }
    public DateTime Value { get; }
    public int Year { get; }
    public int Month { get; }
    public int Day { get; }
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    internal Byte[] InternalByteRepresentation { get; }
    public OracleDate(int year, int month, int day, int hour, int minute, int second);
    public OracleDate(int year, int month, int day);
    public OracleDate(DateTime data);
    public OracleDate(Byte[] binData);
    public OracleDate(string datStr);
    internal OracleDate(Byte[] binData, bool bCopyData, int offset, int length);
    private static OracleDate();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public Byte[] get_BinData();
    public sealed virtual bool get_IsNull();
    public DateTime get_Value();
    public int get_Year();
    public int get_Month();
    public int get_Day();
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public virtual string ToString();
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int GetDaysBetween(OracleDate value1);
    public OracleTimeStamp ToOracleTimeStamp();
    public static bool Equals(OracleDate value1, OracleDate value2);
    public static bool GreaterThan(OracleDate value1, OracleDate value2);
    public static bool GreaterThanOrEqual(OracleDate value1, OracleDate value2);
    public static bool LessThan(OracleDate value1, OracleDate value2);
    public static bool LessThanOrEqual(OracleDate value1, OracleDate value2);
    public static bool NotEquals(OracleDate value1, OracleDate value2);
    public static OracleDate GetSysDate();
    public static OracleDate Parse(string datStr);
    public static bool op_Equality(OracleDate value1, OracleDate value2);
    public static bool op_GreaterThan(OracleDate value1, OracleDate value2);
    public static bool op_GreaterThanOrEqual(OracleDate value1, OracleDate value2);
    public static bool op_LessThan(OracleDate value1, OracleDate value2);
    public static bool op_LessThanOrEqual(OracleDate value1, OracleDate value2);
    public static bool op_Inequality(OracleDate value1, OracleDate value2);
    public static OracleDate op_Explicit(OracleTimeStamp value1);
    public static OracleDate op_Explicit(string dateStr);
    public static DateTime op_Explicit(OracleDate value1);
    public static OracleDate op_Explicit(DateTime value1);
    internal static int GetDateData(Byte[] byteRep, byte tsComponent);
    internal static Byte[] ToBytes(int year, int month, int day, int hour, int minute, int second);
    private void FromString(string datStr);
    internal Byte[] get_InternalByteRepresentation();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class Oracle.ManagedDataAccess.Types.OracleDecimal : ValueType {
    private Byte[] m_byteRepresentation;
    private bool m_bPositive;
    private bool m_bZero;
    private string m_format;
    private bool m_bNotNull;
    private int m_numberType;
    internal static byte MaxArrSize;
    internal static byte MinPrecision;
    internal static int ScaleFactor;
    internal static int NumberTypeIndex;
    internal static OracleDecimal PositiveInfinity;
    internal static OracleDecimal NegativeInfinity;
    internal static OracleDecimal NaN;
    public static byte MaxPrecision;
    public static byte MaxScale;
    public static OracleDecimal MaxValue;
    public static int MinScale;
    public static OracleDecimal MinValue;
    public static OracleDecimal NegativeOne;
    public static OracleDecimal Null;
    public static OracleDecimal One;
    private static decimal Pivalue;
    public static OracleDecimal Pi;
    public static OracleDecimal Zero;
    public bool IsNull { get; }
    public Byte[] BinData { get; }
    public bool IsInt { get; }
    public bool IsPositive { get; }
    public bool IsZero { get; }
    internal bool IsInfinity { get; }
    internal bool IsPositiveInfinity { get; }
    internal bool IsNegativeInfinity { get; }
    public string Format { get; public set; }
    public decimal Value { get; }
    internal Byte[] InternalByteRepresentation { get; }
    public OracleDecimal(Byte[] numBytes);
    public OracleDecimal(int intX);
    public OracleDecimal(long longX);
    public OracleDecimal(float floatX);
    public OracleDecimal(double doubleX);
    public OracleDecimal(decimal decimalX);
    public OracleDecimal(string numStr);
    internal OracleDecimal(Byte[] numBytes, bool bContainsLength);
    private static OracleDecimal();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public static bool Equals(OracleDecimal value1, OracleDecimal value2);
    public static bool GreaterThan(OracleDecimal value1, OracleDecimal value2);
    public static bool GreaterThanOrEqual(OracleDecimal value1, OracleDecimal value2);
    public static bool LessThan(OracleDecimal value1, OracleDecimal value2);
    public static bool LessThanOrEqual(OracleDecimal value1, OracleDecimal value2);
    public static bool NotEquals(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal Max(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal Min(OracleDecimal value1, OracleDecimal value2);
    public static bool op_Equality(OracleDecimal value1, OracleDecimal value2);
    public static bool op_GreaterThan(OracleDecimal value1, OracleDecimal value2);
    public static bool op_GreaterThanOrEqual(OracleDecimal value1, OracleDecimal value2);
    public static bool op_LessThan(OracleDecimal value1, OracleDecimal value2);
    public static bool op_LessThanOrEqual(OracleDecimal value1, OracleDecimal value2);
    public static bool op_Inequality(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal op_Addition(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal op_Subtraction(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal op_UnaryNegation(OracleDecimal value1);
    public static OracleDecimal op_Multiply(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal op_Division(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal op_Modulus(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal op_Explicit(string numStr);
    public static byte op_Explicit(OracleDecimal value1);
    public static short op_Explicit(OracleDecimal value1);
    public static int op_Explicit(OracleDecimal value1);
    public static long op_Explicit(OracleDecimal value1);
    public static float op_Explicit(OracleDecimal value1);
    public static double op_Explicit(OracleDecimal value1);
    public static decimal op_Explicit(OracleDecimal value1);
    public static OracleDecimal op_Explicit(double value1);
    public static OracleDecimal op_Implicit(int value1);
    public static OracleDecimal op_Implicit(long value1);
    public static OracleDecimal op_Implicit(decimal value1);
    public static OracleDecimal Abs(OracleDecimal value1);
    public static OracleDecimal Add(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal AdjustScale(OracleDecimal value1, int digits, bool fRound);
    public static OracleDecimal Ceiling(OracleDecimal value1);
    public static OracleDecimal ConvertToPrecScale(OracleDecimal value1, int precision, int scale);
    public static OracleDecimal Divide(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal Floor(OracleDecimal value1);
    public static OracleDecimal Mod(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal Multiply(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal Negate(OracleDecimal value1);
    public static OracleDecimal Parse(string numStr);
    public static OracleDecimal SetPrecision(OracleDecimal value1, int precision);
    internal static OracleDecimal SetPrecisionNoRound(OracleDecimal value1, int precision);
    public static OracleDecimal Round(OracleDecimal value1, int decplace);
    public static OracleDecimal Shift(OracleDecimal value1, int decplace);
    public static int Sign(OracleDecimal value1);
    public static OracleDecimal Sqrt(OracleDecimal value1);
    public static OracleDecimal Subtract(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal Truncate(OracleDecimal value1, int position);
    public static OracleDecimal Exp(OracleDecimal value1);
    public static OracleDecimal Pow(OracleDecimal value1, int power);
    public static OracleDecimal Pow(OracleDecimal value1, OracleDecimal power);
    public static OracleDecimal Log(OracleDecimal value1);
    public static OracleDecimal Log(OracleDecimal value1, int logBase);
    public static OracleDecimal Log(OracleDecimal value1, OracleDecimal logBase);
    public static OracleDecimal Acos(OracleDecimal value1);
    public static OracleDecimal Asin(OracleDecimal value1);
    public static OracleDecimal Atan(OracleDecimal value1);
    public static OracleDecimal Atan2(OracleDecimal value1, OracleDecimal value2);
    public static OracleDecimal Cos(OracleDecimal value1);
    public static OracleDecimal Sin(OracleDecimal value1);
    public static OracleDecimal Tan(OracleDecimal value1);
    public static OracleDecimal Cosh(OracleDecimal value1);
    public static OracleDecimal Sinh(OracleDecimal value1);
    public static OracleDecimal Tanh(OracleDecimal value1);
    public sealed virtual bool get_IsNull();
    public Byte[] get_BinData();
    public bool get_IsInt();
    public bool get_IsPositive();
    public bool get_IsZero();
    internal bool get_IsInfinity();
    internal bool get_IsPositiveInfinity();
    internal bool get_IsNegativeInfinity();
    public string get_Format();
    public void set_Format(string value);
    public decimal get_Value();
    public byte ToByte();
    public short ToInt16();
    public int ToInt32();
    public long ToInt64();
    public float ToSingle();
    public double ToDouble();
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static OracleDecimal SetPi();
    internal static OracleDecimal GetMaxValue();
    internal static OracleDecimal GetMinValue();
    internal static OracleDecimal GetPosInfinity();
    internal static OracleDecimal GetNegInfinity();
    internal static OracleDecimal GetNaN();
    internal static int Compare(OracleDecimal value1, OracleDecimal value2);
    internal static void ToBytes(string numStr, Byte[]& decimalByteRep, Int32& numberType, Boolean& bPositive, Boolean& bZero);
    internal Byte[] get_InternalByteRepresentation();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class Oracle.ManagedDataAccess.Types.OracleIntervalDS : ValueType {
    private static UInt32 INTERVALDSOFFSET;
    private static UInt32 INTERVALDAYOFFSET;
    private static int MAXLEADPREC;
    private static UInt32 INTERVALDAYOFFSET_REGIDFLAG;
    private static UInt32 LDIREGIDSET;
    internal static UInt32 LDIREGIDFLAG;
    internal static short MaxArrSize;
    internal static byte IDSType;
    internal static byte DAY;
    internal static byte HOUR;
    internal static byte MINUTE;
    internal static byte SECOND;
    internal static byte MILLISECOND;
    internal static byte FSECOND;
    internal static byte MaxStrLen;
    private bool m_bNotNull;
    private byte m_dayPrec;
    private byte m_fSecondPrec;
    private Byte[] m_byteRepresentation;
    public static OracleIntervalDS Null;
    internal int initialZoneId;
    public static OracleIntervalDS MaxValue;
    public static OracleIntervalDS MinValue;
    public static OracleIntervalDS Zero;
    public Byte[] BinData { get; }
    public bool IsNull { get; }
    public TimeSpan Value { get; }
    public int Days { get; }
    public int Hours { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public double Milliseconds { get; }
    public int Nanoseconds { get; }
    public double TotalDays { get; }
    internal Byte[] InternalByteRepresentation { get; }
    public OracleIntervalDS(Byte[] binData);
    public OracleIntervalDS(int days, int hours, int minutes, int seconds, int nanoseconds);
    public OracleIntervalDS(int days, int hours, int minutes, int seconds, double milliseconds);
    public OracleIntervalDS(TimeSpan data);
    public OracleIntervalDS(double totalDays);
    public OracleIntervalDS(string intervalStr);
    internal OracleIntervalDS(Byte[] binData, int dayPrecision, int fsecondPrecision, bool bCopyData);
    internal OracleIntervalDS(Byte[] binData, bool bCopyData);
    private static OracleIntervalDS();
    public Byte[] get_BinData();
    public sealed virtual bool get_IsNull();
    public TimeSpan get_Value();
    public int get_Days();
    public int get_Hours();
    public int get_Minutes();
    public int get_Seconds();
    public double get_Milliseconds();
    public int get_Nanoseconds();
    public double get_TotalDays();
    public static bool Equals(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool GreaterThan(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool GreaterThanOrEqual(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool LessThan(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool LessThanOrEqual(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool NotEquals(OracleIntervalDS value1, OracleIntervalDS value2);
    public static OracleIntervalDS Parse(string intervalStr);
    public static OracleIntervalDS SetPrecision(OracleIntervalDS value1, int dayPrecision, int fracSecPrecision);
    public static bool op_Equality(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool op_GreaterThan(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool op_GreaterThanOrEqual(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool op_LessThan(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool op_LessThanOrEqual(OracleIntervalDS value1, OracleIntervalDS value2);
    public static bool op_Inequality(OracleIntervalDS value1, OracleIntervalDS value2);
    public static OracleIntervalDS op_Addition(OracleIntervalDS value1, OracleIntervalDS value2);
    public static OracleIntervalDS op_Subtraction(OracleIntervalDS value1, OracleIntervalDS value2);
    public static OracleIntervalDS op_UnaryNegation(OracleIntervalDS value1);
    public static OracleIntervalDS op_Multiply(OracleIntervalDS value1, int multiplier);
    public static OracleIntervalDS op_Division(OracleIntervalDS value1, int divisor);
    public static OracleIntervalDS op_Explicit(string intervalStr);
    public static TimeSpan op_Explicit(OracleIntervalDS value1);
    public static OracleIntervalDS op_Implicit(TimeSpan value1);
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal Byte[] ToBytes(string intervalStr);
    internal static int GetIDSData(Byte[] byteRepresentation, byte idsComponent);
    internal static void GetIDSData(Byte[] byteRepresentation, Int32& days, Int32& hours, Int32& minutes, Int32& seconds, Int32& fseconds, int offset);
    internal static decimal IntervalDSToTicks(Byte[] byteRepresentation);
    internal static TimeSpan GetTimeSpan(Byte[] byteRepresentation, OracleDbType oraType, int dataOffset, int dataLength);
    internal static OracleIntervalDS GetOracleIntervalDS(int days, int hours, int minutes, int seconds, int nanoseconds);
    internal Byte[] get_InternalByteRepresentation();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class Oracle.ManagedDataAccess.Types.OracleIntervalYM : ValueType {
    private static UInt32 INTYMYEAROFFSET;
    private static UInt32 INTYMMONTHOFFSET;
    private bool m_bNotNull;
    private byte m_yearPrec;
    private Byte[] m_byteRepresentation;
    internal static short MaxArrSize;
    internal static byte IYMType;
    internal static byte YEAR;
    internal static byte MONTH;
    public static OracleIntervalYM MaxValue;
    public static OracleIntervalYM MinValue;
    public static OracleIntervalYM Zero;
    public static OracleIntervalYM Null;
    public Byte[] BinData { get; }
    public bool IsNull { get; }
    public long Value { get; }
    public int Years { get; }
    public int Months { get; }
    public double TotalYears { get; }
    internal Byte[] InternalByteRepresentation { get; }
    public OracleIntervalYM(int years, int months);
    public OracleIntervalYM(long totalMonths);
    public OracleIntervalYM(double totalYears);
    public OracleIntervalYM(string intervalStr);
    public OracleIntervalYM(Byte[] binData);
    internal OracleIntervalYM(Byte[] binData, int precision, bool bCopyData);
    internal OracleIntervalYM(Byte[] binData, bool bCopyData);
    private static OracleIntervalYM();
    public Byte[] get_BinData();
    public sealed virtual bool get_IsNull();
    public long get_Value();
    public int get_Years();
    public int get_Months();
    public double get_TotalYears();
    public static bool Equals(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool GreaterThan(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool GreaterThanOrEqual(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool LessThan(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool LessThanOrEqual(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool NotEquals(OracleIntervalYM value1, OracleIntervalYM value2);
    public static OracleIntervalYM Parse(string intervalStr);
    public static OracleIntervalYM SetPrecision(OracleIntervalYM value1, int yearPrecision);
    public static bool op_Equality(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool op_GreaterThan(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool op_GreaterThanOrEqual(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool op_LessThan(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool op_LessThanOrEqual(OracleIntervalYM value1, OracleIntervalYM value2);
    public static bool op_Inequality(OracleIntervalYM value1, OracleIntervalYM value2);
    public static OracleIntervalYM op_Addition(OracleIntervalYM value1, OracleIntervalYM value2);
    public static OracleIntervalYM op_Subtraction(OracleIntervalYM value1, OracleIntervalYM value2);
    public static OracleIntervalYM op_UnaryNegation(OracleIntervalYM value1);
    public static OracleIntervalYM op_Multiply(OracleIntervalYM value1, int multiplier);
    public static OracleIntervalYM op_Division(OracleIntervalYM value1, int divisor);
    public static OracleIntervalYM op_Explicit(string intervalStr);
    public static long op_Explicit(OracleIntervalYM value1);
    public static OracleIntervalYM op_Implicit(long months);
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal Byte[] ToBytes(string intervalYM);
    internal static int GetIYMData(Byte[] byteRepresentation, byte iymComponent, int dataOffset);
    internal static long GetLong(Byte[] byteRepresentation, OracleDbType oraType, int dataOffset, int dataLength);
    internal static long GetTotalMonth(OracleIntervalYM value);
    internal Byte[] get_InternalByteRepresentation();
}
public class Oracle.ManagedDataAccess.Types.OracleNullValueException : OracleTypeException {
    public OracleNullValueException(string message);
    internal OracleNullValueException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("384")]
public class Oracle.ManagedDataAccess.Types.OracleObjectMappingAttribute : Attribute {
    internal int m_attrIndex;
    internal string m_attrName;
    public int AttributeIndex { get; }
    public string AttributeName { get; }
    private static OracleObjectMappingAttribute();
    public OracleObjectMappingAttribute(int attrIndex);
    public OracleObjectMappingAttribute(string attrName);
    public int get_AttributeIndex();
    public string get_AttributeName();
}
public class Oracle.ManagedDataAccess.Types.OracleRef : MarshalByRefObject {
    private static string SQL_GetUDTFromRef;
    private static string SQL_UpdateUDTFromRef;
    private static string SQL_DeleteRef;
    private static string SQL_LockRef;
    internal bool m_bNotNull;
    internal bool m_bDisposed;
    internal bool m_bClosed;
    internal object m_lock;
    internal Byte[] m_refLocator;
    internal string m_refHexString;
    internal OracleConnection m_conn;
    internal OracleCommand m_cmd;
    internal string m_typeName;
    public static OracleRef Null;
    public OracleConnection Connection { get; }
    public bool IsNull { get; }
    public string Value { get; }
    internal OracleRef(OracleConnection conn, string typeName, Byte[] refLocator);
    private static OracleRef();
    protected virtual override void Finalize();
    public OracleConnection get_Connection();
    public sealed virtual bool get_IsNull();
    public string get_Value();
    public bool IsEqual(OracleRef obj);
    public sealed virtual object Clone();
    public void Delete();
    public sealed virtual void Dispose();
    public object GetCustomObject();
    public string GetString();
    public void Update(object customObj);
    internal static string ConvertBytesToHexString(Byte[] refBytes);
    internal static int GetHexByte(char c);
    internal static Byte[] ConvertHexStrToBytes(string hex);
    private static bool ByteArrayCompare(Byte[] a1, Byte[] a2);
    internal OracleCommand GetCmd(string cmdText);
    internal void SetRefLocator(Byte[] refLocator);
    internal void Dispose(bool disposing);
    internal void Close();
}
public class Oracle.ManagedDataAccess.Types.OracleRefCursor : MarshalByRefObject {
    internal OracleRefCursorImpl m_refCursorImpl;
    internal OracleConnection m_connection;
    private OracleDataReader m_cachedReader;
    private long m_fetchSize;
    private bool m_bNotNull;
    internal bool m_bReaderGivenToRefCursor;
    internal static int MAX_SIZE;
    private long m_initialLongFS;
    private long m_clientInitialLOBFS;
    private long m_internalInitialLOBFS;
    private long m_internalInitialJSONFS;
    private bool m_isFromEF;
    internal Int64[] m_snapshotSCN;
    internal OracleIntervalDS m_sessionTimeZone;
    internal bool m_bClosed;
    internal bool m_bDisposed;
    private object m_syncObj;
    private object lockRefCursor;
    internal bool m_bCanRecordNewCall;
    internal RefCursorInfo m_refCursorInfo;
    public static OracleRefCursor Null;
    public OracleConnection Connection { get; }
    public long FetchSize { get; public set; }
    public long RowSize { get; }
    public bool IsNull { get; }
    internal OracleRefCursor(OracleConnection connection, OracleRefCursorImpl refCursorImpl, OracleIntervalDS sessionTimeZone, string commandText, string paramPosOrName, long initialLongFS, long clientInitialLobFS, long internalInitialLOBFS, long internalInitialJSONFS, Int64[] scnFromExecution, bool bIsFromEF, bool bImplicitRefCursor);
    private static OracleRefCursor();
    private sealed virtual override void Oracle.ManagedDataAccess.Client.IReplayBase.PulginNewObject(object newObject);
    public OracleConnection get_Connection();
    public void set_FetchSize(long value);
    public long get_FetchSize();
    internal void SetFetchSize(long fetchSize, CallHistoryRecord chr);
    public long get_RowSize();
    public OracleDataReader GetDataReader();
    internal OracleDataReader GetDataReader(bool fillRequest);
    internal void Close();
    internal void ConnectionClose();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual bool get_IsNull();
}
[XmlSchemaProviderAttribute("GetXsdType")]
[DefaultMemberAttribute("Item")]
public class Oracle.ManagedDataAccess.Types.OracleString : ValueType {
    private string m_value;
    private bool m_bNotNull;
    private bool m_bCaseIgnored;
    public static OracleString Null;
    public bool IsNull { get; }
    public char Item { get; }
    public int Length { get; }
    public string Value { get; }
    public bool IsCaseIgnored { get; public set; }
    public OracleString(string data);
    public OracleString(string data, bool isCaseIgnored);
    public OracleString(Byte[] bytes, bool isUnicode);
    public OracleString(Byte[] bytes, bool isUnicode, bool isCaseIgnored);
    public OracleString(Byte[] bytes, int index, int count, bool isUnicode);
    public OracleString(Byte[] bytes, int index, int count, bool isUnicode, bool isCaseIgnored);
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public sealed virtual bool get_IsNull();
    public char get_Item(int index);
    public int get_Length();
    public string get_Value();
    public bool get_IsCaseIgnored();
    public void set_IsCaseIgnored(bool value);
    public OracleString Clone();
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Byte[] GetNonUnicodeBytes();
    public Byte[] GetUnicodeBytes();
    public virtual string ToString();
    public static OracleString Concat(OracleString value1, OracleString value2);
    public static bool Equals(OracleString value1, OracleString value2);
    public static bool GreaterThan(OracleString value1, OracleString value2);
    public static bool GreaterThanOrEqual(OracleString value1, OracleString value2);
    public static bool LessThan(OracleString value1, OracleString value2);
    public static bool LessThanOrEqual(OracleString value1, OracleString value2);
    public static bool NotEquals(OracleString value1, OracleString value2);
    public static bool op_Equality(OracleString value1, OracleString value2);
    public static bool op_GreaterThan(OracleString value1, OracleString value2);
    public static bool op_GreaterThanOrEqual(OracleString value1, OracleString value2);
    public static bool op_LessThan(OracleString value1, OracleString value2);
    public static bool op_LessThanOrEqual(OracleString value1, OracleString value2);
    public static bool op_Inequality(OracleString value1, OracleString value2);
    public static OracleString op_Addition(OracleString value1, OracleString value2);
    public static string op_Explicit(OracleString value1);
    public static OracleString op_Implicit(string value1);
    internal static int StringCompare(OracleString oraStr1, OracleString oraStr2);
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class Oracle.ManagedDataAccess.Types.OracleTimeStamp : ValueType {
    private bool m_bNotNull;
    private int m_fSecondPrec;
    internal Byte[] m_byteRepresentation;
    private int m_year;
    private int m_month;
    private int m_day;
    private int m_hour;
    private int m_minute;
    private int m_second;
    private int m_nanosecond;
    internal static byte MaxArrSize;
    public static OracleTimeStamp MaxValue;
    public static OracleTimeStamp MinValue;
    public static OracleTimeStamp Null;
    public Byte[] BinData { get; }
    public bool IsNull { get; }
    public DateTime Value { get; }
    public int Year { get; }
    public int Month { get; }
    public int Day { get; }
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    public double Millisecond { get; }
    public int Nanosecond { get; }
    internal Byte[] InternalByteRepresentation { get; }
    public OracleTimeStamp(int year, int month, int day, int hour, int minute, int second, int nanosecond);
    public OracleTimeStamp(int year, int month, int day, int hour, int minute, int second, double millisecond);
    public OracleTimeStamp(int year, int month, int day);
    public OracleTimeStamp(int year, int month, int day, int hour, int minute, int second);
    public OracleTimeStamp(DateTime date);
    public OracleTimeStamp(Byte[] binData);
    public OracleTimeStamp(string tsStr);
    internal OracleTimeStamp(Byte[] binData, int fSecondPrec);
    internal OracleTimeStamp(Byte[] binData, bool bCopyData);
    internal OracleTimeStamp(Byte[] binData, int dataOffset, int dataLength, bool bCopyData);
    private static OracleTimeStamp();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public Byte[] get_BinData();
    public sealed virtual bool get_IsNull();
    public DateTime get_Value();
    public int get_Year();
    public int get_Month();
    public int get_Day();
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public double get_Millisecond();
    public int get_Nanosecond();
    public OracleTimeStamp AddYears(int years);
    public OracleTimeStamp AddMonths(long months);
    public OracleTimeStamp AddDays(double days);
    public OracleTimeStamp AddHours(double hours);
    public OracleTimeStamp AddMinutes(double minutes);
    public OracleTimeStamp AddSeconds(double seconds);
    public OracleTimeStamp AddMilliseconds(double milliseconds);
    public OracleTimeStamp AddNanoseconds(long nanoseconds);
    public virtual string ToString();
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public OracleIntervalDS GetDaysBetween(OracleTimeStamp value1);
    public OracleIntervalYM GetYearsBetween(OracleTimeStamp value1);
    public OracleDate ToOracleDate();
    public OracleTimeStampLTZ ToOracleTimeStampLTZ();
    public OracleTimeStampTZ ToOracleTimeStampTZ();
    public static bool Equals(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool GreaterThan(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool GreaterThanOrEqual(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool LessThan(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool LessThanOrEqual(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool NotEquals(OracleTimeStamp value1, OracleTimeStamp value2);
    public static OracleTimeStamp GetSysDate();
    public static OracleTimeStamp Parse(string tsStr);
    public static OracleTimeStamp SetPrecision(OracleTimeStamp value1, int fracSecPrecision);
    public static bool op_Equality(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool op_GreaterThan(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool op_GreaterThanOrEqual(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool op_LessThan(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool op_LessThanOrEqual(OracleTimeStamp value1, OracleTimeStamp value2);
    public static bool op_Inequality(OracleTimeStamp value1, OracleTimeStamp value2);
    public static OracleTimeStamp op_Addition(OracleTimeStamp value1, OracleIntervalDS value2);
    public static OracleTimeStamp op_Addition(OracleTimeStamp value1, OracleIntervalYM value2);
    public static OracleTimeStamp op_Addition(OracleTimeStamp value1, TimeSpan value2);
    public static OracleTimeStamp op_Subtraction(OracleTimeStamp value1, OracleIntervalDS value2);
    public static OracleTimeStamp op_Subtraction(OracleTimeStamp value1, OracleIntervalYM value2);
    public static OracleTimeStamp op_Subtraction(OracleTimeStamp value1, TimeSpan value2);
    public static OracleTimeStamp op_Explicit(string tsStr);
    public static DateTime op_Explicit(OracleTimeStamp value1);
    public static OracleTimeStamp op_Implicit(OracleDate value1);
    public static OracleTimeStamp op_Explicit(OracleTimeStampLTZ value1);
    public static OracleTimeStamp op_Explicit(OracleTimeStampTZ value1);
    public static OracleTimeStamp op_Implicit(DateTime value1);
    internal static OracleTimeStamp AddDayTimeToTimeStamp(Byte[] byteRepresentation, object value, byte tsComponent);
    internal static OracleTimeStamp AddYearMonthToTimeStamp(Byte[] byteRepresentation, int yearToBeAdded, long monthToBeAdded);
    private void FromString(string tsStr);
    internal Byte[] get_InternalByteRepresentation();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class Oracle.ManagedDataAccess.Types.OracleTimeStampLTZ : ValueType {
    internal Byte[] m_byteRepresentation;
    private int m_fSecondPrec;
    private bool m_bNotNull;
    private int m_year;
    private int m_month;
    private int m_day;
    private int m_hour;
    private int m_minute;
    private int m_second;
    private int m_nanosecond;
    internal static byte MaxArrSize;
    public static OracleTimeStampLTZ MaxValue;
    public static OracleTimeStampLTZ MinValue;
    public static OracleTimeStampLTZ Null;
    public bool IsNull { get; }
    public Byte[] BinData { get; }
    public DateTime Value { get; }
    public int Year { get; }
    public int Month { get; }
    public int Day { get; }
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    public double Millisecond { get; }
    public int Nanosecond { get; }
    internal Byte[] InternalByteRepresentation { get; }
    public OracleTimeStampLTZ(int year, int month, int day, int hour, int minute, int second, int nanosecond);
    public OracleTimeStampLTZ(int year, int month, int day, int hour, int minute, int second, double millisecond);
    public OracleTimeStampLTZ(int year, int month, int day);
    public OracleTimeStampLTZ(int year, int month, int day, int hour, int minute, int second);
    public OracleTimeStampLTZ(DateTime data);
    public OracleTimeStampLTZ(Byte[] binData);
    public OracleTimeStampLTZ(string tsStr);
    internal OracleTimeStampLTZ(Byte[] binData, int fSecondPrec);
    internal OracleTimeStampLTZ(Byte[] binData, bool bCopyData);
    internal OracleTimeStampLTZ(Byte[] binData, int dataOffset, int dataLength, TimeSpan localTimeAdjustment, bool bCopyData);
    private static OracleTimeStampLTZ();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public sealed virtual bool get_IsNull();
    public Byte[] get_BinData();
    public DateTime get_Value();
    public int get_Year();
    public int get_Month();
    public int get_Day();
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public double get_Millisecond();
    public int get_Nanosecond();
    public OracleTimeStampLTZ AddYears(int years);
    public OracleTimeStampLTZ AddMonths(long months);
    public OracleTimeStampLTZ AddDays(double days);
    public OracleTimeStampLTZ AddHours(double hours);
    public OracleTimeStampLTZ AddMinutes(double minutes);
    public OracleTimeStampLTZ AddSeconds(double seconds);
    public OracleTimeStampLTZ AddMilliseconds(double milliseconds);
    public OracleTimeStampLTZ AddNanoseconds(long nanoseconds);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public OracleIntervalDS GetDaysBetween(OracleTimeStampLTZ value1);
    public OracleIntervalYM GetYearsBetween(OracleTimeStampLTZ value1);
    public OracleDate ToOracleDate();
    public OracleTimeStamp ToOracleTimeStamp();
    public OracleTimeStampTZ ToOracleTimeStampTZ();
    public virtual string ToString();
    public OracleTimeStampTZ ToUniversalTime();
    public static bool Equals(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool GreaterThan(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool GreaterThanOrEqual(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool LessThan(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool LessThanOrEqual(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool NotEquals(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static OracleTimeStampLTZ GetSysDate();
    public static string GetLocalTimeZoneName();
    public static TimeSpan GetLocalTimeZoneOffset();
    public static OracleTimeStampLTZ Parse(string tsStr);
    public static OracleTimeStampLTZ SetPrecision(OracleTimeStampLTZ value1, int fracSecPrecision);
    public static bool op_Equality(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool op_GreaterThan(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool op_GreaterThanOrEqual(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool op_LessThan(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool op_LessThanOrEqual(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static bool op_Inequality(OracleTimeStampLTZ value1, OracleTimeStampLTZ value2);
    public static OracleTimeStampLTZ op_Addition(OracleTimeStampLTZ value1, OracleIntervalDS value2);
    public static OracleTimeStampLTZ op_Addition(OracleTimeStampLTZ value1, OracleIntervalYM value2);
    public static OracleTimeStampLTZ op_Addition(OracleTimeStampLTZ value1, TimeSpan value2);
    public static OracleTimeStampLTZ op_Subtraction(OracleTimeStampLTZ value1, OracleIntervalDS value2);
    public static OracleTimeStampLTZ op_Subtraction(OracleTimeStampLTZ value1, OracleIntervalYM value2);
    public static OracleTimeStampLTZ op_Subtraction(OracleTimeStampLTZ value1, TimeSpan value2);
    public static OracleTimeStampLTZ op_Explicit(string tsStr);
    public static DateTime op_Explicit(OracleTimeStampLTZ value1);
    public static OracleTimeStampLTZ op_Implicit(OracleDate value1);
    public static OracleTimeStampLTZ op_Explicit(OracleTimeStamp value1);
    public static OracleTimeStampLTZ op_Explicit(OracleTimeStampTZ value1);
    public static OracleTimeStampLTZ op_Implicit(DateTime value1);
    internal static OracleTimeStampLTZ AddDayTimeToTimeStampLTZ(Byte[] byteRepresentation, object value, byte tsComponent);
    internal static OracleTimeStampLTZ AddYearMonthToTimeStampLTZ(Byte[] byteRepresentation, int yearToBeAdded, long monthToBeAdded);
    private void FromString(string tsStr);
    internal Byte[] get_InternalByteRepresentation();
}
[XmlSchemaProviderAttribute("GetXsdType")]
public class Oracle.ManagedDataAccess.Types.OracleTimeStampTZ : ValueType {
    internal Byte[] m_byteRepresentation;
    private bool m_bNotNull;
    private int m_fSecondPrec;
    private string m_timeZone;
    private int m_year;
    private int m_month;
    private int m_day;
    private int m_hour;
    private int m_minute;
    private int m_second;
    private int m_nanosecond;
    private int m_hourTZ;
    private int m_minuteTZ;
    private int m_zoneID;
    internal static byte MaxArrSize;
    public static OracleTimeStampTZ MaxValue;
    public static OracleTimeStampTZ MinValue;
    public static OracleTimeStampTZ Null;
    public bool IsNull { get; }
    public DateTime Value { get; }
    public Byte[] BinData { get; }
    public int Year { get; }
    public int Month { get; }
    public int Day { get; }
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    public double Millisecond { get; }
    public int Nanosecond { get; }
    public string TimeZone { get; }
    internal Byte[] InternalByteRepresentation { get; }
    public OracleTimeStampTZ(int year, int month, int day, int hour, int minute, int second, int nanosecond, string timeZone);
    public OracleTimeStampTZ(int year, int month, int day, int hour, int minute, int second, int nanosecond);
    public OracleTimeStampTZ(int year, int month, int day, int hour, int minute, int second, double millisecond, string timeZone);
    public OracleTimeStampTZ(int year, int month, int day, int hour, int minute, int second, double millisecond);
    public OracleTimeStampTZ(int year, int month, int day, string timeZone);
    public OracleTimeStampTZ(int year, int month, int day);
    public OracleTimeStampTZ(int year, int month, int day, int hour, int minute, int second, string timeZone);
    public OracleTimeStampTZ(int year, int month, int day, int hour, int minute, int second);
    public OracleTimeStampTZ(DateTime data, string timeZone);
    public OracleTimeStampTZ(DateTime data);
    public OracleTimeStampTZ(Byte[] binData);
    public OracleTimeStampTZ(string tsStr);
    internal OracleTimeStampTZ(Byte[] binData, bool bCopyData, int dataOffset, int dataLength);
    internal OracleTimeStampTZ(Byte[] binData, int fSecondPrec);
    private static OracleTimeStampTZ();
    public static XmlQualifiedName GetXsdType(XmlSchemaSet schemaSet);
    private sealed virtual override XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
    private sealed virtual override void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
    public sealed virtual bool get_IsNull();
    public DateTime get_Value();
    public Byte[] get_BinData();
    public int get_Year();
    public int get_Month();
    public int get_Day();
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public double get_Millisecond();
    public int get_Nanosecond();
    public string get_TimeZone();
    public OracleTimeStampTZ AddYears(int years);
    public OracleTimeStampTZ AddMonths(long months);
    public OracleTimeStampTZ AddDays(double days);
    public OracleTimeStampTZ AddHours(double hours);
    public OracleTimeStampTZ AddMinutes(double minutes);
    public OracleTimeStampTZ AddSeconds(double seconds);
    public OracleTimeStampTZ AddMilliseconds(double milliseconds);
    public OracleTimeStampTZ AddNanoseconds(long nanoseconds);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public OracleIntervalDS GetDaysBetween(OracleTimeStampTZ value);
    public OracleIntervalYM GetYearsBetween(OracleTimeStampTZ value);
    public TimeSpan GetTimeZoneOffset();
    public OracleTimeStampLTZ ToLocalTime();
    public OracleDate ToOracleDate();
    public OracleTimeStamp ToOracleTimeStamp();
    public OracleTimeStampLTZ ToOracleTimeStampLTZ();
    public virtual string ToString();
    public OracleTimeStampTZ ToUniversalTime();
    public static bool Equals(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool GreaterThan(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool GreaterThanOrEqual(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool LessThan(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool LessThanOrEqual(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool NotEquals(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static OracleTimeStampTZ GetSysDate();
    public static OracleTimeStampTZ Parse(string tsStr);
    public static OracleTimeStampTZ SetPrecision(OracleTimeStampTZ value1, int fracSecPrecision);
    public static bool op_Equality(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool op_GreaterThan(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool op_GreaterThanOrEqual(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool op_LessThan(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool op_LessThanOrEqual(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static bool op_Inequality(OracleTimeStampTZ value1, OracleTimeStampTZ value2);
    public static OracleTimeStampTZ op_Addition(OracleTimeStampTZ value1, OracleIntervalDS value2);
    public static OracleTimeStampTZ op_Addition(OracleTimeStampTZ value1, OracleIntervalYM value2);
    public static OracleTimeStampTZ op_Addition(OracleTimeStampTZ value1, TimeSpan value2);
    public static OracleTimeStampTZ op_Subtraction(OracleTimeStampTZ value1, OracleIntervalDS value2);
    public static OracleTimeStampTZ op_Subtraction(OracleTimeStampTZ value1, OracleIntervalYM value2);
    public static OracleTimeStampTZ op_Subtraction(OracleTimeStampTZ value1, TimeSpan value2);
    public static OracleTimeStampTZ op_Explicit(string tsStr);
    public static DateTime op_Explicit(OracleTimeStampTZ value1);
    public static OracleTimeStampTZ op_Implicit(OracleDate value1);
    public static OracleTimeStampTZ op_Explicit(OracleTimeStamp value1);
    public static OracleTimeStampTZ op_Explicit(OracleTimeStampLTZ value1);
    public static OracleTimeStampTZ op_Implicit(DateTime value1);
    internal static string ConstructTimeZone(int hoursTZ, int minutesTZ);
    internal static OracleTimeStampTZ AddDayTimeToTimeStampTZ(Byte[] byteRepresentation, object value, byte tsComponent);
    internal static OracleTimeStampTZ AddYearMonthToTimeStampTZ(Byte[] byteRepresentation, int yearToBeAdded, long monthToBeAdded);
    private void FromString(string tsStr);
    internal Byte[] get_InternalByteRepresentation();
}
internal class Oracle.ManagedDataAccess.Types.OracleTimeZoneInfo : ValueType {
    internal int m_zoneId;
    internal int m_tzHours;
    internal int m_tzMinutes;
    internal OracleTimeZoneInfo(int zoneId, int tzHours, int tzMinutes);
}
public class Oracle.ManagedDataAccess.Types.OracleTruncateException : OracleTypeException {
    internal static string DefMesg;
    private static OracleTruncateException();
    public OracleTruncateException(string message);
    internal OracleTruncateException(SerializationInfo info, StreamingContext context);
    internal static string GetDefMesg();
}
public class Oracle.ManagedDataAccess.Types.OracleTypeException : SystemException {
    protected string m_mesg;
    protected int m_number;
    protected static string dataProviderName;
    public string Message { get; }
    public int Number { get; }
    public string Source { get; }
    private static OracleTypeException();
    public OracleTypeException(string message);
    protected OracleTypeException(SerializationInfo info, StreamingContext context);
    internal OracleTypeException(int mesgNum, Object[] args);
    public virtual string get_Message();
    public int get_Number();
    public virtual string get_Source();
    public virtual string ToString();
    internal static string GetTypeMsg(int errCode, Object[] args);
}
public class Oracle.ManagedDataAccess.Types.OracleUdt : object {
    internal static Dictionary`2<string, string> s_mapCustomTypeNameToUdtName;
    protected static object s_lockObj;
    internal static Hashtable s_mapUdtNameToMappingObj;
    internal static Hashtable s_mapUdtNameToFactory;
    internal static string CustomTypeName;
    internal static List`1<string> s_ODPExcludedAssembliesList;
    private static OracleUdt();
    public static bool IsDBNull(OracleConnection con, object udt, int attrIndex);
    public static bool IsDBNull(OracleConnection con, object udt, string attrName);
    public static object GetValue(OracleConnection con, object udt, int attrIndex);
    public static object GetValue(OracleConnection con, object udt, int attrIndex, Object& statusArray);
    public static object GetValue(OracleConnection con, object udt, string attrName);
    public static object GetValue(OracleConnection con, object udt, string attrName, Object& statusArray);
    public static void SetValue(OracleConnection con, object udt, int attrIndex, object value, object statusArray);
    public static void SetValue(OracleConnection con, object udt, string attrName, object value);
    public static void SetValue(OracleConnection con, object udt, int attrIndex, object value);
    public static void SetValue(OracleConnection con, object udt, string attrName, object value, object statusArray);
    private static bool IsAttributeNull(OracleConnection conn, object udt, int attrIndex);
    private static object GetData(OracleConnection conn, object udt, int attrIndex, OracleUdtStatus& dataStatus, OracleUdtStatus[]& elemArrayStatus);
    private static object GetData(OracleConnection conn, object udt, int attrIndex);
    private static void SetData(OracleConnection conn, object udt, int attrIndex, object attrValue, object udtStatus);
    internal static object GetFactory(string type, string schemaName, string dataSource);
    internal static string GetUdtName(string customTypeName, string dataSource);
    internal static void OracleUdt2();
    internal static void SetCustomTypeMappings();
    internal static bool IsExcludedAssembly(Assembly a);
    internal static bool IsExcludedAssembly(AssemblyName childAssemblyName);
    internal static ArrayList GetAllReferencedAssemblies();
    internal static object GetFactory(string typeName, string dsQualifiedName, string schemaQualifiedName, string dsQualifiedSchemaLessName);
}
public class Oracle.ManagedDataAccess.Types.OracleXmlStream : Stream {
    private bool m_bClosed;
    private long m_position;
    private OracleConnection m_connection;
    private OracleXmlType m_xmlType;
    internal OracleXmlStreamImpl m_xmlStreamImpl;
    private object lockXmlStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public OracleConnection Connection { get; }
    public long Length { get; }
    public string Value { get; }
    public long Position { get; public set; }
    public OracleXmlStream(OracleXmlType xmlType);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleXmlStream/<ReadInternalAsync>d__0")]
private ValueTask`1<int> ReadInternalAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, bool bAsync);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleXmlStream/<ReadAsyncHelper>d__2")]
internal ValueTask`1<int> ReadAsyncHelper(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public Task`1<int> ReadAsync(Char[] buffer, int offset, int count);
    public Task`1<int> ReadAsync(Char[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleXmlStream/<ReadAsyncHelper>d__5")]
internal ValueTask`1<int> ReadAsyncHelper(Char[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Oracle.ManagedDataAccess.Types.OracleXmlStream/<ReadInternalAsync>d__7")]
private ValueTask`1<int> ReadInternalAsync(Char[] buffer, int offset, int count, CancellationToken cancellationToken, bool bAsync);
    private void Initialize(OracleXmlType xmlType);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public OracleConnection get_Connection();
    public virtual long get_Length();
    public string get_Value();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public sealed virtual object Clone();
    public virtual void Close();
    public void Dispose();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    internal void CancelAsyncCommandExecution();
    public int Read(Char[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual override void Finalize();
    internal void ConnectionClose();
    private int ReadInternal(Byte[] buffer, int offset, int count, CancellationToken cancellationToken, bool bAsync);
    private int ReadInternal(Char[] buffer, int offset, int count, CancellationToken cancellationToken, bool bAsync);
}
public class Oracle.ManagedDataAccess.Types.OracleXmlType : object {
    internal OracleConnection m_connection;
    private bool m_bNotNull;
    private bool m_bClosed;
    private bool m_bPopluateSchema;
    private bool m_bIsSchemaBased;
    private bool m_bIsEmpty;
    private string m_schemaURL;
    private Byte[] m_schemaID;
    private bool m_bGotRootElement;
    private string m_rootElement;
    private object lockXmlType;
    internal OracleClob m_schemaClob;
    internal OracleXmlTypeImpl m_xmlTypeImpl;
    internal OracleCommand m_command;
    public static OracleXmlType Null;
    public OracleConnection Connection { get; }
    public bool IsEmpty { get; }
    public bool IsNull { get; }
    public bool IsSchemaBased { get; }
    public bool IsFragment { get; }
    public string RootElement { get; }
    public OracleXmlType Schema { get; }
    public string SchemaUrl { get; }
    public string Value { get; }
    public OracleXmlType(OracleConnection con, string xmlData);
    public OracleXmlType(OracleClob clob);
    public OracleXmlType(OracleConnection con, XmlReader reader);
    public OracleXmlType(OracleConnection con, XmlDocument domDoc);
    internal OracleXmlType(OracleConnection conn, OracleXmlTypeImpl xmlTypeImpl);
    internal OracleXmlType(OracleConnection con);
    internal OracleXmlType(OracleXmlType orgXmlType);
    internal OracleXmlType(OracleConnection con, string xmlData, bool bThrowException);
    private static OracleXmlType();
    protected virtual override void Finalize();
    public OracleConnection get_Connection();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsNull();
    public bool get_IsSchemaBased();
    public bool get_IsFragment();
    public string get_RootElement();
    public OracleXmlType get_Schema();
    public string get_SchemaUrl();
    public string get_Value();
    public sealed virtual void Dispose();
    public sealed virtual object Clone();
    public OracleXmlType Extract(string xpathExpr, string nsMap);
    public OracleXmlType Extract(string xpathExpr, XmlNamespaceManager nsMgr);
    public OracleXmlStream GetStream();
    public XmlDocument GetXmlDocument();
    public XmlReader GetXmlReader();
    public bool IsExists(string xpathExpr, string nsMap);
    public bool IsExists(string xpathExpr, XmlNamespaceManager nsMgr);
    public OracleXmlType Transform(OracleXmlType xsldoc, string paramMap);
    public OracleXmlType Transform(string xsldoc, string paramMap);
    public void Update(string xpathExpr, string nsMap, OracleXmlType val);
    public void Update(string xpathExpr, XmlNamespaceManager nsMgr, OracleXmlType val);
    public void Update(string xpathExpr, string nsMap, string val);
    public void Update(string xpathExpr, XmlNamespaceManager nsMgr, string val);
    public bool Validate(string schemaUrl);
    internal void Dispose(bool disposing);
    internal void Close();
    internal void Set(OracleConnection conn, OraXmlTypeHeader xmlTypeHeader, OraXmlTypeData xmlTypeData);
    internal void ConnectionClose();
    internal bool GetSchemaInfo(bool bGetSchemaValue, String& xmlSchemaValue);
}
internal static class Oracle.ManagedDataAccess.Types.TimeSpanConv : object {
    internal static int FSecondsPerMilliSecond;
    internal static int FSecondsPerSecond;
    internal static int FSecondsPerTick;
    internal static double TicksPerFSecond;
    internal static string IsoStrIntervalDsZero;
    internal static string IsoStrIntervalYmZero;
    internal static string ToString(Byte[] byteRep, int yearPrec);
    internal static string ToString(Byte[] byteRep, int dayPrec, int fSecondPrec);
    internal static string ToIsoString(Byte[] byteRep, int yearPrec);
    internal static string ToIsoString(Byte[] byteRep, int dayPrec, int fSecondPrec);
}
internal static class Oracle.ManagedDataAccess.Types.TimeStamp : object {
    internal static short DaysPerYear;
    internal static short MaxYear;
    internal static byte MaxMonth;
    internal static byte MaxDay;
    internal static byte MaxHour;
    internal static byte MaxMinute;
    internal static byte MaxSecond;
    internal static double MaxMillisecond;
    internal static int MaxFSecond;
    internal static int MaxTZHours;
    internal static int MaxTZMinutes;
    internal static short MinYear;
    internal static byte MinMonth;
    internal static byte MinDay;
    internal static byte MinHour;
    internal static byte MinMinute;
    internal static byte MinSecond;
    internal static double MinMillisecond;
    internal static byte MinFSecond;
    internal static int MinTZHours;
    internal static int MinTZMinutes;
    internal static byte MaxFSecondPrec;
    internal static byte MinFSecondPrec;
    private static int MaxTZHFormatLength;
    internal static int MinTransYear;
    internal static byte YEAR;
    internal static byte MONTH;
    internal static byte DAY;
    internal static byte HOUR;
    internal static byte MINUTE;
    internal static byte SECOND;
    internal static byte MILLISECOND;
    internal static byte FSECOND;
    internal static byte TZHOURS;
    internal static byte TZMINUTES;
    internal static byte TIMESPAN;
    internal static byte DAYTOSECOND;
    private static byte DLSBIT;
    private static byte REGLOCBIT;
    private static byte NOTREGLOCBIT;
    private static byte MINLOCBIT;
    private static byte NOTMINLOCBIT;
    private static byte REGIDBIT;
    private static int OFFSET_HOUR;
    private static int OFFSET_MINUTE;
    internal static OracleTimeZone s_timeZoneObj;
    internal static TZInfo LocalTZOffset;
    private static TimeStamp();
    private static int setHighOrderbits(int ID);
    private static int setLowOrderbits(int ID);
    private static int getHighOrderbits(int hour);
    private static int getLowOrderbits(int minute);
    internal static bool IsValidDateTime(int year, int month, int day, int hour, int minute, int second, int nanosecond);
    internal static bool IsValidTimeZone(int hourTZ, int minuteTZ);
    internal static string GetZoneName(int zoneId);
    internal static int GetZoneId(string zoneName);
    internal static bool IsValidZoneName(string zoneName);
    internal static bool IsValidZoneId(int id);
    internal static void InitializelatestTZversion();
    internal static void ProcessTimeZone(int year, int month, int day, int hour, int minute, int second, String& timeZone, Int32& hoursTZ, Int32& minutesTZ, Int32& zoneID);
    internal static void GetTimeZoneOffsetInfo(Nullable`1<DateTime> date, Byte[] byteRep, Int32& hourTZ, Int32& minuteTZ, Int32& zoneID, Boolean& dst, bool isDataInLocalTime, int offset, int length);
    internal static int GetFsecond(DateTime date);
    internal static int GetDays(int month, int year);
    internal static int GetDaysBetweenMonth(int lowMonth, int lowDays, int upMonth, int upDays, int year);
    internal static OracleIntervalDS GetDaysBetweenTimeStamp(Byte[] byteRepresentation, int lesserHour, int lesserMinute, int lesserSecond, int lesserNanosecond, int upYear, int upMonth, int upDay, int lowYear, int lowMonth, int lowDay, bool isPositive, OracleDbType oraType);
    internal static OracleIntervalYM GetYearsBetweenTimeStamp(int sumDay, int sumMonth, int sumYear, int passYear, bool isPositive);
    internal static Byte[] ConstructTimeStampByteRep(int maxArrSize, int year, int month, int day, int hour, int minute, int second, int nanosecond, int hoursTZ, int minutesTZ, int zoneID);
    internal static Byte[] ConstructByteArrayTS(int year, int month, int day, int hour, int minute, int second, int nanosecond);
    internal static Byte[] ConstructUTCByteArray(int year, int month, int day, int hour, int minute, int second, int nanosecond, int hoursTZ, int minutesTZ, int zoneID);
    internal static Byte[] AddYearMonthToTimeStamp(Byte[] byteRepresentation, int yearToBeAdded, long monthToBeAdded, OracleDbType oraType);
    internal static Byte[] AddDayTimeToTimeStamp(Byte[] byteRepresentation, object value, byte tsComponent, OracleDbType oraType);
    internal static void GetPositiveTimeStampValues(Int32& year, Int64& month, Int64& days, Int64& hours, Int64& minutes, Int64& seconds, Int64& nanoseconds);
    internal static void AdjustTimeStampValues(Int32& year, Int32& month, Int32& days, Int32& hours, Int32& minutes, Int32& seconds, Int32& nanoseconds);
    internal static int GetTSData(Byte[] byteRep, byte tsComponent);
    internal static int GetTSTZData(Byte[] byteRep, byte tsComponent);
    internal static void ExtractTimeStampValues(double data, byte tsComponent, Int32& day, Int32& hour, Int32& minute, Int32& second, Int32& nanosecond);
    internal static void ExtractTimeStampValuesFromByteArray(Byte[] binData, Int32& year, Int32& month, Int32& day, Int32& hour, Int32& minute, Int32& second, Int32& nanosecond, Int32& hourTZ, Int32& minuteTZ, Int32& zoneID, TSType tsType);
    internal static void ExtractTimeStampTZValuesFromByteArray(Byte[] binData, Int32& year, Int32& month, Int32& day, Int32& hour, Int32& minute, Int32& second, Int32& nanosecond, Int32& hourTZ, Int32& minuteTZ, Int32& zoneID);
    internal static TimeSpan GetLTZOffset(Byte[] dbTimeZoneBytes, OracleIntervalDS sessionTimeZone);
    internal static Byte[] GetAdjustedTimeStampLTZ(Byte[] bindata, TimeSpan adjTimeZone, bool isSend);
    internal static Byte[] GetLocalTimeFromUTCByteRep(Byte[] bindata);
    internal static void GetUTCByteRepFromLocalArray(Byte[] bindata, Byte[]& utcArray, Nullable`1& dateObj, bool returnAsDateTime);
    internal static void ToUniversalTime(Int32& year, Int32& month, Int32& day, Int32& hour, Int32& minute, Int32& second, Int32& nanosecond, Int32& hoursTZ, Int32& minutesTZ);
    internal static OracleTimeStampLTZ ToLocalTime(int year, int month, int day, int hour, int minute, int second, int nanosecond, int hoursTZ, int minutesTZ);
    internal static Byte[] ConvertLTZDataToDBTime(Byte[] ltzByteArray, Nullable`1<OracleTimeZoneInfo> dbTimeZoneBytes, OracleIntervalDS sessionTimeZone);
    internal static void ConvertDBTimeToLTZData(Byte[] dbByteArray, Nullable`1<OracleTimeZoneInfo> dbTimeZoneBytes, OracleIntervalDS sessionTimeZone, Byte[]& byteRep, Nullable`1& dateObj, bool returnAsDateTimeObj);
    internal static TZInfo GetLocalTZOffset();
    internal static OracleTimeZoneInfo GetTimeZoneInfo(Byte[] dbTimeZoneBytes);
}
internal static class Oracle.ManagedDataAccess.Types.TimeStampConv : object {
    internal static int FSecondsPerMilliSecond;
    internal static int FSecondsPerTick;
}
internal enum Oracle.ManagedDataAccess.Types.TSType : Enum {
    public int value__;
    public static TSType TimeStamp;
    public static TSType TimeStampLTZ;
    public static TSType UtcTimeTZ;
    public static TSType LocalTimeTZ;
}
internal class Oracle.ManagedDataAccess.Types.TZInfo : ValueType {
    internal int m_tzHours;
    internal int m_tzMinutes;
    internal TZInfo(int tzHours, int tzMinutes);
}
internal class Oracle.ManagedDataAccess.Types.ZoneIdMap : object {
    internal static Hashtable zoneid;
    internal static Hashtable windowsToOracleZones;
    internal static Hashtable oracleZoneNameToNumber;
    internal static int INV_ZONEID;
    private static ZoneIdMap();
    internal static string GetLocalTimeZoneInformation(string key);
}
public enum Oracle.OciServicesSdk.OracleOciSdkResourceStringIds : Enum {
    public int value__;
    public static OracleOciSdkResourceStringIds PemReaderDerAsnWrongItemsNo;
    public static OracleOciSdkResourceStringIds PemReaderDerAsnUnexpectedTag;
    public static OracleOciSdkResourceStringIds PemReaderDerAsnUnknownType;
    public static OracleOciSdkResourceStringIds PemReaderCantReadSection;
    public static OracleOciSdkResourceStringIds PemReaderUnknownFormat;
}
internal static class Oracle.OciServicesSdk.OracleOciServicesSdkErrorStrings : object {
    internal static string s_vPemReaderDerAsnWrongItemsNo;
    internal static string s_vPemReaderDerAsnUnexpectedTag;
    internal static string s_vPemReaderDerAsnUnknownType;
    internal static string s_vPemReaderCantReadSection;
    internal static string s_vPemReaderUnknownFormat;
    private static OracleOciServicesSdkErrorStrings();
}
public class Oracle.OciServicesSdk.Utilities.OracleOciSdkResourceManager : object {
    private static string s_cStringResourceName;
    private static string s_cPrefixString;
    private ResourceManager m_vStrResourceManager;
    private CultureInfo m_vUICulture;
    private static OracleOciSdkResourceManager s_vSdkResourceManager;
    private bool disposedValue;
    private static OracleOciSdkResourceManager();
    public static string GetString(OracleOciSdkResourceStringIds id);
    public static string GetResourceString(string resStr);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public enum Oracle.OciServicesSdk.Utilities.OracleOciSdkResourceStringIds : Enum {
    public int value__;
    public static OracleOciSdkResourceStringIds PemReaderDerAsnWrongItemsNo;
    public static OracleOciSdkResourceStringIds PemReaderDerAsnUnexpectedTag;
    public static OracleOciSdkResourceStringIds PemReaderDerAsnUnknownType;
    public static OracleOciSdkResourceStringIds PemReaderCantReadSection;
    public static OracleOciSdkResourceStringIds PemReaderUnknownFormat;
}
internal class Oracle.PemUtilities.OraclePemDecodingException : Exception {
    internal OraclePemDecodingException(string message);
    internal OraclePemDecodingException(string message, Exception innerException);
    [SecuritySafeCriticalAttribute]
protected OraclePemDecodingException(SerializationInfo info, StreamingContext context);
}
internal class Oracle.PemUtilities.OraclePemReader : object {
    protected static string s_cMatchSection;
    protected static string s_cMatchEncryption;
    protected static Regex s_vSectionRegExp;
    protected static Regex s_vEncryptionRegExp;
    protected SecureString m_vPassPhrase;
    internal OraclePemReader(SecureString passPhrase);
    private static OraclePemReader();
    internal AsymmetricAlgorithm ReadObject(string st, int uniqueHashCode);
    internal static Byte[] GetEvenSizeArray(Byte[] origData);
    internal static Byte[] GetRightSizeData(Byte[] origData, int expectedSize);
    internal static RSACryptoServiceProvider CreateRSACryptoServiceProvider(Byte[] privateKey, int uniqueHashCode);
}
internal class Oracle.PemUtilities.OraclePemSectionType : object {
    internal static string s_cX509CertificateOld;
    internal static string s_cX509Certificate;
    internal static string s_cX509Pair;
    internal static string s_cX509Trusted;
    internal static string s_cX509RequestOld;
    internal static string s_cX509Request;
    internal static string s_cX509Crl;
    internal static string s_cEvpPkey;
    internal static string s_cPublic;
    internal static string s_cRsa;
    internal static string s_cRsaPublic;
    internal static string s_cDsa;
    internal static string s_cDsaPublic;
    internal static string s_cPkcs7;
    internal static string s_cPkcs7Signed;
    internal static string s_cPkcs8;
    internal static string s_cPkcs8Inf;
    internal static string s_cDhParameters;
    internal static string s_cSslSession;
    internal static string s_cDsaParameters;
    internal static string s_cEcdsaPublic;
    internal static string s_cEcParameters;
    internal static string s_cEcPrivateKey;
    internal static string s_cParameters;
    internal static string s_cCms;
}
public class OracleAQMessageAvailableEventHandler : MulticastDelegate {
    public OracleAQMessageAvailableEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OracleAQMessageAvailableEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OracleAQMessageAvailableEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class OracleInternal.BinXml.AttributeInfo : object {
    private ObxmlNodeState m_nodeState;
    private string m_attributeValue;
    internal bool IsNamespaceAttribute;
    internal string Prefix;
    internal ulong PrefixId;
    private PrefixInfo m_PrefixInfo;
    private string m_AttributeString;
    private string m_LocalName;
    private string m_NameSpace;
    private string m_QualifiedName;
    internal string Value { get; internal set; }
    internal string get_Value();
    internal void set_Value(string value);
    internal AttributeInfo ResetAttributeInfo(ObxmlDecodeState decodeState, ObxmlNodeState nodeState, bool isNamespaceAttribute, ulong pfxid, string localname, string nameSpace, string value);
    internal AttributeInfo ResetAttributeInfo(ObxmlDecodeState decodeState, ObxmlNodeState nodeState, bool isNamespaceAttribute, PrefixInfo pfxInfo, string localname, string nmspace, string value);
    internal AttributeInfo ResetAttributeInfo(ObxmlDecodeState decodeState, ObxmlNodeState nodeState, bool isNamespaceAttribute, string prefix, string localname, string nmspace, string value);
    internal string GetQualifiedName(ObxmlDecodeState decodeState);
    internal string GetQualifiedName(string prefix, string localName);
    internal PrefixInfo GetPrefixInfo(ObxmlDecodeState decodeState, bool refetchPrefixInfo);
    internal string GetLocalName(ObxmlDecodeState decodeState);
    internal string GetNamespace(ObxmlDecodeState decodeState);
    internal string GetQualifiedAttributeString(ObxmlDecodeState decodeState);
    protected object Clone(ObxmlDecodeState decodeState, bool refetchPrefixInfo);
}
internal class OracleInternal.BinXml.BinXmlArrayStream : object {
    protected BinaryReader m_BinReader;
    protected bool m_bInit;
    protected bool m_ReadOnlyStream;
    protected bool m_Disposed;
    internal long Position { get; internal set; }
    internal BinXmlArrayStream(Byte[] buffer, long size);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual void Init();
    internal void Reset();
    internal long get_Position();
    internal void set_Position(long value);
    internal Byte[] ReadBytes(int count, int startPos);
    internal void ReadAndCopyBytes(Byte[] destination, long offset, long count);
    internal byte ReadByte();
    internal Byte[] ReadAllBytes(long startPos);
}
internal enum OracleInternal.BinXml.CsxDecodeChunkingPolicy : Enum {
    public int value__;
    public static CsxDecodeChunkingPolicy SpecifiyChunkPerCall;
    public static CsxDecodeChunkingPolicy SpecifiyChunkMaxSize;
    public static CsxDecodeChunkingPolicy UseDefaultChunkSize;
    public static CsxDecodeChunkingPolicy None;
}
internal enum OracleInternal.BinXml.DataOperationTypes : Enum {
    public short value__;
    public static DataOperationTypes NoData;
    public static DataOperationTypes DataOnly;
    public static DataOperationTypes LengthAndData;
}
[FlagsAttribute]
internal enum OracleInternal.BinXml.DecodeStates : Enum {
    public int value__;
    public static DecodeStates None;
    public static DecodeStates InstructionStart;
    public static DecodeStates ElementStart;
    public static DecodeStates ElementStartNoClosingBracket;
    public static DecodeStates ElementStartTagBegin;
    public static DecodeStates ElementStartTagEnd;
    public static DecodeStates ElementStartAttribute;
    public static DecodeStates ElementStartAttributeStart;
    public static DecodeStates ElementStartAttributeDone;
    public static DecodeStates ElementEndStart;
    public static DecodeStates ElementEndPending;
    public static DecodeStates ElementData;
    public static DecodeStates ElementDataStart;
    public static DecodeStates ElementDataStartElementOpt;
    public static DecodeStates ElementDataStartCharsOpt;
    public static DecodeStates ElementDataStartCharsLoc;
    public static DecodeStates ElementDataStartPartial;
    public static DecodeStates ElementDataDone;
    public static DecodeStates SectionStart;
    public static DecodeStates SectionEnd;
}
internal class OracleInternal.BinXml.DTDElementAttributeInfo : ObxmlStateObject {
    private string m_attributeValue;
    internal string ElementName;
    internal string AttributeName;
    internal bool AttributeStringExpanded;
    internal string AttributeString;
    internal string AttributeType;
    internal string AttributeMode;
    internal string AttributeValue { get; internal set; }
    internal DTDElementAttributeInfo(string elementName, string attributeName, string type, string mode, string value);
    internal string get_AttributeValue();
    internal void set_AttributeValue(string value);
    internal void SplitAttrString(string attributeType);
    internal virtual void ClearStateObject();
}
internal class OracleInternal.BinXml.DTDElementInfo : ObxmlStateObject {
    internal string ElementName;
    internal string ContentSpec;
    internal virtual void ClearStateObject();
}
internal class OracleInternal.BinXml.DTDObject : ObxmlStateObject {
    internal DTDObjectTypes DTDObjectType;
    private string m_objectValue;
    internal string ObjectName;
    internal string PublicId;
    internal string SystemId;
    internal string Note;
    internal string ObjectValue { get; internal set; }
    internal bool IsEntity { get; }
    internal bool IsParsedEntity { get; }
    internal bool IsUnparsedEntity { get; }
    internal bool IsExternalEntity { get; }
    internal DTDObject(DTDObjectTypes objectType);
    internal DTDObject(DTDObjectTypes objectType, string objectName);
    internal string get_ObjectValue();
    internal void set_ObjectValue(string value);
    internal bool get_IsEntity();
    internal bool get_IsParsedEntity();
    internal bool get_IsUnparsedEntity();
    internal bool get_IsExternalEntity();
    internal virtual void ClearStateObject();
}
internal enum OracleInternal.BinXml.DTDObjectTypes : Enum {
    public int value__;
    public static DTDObjectTypes DTD;
    public static DTDObjectTypes Note;
    public static DTDObjectTypes Entity;
    public static DTDObjectTypes PartialEntity;
    public static DTDObjectTypes None;
}
internal enum OracleInternal.BinXml.InputOutputTypes : Enum {
    public int value__;
    public static InputOutputTypes XmlFilePath;
    public static InputOutputTypes BinaryXmlFilePath;
    public static InputOutputTypes XmlUri;
    public static InputOutputTypes BinaryXmlUri;
    public static InputOutputTypes OracleBlob;
    public static InputOutputTypes ByteArray;
    public static InputOutputTypes FileStream;
    public static InputOutputTypes TextStream;
    public static InputOutputTypes StringBuilder;
    public static InputOutputTypes None;
}
internal enum OracleInternal.BinXml.InstructionTypes : Enum {
    public int value__;
    public static InstructionTypes None;
    public static InstructionTypes Element;
    public static InstructionTypes Attribute;
    public static InstructionTypes Cdata;
    public static InstructionTypes Comment;
    public static InstructionTypes Namespace;
    public static InstructionTypes Token;
}
[FlagsAttribute]
internal enum OracleInternal.BinXml.NodeFlags : Enum {
    public short value__;
    public static NodeFlags SELFMODE;
    public static NodeFlags ARRMODE;
    public static NodeFlags SEQMODE;
    public static NodeFlags SELFSTRMMODE;
    public static NodeFlags STRMMODE;
    public static NodeFlags OPTMODE;
    public static NodeFlags KIDMODE;
    public static NodeFlags ARRNEXTMODE;
    public static NodeFlags TYPEID;
    public static NodeFlags ARRSEQMODE;
    public static NodeFlags OPTSEQMODE;
    public static NodeFlags ARRNEXTSEQMODE;
}
internal enum OracleInternal.BinXml.NodeTypes : Enum {
    public int value__;
    public static NodeTypes None;
    public static NodeTypes Element;
    public static NodeTypes Attribute;
    public static NodeTypes Cdata;
    public static NodeTypes Comment;
    public static NodeTypes Namespace;
}
internal class OracleInternal.BinXml.ObxmlContentObject : object {
    private InputOutputTypes inputContentType;
    internal static int s_InputNumericValueNotSet;
    [CompilerGeneratedAttribute]
private long <ReadOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <InputLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ContentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ObxmlDecodeRequest <Parent>k__BackingField;
    internal long ReadOffset { get; internal set; }
    internal long InputLength { get; internal set; }
    internal InputOutputTypes InputType { get; internal set; }
    internal string StreamId { get; internal set; }
    internal object ContentObject { get; internal set; }
    internal ObxmlDecodeRequest Parent { get; internal set; }
    internal ObxmlContentObject(ObxmlDecodeRequest parent);
    [CompilerGeneratedAttribute]
internal long get_ReadOffset();
    [CompilerGeneratedAttribute]
internal void set_ReadOffset(long value);
    [CompilerGeneratedAttribute]
internal long get_InputLength();
    [CompilerGeneratedAttribute]
internal void set_InputLength(long value);
    internal void SetObxmlContentObject(OracleBlob blob);
    internal void SetObxmlContentObject(InputOutputTypes contentType, string urlOrPathOrId);
    internal void SetObxmlContentObject(Byte[] binArray);
    internal bool IsInputContentTypeValid(InputOutputTypes contentType);
    internal InputOutputTypes get_InputType();
    internal void set_InputType(InputOutputTypes value);
    [CompilerGeneratedAttribute]
internal string get_StreamId();
    [CompilerGeneratedAttribute]
internal void set_StreamId(string value);
    [CompilerGeneratedAttribute]
internal object get_ContentObject();
    [CompilerGeneratedAttribute]
internal void set_ContentObject(object value);
    [CompilerGeneratedAttribute]
internal ObxmlDecodeRequest get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ObxmlDecodeRequest value);
    internal bool IsContentValid();
    internal bool ResetContentObject();
}
internal class OracleInternal.BinXml.ObxmlDecodeContext : object {
    protected bool m_IsDone;
    protected ObxmlMetaDataRepository m_MetaDataRepository;
    protected ObxmlTokenManagerContext m_TokenMapContext;
    protected ObxmlTokenMap m_TokenMap;
    protected OracleConnection m_DbConnection;
    protected long m_SpecificTokenId;
    internal static int DEFAULT_XMLTYPE_NODEPOOL_SIZE;
    internal static int m_XMLTypeNodePoolSize;
    internal static bool m_XMLTypeOpcodeDump;
    internal static bool m_XMLTypeParseAllXml;
    internal static bool m_XMLTypeParseXml;
    internal static bool m_XMLTypeUseHeaderEncodingFromServer;
    internal static int DEFAULT_XMLTYPE_OPTIMIZATION_LEVEL;
    internal static int XMLTYPE_OPTIMIZATION_LEVEL_NO_CHAR_REPLACEMENT;
    internal static int m_XMLTypeOptimizationLevel;
    internal static int DEFAULT_XMLTYPE_MAX_CACHE_ENTRIES;
    internal static int m_XMLTypeMaxCacheEntries;
    internal CsxDecodeChunkingPolicy ChunkingPolicy;
    internal long CsxReadMaxChunkSize;
    protected string DecodeTimeStamp { get; }
    protected string CacheSizeString { get; }
    protected string PerformanceCounterString { get; }
    internal string ContextId { get; }
    internal bool IsBusy { get; }
    internal bool IsValid { get; }
    internal OracleConnection DbConnection { get; internal set; }
    internal ObxmlTokenManagerContext TokenMapContext { get; internal set; }
    internal ObxmlTokenMap TokenMap { get; internal set; }
    internal ObxmlMetaDataRepository MetaDataRepository { get; }
    private static ObxmlDecodeContext();
    internal static ObxmlDecodeContext CreateDefaultContext(OracleConnection dbConnection);
    internal static ObxmlDecodeContext UpdateContext(ObxmlDecodeContext decodeContext, ObxmlMetaDataRepository metaDataRepository, ObxmlTokenMap tokenMap, CsxDecodeChunkingPolicy chunkingPolicy, long csxReadMaxChunkSize);
    protected string GetTimeStamp(bool isStart);
    protected string get_DecodeTimeStamp();
    protected string get_CacheSizeString();
    protected string get_PerformanceCounterString();
    internal string get_ContextId();
    internal bool get_IsBusy();
    internal bool get_IsValid();
    internal OracleConnection get_DbConnection();
    internal void set_DbConnection(OracleConnection value);
    internal ObxmlTokenManagerContext get_TokenMapContext();
    internal void set_TokenMapContext(ObxmlTokenManagerContext value);
    internal ObxmlTokenMap get_TokenMap();
    internal void set_TokenMap(ObxmlTokenMap value);
    internal ObxmlMetaDataRepository get_MetaDataRepository();
    internal void SetDecodeContext(ObxmlDecodeContext decodeContext);
    protected ObxmlDecodeContext SetDecodeContext(OracleConnection dbConnection, ObxmlMetaDataRepository metaDataRepository, ObxmlTokenMap tokenMap, CsxDecodeChunkingPolicy chunkingPolicy, long csxReadMaxChunkSize);
    protected ObxmlDecodeContext SetDecodeContext(OracleConnection dbConnection, ObxmlMetaDataRepository metaDataRepository, ObxmlTokenManagerContext tokenMapContext, CsxDecodeChunkingPolicy chunkingPolicy, long csxReadMaxChunkSize);
    internal virtual bool ResetDecodeState(bool disposing);
    internal static int GetOutputLengthEstimate(int inputCSXLength, bool fullBufferEstimate);
    internal static int GetOutputResetLengthEstimate();
}
internal class OracleInternal.BinXml.ObxmlDecoder : ObxmlDecodeContext {
    private bool m_Disposed;
    private ObxmlDecodeState m_DecodeState;
    private ObxmlInstruction m_Instruction;
    private int DefaultDecodeBufferLength;
    internal static Dictionary`2<short, string> ReservedNSTable;
    internal static Dictionary`2<short, string> ReservedPrefixTable;
    internal static Dictionary`2<short, string> ReservedNSPrefixTable;
    internal static string nameXML;
    internal static string nameXSLPI;
    internal static string nameXMLSpace;
    internal static string nameXMLLang;
    internal static string nameNamespace;
    internal static string nameXMLNamespace;
    internal static string DEFAULT_PREFIX;
    internal static string nameXMLNSNamespace;
    internal static string nameDOCUMENTFRAGMENT;
    internal static string nameDOCUMENT;
    internal static string nameTEXT;
    internal static string nameCOMMENT;
    internal static string nameCDATA;
    internal static string XMLSCHEMA;
    protected ObxmlDecodeRequest RequestObject { get; }
    private ObxmlInstructionState CurrentInstruction { get; }
    private ObxmlStream DataStream { get; private set; }
    internal ObxmlDecodeState DecodeState { get; }
    internal ObxmlDecodeContext DecodeContext { get; }
    private static ObxmlDecoder();
    internal ObxmlDecoder(Char[] encodedArray);
    protected ObxmlDecodeRequest get_RequestObject();
    private ObxmlInstructionState get_CurrentInstruction();
    private ObxmlStream get_DataStream();
    private void set_DataStream(ObxmlStream value);
    private void InitState(bool resetting);
    private bool IsDecoderValid();
    private bool InitRequestObject();
    internal PrefixInfo GetReservedPrefixInfo(short pfxid);
    internal ObxmlDecodeState get_DecodeState();
    internal void GetNextInstruction();
    internal void SetDecodeComplete();
    internal bool ResetRequestObject();
    internal virtual bool ResetDecodeState(bool disposing);
    internal ObxmlDecoder SetRequestObject(bool isFullDecode, long readOffset, Byte[] inputBuffer, int inputLength, int writeOffset, Byte[] outputBuffer, bool outputOwnedByClient, long textLengthRequested);
    internal ObxmlDecoder SetRequestObject(StringBuilder& utf16OutPutBuilder, bool outputOwnedByClient, long readOffset, Byte[] inputBuffer, int inputLength);
    internal ObxmlDecoder SetRequestObject(bool isFullDecode, long readOffset, OracleBlob blob, int writeOffset, Byte[] outputBuffer, bool outputOwnedByClient, long textLengthRequested);
    internal ObxmlDecodeContext get_DecodeContext();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal ObxmlDecodeResponse Decode();
    internal ObxmlDecodeResponse Decode_New(ObxmlDecodeRequest request);
    private int HandleDecodeComplete_New();
}
internal class OracleInternal.BinXml.ObxmlDecodeRequest : object {
    private ObxmlContentObject encodedContent;
    internal ObxmlOutputObject m_RequestOutput;
    [CompilerGeneratedAttribute]
private bool <IsFullDecode>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TextLengthRequested>k__BackingField;
    internal long m_CountRemaining;
    internal ObxmlContentObject EncodedContent { get; }
    internal bool IsFullDecode { get; internal set; }
    internal long TextLengthRequested { get; internal set; }
    internal ObxmlContentObject get_EncodedContent();
    [CompilerGeneratedAttribute]
internal bool get_IsFullDecode();
    [CompilerGeneratedAttribute]
internal void set_IsFullDecode(bool value);
    [CompilerGeneratedAttribute]
internal long get_TextLengthRequested();
    [CompilerGeneratedAttribute]
internal void set_TextLengthRequested(long value);
    internal void SetObxmlDecodeRequest(bool isFullDecode, long textLengthRequested);
    internal bool IsRequestValid();
    internal bool ResetRequestObject();
}
internal class OracleInternal.BinXml.ObxmlDecodeResponse : object {
    internal object ObxmlDecodeContext;
    internal Byte[] OutputBuffer;
    internal long CurrentOffset;
    internal long DecodedTextLength;
    internal ObxmlErrorTypes ErrorType;
    internal string ErrorMessage { get; }
    internal bool IsSuccess { get; }
    internal bool IsDone { get; }
    internal ObxmlDecodeResponse(ObxmlErrorTypes errorType, ObxmlDecodeState parent);
    internal ObxmlDecodeResponse(ObxmlDecodeState parent);
    internal string get_ErrorMessage();
    internal bool get_IsSuccess();
    internal bool get_IsDone();
    internal void SetSuccess();
    internal bool ResetResponseObject(ObxmlDecodeState parent, ObxmlErrorTypes errorType);
    internal bool IsResponseValid();
    internal static string GetErrorMessage(ObxmlErrorTypes errorType, Exception ex, OpcodeIds opcodeId);
}
internal class OracleInternal.BinXml.ObxmlDecodeState : ObxmlStateObject {
    private bool m_bInit;
    internal bool m_IsProcessingDTD;
    private bool m_bUseXmlWriterForDTDAndData;
    private ObxmlObjectPool`1<ObxmlNodeState> m_NodePool;
    private ObxmlObjectPool`1<AttributeInfo> m_AttributePool;
    private Stack`1<ObxmlNodeState> m_NodeStates;
    private ObxmlNodeState m_CurrentNode;
    private ObxmlNodeState m_PreviousSibling;
    private List`1<PrefixInfo> m_NsStack;
    private Dictionary`2<int, PrefixInfo> m_PrefixTable;
    private Dictionary`2<int, PrefixInfo> m_NsPrefixTable;
    internal List`1<AttributeInfo> AttributeList;
    internal DecodeStates DecodeStateMask;
    internal DataOperationTypes CurrentDataOperation;
    internal ObxmlSectionHeader SectionHeader;
    internal ObxmlDocHeader DocHeader;
    private ObxmlDTDInfo m_DTDInfo;
    internal ObxmlInstructionState m_CurrentInstruction;
    internal ObxmlInstructionState m_LastInstruction;
    internal Byte[] CurrentCsxBuffer;
    internal Byte[] LastCsxBuffer;
    internal bool IsExtendedOpcode;
    internal OpcodeIds PrtOpcode;
    internal string PrtBuffer;
    internal ObxmlDecodeRequest m_RequestObject;
    internal ObxmlStream m_BinXmlStream;
    internal bool SectionHeaderFound;
    internal ObxmlDecoder Parent;
    internal ObxmlErrorTypes ErrorType;
    internal ObxmlDecodeResponse LastDecodeResult;
    internal bool HasBeginTagClosurePending;
    internal int LastNodeId;
    internal bool ProcessingTokenSet;
    internal ObxmlDTDInfo DTDInfo { get; }
    internal bool IsInitialized { get; }
    internal bool IsNotSchemaBased { get; }
    internal bool PerformFullXmlParse { get; }
    internal bool UseXmlWriterForDTDAndData { get; }
    internal ObxmlTokenMap TokenMap { get; }
    internal ObxmlDTDInfo get_DTDInfo();
    internal void DisposeOutput();
    internal virtual void ClearStateObject();
    internal void SetObxmlDecodeState(ObxmlDecoder decoder, ObxmlStream stream, ObxmlDecodeResponse lastDecodeResult);
    internal bool IsDecoderStateValid();
    internal bool get_IsInitialized();
    internal bool get_IsNotSchemaBased();
    internal bool get_PerformFullXmlParse();
    internal bool get_UseXmlWriterForDTDAndData();
    internal ObxmlNodeState GetNodeState();
    internal void FreeNodeState(ObxmlNodeState ns);
    internal AttributeInfo GetAttributeInfo();
    internal void FreeAttributeInfo(AttributeInfo attrInfo);
    internal bool TryAppendingBeginTagClosure(ObxmlNodeState ns, bool checkForInitialNode, bool checkForNewNode);
    internal ObxmlTokenMap get_TokenMap();
    internal bool Init();
    internal ObxmlNodeState GetLastNodeState();
    internal ObxmlNodeState GetCurrentNodeState(bool clone);
    internal void SetLastInstructionToCurrent(bool resetCurrent, bool copyCsxPartialBuffer);
    internal void SwapLastInstructionToCurrent(bool resetCurrent);
    internal bool HasDecodeState(DecodeStates stateFlag);
    internal bool HasMoreElementData();
    internal bool HasElementEndPending();
    internal bool HasMoreCsxInstructionData(Int64& csxDataSize);
    internal bool HasMoreTokenOrData(Int64& tokenDataSize);
    internal void SetDecodeState(DecodeStates stateFlag, bool resetOldMasks);
    internal void SetDecodeState(DecodeStates stateFlag, DecodeStates resetStateFlag);
    internal void ResetDecodeStateMask(DecodeStates stateFlag);
    internal void ResetDecodeStateMaskToNone();
    internal void PushNodeState(ObxmlNodeState ns);
    internal ObxmlNodeState PopNodeState();
    internal void PushNamespace(PrefixInfo pInfo);
    internal void PopNamespace(int index);
    internal string GetNamespace(ulong nsid, TokenTypes tokenType);
    internal ObxmlToken GetNamespaceToken(ulong nsid);
    internal string GetNamespaceUri(ulong nsid);
    internal string GetNamespaceUriForNode(ObxmlNodeState node);
    internal PrefixInfo GetPrefixInfo(ulong pfxid);
    internal string GetPrefix(short pfxid);
    internal PrefixInfo SetPrefix(short pfxid, string prefix, ulong nsid);
    internal PrefixInfo SetPrefix(PrefixInfo prefixInfo);
    internal ObxmlToken GetToken(ulong tokenId, TokenTypes tokenType);
    internal void SetToken(ObxmlToken token);
    internal string GetNSPrefix(string uri);
    internal string GetNSPrefix(ulong nsid);
    internal long WriteTextToOutput(string text);
    internal long WriteInputToOutput(int lengthToCopyFromInput, bool useReplaceChar);
    internal long WriteTokenOrData(bool initTokenOrDataLength);
    internal int WriteCsxBytes(bool initCsxDataLength);
}
internal class OracleInternal.BinXml.ObxmlDecodeStream : ObxmlDecoder {
    private int m_CountDecoded;
    private bool m_bInitStreaming;
    private Byte[] m_RawDecodedText;
    private ObxmlDecodeResponse m_DecodeResponse;
    private long m_InputLength;
    private OracleBlob m_Blob;
    private Byte[] m_CsxBuffer;
    private long m_CsxOffset;
    private int m_TextBufferOffset;
    private bool m_IsLastSubstring;
    private bool m_Disposed;
    internal static int DefaultChunkSize;
    internal static int DefaultTextBufferSize;
    [CompilerGeneratedAttribute]
private string <DecodedText>k__BackingField;
    internal bool IsValid { get; }
    internal long CountDecoded { get; }
    internal string DecodedText { get; internal set; }
    internal ObxmlDecodeStream(ObxmlDecodeContext decodeContext, OracleBlob blob);
    private static ObxmlDecodeStream();
    internal bool get_IsValid();
    internal ObxmlDecodeStream ResetRequestObject(ObxmlDecodeContext decodeContext, OracleBlob blob);
    internal int ReadBlob(OracleBlobImpl blobImpl, Byte[] buffer, int offset, int count);
    private Byte[] ReadBlob(OracleBlobImpl blobImpl);
    internal long get_CountDecoded();
    [CompilerGeneratedAttribute]
internal string get_DecodedText();
    [CompilerGeneratedAttribute]
internal void set_DecodedText(string value);
    internal bool Open(ObxmlDecodeContext decodeContext, Byte[] encodedCSX, int inputLength);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    internal virtual bool ResetDecodeState(bool disposing);
    protected virtual void Dispose(bool disposing);
    internal bool Close();
    internal string DecodeNext(int numCharsRequested);
    private int Decode(Byte[] textBuffer, int numCharsToDecode, long textBufferOffset, long csxOffset);
    internal string Decode(Byte[] buffer, int inputLength, int numCharsRequested);
    internal string Decode(Byte[] buffer, int inputLength);
    internal void HandleCompleteParse();
    internal StringBuilder DecodeBlobForXmlStream(bool streamingCall);
    internal string DecodeBlob();
}
internal class OracleInternal.BinXml.ObxmlDocHeader : ObxmlStateObject {
    internal static string sHeaderVersion;
    internal static string sHeaderTagEnd;
    internal static string sHeaderVersion1;
    internal int Flags;
    internal string Version;
    internal string Standalone;
    internal string Encoding;
    internal bool XmlDecl;
    internal bool IsHeaderSubVersion1 { get; }
    private static ObxmlDocHeader();
    internal bool get_IsHeaderSubVersion1();
    internal string GetHeaderString();
    internal virtual void ClearStateObject();
}
internal class OracleInternal.BinXml.ObxmlDTDInfo : DTDObject {
    internal List`1<DTDElementInfo> m_ElementList;
    internal List`1<DTDElementAttributeInfo> m_AttributeList;
    internal List`1<DTDObject> m_ObjectList;
    private bool m_InitSubset;
    private ObxmlDecodeState m_DecodeState;
    private string m_lastElementString;
    internal bool IsValid;
    internal bool IsExternal;
    internal bool InCDATA;
    internal bool IsEmpty { get; }
    internal ObxmlDTDInfo(ObxmlDecodeState mDecodeState);
    internal void SetDecodeStateObject(ObxmlDecodeState mDecodeState);
    internal bool get_IsEmpty();
    internal bool ProcessAttributes();
    internal void InilializeSubset();
    internal bool StartDTD();
    internal bool EndDTD();
    internal bool StartEntity(string name);
    internal bool EndEntity(string name);
    internal bool StartCDATA();
    internal bool EndCDATA();
    internal void ElementDecl(DTDElementInfo dtdElement);
    internal void ElementDecl(string name, string model);
    internal void AttributeDecl(DTDElementAttributeInfo attributeInfo);
    internal void AttributeDecl(string elementName, string attributeName, string type, string mode, string value);
    internal void EntityDecl(DTDObject entity);
    internal void EntityReference(DTDObject entity);
    internal void InternalEntityDecl(string name, string value);
    internal void ExternalEntityDecl(string name, string publicId, string systemId);
    internal void UnparsedEntityDecl(string name, string publicId, string systemId, string notationName);
    internal void NotationDecl(DTDObject note);
    internal void NotationDecl(string name, string publicId, string systemId);
    internal string PrintAttributeDecl();
    internal virtual void ClearStateObject();
}
internal enum OracleInternal.BinXml.ObxmlErrorTypes : Enum {
    public int value__;
    public static ObxmlErrorTypes Success;
    public static ObxmlErrorTypes Done;
    public static ObxmlErrorTypes DecodeFailed;
    public static ObxmlErrorTypes NotImplemented;
    public static ObxmlErrorTypes InvalidArguments;
    public static ObxmlErrorTypes InvalidAttribute;
    public static ObxmlErrorTypes NotOpenForStreaming;
    public static ObxmlErrorTypes CsxInvalidInputStream;
    public static ObxmlErrorTypes CsxInvalidOpcode;
    public static ObxmlErrorTypes CsxInvalidInstruction;
    public static ObxmlErrorTypes CsxEndOfStream;
    public static ObxmlErrorTypes DTDStartFailed;
    public static ObxmlErrorTypes CDATAStartFailed;
    public static ObxmlErrorTypes CDATAEndFailed;
    public static ObxmlErrorTypes DTDEndFailed;
    public static ObxmlErrorTypes DTDError;
    public static ObxmlErrorTypes TokenCacheCorrupt;
    public static ObxmlErrorTypes TokenRetrievalFailed;
    public static ObxmlErrorTypes TokenInvalid;
    public static ObxmlErrorTypes TokenInvalidPrefix;
    public static ObxmlErrorTypes SchemaInvalid;
    public static ObxmlErrorTypes SchemaRetrievalFailed;
    public static ObxmlErrorTypes SchemaValidationFailed;
    public static ObxmlErrorTypes SchemaInvalidProperty;
    public static ObxmlErrorTypes DecodeStateInvalid;
    public static ObxmlErrorTypes MetaDataRepositoryInvalid;
    public static ObxmlErrorTypes MetaDataNotFound;
    public static ObxmlErrorTypes BufferInsufficient;
    public static ObxmlErrorTypes StringNotTerminated;
    public static ObxmlErrorTypes RequestInputInvalid;
    public static ObxmlErrorTypes RequestOutputInvalid;
}
internal class OracleInternal.BinXml.ObxmlInstruction : object {
    private static int MaxInstructionDataLen;
    private ObxmlInstructionFormat m_InstructionFormat;
    private UInt64[] m_InstructionData;
    private ObxmlDecodeState m_DecodeState;
    internal bool InstructionPending;
    private Char[] charbuf;
    private ObxmlStream DataStream { get; }
    internal ObxmlSectionHeader SectionHeader { get; }
    internal ObxmlDocHeader DocHeader { get; }
    internal ObxmlOutputObject RequestOutput { get; }
    internal ObxmlInstruction(ObxmlDecodeState state);
    private static ObxmlInstruction();
    private ObxmlStream get_DataStream();
    internal ObxmlSectionHeader get_SectionHeader();
    internal ObxmlDocHeader get_DocHeader();
    internal void ResetObxmlInstruction(ObxmlDecodeState state);
    private void ResetLastInstructionToCurrent();
    internal ObxmlOutputObject get_RequestOutput();
    internal void ResetData();
    internal OpcodeIds ReadOpcode();
    internal bool IsLastTokenAttribute();
    internal ObxmlNodeState GetLastNodeState();
    internal bool ReadSectionHeader(OpcodeIds opcode);
    internal bool ReadDocHeader(OpcodeIds opcode);
    internal OpcodeIds ReadInstructionInfo(bool readNewOpcode);
    private OpcodeIds ReadOpcodeInfo(bool readNewOpcode, bool IsExtended);
    private ulong GetDataLen(short opcode);
    internal static bool OpcodeHasDataPart(OpcodeIds opcode);
    private void SkipBytes(long skipCount);
    internal static bool IsCloseTagPending(ObxmlDecodeState decodeState);
    internal byte ReadNum1();
    internal short ReadNum2();
    internal int ReadNum4();
    internal int ReadNum4r();
    internal long ReadLong8();
    internal ObxmlNodeState GetNodeData(ulong tokenId, NodeTypes nodeType, ulong datalen);
    internal long ReadAndWriteFixedData(OpcodeIds opcode, Int64& processed);
    private Char[] DecodeWhitespaces(OpcodeIds opcode, Int32& datalen);
    private void SkipData(OpcodeIds opcode);
    internal Byte[] GetEventChars(OpcodeIds opcode, UInt64& datalen, String& stringValue);
    internal ObxmlNodeState ReadElementInfo(OpcodeIds Opcode, bool optimizedOpcode, UInt64& qnameid, String& prefix);
    internal ObxmlNodeState ReadElementInfo(OpcodeIds opcode, bool optimizedOpcode, ObxmlNodeState ns, bool arrayModeDataBegin);
    private static long ProcessPendingBytesOrTokenData(ObxmlDecodeState decodeState, bool initTokenOrDataLength, bool initCsxDataLength, Int64& processed);
    private static long ProcessTokenOrTextData(ObxmlDecodeState decodeState, bool initTokenOrDataLength, Int64& processed);
    private static long ProcessCsxBytes(ObxmlDecodeState decodeState, bool initCsxDataLength, Int64& processed);
    private long ProcessEndElement(Int64& processed);
    internal bool DecodeInstruction_New();
    private bool HandleArrayModeDataBegin(OpcodeIds opcode, Int64& processed);
    private void ReadAttributes_New(bool skip);
    internal bool ReadInlineToken(OpcodeIds opcode);
    internal bool ReadNamespaceToken(OpcodeIds opcode);
    internal bool ReadPrefix(OpcodeIds opcode, PrefixInfo& prefixInfo);
    internal bool ReadToken(OpcodeIds opcode, ObxmlToken& token);
    internal string ReadEventText(ObxmlNodeState elem, OpcodeIds opcode);
    private void ProcessInstruction(string target, string value);
}
internal class OracleInternal.BinXml.ObxmlInstructionFormat : object {
    internal static short NOOP;
    internal static int HDR_RGUID_LEN;
    internal static byte CSX_MAX_SCHID_LEN;
    internal static byte CSX_MAX_PFX_LEN;
    internal static byte CSX_DEFQNF_ATTR;
    internal static int KIDNUM;
    internal static int TOKENID;
    internal static int TYPDATA;
    internal static int DTDLEN;
    internal static int STANDALONE_SPECIFIED;
    internal static int PROLOG_SPECIFIED;
    internal static int ENCODING_SPECIFIED;
    internal static int VERSION_SPECIFIED;
    internal static int STANDALONE_TRUE;
    internal static int VERSION_MASK;
    internal static int VERSION_ELEVEN;
    internal static int ELSTF_SSEQ;
    internal static int ELSTF_NOTDECTYP;
    internal static int ELSTF_IMPTYP;
    internal static int ELSTF_PFXID;
    internal string name;
    internal bool startframe;
    internal bool endframe;
    internal int flags;
    internal bool hasfixeddata;
    internal bool hasvardata;
    internal int opnum;
    internal Int32[] oplen;
    internal int skiplen;
    internal int fixeddatalen;
    internal static ObxmlInstructionFormat[] InstructionFormats;
    internal static ObxmlInstructionFormat[] ExtendedInstructionFormats;
    private ObxmlInstructionFormat(string name, bool startframe, bool endframe, int flags, bool hasfixeddata, bool hasvardata, int opnum, int op1len, int op2len, int op3len, int op4len, int fixeddatalen);
    private static ObxmlInstructionFormat();
    internal static ObxmlInstructionFormat CreateFormatFixedData(string name, int fixeddatalen);
    internal static ObxmlInstructionFormat CreateFormatEntry(string name, bool hasvardata, int numops, int op1len, int op2len, int op3len);
    internal static ObxmlInstructionFormat CreateFormatEntry4(string name, bool hasvardata, int op1len, int op2len, int op3len, int op4len);
    internal static ObxmlInstructionFormat CreateFormatEntryF(string name, int flags, bool hasvardata, int numops, int op1len, int op2len, int op3len);
    internal static ObxmlInstructionFormat CreateFormatEntrySF(string name, int flags, bool hasvardata, int numops, int op1len, int op2len, int op3len);
    internal static ObxmlInstructionFormat CreateFormatEntryEF(string name, bool hasvardata, int numops, int op1len, int op2len, int op3len);
}
internal class OracleInternal.BinXml.ObxmlInstructionState : ObxmlStateObject {
    internal InstructionTypes InstructionType;
    internal short m_Opcode;
    internal byte DataType;
    internal ulong TokenId;
    internal static string sXmlTagOpeningBracket;
    internal static string sXmlTagOpeningBracketWithSlash;
    internal static string sXmlTagClosingBracket;
    internal static string sXmlTagClosingBracketWithSpace;
    internal static string sXmlTagClosingBracketWithSlash;
    internal static string sXmlTagCommentOpen;
    internal static string sXmlTagCommentClose;
    internal static string sXmlTagSquareOpen;
    internal static string sXmlTagSquareClose;
    internal static string sXmlTagAttributeStart;
    internal static string sXmlWhitespaceNewLine;
    internal static string sXmlWhitespaceBlank;
    internal static string sXmlWhitespaceTab;
    internal static string sXmlQuote;
    internal static string sXmlDocType;
    internal static string sXmlPublic;
    internal static string sXmlSystem;
    internal static string sXmlElement;
    internal static string sXmlEntity;
    internal static string sXmlNotation;
    internal static string sXmlNdata;
    internal static string sXmlCdataStart;
    internal static string sXmlCdataEnd;
    internal static string sXmlAmp;
    internal static string sXmlPercentage;
    internal static string sXmlSemi;
    private static Dictionary`2<int, string> sXmlWhiteSpaceBlanks;
    private ObxmlDecodeState m_DecodeState;
    private static int DefaultTokenOrDataSize;
    internal Char[] m_TextOrTokenData;
    internal long m_TextOrTokenDataBufferSize;
    internal long m_TokenOrDataLength;
    internal long m_TokenOrDataOffset;
    internal long m_CsxDataLength;
    internal string m_CsxDataText;
    internal long m_CsxDataOffset;
    internal bool PreviousCharNewLine;
    internal ObxmlInstructionState(ObxmlDecodeState parent);
    private static ObxmlInstructionState();
    internal virtual void ClearStateObject();
    internal int AppendNewLine();
    internal int Append(string data, int offset, int length);
    internal int Append(Char[] data, int offset, int length);
    internal int AppendUtf8(Byte[] data, Int32& charCount, int offset, int length);
    private int AppendUnicode(Byte[] data, Int32& charCount, int offset, int length);
    private void FlushTokenTextData(int charsLength);
    private int TextTokenDataCopy(Byte[] data, int offset, int length, Int32& charscount, bool isUtf8);
    private int TextTokenDataCopy(Char[] data, int offset, int length);
    private int TextTokenDataCopy(string data, int offset, int length);
    internal void GetWhiteSpaces(Char[] textOrTokenData, ObxmlNodeState ns, bool appendEndOfLine, bool prefixEndOfLine, bool SaveToNodeLevelWhiteSpaces);
    internal void AppendElementStartTagClosing(ObxmlDecodeState decodeState, bool bPreviousElement);
    internal void AppendEmptyElementToken(ObxmlDecodeState decodeState, ObxmlNodeState ns);
    internal void AppendWhiteSpaces(ObxmlDecodeState decodeState, ObxmlNodeState ns, bool appendEndOfLine, bool prefixEndOfLine);
    internal void AppendElementStartToken(ObxmlDecodeState decodeState, ObxmlNodeState ns);
    internal void AppendElementEndToken(ObxmlDecodeState decodeState, ObxmlNodeState ns);
    private int ReadUtf8StringChar(int length);
    internal void AppendAttributeToken(ObxmlDecodeState decodeState, AttributeInfo attribute);
    internal bool AppendComment(string value, int length, bool prefixNewLine);
    internal void WriteCDATABlock(ObxmlDecodeState decodeState, string cdataValue, int length);
    internal bool StartCDATA(ObxmlDecodeState decodeState);
    internal bool EndCDATA(ObxmlDecodeState decodeState);
    internal bool AppendString(string value, int length, bool appendNewLine, bool appendSpace);
    internal bool AppendStringWithSpaces(string value, int length, string appendSpaces, string prefixSpaces);
    internal bool AppendStringWithSpaces(string value, int length, bool appendSpace, bool prefixSpace);
    internal bool AppendQuoted(string value, int length, bool appendSpace, bool prefixSpace);
    internal bool AppendEntity(string name, int length, bool appendSpace, bool prefixSpace);
    private static void FillBlankSpaces();
    internal void ClearStateDataObject();
    internal bool ResetTokenDataConsumed(int length);
    internal int ResetTextOrTokenDataLength(long consumedLength);
    internal int ResetCsxDataLength(int consumedLength);
    internal bool HasMoreCsxInstructionData(Int64& csxDataSize);
    internal bool HasMoreTokenOrData(Int64& tokenDataSize);
    internal void ResetTo(ObxmlInstructionState newState, bool copyCsxPartialBuffer);
    internal void SetInstructionState(long countCharConsumed, OpcodeIds opcode, long csxOffset, ObxmlToken token, InstructionTypes instructionType);
}
internal class OracleInternal.BinXml.ObxmlMetaDataRepository : object {
    public sealed virtual void Dispose();
    internal bool Validate(ObxmlDecodeContext decodeContextForCurrentCall);
    internal OracleXmlType GetTokenSet(ObxmlDecodeContext decodeContext, ulong tokenId, TokenTypes tokenType, string nameSpaceId, Byte[] guid, bool bPopulateTokenMap);
    internal string GetResource(ObxmlDecodeContext decodeContext, string absPath);
    internal void PopulateTokenSet(ObxmlDecodeContext decodeContext, OracleXmlType tokenSet, bool isNameSpaceTokenSet);
}
internal class OracleInternal.BinXml.ObxmlNodeState : ObxmlStateObject {
    internal NodeTypes NodeType;
    internal ulong NodeDataLen;
    internal string Prefix;
    internal short PrefixId;
    internal ObxmlNodeState m_ParentNode;
    internal ulong NsIndex;
    internal ObxmlToken m_ElementToken;
    private string qualifiedName;
    internal string m_PrefixWhiteSpaces;
    internal int NodeLevel;
    internal bool PendingDataNode;
    internal NodeFlags NodeMask;
    internal int ArrayModeCount;
    internal int ChildNodesCount;
    internal int NodeId;
    internal bool IsOptimizedOpcode;
    internal bool HasPrefix { get; }
    internal bool IsAttribute { get; }
    internal bool IsArrayMode { get; }
    internal bool IsSequentialMode { get; }
    internal bool get_HasPrefix();
    internal bool get_IsAttribute();
    internal bool get_IsArrayMode();
    internal bool get_IsSequentialMode();
    internal void SetArrayMode(bool hasArrayMode);
    internal void ResetObxmlNodeState(NodeTypes nodeType, ObxmlToken token);
    internal void ResetObxmlNodeState(NodeTypes nodeType, ObxmlToken token, ulong nodeDataLen);
    internal virtual void ClearStateObject();
    internal void Reset();
    internal string ConvertToText(ObxmlDecodeState decodeState);
    internal static NodeTypes GetDefaultNodeTypeForTokenType(TokenTypes tokenType);
    internal static TokenTypes GetDefaultTokenTypeForNodeType(NodeTypes nodeType);
    internal AttributeInfo GetAttributeInfo(ObxmlDecodeState decodeState, ulong index);
    internal void AddAttributeInfo(ObxmlDecodeState decodeState, AttributeInfo attributeInfo);
    internal string GetQualifiedName(ObxmlDecodeState decodeState);
    internal string SetPrefix(ObxmlDecodeState decodeState, string px);
    internal ObxmlNodeState Clone();
}
internal class OracleInternal.BinXml.ObxmlObjectPool`1 : object {
    private static int INITIAL_POOL_SIZE;
    private Queue`1<T> m_ObjectPool;
    private int m_PoolSize;
    private object m_syncPool;
    internal bool IsEnabled { get; }
    public ObxmlObjectPool`1(int poolsize);
    internal bool get_IsEnabled();
    internal T Get();
    internal int Count();
    internal void Put(T obj);
    internal void Purge(int size);
}
internal class OracleInternal.BinXml.ObxmlOpcode : object {
    internal static byte HDR_CSX_VERSION;
    internal static String[] ENCODING_TYPES;
    internal static int STARTELEM_FLAG_SSEQ;
    internal static int STARTELEM_FLAG_NOTDECTYP;
    internal static int STARTELEM_FLAG_IMPTYP;
    internal static int STARTELEM_FLAG_PFXID;
    internal static int DATL2MAXLEN;
    internal static long DATL8MAXLEN;
    internal static int DATL2STRMSK;
    internal static int DATL2BINMSK;
    internal static long DATL8STRMSK;
    internal static long DATL8BINMSK;
    internal static int ENCODER_IGN_WHITESPACE;
    internal static int ENCODER_NO_OPTPRPOPC;
    internal static int ENCODER_FORCE_NONSCHEMABASED;
    internal static int ENCODER_NO_SCHEMASEQ;
    internal static int ENCODER_NO_ARRAYMODE;
    internal static int DTD_SYSTEM_EMPTY;
    internal static int DTD_internal_EMPTY;
    internal static int DTD_internal_SYSTEM_EMPTY;
    internal static int DTD_VALUE_EMPTY;
    internal static int NAMESPACEID_XML;
    internal static int NAMESPACEID_XMLNS;
    internal static int NAMESPACEID_NONAMESPACE;
    internal static short SPACE_FLAG;
    internal static short TAB_FLAG;
    internal static short LNFEED_FLAG;
    internal static short CR_FLAG;
    internal static short CR_SPACE_FLAG;
    internal static short SPACE1_IDMASK;
    internal static short SPACE2_IDMASK;
    internal static short SPACE_FLAGMASK;
    internal static int CSX_MAX_HASH_TRIES;
    internal static int CSX_IDGEN_SKIP_LEN;
    internal static long UB4MAXVAL;
    internal static long SB4MAXVAL;
    internal static int UB2MAXVAL;
    internal static int SB2MAXVAL;
    internal static short UB1MAXVAL;
    internal static int CSX_TOKENTABLE_INITIAL_CAPACITY;
    internal static int CSX_NAMESPACE_LIST_INITIAL_CAPACITY;
    internal static string CSX_DEFAULT_ENCODING;
    internal static int CSX_INTERNAL_ERR;
    internal static int CSX_UNEXPECTED_EOF_ERR;
    internal static int CSX_NOT_FOUND_ERR;
    internal static int CSX_MAX_PEFIX_LEN_ERR;
    internal static int CSX_INVALID_BINXML_ERR;
    internal static int CSX_INVALID_ENCTYPE_ERR;
    internal static int CSX_MAX_NSURL_ERR;
    internal static int CSX_TYPECONV_ERR;
    internal static int CSX_INVALID_DTDEVT_ERR;
    internal static int CSX_MISMATCH_TGTNS_ERR;
    internal static int CSX_INVALID_SCHEMALINF_ERR;
    internal static int CSX_CANNOT_CREATEURL_ERR;
    internal static int CSX_NSID_ERR;
    internal static int CSX_TOKEN_NOTFOUND_ERR;
    internal static int CSX_VERSION_MISMATCH;
    internal static int CSX_INVALID_OPCODE_ERR;
    internal static int CSX_NO_STRING_TERMINATOR_ERR;
    internal static string CSX_NS_DEFINITION;
    internal static string CSX_ENCODING_TYPE;
    internal static string CSX_KIDLIST;
    internal static string CSX_KID;
    internal static string CSX_PROPERTY_ID;
    internal static string CSX_TYPE_ID;
    internal static string STR_ENCODING_TYPE;
    internal static string STR_PROPERTY_ID;
    internal static string STR_TYPE_ID;
    internal static string STR_SEQUENTIAL;
    internal static string STR_KIDNUM;
    internal static string STR_KIDLIST;
    internal static string POSITIVE_SIGN;
    internal static int MAX_RESERVED_TYPE_IDS;
    internal static long SIMPLIFIED_INLINE_ENCODING_START_TOKENID;
    internal static Byte[] dataType;
    private static ObxmlOpcode();
}
internal class OracleInternal.BinXml.ObxmlOutputObject : object {
    internal static int s_OutputNumericValueNotSet;
    private InputOutputTypes m_outputContentType;
    [CompilerGeneratedAttribute]
private long <WriteOffset>k__BackingField;
    internal object m_OutputObject;
    [CompilerGeneratedAttribute]
private bool <OutputObjectOwnedByClient>k__BackingField;
    internal ObxmlDecodeRequest m_Parent;
    [CompilerGeneratedAttribute]
private OutputEncodingTypes <EncodingType>k__BackingField;
    private static int DefaultUnicodeStringSize;
    internal Char[] m_UnicodeArray;
    private bool m_UnicodeArrayInUse;
    private object m_nlsLock;
    internal long WriteOffset { get; internal set; }
    internal bool OutputObjectOwnedByClient { get; internal set; }
    internal InputOutputTypes OutputType { get; internal set; }
    internal OutputEncodingTypes EncodingType { get; internal set; }
    internal ObxmlOutputObject(ObxmlDecodeRequest parent);
    private static ObxmlOutputObject();
    [CompilerGeneratedAttribute]
internal long get_WriteOffset();
    [CompilerGeneratedAttribute]
internal void set_WriteOffset(long value);
    [CompilerGeneratedAttribute]
internal bool get_OutputObjectOwnedByClient();
    [CompilerGeneratedAttribute]
internal void set_OutputObjectOwnedByClient(bool value);
    internal InputOutputTypes get_OutputType();
    internal void set_OutputType(InputOutputTypes value);
    internal bool IsOutputType(InputOutputTypes outputType);
    [CompilerGeneratedAttribute]
internal OutputEncodingTypes get_EncodingType();
    [CompilerGeneratedAttribute]
internal void set_EncodingType(OutputEncodingTypes value);
    internal int ReadTextInUnicode(Byte[] bytes, int offset, int bytesCount);
    internal string ReadTextInUnicode_old(Byte[] bytes, int offset, int bytesCount);
    internal void SetObxmlOutputObject(Byte[] textBuffer, bool outputOwnedByClient);
    internal void SetObxmlOutputObject(StringBuilder& utf16OutputBuilder, bool outputOwnedByClient, long inputEstimate);
    internal void SetObxmlOutputObject(Byte[] textBuffer, long offset);
    internal void SetObxmlOutputObject(FileStream outputFileStream);
    internal long WriteTextOutput(StringBuilder sbText, int readOffset);
    internal long WriteTextOutput(string text);
    internal long WriteTextOutput(ObxmlStream input, int lengthToCopyFromInput, DelegateReplaceCharsInSB replaceDelegate);
    internal long WriteTextOutput(string text, int readOffset);
    internal long WriteTextOutput(Char[] text, int readOffset, int length);
    internal long WriteTextOutput(Byte[] text, int readOffset);
    internal bool IsOutputContentTypeValid(InputOutputTypes contentType);
    internal bool IsOutputValid();
    internal bool ResetOutputObject();
}
internal class OracleInternal.BinXml.ObxmlProcessor : object {
    private ObxmlDecodeContext m_DecodeContext;
    private object m_DecodeContextLock;
    internal ObxmlDecodeStream GetDecodeStream(OracleConnection conn, OracleBlob csxBlob);
    internal void DisposeDecodeStream();
    internal void CloseDecodeStream(ObxmlDecodeContext decodeContext);
}
internal class OracleInternal.BinXml.ObxmlSectionHeader : ObxmlStateObject {
    internal byte Version;
    internal byte Flags;
    internal Byte[] DocId;
    internal Byte[] Rguid;
    internal Byte[] PathId;
    internal bool BigEflt;
    internal virtual void ClearStateObject();
}
internal abstract class OracleInternal.BinXml.ObxmlStateObject : object {
    internal abstract virtual void ClearStateObject();
}
internal class OracleInternal.BinXml.ObxmlStream : object {
    internal static long sUseCurrentOffset;
    private BinXmlArrayStream m_DataStream;
    private bool m_Disposed;
    private static int DefaultUnicodeStringSize;
    private Char[] m_UnicodeArray;
    internal static Conv Unicode_AL16UTF16_CHARSET;
    internal static Conv Utf8_AL32UTF8_CHARSET;
    private ObxmlContentObject m_contentObj;
    private Char[] m_temp;
    internal long Position { get; internal set; }
    internal ObxmlStream(ObxmlContentObject contentObj);
    private static ObxmlStream();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal long get_Position();
    internal void set_Position(long value);
    internal Stream Open(string filePath);
    internal Stream Open(OracleBlob blob);
    internal void Close();
    internal void ReadAndCopyBytes(Byte[] destination, long offset, long count);
    internal Byte[] ReadBytes(int count);
    internal void SkipBytes(int count);
    internal Byte[] ReadAllBytes(int offset);
    internal short ReadShortIntFromByte();
    internal short ReadShortInt();
    internal int ReadInt4();
    internal long ReadInt8();
    internal char ReadChar();
    internal Char[] ReadChar(int count);
    internal int ReadUtf8StringSB(ulong length, StringBuilder sb, DelegateReplaceCharsInSB replaceDelegate);
    internal int ReadUtf8StringChar(int length, ObxmlInstructionState currentInstruction);
    internal string ReadUtf8String(ulong length, StringBuilder sb);
    internal static Byte[] Reverse(Byte[] array, int count, int startpost);
}
internal class OracleInternal.BinXml.ObxmlTextStream : XmlTextWriter {
    private Char[] m_chars;
    internal ObxmlTextStream(StringBuilder sb);
    internal void AppendCData(string cdata);
    internal void AppendComment(string comment);
    internal void AppendData(Byte[] data);
    internal void Clear();
}
internal class OracleInternal.BinXml.ObxmlToken : object {
    private object tokenLock;
    internal ulong TokenId;
    internal ulong NamespaceId;
    [CompilerGeneratedAttribute]
private string <m_TokenName>k__BackingField;
    private static int DefaultCharArraySize;
    private static Char[] m_TokenCharArray;
    internal string Uri;
    internal TokenTypes TokenType;
    internal Byte[] m_TokenNameBytes;
    internal string m_TokenName { get; internal set; }
    internal string TokenName { get; internal set; }
    internal bool IsAttribute { get; }
    internal bool IsNamespaceToken { get; }
    internal bool IsPrefixToken { get; }
    internal bool IsElementToken { get; }
    internal ObxmlToken(ulong tokenId, string tokenName, TokenTypes tokenType);
    internal ObxmlToken(ulong tokenId, ulong namespaceId, string tokenName, TokenTypes tokenType);
    internal ObxmlToken(ulong tokenId, Byte[] tokenNameBytes, TokenTypes tokenType);
    internal ObxmlToken(ulong tokenId, ulong namespaceId, Byte[] tokenNameBytes, TokenTypes tokenType);
    private static ObxmlToken();
    [CompilerGeneratedAttribute]
internal string get_m_TokenName();
    [CompilerGeneratedAttribute]
internal void set_m_TokenName(string value);
    internal string get_TokenName();
    internal void set_TokenName(string value);
    internal bool get_IsAttribute();
    internal bool get_IsNamespaceToken();
    internal bool get_IsPrefixToken();
    internal bool get_IsElementToken();
}
internal class OracleInternal.BinXml.ObxmlTokenManager : object {
    private ObxmlMetaDataRepository m_DefaultMetaDataRepository;
    private bool m_bOwnsMetaDataRepository;
    private Hashtable m_TokenMapHash;
    private static int m_MaxTokenPoolEntries;
    private OraclePoolManager m_parent;
    private object m_tokenMapLock;
    internal static bool ClientDecodeEnabled { get; }
    internal static int MaxTokenPoolEntries { get; }
    internal int Count { get; }
    internal ObxmlTokenManager(OraclePoolManager parent);
    private static ObxmlTokenManager();
    internal static bool get_ClientDecodeEnabled();
    internal static int get_MaxTokenPoolEntries();
    internal static ObxmlTokenManager GetOracleBinXmlTokenManager(ObxmlDecodeContext decodeContext);
    internal static ObxmlTokenManager GetOracleBinXmlTokenManager(OracleConnection dbConnection);
    internal ObxmlMetaDataRepository GetDefaultMetaDataRepository(bool bDisposeMetaDataRepository, ObxmlDecodeContext decodeContext);
    internal ObxmlTokenMap Open(ObxmlTokenManagerContext tmContext);
    internal int get_Count();
    internal ObxmlTokenMap Open(string partitionId);
    internal void Close(ObxmlTokenMap tokenMap);
    internal void Close(string partitionId);
    internal void Clear(ObxmlTokenMap tokenMap);
    internal void Clear(string partitionId);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void PurgeTokenMaps(List`1<string> lruPartitionsList, int thresHold);
    private void SetMap(ObxmlTokenMap& tokenMap, string partitionId);
    private ObxmlTokenMap GetMap(string partitionId);
}
internal class OracleInternal.BinXml.ObxmlTokenManagerContext : object {
    private String[] m_TokenMgrStringIds;
    private Object[] m_TokenMgrObjectIds;
    private string m_PartitionId;
    internal bool IsValid { get; }
    internal string PartitionId { get; }
    internal ObxmlTokenManagerContext(String[] tokenMgrStringIds, Object[] tokenMgrObjectIds);
    internal static ObxmlTokenManagerContext CreateDefaultTokenManagerContext(OracleConnection connection);
    internal bool get_IsValid();
    internal string get_PartitionId();
}
internal class OracleInternal.BinXml.ObxmlTokenMap : object {
    private static ulong m_Nsidnull;
    private static ulong m_Nsidxi;
    internal static List`1<ObxmlToken> m_NsTokenList;
    internal static List`1<ObxmlToken> m_AttrTokenList;
    private TokenTypes m_DefaultTokenType;
    private bool m_bInit;
    private ObxmlTokenManagerContext m_tmContext;
    private CacheWithLRUList`2<ulong, ObxmlToken> m_ElementAttributeTokens;
    private CacheWithLRUList`2<ulong, ObxmlToken> m_NamespaceTokens;
    private Hashtable m_NamespaceUriTokens;
    internal string PartitionId;
    internal bool IsActive;
    internal string TokenMapSizeString { get; }
    internal ulong NSIDNULL { get; }
    internal ulong NSIDXI { get; }
    private static ObxmlTokenMap();
    internal ObxmlTokenMap(ObxmlTokenManagerContext context, TokenTypes tokenType);
    internal string get_TokenMapSizeString();
    internal void Clear();
    internal ObxmlTokenManagerContext GetTokenMgrContext();
    internal ulong get_NSIDNULL();
    internal ulong get_NSIDXI();
    internal bool Init();
    internal string GetPartitionId();
    internal void SetToken(ObxmlToken token);
    internal ObxmlToken PopulateNamespaceUri(ObxmlDecodeContext decodeContext, ObxmlToken token);
    internal string GetTokenNameForDefaultTokenType(ObxmlDecodeContext decodeContext, ulong tokenId);
    internal ObxmlToken ConvertNSIDToNullNameSpaceId(ObxmlDecodeContext decodeContext, ObxmlToken token, bool tryBothIds);
    internal ObxmlToken GetTokenForDefaultTokenType(ObxmlDecodeContext decodeContext, ulong tokenId);
    internal ObxmlToken GetToken(ObxmlDecodeContext decodeContext, ulong tokenId, TokenTypes tokenType, bool tryRepository);
    internal static bool TryGetValue(CacheWithLRUList`2<ulong, ObxmlToken> tokenCache, ulong key, ObxmlToken& value);
    internal ObxmlToken GetToken(ObxmlDecodeContext decodeContext, ulong tokenId, bool tryRepository);
    internal string GetTokenName(ObxmlDecodeContext decodeContext, ulong tokenId, TokenTypes tokenType);
    internal string GetTokenName(ObxmlDecodeContext decodeContext, ulong tokenId);
    internal void RegisterNamespace(ObxmlToken token);
    internal string GetNamespaceUri(ObxmlDecodeContext decodeContext, ulong nsid, ObxmlToken& token);
    internal ObxmlToken GetNamespaceToken(ObxmlDecodeContext decodeContext, ulong nsid, TokenTypes tokenType);
    internal static ObxmlToken CreateObxmlToken(ulong tokenId, string tokenName, TokenTypes tokenType);
    internal ObxmlToken CreateToken(ulong tokenId, string tokenName, TokenTypes tokenType);
    internal static ObxmlToken CreateObxmlNamespaceToken(ulong tokenId, string namespaceURI);
    internal ObxmlToken CreateNamespaceToken(ulong tokenId, string namespaceURI);
    internal static ObxmlToken CreateObxmlQNameToken(ulong tokenId, ulong namespaceId, string localName, bool isAttribute);
    internal ObxmlToken CreateQNameToken(ulong tokenId, ulong namespaceId, string localName, bool isAttribute);
    internal ObxmlToken PutNamespaceNonSchema(string namespaceURI);
    internal ulong GetNamespaceTokenId(string namespaceURI);
}
internal enum OracleInternal.BinXml.OutputEncodingTypes : Enum {
    public int value__;
    public static OutputEncodingTypes Utf8;
    public static OutputEncodingTypes Unicode;
    public static OutputEncodingTypes Utf16;
    public static OutputEncodingTypes None;
}
internal class OracleInternal.BinXml.PrefixInfo : object {
    internal string Prefix;
    internal string Uri;
    internal ulong Nsid;
    internal short PrefixId;
    internal PrefixInfo(ObxmlDecodeContext decodeContext, short pfxid, string prefix, ulong nsid, string uri);
    internal static PrefixInfo GetPrefixInfo(ObxmlDecodeState decodeState, ulong prefixId, PrefixInfo prefixInfo, bool refetchPrefixInfo);
    protected object Clone();
}
internal enum OracleInternal.BinXml.TokenTypes : Enum {
    public int value__;
    public static TokenTypes NamespaceToken;
    public static TokenTypes AttributeToken;
    public static TokenTypes PrefixToken;
    public static TokenTypes ElementToken;
    public static TokenTypes None;
}
internal class OracleInternal.BulkCopy.BulkCopyBindingRow : object {
    private static Queue`1<BulkCopyBindingRow> s_bindingRowCache;
    private static object s_bindingRowCacheLock;
    internal int m_columnCount;
    internal Byte[][] m_columnsBindValues;
    internal Boolean[] m_col_nullIndicators;
    internal Int32[] m_bindValuesLen;
    private static BulkCopyBindingRow();
    private BulkCopyBindingRow(int columnCount);
    internal static void AddToCache(BulkCopyBindingRow bindingRow);
    internal static void AddToCache(List`1<BulkCopyBindingRow> bindingRows);
    internal static BulkCopyBindingRow GetFromCache(int columnCount);
    internal void Reset();
    internal void Initialize(int columnCount);
    internal BulkCopyBindingRow Copy();
}
internal class OracleInternal.BulkCopy.BulkCopyBindingRowList : object {
    private List`1<BulkCopyBindingRow> m_bindingRows;
}
internal abstract class OracleInternal.BulkCopy.BulkCopyDataSource : object {
    protected ColumnDescribeInfo[] m_columnsMetaData;
    protected OracleBulkCopy m_bulkCopy;
    internal bool m_bMoveToNextRow;
    internal bool m_bAllRowsRead;
    internal BulkCopyDataSource(OracleBulkCopy bulkCopy, int requestedBatchSize);
    protected BulkCopyBindingRow GetBindingRow(int rowIndex, BulkCopyRows rows);
    public abstract virtual bool CanReadNext();
    public abstract virtual int GetBatchSize();
    public abstract virtual void Initialize(ColumnDescribeInfo[] destinationColumnsMetaData);
    public abstract virtual int GetColumnCount();
    public abstract virtual int GetColumnOrdinal(string columnName);
    public abstract virtual Type GetSrcColumnType(int columnIndex);
    public abstract virtual int PopulateRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRow);
    public abstract virtual int GetRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRows, BulkCopyRows& row);
}
internal enum OracleInternal.BulkCopy.BulkCopyResult : Enum {
    public int value__;
    public static BulkCopyResult Success;
    public static BulkCopyResult AllRowRead;
    public static BulkCopyResult UserAbort;
    public static BulkCopyResult Timeout;
}
internal class OracleInternal.BulkCopy.BulkCopyRows : object {
    private bool m_bTimeout;
    internal int m_columnCount;
    internal int m_numOfRowsProcessed;
    internal ColumnDescribeInfo[] m_columnsMetaData;
    internal bool m_bAllfastColumns;
    internal List`1<BulkCopyBindingRow> m_bindingRows;
    internal bool Timeout { get; }
    internal BulkCopyRows(ColumnDescribeInfo[] columnsMetadata, bool bAllFastColTypes);
    internal void Reset();
    internal static bool IsFastType(int typeCode);
    internal static bool IsAllFastType(ColumnDescribeInfo[] columnsMetaData);
    internal bool get_Timeout();
}
internal class OracleInternal.BulkCopy.BulkCopySourceDataReader : BulkCopySourceDotNetTypes {
    internal IDataReader m_dataSource;
    internal BulkCopySourceDataReader(IDataReader reader, OracleBulkCopy bulkCopy, int requestedBatchSize);
    public virtual int GetColumnCount();
    public virtual int GetColumnOrdinal(string columnName);
    public virtual Type GetSrcColumnType(int columnIndex);
    private bool ReadNext();
    public virtual int GetBatchSize();
    private int PopulateOneRow(OracleBulkCopyColumnMappingCollection internalColumnMappings);
    protected int PopulateArrayRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRows);
    public virtual int PopulateRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRow);
    public virtual bool CanReadNext();
}
internal class OracleInternal.BulkCopy.BulkCopySourceDataRows : BulkCopySourceDotNetTypes {
    internal DataTable m_dataSource;
    internal IEnumerator m_rowEnumerator;
    internal BulkCopySourceDataRows(DataTable dt, OracleBulkCopy bulkCopy, int requestedBatchSize);
    public virtual int GetColumnCount();
    public virtual int GetColumnOrdinal(string columnName);
    public virtual Type GetSrcColumnType(int columnIndex);
    public virtual int GetBatchSize();
    private DataRow ReadNext();
    internal virtual bool CheckRowState(DataRow dataRow);
    protected int PopulateOneRow(OracleBulkCopyColumnMappingCollection internalColumnMappings);
    protected int PopulateArrayRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRows);
    public virtual int PopulateRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRow);
    public virtual bool CanReadNext();
}
internal class OracleInternal.BulkCopy.BulkCopySourceDataTable : BulkCopySourceDataRows {
    internal DataRowState m_rowState;
    internal BulkCopySourceDataTable(DataTable dt, OracleBulkCopy bulkCopy, int requestedBatchSize, DataRowState rowState);
    internal BulkCopySourceDataTable(DataTable dt, OracleBulkCopy bulkCopy, int requestedBatchSize);
    internal virtual bool CheckRowState(DataRow dataRow);
}
internal abstract class OracleInternal.BulkCopy.BulkCopySourceDotNetTypes : BulkCopyDataSource {
    protected OracleParameterCollection m_columns;
    private ColumnDescribeInfo[] m_cachedParamMetadata;
    internal BulkCopySourceDotNetTypes(OracleBulkCopy bulkCopy, int requestedBatchSize);
    private int GetOneRow(OracleBulkCopyColumnMappingCollection internalColumnMappings, int rowIndex, BulkCopyRows bulkCopyRows);
    private void CheckSourceValues(int numOfRows);
    private int GetArrayRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRows, BulkCopyRows bulkCopyRows);
    public virtual void Initialize(ColumnDescribeInfo[] destinationColumnsMetaData);
    public virtual int GetRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRows, BulkCopyRows& bulkCopyRows);
}
internal class OracleInternal.BulkCopy.BulkCopySourceOracleDataReader : BulkCopySourceDotNetTypes {
    internal OracleDataReader m_dataSource;
    internal BulkCopySourceOracleDataReader(OracleDataReader reader, OracleBulkCopy bulkCopy, int requestedBatchSize);
    public virtual int GetColumnCount();
    public virtual int GetColumnOrdinal(string columnName);
    public virtual Type GetSrcColumnType(int columnIndex);
    private bool ReadNext();
    public virtual int GetBatchSize();
    private int PopulateOneRow(OracleBulkCopyColumnMappingCollection internalColumnMappings);
    protected int PopulateArrayRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRows);
    public virtual int PopulateRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRow);
    public virtual bool CanReadNext();
}
internal class OracleInternal.BulkCopy.DirectPathDefine : object {
    private static short KDRCSSHC;
    private static short KDRCSLNG;
    private static short KDRCSNUL;
    internal static int KPCDP_STR_MAX_ROW_PIECE_SIZE;
    internal static short KPCDP_STR_RHDR;
    internal static byte KPCDP_STR_RHDR_OVERFLOW;
    internal static byte KPCDP_STR_RHDR_ERROR;
    internal static byte KPCDP_STR_RHDR_BYTE_CLEN;
    internal static byte KPCDP_STR_RHDR_FRC;
    internal static byte KPCDP_STR_RHDR_FAST;
    internal static byte KPCDP_STR_RHDR_FIRST;
    internal static byte KPCDP_STR_RHDR_LAST;
    internal static byte KPCDP_STR_RHDR_PREV;
    internal static byte KPCDP_STR_RHDR_NEXT;
    internal static short KPCDP_STR_CCNT;
    internal static short KPCDP_STR_CCNT_MAX;
    internal static ushort KPCDP_STR_RLEN;
    internal static ushort KPCDP_STR_CLEN;
    internal static short KPCDP_STR_BYTE_CLEN;
    internal static short KPCDP_STR_THREE_BYTE_CLEN;
    internal static ushort KPCDP_STR_CLEN_NULL;
    internal static short KPCDP_STR_BYTE_CLEN_NULL;
    internal static short KPCDP_STR_CLEN_FOLLOWS;
    internal static ushort KPCDP_STR_CLEN_EMPTY;
    internal static ushort KPCDP_STR_CLEN_ADT;
    internal static ushort KPCDP_STR_CLEN_ALIGN;
    internal static int KPCDP_STR_CLEN_MAX;
    internal static short KPCDP_STR_BYTE_CLEN_MAX;
    internal static ushort KPCDP_STR_SUBTYPE_INDEX_LEN;
    internal static short KPCDP_STR_CLEN_SPECIAL;
    internal static short KPCDP_STR_CLEN_SPECIAL_SIZE;
    internal static short KPCDP_STR_CLEN_SPECIAL_LOB_MD;
    internal static string KPCDP_STR_CLEN_SPECIAL_LOB_MD_VER;
    internal static int KPCDP_STR_ROW_MIN;
    internal static int KPCDP_STR_COL_MIN;
    internal static int KPCDPLS_ROW_INCOMPLETE;
    internal static int KPCDPLS_ROW_PARTIAL;
    internal static int KPCDPLS_STREAM_CONSUMED;
    internal static int STREAM_BUFFER_SIZE;
    internal static int MAX_BATCHSIZE;
    internal static byte FAST_HEADER_FLAGS;
    internal static int ROWPIECE_FAST_HEADER_SIZE;
    internal static int ROWPIECE_SLOW_HEADER_SIZE;
    internal static short MAXSIZE_OF_BYTELEN;
    internal static int ROWPIECE_MAX_SIZE;
    internal static int ROWPIECE_MAX_FAST_DATA;
    internal static int ROWPIECE_MAX_DATA_LENGTH;
    internal static int ROWPIECE_MAX_DATA_LENGTH_ENCODING;
    internal static int ROWPIECE_THREE_BYTE_ENCODING_LEN;
    internal static int ROWPIECE_NULL_INDICATOR;
    internal static int ROWPIECE_EMPTY_INDICATOR;
    internal static short ROWPIECE_MAX_COLUMN_COUNT;
    internal static int INTERNAL_BATCH_SIZE;
}
internal class OracleInternal.BulkCopy.DirectPathRow : object {
    private static Queue`1<DirectPathRow> s_directPathRowCache;
    private static object s_directPathRowCacheLock;
    internal List`1<DirectPathRowPiece> m_rowPieces;
    private bool m_bIsAllFastType;
    private int m_rowSize;
    internal int Size { get; }
    private static DirectPathRow();
    private DirectPathRow(bool bFastTypes);
    internal static void AddToCache(DirectPathRow dpRow);
    internal static void AddToCache(List`1<DirectPathRow> dpRows);
    internal static DirectPathRow GetFromCache(bool bFastType);
    internal void Reset();
    internal void Initialize(bool bFastType);
    internal int get_Size();
    internal void AddPiece(DirectPathRowPiece rowPiece);
    private void RemovePiece(DirectPathRowPiece rowPiece);
    internal static DirectPathRow SplitRow(int requestedRowSize, DirectPathRow rowToSplit);
}
internal class OracleInternal.BulkCopy.DirectPathRowPiece : object {
    private static Queue`1<DirectPathRowPiece> s_directPathRowPieceCache;
    private static object s_directPathRowPieceCacheLock;
    internal int m_totalColsLen;
    internal int m_firstColIndex;
    internal int m_beginColDataOffset;
    internal int m_endColIndex;
    internal int m_endColDataOffset;
    internal bool m_bFastRow;
    internal bool m_bFullRow;
    internal bool m_bFirstPiece;
    internal bool m_bLastPiece;
    internal bool m_bContinueFromPrevPiece;
    internal bool m_bContinueToNextPiece;
    internal int m_colCount;
    internal short Flags { get; }
    internal int RowPieceLen { get; }
    private static DirectPathRowPiece();
    internal static void AddToCache(DirectPathRowPiece dpRowPiece);
    internal static void AddToCache(List`1<DirectPathRowPiece> dpRowPieces);
    internal static DirectPathRowPiece GetFromCache();
    internal static DirectPathRowPiece CreateFullPiece(bool bAllFastColumns, int len, int firstColIndex, int firstColDataOffset, int endColIndex, int endColDataOffset);
    internal static DirectPathRowPiece CreateFirstPiece(bool bAllFastColumns, int len, int firstColIndex, int firstColDataOffset, int endColIndex, int endColDataOffset);
    internal static DirectPathRowPiece CreateNextPiece(bool bAllFastColumns, int len, int firstColIndex, int firstColDataOffset, int endColIndex, int endColDataOffset);
    internal static DirectPathRowPiece CreateLastPiece(bool bAllFastColumns, int len, int firstColIndex, int firstColDataOffset, int endColIndex, int endColDataOffset);
    internal static DirectPathRowPiece CreateFirstSplitPiece(bool bAllFastColumns, int len, int colIndex, int beginDataOffset, int endDataOffset);
    internal static DirectPathRowPiece CreateNextSplitPiece(bool bAllFastColumns, int len, int colIndex, int beginDataOffset, int endDataOffset);
    internal static DirectPathRowPiece CreateLastSplitPiece(bool bAllFastColumns, int len, int colIndex, int beginDataOffset, int endDataOffset, bool bLastPiece);
    internal void InitRowPiece(bool bFastRow, int len, int firstColIndex, int beginColDataOffset, int endColIndex, int endColDataOffset);
    internal void InitFullPiece(bool bAllFastColumns, int len, int firstColIndex, int firstColDataOffset, int endColIndex, int endColDataOffset);
    internal void InitFirstPiece(bool bAllFastColumns, int len, int firstColIndex, int firstColDataOffset, int endColIndex, int endColDataOffset);
    internal void InitNextPiece(bool bAllFastColumns, int len, int firstColIndex, int firstColDataOffset, int endColIndex, int endColDataOffset);
    internal void InitLastPiece(bool bAllFastColumns, int len, int firstColIndex, int firstColDataOffset, int endColIndex, int endColDataOffset);
    internal void InitFirstSplitPiece(bool bAllFastColumns, int len, int colIndex, int beginDataOffset, int endDataOffset);
    internal void InitNextSplitPiece(bool bAllFastColumns, int len, int colIndex, int beginDataOffset, int endDataOffset);
    internal void InitLastSplitPiece(bool bAllFastColumns, int len, int colIndex, int beginDataOffset, int endDataOffset, bool bLastPiece);
    internal short get_Flags();
    internal int get_RowPieceLen();
    internal void MarshalHeader(MarshallingEngine mEngine, int rowIndex);
    private static void MarshalColLength(MarshallingEngine mEngine, int length);
}
internal class OracleInternal.BulkCopy.DirectPathStreamPlanner : object {
    internal ColumnDescribeInfo[] m_colsMetaData;
    internal OracleParameterCollection m_colParameters;
    internal Object[] m_colParamValueArray;
    internal List`1<DirectPathRow> m_rows;
    internal static string ConvertToQuotedDbObjName(string inputName);
    internal static int SizeOfColumnLength(bool bIsNull, bool bIsEmpty, int colDataLen);
    internal static bool IsLargeColumn(int oraType);
    internal static DirectPathRow CreateDirectPathRow(string schemaName, string tableName, DirectPathContext dpContext, bool bAllFastColumns, BulkCopyBindingRow bindingRow);
    internal static int CreateRowPieceForLargeSizeColumn(DirectPathRow row, bool bAllFastColumns, int colIndex, int colLen, bool bLastCol);
}
internal interface OracleInternal.BulkCopy.IBulkCopyDataSource {
    public abstract virtual void Initialize(ColumnDescribeInfo[] destinationColumnsMetaData);
    public abstract virtual int GetColumnCount();
    public abstract virtual int GetColumnOrdinal(string columnName);
    public abstract virtual Type GetSrcColumnType(int columnIndex);
    public abstract virtual int GetBatchSize();
    public abstract virtual int PopulateRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRow);
    public abstract virtual int GetRows(OracleBulkCopyColumnMappingCollection internalColumnMappings, int numOfRows, BulkCopyRows& rows);
    public abstract virtual bool CanReadNext();
}
internal abstract class OracleInternal.Common.AbstractConfigProvider : AbstractUrlProvider {
    internal ConfigUrl ConfigUrl { get; }
    protected AbstractConfigProvider(ConfigUrl configUrl);
    internal ConfigUrl get_ConfigUrl();
}
internal abstract class OracleInternal.Common.AbstractSecret : object {
    internal static string AZURE_SECRET_LABELNAMEKEY;
    internal static string OCI_SECRET_LABELNAMEKEY;
    internal static string BASE64_SECRET_LABELNAMEKEY;
    internal static string SECRET_AUTH;
    internal static string SECRET_TYPE;
    internal static string SECRET_VALUE;
    internal static string SECRET_AUTH_METHOD;
    internal static string SECRET_VERSION_NUMBER;
    internal static string SECRET_STAGE;
    internal static SecretProviderType GetProviderType(string providerName);
}
public abstract class OracleInternal.Common.AbstractTokenAuthentication : object {
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventHandler ClearTokenCacheEvent;
    internal bool IsReadOnly { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
internal void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
internal static void add_ClearTokenCacheEvent(EventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_ClearTokenCacheEvent(EventHandler value);
    internal static void ClearTokenCache();
}
internal abstract class OracleInternal.Common.AbstractUrlProvider : object {
    protected static string ODPKEY_SEPARATOR;
    protected static string ODP_CONFIG_KEY;
    protected static string ODP_CONNSTR;
    protected static string AZURE_ODP_KEY;
    protected static string JSON_ODP_KEY;
    internal static string AZURE_CONNSTR_KEY;
    internal static string JSON_CONNSTR_KEY;
    protected static string COMMON_USER_KEY;
    protected static string COMMON_PASSW_KEY;
    protected static string COMMON_CONNECTDESC_KEY;
    protected static string COMMON_CONFIGTIMETOLIVE_KEY;
    internal static string ORACONN_CHUNK_MIG_CONN_TIMEOUT;
    internal static string ORACONN_DRCP_CONN_CLASS;
    internal static string ORACONN_OCI_COMPARTMENT;
    internal static string ORACONN_OCI_DATABASE;
    internal static string ORACONN_OCI_IAM_URL;
    internal static string ORACONN_OCI_TENANCY;
    internal static string ORACONN_DB_EDITION_NAME;
    internal static string ORACONN_PASSW_AUTH;
    internal static string ORACONN_TOKEN_AUTH;
    internal static string ORACONN_BIND_BY_NAME;
    internal static string ORACONN_COMMAND_TIMEOUT;
    internal static string ORACONN_CONNECTIONID_PREFIX;
    internal static string ORACONN_FETCHSIZE;
    internal static string ORACONN_MAX_STMT_CACHESIZE;
    internal static string ORACONN_USE_CLIENT_INITIATED_CQN;
    internal static string ORACONN_PIPELINING;
    internal static string ORACONN_SERVICE_RELOC_CONN_TIMEOUT;
    internal static string ORACONN_SSL_WALLET;
    internal static string ORACONN_ACCESS_TOKEN;
    protected ProviderUrl m_providerUrl;
    protected UrlAuth m_urlAuth;
    internal ProviderUrl ProviderUrl { get; }
    internal UrlProviderType ProviderType { get; }
    internal UrlAuth UrlAuthentication { get; }
    protected AbstractUrlProvider(ProviderUrl connStrUrl);
    internal static OracleOpaqueString GetOpaquePassw(string passwStr);
    internal static bool GetSecretFromSecretUrl(string secretUrlStr, OracleOpaqueString& opaqueSecret, bool bUseUrlProviderCache);
    internal ProviderUrl get_ProviderUrl();
    internal UrlProviderType get_ProviderType();
    internal UrlAuth get_UrlAuthentication();
    protected abstract virtual UrlAuth GetAuthentication();
    internal abstract virtual UrlProviderInfo GetConnectionInfo();
    internal abstract virtual UrlProviderInfo GetSecretInfo();
    protected static void TraceResultingConnStr(OracleConnectionStringBuilder connStrBuilder, string secureUrlConnStr, ConfigPasswKey userPasswKey, ConfigPasswKey proxyPasswKey);
    protected static OracleConnectionStringBuilder ProcessConnectionString(string connStr, string outerKey, bool remoteConfigurationFiltering, bool bTnsAdminInFileUrl, UrlProviderType providerType, Dictionary`2& connProperties, ConfigPasswKey& userPasswKey, ConfigPasswKey& proxyPasswKey, OracleOpaqueString& userOpaquePassw, OracleOpaqueString& proxyOpaquePassw);
    internal UrlProviderInfo GetProviderInfo(UrlProviderRequestType requestType);
}
internal abstract class OracleInternal.Common.AbstractURLWatcher : object {
    protected UrlProviderCache m_cache;
    protected Dictionary`2<string, HashSet`1<ConfigUrl>> m_watchedConfigUrls;
    public AbstractURLWatcher(UrlProviderCache cache);
    public abstract virtual void AddConfigUrl(ConfigUrl configUrl);
    public abstract virtual void RemoveConfigUrl(ConfigUrl configUrl);
    public abstract virtual bool IsConfigUrlWatched(ConfigUrl configUrl);
    protected void UpdateCache(string watchedUrlProvidersKey);
    protected abstract virtual void ProcessMessage(string message);
}
internal abstract class OracleInternal.Common.AbstractVaultProvider : AbstractUrlProvider {
    internal SecretUrl SecretUrl { get; }
    protected AbstractVaultProvider(SecretUrl secretUrl);
    internal SecretUrl get_SecretUrl();
}
internal class OracleInternal.Common.AzureConfigUrl : ConfigUrl {
    internal static string AZURE_LABEL_PARAM;
    internal static string AZURE_AUTH_MANAGEDIDENTITYCLIENTID_PARAM;
    internal static string AZURE_AUTH_TENANTID_PARAM;
    internal static string AZURE_AUTH_CLIENTID_PARAM;
    internal static string AZURE_AUTH_CLIENTSECRET_PARAM;
    internal static string AZURE_AUTH_CLIENTCERT_PARAM;
    internal static string AZURE_AUTH_CLIENTCERT_PASSW_PARAM;
    internal static string AZURE_AUTH_REDIRECTURL_PARAM;
    internal static string AZURE_AUTH_MAXRETRIES_PARAM;
    internal static string AZURE_AUTH_RETRYTIMEOUT_PARAM;
    internal static string AZURE_AUTH_AUTHORITYHOST_PARAM;
    internal static string AZURE_SERVICE_BUS_HOST;
    internal static string AZURE_SERVICE_BUS_TOPIC_NAME;
    internal static string AZURE_SERVICE_BUS_SUBSCRIPTION_NAME;
    internal static string AZURE_SERVICE_BUS_QUEUE_NAME;
    internal static String[] UrlAuthParamList;
    internal static String[] UrlSecureAuthParamList;
    internal static String[] UrlKeyParamList;
    internal static String[] UrlAcceptableParamList;
    internal static String[] SecretAuthParamList;
    internal static String[] ServiceBusParamList;
    protected string m_label;
    internal string Prefix { get; }
    internal string Label { get; }
    private static AzureConfigUrl();
    internal AzureConfigUrl(string userProvidedConnStr, string userProvidedUrlSource, OracleOpaqueString opaqueUrlOptions, string configName, string prefixName, string labelName, Dictionary`2<string, object> azOptions, UrlProviderRequestType requestType, bool bFiltering, bool bEnlistForChangeNotifications, Dictionary`2<string, string> changeNotificationMeta);
    internal static AzureConfigUrl Parse(string userProvidedUrlConnStr, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering);
    internal string get_Prefix();
    internal string get_Label();
    protected virtual string GetSecureUrlStr();
    protected virtual bool CompareUrl(ProviderUrl otherConfigUrl);
}
internal class OracleInternal.Common.AzureSecretInfo : ConfigSecretInfo {
    internal static string AZURE_SECRET_NAMEID;
    internal static string AZURE_SECRET_ID;
    internal Dictionary`2<string, object> m_authOptions;
    private UrlAuth m_azureAuth;
    internal string m_keyVaultName;
    internal string m_secretName;
    internal string m_secretVersion;
    internal UrlAuth CloudAuthentication { get; }
    internal AzureSecretInfo(string keyVaultName, string secretName, string secretVersion);
    internal AzureSecretInfo(Dictionary`2<string, object> authOptions, string keyVaultName, string secretName, string secretVersion);
    internal AzureSecretInfo(UrlAuth urlAuth, string keyVaultName, string secretName, string secretVersion);
    internal static bool ExtractAzureSecretInfo(string secretUriString, String& keyVaultName, String& secretName, String& secretVersion);
    internal UrlAuth get_CloudAuthentication();
}
internal class OracleInternal.Common.AzureSecretUrl : SecretUrl {
    internal static String[] UrlAuthParamList;
    internal static String[] UrlSecureAuthParamList;
    internal static String[] UrlKeyParamList;
    internal static String[] UrlAcceptableParamList;
    internal string m_keyVaultName;
    internal string m_secretName;
    internal string m_secretVersion;
    internal string SecretName { get; }
    private static AzureSecretUrl();
    internal AzureSecretUrl(string userProvidedConnStr, string userProvidedUrlSource, OracleOpaqueString opaqueUrlOptions, string keyVaultName, string secretName, string secretVersion, string connKey, Dictionary`2<string, object> authParameterValues, UrlProviderRequestType requestType, bool bFiltering);
    internal static ProviderUrl Parse(string secretUrl, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering);
    internal virtual string get_SecretName();
    protected virtual string GetSecureUrlStr();
    protected virtual bool CompareUrl(ProviderUrl otherConnStrUrl);
}
internal class OracleInternal.Common.Base64Secret : AbstractSecret {
    internal static string GetSecret(string base64Secret);
    internal static string GetSecret(ConfigSecretInfo secretInfo, bool bConvertBase64);
}
internal class OracleInternal.Common.Base64SecretInfo : ConfigSecretInfo {
    internal string m_base64Secret;
    internal Base64SecretInfo(string base64Secret);
}
internal enum OracleInternal.Common.BindDirection : Enum {
    public int value__;
    public static BindDirection Input;
    public static BindDirection InputOutput;
    public static BindDirection Output;
}
internal class OracleInternal.Common.ByteBuffer : object {
    internal Byte[] m_byteBuffer;
    internal int m_capacity;
    internal int m_position;
    internal int m_limit;
    internal bool HasRemaining { get; }
    internal int Remaining { get; }
    internal int Limit { get; internal set; }
    internal ByteBuffer(int capacity);
    internal bool get_HasRemaining();
    internal int get_Remaining();
    internal int get_Limit();
    internal void set_Limit(int value);
    internal void GetBufferRef(Byte[]& userBuff, Int32& offset, int length);
    internal void GetBuffer(Byte[] userBuff, int offset, int length);
    internal byte GetByte();
    internal short GetShort();
    internal int GetInt();
    internal long GetLong();
}
internal class OracleInternal.Common.CachedItem`1 : object {
    internal T m_value;
    internal long m_lastUsedCount;
    internal CachedItem`1(T value, long lastUsedCount);
    private sealed virtual override int System.IComparable.CompareTo(object ci);
}
internal class OracleInternal.Common.CachedLRUItem`2 : object {
    internal T m_value;
    internal U m_pos;
    internal CachedLRUItem`2(T value, U pos);
}
internal class OracleInternal.Common.CachedSchemaWithId : object {
    internal Byte[] schemaId;
    internal string schemaInfo;
    internal CachedSchemaWithId(Byte[] id, string info);
}
internal class OracleInternal.Common.CachedSchemaWithUrl : object {
    internal string schemaUrl;
    internal string schemaInfo;
    internal CachedSchemaWithUrl(string url, string info);
}
internal class OracleInternal.Common.CacheWithLRUList`2 : object {
    private object m_LRUsync;
    private ConcurrentDictionary`2<keyType, CachedLRUItem`2<valType, LinkedListNode`1<keyType>>> m_cache;
    private LinkedList`1<keyType> m_LRUList;
    internal int m_maxCacheSize;
    internal int Count { get; }
    internal CacheWithLRUList`2(int maxCacheSize);
    internal int get_Count();
    internal virtual valType RemoveLRU(int count);
    internal virtual valType Put(keyType key, valType value, bool updateLRU);
    internal virtual valType Get(keyType key);
    internal virtual bool ContainsKey(keyType key);
    internal void Purge();
}
internal class OracleInternal.Common.CharArrayPooler : SyncQueueList`1<Char[]> {
    private int m_charBufSize;
    internal CharArrayPooler(int maxElements);
    internal CharArrayPooler(int maxElements, int charBufSize);
    internal virtual Char[] Dequeue();
}
internal class OracleInternal.Common.ColumnDescribeInfo : object {
    internal bool m_isNullAllowed;
    internal string pColAlias;
    internal string m_pColDomainSchema;
    internal string m_pColDomainName;
    internal List`1<Hashtable> m_annotations;
    internal string m_udtSchemaName;
    internal string m_udtTypeName;
    internal UDTNamedType m_udtTypeMetaData;
    internal short m_dataType;
    internal bool bIsXmlType;
    internal bool m_bIsIdentityCol;
    internal bool m_bIsGenAlways;
    internal bool m_bIsGenByDefaultOnNull;
    internal bool m_bIsValueLob;
    internal short m_flag;
    internal short m_precision;
    internal short m_scale;
    internal int m_maxLength;
    internal int m_maxLengthOfChars;
    internal int m_maxNoOfArrayElements;
    internal long m_contFlag;
    internal bool m_bIsByteSemantic;
    internal Byte[] m_toid;
    internal int m_version;
    internal int m_characterSetId;
    internal short m_characterSetForm;
    internal int m_oaccollid;
    internal int m_vectorDim;
    internal VectorNumFormat m_vectorNumFormat;
    internal byte m_vectorFlag;
}
internal class OracleInternal.Common.ColumnLocalParsePrimaryKeyInfo : object {
    internal string m_schemaName;
    internal string m_columnName;
    internal string pTabAlias;
    internal string pTabName;
    internal bool bIsExpression;
    internal bool Updatable;
    internal bool bIsUnique;
    internal bool bIsKeyColumn;
    internal bool bIsHidden;
    internal static ColumnLocalParsePrimaryKeyInfo Null;
    private static ColumnLocalParsePrimaryKeyInfo();
    internal void CopyPrimaryKeyInfoFrom(ColumnLocalParsePrimaryKeyInfo destInfo);
}
internal class OracleInternal.Common.ConfigBaseClass : object {
    internal static long m_DefaultTraceFileMaxSize;
    internal static int m_DefaultTraceOption;
    internal static int m_DefaultTraceLevel;
    [ConfigurationAttribute("ApplicationContinuity")]
internal static bool m_applicationContinuity;
    internal static bool m_bApplicationContinuityConfigured;
    [ConfigurationAttribute("CommandTimeout")]
internal static int m_commandTimeout;
    [ConfigurationAttribute("CPVersion")]
internal static string m_cpversion;
    internal static int m_cpMajorVersion;
    [ConfigurationAttribute("DbNotificationPort")]
internal static int m_DBNotificationPort;
    [ConfigurationAttribute("DbNotificationAddress")]
internal static string m_DBNotificationAddress;
    [ConfigurationAttribute("GetDecimalRetainTrailingZeros")]
internal static bool m_GetDecimalRetainTrailingZeros;
    [ConfigurationAttribute("DemandOraclePermission")]
internal static bool m_DemandOraclePermission;
    [ConfigurationAttribute("BindByName")]
internal static bool m_BindByName;
    [ConfigurationAttribute("UseClientInitiatedCQN")]
internal static bool m_bUseClientInitiatedCQN;
    [ConfigurationAttribute("TAFUsePooledConnections")]
internal static bool m_bUsePooledConnectionsForTAF;
    [ConfigurationAttribute("DatabaseCharset")]
internal static OracleDatabaseCharset m_dbCharset;
    [ConfigurationAttribute("DatabaseNCharset")]
internal static OracleDatabaseNCharset m_dbNCharset;
    internal static int DEFAULT_COMMAND_FETCHSIZE;
    [ConfigurationAttribute("FetchSize")]
internal static int m_FetchSize;
    [ConfigurationAttribute("MaxStatementCacheSize")]
internal static int m_MaxStatementCacheSize;
    [ConfigurationAttribute("MetaDataXml")]
internal static string m_MetaDataXml;
    [ConfigurationAttribute("PROMOTABLE")]
internal static PromotableTransaction m_PromotableTransaction;
    [ConfigurationAttribute("LegacyIsolationLevelBehavior")]
internal static bool m_bLegacyIsolationLevelBehavior;
    [ConfigurationAttribute("SelfTuning")]
internal static bool m_SelfTuning;
    internal static int DEFAULT_STMT_CACHE_SIZE;
    [ConfigurationAttribute("StatementCacheSize")]
internal static int m_StatementCacheSize;
    [ConfigurationAttribute("RevertBatchUpdateErrorHandling")]
internal static bool m_RevertBUErrHandling;
    [ConfigurationAttribute("PerformanceCounters")]
internal static long m_PerformanceCounters;
    [ConfigurationAttribute("SuppressErrorURL")]
internal static bool m_bSuppressErrorURL;
    [ConfigurationAttribute("MapVectorColumnAsClob")]
internal static bool m_bMapVectorColumnAsClob;
    [ConfigurationAttribute("InitialLOBFetchSize")]
internal static int m_InitialLOBFetchSize;
    [ConfigurationAttribute("Pipelining")]
internal static bool m_Pipelining;
    [ConfigurationAttribute("InitialLONGFetchSize")]
internal static int m_InitialLONGFetchSize;
    [ConfigurationAttribute("TNS_ADMIN")]
internal static string m_TnsAdminLocation;
    [ConfigurationAttribute("ORA_DEBUG_JDWP")]
internal static string m_OraDebugJDWP;
    [ConfigurationAttribute("LDAP_ADMIN")]
internal static string m_LdapAdminLocation;
    [ConfigurationAttribute("CONFIGURATION_PROVIDERS")]
internal static string m_ConfigurationProviders;
    [ConfigurationAttribute("TOKEN_AUTH")]
internal static OracleTokenAuth m_tokenAuth;
    [ConfigurationAttribute("TOKEN_LOCATION")]
internal static string m_tokenLocation;
    [ConfigurationAttribute("PASSWORD_AUTH")]
internal static OraclePasswordAuth m_passwAuth;
    [ConfigurationAttribute("OCI_IAM_URL")]
internal static string m_ociIamUrl;
    [ConfigurationAttribute("OCI_TENANCY")]
internal static string m_ociTenancy;
    [ConfigurationAttribute("OCI_COMPARTMENT")]
internal static string m_ociCompartment;
    [ConfigurationAttribute("OCI_DATABASE")]
internal static string m_ociDatabase;
    [ConfigurationAttribute("OCI_CONFIG_FILE")]
internal static string m_ociConfigFile;
    [ConfigurationAttribute("OCI_PROFILE")]
internal static string m_ociProfile;
    [ConfigurationAttribute("AttemptConnectDuringSvcRelocation")]
internal static int m_attemptConnectDuringSvcReloc;
    [ConfigurationAttribute("ServiceRelocationConnectionTimeout")]
internal static string m_serviceRelocationTimeout;
    [ConfigurationAttribute("ChunkMigrationConnectionTimeout")]
internal static string m_chunkMigrationTimeout;
    [ConfigurationAttribute("XMLTypeClientSideDecoding")]
internal static bool m_XMLTypeClientSideDecoding;
    [ConfigurationAttribute("TraceFileLocation")]
internal static string m_traceFileLocation;
    [ConfigurationAttribute("TraceLevel")]
internal static int m_TraceLevel;
    [ConfigurationAttribute("TraceOption")]
internal static int m_TraceOption;
    [ConfigurationAttribute("LegacyEntireLOBFetch")]
internal static bool m_bLegacyNegativeOneILFSBehavior;
    [ConfigurationAttribute("HAEvents")]
internal static bool m_haEvents;
    internal static bool m_bHAEventsConfigured;
    [ConfigurationAttribute("LoadBalancing")]
internal static bool m_loadBalancing;
    internal static bool m_bLoadBalancingConfigured;
    [ConfigurationAttribute("OpenTelemetryTracing")]
internal static bool m_openTelemetryTracing;
    [ConfigurationAttribute("UseLegacyLocalParser")]
internal static bool m_bUseLegacyLocalParser;
    [ConfigurationAttribute("ColumnCacheSize")]
internal static int m_ColumnCacheSize;
    [ConfigurationAttribute("DRCPConnectionClass")]
internal static string m_connectionClass;
    internal static object m_maxStatementCacheSizeLock;
    [ConfigurationAttribute("Edition")]
internal static string m_appEdition;
    [ConfigurationAttribute("SuppressGetDecimalInvalidCastException")]
internal static bool m_bSuppressGetDecimalInvalidCastException;
    [ConfigurationAttribute("ProgramName")]
internal static string m_programName;
    internal static Process CurrentProcess;
    internal static Version m_assemblyVersion;
    internal static string m_sectionVersion;
    internal static string m_sqlnetOraLoc;
    internal static string m_TNSNamesoraloc;
    internal static ArrayList m_TNSConfigPath;
    internal static string m_OracleHome;
    internal static bool m_OracleHomeSet;
    [ConfigurationAttribute("TraceFileMaxSize")]
internal static long m_TraceFileMaxSize;
    internal static Char[] m_allowedCont;
    internal static Char[] m_parens;
    internal static Hashtable m_configParameters;
    internal static Hashtable m_configParameters_nonsqlnet;
    internal static Hashtable m_configParametersClone;
    internal static Hashtable m_oracleConfigParameters;
    internal static Hashtable m_LDAPconfigParameters;
    internal static Hashtable m_configDataSourcesMap;
    internal static Hashtable m_oracleConfigurationDataSourcesMap;
    internal static Hashtable m_jsonConfigDataSourcesMap;
    internal static Hashtable m_connectionPoolNameMapping;
    internal static Hashtable m_udtMappings;
    internal static string m_singleTraceFileLocation;
    internal static Char[] s_percentage;
    internal static Char[] s_dollar;
    internal static Char[] s_metachars;
    internal static Char[] s_space_and_tab;
    internal static Char[] s_dirSeparators;
    internal static string m_ONSWalletLocation;
    internal static string m_ONSProtocol;
    internal static string m_ONSConfigFile;
    internal static OnsConfigMode m_ONSMode;
    internal static Dictionary`2<string, Dictionary`2<string, string>> m_ONSMapping;
    internal static string m_nodeListFromConfFile;
    internal static ParseMode m_ParseMode;
    internal static ushort DTC_DEFAULT_RECO_PORT;
    internal static UInt32 DTC_DEFAULT_TXNTIMETOLIVE;
    internal static string m_recoveryServiceHost;
    internal static ushort m_recoveryServicePort;
    internal static UInt32 m_dtcTxnTimeout;
    internal static bool m_dtcUseDTCDLL;
    internal static bool m_dtcUseManagedDTC;
    internal static bool m_bIsManaged;
    internal static Hashtable m_configParamFrAppConfig;
    internal static Hashtable m_configParamFrSqlnetora;
    internal static Hashtable m_LDAPCfParamFrAppConfig;
    internal static ArrayList m_versionSpecificNodesList;
    private static ConfigBaseClass instance;
    internal StringBuilder mtsTrace;
    internal static Hashtable s_odtConfigNamesToRefCursorInfo;
    internal static NameValueCollection m_configSection;
    internal static RegistryKey odpNetKey;
    internal static Hashtable s_edmMapping;
    internal static String[] s_edmTypes;
    internal static Int32[] s_maxPrecision;
    internal static bool s_bEdmNumberMappingPresent;
    internal static bool s_bLegacyEdmMappingPresent;
    internal static bool s_bFromConfigSRCT;
    internal static int srctOffset;
    internal static bool s_bDrainTimeoutInSRCT;
    internal static bool s_bFromConfigCMCT;
    internal static int cmctOffset;
    internal static bool s_bTimeoutInCMCT;
    internal static Dictionary`2<string, DbType> s_EdmMappingToDbType;
    internal static DbType[] s_edmPrecisonMapping;
    internal string s_strReg;
    internal string s_strCfg;
    internal string s_strOcfg;
    internal string s_strVer;
    internal string s_strEnv;
    internal string s_strProdVer;
    internal string s_strTrm;
    internal Hashtable s_storedProcInformation;
    internal static string s_appDir;
    private static ConfigBaseClass();
    internal virtual void ValidateEdmMapping();
    internal virtual void setudtmapping(Hashtable& s_mapUdtNameToMappingObj);
    private static bool IsDirExist(string str);
    internal static string GetResolvedFileLocation(string path);
    private static string ResolveEnvVariables(String[] folders, bool bStartsWithSeparator, bool bEndsWithSeparator, bool bIsSharedLocation);
    internal static int GetMaxPrecision(string edmType, bool isEF6OrHigher);
    internal static void PopulateMaxPrecisionArray();
    public string RetrieveStringValue(string entryToBeSearched, object defaultValue, Boolean& bFromConfigFile);
    public int RetrieveIntValue(string entryToBeSearched, object defaultValue, bool bAcceptNegativeValues, Boolean& bFromConfigFile);
    internal StoredProcedureInfo GetStoredProcInfo(string commandText);
    internal string GetAttrValueInProperCase(string attributeValue);
    internal void GetKeyInProperCase(String& storedProcKey);
    public static ConfigBaseClass GetInstance(bool bIsManaged);
    internal virtual void ParseConfigFile();
    internal static string CurOraFileLoc(OraFiles file);
    internal static Hashtable CurOraFileParams(OraFiles file);
    internal static ArrayList GetTnsNamesSearchPath(Boolean& isTnsnamesEnabled);
    internal virtual void ParseClientXmlNode(XmlNode xmlElement, Hashtable& hashtable, ArrayList& arrayList, ArrayList filterNodes);
    internal static string OraDebugJDWP();
}
internal class OracleInternal.Common.ConfigInfo : object {
    public static string SectionName;
    public static string Section;
    public static string ODPMSectionName;
    public static string VersionSubSection;
    public static string VersionNumber;
    public static string VersionNumberGeneric;
    public static string ApplicationContinuity;
    public static string DataSourcesElement;
    public static string LDAPsettingsElement;
    public static string DataSourceAlias;
    public static string DataSourceDesc;
    public static string StoredProcedure;
    public static string ConfigParamName;
    public static string ConfigParamValue;
    public static string ConfigNetTypeName;
    public static string ConfigDbTypeName;
    public static string UdtCustomClass;
    public static string Schema;
    public static string ConnectionPoolsElement;
    public static string ConnectionPoolConnectionString;
    public static string ConnectionPoolName;
    public static string Mode;
    public static string Position;
    public static string Implicit;
    public static string UDTMappingsElement;
    public static string SettingsElement;
    public static string DbNtfnPort;
    public static string DbNtfnRegInterval;
    public static string DbNtfnAddress;
    public static string XMLTypeClientSideDecoding;
    public static string NamesDirectoryPath;
    public static string FetchSize;
    public static string ImplicitRefCursor;
    public static string OraDebugJDWP;
    public static string AttemptConnectDuringSvcRelocation;
    public static string ServiceRelocationConnectionTimeout;
    public static string ChunkMigrationConnectionTimeout;
    public static string Hostname_Default_Service_is_Host;
    public static string ConnectionPoolType;
    public static string CPVersion;
    public static string CommandTimeout;
    public static string ConfigSchemaFile;
    public static string CommonConfigSchemaFile;
    public static string ColumnOrdinal;
    public static string MetaDataXml;
    public static string RevertBUErrHandling;
    public static string PerfCounters;
    public static string DistributedTransaction;
    public static string distTxnSessTxnTimeToLive;
    public static string distTxnUseDTCDLL;
    public static string PromotableTxn;
    public static string distTxnRecoveryHost;
    public static string distTxnRecoveryPort;
    public static string distTxnUseManagedDTC;
    public static string LegacyEntireLOBFetch;
    public static string HAEvents;
    public static string LoadBalancing;
    public static string OpenTelemetryTracing;
    public static string StmtCacheSize;
    public static string GetDecimalRetainTrailingZeros;
    public static string TraceLevel;
    public static string BindByName;
    public static string UseClientInitiatedCQN;
    public static string TAFUsePooledConnections;
    public static string DatabaseCharset;
    public static string DatabaseNCharset;
    public static string TraceOption;
    public static string TraceFileLocation;
    public static string TnsAdmin;
    public static string LdapAdmin;
    public static string NoPSPESupport;
    public static string UdtMapping;
    public static string ConnectionPool;
    public static string DataSource;
    public static string SchemaName;
    public static string TypeName;
    public static string schemaName;
    public static string typeName;
    public static string FactoryName;
    public static string DemandOrclPermission;
    public static string SelfTuning;
    public static string MaxStatementCacheSize;
    public static string AppEdition;
    public static string UseLegacyLocalParser;
    public static string ColumnCacheSize;
    public static string DRCPConnectionClass;
    public static string TraceFileMaxSize;
    public static string RefCursorBindInfo;
    public static string RefCursorbindInfo;
    public static string RefCursorMetadata;
    public static string RefCursorKey;
    public static string refCursorKey;
    public static string RefCursorMetadataKey;
    public static string ImplicitRefCursorMetadataKey;
    public static string RefCursor;
    public static string Name;
    public static string EdmMappingsElement;
    public static string EdmMappingElement;
    public static string EdmNumberMappingElement;
    public static string EdmNumberMappingMinPrecision;
    public static string EdmNumberMappingMaxPrecision;
    public static string DataType;
    public static string Precision;
    public static string Scale;
    public static string Add;
    public static string NumberDataType;
    public static string edmMapping;
    public static string PromotableTransaction;
    public static string LocalTransaction;
    public static string LegacyIsolationLevelBehavior;
    internal static string ONS;
    internal static string ONSConfig;
    internal static string ONSParamName;
    internal static string ONSParamValue;
    internal static string ONSNodeList;
    internal static string ONSConfigFile;
    internal static string ONSDatabase;
    internal static string ONSMode;
    internal static string ONSConfigFileName;
    internal static string ONSNodes;
    internal static string ONSRemotePort;
    internal static string ONSWalletLocation;
    internal static string ONSProtocol;
    internal static string VERSION;
    internal static string CONFIG;
    internal static string TNSNAMES;
    internal static string SQLNET;
    internal static string ENVIRONMENT;
    public static string InitialLOBFetchSize;
    public static string InitialLONGFetchSize;
    public static string Pipelining;
    public static string ConfigurationProviders;
    public static string TokenAuth;
    public static string TokenLocation;
    public static string PasswAuth;
    public static string OciIamUrl;
    public static string OciTenancy;
    public static string OciCompartment;
    public static string OciDatabase;
    public static string OciConfigFile;
    public static string OciProfile;
    public static string SuppressErrorURL;
    public static string MapVectorColumnAsClob;
    public static string SuppressGetDecimalInvalidCastException;
    public static string ODPMRegistryKey;
    public static string ODPURegistryKey;
    public static string ProgramName;
    private static ConfigInfo();
}
internal enum OracleInternal.Common.ConfigPasswKey : Enum {
    public int value__;
    public static ConfigPasswKey Null;
    public static ConfigPasswKey ODPConnStr;
    public static ConfigPasswKey ODPPassw;
    public static ConfigPasswKey CommonPassw;
}
internal abstract class OracleInternal.Common.ConfigSecret : object {
    internal static string GetAzureSecretContent(ConfigSecretInfo secretInfo);
    internal static string GetOciSecretContent(ConfigSecretInfo secretInfo);
    internal static string GetSecretContent(ConfigSecretInfo secretInfo, bool bConvertBase64);
}
internal abstract class OracleInternal.Common.ConfigSecretInfo : object {
    internal SecretProviderType m_providerType;
    internal ConfigSecretInfo(SecretProviderType providerType);
}
[AttributeUsageAttribute("256")]
internal class OracleInternal.Common.ConfigurationAttribute : Attribute {
    private string m_configEntry;
    internal string ConfigEntry { get; }
    internal ConfigurationAttribute(string configEntry);
    internal string get_ConfigEntry();
}
internal abstract class OracleInternal.Common.ConfigUrl : ProviderUrl {
    internal bool m_enlistForChangeNotification;
    internal String[] changeNotificationParams;
    internal int m_changeNotifId;
    internal string m_traceChangeNotifId;
    protected string m_configName;
    internal Dictionary`2<string, string> m_changeNotificationMeta;
    internal string ConfigName { get; }
    internal string SecureUrlConnStr { get; }
    internal ConfigUrl(string userProvidedConnStr, string userProvidedUrlSource, OracleOpaqueString opaqueUrlOptions, string configName, string connKey, Dictionary`2<string, object> authParameters, UrlProviderRequestType requestType, bool bFiltering, bool enlistForChangeNotifications, Dictionary`2<string, string> changeNotificationMeta);
    internal string get_ConfigName();
    internal virtual string get_SecureUrlConnStr();
    protected string GetChangeNotifStr(String[] changeNotifParamList);
    protected bool CompareChangeNotifMeta(ConfigUrl otherConfigUrl);
}
internal enum OracleInternal.Common.ConnectionReplacement : Enum {
    public int value__;
    public static ConnectionReplacement None;
    public static ConnectionReplacement CreateNew;
    public static ConnectionReplacement AttemptIdle;
}
internal class OracleInternal.Common.ConOraBufPool : object {
    private OraBufPool m_obp;
    private static int m_sId;
    private static object m_idSync;
    internal int m_poolId;
    private OraBuf[] m_smallBufPooler;
    private OraBuf[] m_largeBufPooler;
    private object m_smallBufPoolerSync;
    private object m_largeBufPoolerSync;
    private int m_smallBufPoolerPos;
    private int m_largeBufPoolerPos;
    private int m_smallBufPoolerMin;
    private int m_smallBufPoolerMax;
    private int m_largeBufPoolerMin;
    private int m_largeBufPoolerMax;
    internal int m_smallBufSize;
    internal int m_largeBufSize;
    private int m_bufPoolerCapacity;
    public ConOraBufPool(OraBufPool obp, OracleTraceClassName className, OracleTraceFuncName funcName, object traceObj);
    private static ConOraBufPool();
    public OraBuf Get(int key, OracleCommunication oracleCommunication, bool bReceive, OracleTraceClassName className, OracleTraceFuncName funcName);
    public void Put(int key, OraBuf oraBuf, OracleTraceClassName className, OracleTraceFuncName funcName, object traceObj);
    public void Init(OracleCommunication oc, OracleTraceClassName className, OracleTraceFuncName funcName);
    public void ReturnAll(OracleTraceClassName className, OracleTraceFuncName funcName, object traceObj);
}
internal class OracleInternal.Common.CustomConfigFileReader : ConfigBaseClass {
    public static string EdmMappingsElement;
    public static string DataSource;
    public static string EdmMappingElement;
    public static string DataType;
    public static string Precision;
    public static string Scale;
    public static string Add;
    public static string NumberDataType;
    private static string ORA_DEBUG_JDWP;
    private static string TNS_ADMIN;
    private static string LDAP_ADMIN;
    private static string ORACLE_HOME;
    private string NETWORK_ADMIN;
    private string LDAP_ADMIN_DIR;
    private static string LDAPORA;
    private static string TNSNAMESORA;
    private static string SQLNETORA;
    private Hashtable mapUdtNameToMappingObjConfig;
    private static CustomConfigFileReader();
    public CustomConfigFileReader(bool bIsManaged);
    private static void GetProcessAndEnvInfo();
    internal static Version GetExecutingAssemblyVersion();
    private static Assembly LoadODPMDLL(object sender, ResolveEventArgs args);
    internal String[] GetName(StreamReader strmRdr, String& leftover);
    internal string GetValue(StreamReader strmRdr, string leftover);
    internal virtual void ParseConfigFile();
    private void ParseAndCacheConfigParams();
    internal void ParseSubSection(XmlNode subSectionNode, Hashtable& schemaTable, ArrayList filterNodes);
    private void ParseConnectionPoolsElement(XmlNode connectionPoolsNode);
    private bool ParseBooleanConfigValue(string configValue);
    private void ParseDataSourcesElement(XmlNode dataSourceNode);
    private void ParseDistTxnElement(XmlNode distTxnNode);
    internal virtual void setudtmapping(Hashtable& s_mapUdtNameToMappingObj);
    private void ParseUdtMappingsElement(XmlNode udtMappingsNode);
    private void ParseImpRefCursorElement(XmlNode node, Hashtable& schemaTable);
    private void ParseLDAPsettingsElement(XmlNode settingsNode);
    private void ParseONSConfigElement(XmlNode ONSConfigNode);
    private void ParseONSElement(XmlNode ONSNode);
    internal string GetPropertyFromONSConfig(string ONSConfigFile, string onsConfigProperty);
    private void AddInfoForRefCursor(string storedProcKey, XmlNode refCursorNode, Hashtable& schemaTable);
    private void AddBindInfoForRefCursor(string storedProcKey, XmlNode bindInfoNode, RefCursorInfo& refCursorInfo, bool isInfoBasedOnName, Hashtable& schemaTable);
    private void AddMetadataForRefCursor(string storedProcKey, XmlNode metadataNode, RefCursorInfo& refCursorInfo, bool isInfoBasedOnName, Hashtable& schemaTable);
    private Type GetSystemType(string attributeValue);
    private void ThrowExceptionForRefCursor(string messageForTrace, string messageForException);
    private void ParseSettingsElement(XmlNode settingsNode);
    private void ParseEdmMappingsElement(XmlNode edmMappingsNode);
    internal void InitEdmMapping();
    internal void ValidateBaseDocument(XmlDocument doc);
    private void ValidationCallBack(object sender, ValidationEventArgs args);
    internal virtual void ParseClientXmlNode(XmlNode baseNode, Hashtable& schemaTable, ArrayList& versionSpecificNodesList, ArrayList filterNodes);
}
internal class OracleInternal.Common.CustomSectionHandler : ConfigurationSection {
    internal bool m_bSectionExists;
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Common.DeriveParamInfoPool : object {
    private object m_sync;
    private long m_LastUsedCount;
    private Dictionary`2<string, DeriveParamInfo> m_cache;
    private int m_maxCacheSize;
    internal DeriveParamInfo Item { get; internal set; }
    internal DeriveParamInfoPool(int maxCacheSize);
    private void RemoveLRU();
    internal DeriveParamInfo get_Item(string cmdText);
    internal void set_Item(string cmdText, DeriveParamInfo value);
}
internal class OracleInternal.Common.DeserializationBinder : SerializationBinder {
    public virtual Type BindToType(string assemblyName, string typeName);
}
internal class OracleInternal.Common.DeserializationBinder0 : SerializationBinder {
    public virtual Type BindToType(string assemblyName, string typeName);
}
internal enum OracleInternal.Common.DrcpType : Enum {
    public int value__;
    public static DrcpType False;
    public static DrcpType True;
    public static DrcpType None;
}
internal enum OracleInternal.Common.Enlist : Enum {
    public int value__;
    public static Enlist False;
    public static Enlist True;
    public static Enlist Dynamic;
}
internal class OracleInternal.Common.EntityFrameworkProviderSettings : object {
    private EFOracleProviderType OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.ThickOrThin { get; }
    private int OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.InitialLONGFetchSize { get; }
    private int OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.InitialLOBFetchSize { get; }
    private bool OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.TracingEnabled { get; }
    private sealed virtual override EFOracleProviderType OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.get_ThickOrThin();
    private sealed virtual override int OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.get_InitialLONGFetchSize();
    private sealed virtual override int OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.get_InitialLOBFetchSize();
    private sealed virtual override bool OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.get_TracingEnabled();
    private sealed virtual override void OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.Trace(EFTraceLevel level, string message);
    private sealed virtual override int OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.GetMaxPrecision(string typeName);
    private sealed virtual override string OracleInternal.EntityFramework.EFProviderSettings.IEFProviderSettings.GetErrorMessage(int errorCode, String[] args);
}
internal class OracleInternal.Common.FileConfigUrl : ConfigUrl {
    internal static String[] UrlKeyParamList;
    internal static String[] UrlAcceptableParamList;
    internal static String[] UrlAuthParamList;
    internal static String[] UrlSecurityAuthParamList;
    protected string m_fileName;
    protected string m_fileOrigin;
    protected string m_urlTnsAdmin;
    internal string FileName { get; }
    internal string FileOrigin { get; }
    internal string UrlTnsAdmin { get; }
    private static FileConfigUrl();
    internal FileConfigUrl(string userProvidedConnStr, string userProvidedUrlSource, OracleOpaqueString opaqueUrlOptions, string configName, string fileName, string fileOrigin, string connKey, string urlTnsAdmin, Dictionary`2<string, object> authParameters, UrlProviderRequestType requestType, bool bFiltering);
    internal static FileConfigUrl Parse(string userProvidedConnStr, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering, string connTnsAdminInternal);
    internal string get_FileName();
    internal string get_FileOrigin();
    internal string get_UrlTnsAdmin();
    protected virtual string GetSecureUrlStr();
    protected virtual bool CompareUrl(ProviderUrl otherConfigUrl);
}
internal class OracleInternal.Common.FileWatcher : object {
    private FileSystemWatcher m_watcher;
    private DateTime m_lastWriteTime;
    private int m_hashCode;
    internal bool m_setUp;
    internal FileWatcher(string path);
    private void OnFileChangedNotificationReceived(object sender, FileSystemEventArgs e);
    private void OnAppConfigFileChanged(object state);
    public sealed virtual void Dispose();
}
internal enum OracleInternal.Common.FloatingPointType : Enum {
    public int value__;
    public static FloatingPointType Float;
    public static FloatingPointType Double;
}
internal class OracleInternal.Common.HelperClass : object {
    internal static Char[] WHITE_SPACE_DELIMS;
    internal static string SELECT_CLAUSE;
    internal static string INSERT_CLAUSE;
    internal static string UPDATE_CLAUSE;
    internal static string DELETE_CLAUSE;
    internal static string MERGE_CLAUSE;
    internal static string WITH_CLAUSE;
    internal static string RETURNING_PATTERN;
    internal static int LNXSGNBT;
    private static byte LNXDIGS;
    internal static byte LNXEXPBS;
    private static byte MAX_INT_EXPONENT;
    private static byte MIN_INT_EXPONENT;
    private static byte MAX_LONG_EXPONENT;
    private static byte MIN_LONG_EXPONENT;
    private static Int32[] MAX_LONG;
    private static Int32[] MIN_LONG;
    private static int MAX_LONG_length;
    private static int MIN_LONG_length;
    private static bool GET_XXX_ROUNDS;
    private static int LNXM_NUM;
    private static byte LENINDEX;
    private static byte EXPINDEX;
    private static byte DIGITINDEX;
    private static byte POSEXPOFFSET;
    private static byte POSDIGITOFFSET;
    private static byte DEC_MAX_PRECISION;
    private static byte NEGDIGITOFFSET;
    private static byte NEGEXPOFFSET;
    internal static int LNXEXPMX;
    private static double tablemaxexponent;
    private static Double[] factorTable;
    private static Double[] small10pow;
    private static Int32[] expdigs0;
    private static Int32[] expdigs1;
    private static Int32[] expdigs2;
    private static Int32[] expdigs3;
    private static Int32[] expdigs4;
    private static Int32[] expdigs5;
    private static Int32[] expdigs6;
    private static Int32[] expdigs7;
    private static Int32[] expdigs8;
    private static Int32[] expdigs9;
    private static Int32[] expdigs10;
    private static Int32[] expdigs11;
    private static Int32[] expdigs12;
    private static Int32[] expdigs13;
    private static Int32[] expdigs14;
    private static Int32[] expdigs15;
    private static Int32[] expdigs16;
    private static Int32[] expdigs17;
    private static Int32[] expdigs18;
    private static Int32[] expdigs19;
    private static Int32[] expdigs20;
    private static Int32[] expdigs21;
    private static Int32[] expdigs22;
    private static Int32[] expdigs23;
    private static Int32[] expdigs24;
    private static Int32[] expdigs25;
    private static Int32[] expdigs26;
    private static Int32[] expdigs27;
    private static Int32[] expdigs28;
    private static Int32[] expdigs29;
    private static Int32[] expdigs30;
    private static Int32[] expdigs31;
    private static Int32[] expdigs32;
    private static Int32[] expdigs33;
    private static Int32[] expdigs34;
    private static Int32[] expdigs35;
    private static Int32[] expdigs36;
    private static Int32[] expdigs37;
    private static Int32[] expdigs38;
    private static Int32[] expdigs39;
    private static Int32[] expdigs40;
    private static Int32[] expdigs41;
    private static Int32[] expdigs42;
    private static Int32[] expdigs43;
    private static Int32[] expdigs44;
    private static Int32[] expdigs45;
    private static Int32[] expdigs46;
    private static Int32[] expdigs47;
    private static Int32[] expdigs48;
    private static Int32[] expdigs49;
    private static Int32[] expdigs50;
    private static Int32[] expdigs51;
    private static Int32[] expdigs52;
    private static Int32[] expdigs53;
    private static Int32[] expdigs54;
    private static Int32[] expdigs55;
    private static Int32[] expdigs56;
    private static Int32[] expdigs57;
    private static Int32[] expdigs58;
    private static Int32[] expdigs59;
    private static Int32[] expdigs60;
    private static Int32[] expdigs61;
    private static Int32[] expdigs62;
    private static Int32[] expdigs63;
    private static Int32[] expdigs64;
    private static Int32[] expdigs65;
    private static Int32[] expdigs66;
    private static Int32[] expdigs67;
    private static Int32[] expdigs68;
    private static Int32[] expdigs69;
    private static Int32[] expdigs70;
    private static Int32[] expdigs71;
    private static Int32[] expdigs72;
    private static Int32[] expdigs73;
    private static Int32[] expdigs74;
    private static Int32[] expdigs75;
    private static Int32[] expdigs76;
    private static Int32[] expdigs77;
    private static Int32[] expdigs78;
    private static Int32[] expdigs79;
    private static Int32[] expdigs80;
    private static Int32[] expdigs81;
    private static Int32[] expdigs82;
    private static Int32[] expdigs83;
    private static Int32[] expdigs84;
    private static Int32[] expdigs85;
    private static Int32[] expdigs86;
    private static Int32[] expdigs87;
    private static Int32[] expdigs88;
    private static Int32[] expdigs89;
    private static Int32[] expdigs90;
    private static Int32[] expdigs91;
    private static Int32[] expdigs92;
    private static Int32[] expdigs93;
    private static Int32[] expdigs94;
    private static Int32[] expdigs95;
    private static Int32[] expdigs96;
    private static Int32[] expdigs97;
    private static Int32[] expdigs98;
    private static Int32[] expdigs99;
    private static Int32[] expdigs100;
    private static Int32[] expdigs101;
    private static Int32[] expdigs102;
    private static Int32[] expdigs103;
    private static Int32[] expdigs104;
    private static Int32[] expdigs105;
    private static Int32[] expdigs106;
    private static Int32[] expdigs107;
    private static Int32[] expdigs108;
    private static Int32[] expdigs109;
    private static Int32[] expdigs110;
    private static Int32[] expdigs111;
    private static Int32[] expdigs112;
    private static Int32[] expdigs113;
    private static Int32[] expdigs114;
    private static Int32[] expdigs115;
    private static Int32[] expdigs116;
    private static Int32[] expdigs117;
    private static Int32[] expdigs118;
    private static Int32[] expdigs119;
    private static Int32[] expdigs120;
    private static Int32[] expdigs121;
    private static Int32[] expdigs122;
    private static Int32[] expdigs123;
    private static Int32[] expdigs124;
    private static Int32[] expdigs125;
    private static Int32[] expdigs126;
    private static Int32[] expdigs127;
    private static Int32[] expdigs128;
    private static Int32[] expdigs129;
    private static Int32[] expdigs130;
    private static Int32[] expdigs131;
    private static Int32[] expdigs132;
    private static Int32[] expdigs133;
    private static Int32[] expdigs134;
    private static Int32[] expdigs135;
    private static Int32[] expdigs136;
    private static Int32[] expdigs137;
    private static Int32[] expdigs138;
    private static Int32[] expdigs139;
    private static Int32[] expdigs140;
    private static Int32[] expdigs141;
    private static Int32[] expdigs142;
    private static Int32[] expdigs143;
    private static Int32[] expdigs144;
    private static Int32[] expdigs145;
    private static Int32[] expdigs146;
    private static Int32[] expdigs147;
    private static Int32[][] expdigstable;
    private static Int32[] nexpdigstable;
    private static Int32[] binexpstable;
    private static Char[] InvalidPathChars;
    private static HelperClass();
    internal static int URShift(int number, int bits);
    internal static long URShift(long number, int bits);
    internal static int CompareBytes(Byte[] first, Byte[] second);
    internal static double GetDouble(Byte[] bytes, int offset, int len);
    internal static float GetFloat(OraType oraType, Byte[] bytes, int offset, int len);
    internal static double GetDouble(OraType oraType, Byte[] bytes, int offset, int len);
    internal static OracleDecimal GetOracleDecimal(OraType oraType, Byte[] bytes, int offset);
    internal static float GetFloat(Byte[] bytes, int offset, int len);
    internal static bool GetBool(Byte[] bytes, int offset, int length);
    internal static int GetInt(Byte[] bytes, int offset, int length);
    internal static long GetLong(Byte[] bytes, int offset, int length);
    internal static string GetZeros(int count);
    internal static string RemoveSingleQuotes(string strInput);
    internal static string RemoveDoubleQuotes(string strInput);
    internal static string RemoveSingleAndDoubleQuotes(string strInput);
    internal static bool CheckForFileSecurity(string filePath);
    internal static string GetTokenAuthInString(OracleTokenAuth tokenAuth);
    internal static bool GetTokenAuthEnumFromString(string tokenAuthInString, OracleTokenAuth& tokenAuth);
}
public interface OracleInternal.Common.IOracleMetadata {
    public abstract virtual IEnumerable`1<OracleLpTableColumns> GetColumnInformation(IEnumerable`1<OracleLpTable> tables);
}
internal interface OracleInternal.Common.ITokenAuthenticationProvider {
    public abstract virtual OracleAccessToken GetAccessToken(TokenConfiguration tokenAuthentication);
}
internal enum OracleInternal.Common.NotificationType : Enum {
    public int value__;
    public static NotificationType DBChange;
    public static NotificationType AQ;
    public static NotificationType HA;
    public static NotificationType RLB;
    public static NotificationType ChunkMove;
}
internal enum OracleInternal.Common.NullIndicator : Enum {
    public int value__;
    public static NullIndicator Null;
    public static NullIndicator NotNull;
}
internal class OracleInternal.Common.OciConfigUrl : ConfigUrl {
    private static string OCI_SEPARATOR_NAMESPACE;
    private static string OCI_SEPARATOR_BUCKETNAME;
    private static string OCI_SEPARATOR_OBJECTNAME;
    internal static string OCI_AUTH_PROFILE_PARAM;
    internal static string OCI_AUTH_TENANTID_PARAM;
    internal static string OCI_AUTH_USERID_PARAM;
    internal static string OCI_AUTH_FINGERPRINT_PARAM;
    internal static string OCI_AUTH_PRIVATEKEY_PARAM;
    internal static string OCI_AUTH_PASSPHRASE_PARAM;
    internal static string OCI_REGION_PARAM;
    internal static string OCI_REGION_PREFIX;
    internal static string OCI_REGION_POSTFIX;
    internal static string OCI_REGION_DEDICATED_POSTFIX;
    internal static string WEBHOOK_EVENT_LISTENER_PATH;
    internal static string WEBHOOK_EVENT_LISTENER_PORT;
    internal static String[] UrlAuthParamList;
    internal static String[] UrlSecureAuthParamList;
    internal static String[] UrlKeyParamList;
    internal static String[] UrlAcceptableParamList;
    internal static String[] SecretAuthParamList;
    internal static String[] EventListenerParamList;
    private string m_regionName;
    private string m_namespaceName;
    private string m_bucketName;
    private string m_listenerResourceId;
    private string m_listenerPrefix;
    internal string RegionName { get; }
    internal string NamespaceName { get; }
    internal string BucketName { get; }
    internal string ListenerResourceId { get; }
    internal string ListenerPrefix { get; }
    private static OciConfigUrl();
    internal OciConfigUrl(string userProvidedConnStr, string userProvidedUrlSource, OracleOpaqueString opaqueUrlOptions, string regionName, string namespaceName, string bucketName, string configName, string connKey, Dictionary`2<string, object> options, UrlProviderRequestType requestType, bool bFiltering, bool bEnlistForChangeNotification, Dictionary`2<string, string> changeNotificationMeta);
    private static string GetRegion(string regionHost);
    internal static OciConfigUrl Parse(string userProvidedUrlStr, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering);
    internal string get_RegionName();
    internal string get_NamespaceName();
    internal string get_BucketName();
    internal string get_ListenerResourceId();
    internal string get_ListenerPrefix();
    protected virtual string GetSecureUrlStr();
    protected virtual bool CompareUrl(ProviderUrl otherConfigUrl);
}
internal class OracleInternal.Common.OciSecretInfo : ConfigSecretInfo {
    internal static string OCI_SECRET_ID;
    internal Dictionary`2<string, object> m_authOptions;
    private UrlAuth m_ociAuth;
    internal string m_regionName;
    internal string m_secretOcid;
    internal string m_versionNumberStr;
    internal string m_stageStr;
    internal UrlAuth CloudAuthentication { get; }
    internal OciSecretInfo(string secretOcid, string versionNumberStr, string stageStr);
    internal OciSecretInfo(Dictionary`2<string, object> authOptions, string secretOcid, string versionNumberStr, string stageStr);
    internal OciSecretInfo(UrlAuth auth, string secretOcid, string versionNumberStr, string stageStr);
    internal static string GetRegion(string secretOcid);
    internal UrlAuth get_CloudAuthentication();
}
internal class OracleInternal.Common.OciSecretUrl : SecretUrl {
    internal static String[] UrlAuthParamList;
    internal static String[] UrlSecureAuthParamList;
    internal static String[] UrlKeyParamList;
    internal static String[] UrlAcceptableParamList;
    internal string m_regionName;
    internal string m_secretOcid;
    internal string m_versionNumberStr;
    internal string m_stageStr;
    internal string SecretName { get; }
    internal string RegionName { get; }
    private static OciSecretUrl();
    internal OciSecretUrl(string userProvidedConnStr, string userProvidedUrlSource, OracleOpaqueString opaqueUrlOptions, string regionName, string secretOcid, string versionNumberStr, string stageStr, string connKey, Dictionary`2<string, object> authParameterValues, UrlProviderRequestType requestType, bool bFiltering);
    internal static ProviderUrl Parse(string secretUrl, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering);
    internal virtual string get_SecretName();
    internal string get_RegionName();
    protected virtual string GetSecureUrlStr();
    protected virtual bool CompareUrl(ProviderUrl otherConnStrUrl);
}
internal class OracleInternal.Common.ODPMSectionHandler : ConfigurationSection {
    protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
}
internal abstract class OracleInternal.Common.ODPUrlProviderFactory : object {
    internal static AbstractUrlProvider CreateAzureConfigProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateOciConfigProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateFileConfigProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateAzureVaultProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateOciVaultProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateProvider(UrlProviderType providerType, string userProviderConnStr, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering, string connTnsAdmin);
}
internal static class OracleInternal.Common.ODTSettings : object {
    public static Nullable`1<bool> m_bUse12cTypes;
    public static bool m_bUse32DataTypes;
    public static bool m_bUseLongIdentifiers;
    public static Hashtable m_schemaFilterHashtable;
    [CompilerGeneratedAttribute]
private static EdmInUseEvent m_edmInUseEvent;
    [CompilerGeneratedAttribute]
public static void add_m_edmInUseEvent(EdmInUseEvent value);
    [CompilerGeneratedAttribute]
public static void remove_m_edmInUseEvent(EdmInUseEvent value);
    public static void FireEdmInUseEvent();
    public static bool EdmEventHasSubscribers();
    public static void SetSchemaFilter(Hashtable schemaFilterHashtable);
}
internal class OracleInternal.Common.OraBufPool : object {
    internal string m_poolId;
    private OraBuf[] m_smallBufPooler;
    private OraBuf[] m_largeBufPooler;
    private object m_smallBufPoolerSync;
    private object m_largeBufPoolerSync;
    private object m_sduChangeSync;
    private int m_smallBufPoolerPos;
    private int m_largeBufPoolerPos;
    internal int m_smallBufSize;
    internal int m_largeBufSize;
    private int m_bufPoolerCapacity;
    public OraBufPool(int maxSubCacheSize, OracleTraceClassName className, OracleTraceFuncName funcName, object traceObj);
    internal void UpdateBufSizes(OracleCommunication oc);
    public OraBuf Get(int key, OracleCommunication oc, bool bReceive, OracleTraceClassName className, OracleTraceFuncName funcName);
    public OraBuf GetUninitialized(int key, OracleCommunication oc, OracleTraceClassName className, OracleTraceFuncName funcName);
    public void Put(int key, OraBuf oraBuf, OracleTraceClassName className, OracleTraceFuncName funcName, object traceObj);
}
internal class OracleInternal.Common.OracleGlobalConstants : object {
    public static string s_CmdDataDesignerWizardString;
    public static string s_ConnStringEditorString;
    public static string s_AdapDataDesignerWizardString;
    public static string s_ParameterTypeConverterString;
}
public class OracleInternal.Common.OracleLpColumn : object {
    public string m_columnName;
    public string m_tableName;
    public string m_schemaName;
    public bool m_isHidden;
    public OracleLpColumn(string columnName);
}
public class OracleInternal.Common.OracleLpTable : object {
    public string m_schemaName;
    public string m_tableName;
    public string m_dbLinkName;
    public OracleLpTable(string schemaName, string tableName, string dbLinkName);
}
public class OracleInternal.Common.OracleLpTableColumns : object {
    public OracleLpTable m_table;
    public IEnumerable`1<OracleLpColumn> m_columns;
    public OracleLpTableColumns(OracleLpTable table, IEnumerable`1<OracleLpColumn> columns);
}
public static class OracleInternal.Common.OracleMetadata : object {
    private static Char[] double_quotes;
    private static string atSign;
    private static OracleMetadata();
    public static IEnumerable`1<OracleLpTableColumns> GetColumnInformation(OracleConnection con, IEnumerable`1<OracleLpTable> tables);
    public static IEnumerable`1<OracleLpTableColumns> GetColumnInfoWithSameDbLink(OracleConnection con, IEnumerable`1<OracleLpTable> tables, string dbLinkName);
    public static IEnumerable`1<OracleLpTableColumns> GetColumnInfoWithDiffDbLinks(OracleConnection con, IEnumerable`1<OracleLpTable> tables);
}
internal class OracleInternal.Common.OracleOpaqueString : object {
    internal static OracleOpaqueString NULL;
    internal static OracleOpaqueString EMPTY;
    internal int m_randomizingSeed;
    internal int m_hashCode;
    private Char[] m_obfuscatedChars;
    internal int Length { get; }
    private OracleOpaqueString(string s);
    private OracleOpaqueString(Char[] ch);
    private static OracleOpaqueString();
    internal static OracleOpaqueString NewOracleOpaqueString(Char[] ch);
    internal static SecureString GetSecureString(Char[] clearText, bool bClearChars);
    internal static OracleOpaqueString NewOracleOpaqueString(string s);
    internal static OracleOpaqueString NewOracleOpaqueString(SecureString s, bool trimDoubleQuotesFromStartAndEnd);
    internal int get_Length();
    internal string GetString();
    internal Char[] GetChars();
    internal SecureString GetSecureString();
    internal Byte[] GetBytes(MarshallingEngine marshallingEngine);
    internal bool IsNull();
    public virtual bool Equals(object obj);
    public static bool Equals(OracleOpaqueString strA, OracleOpaqueString strB);
    public static bool Equals(OracleOpaqueString strA, Char[] strB, int bOffset, int bLength);
    public OracleOpaqueString Copy();
    public virtual int GetHashCode();
    private static void xor(Char[] input, Char[] output, int seed);
    public IntPtr MarshalUnicode();
}
internal class OracleInternal.Common.OracleTimeZone : object {
    private static OracleTimeZone tzCacheObj;
    private static string FILENAME;
    internal int m_latestTimeZoneVersion;
    internal static int INV_ZONEID;
    internal Dictionary`2<int, string> m_zoneIdMap;
    internal Hashtable m_zoneIdToOffsetMap;
    public OracleTimeZone(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static OracleTimeZone GetInstance();
    internal int GetZoneId(string zoneName);
    internal string GetZoneName(int id);
    internal int GetlatestTZversion();
    internal void GetOffsetOfUTCTime(Nullable`1<DateTime> utcTime, int zoneid, TimeSpan& offset, Boolean& isDST);
    internal bool GetOffsetOfLocalTime(Nullable`1<DateTime> localTime, int zoneid, TimeSpan& offset, Boolean& isDST);
    internal bool IsValidZoneId(int id);
    internal bool IsValidZoneName(string zoneName);
    internal static object ReadObj(string entryName);
    internal void SetZoneIdMap(Dictionary`2<int, string> zoneIdMap);
    internal void SetLatestTZVersion(int latestTZVersion);
    internal void SetZoneIdtoOffsetMap(Hashtable offsetMap);
}
internal enum OracleInternal.Common.OracleTraceClassName : Enum {
    public int value__;
    public static OracleTraceClassName ManagedDTCImpl;
    public static OracleTraceClassName OracleConnectionCCP;
    public static OracleTraceClassName OCPMTSTxnRM;
    public static OracleTraceClassName MTSTransactionImpl;
    public static OracleTraceClassName DTCImpl;
    public static OracleTraceClassName OracleTimeStampTZ;
    public static OracleTraceClassName OracleTuner;
    public static OracleTraceClassName PropertyElement;
    public static OracleTraceClassName SEPS;
    public static OracleTraceClassName MTSTxnRM;
    public static OracleTraceClassName MTSProxyPool;
    public static OracleTraceClassName ProviderConfig;
    public static OracleTraceClassName RegAndConfigRdr;
    public static OracleTraceClassName ConfigBaseClass;
    public static OracleTraceClassName ObxmlDecoder;
    public static OracleTraceClassName ObxmlDTDInfo;
    public static OracleTraceClassName ObxmlDecodeState;
    public static OracleTraceClassName ObxmlDecodeStream;
    public static OracleTraceClassName ObxmlInstruction;
    public static OracleTraceClassName ObxmlInstructionState;
    public static OracleTraceClassName ObxmlMetaDataRepository;
    public static OracleTraceClassName BatchUpdateHelper;
    public static OracleTraceClassName OracleClientFactory;
    public static OracleTraceClassName OracleCommand;
    public static OracleTraceClassName OracleCommandBuilder;
    public static OracleTraceClassName OracleConnection;
    public static OracleTraceClassName OracleConnectionOpenEventArgs;
    public static OracleTraceClassName OracleLogicalTransaction;
    public static OracleTraceClassName OracleConnectionStringBuilder;
    public static OracleTraceClassName OracleDataAdapter;
    public static OracleTraceClassName OracleDataReader;
    public static OracleTraceClassName OracleTypeMapper;
    public static OracleTraceClassName OracleDataSourceEnumerator;
    public static OracleTraceClassName OracleDependency;
    public static OracleTraceClassName OracleError;
    public static OracleTraceClassName OracleException;
    public static OracleTraceClassName OracleGlobalization;
    public static OracleTraceClassName OracleHAEventArgs;
    public static OracleTraceClassName OracleInfoMessageEventArgs;
    public static OracleTraceClassName OracleNotificationEventArgs;
    public static OracleTraceClassName OracleNotificationRequest;
    public static OracleTraceClassName OracleParameter;
    public static OracleTraceClassName OracleParameterCollection;
    public static OracleTraceClassName OraclePermission;
    public static OracleTraceClassName OraclePermissionAttribute;
    public static OracleTraceClassName OracleRowUpdatingEventArgs;
    public static OracleTraceClassName OracleTransaction;
    public static OracleTraceClassName StoredProcedureInfo;
    public static OracleTraceClassName CustomConfigFileReader;
    public static OracleTraceClassName RegistryUtility;
    public static OracleTraceClassName EntityFrameworkProviderSettings;
    public static OracleTraceClassName OraBufPool;
    public static OracleTraceClassName ConOraBufPool;
    public static OracleTraceClassName MaxStatementCacheSize;
    public static OracleTraceClassName ODTConfigFileInfoForRefCursors;
    public static OracleTraceClassName SQLMetaData;
    public static OracleTraceClassName OracleMetadata;
    public static OracleTraceClassName OracleConnectionDispenser;
    public static OracleTraceClassName ServiceCtx;
    public static OracleTraceClassName ConnectionString;
    public static OracleTraceClassName OraclePool;
    public static OracleTraceClassName OraclePoolManager;
    public static OracleTraceClassName Pool;
    public static OracleTraceClassName PoolManager;
    public static OracleTraceClassName TransactionContext;
    public static OracleTraceClassName PoolResource;
    public static OracleTraceClassName RLB;
    public static OracleTraceClassName OracleNumberCore;
    public static OracleTraceClassName CCPMTSTxnBranch;
    public static OracleTraceClassName CCPMTSTxnRM;
    public static OracleTraceClassName FWPSPEManager;
    public static OracleTraceClassName DTCDebugConfig;
    public static OracleTraceClassName MTSRMManager;
    public static OracleTraceClassName MTSTxnBranch;
    public static OracleTraceClassName MTSTxnCtx;
    public static OracleTraceClassName TxnBranchesByUserAuth;
    public static OracleTraceClassName MTSProxies;
    public static OracleTraceClassName MTSTxnRMWorker;
    public static OracleTraceClassName PSPEManager;
    public static OracleTraceClassName Ano;
    public static OracleTraceClassName CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;
    public static OracleTraceClassName LdapConfig;
    public static OracleTraceClassName OraBuf;
    public static OracleTraceClassName TNSresolvedAddr;
    public static OracleTraceClassName OracleCommunication;
    public static OracleTraceClassName ReaderStream;
    public static OracleTraceClassName TcpsTransportAdapter;
    public static OracleTraceClassName TcpTransportAdapter;
    public static OracleTraceClassName CallBackThread;
    public static OracleTraceClassName Connection;
    public static OracleTraceClassName InputBuffer;
    public static OracleTraceClassName Concurrency;
    public static OracleTraceClassName NodeList;
    public static OracleTraceClassName Notification;
    public static OracleTraceClassName QueueElement;
    public static OracleTraceClassName NotificationQueue;
    public static OracleTraceClassName ONS;
    public static OracleTraceClassName ONSException;
    public static OracleTraceClassName ONSTcpClient;
    public static OracleTraceClassName OutputBuffer;
    public static OracleTraceClassName PropertyList;
    public static OracleTraceClassName Publisher;
    public static OracleTraceClassName ReceiverThread;
    public static OracleTraceClassName SendElement;
    public static OracleTraceClassName SenderThread;
    public static OracleTraceClassName Subscriber;
    public static OracleTraceClassName SubscriptionException;
    public static OracleTraceClassName SubscriptionNotification;
    public static OracleTraceClassName SupportClass;
    public static OracleTraceClassName CollectionsSupport;
    public static OracleTraceClassName CompareCharValues;
    public static OracleTraceClassName EqualsSupport;
    public static OracleTraceClassName ThreadClass;
    public static OracleTraceClassName CalendarHashTable;
    public static OracleTraceClassName DateTimeFormatHashTable;
    public static OracleTraceClassName DateTimeFormatProperties;
    public static OracleTraceClassName OracleTunerBase;
    public static OracleTraceClassName MEMORYSTATUS;
    public static OracleTraceClassName NotificationBufferManager;
    public static OracleTraceClassName NotificationDetails;
    public static OracleTraceClassName NotificationHandler;
    public static OracleTraceClassName NotificationListener;
    public static OracleTraceClassName OracleBFileImpl;
    public static OracleTraceClassName OracleBlobImpl;
    public static OracleTraceClassName OracleClobImpl;
    public static OracleTraceClassName OracleCommandImpl;
    public static OracleTraceClassName OracleConnectionImpl;
    public static OracleTraceClassName OracleJsonImpl;
    public static OracleTraceClassName OracleVectorImpl;
    public static OracleTraceClassName HARLBCallbackRegisterData;
    public static OracleTraceClassName OracleDataReaderImpl;
    public static OracleTraceClassName OracleDependencyImpl;
    public static OracleTraceClassName OracleBulkCopyImpl;
    public static OracleTraceClassName OracleGlobalizationImpl;
    public static OracleTraceClassName OracleHANotificationManager;
    public static OracleTraceClassName OracleNotificationManager;
    public static OracleTraceClassName OracleONSNotificationManager;
    public static OracleTraceClassName OracleParameterImpl;
    public static OracleTraceClassName OracleRLBNotificationManager;
    public static OracleTraceClassName OracleTransactionImpl;
    public static OracleTraceClassName to;
    public static OracleTraceClassName SQLParser;
    public static OracleTraceClassName TTCAuthenticate;
    public static OracleTraceClassName TTCBFile;
    public static OracleTraceClassName TTCBlob;
    public static OracleTraceClassName TTCCancel;
    public static OracleTraceClassName TTCClob;
    public static OracleTraceClassName TTCClose;
    public static OracleTraceClassName TTCColumnInfo;
    public static OracleTraceClassName TTCColumnMetaData;
    public static OracleTraceClassName TTCDescribe;
    public static OracleTraceClassName TTCDataTypeNegotiation;
    public static OracleTraceClassName TTCDescribeInfo;
    public static OracleTraceClassName TTCEndToEndMetrics;
    public static OracleTraceClassName TTCError;
    public static OracleTraceClassName TTCExecuteSql;
    public static OracleTraceClassName TTCFetch;
    public static OracleTraceClassName TTCFunction;
    public static OracleTraceClassName TTCLob;
    public static OracleTraceClassName TTCLobData;
    public static OracleTraceClassName TTCMessage;
    public static OracleTraceClassName TTCNotification;
    public static OracleTraceClassName TTCOPing;
    public static OracleTraceClassName TTCProtocolNegotiation;
    public static OracleTraceClassName TTCReExecuteSql;
    public static OracleTraceClassName TTCRowData;
    public static OracleTraceClassName TTCCookie;
    public static OracleTraceClassName TTCRowHeader;
    public static OracleTraceClassName TTCSessionGet;
    public static OracleTraceClassName TTCSessionRelease;
    public static OracleTraceClassName TTCSessionReturnValues;
    public static OracleTraceClassName TTCSimpleOperations;
    public static OracleTraceClassName TTCSwitchSession;
    public static OracleTraceClassName TTCTransactionEN;
    public static OracleTraceClassName TTCTransactionSE;
    public static OracleTraceClassName TTCVersion;
    public static OracleTraceClassName DecimalConv;
    public static OracleTraceClassName DateTimeConv;
    public static OracleTraceClassName OracleBFile;
    public static OracleTraceClassName OracleBinary;
    public static OracleTraceClassName OracleBlob;
    public static OracleTraceClassName OracleBoolean;
    public static OracleTraceClassName OracleClob;
    public static OracleTraceClassName OracleDate;
    public static OracleTraceClassName OracleDecimal;
    public static OracleTraceClassName OracleIntervalDS;
    public static OracleTraceClassName OracleIntervalYM;
    public static OracleTraceClassName OracleRefCursor;
    public static OracleTraceClassName OracleString;
    public static OracleTraceClassName OracleTimeStamp;
    public static OracleTraceClassName OracleTimeStampLTZ;
    public static OracleTraceClassName OracleXmlStream;
    public static OracleTraceClassName OracleXmlType;
    public static OracleTraceClassName TimeStamp;
    public static OracleTraceClassName EZConnect;
    public static OracleTraceClassName OracleConfiguration;
    public static OracleTraceClassName OracleDataSourceCollection;
    public static OracleTraceClassName OracleOnsServerCollection;
    public static OracleTraceClassName TNSNames;
    public static OracleTraceClassName WssTransportAdapter;
    public static OracleTraceClassName WebSocketStream;
    public static OracleTraceClassName WebSocketDataFrame;
    public static OracleTraceClassName OracleChunkNotificationManager;
    public static OracleTraceClassName OracleChunkEventArgs;
    public static OracleTraceClassName ShardRoutingCache;
    public static OracleTraceClassName ShardingRangeMap;
    public static OracleTraceClassName OracleAQQueue;
    public static OracleTraceClassName JsonConfigFileSettings;
    public static OracleTraceClassName TTCAQNotification;
    public static OracleTraceClassName NotificationHeader;
    public static OracleTraceClassName NotificationMessageProperties;
    public static OracleTraceClassName NotificationMessagePayload;
    public static OracleTraceClassName NotificationContext;
    public static OracleTraceClassName ClientInitiatedConnection;
    public static OracleTraceClassName TTCChunkInfo;
    public static OracleTraceClassName OracleUdt;
    public static OracleTraceClassName OracleRef;
    public static OracleTraceClassName UDTTypeCache;
    public static OracleTraceClassName UDTTDSReader;
    public static OracleTraceClassName UDTPickleContextReader;
    public static OracleTraceClassName UDTBasedType;
    public static OracleTraceClassName UDTNamedType;
    public static OracleTraceClassName UDTObjectType;
    public static OracleTraceClassName UDTCharType;
    public static OracleTraceClassName UDTCollectionType;
    public static OracleTraceClassName UDTOpaqueType;
    public static OracleTraceClassName UDTXmlType;
    public static OracleTraceClassName UDTUPTType;
    public static OracleTraceClassName UDTBuiltInInst;
    public static OracleTraceClassName UDTObjectInst;
    public static OracleTraceClassName UDTCollectionInst;
    public static OracleTraceClassName UDTPickleBuiltInInst;
    public static OracleTraceClassName UDTPickleObjectInst;
    public static OracleTraceClassName UDTPickleCollectionInst;
    public static OracleTraceClassName TTCLobAccessor;
    public static OracleTraceClassName TimeSpanConv;
    public static OracleTraceClassName AddressResolution;
    public static OracleTraceClassName OracleAccessToken;
    public static OracleTraceClassName OracleFailoverMgrImpl;
    public static OracleTraceClassName AnoKerberos;
    public static OracleTraceClassName TTCPipeline;
    public static OracleTraceClassName MarshallingEngine;
    public static OracleTraceClassName DataUnmarshaller;
    public static OracleTraceClassName Packet;
    public static OracleTraceClassName DataPacket;
    public static OracleTraceClassName WriterStream;
    public static OracleTraceClassName Trace;
    public static OracleTraceClassName OraBufReader;
    public static OracleTraceClassName OracleDatabase;
    public static OracleTraceClassName TTCOkeyVal;
    public static OracleTraceClassName OciTokenAuthenticationProvider;
    public static OracleTraceClassName OciInteractiveAuthentication;
    public static OracleTraceClassName AzureTokenAuthenticationConfiguration;
    public static OracleTraceClassName ActiveDirectoryTokenAuthenticationProvider;
    public static OracleTraceClassName OciTokenAuthentication;
    public static OracleTraceClassName TokenAuthDependenciesFactory;
    public static OracleTraceClassName AzureConfigProvider;
    public static OracleTraceClassName AzureConfigUrl;
    public static OracleTraceClassName OciConfigProvider;
    public static OracleTraceClassName FileConfigProvider;
    public static OracleTraceClassName UrlProviderCache;
    public static OracleTraceClassName CommonConfigProvider;
    public static OracleTraceClassName ConfigSecretProvider;
    public static OracleTraceClassName CommonConfigSecret;
    public static OracleTraceClassName OciSecret;
    public static OracleTraceClassName AzureSecret;
    public static OracleTraceClassName FileSecret;
    public static OracleTraceClassName Base64Secret;
    public static OracleTraceClassName TextSecret;
    public static OracleTraceClassName TextJsonSecret;
    public static OracleTraceClassName UrlProviderInfo;
    public static OracleTraceClassName UrlConnInfo;
    public static OracleTraceClassName ConfigConnInfo;
    public static OracleTraceClassName SecretConnInfo;
    public static OracleTraceClassName AbstractSecret;
    public static OracleTraceClassName OracleAQMessageAvailableEventArgs;
    public static OracleTraceClassName EventWrapper;
    public static OracleTraceClassName HelperClass;
    public static OracleTraceClassName LDAP;
    public static OracleTraceClassName AbstractUrlProvider;
    public static OracleTraceClassName OraclePoolNameCollection;
    public static OracleTraceClassName AzureWatcher;
}
internal enum OracleInternal.Common.OracleTraceFuncName : Enum {
    public int value__;
    public static OracleTraceFuncName dtor;
    public static OracleTraceFuncName get_SchemaUrl;
    public static OracleTraceFuncName get_Schema;
    public static OracleTraceFuncName get_RootElement;
    public static OracleTraceFuncName get_IsFragment;
    public static OracleTraceFuncName get_IsSchemaBased;
    public static OracleTraceFuncName get_Value;
    public static OracleTraceFuncName get_Length;
    public static OracleTraceFuncName get_ProxySerialNumber;
    public static OracleTraceFuncName get_ProxySessionId;
    public static OracleTraceFuncName get_SerialNumber;
    public static OracleTraceFuncName get_SessionId;
    public static OracleTraceFuncName get_OracleLogicalTransaction;
    public static OracleTraceFuncName OperatorDouble;
    public static OracleTraceFuncName OperatorFloat;
    public static OracleTraceFuncName OperatorDecimal;
    public static OracleTraceFuncName OperatorInt;
    public static OracleTraceFuncName OperatorShort;
    public static OracleTraceFuncName OperatorByte;
    public static OracleTraceFuncName OperatorLong;
    public static OracleTraceFuncName OperatorLessThanOrEqualTo;
    public static OracleTraceFuncName OperatorNotEqualTo;
    public static OracleTraceFuncName OperatorLessThan;
    public static OracleTraceFuncName OperatorGreaterThanOrEqualTo;
    public static OracleTraceFuncName OperatorGreaterThan;
    public static OracleTraceFuncName OperatorEqualTo;
    public static OracleTraceFuncName cctor;
    public static OracleTraceFuncName Delist;
    public static OracleTraceFuncName EnlistPSPE;
    public static OracleTraceFuncName OraclePoolManagerFinalizer;
    public static OracleTraceFuncName DetachServerProcess;
    public static OracleTraceFuncName AttachServerProcess;
    public static OracleTraceFuncName GetSerialNumber;
    public static OracleTraceFuncName GetSessionId;
    public static OracleTraceFuncName Register_HA_RLB_Callbacks;
    public static OracleTraceFuncName InbandNotificationProcessing;
    public static OracleTraceFuncName GetSecureUrlStr;
    public static OracleTraceFuncName GetAttributes;
    public static OracleTraceFuncName IsTAFEnabled;
    public static OracleTraceFuncName TransportAlive;
    public static OracleTraceFuncName ReleaseRP;
    public static OracleTraceFuncName ReleaseRPs;
    public static OracleTraceFuncName Resume;
    public static OracleTraceFuncName ProcessInstruction;
    public static OracleTraceFuncName GetProxy;
    public static OracleTraceFuncName GetMatchingPR;
    public static OracleTraceFuncName MatchCriteria;
    public static OracleTraceFuncName GetTimeZoneOffset;
    public static OracleTraceFuncName ConstructTimeZone;
    public static OracleTraceFuncName AddDayTimeToTimeStampTZ;
    public static OracleTraceFuncName AddYearMonthToTimeStampTZ;
    public static OracleTraceFuncName Operatorbyte;
    public static OracleTraceFuncName Operatorshort;
    public static OracleTraceFuncName Operatorint;
    public static OracleTraceFuncName Operatorfloat;
    public static OracleTraceFuncName Operatordouble;
    public static OracleTraceFuncName Operatordecimal;
    public static OracleTraceFuncName Operatorlong;
    public static OracleTraceFuncName OperatorString;
    public static OracleTraceFuncName OperatorGreaterthan;
    public static OracleTraceFuncName OperatorGreaterthanorEqualto;
    public static OracleTraceFuncName OperatorLessthan;
    public static OracleTraceFuncName OperatorLessthanorEqualto;
    public static OracleTraceFuncName OperatorByteArray;
    public static OracleTraceFuncName InitRequestObject;
    public static OracleTraceFuncName GetNextInstruction;
    public static OracleTraceFuncName SetDecodeComplete;
    public static OracleTraceFuncName Decode_New;
    public static OracleTraceFuncName StartDTD;
    public static OracleTraceFuncName EndDTD;
    public static OracleTraceFuncName ElementDecl;
    public static OracleTraceFuncName InternalEntityDecl;
    public static OracleTraceFuncName ExternalEntityDecl;
    public static OracleTraceFuncName UnparsedEntityDecl;
    public static OracleTraceFuncName NotationDecl;
    public static OracleTraceFuncName PrintAttributeDecl;
    public static OracleTraceFuncName GetPM;
    public static OracleTraceFuncName MigrateChunk;
    public static OracleTraceFuncName SplitChunk;
    public static OracleTraceFuncName RemoveChunk;
    public static OracleTraceFuncName GetShardInstancesEx;
    public static OracleTraceFuncName PushNodeState;
    public static OracleTraceFuncName PopNodeState;
    public static OracleTraceFuncName ReadBlob;
    public static OracleTraceFuncName HandleCompleteParse;
    public static OracleTraceFuncName DecodeBlobForXmlStream;
    public static OracleTraceFuncName ReadSectionHeader;
    public static OracleTraceFuncName ReadInstructionInfo;
    public static OracleTraceFuncName ReadNum1;
    public static OracleTraceFuncName ReadNum2;
    public static OracleTraceFuncName ReadNum4;
    public static OracleTraceFuncName ReadNum4r;
    public static OracleTraceFuncName ReadLong8;
    public static OracleTraceFuncName ReadEventText;
    public static OracleTraceFuncName StartCDATA;
    public static OracleTraceFuncName EndCDATA;
    public static OracleTraceFuncName GetTokenSet;
    public static OracleTraceFuncName GetResource;
    public static OracleTraceFuncName PopulateTokenSet;
    public static OracleTraceFuncName ctor;
    public static OracleTraceFuncName InitializeBUC;
    public static OracleTraceFuncName FinalizeBUC;
    public static OracleTraceFuncName AddCommand;
    public static OracleTraceFuncName GetBatchedParameter;
    public static OracleTraceFuncName CloneParameters;
    public static OracleTraceFuncName ParseCommandText;
    public static OracleTraceFuncName ParseStoredProcedure;
    public static OracleTraceFuncName GetReturnValueParam;
    public static OracleTraceFuncName CreateCommand;
    public static OracleTraceFuncName CreateCommandBuilder;
    public static OracleTraceFuncName CreateConnection;
    public static OracleTraceFuncName CreateConnectionStringBuilder;
    public static OracleTraceFuncName CreateDataAdapter;
    public static OracleTraceFuncName CreateDataSourceEnumerator;
    public static OracleTraceFuncName CreateParameter;
    public static OracleTraceFuncName CreatePermission;
    public static OracleTraceFuncName Cancel;
    public static OracleTraceFuncName Clone;
    public static OracleTraceFuncName CreateDbParameter;
    public static OracleTraceFuncName ExecuteDbDataReader;
    public static OracleTraceFuncName Dispose;
    public static OracleTraceFuncName BuildCommandText;
    public static OracleTraceFuncName DoPreExecuteProcessing;
    public static OracleTraceFuncName ExecuteNonQuery;
    public static OracleTraceFuncName DoDescribeSelectQuery;
    public static OracleTraceFuncName ExecuteReader;
    public static OracleTraceFuncName ExecuteScalar;
    public static OracleTraceFuncName ExecuteStream;
    public static OracleTraceFuncName ExecuteToStream;
    public static OracleTraceFuncName ExecuteXmlReader;
    public static OracleTraceFuncName ExecuteXmlQuery;
    public static OracleTraceFuncName ExecuteXmlSave;
    public static OracleTraceFuncName SetupCommandTimeoutCallback;
    public static OracleTraceFuncName CommandTimeoutCallback;
    public static OracleTraceFuncName PopulateSubscriptionInfo;
    public static OracleTraceFuncName AddRefCursorParamToParamColl;
    public static OracleTraceFuncName GetPlsqlOutput;
    public static OracleTraceFuncName DeriveParameters;
    public static OracleTraceFuncName PopulateCommandParamsFromDeriveParamInfo;
    public static OracleTraceFuncName GetInsertCommand;
    public static OracleTraceFuncName GetUpdateCommand;
    public static OracleTraceFuncName SetParam;
    public static OracleTraceFuncName CheckPrimaryKey;
    public static OracleTraceFuncName GetColumnType;
    public static OracleTraceFuncName GetSchemaName;
    public static OracleTraceFuncName GetBaseTableName;
    public static OracleTraceFuncName FindBaseColumnOrdinal;
    public static OracleTraceFuncName GetDeleteCommand;
    public static OracleTraceFuncName FillSchemaMetaData;
    public static OracleTraceFuncName QuoteIdentifier;
    public static OracleTraceFuncName UnquoteIdentifier;
    public static OracleTraceFuncName RefreshSchema;
    public static OracleTraceFuncName ApplyParameterInfo;
    public static OracleTraceFuncName IsRowOrigValueNull;
    public static OracleTraceFuncName CreateParams;
    public static OracleTraceFuncName GetSchemaTable;
    public static OracleTraceFuncName SetRowUpdatingHandler;
    public static OracleTraceFuncName RowUpdating;
    public static OracleTraceFuncName GetColumnName;
    public static OracleTraceFuncName Dump;
    public static OracleTraceFuncName Open;
    public static OracleTraceFuncName OpenWithNewPassword;
    public static OracleTraceFuncName BeginTransaction;
    public static OracleTraceFuncName ChangeDatabase;
    public static OracleTraceFuncName Close;
    public static OracleTraceFuncName GetSessionInfo;
    public static OracleTraceFuncName SetSessionInfo;
    public static OracleTraceFuncName PurgeStatementCache;
    public static OracleTraceFuncName GetSchema;
    public static OracleTraceFuncName EnlistDistributedTransaction;
    public static OracleTraceFuncName EnlistTransaction;
    public static OracleTraceFuncName ClearAllPools;
    public static OracleTraceFuncName ClearPool;
    public static OracleTraceFuncName BeginDbTransaction;
    public static OracleTraceFuncName CreateDbCommand;
    public static OracleTraceFuncName OnStateChange;
    public static OracleTraceFuncName OnConnectionOpen;
    public static OracleTraceFuncName OnHAEvent;
    public static OracleTraceFuncName CheckForWarnings;
    public static OracleTraceFuncName GetOutcome;
    public static OracleTraceFuncName SetProperty;
    public static OracleTraceFuncName Clear;
    public static OracleTraceFuncName ContainsKey;
    public static OracleTraceFuncName Remove;
    public static OracleTraceFuncName TryGetValue;
    public static OracleTraceFuncName Fill;
    public static OracleTraceFuncName FillingExtendedProperties;
    public static OracleTraceFuncName FillingExtendedPropertiesHelper;
    public static OracleTraceFuncName FillSchema;
    public static OracleTraceFuncName Update;
    public static OracleTraceFuncName OnRowUpdating;
    public static OracleTraceFuncName OnRowUpdated;
    public static OracleTraceFuncName InitializeBatching;
    public static OracleTraceFuncName AddToBatch;
    public static OracleTraceFuncName ClearBatch;
    public static OracleTraceFuncName ExecuteBatch;
    public static OracleTraceFuncName GetBatchedRecordsAffected;
    public static OracleTraceFuncName GetInt16;
    public static OracleTraceFuncName GetInt32;
    public static OracleTraceFuncName GetInt64;
    public static OracleTraceFuncName GetDecimal;
    public static OracleTraceFuncName GetDouble;
    public static OracleTraceFuncName GetFloat;
    public static OracleTraceFuncName GetString;
    public static OracleTraceFuncName GetTimeSpan;
    public static OracleTraceFuncName GetBoolean;
    public static OracleTraceFuncName GetByte;
    public static OracleTraceFuncName GetBytes;
    public static OracleTraceFuncName GetBytesInternal;
    public static OracleTraceFuncName GetChars;
    public static OracleTraceFuncName GetDateTimeOffset;
    public static OracleTraceFuncName GetDateTime;
    public static OracleTraceFuncName GetGuid;
    public static OracleTraceFuncName GetDataTypeName;
    public static OracleTraceFuncName GetEnumerator;
    public static OracleTraceFuncName GetFieldType;
    public static OracleTraceFuncName GetName;
    public static OracleTraceFuncName GetOracleBinary;
    public static OracleTraceFuncName GetOracleBFile;
    public static OracleTraceFuncName GetOracleBlob;
    public static OracleTraceFuncName GetOracleBlobForUpdate;
    public static OracleTraceFuncName GetOracleClob;
    public static OracleTraceFuncName AutoCommit;
    public static OracleTraceFuncName GetOracleClobForUpdate;
    public static OracleTraceFuncName GetOracleDate;
    public static OracleTraceFuncName GetOracleDecimal;
    public static OracleTraceFuncName GetOracleIntervalDS;
    public static OracleTraceFuncName GetOracleIntervalYM;
    public static OracleTraceFuncName GetOracleString;
    public static OracleTraceFuncName GetOracleTimeStamp;
    public static OracleTraceFuncName GetOracleTimeStampLTZ;
    public static OracleTraceFuncName GetOracleTimeStampTZ;
    public static OracleTraceFuncName GetOracleXmlType;
    public static OracleTraceFuncName GetOracleValue;
    public static OracleTraceFuncName GetOracleValues;
    public static OracleTraceFuncName GetOrdinal;
    public static OracleTraceFuncName GetProviderSpecificFieldType;
    public static OracleTraceFuncName GetProviderSpecificValue;
    public static OracleTraceFuncName GetProviderSpecificValues;
    public static OracleTraceFuncName GetSchemaTableEx;
    public static OracleTraceFuncName GetSchemaTableCopy;
    public static OracleTraceFuncName GetValue;
    public static OracleTraceFuncName GetValues;
    public static OracleTraceFuncName GetXmlReader;
    public static OracleTraceFuncName IsDBNull;
    public static OracleTraceFuncName NextResult;
    public static OracleTraceFuncName Read;
    public static OracleTraceFuncName GetOraDbType;
    public static OracleTraceFuncName IsCorruptible;
    public static OracleTraceFuncName GetMinSchemaTable;
    public static OracleTraceFuncName ChangeType;
    public static OracleTraceFuncName GetLongData;
    public static OracleTraceFuncName GetLongRawData;
    public static OracleTraceFuncName GetLongAccessorToFetchMoreData;
    public static OracleTraceFuncName ExecuteQueryToFetchLongData;
    public static OracleTraceFuncName GetOracleLobForUpdate;
    public static OracleTraceFuncName GetEdmMappingConfigValues;
    public static OracleTraceFuncName PopulateExpectedTypes;
    public static OracleTraceFuncName GetDataSources;
    public static OracleTraceFuncName GetOracleDependency;
    public static OracleTraceFuncName AddCommandDependency;
    public static OracleTraceFuncName RemoveRegistration;
    public static OracleTraceFuncName FiredEvent;
    public static OracleTraceFuncName SetRegisterInfo;
    public static OracleTraceFuncName GetOracleDependencyFromNTFNId;
    public static OracleTraceFuncName SetNotificationDetails;
    public static OracleTraceFuncName GetObjectData;
    public static OracleTraceFuncName AddBindErrorToCollection;
    public static OracleTraceFuncName HandleError;
    public static OracleTraceFuncName ResetDbType;
    public static OracleTraceFuncName ResetOracleDbType;
    public static OracleTraceFuncName ToString;
    public static OracleTraceFuncName GetBindingSize_Char;
    public static OracleTraceFuncName GetBindingSize_Raw;
    public static OracleTraceFuncName GetBindingSize;
    public static OracleTraceFuncName SetSize;
    public static OracleTraceFuncName PreBindFree;
    public static OracleTraceFuncName PreBind;
    public static OracleTraceFuncName IsProviderSpecificNullValue;
    public static OracleTraceFuncName SetNullIndicators;
    public static OracleTraceFuncName SetArrayContext;
    public static OracleTraceFuncName PreBind_Char;
    public static OracleTraceFuncName PreBind_BDouble;
    public static OracleTraceFuncName PreBind_BFloat;
    public static OracleTraceFuncName PreBind_Int32;
    public static OracleTraceFuncName PreBind_Int64;
    public static OracleTraceFuncName PreBind_Double;
    public static OracleTraceFuncName PreBind_Single;
    public static OracleTraceFuncName PreBind_Decimal;
    public static OracleTraceFuncName PreBind_Date;
    public static OracleTraceFuncName PreBind_TimeStamp;
    public static OracleTraceFuncName PreBind_TimeStampLTZ;
    public static OracleTraceFuncName PreBind_TimeStampTZ;
    public static OracleTraceFuncName PreBind_IntervalDS;
    public static OracleTraceFuncName PreBind_IntervalYM;
    public static OracleTraceFuncName PreBind_Raw;
    public static OracleTraceFuncName PreBind_Clob;
    public static OracleTraceFuncName PreBind_BFile;
    public static OracleTraceFuncName PreBind_Blob;
    public static OracleTraceFuncName PreBind_Json;
    public static OracleTraceFuncName PreBind_Vector;
    public static OracleTraceFuncName PreBind_XmlType;
    public static OracleTraceFuncName PreBind_Cursor;
    public static OracleTraceFuncName PreBind_Boolean;
    public static OracleTraceFuncName PostBind_Boolean;
    public static OracleTraceFuncName PostBind_Char;
    public static OracleTraceFuncName PostBind_RefCursor;
    public static OracleTraceFuncName PostBind_Lob;
    public static OracleTraceFuncName PostBind_TimeStamp;
    public static OracleTraceFuncName PostBind_TimeStampLTZ;
    public static OracleTraceFuncName PostBind_TimeStampTZ;
    public static OracleTraceFuncName PostBind_Raw;
    public static OracleTraceFuncName PostBind_Int32;
    public static OracleTraceFuncName PostBind_Int64;
    public static OracleTraceFuncName PostBind_Decimal;
    public static OracleTraceFuncName PostBind_Single;
    public static OracleTraceFuncName PostBind_BinaryFloat;
    public static OracleTraceFuncName PostBind_BinaryDouble;
    public static OracleTraceFuncName PostBind_Double;
    public static OracleTraceFuncName PostBind_Date;
    public static OracleTraceFuncName PostBind_IntervalDS;
    public static OracleTraceFuncName PostBind_IntervalYM;
    public static OracleTraceFuncName PostBind_XmlType;
    public static OracleTraceFuncName PostBind_Json;
    public static OracleTraceFuncName PostBind_Vector;
    public static OracleTraceFuncName Contains;
    public static OracleTraceFuncName IndexOf;
    public static OracleTraceFuncName RemoveAt;
    public static OracleTraceFuncName Add;
    public static OracleTraceFuncName Insert;
    public static OracleTraceFuncName CopyTo;
    public static OracleTraceFuncName AddRange;
    public static OracleTraceFuncName GetParameter;
    public static OracleTraceFuncName SetParameter;
    public static OracleTraceFuncName FindParamByName;
    public static OracleTraceFuncName Decode;
    public static OracleTraceFuncName Encode;
    public static OracleTraceFuncName FindLastParamByName;
    public static OracleTraceFuncName Copy;
    public static OracleTraceFuncName IsSubsetOf;
    public static OracleTraceFuncName EliminatePasswordValue;
    public static OracleTraceFuncName Commit;
    public static OracleTraceFuncName Rollback;
    public static OracleTraceFuncName Save;
    public static OracleTraceFuncName ConnectionClose;
    public static OracleTraceFuncName ConfigBaseClass;
    public static OracleTraceFuncName GetStoredProcInfo;
    public static OracleTraceFuncName LoadODPMDLL;
    public static OracleTraceFuncName ParseConfigFile;
    public static OracleTraceFuncName ParseEdmMappingsElement;
    public static OracleTraceFuncName Output;
    public static OracleTraceFuncName NewOraFileParams;
    public static OracleTraceFuncName ValidationCallBack;
    public static OracleTraceFuncName ThrowExceptionForRefCursor;
    public static OracleTraceFuncName TraceConfigAndEnvParams;
    public static OracleTraceFuncName TraceImplicitRefCursorParams;
    public static OracleTraceFuncName GetRefCursorInfoForSP;
    public static OracleTraceFuncName GetPrimaryKey;
    public static OracleTraceFuncName CalculateRowSize;
    public static OracleTraceFuncName GetColumnInfoWithSameDbLink;
    public static OracleTraceFuncName CreateSEPSFileWatcher;
    public static OracleTraceFuncName SEPSFileRenamedEvent;
    public static OracleTraceFuncName SEPSFileChangedEvent;
    public static OracleTraceFuncName ProcessSEPSFileChangeEvent;
    public static OracleTraceFuncName CreateConfigFileWatcher;
    public static OracleTraceFuncName OnDeleteEvent;
    public static OracleTraceFuncName OnChangedEvent;
    public static OracleTraceFuncName Get;
    public static OracleTraceFuncName PutFromApp;
    public static OracleTraceFuncName PutFromPSPE;
    public static OracleTraceFuncName PutFromDTC;
    public static OracleTraceFuncName Put;
    public static OracleTraceFuncName ProcessHAEvent;
    public static OracleTraceFuncName GetEnlisted;
    public static OracleTraceFuncName GetRM;
    public static OracleTraceFuncName RemoveRM;
    public static OracleTraceFuncName RegisterCallbacks;
    public static OracleTraceFuncName OnRLBCallback;
    public static OracleTraceFuncName CheckAndUpdateServiceMemberDOWNNames_RLB;
    public static OracleTraceFuncName SecureWithNewPassword;
    public static OracleTraceFuncName Secure;
    public static OracleTraceFuncName GetCS;
    public static OracleTraceFuncName Compare;
    public static OracleTraceFuncName Parse;
    public static OracleTraceFuncName GetStringFromSecureString;
    public static OracleTraceFuncName JsonModuleSettings;
    public static OracleTraceFuncName PerformanceCounterDecrement;
    public static OracleTraceFuncName PerformanceCounterIncrement;
    public static OracleTraceFuncName PutNewPR;
    public static OracleTraceFuncName InitializeSEPSCredentials;
    public static OracleTraceFuncName FetchSEPSCredentails;
    public static OracleTraceFuncName GetUsingDiffPassword;
    public static OracleTraceFuncName RemoveCheckedInPR;
    public static OracleTraceFuncName RemoveCheckedOutPR;
    public static OracleTraceFuncName CacheSqlWithRowIdInfo;
    public static OracleTraceFuncName OnUpdateRecommendations;
    public static OracleTraceFuncName Initialize;
    public static OracleTraceFuncName GetNumberOfIdleConnections;
    public static OracleTraceFuncName UnPopulatePool;
    public static OracleTraceFuncName PopulatePool;
    public static OracleTraceFuncName PutCP;
    public static OracleTraceFuncName AddPRToPool;
    public static OracleTraceFuncName CreateNewPRThreadFunc;
    public static OracleTraceFuncName CreateNewPR;
    public static OracleTraceFuncName GetIdleConnectionToKill;
    public static OracleTraceFuncName GetPRWithMatchingServiceOrInstance;
    public static OracleTraceFuncName GetInstanceNameToConnect;
    public static OracleTraceFuncName ProcessCriteriaCtx_EnlistedConnection;
    public static OracleTraceFuncName ProcessCriteriaCtx_NonEnlistedConnection;
    public static OracleTraceFuncName GetNew;
    public static OracleTraceFuncName MarkAllPRsForDeletion;
    public static OracleTraceFuncName ReInitialize;
    public static OracleTraceFuncName ProcessCriteriaCtx;
    public static OracleTraceFuncName IsInt;
    public static OracleTraceFuncName GetByteRep;
    public static OracleTraceFuncName FromLnxFmt;
    public static OracleTraceFuncName ToLnxFmt;
    public static OracleTraceFuncName SetLength;
    public static OracleTraceFuncName lnxmin;
    public static OracleTraceFuncName lnxren;
    public static OracleTraceFuncName lnxsni;
    public static OracleTraceFuncName lnxnur;
    public static OracleTraceFuncName NegateNumber;
    public static OracleTraceFuncName lnxabs;
    public static OracleTraceFuncName lnxneg;
    public static OracleTraceFuncName lnxadd;
    public static OracleTraceFuncName lnxsub;
    public static OracleTraceFuncName lnxmul;
    public static OracleTraceFuncName lnxdiv;
    public static OracleTraceFuncName lnxmod;
    public static OracleTraceFuncName lnxsqr;
    public static OracleTraceFuncName lnxceil;
    public static OracleTraceFuncName lnxshift;
    public static OracleTraceFuncName lnxfpr;
    public static OracleTraceFuncName lnxflo;
    public static OracleTraceFuncName lnxrou;
    public static OracleTraceFuncName lnxtru;
    public static OracleTraceFuncName lnxpow;
    public static OracleTraceFuncName lnxbex;
    public static OracleTraceFuncName lnxln;
    public static OracleTraceFuncName lnxlog;
    public static OracleTraceFuncName lnxexp;
    public static OracleTraceFuncName lnxsin;
    public static OracleTraceFuncName lnxasin;
    public static OracleTraceFuncName lnxcos;
    public static OracleTraceFuncName lnxcsh;
    public static OracleTraceFuncName lnxacos;
    public static OracleTraceFuncName lnxtan;
    public static OracleTraceFuncName lnxatan;
    public static OracleTraceFuncName lnxatan2;
    public static OracleTraceFuncName lnxtnh;
    public static OracleTraceFuncName LnxmulSetSum;
    public static OracleTraceFuncName LnxmulSetDigit1;
    public static OracleTraceFuncName compareBytes;
    public static OracleTraceFuncName lnxcmp;
    public static OracleTraceFuncName lnxsgn;
    public static OracleTraceFuncName lnxqIDiv;
    public static OracleTraceFuncName lnxqtra;
    public static OracleTraceFuncName lnxqtri;
    public static OracleTraceFuncName GetConnection;
    public static OracleTraceFuncName ReleaseConnection;
    public static OracleTraceFuncName MTSTransactionCompleted;
    public static OracleTraceFuncName InternalCommit;
    public static OracleTraceFuncName InternalRollback;
    public static OracleTraceFuncName InternalHandlePromoteError;
    public static OracleTraceFuncName HandleException;
    public static OracleTraceFuncName EnlistPromotedTransaction;
    public static OracleTraceFuncName CCPEnlistDistributedTxnToSysTxn;
    public static OracleTraceFuncName CCPEnlistTransaction;
    public static OracleTraceFuncName OCPEnlistPSPE;
    public static OracleTraceFuncName OCPEnlistDistributedTxnToSysTxn;
    public static OracleTraceFuncName StartDistributedTransaction;
    public static OracleTraceFuncName PromoteDistributedTransaction;
    public static OracleTraceFuncName Detach;
    public static OracleTraceFuncName Prepare;
    public static OracleTraceFuncName Abort;
    public static OracleTraceFuncName Reset;
    public static OracleTraceFuncName SetLocalCtx;
    public static OracleTraceFuncName SetDistributedCtx;
    public static OracleTraceFuncName DelistTransaction;
    public static OracleTraceFuncName ReleaseRM;
    public static OracleTraceFuncName SinglePhaseCommit;
    public static OracleTraceFuncName doPrepare;
    public static OracleTraceFuncName doCommit;
    public static OracleTraceFuncName doAbort;
    public static OracleTraceFuncName doSinglePhaseCommit;
    public static OracleTraceFuncName EnlistToSysTransaction;
    public static OracleTraceFuncName GetTxnBranch;
    public static OracleTraceFuncName ReleaseTxnBranch;
    public static OracleTraceFuncName FreeTxnBranch;
    public static OracleTraceFuncName AddBranch;
    public static OracleTraceFuncName DetachBranches;
    public static OracleTraceFuncName OnPrepare;
    public static OracleTraceFuncName OnCommit;
    public static OracleTraceFuncName OnAbort;
    public static OracleTraceFuncName OnSinglePhase;
    public static OracleTraceFuncName Promote;
    public static OracleTraceFuncName KerberosHandshake;
    public static OracleTraceFuncName GetSEPSUandP;
    public static OracleTraceFuncName GetListOfSecretBags;
    public static OracleTraceFuncName ExtractDataAndKeyParametersFromPFX;
    public static OracleTraceFuncName ConfigError;
    public static OracleTraceFuncName _trace;
    public static OracleTraceFuncName SendConnectPacketAndProcessResponse;
    public static OracleTraceFuncName ProcessHeaderData;
    public static OracleTraceFuncName ProcessOB;
    public static OracleTraceFuncName Connect;
    public static OracleTraceFuncName ConnectIterate;
    public static OracleTraceFuncName Negotiate;
    public static OracleTraceFuncName ValidateRemoteCertificate;
    public static OracleTraceFuncName Run;
    public static OracleTraceFuncName threadpercb;
    public static OracleTraceFuncName singlethread;
    public static OracleTraceFuncName getStatus;
    public static OracleTraceFuncName pingServer;
    public static OracleTraceFuncName getClientSocket;
    public static OracleTraceFuncName setClientSocket;
    public static OracleTraceFuncName closeClientSocket;
    public static OracleTraceFuncName connect;
    public static OracleTraceFuncName sendRequest;
    public static OracleTraceFuncName checkResponse;
    public static OracleTraceFuncName getBytes;
    public static OracleTraceFuncName skipBytes;
    public static OracleTraceFuncName assign;
    public static OracleTraceFuncName connected;
    public static OracleTraceFuncName clear;
    public static OracleTraceFuncName setListFailed;
    public static OracleTraceFuncName buildConnectionArray;
    public static OracleTraceFuncName joinConnection;
    public static OracleTraceFuncName joinStaleRecievers;
    public static OracleTraceFuncName setConnectionsBusy;
    public static OracleTraceFuncName send;
    public static OracleTraceFuncName type;
    public static OracleTraceFuncName affectedComponents;
    public static OracleTraceFuncName affectedNodes;
    public static OracleTraceFuncName generatingComponent;
    public static OracleTraceFuncName generatingNode;
    public static OracleTraceFuncName generatingProcess;
    public static OracleTraceFuncName clusterId;
    public static OracleTraceFuncName clusterName;
    public static OracleTraceFuncName instanceId;
    public static OracleTraceFuncName instanceName;
    public static OracleTraceFuncName id;
    public static OracleTraceFuncName creationTime;
    public static OracleTraceFuncName deliveryTime;
    public static OracleTraceFuncName setProperty;
    public static OracleTraceFuncName hasInvalidNameCharacters;
    public static OracleTraceFuncName hasInvalidValueCharacters;
    public static OracleTraceFuncName getProperty;
    public static OracleTraceFuncName body;
    public static OracleTraceFuncName setLocalOnly;
    public static OracleTraceFuncName getLocalOnly;
    public static OracleTraceFuncName print;
    public static OracleTraceFuncName enqueue;
    public static OracleTraceFuncName push;
    public static OracleTraceFuncName close;
    public static OracleTraceFuncName dequeue;
    public static OracleTraceFuncName internalDequeue;
    public static OracleTraceFuncName count;
    public static OracleTraceFuncName waiters;
    public static OracleTraceFuncName wake;
    public static OracleTraceFuncName drain_and_close;
    public static OracleTraceFuncName localInit;
    public static OracleTraceFuncName scanNodeLists;
    public static OracleTraceFuncName propertiesNodeLists;
    public static OracleTraceFuncName configNodeLists;
    public static OracleTraceFuncName addNodeList;
    public static OracleTraceFuncName nodeListFailOver;
    public static OracleTraceFuncName nodeListFallBack;
    public static OracleTraceFuncName getMyProperty;
    public static OracleTraceFuncName getConfig;
    public static OracleTraceFuncName getValue;
    public static OracleTraceFuncName checkDebug;
    public static OracleTraceFuncName onsInit;
    public static OracleTraceFuncName getONS;
    public static OracleTraceFuncName addSubscriber;
    public static OracleTraceFuncName removeSubscriber;
    public static OracleTraceFuncName lookupSubscriber;
    public static OracleTraceFuncName closeSubscribers;
    public static OracleTraceFuncName addPublisher;
    public static OracleTraceFuncName removePublisher;
    public static OracleTraceFuncName shutdown;
    public static OracleTraceFuncName debug;
    public static OracleTraceFuncName processId;
    public static OracleTraceFuncName hostname;
    public static OracleTraceFuncName publish;
    public static OracleTraceFuncName deliver;
    public static OracleTraceFuncName handleSubscriptionReply;
    public static OracleTraceFuncName resendSubscriptions;
    public static OracleTraceFuncName createNewSubscriber;
    public static OracleTraceFuncName createNewPublisher;
    public static OracleTraceFuncName readLocalPort;
    public static OracleTraceFuncName readRemotePort;
    public static OracleTraceFuncName readRequestPort;
    public static OracleTraceFuncName readPortFromConfigFile;
    public static OracleTraceFuncName readStandaloneLocalPort;
    public static OracleTraceFuncName getConfigFileName;
    public static OracleTraceFuncName readFormFactor;
    public static OracleTraceFuncName getNodeLists;
    public static OracleTraceFuncName error;
    public static OracleTraceFuncName debugRaw;
    public static OracleTraceFuncName printLists;
    public static OracleTraceFuncName getCallBackManager;
    public static OracleTraceFuncName getPendingSubscriptions;
    public static OracleTraceFuncName GetStream;
    public static OracleTraceFuncName putBytes;
    public static OracleTraceFuncName putString;
    public static OracleTraceFuncName putByte;
    public static OracleTraceFuncName flush;
    public static OracleTraceFuncName PropertyElement;
    public static OracleTraceFuncName put;
    public static OracleTraceFuncName get_Renamed;
    public static OracleTraceFuncName write;
    public static OracleTraceFuncName num;
    public static OracleTraceFuncName realStartup;
    public static OracleTraceFuncName establishConnection;
    public static OracleTraceFuncName readStatusMessage;
    public static OracleTraceFuncName readNotificationMessage;
    public static OracleTraceFuncName runLocal;
    public static OracleTraceFuncName runRemote;
    public static OracleTraceFuncName quiescent;
    public static OracleTraceFuncName wakeThread;
    public static OracleTraceFuncName flushSenderQueue;
    public static OracleTraceFuncName getPublisher;
    public static OracleTraceFuncName receive;
    public static OracleTraceFuncName subscription;
    public static OracleTraceFuncName component;
    public static OracleTraceFuncName register_callback;
    public static OracleTraceFuncName cancel_callback;
    public static OracleTraceFuncName cbthread_exit;
    public static OracleTraceFuncName resendSubscription;
    public static OracleTraceFuncName waitForReply;
    public static OracleTraceFuncName wakeup;
    public static OracleTraceFuncName ToByteArray;
    public static OracleTraceFuncName ToSByteArray;
    public static OracleTraceFuncName WriteStackTrace;
    public static OracleTraceFuncName ToCharArray;
    public static OracleTraceFuncName Identity;
    public static OracleTraceFuncName Max;
    public static OracleTraceFuncName Min;
    public static OracleTraceFuncName Sort;
    public static OracleTraceFuncName Shuffle;
    public static OracleTraceFuncName Equals;
    public static OracleTraceFuncName ReverseStack;
    public static OracleTraceFuncName URShift;
    public static OracleTraceFuncName ReadInput;
    public static OracleTraceFuncName Start;
    public static OracleTraceFuncName Interrupt;
    public static OracleTraceFuncName Join;
    public static OracleTraceFuncName Current;
    public static OracleTraceFuncName SetDateTime;
    public static OracleTraceFuncName Set;
    public static OracleTraceFuncName SetTimeInMilliseconds;
    public static OracleTraceFuncName GetFirstDayOfWeek;
    public static OracleTraceFuncName SetFirstDayOfWeek;
    public static OracleTraceFuncName SetDateFormatPattern;
    public static OracleTraceFuncName GetDateFormatPattern;
    public static OracleTraceFuncName SetTimeFormatPattern;
    public static OracleTraceFuncName GetTimeFormatPattern;
    public static OracleTraceFuncName FormatDateTime;
    public static OracleTraceFuncName TuningFunction;
    public static OracleTraceFuncName OracleTuner;
    public static OracleTraceFuncName setThreshold;
    public static OracleTraceFuncName Register;
    public static OracleTraceFuncName Unregister;
    public static OracleTraceFuncName SubmitData;
    public static OracleTraceFuncName DoScan;
    public static OracleTraceFuncName DoWatch;
    public static OracleTraceFuncName DoWait;
    public static OracleTraceFuncName DoRevert;
    public static OracleTraceFuncName DoReduce;
    public static OracleTraceFuncName DoOptimize;
    public static OracleTraceFuncName startTunerThread;
    public static OracleTraceFuncName SelectPoolToOptimize;
    public static OracleTraceFuncName OptimizeSCSUptoFES;
    public static OracleTraceFuncName OptimizeSCSUptoUniqueStmt;
    public static OracleTraceFuncName GetNotificationOraBufPool;
    public static OracleTraceFuncName PutNotificationOraBufPool;
    public static OracleTraceFuncName ParseNotificationInfo;
    public static OracleTraceFuncName ReadQueryInfo;
    public static OracleTraceFuncName ReadTableInfo;
    public static OracleTraceFuncName ReadRowInfo;
    public static OracleTraceFuncName AddRowDetail;
    public static OracleTraceFuncName SetNotificationTypeSourceInfo;
    public static OracleTraceFuncName ProcessBufferedNSDataPackets;
    public static OracleTraceFuncName ProcessNotification;
    public static OracleTraceFuncName ReadFromNetwork;
    public static OracleTraceFuncName ReadFromBufferedData;
    public static OracleTraceFuncName UnmarshalNSDataPacket;
    public static OracleTraceFuncName ReadByte;
    public static OracleTraceFuncName ReadShort;
    public static OracleTraceFuncName ReadInt;
    public static OracleTraceFuncName ReadBuffer;
    public static OracleTraceFuncName CreateListener;
    public static OracleTraceFuncName ListenerThreadFunction;
    public static OracleTraceFuncName IsPortAvailable;
    public static OracleTraceFuncName FindFreePort;
    public static OracleTraceFuncName GetLength;
    public static OracleTraceFuncName SetDirFileName;
    public static OracleTraceFuncName OpenFile;
    public static OracleTraceFuncName CloseFile;
    public static OracleTraceFuncName FileExists;
    public static OracleTraceFuncName CreateTemporaryLob;
    public static OracleTraceFuncName FreeTemporaryLob;
    public static OracleTraceFuncName IsTemporaryLob;
    public static OracleTraceFuncName GetChunkSize;
    public static OracleTraceFuncName Write;
    public static OracleTraceFuncName ValidateTypeRepresentations;
    public static OracleTraceFuncName Erase;
    public static OracleTraceFuncName Append;
    public static OracleTraceFuncName AddRef;
    public static OracleTraceFuncName RelRef;
    public static OracleTraceFuncName GetRefCount;
    public static OracleTraceFuncName ConvertBytesToChars;
    public static OracleTraceFuncName CanUseOptimizeExecute;
    public static OracleTraceFuncName ValidateStatementCacheSize;
    public static OracleTraceFuncName TrimStringsFromSQL;
    public static OracleTraceFuncName ProcessParameters;
    public static OracleTraceFuncName InitializeParamInfo;
    public static OracleTraceFuncName GetSqlStatementTypeAdrianParser;
    public static OracleTraceFuncName GetSqlStatementType;
    public static OracleTraceFuncName CheckForReturningClauseAdrianParser;
    public static OracleTraceFuncName CheckForReturningClause;
    public static OracleTraceFuncName HasReturningClause;
    public static OracleTraceFuncName ExtractAccessorValuesIntoParam;
    public static OracleTraceFuncName ExtractXMLValuesIntoParam;
    public static OracleTraceFuncName ExtractXMLSaveValuesIntoParam;
    public static OracleTraceFuncName RetrieveMetadata;
    public static OracleTraceFuncName GetBindInfoUsingAdrianParser;
    public static OracleTraceFuncName GetPlaceHolderName;
    public static OracleTraceFuncName ReorderBindByNameBasedParameterCollectionForStoredProcedure;
    public static OracleTraceFuncName GetBindByPositionBasedParameterCollection;
    public static OracleTraceFuncName RegisterForConnectionClose;
    public static OracleTraceFuncName DeregisterForConnectionClose;
    public static OracleTraceFuncName FireConnectionCloseEvent;
    public static OracleTraceFuncName GetInitializedDataReaderImpl;
    public static OracleTraceFuncName SwitchIsolationLevel;
    public static OracleTraceFuncName PingServer;
    public static OracleTraceFuncName OnOra01000Exception;
    public static OracleTraceFuncName AlterSession;
    public static OracleTraceFuncName SubscribeONSEvents;
    public static OracleTraceFuncName Logoff;
    public static OracleTraceFuncName DisConnect;
    public static OracleTraceFuncName ClearState;
    public static OracleTraceFuncName DoProtocolNegotiation;
    public static OracleTraceFuncName DoDataTypeNegotiation;
    public static OracleTraceFuncName SendVersionMessageAndProcessResponse;
    public static OracleTraceFuncName DoAuthentication;
    public static OracleTraceFuncName SetAutoCommit;
    public static OracleTraceFuncName AddTempLOBsToBeFreed;
    public static OracleTraceFuncName AddCursorIdToBeClosed;
    public static OracleTraceFuncName AddCursorIdsToBeClosed;
    public static OracleTraceFuncName AddCursorIdToBeCancelled;
    public static OracleTraceFuncName PiggybackCloseAllCursors;
    public static OracleTraceFuncName PiggybackCancelAllCursors;
    public static OracleTraceFuncName PiggyBackEndToEndMetrics;
    public static OracleTraceFuncName FlushPendingPiggybackMessages;
    public static OracleTraceFuncName AddAllPiggyBackRequests;
    public static OracleTraceFuncName ResetEndToEndMetrics;
    public static OracleTraceFuncName GetServerVersion;
    public static OracleTraceFuncName EvaluateDbMajorMinorPatchsetVersion;
    public static OracleTraceFuncName CheckForAnyErrorFromDB;
    public static OracleTraceFuncName GetDBTimeZoneBytes;
    public static OracleTraceFuncName ParseUserIdForProxyName;
    public static OracleTraceFuncName HandleProxyConection;
    public static OracleTraceFuncName OpenProxySession;
    public static OracleTraceFuncName OpenEndUserSession;
    public static OracleTraceFuncName CloseEndUserSession;
    public static OracleTraceFuncName UpdateSessionAttributes;
    public static OracleTraceFuncName ExecuteNonQueryWithBind;
    public static OracleTraceFuncName AcceptStatementData;
    public static OracleTraceFuncName GetLastWarning;
    public static OracleTraceFuncName TemporaryLobReferenceGet;
    public static OracleTraceFuncName TemporaryLobReferenceAdd;
    public static OracleTraceFuncName TemporaryLobReferenceRemove;
    public static OracleTraceFuncName Init;
    public static OracleTraceFuncName ReleaseCursor;
    public static OracleTraceFuncName FetchMoreRows;
    public static OracleTraceFuncName GetByteRepresentation;
    public static OracleTraceFuncName GetLobLocator;
    public static OracleTraceFuncName IsCompleteDataForLongAvailable;
    public static OracleTraceFuncName GetColumnOrdinal;
    public static OracleTraceFuncName ConfigureNextResult;
    public static OracleTraceFuncName CollectTempLOBsToBeFreed;
    public static OracleTraceFuncName GetMachineAddress;
    public static OracleTraceFuncName GetEventTypeForNotification;
    public static OracleTraceFuncName HandleEvent;
    public static OracleTraceFuncName StartListener;
    public static OracleTraceFuncName IsListenerRunning;
    public static OracleTraceFuncName SetCallbackForNotification;
    public static OracleTraceFuncName RegisterForChangeNotification;
    public static OracleTraceFuncName SendRegistrationInfo;
    public static OracleTraceFuncName UnRegisterFromChangeNotification;
    public static OracleTraceFuncName UnregisterForChangeNotifications;
    public static OracleTraceFuncName MarkDirty;
    public static OracleTraceFuncName HandleNotification;
    public static OracleTraceFuncName GetNotificationManager;
    public static OracleTraceFuncName RegisterForNotification;
    public static OracleTraceFuncName StartSubscription;
    public static OracleTraceFuncName ExtractDecimalFromAccessor;
    public static OracleTraceFuncName ExtractDoubleFromAccessor;
    public static OracleTraceFuncName ExtractSingleFromAccessor;
    public static OracleTraceFuncName ExtractIntFromAccessor;
    public static OracleTraceFuncName ExtractRefCursorFromAccessor;
    public static OracleTraceFuncName ExtractLongFromAccessor;
    public static OracleTraceFuncName ExtractBDoubleFromAccessor;
    public static OracleTraceFuncName ExtractBFloatFromAccessor;
    public static OracleTraceFuncName ExtractCharFromAccessor;
    public static OracleTraceFuncName ExtractRawFromAccessor;
    public static OracleTraceFuncName ExtractDateFromAccessor;
    public static OracleTraceFuncName ExtractTimeStampFromAccessor;
    public static OracleTraceFuncName ExtractTimeStampTZFromAccessor;
    public static OracleTraceFuncName ExtractTimeStampLTZFromAccessor;
    public static OracleTraceFuncName ExtractIntervalYMFromAccessor;
    public static OracleTraceFuncName ExtractIntervalDSFromAccessor;
    public static OracleTraceFuncName GetParameterMetaData;
    public static OracleTraceFuncName SetCharDataArrayInBytes;
    public static OracleTraceFuncName SetRawDataArrayInBytes;
    public static OracleTraceFuncName SetCharDataInBytes;
    public static OracleTraceFuncName SetInt32DataInBytes;
    public static OracleTraceFuncName SetPlsqlBooleanDataInBytes;
    public static OracleTraceFuncName SetJsonDataInBytes;
    public static OracleTraceFuncName SetJsonArrayInBytes;
    public static OracleTraceFuncName IsJsonDataNullValue;
    public static OracleTraceFuncName SetVectorDataInBytes;
    public static OracleTraceFuncName SetVectorArrayInBytes;
    public static OracleTraceFuncName IsVectorDataNullValue;
    public static OracleTraceFuncName SetInt64DataInBytes;
    public static OracleTraceFuncName SetInt32ArrayInBytes;
    public static OracleTraceFuncName SetInt64ArrayInBytes;
    public static OracleTraceFuncName SetBinaryDoubleArrayInBytes;
    public static OracleTraceFuncName SetClobArrayDataInBytes;
    public static OracleTraceFuncName SetBlobArrayDataInBytes;
    public static OracleTraceFuncName SetBFileArrayInBytes;
    public static OracleTraceFuncName SetTimeStampArrayInBytes;
    public static OracleTraceFuncName SetTimeStampLTZArrayInBytes;
    public static OracleTraceFuncName SetTimeStampTZArrayInBytes;
    public static OracleTraceFuncName SetIntervalYMArrayInBytes;
    public static OracleTraceFuncName SetIntervalDSArrayInBytes;
    public static OracleTraceFuncName SetBinaryFloatArrayInBytes;
    public static OracleTraceFuncName SetDecimalArrayInBytes;
    public static OracleTraceFuncName SetDateArrayInBytes;
    public static OracleTraceFuncName SetPlsqlBooleanArrayInBytes;
    public static OracleTraceFuncName SetRefCursorArrayInBytes;
    public static OracleTraceFuncName SetDecimalDataInBytes;
    public static OracleTraceFuncName SetBinaryDoubleInBytes;
    public static OracleTraceFuncName SetDoubleInBytes;
    public static OracleTraceFuncName SetDoubleArrayInBytes;
    public static OracleTraceFuncName SetSingleInBytes;
    public static OracleTraceFuncName SetSingleArrayInBytes;
    public static OracleTraceFuncName SetBinaryFloatInBytes;
    public static OracleTraceFuncName SetTimeStampInBytes;
    public static OracleTraceFuncName SetTimeStampLTZInBytes;
    public static OracleTraceFuncName SetTimeStampTZInBytes;
    public static OracleTraceFuncName SetIntervalDSInBytes;
    public static OracleTraceFuncName SetIntervalYMInBytes;
    public static OracleTraceFuncName SetRawDataInBytes;
    public static OracleTraceFuncName SetDateInBytes;
    public static OracleTraceFuncName SetBlobDataInBytes;
    public static OracleTraceFuncName SetBFileDataInBytes;
    public static OracleTraceFuncName SetRefCursorDataInBytes;
    public static OracleTraceFuncName SetClobDataInBytes;
    public static OracleTraceFuncName SetXmlTypeInBytes;
    public static OracleTraceFuncName SetXmlTypeArrayInBytes;
    public static OracleTraceFuncName GetPreBindBuffer_Char;
    public static OracleTraceFuncName GetPreBindBuffer_Str;
    public static OracleTraceFuncName GetPreBindBuffer_Raw;
    public static OracleTraceFuncName GetCharDataFromBytes;
    public static OracleTraceFuncName GetRefCursorFromBytes;
    public static OracleTraceFuncName GetLobDataFromBytes;
    public static OracleTraceFuncName ExtractLobDataFromAccessor;
    public static OracleTraceFuncName GetJsonFrombytes;
    public static OracleTraceFuncName GetJsonArrayFromBytes;
    public static OracleTraceFuncName ExtractJsonFromAccessor;
    public static OracleTraceFuncName GetVectorFrombytes;
    public static OracleTraceFuncName GetVectorArrayFromBytes;
    public static OracleTraceFuncName ExtractVectorFromAccessor;
    public static OracleTraceFuncName GetXmlTypeArrayFromBytes;
    public static OracleTraceFuncName ExtractXmlTypeDataFromAccessor;
    public static OracleTraceFuncName GetTimeStampFromBytes;
    public static OracleTraceFuncName GetTimeStampLTZFromBytes;
    public static OracleTraceFuncName GetTimeStampTZFromBytes;
    public static OracleTraceFuncName GetRawDataFromBytes;
    public static OracleTraceFuncName GetRawDataFromBytesInPlSqlArray;
    public static OracleTraceFuncName GetDecimalArrayFromBytes;
    public static OracleTraceFuncName GetBinaryDoubleArrayFromBytes;
    public static OracleTraceFuncName GetBinaryFloatArrayFromBytes;
    public static OracleTraceFuncName GetIntArrayFromBytes;
    public static OracleTraceFuncName GetPlsqlBooleanArrayFromBytes;
    public static OracleTraceFuncName GetCharArrayFromBytes;
    public static OracleTraceFuncName GetDateArrayFromBytes;
    public static OracleTraceFuncName GetDoubleArrayFromBytes;
    public static OracleTraceFuncName GetIntervalDSArrayFromBytes;
    public static OracleTraceFuncName GetIntervalYMArrayFromBytes;
    public static OracleTraceFuncName GetLobArrayFromBytes;
    public static OracleTraceFuncName GetLongArrayFromBytes;
    public static OracleTraceFuncName GetRawArrayFromBytes;
    public static OracleTraceFuncName GetRefCursorArrayFromBytes;
    public static OracleTraceFuncName GetSingleArrayFromBytes;
    public static OracleTraceFuncName GetTimeStampArrayFromBytes;
    public static OracleTraceFuncName GetTimeStampLTZArrayFromBytes;
    public static OracleTraceFuncName GetTimeStampTZArrayFromBytes;
    public static OracleTraceFuncName GetDecimalFromBytes;
    public static OracleTraceFuncName GetIntFromBytes;
    public static OracleTraceFuncName GetPlsqlBooleanFromBytes;
    public static OracleTraceFuncName GetLongFromBytes;
    public static OracleTraceFuncName GetSingleFromBytes;
    public static OracleTraceFuncName GetBinaryFloatFromBytes;
    public static OracleTraceFuncName GetDoubleFromBytes;
    public static OracleTraceFuncName GetBinaryDoubleFromBytes;
    public static OracleTraceFuncName GetDateFromBytes;
    public static OracleTraceFuncName GetIntervalDSFromBytes;
    public static OracleTraceFuncName GetIntervalYMFromBytes;
    public static OracleTraceFuncName GetXmlTypeDataFromBytes;
    public static OracleTraceFuncName GetCharDataFromBytesInPLSQLArray;
    public static OracleTraceFuncName GetDoubleFromBytesInPLSQLArray;
    public static OracleTraceFuncName GetSingleFromBytesInPLSQLArray;
    public static OracleTraceFuncName GetBinaryDoubleFromBytesInPLSQLArray;
    public static OracleTraceFuncName GetBinaryFloatFromBytesInPLSQLArray;
    public static OracleTraceFuncName GetInt32FromBytesInPLSQLArray;
    public static OracleTraceFuncName GetDecimalFromBytesInPLSQLArray;
    public static OracleTraceFuncName GetLongFromBytesInPLSQLArray;
    public static OracleTraceFuncName GetDateFromBytesInPLSQLArray;
    public static OracleTraceFuncName OracleXmlTypeImpl;
    public static OracleTraceFuncName DoSqlLocalProcessing;
    public static OracleTraceFuncName GetSchemaMetaData;
    public static OracleTraceFuncName SqlFillMetaAttr;
    public static OracleTraceFuncName WriteOSessKeyMessage;
    public static OracleTraceFuncName ReadOSessKeyResponse;
    public static OracleTraceFuncName EncryptNewPassword;
    public static OracleTraceFuncName WriteOAuthMessage;
    public static OracleTraceFuncName ReceiveOAuthResponse;
    public static OracleTraceFuncName Exists;
    public static OracleTraceFuncName ReadMessage;
    public static OracleTraceFuncName WriteMessage;
    public static OracleTraceFuncName ReadErrorMessage;
    public static OracleTraceFuncName ReadWarning;
    public static OracleTraceFuncName ReInit;
    public static OracleTraceFuncName SendReExecuteRequest;
    public static OracleTraceFuncName SendExecuteRequest;
    public static OracleTraceFuncName WriteOall8Message;
    public static OracleTraceFuncName WritePisdef;
    public static OracleTraceFuncName WritePisdefData;
    public static OracleTraceFuncName MarshalValuesForArrayBind;
    public static OracleTraceFuncName MarshalDefines;
    public static OracleTraceFuncName MarshalBindMetaData;
    public static OracleTraceFuncName MarshalBindValues;
    public static OracleTraceFuncName MarshalParameterValue;
    public static OracleTraceFuncName MarshalAssociativeArrayParameterValue;
    public static OracleTraceFuncName ReceiveExecuteResponse;
    public static OracleTraceFuncName Process_RPA_Message;
    public static OracleTraceFuncName GetExecuteOptions;
    public static OracleTraceFuncName CreateDefineAccessors;
    public static OracleTraceFuncName InitDefines;
    public static OracleTraceFuncName WriteFunctionHeader;
    public static OracleTraceFuncName ProcessServerSidePiggybackFunction;
    public static OracleTraceFuncName ProcessOCSSYNCMessage;
    public static OracleTraceFuncName OpenLob;
    public static OracleTraceFuncName CloseLob;
    public static OracleTraceFuncName Trim;
    public static OracleTraceFuncName FreeTempLobsPiggyBack;
    public static OracleTraceFuncName LobArrayRead;
    public static OracleTraceFuncName WriteLobArrayOperation;
    public static OracleTraceFuncName LobArrayReceiveResponse;
    public static OracleTraceFuncName WriteLobOperation;
    public static OracleTraceFuncName ReceiveResponse;
    public static OracleTraceFuncName GetLobId;
    public static OracleTraceFuncName GetLobIdString;
    public static OracleTraceFuncName WriteLobDataAsUB2;
    public static OracleTraceFuncName WriteLobData;
    public static OracleTraceFuncName ReadLobDataAsUB2;
    public static OracleTraceFuncName ReadLobData;
    public static OracleTraceFuncName ReadLobDataForArray;
    public static OracleTraceFuncName WriteTTCCode;
    public static OracleTraceFuncName WriteOKPNMessage;
    public static OracleTraceFuncName ReceiveOKPNResponse;
    public static OracleTraceFuncName ReadResponse;
    public static OracleTraceFuncName SetNumberOfColumns;
    public static OracleTraceFuncName SetBitVector;
    public static OracleTraceFuncName ReadRow;
    public static OracleTraceFuncName ReadRowNew;
    public static OracleTraceFuncName ReadBVC;
    public static OracleTraceFuncName GetSession;
    public static OracleTraceFuncName ReadRPAMessage;
    public static OracleTraceFuncName ReleaseSession;
    public static OracleTraceFuncName Receive;
    public static OracleTraceFuncName GetVersionNumber;
    public static OracleTraceFuncName ToDateTime;
    public static OracleTraceFuncName Search;
    public static OracleTraceFuncName Seek;
    public static OracleTraceFuncName IsEqual;
    public static OracleTraceFuncName GetDFNames;
    public static OracleTraceFuncName SetDFNames;
    public static OracleTraceFuncName CompareTo;
    public static OracleTraceFuncName GetHashCode;
    public static OracleTraceFuncName Concat;
    public static OracleTraceFuncName GreaterThan;
    public static OracleTraceFuncName GreaterThanOrEqual;
    public static OracleTraceFuncName LessThan;
    public static OracleTraceFuncName LessThanOrEqual;
    public static OracleTraceFuncName NotEquals;
    public static OracleTraceFuncName OperatorEqualto;
    public static OracleTraceFuncName OperatorNotequalto;
    public static OracleTraceFuncName OperatorPlus;
    public static OracleTraceFuncName SetLobLocator;
    public static OracleTraceFuncName BeginChunkWrite;
    public static OracleTraceFuncName EndChunkWrite;
    public static OracleTraceFuncName GetOptimumChunkSize;
    public static OracleTraceFuncName CreateTempLob;
    public static OracleTraceFuncName CreateDeepCopy;
    public static OracleTraceFuncName GetDaysBetween;
    public static OracleTraceFuncName ToOracleTimeStamp;
    public static OracleTraceFuncName GetSysDate;
    public static OracleTraceFuncName DateTime;
    public static OracleTraceFuncName GetDateData;
    public static OracleTraceFuncName ToBytes;
    public static OracleTraceFuncName OperatorMinus;
    public static OracleTraceFuncName OperatorMultiply;
    public static OracleTraceFuncName OperatorDivide;
    public static OracleTraceFuncName OperatorPercent;
    public static OracleTraceFuncName Abs;
    public static OracleTraceFuncName AdjustScale;
    public static OracleTraceFuncName Ceiling;
    public static OracleTraceFuncName ConvertToPrecScale;
    public static OracleTraceFuncName Divide;
    public static OracleTraceFuncName Floor;
    public static OracleTraceFuncName Mod;
    public static OracleTraceFuncName Multiply;
    public static OracleTraceFuncName Negate;
    public static OracleTraceFuncName SetPrecision;
    public static OracleTraceFuncName SetPrecisionNoRound;
    public static OracleTraceFuncName Round;
    public static OracleTraceFuncName Shift;
    public static OracleTraceFuncName Sign;
    public static OracleTraceFuncName Sqrt;
    public static OracleTraceFuncName Subtract;
    public static OracleTraceFuncName Truncate;
    public static OracleTraceFuncName Exp;
    public static OracleTraceFuncName Pow;
    public static OracleTraceFuncName Log;
    public static OracleTraceFuncName Acos;
    public static OracleTraceFuncName Asin;
    public static OracleTraceFuncName Atan;
    public static OracleTraceFuncName Atan2;
    public static OracleTraceFuncName Cos;
    public static OracleTraceFuncName Sin;
    public static OracleTraceFuncName Tan;
    public static OracleTraceFuncName Cosh;
    public static OracleTraceFuncName Sinh;
    public static OracleTraceFuncName Tanh;
    public static OracleTraceFuncName ToByte;
    public static OracleTraceFuncName ToInt16;
    public static OracleTraceFuncName ToInt32;
    public static OracleTraceFuncName ToInt64;
    public static OracleTraceFuncName ToSingle;
    public static OracleTraceFuncName ToDouble;
    public static OracleTraceFuncName SetPi;
    public static OracleTraceFuncName GetPosInfinity;
    public static OracleTraceFuncName GetNegInfinity;
    public static OracleTraceFuncName GetNaN;
    public static OracleTraceFuncName TimeSpan;
    public static OracleTraceFuncName GetIDSData;
    public static OracleTraceFuncName IntervalDSToTicks;
    public static OracleTraceFuncName GetIYMData;
    public static OracleTraceFuncName GetLong;
    public static OracleTraceFuncName GetTotalMonth;
    public static OracleTraceFuncName GetDataReader;
    public static OracleTraceFuncName GetNonUnicodeBytes;
    public static OracleTraceFuncName GetUnicodeBytes;
    public static OracleTraceFuncName StringCompare;
    public static OracleTraceFuncName AddYears;
    public static OracleTraceFuncName AddMonths;
    public static OracleTraceFuncName AddDays;
    public static OracleTraceFuncName AddHours;
    public static OracleTraceFuncName AddMinutes;
    public static OracleTraceFuncName AddSeconds;
    public static OracleTraceFuncName AddMilliseconds;
    public static OracleTraceFuncName AddNanoseconds;
    public static OracleTraceFuncName GetYearsBetween;
    public static OracleTraceFuncName ToOracleDate;
    public static OracleTraceFuncName ToOracleTimeStampLTZ;
    public static OracleTraceFuncName ToOracleTimeStampTZ;
    public static OracleTraceFuncName AddDayTimeToTimeStamp;
    public static OracleTraceFuncName AddYearMonthToTimeStamp;
    public static OracleTraceFuncName ToUniversalTime;
    public static OracleTraceFuncName GetLocalTimeZoneName;
    public static OracleTraceFuncName GetLocalTimeZoneOffset;
    public static OracleTraceFuncName AddDayTimeToTimeStampLTZ;
    public static OracleTraceFuncName AddYearMonthToTimeStampLTZ;
    public static OracleTraceFuncName Flush;
    public static OracleTraceFuncName Extract;
    public static OracleTraceFuncName GetXmlDocument;
    public static OracleTraceFuncName IsExists;
    public static OracleTraceFuncName Transform;
    public static OracleTraceFuncName Validate;
    public static OracleTraceFuncName GetSchemaInfo;
    public static OracleTraceFuncName InitializelatestTZversion;
    public static OracleTraceFuncName ProcessTimeZone;
    public static OracleTraceFuncName GetTimeZoneOffsetInfo;
    public static OracleTraceFuncName GetFsecond;
    public static OracleTraceFuncName GetDaysBetweenMonth;
    public static OracleTraceFuncName GetDaysBetweenTimeStamp;
    public static OracleTraceFuncName GetYearsBetweenTimeStamp;
    public static OracleTraceFuncName ConstructTimeStampByteRep;
    public static OracleTraceFuncName ConstructByteArrayTS;
    public static OracleTraceFuncName ConstructUTCByteArray;
    public static OracleTraceFuncName GetPositiveTimeStampValues;
    public static OracleTraceFuncName AdjustTimeStampValues;
    public static OracleTraceFuncName GetTSData;
    public static OracleTraceFuncName GetTSTZData;
    public static OracleTraceFuncName ExtractTimeStampValues;
    public static OracleTraceFuncName GetLTZOffset;
    public static OracleTraceFuncName GetAdjustedTimeStampLTZ;
    public static OracleTraceFuncName GetLocalTimeFromUTCByteRep;
    public static OracleTraceFuncName GetUTCByteRepFromLocalArray;
    public static OracleTraceFuncName ToLocalTime;
    public static OracleTraceFuncName ConvertLTZDataToDBTime;
    public static OracleTraceFuncName ConvertDBTimeToLTZData;
    public static OracleTraceFuncName GetLocalTZOffset;
    public static OracleTraceFuncName GetTimeZoneInfo;
    public static OracleTraceFuncName ResolveSimple;
    public static OracleTraceFuncName Handle_HTTPS_PROXY;
    public static OracleTraceFuncName Trace;
    public static OracleTraceFuncName Listen;
    public static OracleTraceFuncName BindByName;
    public static OracleTraceFuncName CommandTimeout;
    public static OracleTraceFuncName DatabaseEditionName;
    public static OracleTraceFuncName DbNotificationAddress;
    public static OracleTraceFuncName DbNotificationPort;
    public static OracleTraceFuncName DisableOOB;
    public static OracleTraceFuncName DrcpConnectionClass;
    public static OracleTraceFuncName FetchSize;
    public static OracleTraceFuncName HAEvents;
    public static OracleTraceFuncName LoadBalancing;
    public static OracleTraceFuncName MaxStatementCacheSize;
    public static OracleTraceFuncName NamesDirectoryPath;
    public static OracleTraceFuncName OnsConfigFile;
    public static OracleTraceFuncName OnsMode;
    public static OracleTraceFuncName OnsProtocol;
    public static OracleTraceFuncName OnsWalletLocation;
    public static OracleTraceFuncName OracleOnsServers;
    public static OracleTraceFuncName ReceiveBufferSize;
    public static OracleTraceFuncName SelfTuning;
    public static OracleTraceFuncName SendBufferSize;
    public static OracleTraceFuncName ServiceRelocationConnectionTimeout;
    public static OracleTraceFuncName ChunkMigrationConnectionTimeout;
    public static OracleTraceFuncName SqlNetAuthenticationServices;
    public static OracleTraceFuncName SqlNetCryptoChecksumClient;
    public static OracleTraceFuncName SqlNetCryptoChecksumTypesClient;
    public static OracleTraceFuncName SqlNetEncryptionClient;
    public static OracleTraceFuncName SqlNetEncryptionTypesClient;
    public static OracleTraceFuncName SqlNetKerberos5CCName;
    public static OracleTraceFuncName SqlNetKerberos5Conf;
    public static OracleTraceFuncName SqlNetWalletOverride;
    public static OracleTraceFuncName SSLServerDNMatch;
    public static OracleTraceFuncName SSLVersion;
    public static OracleTraceFuncName SSLCertificateThumbprint;
    public static OracleTraceFuncName StatementCacheSize;
    public static OracleTraceFuncName TcpConnectTimeout;
    public static OracleTraceFuncName TcpNoDelay;
    public static OracleTraceFuncName TnsAdmin;
    public static OracleTraceFuncName TraceFileLocation;
    public static OracleTraceFuncName DumpInfo;
    public static OracleTraceFuncName TraceLevel;
    public static OracleTraceFuncName TraceOption;
    public static OracleTraceFuncName WalletLocation;
    public static OracleTraceFuncName TNSNames;
    public static OracleTraceFuncName ProcessBatch;
    public static OracleTraceFuncName DemandOrclPermission;
    public static OracleTraceFuncName MetaDataXml;
    public static OracleTraceFuncName PromotableTransaction;
    public static OracleTraceFuncName PerformanceCounters;
    public static OracleTraceFuncName Pipelining;
    public static OracleTraceFuncName InitialLOBFetchSize;
    public static OracleTraceFuncName InitialLONGFetchSize;
    public static OracleTraceFuncName OpenTelemetryTracing;
    public static OracleTraceFuncName OraDebugJDWP;
    public static OracleTraceFuncName LdapAdmin;
    public static OracleTraceFuncName DirectoryServers;
    public static OracleTraceFuncName NamesLdapAuthenticateBind;
    public static OracleTraceFuncName NamesLdapAuthenticateBindMethod;
    public static OracleTraceFuncName DirectoryType;
    public static OracleTraceFuncName DefaultAdminContext;
    public static OracleTraceFuncName NamesLdapConnTimeout;
    public static OracleTraceFuncName OMTSRECO_IP_ADDRESS;
    public static OracleTraceFuncName OMTSRECO_PORT;
    public static OracleTraceFuncName ORAMTS_SESS_TXNTIMETOLIVE;
    public static OracleTraceFuncName TraceFileMaxSize;
    public static OracleTraceFuncName FindFile;
    public static OracleTraceFuncName GetKey;
    public static OracleTraceFuncName Renegotiate;
    public static OracleTraceFuncName CreateTcpConnection;
    public static OracleTraceFuncName Handshake;
    public static OracleTraceFuncName SendHandshakeRequest;
    public static OracleTraceFuncName ParseHandshakeResponse;
    public static OracleTraceFuncName GetHandshakeMessage;
    public static OracleTraceFuncName ProcessChunkMoveEvent;
    public static OracleTraceFuncName IsOsUserPresentInConString;
    public static OracleTraceFuncName OnConnectionCreation;
    public static OracleTraceFuncName OnMigrateChunk;
    public static OracleTraceFuncName OnRemoveChunk;
    public static OracleTraceFuncName OnSplitChunk;
    public static OracleTraceFuncName GetAllPriorityInstances;
    public static OracleTraceFuncName BuildTopologyForInstance;
    public static OracleTraceFuncName OnAddChunk;
    public static OracleTraceFuncName OnAddChunkValues;
    public static OracleTraceFuncName OnDropChunk;
    public static OracleTraceFuncName OnDropChunkValues;
    public static OracleTraceFuncName OnMergeChunk;
    public static OracleTraceFuncName OnInvalidateChunk;
    public static OracleTraceFuncName SqlNetURI;
    public static OracleTraceFuncName SqlNetCloudUser;
    public static OracleTraceFuncName NewDRCPSessionAttached;
    public static OracleTraceFuncName GetPRForSharding;
    public static OracleTraceFuncName AddCQNRestration;
    public static OracleTraceFuncName GetCQNListenerClientId;
    public static OracleTraceFuncName RemoveCQNRestration;
    public static OracleTraceFuncName EnqueueNotification;
    public static OracleTraceFuncName PropagateNotifications;
    public static OracleTraceFuncName ReceiveONSEvents;
    public static OracleTraceFuncName ShutDownListener;
    public static OracleTraceFuncName UseClientInitiatedCQN;
    public static OracleTraceFuncName ReConnect;
    public static OracleTraceFuncName ReconnectCallback;
    public static OracleTraceFuncName StartSecureCQNListener;
    public static OracleTraceFuncName NotifyRegistrationEndToAll;
    public static OracleTraceFuncName AddAsPiggyback;
    public static OracleTraceFuncName OnErrorInvalidateChunk;
    public static OracleTraceFuncName OnErrorInvalidateChunkForInstance;
    public static OracleTraceFuncName OnSplitPartitionset;
    public static OracleTraceFuncName OnNewPartitionset;
    public static OracleTraceFuncName TraceTopologyForChunk;
    public static OracleTraceFuncName GetFactory;
    public static OracleTraceFuncName GetUdtName;
    public static OracleTraceFuncName setudtmapping;
    public static OracleTraceFuncName GetAllReferencedAssemblies;
    public static OracleTraceFuncName GetCustomObject;
    public static OracleTraceFuncName DescribeCustomType;
    public static OracleTraceFuncName GetUDTJsonString;
    public static OracleTraceFuncName WriteUnpickleElements;
    public static OracleTraceFuncName GetDataReaderFromLocator;
    public static OracleTraceFuncName GetElementsFromReader;
    public static OracleTraceFuncName WriteElementsFromReader;
    public static OracleTraceFuncName WriteJsonFromLocator;
    public static OracleTraceFuncName ParseTDS;
    public static OracleTraceFuncName ParseTypeInfo;
    public static OracleTraceFuncName GetMetaData;
    public static OracleTraceFuncName GetNamedTypeMetaData;
    public static OracleTraceFuncName GetNullCustomValue;
    public static OracleTraceFuncName GetUDTType;
    public static OracleTraceFuncName AddUDTType;
    public static OracleTraceFuncName SetValue;
    public static OracleTraceFuncName GetAttrType;
    public static OracleTraceFuncName GetUDTSQLName;
    public static OracleTraceFuncName GetUDTNamedType;
    public static OracleTraceFuncName CreateNullInstance;
    public static OracleTraceFuncName CreateAttrInstance;
    public static OracleTraceFuncName CreateUDTInstance;
    public static OracleTraceFuncName CreatedFromTDS;
    public static OracleTraceFuncName CreatedFromOpaque;
    public static OracleTraceFuncName GetRealInstType;
    public static OracleTraceFuncName GetNumberString;
    public static OracleTraceFuncName GetDateTimeString;
    public static OracleTraceFuncName GetIntervalString;
    public static OracleTraceFuncName PreBind_UDT;
    public static OracleTraceFuncName PostBind_UDT;
    public static OracleTraceFuncName GetUDTFromBytes;
    public static OracleTraceFuncName GetUDTArrayFromBytes;
    public static OracleTraceFuncName SetUDTDataInBytes;
    public static OracleTraceFuncName SetUDTArrayInBytes;
    public static OracleTraceFuncName IsUDTDataNullValue;
    public static OracleTraceFuncName ExtractUDTFromAccessor;
    public static OracleTraceFuncName SetKeepAlive;
    public static OracleTraceFuncName GetData;
    public static OracleTraceFuncName ExtractUDTAsJsonFromAccessor;
    public static OracleTraceFuncName GetUDTAsJsonFromBytes;
    public static OracleTraceFuncName GetUDTAsJsonArrayFromBytes;
    public static OracleTraceFuncName PostBind_UDTAsJson;
    public static OracleTraceFuncName GetOracleRef;
    public static OracleTraceFuncName GetRefHexString;
    public static OracleTraceFuncName PreBind_Ref;
    public static OracleTraceFuncName PostBind_Ref;
    public static OracleTraceFuncName GetREFFromBytes;
    public static OracleTraceFuncName GetREFArrayFromBytes;
    public static OracleTraceFuncName SetREFDataInBytes;
    public static OracleTraceFuncName SetREFArrayInBytes;
    public static OracleTraceFuncName IsREFDataNullValue;
    public static OracleTraceFuncName ExtractRefFromAccessor;
    public static OracleTraceFuncName Delete;
    public static OracleTraceFuncName ReleaseUDTInsts;
    public static OracleTraceFuncName BeginRequest;
    public static OracleTraceFuncName EndRequest;
    public static OracleTraceFuncName AddRequestBoundaryPiggyback;
    public static OracleTraceFuncName DestroyAndReplace;
    public static OracleTraceFuncName RemoveDeadConnections;
    public static OracleTraceFuncName GetDecimalRetainTrailingZeros;
    public static OracleTraceFuncName BuildCo;
    public static OracleTraceFuncName GetCustomValue;
    public static OracleTraceFuncName GetAttrNamesAndTypeNames;
    public static OracleTraceFuncName GetAttrNamesAndTypeNamesUsingSQLName;
    public static OracleTraceFuncName GetAttrNamesAndTypeNamesUsingTOID;
    public static OracleTraceFuncName GetSQLNameFromTOID;
    public static OracleTraceFuncName GetSQLNameFromParent;
    public static OracleTraceFuncName GetSubTypeNames;
    public static OracleTraceFuncName GetElementTypeName;
    public static OracleTraceFuncName GetValueFromLocator;
    public static OracleTraceFuncName UnpickleElements;
    public static OracleTraceFuncName UnpickleCollection;
    public static OracleTraceFuncName UnpickleObject;
    public static OracleTraceFuncName UnpickleUPT;
    public static OracleTraceFuncName Pickle;
    public static OracleTraceFuncName CheckNextByte;
    public static OracleTraceFuncName ReadLength;
    public static OracleTraceFuncName SkipRestOfLength;
    public static OracleTraceFuncName GetCustomType;
    public static OracleTraceFuncName GetCustomTypeFactory;
    public static OracleTraceFuncName ReadPrefetchInformation;
    public static OracleTraceFuncName UnmarshalColumnData;
    public static OracleTraceFuncName UnmarshalCLR;
    public static OracleTraceFuncName UnmarshalCLR_ColData;
    public static OracleTraceFuncName UnmarshalCLR_ScanOnly;
    public static OracleTraceFuncName GetLocaleSpecificNLSValues;
    public static OracleTraceFuncName TreatConnectionCreationAsUpEvent;
    public static OracleTraceFuncName CreateServiceCtx;
    public static OracleTraceFuncName UpdateServiceDown;
    public static OracleTraceFuncName RLBGravitateThreadFunc;
    public static OracleTraceFuncName get_ServiceName;
    public static OracleTraceFuncName ParseDistTxnElement;
    public static OracleTraceFuncName OciTenancy;
    public static OracleTraceFuncName OciIamUrl;
    public static OracleTraceFuncName OciCompartment;
    public static OracleTraceFuncName OciDatabase;
    public static OracleTraceFuncName TokenLocation;
    public static OracleTraceFuncName PasswordAuthentication;
    public static OracleTraceFuncName TokenAuthentication;
    public static OracleTraceFuncName OracleAccessToken;
    public static OracleTraceFuncName RefreshAccessToken;
    public static OracleTraceFuncName ParseDBToken;
    public static OracleTraceFuncName GetRefreshedAccessToken;
    public static OracleTraceFuncName CalculateTokenExpiryTime;
    public static OracleTraceFuncName StartTokenRefreshTimer;
    public static OracleTraceFuncName ResetTokenRefreshTimer;
    public static OracleTraceFuncName StopTokenRefreshTimer;
    public static OracleTraceFuncName TokenExpiryCallback;
    public static OracleTraceFuncName GetAccessTokenForAuthentication;
    public static OracleTraceFuncName GetBearerToken;
    public static OracleTraceFuncName OracleJsonWebToken;
    public static OracleTraceFuncName DeriveDefaultDirectory;
    public static OracleTraceFuncName GetTokenConfigurationInstance;
    public static OracleTraceFuncName LoadPluginAssembly;
    public static OracleTraceFuncName GenerateAuthHeader;
    public static OracleTraceFuncName SignHeader;
    public static OracleTraceFuncName CreateTokenFromFile;
    public static OracleTraceFuncName GetDBTokenBytes;
    public static OracleTraceFuncName DBTokenFileChangedNotification;
    public static OracleTraceFuncName PrivateKeyFileChangedNotification;
    public static OracleTraceFuncName OpenWithNewToken;
    public static OracleTraceFuncName GetTokenAuthFieldValues;
    public static OracleTraceFuncName ReadNewTokenAndPrivateKeyFiles;
    public static OracleTraceFuncName ConnectedUserName;
    public static OracleTraceFuncName Enqueue;
    public static OracleTraceFuncName SqlnetURI;
    public static OracleTraceFuncName EnqueueArray;
    public static OracleTraceFuncName Dequeue;
    public static OracleTraceFuncName DequeueArray;
    public static OracleTraceFuncName GetOracleBoolean;
    public static OracleTraceFuncName GetDBTokenUsingApiKey;
    public static OracleTraceFuncName GetDBTokenUsingInstancePrincipal;
    public static OracleTraceFuncName GetDBTokenUsingDelegationToken;
    public static OracleTraceFuncName GetDBTokenUsingInteractive;
    public static OracleTraceFuncName GetTenancyNameUsingOciApi;
    public static OracleTraceFuncName GetDBTokenUsingDefault;
    public static OracleTraceFuncName GetDBTokenUsingResourcePrincipal;
    public static OracleTraceFuncName GetTokenAuthEnumFromString;
    public static OracleTraceFuncName PromptForRegion;
    public static OracleTraceFuncName GetSessionToken;
    public static OracleTraceFuncName AcceptRedirect;
    public static OracleTraceFuncName OnContext;
    public static OracleTraceFuncName OpenBrowser;
    public static OracleTraceFuncName WritePrivateKey;
    public static OracleTraceFuncName CreateOciConfigFile;
    public static OracleTraceFuncName OciConfigFile;
    public static OracleTraceFuncName OciProfile;
    public static OracleTraceFuncName TenantId;
    public static OracleTraceFuncName AzureDbAppIdUri;
    public static OracleTraceFuncName ClientId;
    public static OracleTraceFuncName OpenWithNewClientSecret;
    public static OracleTraceFuncName AzureTokenAuthenticationConfiguration;
    public static OracleTraceFuncName OpenAsync;
    public static OracleTraceFuncName OpenAsyncHelper;
    public static OracleTraceFuncName OpenInternal;
    public static OracleTraceFuncName OpenWithNewPasswordAsync;
    public static OracleTraceFuncName OpenWithNewPasswordAsyncHelper;
    public static OracleTraceFuncName OpenWithNewPasswordInternal;
    public static OracleTraceFuncName CancelAsyncOpen;
    public static OracleTraceFuncName ReadAsync;
    public static OracleTraceFuncName IsDBNullAsync;
    public static OracleTraceFuncName NextResultAsync;
    public static OracleTraceFuncName CancelAsyncOperation;
    public static OracleTraceFuncName ExecuteNonQueryAsync;
    public static OracleTraceFuncName ExecuteXmlReaderAsync;
    public static OracleTraceFuncName ExecuteScalarAsync;
    public static OracleTraceFuncName ExecuteReaderAsync;
    public static OracleTraceFuncName ExecuteDbDataReaderAsync;
    public static OracleTraceFuncName CancelAsyncCommandExecution;
    public static OracleTraceFuncName ExecuteReaderAsyncHelper;
    public static OracleTraceFuncName ExecuteNonQueryAsyncHelper;
    public static OracleTraceFuncName ExecuteScalarAsyncHelper;
    public static OracleTraceFuncName ExecuteXmlReaderAsyncHelper;
    public static OracleTraceFuncName ReadAsyncHelper;
    public static OracleTraceFuncName ExecuteNonQueryInternal;
    public static OracleTraceFuncName ExecuteReaderInternal;
    public static OracleTraceFuncName ExecuteScalarInternal;
    public static OracleTraceFuncName ExecuteXmlReaderInternal;
    public static OracleTraceFuncName ReadInternal;
    public static OracleTraceFuncName WriteInternal;
    public static OracleTraceFuncName WriteAsync;
    public static OracleTraceFuncName WriteAsyncHelper;
    public static OracleTraceFuncName CopyToInternal;
    public static OracleTraceFuncName CopyToAsync;
    public static OracleTraceFuncName CopyToAsyncHelper;
    public static OracleTraceFuncName GetValueInternal;
    public static OracleTraceFuncName GetFieldValueAsync;
    public static OracleTraceFuncName GetFieldValueAsyncHelper;
    public static OracleTraceFuncName GenerateKeyPair;
    public static OracleTraceFuncName GetDBToken;
    public static OracleTraceFuncName GetAccessToken;
    public static OracleTraceFuncName TryGetOciAuthenticationParameter;
    public static OracleTraceFuncName PopulateOciTokenParameters;
    public static OracleTraceFuncName PopulateTokenParameters;
    public static OracleTraceFuncName AddParametersRange;
    public static OracleTraceFuncName BeginReplay;
    public static OracleTraceFuncName EndReplay;
    public static OracleTraceFuncName PrepareReplay;
    public static OracleTraceFuncName DisableReplay;
    public static OracleTraceFuncName OracleFailoverMgrImpl;
    public static OracleTraceFuncName SaveNLSSessionState;
    public static OracleTraceFuncName DisableReplayInternal;
    public static OracleTraceFuncName DisableReplayByApplicationCall;
    public static OracleTraceFuncName SetStateSignatureSyncUp;
    public static OracleTraceFuncName CheckStateSignatureSyncUp;
    public static OracleTraceFuncName SessionRestoreAfterReconnect;
    public static OracleTraceFuncName RestoreCommonSessionState;
    public static OracleTraceFuncName RestoreE2EMetrics;
    public static OracleTraceFuncName RestoreAutoCommit;
    public static OracleTraceFuncName InvokeConnectionInitializationCallback;
    public static OracleTraceFuncName PreForAll;
    public static OracleTraceFuncName PostForAll;
    public static OracleTraceFuncName RecordCall;
    public static OracleTraceFuncName DoPostWhileRecording;
    public static OracleTraceFuncName UpdateCallRecord;
    public static OracleTraceFuncName GetConnectionForFailover;
    public static OracleTraceFuncName OnError;
    public static OracleTraceFuncName OnErrorForAll;
    public static OracleTraceFuncName HandleOutage;
    public static OracleTraceFuncName ReplayOneCall;
    public static OracleTraceFuncName ReplayLastCall;
    public static OracleTraceFuncName ReplayAllBeforeLastCall;
    public static OracleTraceFuncName HandleOutageInternal;
    public static OracleTraceFuncName SetAQNotificationDetails;
    public static OracleTraceFuncName GetFailoverConnection;
    public static OracleTraceFuncName AddAsPiggybackBlock;
    public static OracleTraceFuncName AddAsPiggybackBegin;
    public static OracleTraceFuncName AddAsPiggybackEnd;
    public static OracleTraceFuncName Authenticate;
    public static OracleTraceFuncName CheckImplicitRequestBoundary;
    public static OracleTraceFuncName HasNoOpenHandles;
    public static OracleTraceFuncName addInstance;
    public static OracleTraceFuncName BuildCO;
    public static OracleTraceFuncName ConnectViaCO;
    public static OracleTraceFuncName DoConnect;
    public static OracleTraceFuncName ConnectionIdPrefix;
    public static OracleTraceFuncName ReadWebSocketHeader;
    public static OracleTraceFuncName SeekInternal;
    public static OracleTraceFuncName GetIsTemporary;
    public static OracleTraceFuncName EndChunkWriteInternal;
    public static OracleTraceFuncName TransportAliveNoSend;
    public static OracleTraceFuncName GetDataFromNetwork;
    public static OracleTraceFuncName NTS;
    public static OracleTraceFuncName GetUserAuthenticationString;
    public static OracleTraceFuncName GetStringInternal;
    public static OracleTraceFuncName GetOracleBlobInternal;
    public static OracleTraceFuncName GetOracleClobInternal;
    public static OracleTraceFuncName GetOracleValueInternal;
    public static OracleTraceFuncName GetOracleBinaryInternal;
    public static OracleTraceFuncName GetOracleStringInternal;
    public static OracleTraceFuncName GetOracleValuesInternal;
    public static OracleTraceFuncName OracleDatabase;
    public static OracleTraceFuncName Startup;
    public static OracleTraceFuncName Shutdown;
    public static OracleTraceFuncName ProcessInstanceUp;
    public static OracleTraceFuncName ProcessServiceUp;
    public static OracleTraceFuncName SuppressErrorURL;
    public static OracleTraceFuncName SetFetchSize;
    public static OracleTraceFuncName InitializeAC;
    public static OracleTraceFuncName InitializeDBSvcProperties;
    public static OracleTraceFuncName DedicatedThreadFunc;
    public static OracleTraceFuncName CreateConsUsingDedicatedThread;
    public static OracleTraceFuncName CreateIncrPoolSizeCons;
    public static OracleTraceFuncName ConnectWithNoTimeout;
    public static OracleTraceFuncName PopulatePoolThreadFunc;
    public static OracleTraceFuncName SetPositionInternal;
    public static OracleTraceFuncName GetConnInfoFromUrlConfig;
    public static OracleTraceFuncName GetConnectionString;
    public static OracleTraceFuncName GetConnInfoFromUrlProvider;
    public static OracleTraceFuncName GetConnectionInfo;
    public static OracleTraceFuncName GetSecret;
    public static OracleTraceFuncName GetSecretContent;
    public static OracleTraceFuncName CreateSecret;
    public static OracleTraceFuncName ParseUrlOptions;
    public static OracleTraceFuncName RemoveUrlProvider;
    public static OracleTraceFuncName ClearAllConfigProviders;
    public static OracleTraceFuncName ProcessODPParameters;
    public static OracleTraceFuncName ConfigTryWithUpdatedPassword;
    public static OracleTraceFuncName GetAuthenticationOptions;
    public static OracleTraceFuncName GetLengthInternal;
    public static OracleTraceFuncName OpenFileInternal;
    public static OracleTraceFuncName CloseFileInternal;
    public static OracleTraceFuncName GetOracleBFileInternal;
    public static OracleTraceFuncName ReturnToPool;
    public static OracleTraceFuncName ReleaseAllOBs;
    public static OracleTraceFuncName TryOraBufRelease;
    public static OracleTraceFuncName EncryptOraBuf;
    public static OracleTraceFuncName ReturnAll;
    public static OracleTraceFuncName _LdapConfig;
    public static OracleTraceFuncName _LdapConfig1;
    public static OracleTraceFuncName ADorOIDdiscover;
    public static OracleTraceFuncName GetUninitialized;
    public static OracleTraceFuncName UpdatePassword;
    public static OracleTraceFuncName RefreshPassword;
    public static OracleTraceFuncName GetProviderType;
    public static OracleTraceFuncName RegisterForAQNotification;
    public static OracleTraceFuncName SubscriptionRegister;
    public static OracleTraceFuncName SendAQRegistrationInfo;
    public static OracleTraceFuncName SubscriptionUnRegister;
    public static OracleTraceFuncName PopulateConnProperties;
    public static OracleTraceFuncName AcknowledgeTxEventQNotification;
    public static OracleTraceFuncName FireEvent;
    public static OracleTraceFuncName ClearInteractiveTokensForConnPools;
    public static OracleTraceFuncName GetNewAzureToken;
    public static OracleTraceFuncName GetNewOciToken;
    public static OracleTraceFuncName GetChainedTokenCredentials;
    public static OracleTraceFuncName GetServicePrincipalCredentials;
    public static OracleTraceFuncName GetManagedIdentityCredentials;
    public static OracleTraceFuncName GetInteractiveCredentials;
    public static OracleTraceFuncName ResolveAssembly;
    public static OracleTraceFuncName TryGetAssemblyUsingHashValue;
    public static OracleTraceFuncName GetSecretInfo;
    public static OracleTraceFuncName GetSecretFromODPVaultProvider;
    public static OracleTraceFuncName RefreshProviderInfoIfExpired;
    public static OracleTraceFuncName CheckForFileSecurity;
    public static OracleTraceFuncName Resolve;
    public static OracleTraceFuncName LDAPinitialize;
    public static OracleTraceFuncName ValidateServerLogonCapabilityBasedOnALV;
    public static OracleTraceFuncName ValidateVerifierTypeBasedOnALV;
    public static OracleTraceFuncName ProcessConnectionString;
    public static OracleTraceFuncName MetricsCounterDecrement;
    public static OracleTraceFuncName ProcessMessage;
    public static OracleTraceFuncName MetricsCounterIncrement;
    public static OracleTraceFuncName MapVectorColumnAsClob;
    public static OracleTraceFuncName _LDAP;
    public static OracleTraceFuncName VerifyServerCertificateCallback;
    public static OracleTraceFuncName ConfigurationProviders;
    public static OracleTraceFuncName HandleTAF;
    public static OracleTraceFuncName TAFUsePooledConnections;
    public static OracleTraceFuncName InitializeTAF;
    public static OracleTraceFuncName GetOracleRefCursor;
    public static OracleTraceFuncName GetOracleDataReader;
    public static OracleTraceFuncName GetRefCursorString;
    public static OracleTraceFuncName SuppressGetDecimalInvalidCastException;
}
internal enum OracleInternal.Common.OracleTraceLevel : Enum {
    public int value__;
    public static OracleTraceLevel None;
    public static OracleTraceLevel Public;
    public static OracleTraceLevel Private;
    public static OracleTraceLevel Network;
    public static OracleTraceLevel Secure;
    public static OracleTraceLevel Config;
}
internal enum OracleInternal.Common.OracleTraceTag : Enum {
    public long value__;
    public static OracleTraceTag None;
    public static OracleTraceTag Error;
    public static OracleTraceTag Environment;
    public static OracleTraceTag Version;
    public static OracleTraceTag Config;
    public static OracleTraceTag Sqlnet;
    public static OracleTraceTag Tnsnames;
    public static OracleTraceTag Entry;
    public static OracleTraceTag Exit;
    public static OracleTraceTag SQL;
    public static OracleTraceTag CP;
    public static OracleTraceTag MTS;
    public static OracleTraceTag EDM;
    public static OracleTraceTag REFCursor;
    public static OracleTraceTag EF;
    public static OracleTraceTag SelfTuning;
    public static OracleTraceTag TTC;
    public static OracleTraceTag SvcObj;
    public static OracleTraceTag RLB;
    public static OracleTraceTag HA;
    public static OracleTraceTag ONS;
    public static OracleTraceTag BUF;
    public static OracleTraceTag XML;
    public static OracleTraceTag BinXML;
    public static OracleTraceTag Sharding;
    public static OracleTraceTag BulkCopy;
    public static OracleTraceTag UDT;
    public static OracleTraceTag Send;
    public static OracleTraceTag Receive;
    public static OracleTraceTag Prm;
    public static OracleTraceTag OCSSYNC;
    public static OracleTraceTag TTIRPA;
    public static OracleTraceTag AC;
    public static OracleTraceTag URLProv;
}
internal enum OracleInternal.Common.OraFiles : Enum {
    public int value__;
    public static OraFiles TnsNames;
    public static OraFiles SqlNet;
    public static OraFiles Ldap;
}
internal enum OracleInternal.Common.OraRefCursorState : Enum {
    public int value__;
    public static OraRefCursorState Open;
    public static OraRefCursorState Closed;
}
internal enum OracleInternal.Common.OraSqlCS : Enum {
    public byte value__;
    public static OraSqlCS SQLCS_IMPLICIT;
    public static OraSqlCS SQLCS_NCHAR;
    public static OraSqlCS SQLCS_EXPLICIT;
    public static OraSqlCS SQLCS_FLEXIBLE;
    public static OraSqlCS SQLCS_LIT_NULL;
}
internal enum OracleInternal.Common.OraType : Enum {
    public int value__;
    public static OraType ORA_CHARN;
    public static OraType ORA_NUMBER;
    public static OraType ORA_SB1;
    public static OraType ORA_SB2;
    public static OraType ORA_SB4;
    public static OraType ORA_FLOAT;
    public static OraType ORA_NULLSTR;
    public static OraType ORA_VARNUM;
    public static OraType ORA_LONG;
    public static OraType ORA_VARCHAR;
    public static OraType ORA_ROWID;
    public static OraType ORA_DATE;
    public static OraType ORA_VARRAW;
    public static OraType ORA_IBFLOAT;
    public static OraType ORA_IBDOUBLE;
    public static OraType ORA_RAW;
    public static OraType ORA_LONGRAW;
    public static OraType ORA_UINT;
    public static OraType ORA_LONGVARCHAR;
    public static OraType ORA_LONGVARRAW;
    public static OraType ORA_CHAR;
    public static OraType ORA_CHARZ;
    public static OraType ORA_OCIRowid;
    public static OraType ORA_UROWID;
    public static OraType ORA_NDT;
    public static OraType ORA_INTY;
    public static OraType ORA_OCIRef;
    public static OraType ORA_IRef;
    public static OraType ORA_OCICLobLocator;
    public static OraType ORA_OCIBLobLocator;
    public static OraType ORA_OCIBFileLocator;
    public static OraType ORA_OCIString;
    public static OraType ORA_OCIDate;
    public static OraType ORA_RESULTSET;
    public static OraType ORA_TIME_TZ;
    public static OraType ORA_TIMESTAMP;
    public static OraType ORA_TIMESTAMP_TZ;
    public static OraType ORA_INTERVAL_YM;
    public static OraType ORA_INTERVAL_DS;
    public static OraType ORA_TIMESTAMP_LTZ;
    public static OraType ORA_OCIXMLType;
    public static OraType ORA_BFLOAT;
    public static OraType ORA_BDOUBLE;
    public static OraType ORA_BOOLEAN;
    public static OraType ORA_OCIJSON;
    public static OraType ORA_VECTOR;
    public static OraType ORA_NCO;
    public static OraType ORA_INTERVAL_YM_DTY;
    public static OraType ORA_INTERVAL_DS_DTY;
    public static OraType ORA_TIMESTAMP_DTY;
    public static OraType ORA_TIMESTAMP_TZ_DTY;
    public static OraType ORA_TIMESTAMP_LTZ_DTY;
    public static OraType ORA_REFCURSOR;
}
internal enum OracleInternal.Common.OSAuthent : Enum {
    public int value__;
    public static OSAuthent Neither;
    public static OSAuthent ClientUser;
    public static OSAuthent ProxyUser;
}
internal enum OracleInternal.Common.ParseMode : Enum {
    public int value__;
    public static ParseMode None;
    public static ParseMode FirstParse;
    public static ParseMode ReParseTnsNames;
}
internal class OracleInternal.Common.Pooler`2 : object {
    private object m_sync;
    private ulong m_lastUsedCount;
    private PoolerItemOwnership m_ownership;
    private SortedDictionary`2<keyType, PoolMember`1<valType>> m_cache;
    public int m_maxCacheSize;
    public int m_maxSubCacheSize;
    public Pooler`2(int maxCacheSize, int maxSubCacheSize, PoolerItemOwnership ownership);
    internal bool Remove(keyType key);
    internal PoolMember`1<valType> RemoveLRU();
    public virtual valType Put(keyType key, valType val);
    public valType Get(keyType key);
    public bool ContainsKey(keyType key);
}
internal enum OracleInternal.Common.PoolerItemOwnership : Enum {
    public int value__;
    public static PoolerItemOwnership Exclusive;
    public static PoolerItemOwnership Shared;
}
internal class OracleInternal.Common.PoolMember`1 : object {
    public ulong m_LastUsedTime;
    public List`1<valType> m_list;
    public PoolMember`1(valType val, int maxSubCacheSize, ulong lut);
}
internal enum OracleInternal.Common.PromotableTransaction : Enum {
    public int value__;
    public static PromotableTransaction Promotable;
    public static PromotableTransaction Local;
}
internal class OracleInternal.Common.ProviderConfig : ConfigBaseClass {
    private static string ORA_DEBUG_JDWP;
    private static string TNS_ADMIN;
    private static string LDAP_ADMIN;
    private static string ORACLE_HOME;
    private static string NETWORK_ADMIN;
    private static string LDAP_ADMIN_DIR;
    internal static string LDAPORA;
    internal static string TNSNAMESORA;
    internal static string SQLNETORA;
    internal static string AssyVer;
    internal static bool m_bTraceLevelPublic;
    internal static bool m_bTraceLevelPrivate;
    internal static bool m_bTraceLevelNetwork;
    internal static bool m_bTraceLevelConfig;
    internal static bool m_bTraceLevelSecure;
    internal static bool m_bTraceLevelPrivate_NoTrace;
    private static string s_appConfigFilePath;
    internal static Hashtable ConfigDataSourcesMap { get; }
    internal static string OracleHome { get; }
    private static ProviderConfig();
    internal static Hashtable get_ConfigDataSourcesMap();
    internal static void OnAppConfigFileChanged();
    private static void ReadTraceSettingsFromConfigVersionNode(XElement versionNode, String& traceFilePath, Int32& traceLevel, Boolean& traceOption, Int64& traceFileMaxSize);
    private static Version GetExecutingAssemblyVersion();
    internal static void ReParseDataSourceSection();
    internal static void RefreshDataSources();
    internal static void NewOraFileParams(OraFiles file, string filePath, Hashtable theParams, bool ObCfg);
    internal static string getFilePath(OraFiles file, string dir, string fileName);
    internal static string NewOraFileLoc(OraFiles file);
    internal static string FindFile(string filePath, string fileName);
    internal static string get_OracleHome();
    internal void ParseConfigParamsForODT(XmlNode baseNode, Hashtable& storedProcInformation);
    internal static void ValidateBaseDocument(XmlDocument doc);
    private static void ValidationCallBack(object sender, ValidationEventArgs args);
    internal static string GetPropertyFromONSConfig(string ONSConfigFile, string onsConfigProperty);
    private static void AddInfoForRefCursor(string storedProcKey, XmlNode refCursorNode, Hashtable& storedProcInformation);
    private static void AddBindInfoForRefCursor(string storedProcKey, XmlNode bindInfoNode, RefCursorInfo& refCursorInfo, bool isInfoBasedOnName, Hashtable& storedProcInformation);
    private static void AddMetadataForRefCursor(string storedProcKey, XmlNode metadataNode, RefCursorInfo& refCursorInfo, bool isInfoBasedOnName, Hashtable& storedProcInformation);
    private static void ThrowExceptionForRefCursor(string messageForTrace, string messageForException);
    internal static string GetONSConfiguration(string databaseName);
    internal static void TraceConfigAndEnvParams();
    private static void TraceImplicitRefCursorParams(Hashtable& storedProcInformation, bool isODTCall);
    internal virtual void setudtmapping(Hashtable& s_mapUdtNameToMappingObj);
}
internal abstract class OracleInternal.Common.ProviderUrl : object {
    protected static string PROVIDER_SEPARATOR;
    protected static string ODP_AZCONFIG_LABELNAME;
    protected static string ODP_OCICONFIG_LABELNAME;
    protected static string ODP_AZVAULTCONFIG_LABELNAME;
    protected static string ODP_OCIVAULTCONFIG_LABELNAME;
    protected static string ODP_FILECONFIG_LABELNAME;
    protected static string ODP_AZCONFIG_LABEL;
    protected static string ODP_OCICONFIG_LABEL;
    protected static string ODP_FILECONFIG_LABEL;
    protected static string ODP_AZVAULT_LABELNAME;
    protected static string ODP_OCIVAULT_LABELNAME;
    internal static string ODP_AZVAULT_LABEL;
    internal static string ODP_OCIVAULT_LABEL;
    protected static char NAME_SEPARATOR;
    protected static string NAME_SEPARATOR_STR;
    internal static char OPTIONS_SEPARATOR;
    internal static string IN_OPTIONS_SEPARATOR;
    internal static char URL_SEGMENT_SEPARATOR;
    internal static string COMMON_AUTH_PARAM;
    internal static string COMMON_KEY_PARAM;
    internal static string SECURE_URL_KEY;
    internal static string PROVIDER_REQUEST_TYPE;
    internal static string PROVIDER_CONN_FILTERING;
    protected int m_userProvidedUrlHashCode;
    protected string m_userProvidedUrlSource;
    protected OracleOpaqueString m_opaqueUrlOptions;
    protected string m_secureConnStr;
    protected string m_urlConnStrID;
    protected UrlProviderType m_providerType;
    protected Dictionary`2<string, object> m_authParameters;
    protected UrlProviderRequestType m_requestType;
    protected bool m_bFiltering;
    protected string m_connKey;
    internal string UserProvidedUrlStr { get; }
    internal UrlProviderType UrlProviderType { get; }
    internal UrlProviderRequestType RequestType { get; }
    internal bool RemoteConfigurationFiltering { get; }
    internal string UrlProviderName { get; }
    internal int UrlProviderHashKey { get; }
    internal string ConnectionKey { get; }
    internal Dictionary`2<string, object> AuthParameters { get; }
    internal bool IsJsonConfigType { get; }
    internal string SecureUrlConnStr { get; }
    internal string UrlProviderUniqueID { get; }
    internal ProviderUrl(string userProvidedConnStr, string userProvidedUrlSource, OracleOpaqueString opaqueUrlOptions, string connKey, Dictionary`2<string, object> authParameters, UrlProviderRequestType requestType, bool bFiltering);
    internal static UrlProviderType GetUrlProviderType(string userProvidedUrl);
    internal static UrlProviderType GetUrlProviderType(Char[] userProvidedUrl);
    private static bool charsStartWith(Char[] chars, string label);
    internal static int GetCachedHashKey(string userProvidedConnStr, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering);
    internal static string RemoveProviderPrefix(UrlProviderType urlProviderType, string url);
    internal static bool ExtractUrlInfo(UrlProviderType urlProviderType, string userProvidedUrl, String& urlSource, String& urlOptions, String& userProvidedUrlSource, OracleOpaqueString& opaqueUrlOptions);
    internal static ProviderUrl ParseUrl(UrlProviderType providerType, string userProvidedUrl, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering, string connTnsAdmin);
    internal static void ParseUrlOptions(string urlSource, string optionsStr, String[] keyParameterList, String[] authParameterList, String[] securityAuthParameterList, String[] acceptableParameterList, Dictionary`2& sourceParameterValues, Dictionary`2& authParameterValues);
    internal static bool TryCreateUri(string urlString, Uri& uri);
    internal static bool TryCreateUri(string urlString, Uri& uri, string scheme, int port);
    internal string get_UserProvidedUrlStr();
    internal UrlProviderType get_UrlProviderType();
    internal UrlProviderRequestType get_RequestType();
    internal bool get_RemoteConfigurationFiltering();
    internal string get_UrlProviderName();
    internal int get_UrlProviderHashKey();
    internal string get_ConnectionKey();
    internal Dictionary`2<string, object> get_AuthParameters();
    internal bool get_IsJsonConfigType();
    internal virtual string get_SecureUrlConnStr();
    internal string get_UrlProviderUniqueID();
    protected abstract virtual string GetSecureUrlStr();
    protected string GetSecureAuthStr(String[] secureAuthParamList, bool bAddedOption);
    protected bool CompareAuthParameters(String[] authParamList, String[] secureAuthParamList, Dictionary`2<string, object> otherAuthParameters);
    protected abstract virtual bool CompareUrl(ProviderUrl otherUrl);
    internal bool Compare(object other);
}
internal class OracleInternal.Common.RefCursorInfo : object {
    internal string name;
    internal int position;
    internal ParameterDirection mode;
    internal bool isPrimaryKeyPresent;
    internal DataTable columnInfo;
    internal Dictionary`2<int, HashSet`1<string>> seenInConfigByRow;
    internal int rowIndex;
    internal void FillMissingValuesFromMetadata(DataRow srcDataRow, DataRow targetDataRow, HashSet`1<string> seenInConfig);
}
internal class OracleInternal.Common.RepConversion : object {
    internal static byte nibbleToHex(byte nibble);
    internal static void bArray2nibbles(Byte[] array, Byte[] nibbles);
    public static Byte[] ToBinArray(string hexStr);
    internal static int LeftShiftFirstNibble(byte val);
    internal static int LeftShiftSecondNibble(byte val);
    internal static int LeftShiftThirdNibble(byte val);
    internal static int LeftShiftFourthNibble(byte val);
    internal static byte RightShiftFirstNibble(int val);
    internal static byte RightShiftSecondNibble(int val);
    internal static byte RightShiftThirdNibble(int val);
    internal static byte RightShiftFourthNibble(int val);
    internal static ushort GetRegHour(byte val);
    internal static byte GetRegMin(byte val);
}
internal class OracleInternal.Common.RNGCryptoRandom : object {
    private RNGCryptoServiceProvider _rng;
    private Byte[] _uint32Buffer;
    public int Next();
    public int Next(int maxValue);
    public int Next(int minValue, int maxValue);
    public void NextBytes(Byte[] buffer);
}
internal enum OracleInternal.Common.SecretProviderType : Enum {
    public int value__;
    public static SecretProviderType Null;
    public static SecretProviderType Azure;
    public static SecretProviderType OCI;
    public static SecretProviderType Base64;
}
internal abstract class OracleInternal.Common.SecretUrl : ProviderUrl {
    internal string SecretName { get; }
    internal SecretUrl(string userProvidedConnStr, string userProvidedUrlSource, OracleOpaqueString opaqueUrlOptions, string connKey, Dictionary`2<string, object> authParameters, UrlProviderRequestType requestType, bool bFiltering);
    internal abstract virtual string get_SecretName();
}
internal enum OracleInternal.Common.SessionType : Enum {
    public int value__;
    public static SessionType Non_Proxy;
    public static SessionType Single_Session_Proxy;
    public static SessionType Two_Session_Proxy;
}
internal class OracleInternal.Common.SQLInfo : object {
    internal SqlStatementType m_SQLStatementType;
    internal Byte[] m_SQLcommandTextByteStream;
    internal bool m_SQLhasReturningClause;
}
internal class OracleInternal.Common.SQLLocalParsePrimaryKeyInfo : object {
    internal string m_tableName;
    internal string m_schemaName;
    internal bool bPkPresent;
    internal bool bRowidPresent;
    internal ColumnLocalParsePrimaryKeyInfo[] m_columnMetaInfo;
    internal bool bPkFetched;
    internal bool bStmtParsed;
    internal long m_lastUsedCount;
    internal bool bIsPooled;
    internal static SQLLocalParsePrimaryKeyInfo Null;
    internal SQLLocalParsePrimaryKeyInfo(int count);
    private static SQLLocalParsePrimaryKeyInfo();
    internal void CopyPrimaryKeyInfoFrom(SQLLocalParsePrimaryKeyInfo destInfo);
}
internal class OracleInternal.Common.SQLLocalParsePrimaryKeyInfoPool : object {
    private object m_sync;
    private long m_lastUsedCount;
    private Dictionary`2<string, SQLLocalParsePrimaryKeyInfo> m_cache;
    public int m_maxCacheSize;
    public SQLLocalParsePrimaryKeyInfoPool(int maxCacheSize);
    private void RemoveLRU();
    public void Put(string cmdText, SQLLocalParsePrimaryKeyInfo metaInfo);
    public SQLLocalParsePrimaryKeyInfo Get(string cmdText);
}
internal class OracleInternal.Common.SQLMetaData : object {
    internal static string IDENTIFIER_MAXSIZE;
    internal static string OBJ_TYPE_MAXSIZE;
    internal short m_noOfColumns;
    internal int m_maxRowSize;
    internal int m_numOfLOBColumns;
    internal int m_numOfLONGColumns;
    internal int m_numOfBFileColumns;
    internal int m_numOfJSONColumns;
    internal int m_numOfVectorColumns;
    internal int m_numOfCLOBCols;
    internal int m_numOfBLOBCols;
    internal Byte[] m_describeInfoHash;
    internal ColumnDescribeInfo[] m_columnDescribeInfo;
    internal Type[] m_fieldTypes;
    internal SQLLocalParsePrimaryKeyInfo m_sqlMetaInfo;
    internal bool bGotDescribeInfoFromDB;
    internal bool bPkFetched;
    internal bool bStmtParsed;
    internal bool bStmtParseFailed;
    internal object m_syncPK;
    internal object m_syncLP;
    internal string pCommandText;
    internal bool m_bHasLOBOrLongColumn;
    internal bool m_bHasJSONColumn;
    internal bool m_bHasVectorColumn;
    internal bool m_bHasUDTColumn;
    internal bool m_bHasLOBOrLongColumnChecked;
    internal bool m_bIsInitialLongFetchSizeInChars;
    internal bool m_bHasBFILEColumn;
    internal bool m_bHasBFILEColumnChecked;
    internal static string pSqlBlock1;
    internal static string pSqlBlock2;
    internal static string pSqlBlock3a;
    internal static string pSqlBlock3b;
    internal static string pSqlBlock3c;
    internal static string pSqlBlock4;
    internal static string pSqlBlock4_01;
    internal static string pSqlBlock4_updated;
    internal static string pSqlBlock5;
    internal static string pSqlBlock6;
    internal static string pSqlBlock7;
    internal static string pSqlBlock8;
    internal static string pSqlBlock9;
    internal static string pSqlBlock10;
    internal static string pSqlBlock11;
    internal static string pSqlBlock12;
    internal static string pSqlBlock13;
    internal static string pSqlBlock14;
    internal static string pSqlBlock18;
    internal static string pSqlBlock15;
    internal static string pSqlBlock16;
    internal static string pSqlBlock17;
    internal bool IsInitialLongFetchSizeInChars { get; }
    internal bool HasLOBColumns { get; }
    internal bool HasBFILEColumn { get; }
    internal bool HasLOBOrLongColumn { get; }
    internal bool HasJSONColumn { get; }
    internal bool HasVectorColumn { get; }
    internal bool HasUDTColumn { get; }
    private static SQLMetaData();
    internal bool get_IsInitialLongFetchSizeInChars();
    internal bool get_HasLOBColumns();
    internal bool get_HasBFILEColumn();
    internal bool get_HasLOBOrLongColumn();
    internal bool get_HasJSONColumn();
    internal bool get_HasVectorColumn();
    internal bool get_HasUDTColumn();
    internal static bool GetPrimaryKey(OracleConnection conn, SQLMetaData sqlMetaData, int hiddenColumnCount, bool bSchemaTable);
    internal UDTNamedType GetUDTType(OracleConnection conn, int columnIndex);
    internal void CalculateRowSize();
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Common.SqlNetOraConfig : object {
    internal static string ALLOWED_LOGON_VERSION;
    internal static string ALLOWED_LOGON_VERSION_CLIENT;
    private static string SSL_CLIENT_AUTHENTICATION;
    internal static string DEFAULT_SDU_SIZE;
    internal static string SSL_SERVER_DN_MATCH;
    internal static string SSL_VERSION;
    internal static string SSL_Certificate_Thumbprint;
    private static string SSL_CIPHER_SUITES;
    internal static string SQLNET_AUTHENTICATION_SERVICES;
    internal static string SQLNET_ENCRYPTION_TYPES_CLIENT;
    internal static string SQLNET_ENCRYPTION_CLIENT;
    internal static string SQLNET_CRYPTO_CHECKSUM_TYPES_CLIENT;
    internal static string SQLNET_CRYPTO_CHECKSUM_CLIENT;
    internal static string SQLNET_ALLOW_WEAK_CRYPTO;
    internal static string NAMES_DIRECTORY_PATH;
    internal static string WALLET_LOCATION;
    internal static string DISABLE_OOB;
    internal static string NODELAY;
    internal static string SBS;
    internal static string RBS;
    internal static string NAMES_DEFAULT_DOMAIN;
    private static string TRACE_LEVEL_CLIENT;
    private static string TRACE_UNIQUE_CLIENT;
    internal static string TCP_NODELAY;
    internal static string TCP_CONNECT_TIMEOUT;
    internal static string DEFAULT_SERVICE_IS_HOST;
    internal static string NAMES_LDAP_AUTHENTICATE_BIND;
    internal static string NAMES_LDAP_AUTHENTICATE_BIND_METHOD;
    internal static string NAMES_LDAP_CONN_TIMEOUT;
    internal static string SQLNET_KERBEROS5_CONF;
    internal static string SQLNET_KERBEROS5_CC_NAME;
    internal static string SQLNET_WALLET_OVERRIDE;
    internal static string SQLNET_EXPIRE_TIME;
    internal static string LDAPS_SIMPLE_AUTH;
    internal static string ORACLE_LDAP_CLIENT_DN;
    internal static string ORACLE_LDAP_CLIENT_PASSW;
    internal static string SQLNET_URI;
    internal static string SQLNET_CLOUD_USER;
    private static char chSingleQuote;
    private static char chDoubleQuote;
    private Char[] trimChars;
    internal static string CONFIGURATION_PROVIDERS;
    internal static string TOKEN_AUTH;
    internal static string TOKEN_LOCATION;
    internal string m_tokenAuth;
    internal string m_tokenLocation;
    internal bool m_tokenAuth_accessed;
    internal bool m_tokenLocation_accessed;
    internal static string PASSW_AUTH;
    internal static string OCI_IAM_URL;
    internal static string OCI_TENANCY;
    internal static string OCI_COMPARTMENT;
    internal static string OCI_DATABASE;
    internal string m_passwAuth;
    internal string m_ociIamUrl;
    internal string m_ociTenancy;
    internal string m_ociCompartment;
    internal string m_ociDatabase;
    internal bool m_passwAuth_accessed;
    internal bool m_ociIamUrl_accessed;
    internal bool m_ociTenancy_accessed;
    internal bool m_ociCompartment_accessed;
    internal bool m_ociDatabase_accessed;
    internal static string OCI_CONFIG_FILE;
    internal static string OCI_PROFILE;
    internal string m_ociConfigFile;
    internal string m_ociProfile;
    internal bool m_ociConfigFile_accessed;
    internal bool m_ociProfile_accessed;
    internal static string TENANT_ID;
    internal static string AZURE_DB_APP_ID_URI;
    internal static string CLIENT_ID;
    internal string m_tenantId;
    internal string m_azureDbAppIdUri;
    internal string m_clientId;
    internal bool m_tenantId_accessed;
    internal bool m_azureDbAppIdUri_accessed;
    internal bool m_clientId_accessed;
    internal static string CONNECTION_ID;
    internal static string CONNECTION_ID_PREFIX;
    internal int m_default_sdu_size;
    internal bool m_default_sdu_size_accessed;
    private string m_allowed_logon_version;
    private bool m_allowed_logon_version_accessed;
    private string m_allowed_logon_version_client;
    private bool m_allowed_logon_version_client_accessed;
    private string m_ExpireTime;
    private bool m_ExpireTime_accessed;
    private bool m_bDisableOOB;
    private bool m_bDisableOOB_accessed;
    private bool m_bNoDelay;
    private bool m_bNoDelay_accessed;
    private int m_SBS;
    private bool m_SBS_accessed;
    private int m_RBS;
    private bool m_RBS_accessed;
    private string m_sslVersion;
    private bool m_bSSLVersion_accessed;
    private string m_SSLCertificateThumbprint;
    private bool m_bSSLCertificateThumbprint_accessed;
    private bool m_bSSLServerDNMatch;
    private bool m_bSSLServerDNMatch_accessed;
    private bool m_bSSLClientAuthentication;
    private bool m_bSSLClientAuthentication_accessed;
    private bool m_bAllowWeakCrypto;
    private bool m_bAllowWeakCrypto_accessed;
    private bool m_bTCPNoDelay;
    private bool m_bTCPNoDelay_accessed;
    private string m_TCPCTimeOut;
    private bool m_TCPCTimeOut_accessed;
    private bool m_DefaultServiceIsHost;
    private bool m_DefaultServiceIsHost_accessed;
    private static String[] m_sslCipherSuites;
    private bool m_bSSLCipherSuites_accessed;
    private String[] m_configurationProviders;
    internal bool m_bConfigurationProviders_accessed;
    private String[] m_sqlNetAuthenticationServices;
    internal bool m_bSqlNetAuthenticationServices_accessed;
    private String[] m_sqlNetEncryptionTypesClient;
    internal bool m_bSqlNetEncryptionTypesClient_accessed;
    private string m_sqlNetEncryptionClient;
    private bool m_bSqlNetEncryptionClient_accessed;
    private String[] m_sqlNetCryptoChecksumTypesClient;
    internal bool m_bSqlNetCryptoChecksumTypesClient_accessed;
    private string m_sqlNetCryptoChecksumClient;
    private bool m_bSqlNetCryptoChecksumClient_accessed;
    private string m_namesDefaultDomain;
    private bool m_bNamesDefaultDomain_accessed;
    private static String[] m_namesDirectoryPath_def;
    private String[] m_namesDirectoryPath;
    internal bool m_bNamesDirectoryPath_accessed;
    internal string m_strAllowedLogonVersionServer;
    internal bool m_bAllowedLogonVersionServer_accessed;
    internal string m_strAllowedLogonVersionClient;
    internal bool m_bAllowedLogonVersionClient_accessed;
    internal bool m_bWalletOverride;
    internal bool m_bWalletOverride_accessed;
    internal string m_walletLocation;
    internal bool m_walletLocation_accessed;
    internal string m_traceLevelClient;
    internal bool m_bTraceLevelClient_accessed;
    internal bool m_bTraceUniqueClient;
    internal bool m_bTraceUniqueClient_accessed;
    private static bool m_bNamesLdapAuthenticateBind;
    private static bool m_bNamesLdapAuthenticateBind_accessed;
    private string m_bNamesLdapAuthenticateBindMethod;
    private bool m_bNamesLdapAuthenticateBindMethod_accessed;
    private static int m_LDAPCTimeOut;
    private static bool m_LDAPCTimeOut_accessed;
    private string m_traceDirectoryClient;
    internal string m_sqlNetURI;
    internal bool m_sqlNetURI_accessed;
    internal string m_sqlNetCloudUser;
    internal bool m_sqlNetCloudUser_accessed;
    internal string m_connectionIdPrefix;
    internal bool m_connectionIdPrefix_accessed;
    internal Hashtable m_ConfigHT;
    internal string Item { get; }
    internal string TokenAuthentication { get; internal set; }
    internal string TokenLocation { get; internal set; }
    internal string PasswAuthentication { get; internal set; }
    internal string OciIamUrl { get; internal set; }
    internal string OciTenancy { get; internal set; }
    internal string OciCompartment { get; internal set; }
    internal string OciDatabase { get; internal set; }
    internal string OciConfigurationFile { get; internal set; }
    internal string OciProfile { get; internal set; }
    internal string TenantId { get; internal set; }
    internal string AzureDbAppIdUri { get; internal set; }
    internal string ClientId { get; internal set; }
    internal bool SSLClientAuthentication { get; internal set; }
    internal bool SSLServerDNMatch { get; internal set; }
    internal string SSLVersion { get; internal set; }
    internal string SSLCertThumbprint { get; internal set; }
    internal String[] SSLCipherSuites { get; }
    internal String[] ConfigurationProviders { get; }
    internal String[] SqlNetAuthenticationServices { get; }
    internal String[] SqlNetEncryptionTypesClient { get; }
    internal string SqlNetEncryptionClient { get; internal set; }
    internal String[] SqlNetCryptoChecksumTypesClient { get; }
    internal string SqlNetCryptoChecksumClient { get; internal set; }
    internal bool SqlnetAllowWeakCrypto { get; internal set; }
    internal String[] NamesDirectoryPath { get; }
    internal string WalletLocation { get; }
    internal bool DisableOOB { get; internal set; }
    internal bool NoDelay { get; internal set; }
    internal string AllowedLogonVersion { get; internal set; }
    internal string AllowedLogonVersionClient { get; internal set; }
    internal string NamesDefaultDomain { get; internal set; }
    internal string TraceLevelClient { get; internal set; }
    internal bool TraceUniqueClient { get; internal set; }
    internal bool TCPNoDelay { get; internal set; }
    internal bool WalletOverride { get; internal set; }
    internal int DefaultSDUSize { get; internal set; }
    internal int SendBufSize { get; internal set; }
    internal int RecvBufSize { get; internal set; }
    internal string TCPCTimeOut { get; internal set; }
    internal bool HostnameDefaultServiceIsHost { get; internal set; }
    internal bool NamesLdapAuthenticateBind { get; internal set; }
    internal string NamesLdapAuthenticateBindMethod { get; internal set; }
    internal int LDAPCTimeout { get; internal set; }
    internal string ExpireTime { get; internal set; }
    internal string SQLNetURI { get; }
    internal string SQLNetCloudUser { get; }
    internal string ConnectionIdPrefix { get; internal set; }
    internal SqlNetOraConfig(Hashtable ConfigHT);
    private static SqlNetOraConfig();
    internal static void getIntValue(string Name, Int32& Value, Hashtable HT, Boolean& accessed);
    internal static void getStrValue(string Name, String& Value, Hashtable HT, Boolean& accessed);
    internal static void getBoolValue(string Name, Boolean& Value, Hashtable HT, Boolean& accessed);
    internal string get_Item(string key);
    internal string get_TokenAuthentication();
    internal void set_TokenAuthentication(string value);
    internal string get_TokenLocation();
    internal void set_TokenLocation(string value);
    internal string get_PasswAuthentication();
    internal void set_PasswAuthentication(string value);
    internal string get_OciIamUrl();
    internal void set_OciIamUrl(string value);
    internal string get_OciTenancy();
    internal void set_OciTenancy(string value);
    internal string get_OciCompartment();
    internal void set_OciCompartment(string value);
    internal string get_OciDatabase();
    internal void set_OciDatabase(string value);
    internal string get_OciConfigurationFile();
    internal void set_OciConfigurationFile(string value);
    internal string get_OciProfile();
    internal void set_OciProfile(string value);
    internal string get_TenantId();
    internal void set_TenantId(string value);
    internal string get_AzureDbAppIdUri();
    internal void set_AzureDbAppIdUri(string value);
    internal string get_ClientId();
    internal void set_ClientId(string value);
    internal bool get_SSLClientAuthentication();
    internal void set_SSLClientAuthentication(bool value);
    internal bool get_SSLServerDNMatch();
    internal void set_SSLServerDNMatch(bool value);
    internal string get_SSLVersion();
    internal void set_SSLVersion(string value);
    internal string get_SSLCertThumbprint();
    internal void set_SSLCertThumbprint(string value);
    internal String[] get_SSLCipherSuites();
    internal String[] get_ConfigurationProviders();
    internal static String[] MultipleValueSplit(string value);
    internal String[] get_SqlNetAuthenticationServices();
    internal String[] get_SqlNetEncryptionTypesClient();
    internal string get_SqlNetEncryptionClient();
    internal void set_SqlNetEncryptionClient(string value);
    internal String[] get_SqlNetCryptoChecksumTypesClient();
    internal string get_SqlNetCryptoChecksumClient();
    internal void set_SqlNetCryptoChecksumClient(string value);
    internal bool get_SqlnetAllowWeakCrypto();
    internal void set_SqlnetAllowWeakCrypto(bool value);
    internal String[] get_NamesDirectoryPath();
    internal static String[] splitValues(string tmpValue);
    internal string get_WalletLocation();
    internal bool get_DisableOOB();
    internal void set_DisableOOB(bool value);
    internal bool get_NoDelay();
    internal void set_NoDelay(bool value);
    internal string get_AllowedLogonVersion();
    internal void set_AllowedLogonVersion(string value);
    internal string get_AllowedLogonVersionClient();
    internal void set_AllowedLogonVersionClient(string value);
    internal string get_NamesDefaultDomain();
    internal void set_NamesDefaultDomain(string value);
    internal string get_TraceLevelClient();
    internal void set_TraceLevelClient(string value);
    internal bool get_TraceUniqueClient();
    internal void set_TraceUniqueClient(bool value);
    internal bool get_TCPNoDelay();
    internal void set_TCPNoDelay(bool value);
    internal bool get_WalletOverride();
    internal void set_WalletOverride(bool value);
    internal int get_DefaultSDUSize();
    internal void set_DefaultSDUSize(int value);
    internal int get_SendBufSize();
    internal void set_SendBufSize(int value);
    internal int get_RecvBufSize();
    internal void set_RecvBufSize(int value);
    internal string get_TCPCTimeOut();
    internal void set_TCPCTimeOut(string value);
    internal bool get_HostnameDefaultServiceIsHost();
    internal void set_HostnameDefaultServiceIsHost(bool value);
    internal bool get_NamesLdapAuthenticateBind();
    internal void set_NamesLdapAuthenticateBind(bool value);
    internal string get_NamesLdapAuthenticateBindMethod();
    internal void set_NamesLdapAuthenticateBindMethod(string value);
    internal int get_LDAPCTimeout();
    internal void set_LDAPCTimeout(int value);
    internal string get_ExpireTime();
    internal void set_ExpireTime(string value);
    internal string get_SQLNetURI();
    internal string get_SQLNetCloudUser();
    internal string get_ConnectionIdPrefix();
    internal void set_ConnectionIdPrefix(string value);
    internal static Hashtable ParseWalletLocation(string wallet_location);
    internal static void GetWalletLoc(ConnectionOption conOption, SqlNetOraConfig SNOConfig, String& Dir, Hashtable& HT);
    internal static bool ParamValueIsTrue(string paramValue);
    internal static string HandlePathSeparators(string WalletDirectory);
    internal void ResetAccessFlags();
}
internal class OracleInternal.Common.SQLParseInfoPool : object {
    private object m_sync;
    private long m_LastUsedCount;
    private Dictionary`2<string, SQLParseInfo> m_cache;
    internal int m_maxCacheSize;
    internal SQLParseInfoPool(int maxCacheSize);
    private void RemoveLRU();
    internal void Put(string cmdText, string cmdTextWithRowId, bool hadRowId);
    internal string Get(string cmdText, Boolean& hadRowId);
}
internal enum OracleInternal.Common.SqlStatementType : Enum {
    public int value__;
    public static SqlStatementType SELECT;
    public static SqlStatementType DML;
    public static SqlStatementType PLSQL;
    public static SqlStatementType BULKCOPY;
    public static SqlStatementType OTHERS;
}
internal enum OracleInternal.Common.SQLT : Enum {
    public int value__;
    public static SQLT CHR;
    public static SQLT NUM;
    public static SQLT INT;
    public static SQLT FLT;
    public static SQLT STR;
    public static SQLT VNU;
    public static SQLT PDN;
    public static SQLT LNG;
    public static SQLT VCS;
    public static SQLT NON;
    public static SQLT RID;
    public static SQLT DAT;
    public static SQLT VBI;
    public static SQLT BFLT;
    public static SQLT BDBL;
    public static SQLT BIN;
    public static SQLT LBI;
    public static SQLT UIN;
    public static SQLT SLS;
    public static SQLT LVC;
    public static SQLT LVB;
    public static SQLT AFC;
    public static SQLT AVC;
    public static SQLT IBFL;
    public static SQLT IBDL;
    public static SQLT CUR;
    public static SQLT RDD;
    public static SQLT LAB;
    public static SQLT OSL;
    public static SQLT BOL;
    public static SQLT NTY;
    public static SQLT INTY;
    public static SQLT REF;
    public static SQLT IREF;
    public static SQLT CLOB;
    public static SQLT BLOB;
    public static SQLT BFILEE;
    public static SQLT CFILEE;
    public static SQLT RSET;
    public static SQLT JSON;
    public static SQLT VECTOR;
    public static SQLT NCO;
    public static SQLT VST;
    public static SQLT ODT;
    public static SQLT DTYSTAMP;
    public static SQLT DTYSTZ;
    public static SQLT DTYIYM;
    public static SQLT DTYIDS;
    public static SQLT DATE;
    public static SQLT TIME;
    public static SQLT TIME_TZ;
    public static SQLT TIMESTAMP;
    public static SQLT TIMESTAMP_TZ;
    public static SQLT INTERVAL_YM;
    public static SQLT INTERVAL_DS;
    public static SQLT URID;
    public static SQLT DTYSLTZ;
    public static SQLT TIMESTAMP_LTZ;
    public static SQLT PNTY;
    public static SQLT FILE;
    public static SQLT CFILE;
    public static SQLT BFILE;
}
internal static class OracleInternal.Common.SSOConstants : object {
    internal static int TOKEN_AUTH_ATTRIBUTE_ID;
    internal static int DB_APP_ID_URI_ATTRIBUTE_ID;
    internal static int PASSW_AUTH_ATTRIBUTE_ID;
    internal static int CLIENT_ID_ATTRIBUTE_ID;
    internal static int TENANT_ID_ATTRIBUTE_ID;
    internal static int CLIENT_SECRET_ATTRIBUTE_ID;
    internal static int CLIENT_CERTIFICATE_ATTRIBUTE_ID;
    internal static int REDIRECT_URI_ATTRIBUTE_ID;
    internal static int USERNAME_ATTRIBUTE_ID;
    internal static int PASSW_ATTRIBUTE_ID;
    internal static int TIMEOUT_ATTRIBUTE_ID;
    internal static int NEW_CLIENT_SECRET_ATTRIBUTE_ID;
    internal static int CONFIG_FILE_ATTRIBUTE_ID;
    internal static int PROFILE_ATTRIBUTE_ID;
    internal static int COMPARTMENT_ATTRIBUTE_ID;
    internal static int DATABASE_ATTRIBUTE_ID;
}
internal class OracleInternal.Common.StatementCache : object {
    private object m_sync;
    private ulong m_lastUsedCount;
    private Dictionary`2<string, CachedStatement> m_cache;
    internal int m_maxCacheSize;
    internal int Count { get; }
    internal StatementCache(int maxCacheSize);
    internal int get_Count();
    internal List`1<long> Purge(int targetSize);
    internal void ClearAllCursorIds();
    internal CachedStatement RemoveLRU();
    internal CachedStatement Put(string cmdText, CachedStatement cachedStmnt);
    internal void Get(string cmdText, CachedStatement& cachedStmnt, SQLMetaData& metadata, SQLInfo& sqlInfo);
    internal bool PeekForSQLMetaInfo(string cmdText, SQLInfo& info, SQLMetaData& data);
}
internal class OracleInternal.Common.StoredProcedureInfo : object {
    internal ArrayList refCursors;
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Common.SyncDictionary`2 : object {
    private object m_sync;
    private Dictionary`2<K, V> m_hashtable;
    internal int Count { get; }
    internal V Item { get; internal set; }
    internal int get_Count();
    internal void Clear();
    internal bool Remove(K k);
    internal V get_Item(K key);
    internal void set_Item(K key, V value);
    internal bool ContainsKey(K k);
    internal List`1<K> GetKeys();
    internal List`1<V> GetValues();
    public IEnumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Common.SyncQueueList`1 : object {
    internal List`1<T> m_list;
    internal object m_sync;
    internal int m_max;
    internal bool m_bMaxExplicitlySet;
    internal T Item { get; }
    internal int Count { get; }
    internal SyncQueueList`1(int max);
    internal List`1<T> GetList();
    internal void Enqueue(T t);
    internal void Enqueue(T& t);
    internal bool Dequeue(T& t);
    internal virtual T Dequeue();
    internal void Add(T t);
    internal bool AddIfNotExist(T t);
    internal bool Contains(T t);
    internal int IndexOf(T t);
    internal bool Remove(T t, int minRequirement);
    internal bool Remove(T t);
    internal void Clear();
    internal T get_Item(int index);
    internal int get_Count();
}
internal class OracleInternal.Common.TableColumnsCache : object {
    private Dictionary`2<Tuple`3<string, string, string>, OracleLpTableColumns> tableColumnsCache;
    private ReaderWriterLockSlim m_sync_rw;
    internal void Put(string serviceName, string schemaName, string tableName, OracleLpTableColumns tableColumns);
    internal OracleLpTableColumns Get(string serviceName, string schemaName, string tableName);
    internal void Clear();
}
internal class OracleInternal.Common.ThreadData : object {
    internal Stream traceFile;
    internal TextWriterTraceListener textListener;
    internal long traceFileSize;
    internal string traceFilePath;
    internal int timeStampHash;
    internal static int TimeStampHash;
    internal bool IsOutdated { get; }
    private static ThreadData();
    internal bool get_IsOutdated();
    internal static void RegenerateTimeStampHash();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal class OracleInternal.Common.TimeZoneFileReader : object {
    private static int LTZ_MINSPERHOUR;
    private static int LTZ_SECSPERMIN;
    private static int LTZ_HOURSPERDAY;
    private static int LTZ_SECSPERHOUR;
    private static int LTZERR_OK;
    private static int LTZERR_NULL_PTR;
    private static int LTZERR_BAD_DATA;
    private static int LTZERR_BAD_VER;
    private static int LTZERR_INV_ZONE;
    private static int LTZERR_NO_DATA;
    private static int LTZERR_BAD_ABBRV;
    private static int LTZERR_INV_DATE;
    private static int LTZERR_BAD_MEM;
    private static int LTZ_NUM_IDS;
    private static int LTZ_REGID_BITS;
    private static int LTZ_MAGIC;
    private static short LTZ_VERSION;
    private static int LTZ_MAX_FILE_SIZE;
    internal OracleTimeZone ReadObj();
    internal LTZHead PopulateHead(BinaryReader binaryReader, Int32& errcode);
    internal LdiDateTime[] ReadTransitionsOfAllZones(LTZHead head, BinaryReader binaryReader);
    internal LTZtag[] PopulateTagArray(LTZHead head, BinaryReader binaryReader);
    internal Int16[] PopulateTagMapArray(LTZHead head, BinaryReader binaryReader);
    internal Byte[] PopulateDSTFlagArray(LTZHead head, BinaryReader binaryReader);
    internal Dictionary`2<int, string> PopulateZoneIdMapHashtable(LTZHead head, BinaryReader binaryReader);
    internal Hashtable PopulateZoneOffsetMapHashtable(LTZHead head, LdiDateTime[] dttab, Int16[] tagmap, LTZtag[] tagtab, Byte[] dstflag);
    private TimeSpan GetTimeSpan(int hourMinuteSecond);
}
internal static class OracleInternal.Common.TokenAuthDependenciesFactory : object {
    private static Lazy`1<ITokenAuthenticationProvider> AzureTokenProviderInstance;
    private static Lazy`1<ITokenAuthenticationProvider> OciTokenProviderInstance;
    internal static ITokenAuthenticationProvider AzureTokenProvider { get; }
    internal static ITokenAuthenticationProvider OciTokenProvider { get; }
    private static TokenAuthDependenciesFactory();
    internal static ITokenAuthenticationProvider get_AzureTokenProvider();
    internal static ITokenAuthenticationProvider get_OciTokenProvider();
    private static ITokenAuthenticationProvider GetAzureTokenProviderInstance();
    private static ITokenAuthenticationProvider GetOciTokenProviderInstance();
}
internal class OracleInternal.Common.TokenConfiguration : object {
    private IDictionary`2<int, object> m_tokenParameters;
    internal string AZURE_ENV_TENANT_ID;
    internal string AZURE_ENV_CLIENT_ID;
    internal OracleOpaqueString AZURE_ENV_CLIENT_SECRET;
    internal string AZURE_ENV_CLIENT_CERTIFICATE_PATH;
    internal string AZURE_ENV_USERNAME;
    internal OracleOpaqueString AZURE_ENV_PASSW;
    [CompilerGeneratedAttribute]
private AbstractTokenAuthentication <AbstractTokenAuthentication>k__BackingField;
    public AbstractTokenAuthentication AbstractTokenAuthentication { get; }
    public TokenConfiguration(AbstractTokenAuthentication abstractTokenAuthentication, OracleTokenAuth tokenAuth, OraclePasswordAuth passwAuth, string userId, OracleOpaqueString securePassw, ConnectionOption connOption, SqlNetOraConfig snoConfig, bool WalletOverride);
    public TokenConfiguration(AbstractTokenAuthentication abstractTokenAuthentication, OracleTokenAuth tokenAuth, string configFile, string profile, string compartment, string database, string userId);
    [CompilerGeneratedAttribute]
public AbstractTokenAuthentication get_AbstractTokenAuthentication();
    public bool TryGetTokenParameterValue(int identifier, T& paramValue);
    public void AddNewClientSecret(object newClientSecret);
}
internal static class OracleInternal.Common.Trace : object {
    private static object s_syncObj;
    internal static TextWriterTraceListener s_singleTextListener;
    internal static string s_namedSlot;
    internal static string s_dateTimeFormat;
    internal static string s_dateFormat;
    internal static string s_timeFormat;
    internal static string s_oldTraceFileLocation;
    internal static string s_lastEventLogEntryAdded;
    internal static int s_oldTraceLevel;
    internal static string s_odpTraceDir;
    internal static string s_eventLogSource;
    internal static string s_eventLogName;
    internal static bool m_bEventLogEntryAdded;
    internal static long s_singleTraceFileSize;
    internal static string s_singleTraceFilePath;
    private static Trace();
    internal static void Init();
    internal static void ReInit(bool doFinalize);
    private static void FinalizeMultiTraceListener();
    private static ThreadData InitializeMultiTraceListener(bool reInit);
    private static void FinalizeSingleTraceListener();
    private static void InitializeSingleTraceListener();
    internal static void Write(OracleTraceLevel traceLevel, OracleTraceTag traceTag, OracleTraceClassName className, OracleTraceFuncName funcName, String[] args);
    internal static void Write(OracleTraceLevel traceLevel, OracleTraceTag traceTag, OracleTraceClassName className, OracleTraceFuncName funcName, object traceObj, String[] args);
    internal static void Write(OracleTraceLevel traceLevel, OracleTraceTag tracetag, Byte[] dataBuffer, int offset, int size);
    internal static void Write(OracleTraceLevel traceLevel, OracleTraceTag tracetag, object traceObj, Byte[] dataBuffer, int offset, int size);
    private static string GetTimeInfo();
    internal static string GetConnectionId(object traceObj, bool bLocalConnectionId);
    private static void WriteTrace(string message);
    internal static void SetConnectionId(object obj, string connectionId, OracleTraceClassName className, OracleTraceFuncName funcName);
    private static Stream OpenFile(string singleTraceFileLocation, string traceFileName, int threadId, String& traceFilePath, Int64& traceFileSize);
    private static void CreateEventLogSource();
    private static Stream GetFileName(string singleTraceFileLocation, int threadId, String& traceFilePath, Int64& traceFileSize);
    private static string GetAsciiCharacters(Byte[] dataBuffer, int offset, int size);
    public static string GetCPInfo(OracleConnectionImpl con, object transaction, string affinityInstance, string oper, bool bResourcePoolInfo, bool bDistributionInfo, String[] instanceNames, bool bConnectionId);
    internal static string GetMTSTraceOutput(OraclePoolManager pm, OracleConnectionImpl conImpl, string txnid, string operation, string txnctxid, string respool);
}
internal class OracleInternal.Common.TraceParameters : object {
    private static int m_localConnectionIdIdx;
    private string m_connectionId;
    private string m_localConnectionId;
    internal string ConnectionId { get; internal set; }
    internal string LocalConnectionId { get; }
    internal string get_ConnectionId();
    internal void set_ConnectionId(string value);
    internal string get_LocalConnectionId();
    internal void SetLocalConnectionId();
}
internal class OracleInternal.Common.Tracing : object {
    private static Tracing();
    internal static void Start();
}
internal class OracleInternal.Common.TracingState : object {
    internal static bool s_bTracingStarted;
}
internal class OracleInternal.Common.Transitions : ValueType {
    internal DateTime m_dateTimeInUtc;
    internal DateTime m_dateTimeInLocal;
    internal TimeSpan m_hourOffset;
    internal byte m_dst;
    internal TimeSpan m_dstDuration;
}
internal abstract class OracleInternal.Common.UrlAuth : object {
    protected static string GetAuthValueFromAuthParam(String[] secureAuthParameterList, Dictionary`2<string, object> authParameterValues, string authKey);
    protected static bool IsAuthValueFromAuthParamExist(String[] secureAuthParameterList, Dictionary`2<string, object> authParameterValues, string authKey);
    protected static string GetAuthValueFromAuthParamAndEnv(String[] secureAuthParameterList, Dictionary`2<string, object> authParameterValues, string authKey, string envAuthKey);
    protected static SecureString GetSecuredAuthValueFromEnv(string envAuthKey);
    protected static SecureString GetSecuredAuthValueFromAuthParamAndEnv(String[] secureAuthParameterList, Dictionary`2<string, object> authParameterValues, string authKey, string envAuthKey);
}
internal class OracleInternal.Common.UrlConnInfo : UrlProviderInfo {
    protected OracleConnectionStringBuilder m_connStrBlr;
    protected string m_passwLessConnStr;
    protected string m_passwLessResultingConnStr;
    protected ConfigPasswKey m_userPasswKey;
    protected internal OracleOpaqueString m_userOpaquePassw;
    protected ConfigPasswKey m_proxyPasswKey;
    protected internal OracleOpaqueString m_proxyOpaquePassw;
    protected DateTime m_passwsUpdatedTime;
    protected Dictionary`2<string, string> m_connProperties;
    internal PasswSource m_passwSource;
    internal bool IsEmpty { get; }
    internal string PasswLessResultingConnectionString { get; }
    internal string ResultingConnectionString { get; }
    internal bool ContainPassws { get; }
    internal DateTime PasswUpdatedTime { get; }
    internal UrlConnInfo(AbstractUrlProvider configProvider, OracleConnectionStringBuilder connStrBlr, Dictionary`2<string, string> connProperties, ConfigPasswKey userPasswKey, OracleOpaqueString userPassw, ConfigPasswKey proxyPasswKey, OracleOpaqueString proxyPassw);
    internal virtual bool get_IsEmpty();
    internal string get_PasswLessResultingConnectionString();
    internal string get_ResultingConnectionString();
    internal void UpdatePassws(UrlConnInfo urlConnInfo);
    internal bool get_ContainPassws();
    internal virtual void PopulateConnProperties(OracleConnection conn, bool bOverride);
    internal virtual void MakeCopy(UrlProviderInfo providerInfo);
    internal DateTime get_PasswUpdatedTime();
    internal virtual bool IsSameResultingConnStr(UrlConnInfo connInfo);
    internal virtual UrlProviderInfo MakeCopy();
    internal bool HasSamePassws(UrlConnInfo connInfo);
    internal bool RefreshPassws(OracleOpaqueString& userSecuredPassw, OracleOpaqueString& proxySecuredPassw);
    internal void UpdatePassws(OracleOpaqueString userPassw, OracleOpaqueString proxyPassw);
    internal virtual void UpdatePassws(UrlProviderInfo connInfo);
    internal void SetPasswSource(bool passwInConnectionString, bool passwInOdpPassw, bool passwInPassw);
}
internal class OracleInternal.Common.UrlProviderDependenciesFactory : object {
    internal static AbstractUrlProvider CreateAzureConfigProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateOciConfigProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateConfigFileProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateAzureVaultProvider(ProviderUrl connStrUrl);
    internal static AbstractUrlProvider CreateOciVaultProvider(ProviderUrl connStrUrl);
    internal static string GetAzureSecret(ConfigSecretInfo secretInfo);
    internal static string GetOciSecret(ConfigSecretInfo secretInfo);
}
internal abstract class OracleInternal.Common.UrlProviderInfo : object {
    protected static TimeSpan s_defaultTimeToLive;
    protected static TimeSpan s_defaultSoftlyExpiredCache;
    internal bool IsDirty;
    protected AbstractUrlProvider m_urlProvider;
    protected DateTime m_urlRefreshedTime;
    protected bool m_bPooling;
    protected TimeSpan m_timeToLive;
    protected bool m_bHonorTimeToLive;
    protected object m_urlChangedLock;
    internal bool NeedsUpdate { get; }
    internal UrlProviderRequestType RequestType { get; }
    internal bool IsEmpty { get; }
    internal string SecureUrlConnStr { get; }
    internal ProviderUrl ProviderUrl { get; }
    internal bool Pooling { get; }
    internal DateTime RefreshedTime { get; }
    internal bool IsExpired { get; }
    internal long TimeToLive { get; internal set; }
    internal UrlProviderInfo(AbstractUrlProvider urlProvider);
    private static UrlProviderInfo();
    internal bool get_NeedsUpdate();
    internal UrlProviderRequestType get_RequestType();
    internal abstract virtual bool get_IsEmpty();
    internal string get_SecureUrlConnStr();
    internal ProviderUrl get_ProviderUrl();
    internal bool get_Pooling();
    internal DateTime get_RefreshedTime();
    internal bool get_IsExpired();
    internal long get_TimeToLive();
    internal void set_TimeToLive(long value);
    internal bool RefreshProviderInfoIfExpired(UrlProviderInfo& refreshProviderInfo);
    internal bool RefreshProviderInfo(UrlProviderInfo& refreshProviderInfo);
    internal abstract virtual UrlProviderInfo MakeCopy();
    internal virtual void MakeCopy(UrlProviderInfo providerInfo);
    internal virtual void UpdatePassws(UrlProviderInfo urlInfo);
}
internal enum OracleInternal.Common.UrlProviderRequestType : Enum {
    public int value__;
    public static UrlProviderRequestType ConnectInfo;
    public static UrlProviderRequestType PasswInfo;
    public static UrlProviderRequestType NestedPasswInfo;
}
internal enum OracleInternal.Common.UrlProviderType : Enum {
    public int value__;
    public static UrlProviderType Standard;
    public static UrlProviderType Azure;
    public static UrlProviderType OCI;
    public static UrlProviderType File;
    public static UrlProviderType Secret_Azure;
    public static UrlProviderType Secret_OCI;
}
internal class OracleInternal.Common.UrlWatcherFactory : object {
    private static string AZURE_WATCHER_FULL_NAME;
    private static string OCI_WATCHER_FULL_NAME;
    private static Type[] AzureWatcherConstructorTypes;
    private static Type[] OciWatcherConstructorTypes;
    private static UrlWatcherFactory();
    public static AbstractURLWatcher CreateAzureWatcher(UrlProviderCache cache);
    public static AbstractURLWatcher CreateOciWatcher(UrlProviderCache cache);
}
internal class OracleInternal.Common.VaultPasswInfo : UrlProviderInfo {
    protected OracleOpaqueString m_opaquePassw;
    protected DateTime m_passwsUpdatedTime;
    internal OracleOpaqueString Secret { get; }
    internal bool IsEmpty { get; }
    internal VaultPasswInfo(AbstractUrlProvider configProvider, OracleOpaqueString passw);
    internal virtual OracleOpaqueString get_Secret();
    internal virtual bool get_IsEmpty();
    internal virtual UrlProviderInfo MakeCopy();
    internal virtual void MakeCopy(UrlProviderInfo providerInfo);
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Common.XmlSchemaPool : object {
    private object m_sync;
    private ConcurrentDictionary`2<string, CachedSchemaWithId> m_schemaUrlCache;
    private ConcurrentDictionary`2<Byte[], CachedSchemaWithUrl> m_schemaIdCache;
    private int m_maxCacheSize;
    internal CachedSchemaWithId Item { get; internal set; }
    internal CachedSchemaWithUrl Item { get; internal set; }
    internal XmlSchemaPool(int maxCacheSize);
    internal bool Contains(string url);
    internal bool Contains(Byte[] id);
    internal CachedSchemaWithId get_Item(string url);
    internal void set_Item(string url, CachedSchemaWithId value);
    internal CachedSchemaWithUrl get_Item(Byte[] id);
    internal void set_Item(Byte[] id, CachedSchemaWithUrl value);
}
internal class OracleInternal.Common.ZoneValue : ValueType {
    internal Transitions[] m_transitions;
}
internal class OracleInternal.ConnectionPool.ChunkUpEvent : object {
    private SyncDictionary`2<string, ChunkUpEventState> m_events;
    public string GetId(string db, int chunkId);
    public void CreateEvent(string db, int chunkId, string sourceChunkName);
    public ManualResetEventSlim GetEvent(string db, int chunkId);
    public void SetAndRemoveEvent(string db, int chunkId);
    public void SetAndRemoveEvent(string db, int chunkId, string chunkName, OracleChunkEventStatus status);
}
internal class OracleInternal.ConnectionPool.ChunkUpEventState : object {
    [CompilerGeneratedAttribute]
private ManualResetEventSlim <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DownReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SplitPsetReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NewPsetReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceChunkName>k__BackingField;
    internal ManualResetEventSlim Event { get; internal set; }
    internal bool UpReceived { get; internal set; }
    internal bool DownReceived { get; internal set; }
    internal bool SplitPsetReceived { get; internal set; }
    internal bool NewPsetReceived { get; internal set; }
    internal string SourceChunkName { get; internal set; }
    internal ChunkUpEventState(string sourceChunkName);
    [CompilerGeneratedAttribute]
internal ManualResetEventSlim get_Event();
    [CompilerGeneratedAttribute]
internal void set_Event(ManualResetEventSlim value);
    [CompilerGeneratedAttribute]
internal bool get_UpReceived();
    [CompilerGeneratedAttribute]
internal void set_UpReceived(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DownReceived();
    [CompilerGeneratedAttribute]
internal void set_DownReceived(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SplitPsetReceived();
    [CompilerGeneratedAttribute]
internal void set_SplitPsetReceived(bool value);
    [CompilerGeneratedAttribute]
internal bool get_NewPsetReceived();
    [CompilerGeneratedAttribute]
internal void set_NewPsetReceived(bool value);
    [CompilerGeneratedAttribute]
internal string get_SourceChunkName();
    [CompilerGeneratedAttribute]
internal void set_SourceChunkName(string value);
}
internal class OracleInternal.ConnectionPool.ComparisonInfo : object {
    public ComparisonType m_compType;
    public int m_oriStartPos;
    public int m_newStartPos;
    public int m_length;
    public int m_attrStartPos;
    public int m_attrEndPos;
    public bool m_bLastAttribute;
    public ComparisonInfo(ComparisonType compType, int oriStartPos, int newStartPos, int length, int attrStartPos, int attrEndPos, bool bLastAttribute);
    public sealed virtual int Compare(ComparisonInfo a, ComparisonInfo b);
}
internal enum OracleInternal.ConnectionPool.ComparisonType : Enum {
    public int value__;
    public static ComparisonType Default;
    public static ComparisonType UserId;
    public static ComparisonType Passw;
    public static ComparisonType ProxyPassw;
}
internal class OracleInternal.ConnectionPool.ConnectionPoolId : object {
    private int m_hashCode;
    internal OracleCredential m_orclCredential;
    internal string m_passwLessconnString;
    internal string m_guidDRCPConnectionClass;
    internal OracleAccessToken m_accessToken;
    internal AbstractTokenAuthentication m_tokenConfiguration;
    internal ConnectionPoolId(string connString, OracleCredential orclCredential, OracleAccessToken accessToken, AbstractTokenAuthentication tokenConfiguration);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private void CalculateHashCode();
}
internal enum OracleInternal.ConnectionPool.ConnectionPoolType : Enum {
    public byte value__;
    public static ConnectionPoolType Unknown;
    public static ConnectionPoolType OCP;
    public static ConnectionPoolType CCP;
}
internal class OracleInternal.ConnectionPool.ConnectionString : object {
    private static char s_space;
    private static char s_singleQuote;
    private static char s_doubleQuote;
    private static char s_semiColon;
    private static char s_equalSign;
    private static Char[] s_whiteSpace;
    private static Char[] s_ignore;
    private static Char[] s_quotes;
    private static Char[] s_separator;
    private static Char[] s_equal;
    private static Char[] delim;
    private static Char[] delim2;
    internal object m_sync;
    public static string s_sysDba;
    public static string s_sysOper;
    public static string s_sysAsm;
    public static string s_sysBackup;
    public static string s_sysDg;
    public static string s_sysKm;
    public static string s_sysRac;
    private static string s_dataSource;
    private static string s_dbaPrivilege;
    private static string s_enlist;
    private static string s_connectionLifetime;
    private static string s_incrPoolSize;
    private static string s_decrPoolSize;
    private static string s_maxPoolSize;
    private static string s_minPoolSize;
    private static string s_passw;
    private static string s_persistSecurityInfo;
    private static string s_pooling;
    private static string s_connectionTimeout;
    private static string s_connectTimeout;
    private static string s_userId;
    private static string s_poolRegulator;
    private static string s_tnsAdmin;
    private static string s_walletLocation;
    private static string s_promotableTransaction;
    private static string s_proxyUserId;
    private static string s_proxyPassw;
    private static string s_validateConnection;
    private static string s_stmtCacheSize;
    private static string s_stmtCachePurge;
    private static string s_haEvents;
    private static string s_loadBalancing;
    private static string s_metadataPooling;
    private static string s_contextConnection;
    private static string s_selftuning;
    private static string s_applicationContinuity;
    private static string s_connectionPoolTimeout;
    private static string s_lowercase_userid;
    private static string s_lowercase_passw;
    private static string s_lowercase_proxyuserid;
    private static string s_lowercase_proxypassw;
    private static string s_dynamic;
    private static string s_urlConnStr;
    public string m_dataSource;
    public OracleDBAPrivilege m_dbaPrivilege;
    public Enlist m_enlist;
    public int m_connectionLifetime;
    public int m_incrPoolSize;
    public int m_decrPoolSize;
    public int m_maxPoolSize;
    public int m_minPoolSize;
    public bool m_persistSecurityInfo;
    public bool m_pooling;
    public int m_connectionTimeout;
    public string m_userId;
    private string m_promotableTransactionString;
    public PromotableTransaction m_promotableTransaction;
    public string m_proxyUserId;
    public bool m_validateConnection;
    public int m_stmtCacheSize;
    public bool m_stmtCachePurge;
    public string m_tnsAdmin;
    public string m_walletLocation;
    internal bool m_bIncludeOsUser;
    internal OracleAccessToken m_accessToken;
    private static string s_token_auth;
    private static string s_token_location;
    internal UrlProviderType m_connStrType;
    internal UrlConnInfo m_urlConnInfo;
    internal OracleTokenAuth m_tokenAuthCS;
    internal string m_tokenLocationCS;
    internal bool m_bTokenAuthSet;
    internal bool m_bTokenLocationSet;
    internal OracleTokenAuth m_tokenAuth;
    internal string m_tokenLocation;
    internal bool m_bTokenAuth_setByApp;
    internal bool m_bTokenLocation_setByApp;
    internal OraclePasswordAuth m_passwAuth;
    internal string m_ociIamUrl;
    internal string m_ociTenancy;
    internal string m_ociCompartmentId;
    internal string m_ociDatabaseId;
    internal bool m_bPasswAuth_setByApp;
    internal bool m_bOciIamUrl_setByApp;
    internal bool m_bOciTenancy_setByApp;
    internal bool m_bOciCompartment_setByApp;
    internal bool m_bOciDatabase_setByApp;
    internal AbstractTokenAuthentication m_tokenConfiguration;
    internal string m_ociConfigFile;
    internal string m_ociProfile;
    internal bool m_bOciConfigFile_setByApp;
    internal bool m_bOciProfile_setByApp;
    public bool m_haEvents;
    public bool m_haEventsPresentInConnString;
    public bool m_loadBalancing;
    public bool m_loadBalancingPresentInConnString;
    public bool m_applicationContinuity;
    public bool m_applicationContinuityPresentInConnString;
    public bool m_metadataPooling;
    public bool m_contextConnection;
    public bool m_selfTuning;
    public ConnectionPoolType m_connectionPoolType;
    public object m_drcpSyncObj;
    public object m_connectionPoolTypeSyncObj;
    public int m_poolRegulator;
    public int m_connectionPoolTimeout;
    internal string m_poolName;
    internal string m_sepsUserId;
    internal string m_sepsProxyUserId;
    public OracleOpaqueString m_sepsOpaquePassw;
    public OracleOpaqueString m_sepsOpaqueProxyPassw;
    public string m_passwlessConString;
    public string m_useridKeyValue;
    public bool m_bPasswSet;
    public bool m_bProxyPasswSet;
    public bool m_bUserIdSet;
    public bool m_bProxyUserIdSet;
    public bool m_bDBAPrivilegeSet;
    public string m_osUserName;
    public TimeSpan m_connectionLifetimeTimeSpan;
    private static Dictionary`2<string, bool> m_boolMapping;
    public bool m_bInitilialized;
    public bool m_bOpaqued;
    public bool m_bPooled;
    public DrcpType m_drcpEnabled;
    public bool m_bModifiedAfterParsing;
    public bool m_bDBStartup;
    public bool m_bPrelimAuthSession;
    public WindowsIdentity m_osUser;
    public static ConStringPool m_conStringPool;
    private static UrlProviderCache s_urlProviderCache;
    internal bool m_bIsWalletFromCloud;
    internal bool m_bIsTokenFromCloud;
    internal bool m_osUserRequired;
    internal bool m_osUserRequired_set;
    public ComparisonType[] m_compTypes;
    public Int32[] m_compOriStartPos;
    public Int32[] m_compNewStartPos;
    public Int32[] m_compLength;
    public String[] m_compSubString;
    public string m_compString;
    public Char[] m_compStringChars;
    public ConnectionPoolId m_conPoolKey;
    public OraclePoolManager m_pm;
    public string m_pmId;
    public OracleOpaqueString m_opaquePassw;
    public OracleOpaqueString m_opaqueProxyPassw;
    public OracleCredential m_orclCredential;
    public SyncQueueList`1<OracleOpaqueString> m_opaPasswList;
    public SyncQueueList`1<OracleOpaqueString> m_opaPxyPasswList;
    internal bool m_bDeadObject;
    public string m_constring;
    internal string m_authString;
    private int m_attrStartPos;
    private int m_attrEndPos;
    private int m_valStartPos;
    private int m_valEndPos;
    private int m_useridPos;
    private int m_useridLength;
    private int m_spaceCount;
    private ComparisonInfo m_compUserId;
    private ComparisonInfo m_compPassw;
    private ComparisonInfo m_compProxyPassw;
    private List`1<ComparisonInfo> m_compList;
    private int m_currentPos;
    private int m_equalPos;
    private int m_prevSemiPos;
    private int m_passwlessOffset;
    public int m_key;
    public int m_length;
    public bool m_fetchPdbNameFromDb;
    private StringBuilder m_passwLessCoonStrBuilder;
    internal string ServerID { get; }
    internal UrlConnInfo UrlConnInfo { get; }
    internal string UserAuthenticationString { get; }
    private static ConnectionString();
    public ConnectionString(OracleConnection con, string constring, OracleCredential credential, OracleAccessToken accessToken, bool bIncludeOsUser);
    private void Initialize(OracleConnection con, string connectionString);
    internal string get_ServerID();
    public void Validate();
    public void SetProperty(string key, string value, string quotedValue, string originalKey, OracleOpaqueString opaquePassw, OracleOpaqueString token);
    public ConnectionString Clone();
    private sealed virtual override object System.ICloneable.Clone();
    private static bool IsOsUserPresentInConString(string constr, object traceObj);
    internal UrlConnInfo get_UrlConnInfo();
    internal static UrlConnInfo GetConnInfoFromODPUrlProvider(UrlProviderType connStrProviderType, string userProvidedConStr, bool bRemoteConfigurationFiltering, string connTnsAdmin);
    internal static VaultPasswInfo GetSecretFromODPVaultProvider(UrlProviderType connStrProviderType, string userProvidedConStr);
    internal static void RemoveODPUrlProviderFromCache(ConnectionString cs);
    internal static void UpdatePasswsInUrlProviderCache(UrlConnInfo updatedConnInfo);
    internal static bool IsConfigConnStrType(UrlProviderType connStrProviderType);
    internal static bool IsUrlSecretType(UrlProviderType connStrProviderType);
    internal static bool IsUrlConnStrType(UrlProviderType connStrProviderType);
    internal static bool IsStandardConnStrType(UrlProviderType connStrProviderType);
    internal static UrlProviderType GetUrlProviderType(string userProviderConnStr);
    internal static void UnregisterCloudConfigNotification(ConnectionString cs);
    public static int GetKey(OracleConnection con, string connStr, OracleCredential orclCred, OracleAccessToken accessToken, bool bIncludeOsUser);
    public static ConnectionString GetCS(OracleConnection con, string userProvidedConStr, OracleCredential credential, OracleAccessToken accessToken, bool bCreateIfNotinCache, bool bIncludeOsUser);
    public bool Compare(OracleConnection con, string constr, OracleAccessToken accessToken, bool bIncludeOsUser, object traceObj);
    public string Parse(OracleConnection con, string constr);
    internal static bool SetCloudWallet(string vaultWalletLocation, string source, OracleConnectionInternal con);
    internal static bool SetCloudToken(string vaultTokenLocation, string source, OracleConnectionInternal con);
    private void CalculatePasswordLessOffset();
    private string GetPoolNameFromConfig(string passwlessConString);
    public static string GetStringFromSecureString(SecureString ss);
    internal bool GetOpaquePassword(OracleOpaqueString& opaPassw);
    internal bool GetOpaqueProxyPassword(OracleOpaqueString& opaProxyPassw);
    internal string get_UserAuthenticationString();
    internal string ConstructConString(OracleConnection con);
    public static bool AccessTokenEqual(OracleAccessToken ctx1, OracleAccessToken ctx2);
    public static bool CharArrayEqual(Char[] arr1, Char[] arr2);
    public static bool OpaqueStringsEqual(OracleOpaqueString strA, OracleOpaqueString strB);
    public static bool OpaqueStringsEqual(OracleOpaqueString strA, Char[] strB, int bOffset, int bLength);
}
internal class OracleInternal.ConnectionPool.ConStringPool : Pooler`2<int, List`1<ConnectionString>> {
    private object m_sync;
    public ConStringPool(int maxCacheSize);
    public bool Remove(ConnectionString val);
    public void Put(ConnectionString val);
}
internal class OracleInternal.ConnectionPool.CPComparer : object {
    public static CPComparer s_cpComparer;
    private static CPComparer();
    public sealed virtual int Compare(object x, object y);
}
internal class OracleInternal.ConnectionPool.CriteriaMapper : object {
    private SyncDictionary`2<string, UInt32> m_dictConnectionId;
    private SyncDictionary`2<string, UInt32> m_dictEditionId;
    private UInt32 m_ConnectionIdCounter;
    private UInt32 m_EditionIdCounter;
    internal object m_syncCriteriaCtx;
    internal object m_syncConnCls;
    internal object m_syncEdition;
    internal void GetId(OracleConnectionImpl pr);
    internal void AssignId(OracleConnection connRefForCriteria);
    internal void AddId(string id_value, int id_type);
    internal void RemoveId(string id_value, int id_type);
}
internal enum OracleInternal.ConnectionPool.DeletionRequestor : Enum {
    public int value__;
    public static DeletionRequestor None;
    public static DeletionRequestor ClearPool;
    public static DeletionRequestor ConnectionLifetime;
    public static DeletionRequestor PoolRegulator;
    public static DeletionRequestor HA;
    public static DeletionRequestor Put;
}
internal interface OracleInternal.ConnectionPool.IOraclePoolResource {
    public abstract virtual ValueTask ConnectAsync(ConnectionString cs, bool bOpenEndUserSession, OracleConnection connRefForCriteria, string instanceName, bool bAsync);
    public abstract virtual void Connect(ConnectionString cs, bool bOpenEndUserSession, OracleConnection connRefForCriteria, string instanceName, bool bAsync);
    public abstract virtual void AttachServerProcess(long sessionFlags, bool bUseDRCPMultiTag, Int64& s2cSessionFlags);
    public abstract virtual void DetachServerProcess(string drcpTagName, bool bUseDRCPMultiTag);
    public abstract virtual void DisConnect(OracleConnection connRefForCriteria);
}
internal static class OracleInternal.ConnectionPool.OracleConnectionDispenser`3 : object {
    public static SyncDictionary`2<ConnectionPoolId, PM> m_htPM;
    public static SyncQueueList`1<PM> m_listPM;
    internal static SyncQueueList`1<string> m_listDataSources;
    internal static object m_syncObjForGetDataSources;
    internal static SyncDictionary`2<string, ManualResetEventSlim> m_chunkUpEvents;
    internal static FileSystemWatcher s_sepsFileWatcher;
    internal static object s_sepsFileWatcherCreationLock;
    internal static bool s_bSEPSFileWatcherCreated;
    internal static ChunkUpEvent m_sChunkUpEvents;
    internal static object s_shardLockObj;
    private static OracleConnectionDispenser`3();
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.OracleConnectionDispenser`3/<GetAsync>d__0")]
internal static ValueTask`1<PR> GetAsync(ConnectionString cs, PM conPM, ConnectionString pmCS, OracleOpaqueString securedPassw, OracleOpaqueString securedProxyPassw, OracleConnection connRefForCriteria, bool bAsync);
    internal static void CreateSEPSFileWatcher(string walletPath, string walletFile);
    internal static void SEPSFileRenamedEvent(object source, RenamedEventArgs e);
    internal static void SEPSFileChangedEvent(object sender, FileSystemEventArgs e);
    internal static void ProcessSEPSFileChangeEvent();
    internal static string Dump();
    internal static string Dump(string txnid);
    internal static PM GetPM(ConnectionString cs, OracleConnection con, PM conPM, ConnectionString pmCS, OracleOpaqueString securedOpaquePassw, OracleOpaqueString securedOpaqueProxyPassw, Boolean& bAuthenticated, Boolean& newPM);
    internal static PR Get(ConnectionString cs, PM conPM, ConnectionString pmCS, OracleOpaqueString securedPassw, OracleOpaqueString securedProxyPassw, OracleConnection connRefForCriteria, bool bAsync);
    internal static void PutFromApp(PR pr, OracleConnection connRefForCriteria);
    internal static void PutFromPSPE(Transaction txn, PR pr);
    internal static void PutFromDTC(PR pr);
    private static void Put(PR pr, OracleConnection connRefForCriteria);
    internal static void ClearInteractiveTokensForConnPools();
    internal static void ClearAllPools();
    internal static void ClearPool(ConnectionString cs);
    internal static List`1<string> GetDataSources();
    internal static List`1<PM> GetImpactedShardingPMs(OracleChunkEventArgs chunkEvent);
    internal static void ProcessChunkMoveEvent(OracleChunkEventArgs chunkEvent);
    internal static void ProcessHAEvent(OracleHAEventArgs haEvent);
    internal static void ProcessInstanceUp(PM currentPM, OracleHAEventArgs haEvent, bool bUnplannedOutage, PR pr);
    internal static void ProcessServiceUp(PM currentPM, OracleHAEventArgs haEvent, PR pr);
    internal static PR GetEnlisted(ConnectionString cs, OracleConnection con, string serviceName, string pdbName, Transaction txn, string affinityInstance, int branchNum, bool bMustMatch, Boolean& bMatchFound);
    internal static MTSTxnRM GetRM(ConnectionString cs, OracleConnection connRefForCriteria, Transaction txn, OracleConnectionImpl pr);
    internal static void RemoveRM(ConnectionString cs, string serviceName, Transaction txn);
}
internal class OracleInternal.ConnectionPool.OraclePool : Pool`3<OraclePoolManager, OraclePool, OracleConnectionImpl> {
    public bool m_bIsPoolActive;
    public static bool m_bPerfCounterEnabled;
    public static bool m_bPerfHardConnectsPerSecond;
    public static bool m_bPerfHardDisconnectsPerSecond;
    public static bool m_bPerfSoftConnectsPerSecond;
    public static bool m_bPerfSoftDisconnectsPerSecond;
    public static bool m_bPerfNumberOfActiveConnectionPools;
    public static bool m_bPerfNumberOfInactiveConnectionPools;
    public static bool m_bPerfNumberOfActiveConnections;
    public static bool m_bPerfNumberOfFreeConnections;
    public static bool m_bPerfNumberOfPooledConnections;
    public static bool m_bPerfNumberOfNonPooledConnections;
    public static bool m_bPerfNumberOfReclaimedConnections;
    public static bool m_bPerfNumberOfStasisConnections;
    private OraclePerfCounter[] m_perfCounterCache;
    private static OraclePool();
    public static void PerformanceCounterDecrement(CounterIndex counterIndex, OracleConnectionImpl pr, OraclePool op);
    public static void PerformanceCounterIncrement(CounterIndex counterIndex, OracleConnectionImpl pr, OraclePool op);
    public static void MetricsCounterDecrement(CounterIndex counterIndex, OracleConnectionImpl pr, OraclePool op);
    public static void MetricsCounterIncrement(CounterIndex counterIndex, OracleConnectionImpl pr, OraclePool op);
    private static string GetInstanceName(OracleConnectionImpl pr);
    public virtual void PutNewPR(OracleConnectionImpl pr, bool bForPoolPopulation);
    public virtual OracleConnectionImpl Get(OracleConnection connRefForCriteria);
}
internal class OracleInternal.ConnectionPool.OraclePoolManager : PoolManager`3<OraclePoolManager, OraclePool, OracleConnectionImpl> {
    private static int s_maxListCapacity;
    private static int DEFAULT_MAX_ELEMS_IN_METADATAPOOL;
    private static int DEFAULT_MAX_ELEMS_IN_SQLPARSEINFOPOOL;
    internal static int DEFAULT_MAX_ELEMS_IN_DERIVEPARAMINFOPOOL;
    internal static int DEFAULT_MAX_ELEMS_IN_XMLSCHEMAPOOL;
    public OraBufPool m_oraBufPool;
    internal SyncDictionary`2<string, DeriveParamInfoPool> m_dictDeriveParamInfoPool;
    internal object m_dictDeriveParamInfoPoolLock;
    internal SyncDictionary`2<string, XmlSchemaPool> m_dictXmlSchemaPool;
    internal object m_dictXmlSchemaPoolLock;
    private UDTTypeCache m_udtTypeCache;
    private object m_udtTypeCacheLock;
    internal object m_orclGlobLock;
    internal int m_appThreadLCID;
    internal static int NUM_CRED_RETRIEVAL_TRIES;
    internal long m_logonMode;
    internal bool m_bDoNAHandShake;
    internal bool m_bDoExternalAuth;
    internal ConnectionCookie m_connCookieObject;
    internal OraBuf m_fabricatedMsgOB;
    internal ArrayList m_fabricatedMsgOBList;
    internal bool m_maxOpenCursorsFetched;
    internal ObxmlTokenManager m_xmlTokenManager;
    internal TableColumnsCache m_tableColumnsCache;
    private SyncDictionary`2<string, SQLLocalParsePrimaryKeyInfoPool> m_dictStatementmetadatacache;
    private object m_dictStatementmetadatacacheLock;
    private SQLParseInfoPool m_sqlParseInfoPool;
    private bool m_isDisposed;
    internal bool m_bSelfTuning;
    private object m_tuningLock;
    internal int m_recommendedSCS;
    private int m_maxAllowedCursors;
    public int MaxAllowedValue { get; public set; }
    public string ID { get; }
    private static OraclePoolManager();
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.OraclePoolManager/<CreateNewPRAsync>d__0")]
public virtual ValueTask`1<PMCNPR_RefAndOutParamArgCtx<OraclePoolManager, OraclePool, OracleConnectionImpl>> CreateNewPRAsync(int reqCount, bool bForPoolPopulation, ConnectionString csWithDiffOrNewPassw, OracleConnection connRefForCriteria, bool bIncrSemObtained, bool bMaxSemObtained, bool bIgnoreIdleSem, PMCNPR_RefAndOutParamArgCtx<OraclePoolManager, OraclePool, OracleConnectionImpl> pmcnpr_refOutctx, string instanceName, List`1<string> switchFailedInstNames, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.OraclePoolManager/<GetAsync>d__1")]
public virtual ValueTask`1<OracleConnectionImpl> GetAsync(ConnectionString csWithNewPassw, bool bGetForApp, OracleConnection connRefForCriteria, string affinityInstanceName, bool bForceMatch, bool bAsync);
    internal UDTNamedType GetUDTType(OracleConnection conn, string schemaName, string typeName);
    internal UDTNamedType GetUDTType(OracleConnection conn, UDTSQLName sqlName);
    internal UDTSQLName GetUDTSQLName(OracleConnection conn, Byte[] toid);
    internal UDTNamedType AddUDTType(OracleConnection conn, UDTNamedType udtType);
    internal void GetUDTMetaData(OracleConnection conn, UDTNamedType udtType);
    internal virtual void Initialize(ConnectionString cs, OracleConnection con);
    internal void InitializeSEPSCredentials(SqlNetOraConfig SNOConfig, string WalletLocation, bool WalletOverride);
    internal static void FetchSEPSCredentails(SqlNetOraConfig DynSNOConfig, string ds, String& seps_userId, OracleOpaqueString& seps_opaque_passw, String& walletPath, String& walletFile, string WalletLocation);
    internal virtual void InitializeSelfTuning();
    public virtual void MarkAllPRsForDeletion(DateTime haEventUtcDateTime, bool isHAEvnt);
    public virtual void ClearAllPools(OracleConnectionImpl pr, bool isHAEvnt);
    internal virtual bool Close(OracleConnectionImpl con, OracleConnection connRefForCriteria, bool isConnectionCheckedout, bool bCallRemoveCheckedOutPR, bool bReleaseMaxSemaphore);
    public virtual PMCNPR_RefAndOutParamArgCtx<OraclePoolManager, OraclePool, OracleConnectionImpl> CreateNewPR(int reqCount, bool bForPoolPopulation, ConnectionString csWithDiffOrNewPassw, OracleConnection connRefForCriteria, bool bIncrSemObtained, bool bMaxSemObtained, bool bIgnoreIdleSem, PMCNPR_RefAndOutParamArgCtx<OraclePoolManager, OraclePool, OracleConnectionImpl> pmcnpr_refOutctx, string instanceName, List`1<string> switchFailedInstNames, bool bAsync);
    public virtual OracleConnectionImpl Get(ConnectionString csWithNewPassw, bool bGetForApp, OracleConnection connRefForCriteria, string affinityInstanceName, bool bForceMatch, bool bAsync);
    public virtual OracleConnectionImpl GetUsingDiffPassword(ConnectionString csWithDiffPassw, OracleConnection connRefForCriteria);
    public virtual void Put(OracleConnectionImpl con, OracleConnection connRefForCriteria);
    public virtual bool RemoveCheckedInPR(OracleConnectionImpl pr, bool bForce);
    public virtual bool RemoveCheckedOutPR(OracleConnectionImpl pr, bool bForce);
    internal bool TryRetrieveLocalParseInfoFromCache(string serviceName, string cmdText, SQLMetaData& sqlMetaData);
    internal bool TryRetrievePrimaryKeyInfoFromCache(string serviceName, string cmdText, SQLMetaData& sqlMetaData);
    internal void TryCacheLocalParsePrimaryKeyInfo(string serviceName, string cmdText, SQLMetaData sqlMetaData);
    internal bool TryGetSqlWithRowId(String& cmdText, Boolean& hadRowId, Boolean& addedRowId);
    internal void CacheSqlWithRowIdInfo(string cmdText, string cmdTextWithRowId, bool hasRowId);
    protected virtual override void Finalize();
    internal void Dispose();
    public int get_MaxAllowedValue();
    public void set_MaxAllowedValue(int value);
    public string get_ID();
    internal void AddTopology(OracleConnectionImpl connImpl);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<PMCNPR_RefAndOutParamArgCtx<OraclePoolManager, OraclePool, OracleConnectionImpl>> <>n__0(int reqCount, bool bForPoolPopulation, ConnectionString csWithDiffOrNewPassw, OracleConnection connRefForCriteria, bool bIncrSemObtained, bool bMaxSemObtained, bool bIgnoreIdleSem, PMCNPR_RefAndOutParamArgCtx<OraclePoolManager, OraclePool, OracleConnectionImpl> pmcnpr_refOutctx, string instanceName, List`1<string> switchFailedInstNames, bool bAsync);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private ValueTask`1<OracleConnectionImpl> <>n__1(ConnectionString csWithDiffOrNewPassw, bool bGetForApp, OracleConnection connRefForCriteria, string affinityInstanceName, bool bForceMatch, bool bAsync);
}
internal class OracleInternal.ConnectionPool.Pool`3 : object {
    public PM m_pm;
    public SyncQueueList`1<PR> m_cpListPR;
    public SyncQueueList`1<PR> m_cpQueuePR;
    public DateTime m_lastDequeueTime;
    public int m_lastDequeuedIdleTime;
    public string m_instanceName;
    public string m_serviceName;
    public DateTime m_lastHADownEventUtcDateTime;
    public bool m_bInstanceDown;
    internal bool HasValidConnections { get; }
    internal bool get_HasValidConnections();
    public virtual void PutNewPR(PR pr, bool bForPoolPopulation);
    public virtual void Put(PR pr);
    internal static void MatchCriteria(PR pr, PR& bestMatchingPR, UInt32& bitRepForBestMatchPR, OracleConnection connRefForCriteria, bool prForDTXN);
    internal void GetMatchingPR(PR& bestMatchingPR, OracleConnection connRefForCriteria);
    public virtual PR Get(OracleConnection connRefForCriteria);
    public PR GetProxy(ConnectionString cs, OracleConnection connRefForCriteria);
    public void MarkAllPRsForDeletion(DateTime haEventUtcDataTime, bool isHAEvnt);
    public void ClearPool(PR prToRetain, bool isHAEvnt);
    protected virtual override void Finalize();
}
internal abstract class OracleInternal.ConnectionPool.PoolManager`3 : object {
    public ConnectionPoolId m_conPoolKey;
    public OracleAccessToken m_accessToken;
    public TokenConfiguration m_tokenConfiguration;
    public OracleTokenAuth m_tokenAuth;
    public SemaphoreSlim m_interactiveTokenObtained;
    public SyncDictionary`2<string, SyncDictionary`2<string, CP>> m_dictDictCP;
    public SyncDictionary`2<string, SyncDictionary`2<string, TransactionContext`3<PM, CP, PR>>> m_dictDictTxnCtx;
    public SyncQueueList`1<CP> m_pmListCP;
    public SyncQueueList`1<PR> m_pmListPR;
    public SyncQueueList`1<CP> m_pmDeactivatedCP;
    public SyncQueueList`1<TransactionContext`3<PM, CP, PR>> m_pmListTxnCtx;
    public SyncDictionary`2<string, ServiceCtx> m_dictSvcCtx;
    private static ReaderWriterLockSlim m_serviceDomainDictLocker;
    private static SyncDictionary`2<string, string> m_serviceDSDict;
    private static SyncDictionary`2<string, string> m_domainDSDict;
    internal SyncDictionary`2<string, string> m_defaultEditionDict;
    internal object m_syncObjForDefaultSvcRelocWait;
    public ConnectionString m_cs;
    internal bool m_bHAEnabled;
    internal bool m_bUsingSEPSCredentials;
    internal bool m_bSEPSForProxyCredentials;
    internal bool m_bSEPSCredentialsFetched;
    internal SqlNetOraConfig m_SNOConfigForSEPS;
    internal Nullable`1<bool> m_bReadOnlyChunkOK;
    internal OracleCredential m_orclCredential;
    public OracleOpaqueString m_opaquePassw;
    public OracleOpaqueString m_opaqueProxyPassw;
    private object m_creationSync;
    private object m_syncPRClose;
    private object m_txnAffinityLock;
    private object m_syncTxnCtx;
    internal Timer m_timer;
    internal bool m_bDefaultsFetched;
    internal string m_databaseDomainName;
    internal string m_databaseName;
    internal string m_connectedUserName;
    internal bool m_bConnectedUserNameProcessed;
    internal object m_userNameSync;
    internal string m_conStrServiceName;
    internal string m_conStrPdbName;
    public int m_drain_timeout;
    internal object m_conStrDefaultsLocker;
    internal object m_defaultEditionLocker;
    internal bool b_setUseHourOffset;
    public Semaphore m_semIdleResource;
    public Semaphore m_semMaxPoolSize;
    public Semaphore m_semIncrPoolSize;
    public WaitHandle[] m_IdleAndIncrHandles;
    public WaitHandle[] m_IdleAndMaxHandles;
    public WaitHandle[] m_IdleAndConCreatedHandles;
    public Semaphore m_semPoolPopulation;
    public string m_serverVersion;
    public string m_fullDescriptor;
    internal int m_SDU;
    internal ConnectionOption m_connOpt;
    public string m_tnsAdmin;
    internal string m_walletLocation;
    public bool m_bKeepAlive;
    public int m_keepAliveTime;
    public int m_keepAliveInterval;
    internal string m_NamesDirectoryPath;
    internal string m_SSLCertificateThumbprint;
    internal string m_SqlNetAuthenticationServices;
    internal bool m_SqlnetWalletOverride;
    internal bool m_AllowCertSelectionUI;
    internal OracleTAFMode m_tafMode;
    public string m_connectionIdPrefix;
    public CP m_pmSingleCP;
    public TimeSpan m_timeoutValue;
    public string m_id;
    private int m_maxPoolSize;
    internal bool m_bSelfTuningDisabled;
    public int m_rlbMissCount;
    private static int MAX_RLB_MISS_COUNT;
    private int m_currentMaxSemCount;
    private int m_currentIncrSemCount;
    private int m_currentIdleSemCount;
    internal bool m_bResolveTnsAlias;
    internal Nullable`1<bool> m_bNAEInUse;
    private IntPtr pShardCtx;
    internal CriteriaMapper m_criteriaMapper;
    internal Dictionary`2<string, ClientInitiatedConnection> m_CQNListeners;
    internal Dictionary`2<int, NotificationRegistrationDetails> m_ntfRegistations;
    internal object m_syncCQNObject;
    internal short MAX_CQN_LISTENERS_PER_POOL;
    internal int MAX_REG_PER_CQN_LISTENER;
    internal static String[] m_criteriaArray;
    internal static Int32[] m_criteriaToCritTypeArray;
    internal static Int32[] m_criteriaToCritTypeForDTXN;
    internal object m_lockDeadConnectionScan;
    internal object m_lockUnPopulatePool;
    internal ShardRoutingCache m_shardRoutingCache;
    protected static SyncDictionary`2<string, SyncDictionary`2<string, ShardRoutingCache>> m_shardRoutingCacheDict;
    internal string m_chunkMigrationConTimeout;
    internal string m_drcpConnectionClass;
    internal bool b_useHourOffsetForUnsupportedTimezone;
    internal bool b_requireMatchCriteria;
    internal Thread m_cpThread;
    internal Semaphore m_semDedicatedThread;
    internal Object[] m_createConsArgs;
    internal ManualResetEventSlim m_eventCreateCons;
    internal ManualResetEventSlim m_eventSRCT;
    public ConnectionString ConnectionString { get; }
    private static PoolManager`3();
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.PoolManager`3/<CreateNewPRThreadFuncAsync>d__0")]
public ValueTask CreateNewPRThreadFuncAsync(object state);
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.PoolManager`3/<ConnectWithNoTimeoutAsync>d__1")]
internal ValueTask`1<PR> ConnectWithNoTimeoutAsync(PR pr, string instanceName, ConnectionString csWithDiffOrNewPassw, bool bForPoolPopulation, OracleConnection connRefForCriteria, bool bIncrSemObtained, bool bMaxSemObtained, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.PoolManager`3/<CreateNewPRAsync>d__2")]
public virtual ValueTask`1<PMCNPR_RefAndOutParamArgCtx<PM, CP, PR>> CreateNewPRAsync(int reqCount, bool bForPoolPopulation, ConnectionString csWithDiffOrNewPassw, OracleConnection connRefForCriteria, bool bIncrSemObtained, bool bMaxSemObtained, bool bIgnoreIdleSem, PMCNPR_RefAndOutParamArgCtx<PM, CP, PR> pmcnpr_refOutctx, string instanceName, List`1<string> switchFailedInstNames, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.PoolManager`3/<DestoryAndReplaceAsync>d__3")]
private ValueTask`1<PR> DestoryAndReplaceAsync(ConnectionString csWithDiffOrNewPassw, OracleConnection connRefForCriteria, string affinityInstanceName, List`1<string> switchFailedInstNames, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.PoolManager`3/<GetAsync>d__4")]
public virtual ValueTask`1<PR> GetAsync(ConnectionString csWithDiffOrNewPassw, bool bGetForApp, OracleConnection connRefForCriteria, string affinityInstanceName, bool bForceMatch, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.PoolManager`3/<GetNewAsync>d__5")]
internal ValueTask`1<PR> GetNewAsync(ConnectionString cs, OracleConnection connRefForCriteria, string instanceName, List`1<string> switchFailedInstNames, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.PoolManager`3/<ReleaseSemaphoreIfNecessary>d__112")]
internal Task ReleaseSemaphoreIfNecessary(Task task, SemaphoreSlim sem, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ConnectionPool.PoolManager`3/<WaitOnMultipleSems>d__113")]
internal Task`1<int> WaitOnMultipleSems(SemaphoreSlim[] sems, bool bAsync);
    internal string GetCQNListenerClientId();
    internal void AddCQNRestration(string listenerClientId, int registrationId, ClientInitiatedConnection clientConn);
    internal void RemoveCQNRestration(string listenerClientId, int registrationId);
    internal void CreateConsUsingDedicatedThread(object state);
    internal void DedicatedThreadFunc(object state);
    internal void CreateIncrPoolSizeCons(OracleConnection connRefForCriteria, int pmListPRCount);
    internal virtual void ResolveTnsAlias(ConnectionString cs, object OC);
    internal virtual void Initialize(ConnectionString cs, OracleConnection con);
    internal virtual void InitializeSelfTuning();
    public ConnectionString get_ConnectionString();
    public int GetNumberOfIdleConnections();
    public void UnPopulatePoolThreadFunc(object state);
    public int UnPopulatePool(object state);
    public void PopulatePoolThreadFunc(object state);
    public int PopulatePool(object state);
    public virtual void PutCP(PR pr, CP cp);
    public virtual void PutNewPR(PR pr, bool bForPoolPopulation);
    public void SetServiceForDS(string dataSource, string serviceName);
    public string GetServiceForDS(string dataSource);
    public void SetDomainForDS(string dataSource, string domainName);
    public string GetDomainForDS(string dataSource);
    private void AddPRToPool(PR pr, bool bForPoolPopulation, bool migratePR);
    private void CreateServiceCtx(PR pr);
    public void TreatConnectionCreationAsUpEvent(PR pr);
    public void CreateNewPRThreadFunc(object state);
    internal PR ConnectWithNoTimeout(PR pr, string instanceName, ConnectionString csWithDiffOrNewPassw, bool bForPoolPopulation, OracleConnection connRefForCriteria, bool bIncrSemObtained, bool bMaxSemObtained, bool bAsync);
    public virtual PMCNPR_RefAndOutParamArgCtx<PM, CP, PR> CreateNewPR(int reqCount, bool bForPoolPopulation, ConnectionString csWithDiffOrNewPassw, OracleConnection connRefForCriteria, bool bIncrSemObtained, bool bMaxSemObtained, bool bIgnoreIdleSem, PMCNPR_RefAndOutParamArgCtx<PM, CP, PR> pmcnpr_refOutctx, string instanceName, List`1<string> switchFailedInstNames, bool bAsync);
    public virtual PR GetUsingDiffPassword(ConnectionString csWithDiffOrNewPassw, OracleConnection connRefForCriteria);
    public PR GetIdleConnectionToKill(TimeSpan ts, bool bIdleSemObtained, List`1<string> instancesToSkip);
    internal static List`1<ShardRoutingCache> GetSharedShardRoutingCaches(string databaseName);
    protected void CreateSharedShardRoutingCache(PR conn);
    public String[] GetShardInstances(OracleConnection connRefForCriteria);
    public String[] GetShardInstancesEx(OracleConnection con, String& chunkName, Int32& chunkId, String[]& readOnlyInstances, InstanceInfo[]& instanceInfos);
    public void OnShardingError(int errorCode, string instanceName, string chunkName);
    public PR GetPRForSharding(ConnectionString csWithDiffOrNewPassw, string requestedServiceName, String[] instanceNames, OracleConnection connRefForCriteria, List`1<string> instancesToSkip);
    public PR GetPRWithMatchingServiceOrInstance(ConnectionString csWithDiffOrNewPassw, List`1<string> services, string serviceName, string instanceName, OracleConnection connRefForCriteria, List`1<string> instancesToSkip);
    private PR DestoryAndReplace(ConnectionString csWithDiffOrNewPassw, OracleConnection connRefForCriteria, string affinityInstanceName, List`1<string> switchFailedInstNames, bool bAsync);
    public virtual PR Get(ConnectionString csWithDiffOrNewPassw, bool bGetForApp, OracleConnection connRefForCriteria, string affinityInstanceName, bool bForceMatch, bool bAsync);
    internal string GetInstanceNameToConnect(string requestedServiceName, List`1<string> instancesToSkip, Boolean& firstConn);
    private List`1<string> GetInstNames();
    internal void ProcessCriteriaCtx_EnlistedConnection(OracleConnection connRefForCriteria);
    internal void ProcessCriteriaCtx_NonEnlistedConnection(OracleConnection& connRefForCriteria);
    internal virtual void ProcessCriteriaCtxAndAlterSessionIfReqd(OracleConnection connRefForCriteria, PR pr);
    internal PR GetNew(ConnectionString cs, OracleConnection connRefForCriteria, string instanceName, List`1<string> switchFailedInstNames, bool bAsync);
    public virtual bool RemoveCheckedInPR(PR pr, bool bForce);
    public virtual bool RemoveCheckedOutPR(PR pr, bool bForce);
    internal virtual bool Close(PR pr, OracleConnection connRefForCriteria, bool isConnectionCheckedout, bool bCallRemoveCheckedOutPR, bool bReleaseMaxSemaphore);
    public virtual void Put(PR pr, OracleConnection connRefForCriteria);
    public virtual void MarkAllPRsForDeletion(DateTime haEventUtcDateTime, bool isHAEvnt);
    public virtual void ClearAllPools(PR pr, bool isHAEvnt);
    internal PR GetEnlisted(ConnectionString csWithDiffOrNewPassw, bool bGetForApp, OracleConnection connRefForCriteria);
    internal PR GetEnlisted(Transaction txn, string affinityInstance, int branchNum, bool bMustMatch, Boolean& bMatchFound, string serviceName, string pdbName);
    internal void InitializePSPEConn(Transaction txn, PR pr);
    internal MTSTxnRM GetRM(Transaction txn, OracleConnection connRefForCriteria, PR pr);
    internal void RemoveRM(string serviceName, Transaction txn);
    private void RLBGravitateThreadFunc(object state);
    private void RLBGravitateTrace(RLB rlb);
    internal void RemoveAndRedistribute(RLB rlb, CP cp, int indexToBeRemoved);
    internal void RemoveDeadConnections(PR pr);
}
internal enum OracleInternal.ConnectionPool.PoolManagerDispenseType : Enum {
    public int value__;
    public static PoolManagerDispenseType RoundRobin;
    public static PoolManagerDispenseType RLB;
    public static PoolManagerDispenseType DistribTransNodeAffnity;
}
internal class OracleInternal.ConnectionPool.PoolPopulationOption : object {
    public int m_requestCount;
    public int m_targetCount;
    public Semaphore m_semPoolPopulation;
    public string m_connectionClass;
    public bool m_ignoreIncrPoolSize;
    public PoolPopulationOption(int requestCount, int targetCount, Semaphore semPoolPopulation, bool ignoreIncrPoolSize, string connectionClass);
}
internal class OracleInternal.ConnectionPool.PoolResource`3 : object {
    public DateTime m_checkinTime;
    public DateTime m_creationTime;
    public string m_databaseDomainName;
    public string m_instanceName;
    public string m_databaseName;
    public string m_hostName;
    public PM m_pm;
    public CP m_cp;
    public DeletionRequestor m_deletionRequestor;
    public ConnectionString m_cs;
    public ManualResetEvent m_eventConCreated;
    public ManualResetEventSlim m_eventConTimeout;
    public SemaphoreSlim m_semConCreated;
    public bool m_bTimedOut;
    public int m_conTimeout;
    public Exception m_exception;
    public string m_id;
    public DateTime m_lastCheckOutTime;
    public bool m_bEndUserSessionEstablished;
    public int m_endUserSessionId;
    internal int m_endUserSerialNum;
    public int m_pxyUserSessionId;
    internal int m_pxyUserSerialNum;
    internal bool m_bPutCompleted;
    internal bool m_bCheckedOutByApp;
    internal bool m_bCheckedOutByDTC;
    internal bool m_bClosedWithReplacement;
    internal bool m_bDynamicallyEnlisted;
    internal MTSTxnCtx m_mtsTxnCtx;
    internal TransactionContext`3<PM, CP, PR> m_txnCtx;
    internal bool m_bPickedFromResourcePool;
    internal SessionType m_sessionType;
    internal int m_dbMajorVersion;
    internal int m_dbMinorVersion;
    internal int m_dbPatchsetVersion;
    internal string m_localTxnId;
    internal string m_affinityInstance;
    internal OracleIntervalDS m_sessionTimeZone;
    internal int m_resPoolRefCount;
    internal bool m_bTxnCtxPrimaryCon;
    internal bool m_isDb10gR2OrHigher;
    internal bool m_isDb11gR1OrHigher;
    internal bool m_isDb12cR1OrHigher;
    internal string m_connectionClass;
    internal bool bGotMatchingServerProcess;
    internal bool bDRCPServerProcessAttached;
    internal UInt32[] m_criteriaIds;
    internal bool bSessionSwitched;
    internal bool m_bCheckIfAlterSessionReqd;
    internal string m_preFailoverInstName;
    internal bool m_failoverOccured;
    internal int requestingThreadId;
    public bool m_bReconnectAtNullState;
    internal bool NTS { get; }
    internal string ServiceName { get; }
    internal string PdbName { get; }
    internal string EditionName { get; }
    public virtual ValueTask ConnectAsync(ConnectionString cs, bool bForPoolPopulation, OracleConnection connRefForCriteria, string instanceName, bool bAsync);
    public virtual void Connect(ConnectionString cs, bool bForPoolPopulation, OracleConnection connRefForCriteria, string instanceName, bool bAsync);
    public virtual void AttachServerProcess(long sessionFlags, bool bUseDRCPMultiTag, Int64& s2cSessionFlags);
    public virtual void DetachServerProcess(string drcpTagName, bool bUseDRCPMultiTag);
    internal virtual void BeginRequest(bool bNoOpenHandles);
    internal virtual void EndRequest();
    public virtual void DisConnect(OracleConnection connRefForCriteria);
    public virtual bool Dump();
    internal virtual bool PingServer();
    internal virtual bool IsTAFEnabled();
    internal virtual bool TransportAlive();
    internal virtual void GetAttributes();
    internal virtual void UpdateAttributes();
    internal virtual void GetConStrDefaults();
    internal virtual string GetDefaultEditionName();
    internal virtual Boolean[] ProcessCriteriaCtx(OracleConnection connRefForCriteria);
    internal virtual bool AlterSession(Boolean[] alterConnectionTuple, OracleConnection connRefForCriteria);
    internal virtual bool get_NTS();
    internal virtual string get_ServiceName();
    internal virtual string get_PdbName();
    internal virtual string GetPdbNameFromDb();
    internal virtual string get_EditionName();
}
internal class OracleInternal.ConnectionPool.RLB : object {
    internal static string s_pattern;
    public bool m_bStatus;
    public float m_version;
    public string m_database;
    public string m_service;
    internal String[] m_instances;
    public Int32[] m_percentages;
    public Int32[] m_rlbPercentages;
    private string m_timestamp;
    private string m_timeZone;
    internal DateTime m_dateTime;
    public Int32[] m_dispenseCounter;
    internal List`1<string> m_removedInstances;
    internal DateTime m_lastUpdateTime;
    public string m_id;
    private RNGCryptoRandom m_random;
    private static DateTimeFormatInfo s_dfi;
    internal object m_syncObject;
    private Dictionary`2<string, RLB> m_snapshotCache;
    private ReaderWriterLockSlim rwLock;
    private static int rwLockTimeout;
    private static RLB();
    internal RLB(string message);
    private RLB(RLB source, List`1<string> instanceNames);
    internal string GetInstanceName(Int32& currentIndex);
    internal RLB GetSnapshot(List`1<string> instanceNames);
    internal bool Parse(string message);
}
internal enum OracleInternal.ConnectionPool.RLBFlag : Enum {
    public int value__;
    public static RLBFlag GOOD;
    public static RLBFlag BLOCKED;
    public static RLBFlag VIOLATING;
    public static RLBFlag NO_DATA;
    public static RLBFlag UNKNOWN;
}
internal static class OracleInternal.ConnectionPool.RLBManager : object {
    private static SyncDictionary`2<string, RLB> m_rlbData;
    private static RLBManager();
    public static RLB Put(string message);
    public static RLB Get(string id);
    public static void InvalidateRLBData(string id);
}
internal class OracleInternal.ConnectionPool.RoundRobin : object {
    private object m_sync;
    private int m_mod;
    private int m_count;
    public int NextValue();
    public int NextValue(int val);
    public void SetMax(int exclusiveMax);
}
internal class OracleInternal.ConnectionPool.ServiceCtx : object {
    internal string m_databaseName;
    internal ManualResetEventSlim m_serviceUpEvent;
    internal DateTime m_serviceDownTime;
    internal bool m_bWaitedForSvcReloc;
    internal RoundRobin m_roundRobin;
    internal OracleGlobalizationImpl m_orclGlobImpl;
    internal bool m_serviceDown;
    internal SyncQueueList`1<string> m_serviceMemberDownInstNames;
    internal DateTime m_serviceMemberDownLastUpdateUtcTime;
    internal DateTime m_serviceDownLastUpdateUtcTime;
    internal object m_sync;
    internal string m_serviceName;
    internal ServiceCtx(string serviceName);
    internal void CheckAndUpdateServiceMemberDOWNNames_RLB(RLB rlb);
    internal void CheckAndUpdateServiceMemberDOWNNames_HA(string instName, bool serviceMemberDown, DateTime eventTime);
    internal void UpdateServiceDown(bool isServiceDown, DateTime eventTime);
}
internal class OracleInternal.ConnectionPool.TransactionContext`3 : object {
    private static int s_maxBranchCount;
    internal int m_maxBranchIndex;
    internal PR[] m_enlistedPRList;
    internal MTSTxnRM m_mtsTxnRM;
    internal object m_syncMTSTxnRM;
    internal string m_affinityInstanceName;
    internal string m_localTxnId;
    internal OraclePoolManager m_pm;
    internal object m_syncStats;
    internal List`1<string> m_instances;
    internal string m_id;
    public TransactionContext`3(PM pm, string localTxnId);
    public void ReInitialize(PM pm, Transaction txn);
    internal MTSTxnRM GetRM(ConnectionString cs, string serviceName, string pdbName, Transaction txn);
    internal void RemoveRM();
    internal PR GetEnlisted(ConnectionString csWithDiffPassw, bool bGetForApp, OracleConnection connRefForCriteria, string instanceName, bool bEnforceAffinity);
    internal PR GetEnlisted(string affinityInstance, int branchNum, bool bMustMatch, Boolean& bMatchFound);
    internal string GetListForTrace();
    private bool CanReturnPR(PR pr, OracleConnection connRefForCriteria);
}
internal class OracleInternal.ConnectionPool.UnPopulatePoolArgs : object {
    internal string m_instanceName;
    internal int m_decrementCount;
    internal string m_serviceName;
    public UnPopulatePoolArgs(string serviceName, string instanceName, int decrementCount);
}
internal class OracleInternal.ConnectionPool.UrlProviderCache : Pooler`2<int, List`1<UrlProviderInfo>> {
    private object m_lock;
    private AbstractURLWatcher ociWatcher;
    private AbstractURLWatcher azureWatcher;
    public UrlProviderCache(int maxCacheSize);
    internal void RegisterForChangeNotifications(ConfigUrl configUrl);
    internal void UnregisterForChangeNotifications(ConfigUrl configUrl);
    internal void MarkDirty(ConfigUrl configUrl);
    internal void TraceAzureMessageError(string ErrorSource, string FullyQualifiedNamespace, string EntityPath, string Exception);
    internal bool RemoveUrlProvider(ProviderUrl connStrUrl);
    internal UrlProviderInfo Get(UrlProviderType providerType, string userProvidedConnStr, UrlProviderRequestType requestType, bool bRemoteConfigurationFiltering, string connTnsAdmin);
    internal UrlProviderInfo FindMatch(UrlProviderInfo matchProviderInfo);
    internal void UpdatePassws(UrlConnInfo connInfoWithUpdatedPassws);
}
internal class OracleInternal.Core.OracleNumberCore : object {
    private static int LNXSGNBT;
    private static int LNXEXPMN;
    private static int LNXEXPMX;
    private static int LNXBASE;
    private static byte LNXEXPBS;
    private static byte LNXDIGS;
    private static int LNXQTRIPREC;
    private static int LNXQTRIMAXITER;
    private static Byte[] lnxqone;
    private static Byte[] lnxqtwo;
    private static int LNXQACOS;
    private static int LNXQASIN;
    private static int LNXQATAN;
    private static int LNXQCOS;
    private static int LNXQSIN;
    private static int LNXQTAN;
    private static int LNXQCSH;
    private static int LNXQSNH;
    private static int LNXQTNH;
    private static int LNXQEXP;
    private static double ORANUM_FBASE;
    internal static Byte[] PI;
    internal static Byte[] E;
    internal static Byte[] LN10;
    internal static Byte[] NANREPD;
    private static int LNXM_NUM;
    private static int LNXBYTEMASK;
    private static int LNXSHORTMASK;
    private static int LNXDIV_LNXBASE_SQUARED;
    private static int MINUB1MAXVAL;
    private static Byte[] MAX_LONG;
    private static Byte[] MIN_LONG;
    private static Byte[][] LnxqAdd_PPP;
    private static Byte[][] LnxqAdd_NNN;
    private static Byte[][] LnxqAdd_PNP;
    private static Byte[][] LnxqAdd_PNN;
    private static Double[][] powerTable;
    private static Byte[] LnxqNegate;
    private static Byte[] LnxqTruncate_P;
    private static Byte[] LnxqTruncate_N;
    private static Byte[] LnxqFirstDigit;
    private static Double[][] factorTable;
    private static Byte[] LnxqRound_P;
    private static Byte[] LnxqRound_N;
    private static Byte[][] LnxqComponents_P;
    private static Byte[][] LnxqComponents_N;
    private static Byte[][] LnxqDigit_P;
    private static Byte[][] LnxqDigit_N;
    private static OracleNumberCore();
    internal static bool IsPositive(Byte[] byteRep);
    internal static bool IsZero(Byte[] byteRep);
    internal static bool IsInfinity(Byte[] byteRep);
    internal static bool IsInt(Byte[] byteRep);
    internal static bool IsPositiveInfinity(Byte[] byteRep);
    internal static bool IsNegativeInfinity(Byte[] byteRep);
    internal static bool IsNaN(Byte[] byteRep, int offset, int len);
    internal static Byte[] GetPositiveInfinityByteRep();
    internal static Byte[] GetNegativeInfinityByteRep();
    internal static Byte[] GetZeroByteRep();
    internal static Byte[] GetByteRep(double doubleNum);
    public static bool isValid(Byte[] num);
    internal static SByte[] FromLnxFmt(Byte[] num);
    internal static Byte[] ToLnxFmt(Byte[] num, bool pos);
    private static Byte[] SetLength(Byte[] oranum, int size);
    internal static Byte[] lnxmin(long longNum);
    internal static Byte[] lnxren(double doubleNum);
    internal static long lnxsni(Byte[] num);
    internal static double lnxnur(Byte[] num);
    internal static void NegateNumber(Byte[] oranum);
    internal static Byte[] lnxabs(Byte[] n);
    internal static Byte[] lnxneg(Byte[] n);
    internal static Byte[] lnxadd(Byte[] n1, Byte[] n2);
    internal static Byte[] lnxsub(Byte[] n1, Byte[] n2);
    internal static Byte[] lnxmul(Byte[] n1, Byte[] n2);
    internal static Byte[] lnxdiv(Byte[] n1, Byte[] n2);
    internal static Byte[] lnxmod(Byte[] n1, Byte[] n2);
    internal static Byte[] lnxsqr(Byte[] n);
    internal static Byte[] lnxceil(Byte[] n);
    internal static Byte[] lnxshift(Byte[] n, int nDig);
    internal static Byte[] lnxfpr(Byte[] n, int precision);
    internal static Byte[] lnxflo(Byte[] n);
    internal static Byte[] lnxrou(Byte[] n, int decimal_place);
    internal static Byte[] lnxtru(Byte[] n, int decimal_place);
    internal static Byte[] lnxpow(Byte[] n, int power);
    internal static Byte[] lnxbex(Byte[] b, Byte[] n);
    internal static Byte[] lnxln(Byte[] n);
    internal static Byte[] lnxlog(Byte[] n, Byte[] b);
    internal static Byte[] lnxexp(Byte[] n);
    internal static Byte[] lnxsin(Byte[] n);
    internal static Byte[] lnxsnh(Byte[] n);
    internal static Byte[] lnxasin(Byte[] n);
    internal static Byte[] lnxcos(Byte[] n);
    internal static Byte[] lnxcsh(Byte[] n);
    internal static Byte[] lnxacos(Byte[] n);
    internal static Byte[] lnxtan(Byte[] n);
    internal static Byte[] lnxatan(Byte[] n);
    internal static Byte[] lnxatan2(Byte[] y, Byte[] x);
    internal static Byte[] lnxtnh(Byte[] n);
    private static int LnxmulSetSum(Int32[] ptr1, Int32[] ptr2, int index1, int index2, int element, int sum);
    private static int LnxmulSetDigit1(Byte[] rslBuf, int index, int sum);
    private static void LnxmulSetDigit2(Byte[] rslBuf, int index, int sum);
    internal static int compareBytes(Byte[] abyte0, Byte[] abyte1);
    private static int lnxcmp(Byte[] n1, Byte[] n2);
    private static int lnxsgn(Byte[] n);
    private static Byte[] lnxqIDiv(Byte[] y, int x);
    private static Byte[] lnxqtra(Byte[] n, int funcid);
    private static Byte[] lnxqtri(Byte[] n, int funcid);
}
internal static class OracleInternal.EntityFramework.EFProviderSettings : object {
    internal static int ODP_NOT_SUPPORTED;
    internal static int ODP_INVALID_VALUE;
    internal static int EF_NILADIC_FUNCTION;
    internal static int EF_READ_ONLY_ENTITY;
    internal static IEFProviderSettings Instance;
    internal static bool s_tracingEnabled;
    internal static void InitializeProviderSettings();
}
internal abstract class OracleInternal.I18N.Conv : object {
    public static int CONCAIN_CHARSET_TABLE;
    public static int AL16UTF16_CHARSET;
    public static int AL16UTF16LE_CHARSET;
    public static int UNICODE_1_CHARSET;
    public static int UNICODE_2_CHARSET;
    public static int UTFE_CHARSET;
    public static int AL32UTF8_CHARSET;
    public static int ISO2022JP_CHARSET;
    public static int ISO2022_JP_OUTLOOK_CHARSET;
    public static int ISO2022_JP_OUTLOOK_HWKANA_CHARSET;
    public static char UTF16_REPLACEMENT_CHAR;
    public static byte UTF16_REPLACEMENT_HIGH_BYTE;
    public static byte UTF16_REPLACEMENT_LOW_BYTE;
    public static int WE8DECTST;
    public static int ZHT32EUCTST;
    public static int WE16DECTST2;
    public static int WE16DECTST;
    public static int KO16TSTSET;
    public static int JA16TSTSET2;
    public static int JA16TSTSET;
    public static int US16TSTFIXED;
    public static int UTF16;
    public static int HZ_GB_2312;
    public static int ISO2022_KR;
    public static int ISO2022_CN;
    public static bool USE_REPLACEMENT;
    private static int s_charsRequestedLength;
    protected static Byte[] REP_CHAR_UTF8;
    private static Dictionary`2<int, Conv> s_oraCharsetCache;
    private static TLBConvBoot s_bootObj;
    private static HashSet`1<int> UNSUPPORTED_CHARSET;
    [CompilerGeneratedAttribute]
private int <OracleId>k__BackingField;
    public int OracleId { get; public set; }
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    protected Conv(int oracleId);
    private static Conv();
    [CompilerGeneratedAttribute]
public int get_OracleId();
    [CompilerGeneratedAttribute]
public void set_OracleId(int value);
    public static Conv GetInstance(int charsetId);
    public abstract virtual int get_MinBytesPerChar();
    public abstract virtual int get_MaxBytesPerChar();
    public static int GetMaxBytesPerChar(int charsetId);
    public abstract virtual int ConvertBytesToChars(Byte[] bytes, int byteOffset, int byteCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    internal virtual int ConvertBytesToChars(Byte[] bytes, int byteOffset, int byteCount, Char[] chars, int charOffset, Int32& charCount, Boolean& shiftIn, bool bUseReplacementChar);
    public int ConvertBytesToChars(ArraySegment`1<byte> bytes, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public int ConvertBytesToChars(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public abstract virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    internal virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, Boolean& shiftIn, bool bUseReplacementChar);
    public int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public void ConvertBytesToStringSB(StringBuilder output, Byte[] bytes, int byteOffset, int byteCount, Int32& charsConverted, Char[] charOutput, int offsetOutput, DelegateReplaceCharsInSB replaceDelegate, bool bUseReplacementChar);
    public string ConvertBytesToString(Byte[] bytes, int byteOffset, int byteCount, Char[] chars, bool bUseReplacementChar);
    public string ConvertBytesToString(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, bool bUseReplacementChar);
    public string ConvertBytesToString(IList`1<ArraySegment`1<byte>> bytes, Char[] chars, bool bUseReplacementChar);
    public abstract virtual int ConvertBytesToUTF16(Byte[] bytes, int byteOffset, int byteCount, Byte[] utf16Bytes, int utf16BytesOffset, Int32& utf16BytesCount, bool bUseReplacementChar);
    public Byte[] ConvertBytesToUTF16(Byte[] bytes, int byteOffset, int byteCount, bool bUseReplacementChar);
    public abstract virtual int ConvertCharsToBytes(Char[] chars, int charOffset, int charCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public abstract virtual int ConvertStringToBytes(string str, int strOffset, int strCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public Byte[] ConvertCharsToBytes(Char[] chars, int charOffset, int charCount, bool bUseReplacementChar);
    public abstract virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public Byte[] ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, bool bUseReplacementChar);
    public Byte[] ConvertStringToBytes(string str, int strOffset, int strCount, bool bUseReplacementChar);
    public abstract virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    public abstract virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public int GetCharsLength(ArraySegment`1<byte> bytes);
    public abstract virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes);
    public abstract virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public abstract virtual int GetBytesLength(string str, int strOffset, int strCount);
    public abstract virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public abstract virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public abstract virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    internal virtual bool IsShitCharset();
}
internal class OracleInternal.I18N.I18nStringResourceManager : object {
    private static ResourceManager s_rm;
    internal static Type resourceStringConstants;
    private static I18nStringResourceManager();
    internal static ResourceManager Instance();
    internal static string GetErrorMesg(string errorcode, String[] args);
    internal static string GetErrorMesgWithErrCode(string errorcode, String[] args);
}
internal abstract class OracleInternal.I18N.TLBConv : Conv {
    public static int CHARCONV1BYTEID;
    public static int CHARCONV12BYTEID;
    public static int CHARCONVJAEUCID;
    public static int CHARCONVLCFIXEDID;
    public static int CHARCONVSJISID;
    public static int CHARCONVZHTEUCID;
    public static int CHARCONV2BYTEFIXEDID;
    public static int CHARCONVSHIFTID;
    public static int CHARCONVLCID;
    public static int CHARCONVGB18030ID;
    public static int CHARCONVAL16UTF16ID;
    public static int CHARCONVMSOLISO2022JPFWID;
    public static int CHARCONVMSOLISO2022JPHWID;
    public static int CHARCONVGBKID;
    private static string CONVERTERNAMEPREFIX;
    private static string CONVERTERIDPREFIX;
    public static byte UNDEFINED_DISPLAY_WIDTH;
    public static int BELOW_CJK;
    protected static int HIBYTEMASK;
    protected static int LOWBYTEMASK;
    protected static int STORE_INCREMENT;
    protected static char CHAR_INVALID_ORA_CHAR;
    protected static int FIRSTBSHIFT;
    protected static int SECONDBSHIFT;
    protected static int THIRDBSHIFT;
    protected static int UB2MASK;
    protected static int UB4MASK;
    protected static string BEGIN_UNISTR;
    protected static string END_UNISTR;
    private static Dictionary`2<string, TLBConv> m_converterStore;
    internal int m_groupId;
    public Int32[][] extraUnicodeToOracleMapping;
    protected TLBConv(int oracleId);
    private static TLBConv();
    public static TLBConv GetGLBInstance(int oraId);
    protected void StoreMappingRange(int ucsCodePt, Dictionary`2<int, Char[]> htable, Dictionary`2<int, Char[]> htable2);
    public int GetGroupId();
    public abstract virtual bool IsOraCharacterReplacement(char ch, char lowsur);
    public abstract virtual void BuildUnicodeToOracleMapping();
    public abstract virtual void ExtractCodepoints(IList`1<Int32[]> vtable);
    public abstract virtual void ExtractExtraMappings(IList`1<Int32[]> vtable);
    public abstract virtual bool HasExtraMappings();
    public abstract virtual char GetOraChar1ByteRep();
    public abstract virtual char GetOraChar2ByteRep();
    public abstract virtual int GetUCS2CharRep();
    public Char[] GetLeadingCodes();
}
internal class OracleInternal.I18N.TLBConv12Byte : TLBConv {
    private static int ORACHARMASK;
    private static int UCSCHARWIDTH;
    private static int ORACHARWIDTH;
    protected static int BYTEWIDTH;
    protected short MAX_7_8_BIT;
    protected static int MAXLIMIT;
    public Char[] m_ucsCharLevel1;
    public Int32[] m_ucsCharLevel2;
    public int m_ucsCharReplacement;
    public Int32[] m_oraCharLevel1;
    public Int32[] m_oraCharSurrogateLevel;
    public Char[] m_oraCharLevel2;
    public char m_1ByteOraCharReplacement;
    public Char[] m_2ByteOraCharReplacement;
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    private static TLBConv12Byte();
    protected int ToUnicode(int srcChar, bool ccb);
    private int ToUnicodeNoException(int srcChar);
    protected char ToOracleCharacter(char srcChar, char lowSurrogate, bool ccb);
    public virtual void BuildUnicodeToOracleMapping();
    public virtual void ExtractCodepoints(IList`1<Int32[]> vtable);
    public virtual void ExtractExtraMappings(IList`1<Int32[]> vtable);
    public virtual bool HasExtraMappings();
    public virtual char GetOraChar1ByteRep();
    public virtual char GetOraChar2ByteRep();
    public virtual int GetUCS2CharRep();
    public virtual bool IsOraCharacterReplacement(char ch, char lowsur);
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string chars, int charOffset, int charCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    protected virtual int GetCharsLengthImpl(Byte[] bytes, int offset, int count, Int32& bytesCounted);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    protected virtual int GetBytesOffsetImpl(Byte[] bytes, int offset, int count, Int32& charCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    public virtual int ConvertCharsToBytes(Char[] chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool bUseReplacementChar);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int ConvertStringToBytes(string chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool bUseReplacementChar);
    protected virtual int ConvertByteArraySegListToCharsImpl(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, T[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar, ConvertByteToCharsDelegate`1<T> t);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
}
internal class OracleInternal.I18N.TLBConv1Byte : TLBConv {
    private static int ORACHARMASK;
    private static int UCSCHARWIDTH;
    public int m_ucsReplacement;
    public Int32[] m_ucsChar;
    public Char[] m_oraCharLevel1;
    public Char[] m_oraCharSurrogateLevel;
    public Char[] m_oraCharLevel2;
    public byte m_oraCharReplacement;
    internal bool noSurrogate;
    internal bool strictASCII;
    internal int m_oraCharLevel2Size;
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    private int ByteToChar(byte srcChar, bool useReplacement);
    private byte CharToByte(char srcChar, char lowSurrogate, bool useReplacement);
    private byte CharToByte(char srcChar, bool useReplacement);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    public virtual int ConvertCharsToBytes(Char[] chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool ccb);
    public virtual int ConvertStringToBytes(string chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool ccb);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool ccb);
    public virtual bool IsOraCharacterReplacement(char ch, char lowsur);
    public virtual void BuildUnicodeToOracleMapping();
    public virtual void ExtractCodepoints(IList`1<Int32[]> vtable);
    public virtual void ExtractExtraMappings(IList`1<Int32[]> vtable);
    public virtual bool HasExtraMappings();
    public virtual char GetOraChar1ByteRep();
    public virtual char GetOraChar2ByteRep();
    public virtual int GetUCS2CharRep();
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string str, int strOffset, int strCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
}
internal class OracleInternal.I18N.TLBConvBoot : object {
    private static TLBConvBoot upCache;
    private static string FILENAME;
    public static int FLAG_FIXEDWIDTH;
    public static int FLAG_ASCII;
    public static int FLAG_EBCDIC;
    internal Dictionary`2<string, string> charSetIdMap;
    internal Dictionary`2<string, string> idtoCharSetMap;
    internal Dictionary`2<string, string> idtoCharSetMaxLen;
    internal IList`1<string> lstCharSetIsAscii;
    internal IList`1<string> lstCharSetIsEbcdic;
    internal IList`1<string> lstCharSetIsFixed;
    internal IList`1<string> lstCharSetIsStorage;
    internal String[] availableCharSet;
    public static TLBConvBoot GetInstance();
    public string GetCharSetFileName(string charSetName);
    public string GetCharSetId(string charSetName);
    public string GetCharSetName(string id);
    public string GetCharsetMaxCharLen(string id);
    public IList`1<string> GetCharSetIsAscii();
    public IList`1<string> GetCharSetIsEbcdic();
    public IList`1<string> GetCharSetIsFixed();
    public IList`1<string> GetCharSetIsStorage();
    public String[] GetAvailableCharacterSets();
    protected static string FormatFileName(string prefix, string id);
    public static object ReadObj(string entryName);
    public void SetAvailableCharSets(String[] array);
    public void setCharSet(Dictionary`2<string, string> h);
    public void setIdtoCharSet(Dictionary`2<string, string> h);
    public void setCharSetMaxLen(Dictionary`2<string, string> h);
    public void setCharSetFlags(IList`1<string> isAscii, IList`1<string> isEbcdic, IList`1<string> isFixed, IList`1<string> isStorage);
    public Dictionary`2<string, string> getCharSetName2IdMap();
}
internal class OracleInternal.I18N.TLBConvGB18030 : TLBConv12Byte {
    private static int GB18030_MAXLIMIT;
    private static long BMPSTART;
    private static UInt32 BMPEND;
    private static int GBBMPSTART;
    private static int GBBMPEND;
    private static int USURSTART;
    private static int USUREND;
    private static int GBSURSTART;
    private static int GBSUREND;
    private static Char[][] gbMappingO2U;
    private static Char[][] gbMappingU2O;
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    private static TLBConvGB18030();
    private int ToUnicodeGB(int srcChar, bool ccb);
    private int ToOracleCharacterGB(char srcChar, char lowSurrogate, bool ccb);
    private int GetCharsLengthGBImpl(Byte[] bytes, int offset, int count, Int32& bytesCounted);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    private int GetBytesOffsetGBImpl(Byte[] bytes, int offset, int count, Int32& charCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    protected virtual int ConvertByteArraySegListToCharsImpl(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, T[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar, ConvertByteToCharsDelegate`1<T> t);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string chars, int charOffset, int charCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int ConvertCharsToBytes(Char[] chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool ccb);
    public virtual int ConvertStringToBytes(string chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool ccb);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
    private int SurrogateUtf16ToUcs4(char highSur, char lowSur);
    private int SurrogateUcs4ToUtf16(int ucs4);
    private int BMPUnicode2Oracle(char uCodepoint);
    private int BMPOracle2Unicode(int oCodepoint);
    private int BMPLinear(int codepoint);
    private int BMPunLinear(int lin);
    private int SearchgbMapping(char codepoint, bool u2o);
    public virtual void BuildUnicodeToOracleMapping();
    public virtual void ExtractCodepoints(IList`1<Int32[]> vtable);
    public virtual void ExtractExtraMappings(IList`1<Int32[]> vtable);
}
internal class OracleInternal.I18N.TLBConvGBK : TLBConv12Byte {
}
internal class OracleInternal.I18N.TLBConvJAEUC : TLBConvLC {
    private static int LEADINGCODE;
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    private int ToUnicodeJAEUC(int srcChar, bool ccb);
    private int GetCharsLengthJAEUCImpl(Byte[] bytes, int offset, int count, Int32& bytesCounted);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    private int GetBytesOffsetJAEUCImpl(Byte[] bytes, int offset, int count, Int32& charCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    private int ConvertByteArraySegListToCharsImpl(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, T[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar, ConvertByteToCharsDelegate`1<T> t);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
    public virtual void ExtractCodepoints(IList`1<Int32[]> vtable);
}
internal abstract class OracleInternal.I18N.TLBConvLC : TLBConv {
    public static int MAX_7BIT;
    private static int ORACHARMASK;
    private static int UCSCHARWIDTH;
    private static int ORACHARWIDTH;
    private static int ORACHARWITHLCWIDTH;
    public static int BYTEWIDTH;
    private static int LOW16BITMASK;
    public static int LEADINGCODEWIDTH;
    public static int LEADINGCODESHIFT;
    public static int LEADINGCODEMASK;
    private static int LCINDEXWIDTH;
    private static int LCINDEXMASK;
    private static int LCINDEXFACTOR;
    private static int MAXBYTEPERCHAR;
    public Char[][] m_ucsCharLeadingCode;
    public Char[] m_ucsCharLevel1;
    public Int32[] m_ucsCharLevel2;
    public int m_ucsCharReplacement;
    public char m_1ByteOraCharReplacement;
    public char m_2ByteOraCharReplacement;
    public Char[] m_displayWidthLevel1;
    public Byte[] m_displayWidthLevel2;
    public Char[][] m_displayWidthLeadingCode;
    public Char[] m_oraCharLevel1;
    public Int32[] m_oraCharLevel2;
    public Char[] m_oraCharSurrogateLevel;
    protected int ToUnicodeLC(int srcChar, bool ccb);
    protected virtual int ToOracleCharacterLC(char srcChar, char lowSurrogate, bool ccb);
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string chars, int charOffset, int charCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int ConvertCharsToBytes(Char[] chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool ccb);
    public virtual int ConvertStringToBytes(string chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool ccb);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual bool IsOraCharacterReplacement(char ch, char lowsur);
    public virtual void BuildUnicodeToOracleMapping();
    public virtual void ExtractCodepoints(IList`1<Int32[]> vtable);
    public virtual void ExtractExtraMappings(IList`1<Int32[]> vtable);
    public virtual bool HasExtraMappings();
    public virtual char GetOraChar1ByteRep();
    public virtual char GetOraChar2ByteRep();
    public virtual int GetUCS2CharRep();
}
internal class OracleInternal.I18N.TLBConvSerializer : object {
    private static string BOOT_FILE_NAME;
    internal static void Serialize(object obj, Stream stream);
    internal static object Deserialize(Stream stream, string fileName);
    private static void Serialize(TLBConvLC obj, Stream stream);
    private static TLBConvLC DeserializeTLBConvLC(Stream stream, int typeID);
    private static void Serialize(TLBConv1Byte obj, Stream stream);
    private static TLBConv1Byte DeserializeTLBConv1Byte(Stream stream, int typeID);
    private static void Serialize(TLBConv12Byte obj, Stream stream);
    private static TLBConv12Byte DeserializeTLBConv12Byte(Stream stream, int typeID);
    private static void Serialize(TLBConvBoot obj, Stream stream);
    private static TLBConvBoot DeserializeTLBConvBoot(Stream stream);
    private static void Serialize(Dictionary`2<string, string> dictionary, BinaryWriter writer);
    private static Dictionary`2<string, string> DeserializeDictionary(BinaryReader reader);
    private static void Serialize(List`1<string> list, BinaryWriter writer);
    private static List`1<string> DeserializeList(BinaryReader reader);
    private static void Serialize(char c, BinaryWriter writer);
    private static char DeserializeChar(BinaryReader reader);
    private static void Serialize(Char[] array, BinaryWriter writer);
    private static Char[] DeserializeCharArray(BinaryReader reader);
    private static void Serialize(Char[][] array, BinaryWriter writer);
    private static Char[][] DeserializeChar2DArray(BinaryReader reader);
    private static void Serialize(int c, BinaryWriter writer);
    private static int DeserializeInt(BinaryReader reader);
    private static void Serialize(Int32[] array, BinaryWriter writer);
    private static Int32[] DeserializeIntArray(BinaryReader reader);
    private static void Serialize(Int32[][] array, BinaryWriter writer);
    private static Int32[][] DeserializeInt2DArray(BinaryReader reader);
    private static void Serialize(byte b, BinaryWriter writer);
    private static byte DeserializeByte(BinaryReader reader);
    private static void Serialize(bool b, BinaryWriter writer);
    private static bool DeserializeBool(BinaryReader reader);
}
internal class OracleInternal.I18N.TLBConvShift : TLBConv12Byte {
    private static byte SHIFT_OUT;
    private static byte SHIFT_IN;
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    internal virtual bool IsShitCharset();
    private int GetCharsLengthShiftImpl(Byte[] bytes, int offset, int count, Boolean& shiftIn, Int32& bytesCounted);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    private int GetBytesOffsetShiftImpl(Byte[] bytes, int offset, int count, Int32& charCount, Boolean& shiftIn);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    private int ConvertBytesToCharsImpl(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, Boolean& shiftIn, bool ccb);
    private int ConvertBytesToUTF16Impl(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, Boolean& shiftIn, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    internal virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, Boolean& shiftIn, bool ccb);
    private int ConvertByteArraySegListToCharsShiftImpl(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, T[] chars, int charOffset, Int32& charCount, Boolean& shiftState, bool bUseReplacementChar, ConvertByteToCharsShiftDelegate`1<T> t);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    internal virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, Boolean& shiftIn, bool bUseReplacementChar);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string chars, int charOffset, int charCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int ConvertCharsToBytes(Char[] chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool ccb);
    public virtual int ConvertStringToBytes(string chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool ccb);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool ccb);
}
internal class OracleInternal.I18N.TLBConvSJIS : TLBConv12Byte {
    private static short MIN_8BIT_SB;
    private static short MAX_8BIT_SB;
    protected virtual int GetCharsLengthImpl(Byte[] bytes, int offset, int count, Int32& bytesCounted);
    protected virtual int GetBytesOffsetImpl(Byte[] bytes, int offset, int count, Int32& charCount);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
}
internal class OracleInternal.I18N.TLBConvZHTEUC : TLBConvLC {
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    private int GetCharsLengthZHTEUCImpl(Byte[] bytes, int offset, int count, Int32& bytesCounted);
    private int GetBytesOffsetZHTEUCImpl(Byte[] bytes, int offset, int count, Int32& charCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    private int GetRemainingBytes(int oraChar);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    private int ConvertByteArraySegListToCharsImpl(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, T[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar, ConvertByteToCharsDelegate`1<T> t);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
}
internal class OracleInternal.I18N.UTF16ConvAL16UTF16 : Conv {
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    internal UTF16ConvAL16UTF16(int oracleId);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertCharsToBytes(Char[] chars, int charsOffset, int nchars, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int ConvertStringToBytes(string chars, int charsOffset, int nchars, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int byteOffset, int byteCount, Byte[] utf16Bytes, int utf16BytesOffset, Int32& utf16BytesCount, bool bUseReplacementChar);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string str, int strOffset, int strCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
}
internal class OracleInternal.I18N.UTF16ConvAL16UTF16LE : Conv {
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    internal UTF16ConvAL16UTF16LE(int oracleId);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertCharsToBytes(Char[] chars, int charsOffset, int nchars, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int ConvertStringToBytes(string chars, int charsOffset, int nchars, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int byteOffset, int byteCount, Byte[] utf16Bytes, int utf16BytesOffset, Int32& utf16BytesCount, bool bUseReplacementChar);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string str, int strOffset, int strCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
}
internal class OracleInternal.I18N.UTF16ConvAL32UTF8 : Conv {
    private static ConvertToCharsDelegate`1<char> ConvertBytesToCharsInstance;
    private static ConvertToCharsDelegate`1<byte> ConvertBytesToUTF16Instance;
    private static GetCharsLengthDelegate GetCharsLengthInstance;
    private static GetBytesOffsetDelegate GetBytesOffsetInstance;
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    internal UTF16ConvAL32UTF8(int oracleId);
    private static UTF16ConvAL32UTF8();
    private static int GetCharsLengthImpl(Byte[] bytes, int byteOffset, int byteCount, Int32& bytesCounted);
    private static int GetBytesOffsetImpl(Byte[] bytes, int byteOffset, int byteCount, Int32& charCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string chars, int charOffset, int charCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int ConvertCharsToBytes(Char[] chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool bUseReplacementChar);
    public virtual int ConvertStringToBytes(string chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool bUseReplacementChar);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    private static int ConvertBytesToCharsImpl(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    private static int ConvertBytesToUTF16Impl(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
}
internal class OracleInternal.I18N.UTF16ConvUTF8 : Conv {
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    internal UTF16ConvUTF8(int oracleId);
    private static int GetCharsLengthImpl(Byte[] bytes, int byteOffset, int byteCount, Int32& bytesCounted);
    private int GetBytesOffsetImpl(Byte[] bytes, int byteOffset, int byteCount, Int32& charCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    private static int UTFToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, Int32& remainingBytes, bool ccb);
    private static int UTFToUTF16Bytes(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, Int32& remainingBytes, bool ccb);
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string chars, int charOffset, int charCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int ConvertCharsToBytes(Char[] chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool bUseReplacementChar);
    public virtual int ConvertStringToBytes(string chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool bUseReplacementChar);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    public virtual int ConvertBytesToChars(Byte[] bytes, int byteOffset, int byteCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int byteOffset, int byteCount, Byte[] utf16Bytes, int utf16BytesOffset, Int32& utf16BytesCount, bool bUseReplacementChar);
    private int ConvertUtf8ArraySegListToCharsImpl(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, T[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar, ConvertToCharsDelegate`1<T> t);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
}
internal class OracleInternal.I18N.UTF16ConvUTFE : Conv {
    private static Byte[][] utf8m2utfe;
    private static Byte[][] utfe2utf8m;
    private static ConvertToCharsDelegate`1<char> ConvertBytesToCharsInstance;
    private static ConvertToCharsDelegate`1<byte> ConvertBytesToUTF16Instance;
    private static GetCharsLengthDelegate GetCharsLengthInstance;
    private static GetBytesOffsetDelegate GetBytesOffsetInstance;
    public int MinBytesPerChar { get; }
    public int MaxBytesPerChar { get; }
    internal UTF16ConvUTFE(int oracleId);
    private static UTF16ConvUTFE();
    private static int GetCharsLengthImpl(Byte[] bytes, int byteOffset, int byteCount, Int32& bytesCounted);
    private static int GetBytesOffsetImpl(Byte[] bytes, int byteOffset, int byteCount, Int32& charCount);
    public virtual int GetBytesOffset(Byte[] bytes, int byteOffset, int byteCount, int charCount);
    private static int ConvertBytesToCharsImpl(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    public virtual int ConvertBytesToChars(Byte[] bytes, int offset, int count, Char[] chars, int charOffset, Int32& charCount, bool ccb);
    private static int ConvertBytesToUTF16Impl(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    public virtual int ConvertBytesToUTF16(Byte[] bytes, int offset, int count, Byte[] utfbytes, int utfOffset, Int32& utfCount, bool ccb);
    public virtual int GetBytesLength(Char[] chars, int charOffset, int charCount);
    public virtual int GetBytesLength(string chars, int charOffset, int charCount);
    public virtual int GetBytesLength(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount);
    public virtual int ConvertCharsToBytes(Char[] chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool bUseReplacementChar);
    public virtual int ConvertStringToBytes(string chars, int chars_offset, int chars_count, Byte[] bytes, int bytes_begin, Int32& bytes_count, bool bUseReplacementChar);
    public virtual int ConvertUTF16ToBytes(Byte[] utf16Bytes, int utf16BytesOffset, int utf16BytesCount, Byte[] bytes, int byteOffset, Int32& byteCount, bool bUseReplacementChar);
    private static int high(int b);
    private static int low(int b);
    private static bool is101xxxxx(byte c);
    public virtual int ConvertBytesToChars(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, Char[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar);
    public virtual int GetCharsLength(Byte[] bytes, int byteOffset, int byteCount);
    public virtual int GetCharsLength(ArraySegment`1<byte> bytes, int bytesOffset, int bytesCount);
    public virtual int GetCharsLength(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount);
    public virtual int GetBytesOffset(IList`1<ArraySegment`1<byte>> bytes, int charCount);
    public virtual int get_MinBytesPerChar();
    public virtual int get_MaxBytesPerChar();
}
internal class OracleInternal.I18N.UTF16ConvUtility : object {
    public static bool IsHiSurrogate(char c);
    public static bool IsLoSurrogate(char c);
    public static bool Check80toBF(byte b);
    public static bool Check80to8F(byte b);
    public static bool Check80to9F(byte b);
    public static bool CheckA0toBF(byte b);
    public static bool Check90toBF(byte b);
    public static char Conv3ByteUTFtoUTF16(byte c, byte c2, byte c3);
    public static bool isDefined(string str);
    public static void GetRemainingBytes(int numBytesToRead, Byte[] buffer1, int offset1, int buffer1Bytes, IList`1<ArraySegment`1<byte>> bytes, Int32& currSegIndex, Int32& continuationOffset, Byte[] dstBuffer);
    public static int ConvertArraySegListToCharsImpl(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, T[] chars, int charOffset, Int32& charCount, bool bUseReplacementChar, ConvertToCharsDelegate`1<T> t);
    public static int GetBytesOffsetListSegs(IList`1<ArraySegment`1<byte>> bytes, int charCount, GetBytesOffsetDelegate t);
    public static int GetCharsLengthListSegs(IList`1<ArraySegment`1<byte>> bytes, int bytesOffset, int bytesCount, GetCharsLengthDelegate t);
    public static void GetSegementIndices(IList`1<ArraySegment`1<byte>> segs, int offset, Int32& idx1, Int32& offSet1);
}
internal class OracleInternal.Json.Binary.AtomicInt : object {
    private int m_value;
    public int Value { get; public set; }
    public int get_Value();
    public void set_Value(int value);
}
internal class OracleInternal.Json.Binary.BigKey : object {
    internal Byte[] key;
    internal int hash;
    public BigKey(string key);
    public sealed virtual int CompareTo(object obj);
}
internal class OracleInternal.Json.Binary.BitSet : object {
    private BitArray m_bits;
    internal void Set(int bitIndex);
    internal bool Get(int bitIndex);
    internal void Clear();
    internal void Clear(int bitIndex);
}
internal class OracleInternal.Json.Binary.ByteBuffer : object {
    private int m_pos;
    private int m_bufferLen;
    private Byte[] m_buffer;
    private Byte[] m_bytesForInt;
    private Byte[] m_bytesForShort;
    internal ByteBuffer(Byte[] buffer);
    internal static ByteBuffer Wrap(Byte[] buffer);
    internal int GetInt();
    internal int GetInt(int pos);
    internal int Position();
    internal int Position(int pos);
    internal int Remaining();
    internal int Limit();
    internal byte Get();
    internal byte Get(int pos);
    internal short GetShort();
    internal short GetShort(int pos);
    internal Byte[] Array();
    internal ByteBuffer Get(Byte[] dst);
}
internal abstract class OracleInternal.Json.Binary.OracleJsonGenerator : object {
    public abstract virtual IOracleJsonGenerator WriteStartObject();
    public abstract virtual IOracleJsonGenerator WriteStartArray();
    public abstract virtual IOracleJsonGenerator WriteKey(string key);
    public abstract virtual IOracleJsonGenerator Write(decimal value);
    public abstract virtual IOracleJsonGenerator Write(BigInteger value);
    public abstract virtual IOracleJsonGenerator Write(string value);
    public abstract virtual IOracleJsonGenerator Write(Char[] value, int strLen);
    public abstract virtual IOracleJsonGenerator Write(int value);
    public abstract virtual IOracleJsonGenerator Write(long value);
    public abstract virtual IOracleJsonGenerator Write(double value);
    public abstract virtual IOracleJsonGenerator Write(float value);
    public abstract virtual IOracleJsonGenerator Write(bool value);
    public abstract virtual IOracleJsonGenerator Write(DateTime value);
    public abstract virtual IOracleJsonGenerator Write(string name, DateTime value);
    public abstract virtual IOracleJsonGenerator Write(Period value);
    public abstract virtual IOracleJsonGenerator Write(TimeSpan value);
    public abstract virtual IOracleJsonGenerator Write(Byte[] value);
    public abstract virtual IOracleJsonGenerator WriteId(Byte[] value);
    public abstract virtual IOracleJsonGenerator Write(string key, Byte[] value);
    public abstract virtual IOracleJsonGenerator WriteNull();
    public abstract virtual IOracleJsonGenerator WriteEnd();
    public abstract virtual void Close();
    public abstract virtual void Flush();
    public sealed virtual IOracleJsonGenerator WriteStartObject(string key);
    public sealed virtual IOracleJsonGenerator WriteStartArray(string key);
    public sealed virtual IOracleJsonGenerator Write(string key, OracleJsonValue value);
    public sealed virtual IOracleJsonGenerator Write(string key, string value);
    public sealed virtual IOracleJsonGenerator Write(string key, BigInteger value);
    public sealed virtual IOracleJsonGenerator Write(string key, decimal value);
    public sealed virtual IOracleJsonGenerator Write(string key, int value);
    public sealed virtual IOracleJsonGenerator Write(string key, long value);
    public sealed virtual IOracleJsonGenerator Write(string key, double value);
    public sealed virtual IOracleJsonGenerator Write(string key, float value);
    public sealed virtual IOracleJsonGenerator Write(string key, bool value);
    public sealed virtual IOracleJsonGenerator WriteNull(string key);
    public sealed virtual IOracleJsonGenerator Write(string key, Period value);
    public sealed virtual IOracleJsonGenerator Write(string key, TimeSpan value);
    public sealed virtual IOracleJsonGenerator Write(OracleJsonValue value);
    public sealed virtual IOracleJsonGenerator WriteParser(Utf8JsonReader parser);
    protected abstract virtual IOracleJsonGenerator WriteBinary(OracleJsonBinary value);
    protected abstract virtual IOracleJsonGenerator WriteDouble(OracleJsonDouble value);
    protected abstract virtual IOracleJsonGenerator WriteFloat(OracleJsonFloat value);
    protected abstract virtual IOracleJsonGenerator WriteOraNumber(OracleJsonDecimal value);
    protected abstract virtual IOracleJsonGenerator WriteTimestamp(OracleJsonTimestamp value);
    protected abstract virtual IOracleJsonGenerator WriteTimestampTZ(OracleJsonTimestampTZ value);
    protected abstract virtual IOracleJsonGenerator WriteDate(OracleJsonDate value);
    protected abstract virtual IOracleJsonGenerator WriteString(OracleJsonString value);
    protected abstract virtual IOracleJsonGenerator WriteIntervalDS(OracleJsonIntervalDS value);
    protected abstract virtual IOracleJsonGenerator WriteIntervalYM(OracleJsonIntervalYM value);
    protected abstract virtual IOracleJsonGenerator WriteVector(OracleJsonVector value);
    private void WriteOracleJsonValue(OracleJsonValue value);
}
internal class OracleInternal.Json.Binary.OracleJsonSerializer : OracleJsonGenerator {
    internal static char MIN_HIGH_SURROGATE;
    internal static char MAX_HIGH_SURROGATE;
    internal static char RUBOUT;
    internal IJsonOutput m_writer;
    internal StreamContext m_streamingCtx;
    private static string s_HexDigitPairs;
    private static OracleJsonSerializer();
    internal OracleJsonSerializer(Stream stream);
    internal OracleJsonSerializer(TextWriter writer);
    public virtual IOracleJsonGenerator WriteStartObject();
    public virtual IOracleJsonGenerator WriteStartArray();
    public virtual IOracleJsonGenerator WriteEnd();
    public virtual IOracleJsonGenerator Write(string value);
    public virtual IOracleJsonGenerator Write(Char[] value, int strLen);
    public virtual IOracleJsonGenerator WriteKey(string key);
    internal static void WriteQuotedString(string value, IJsonOutput m_writer, IExceptionFactory f);
    internal static void WriteQuotedString(Char[] value, int strLen, IJsonOutput m_writer, IExceptionFactory f);
    internal static string SerializeString(string value);
    public virtual IOracleJsonGenerator Write(decimal value);
    public virtual IOracleJsonGenerator Write(BigInteger value);
    public virtual IOracleJsonGenerator Write(int value);
    public virtual IOracleJsonGenerator Write(long value);
    public virtual IOracleJsonGenerator Write(double value);
    public virtual IOracleJsonGenerator Write(float value);
    public virtual IOracleJsonGenerator Write(bool value);
    public virtual IOracleJsonGenerator WriteNull();
    public virtual void Close();
    protected IExceptionFactory GetExceptionFactory();
    public virtual void Flush();
    protected virtual IOracleJsonGenerator WriteBinary(OracleJsonBinary value);
    protected virtual IOracleJsonGenerator WriteDouble(OracleJsonDouble value);
    protected virtual IOracleJsonGenerator WriteFloat(OracleJsonFloat value);
    protected virtual IOracleJsonGenerator WriteOraNumber(OracleJsonDecimal value);
    internal IOracleJsonGenerator WriteNumber(OracleJsonNumber value);
    internal string NumberToString(OracleJsonNumber n);
    protected virtual IOracleJsonGenerator WriteTimestamp(OracleJsonTimestamp value);
    protected virtual IOracleJsonGenerator WriteTimestampTZ(OracleJsonTimestampTZ value);
    protected virtual IOracleJsonGenerator WriteDate(OracleJsonDate value);
    protected virtual IOracleJsonGenerator WriteIntervalDS(OracleJsonIntervalDS value);
    protected virtual IOracleJsonGenerator WriteIntervalYM(OracleJsonIntervalYM value);
    protected virtual IOracleJsonGenerator WriteVector(OracleJsonVector value);
    protected virtual IOracleJsonGenerator WriteString(OracleJsonString value);
    internal void WriteAscii(string s);
    internal void WriteBigDecimal(decimal value);
    private void WriteBigInteger(BigInteger value);
    internal void WriteInt(int value);
    internal void WriteLong(long value);
    internal void WriteFloat(float value);
    internal void WriteDouble(double value);
    internal void WriteBoolean(bool value);
    internal void WriteNullInternal();
    internal void WriteAscii(char c);
    internal void Primitive();
    internal void WriteSeparator();
    internal static void EscapeUnicode(int codePoint, IJsonOutput m_writer);
    internal static void WriteEscapedChar(char c, IJsonOutput m_writer);
    internal static void WriteEscaped(string value, IJsonOutput m_writer);
    internal static void WriteEscaped(Char[] value, int strLen, IJsonOutput m_writer);
    internal void AssertFinite(double value);
    private static void Escape(int cp, IJsonOutput writer);
    public virtual IOracleJsonGenerator Write(string key, DateTime value);
    public virtual IOracleJsonGenerator Write(DateTime value);
    public virtual IOracleJsonGenerator Write(string key, Byte[] value);
    public virtual IOracleJsonGenerator Write(Byte[] value);
    public virtual IOracleJsonGenerator WriteId(Byte[] value);
    public virtual IOracleJsonGenerator Write(Period value);
    public virtual IOracleJsonGenerator Write(TimeSpan value);
}
internal class OracleInternal.Json.Binary.OracleOsonValueFactory : OsonValueFactory {
    internal static OracleOsonValueFactory INSTANCE;
    private static OracleOsonValueFactory();
    internal virtual OsonAbstractArray CreateArray(OsonContext ctx, int pos);
    internal virtual OsonAbstractObject CreateObject(OsonContext ctx, int pos);
    internal virtual object CreateString(OsonContext ctx, int pos, int len);
    internal virtual OracleJsonNumber CreateNumber(Byte[] raw, TargetType type);
    internal virtual OracleJsonNumber CreateStringNumber(string value);
    internal virtual OracleJsonNumber CreateDouble(double value);
    internal virtual object CreateBinary(Byte[] value, bool isId);
    internal virtual object CreateTimestamp(Byte[] raw);
    internal virtual object CreateTimestampTZ(Byte[] raw);
    internal virtual OracleJsonNumber CreateFloat(float flt);
    internal virtual object CreateDate(Byte[] raw);
    internal virtual object CreateIntervalYM(Byte[] value);
    internal virtual object CreateIntervalDS(Byte[] value);
    internal virtual object CreateVector(Byte[] raw);
    internal virtual object CreateTrue();
    internal virtual object CreateFalse();
    internal virtual object CreateNull();
}
internal abstract class OracleInternal.Json.Binary.OsonAbstractArray : OsonStructure {
    internal OsonAbstractArray(OsonContext ctx, int pos);
    protected OsonAbstractArray(OsonContext ctx);
    internal string GetJsonString(int i);
    internal bool GetBoolean(int i);
    internal bool GetBoolean(int i, bool d);
    internal int GetInt(int i);
    internal int GetInt(int i, int d);
    internal bool IsNull(int i);
    internal bool Contains(object value);
    internal Object[] ToArray();
    internal object GetInternal(int i);
    internal int IndexOf(object o);
    internal int LastIndexOf(object o);
    public virtual OracleJsonType GetOracleJsonType();
    protected virtual void Init(int pos);
    protected virtual int GetChildOffset(int i);
    private void CopyToArray(Object[] result);
    protected int GetOffsetWithError(int i);
}
internal class OracleInternal.Json.Binary.OsonAbstractObject : OsonStructure {
    private bool m_fidSorted;
    private int m_fidArrayOffset;
    internal OsonAbstractObject(OsonContext ctx);
    internal OsonAbstractObject(OsonContext ctx, int pos);
    public virtual OracleJsonType GetOracleJsonType();
    internal OsonAbstractArray GetJsonArrayInternal(string key);
    internal OsonAbstractObject GetJsonObjectInternal(string key);
    internal string GetJsonString(string key);
    internal string GetJsonString(string key, string d);
    internal bool GetBoolean(string key);
    internal bool GetBoolean(string key, bool d);
    internal int GetInt(string key, int d);
    internal int GetInt(string key);
    internal bool IsNull(string key);
    internal bool ContainsKey(object key);
    internal object GetInternal(object key);
    protected virtual void Init(int pos);
    protected virtual int GetChildOffset(int fieldPos);
    protected int GetChildOffset(string key);
    protected int GetChildPosition(string key);
    internal string GetFieldName(int child);
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Json.Binary.OsonArray : OsonAbstractArray {
    private int m_iter;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OracleJsonValue Item { get; public set; }
    public OracleJsonValue Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal OsonArray(OsonContext ctx, int pos);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual OracleJsonValue get_Item(int index);
    public sealed virtual void set_Item(int index, OracleJsonValue value);
    public virtual string ToJsonString();
    internal double GetDouble(int index);
    internal decimal GetBigDecimal(int index);
    internal long GetLong(int index);
    internal DateTime GetDateTime(int index);
    internal Byte[] GetBytes(int index);
    internal OracleJsonValue Set(int index, OracleJsonValue element);
    internal void Add(int index, OracleJsonValue element);
    internal OracleJsonValue Remove(int index);
    internal OracleJsonValue Set(int index, string value);
    internal void Add(string value);
    internal OracleJsonValue Set(int index, int value);
    internal void Add(int value);
    internal OracleJsonValue Set(int index, double value);
    internal void Add(double value);
    internal OracleJsonValue Set(int index, bool value);
    internal void Add(bool value);
    internal OracleJsonValue SetNull(int index);
    internal void AddNull();
    internal OracleJsonValue Set(int index, DateTime value);
    internal void Add(DateTime value);
    internal OracleJsonValue Set(int index, Byte[] value);
    internal void Add(Byte[] value);
    internal OracleJsonValue Set(int index, long value);
    internal OracleJsonValue Set(int index, decimal value);
    internal void Add(long value);
    internal void Add(decimal value);
    private NotSupportedException CreateNotModifiable();
    public sealed virtual int IndexOf(OracleJsonValue item);
    public sealed virtual void Insert(int index, OracleJsonValue item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(OracleJsonValue item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(OracleJsonValue item);
    public sealed virtual void CopyTo(OracleJsonValue[] array, int arrayIndex);
    public sealed virtual bool Remove(OracleJsonValue item);
    public sealed virtual IEnumerator`1<OracleJsonValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual OracleJsonValue get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class OracleInternal.Json.Binary.OsonBuffer : object {
    internal ByteBuffer m_buffer;
    internal Char[] m_charBuffer;
    internal OsonBuffer(ByteBuffer buffer);
    internal OsonBuffer(MemoryStream buffer);
    internal int GetInt();
    internal ByteBuffer Buffer();
    internal int Position();
    internal void Position(int pos);
    internal int GetUB1();
    internal int GetUB1(int i);
    internal int GetUB2();
    internal short GetShort(int i);
    internal int GetUB2(int i);
    internal Char[] ReadString(int len, Int32& charArrLen);
    internal int GetUB4int();
    internal int GetUB4int(int i);
    internal int GetInt(int i);
    internal void Get(Byte[] bytes);
    internal double ReadDtyDouble();
    internal float ReadDtyFloat();
    internal int BinarySearchUb1(int fromPos, int count, int test);
    internal int BinarySearchUb2(int fromPos, int count, int test);
    internal int BinarySearchUb4(int fromPos, int count, int test);
    internal int LinearSearchUb1(int fromPos, int count, int test);
    internal int LinearSearchUb2(int fromPos, int count, int test);
    internal int LinearSearchUb4(int fromPos, int count, int test);
}
internal class OracleInternal.Json.Binary.OsonConstants : object {
    internal static UInt32 MAGIC;
    internal SByte[] MAGIC_BYTES;
    internal static UInt32 MAGIC_VERSION1;
    internal static UInt32 MAGIC_VERSION3;
    internal static int JZNOCT3_FLDNM2_SZ_UB2;
    internal static int JZNOCT2_REL_OFFSET;
    internal static int JZNOCT2_INLINE_LEAF;
    internal static int JZNOCT2_SLEN_IN_PCODE;
    internal static int JZNOCT2_TOT_DISFNM_UB4;
    internal static int JZNOCT2_SHR_SIMP_NODES;
    internal static int JZNOCT2_SHR_NODES;
    internal static int JZNOCT2_J_SCALAR;
    internal static int JZNOCT_HID_USEUB1;
    internal static int JZNOCT_HID_USEUB2;
    internal static int JZNOCT_TOT_DISFNM_UB2;
    internal static int JZNOCT_FLDNM_SZ_UB4;
    internal static int JZNOCT_TREE_SZ_UB4;
    internal static int JZNOCT_TINY_NODE_STAT;
    internal static int JZNOCT_FID_NO_SORT;
    internal static int JZNOCTUPDHDR_OVFLW_SEG_UB2;
    internal static int JZNOCT_UPD_OVFLW;
    internal static int JZNOCT_UPD2_FWA;
    internal static int JZNOCT_UPD4_FWA;
    internal static int JZNOCT_UPD_XSZ_RES;
    internal static int JZNOCT_UPD_OBJ_REF_BITMASK;
    internal static int OPCODE_OFFSET_SIZE_BIT;
    internal static int OPCODE_CHILD_SIZE_BITS;
    internal static int OPCODE_CHILD_NO_SORT_BIT;
    internal static int JZNOCT_OBJECT_TYP;
    internal static int JZNOCT_ARRAY_TYP;
    internal static int JZNOCT_JNULL_C;
    internal static int JZNOCT_JBOOLT_C;
    internal static int JZNOCT_JBOOLF_C;
    internal static int JZNOCT_JSUB1L_C;
    internal static int JZNOCT_JORA_DTYNUM_C;
    internal static int JZNOCT_JORA_DTYNUM_DEC_C;
    internal static int JZNOCT_JDTYSTAMPTZ_C;
    internal static int JZNOCT_JDTYSTAMP7_C;
    internal static int JZNOCT_JDTYGENID_C;
    internal static int JZNOCT_JDTYFLT_C;
    internal static int JZNOCT_JSNUM_C;
    internal static int JZNOCT_JDTYDB_C;
    internal static int JZNOCT_JSUB2L_C;
    internal static int JZNOCT_JSUB4L_C;
    internal static int JZNOCT_JDTYSTAMP_C;
    internal static int JZNOCT_JBINUB2L_C;
    internal static int JZNOCT_JBINUB4L_C;
    internal static int JZNOCT_JDTYDATE_C;
    internal static int JZNOCT_JDTYYM_C;
    internal static int JZNOCT_JDTYDS_C;
    internal static int JZNOCT_JEXT;
    internal static int JZNOCT_JEXT_JVECTOR;
    internal static int UB1_MAXSZ;
    internal static int UB2_MAXSZ;
    internal static int MAX_SMALL_KEY_LENGTH;
    internal static int MAX_BIG_KEY_LENGTH;
    internal static int JZNOCT_BIN_SRCH_TRIG_LIMIT;
    internal static int JZNOCT_STR_OK_5BITS;
    internal static int JZNOCT_ORANUM_OK_4BITS;
    internal static int JZNOCT_OBJ_FID_REFERRED;
    internal static int JZNOCT_UPD_UB4_FWA_SZ;
    internal static int MASK_SB4;
    internal static int MASK_SB8;
    internal static int MASK_ORANUM_16;
    internal static int MASK_DEC_16;
    private static OsonConstants();
    internal static bool IsSB4(int op);
    internal static bool IsSB8(int op);
    internal static bool IsOraNum16(int op);
    internal static bool IsDec_16(int op);
}
internal class OracleInternal.Json.Binary.OsonContext : object {
    internal OsonBuffer m_osonBuffer;
    internal OsonHeader m_osonHeader;
    internal OracleOsonValueFactory m_valueFactory;
    internal IExceptionFactory m_exceptionFactory;
    internal OsonContext(OsonBuffer buffer, OsonHeader header, OracleOsonValueFactory valueFactory, IExceptionFactory exceptionFactory);
    internal OsonContext(OsonBuffer buffer, OsonHeader header);
    internal OsonContext(OsonBuffer buffer);
    internal OsonContext(OsonContext other);
    internal OsonHeader GetHeader();
    internal OracleOsonValueFactory GetFactory();
    internal IExceptionFactory GetExceptionFactory();
}
internal class OracleInternal.Json.Binary.OsonGenerator : OracleJsonGenerator {
    private OsonGeneratorState m_state;
    internal OsonGenerator(OsonGeneratorStatePool pool, Stream outStream);
    public void Reset(Stream outStream);
    public void SetTinyNodeStat(bool nodeValue);
    public void SetUseRelativeOffsets(bool value);
    public void SetSimpleValueSharing(bool value);
    public void SetLastValueSharing(bool value);
    public bool GetLastValueSharing();
    public bool GetSimpleValuesharing();
    public bool GetRelativeOffsets();
    public virtual IOracleJsonGenerator WriteStartObject();
    public virtual IOracleJsonGenerator WriteKey(string key);
    public virtual IOracleJsonGenerator WriteStartArray();
    public virtual IOracleJsonGenerator WriteEnd();
    public virtual IOracleJsonGenerator Write(string value);
    public virtual IOracleJsonGenerator Write(Char[] value, int strLen);
    public virtual IOracleJsonGenerator Write(decimal value);
    public virtual IOracleJsonGenerator Write(BigInteger value);
    public virtual IOracleJsonGenerator Write(int value);
    public virtual IOracleJsonGenerator Write(long value);
    public virtual IOracleJsonGenerator Write(double value);
    public virtual IOracleJsonGenerator Write(bool value);
    public virtual IOracleJsonGenerator WriteNull();
    public virtual void Close();
    public virtual IOracleJsonGenerator Write(string key, Byte[] value);
    public virtual IOracleJsonGenerator Write(string key, DateTime value);
    public virtual IOracleJsonGenerator Write(Byte[] bytes);
    public virtual IOracleJsonGenerator WriteId(Byte[] bytes);
    public virtual IOracleJsonGenerator Write(DateTime instant);
    public virtual IOracleJsonGenerator Write(float value);
    public IOracleJsonGenerator WriteDate(DateTime instant);
    public IOracleJsonGenerator WriteIntervalDS(TimeSpan value);
    internal IOracleJsonGenerator WriteIntervalYM(Period value);
    public IOracleJsonGenerator WriteNumberAsString(decimal bd);
    protected virtual IOracleJsonGenerator WriteBinary(OracleJsonBinary value);
    protected virtual IOracleJsonGenerator WriteDouble(OracleJsonDouble value);
    protected virtual IOracleJsonGenerator WriteFloat(OracleJsonFloat value);
    public void WriteDecimal(decimal value);
    public void WriteSB4(int value);
    public void WriteSB8(long value);
    protected virtual IOracleJsonGenerator WriteOraNumber(OracleJsonDecimal value);
    protected virtual IOracleJsonGenerator WriteTimestamp(OracleJsonTimestamp value);
    protected virtual IOracleJsonGenerator WriteTimestampTZ(OracleJsonTimestampTZ value);
    protected virtual IOracleJsonGenerator WriteDate(OracleJsonDate value);
    protected virtual IOracleJsonGenerator WriteIntervalDS(OracleJsonIntervalDS value);
    protected virtual IOracleJsonGenerator WriteIntervalYM(OracleJsonIntervalYM value);
    protected virtual IOracleJsonGenerator WriteVector(OracleJsonVector value);
    protected virtual IOracleJsonGenerator WriteString(OracleJsonString value);
    public virtual void Flush();
    public virtual IOracleJsonGenerator Write(Period p);
    public virtual IOracleJsonGenerator Write(TimeSpan d);
}
internal class OracleInternal.Json.Binary.OsonGeneratorState : object {
    internal static bool DEFAULT_SIMPLE_VALUE_SHARING;
    internal static bool DEFAULT_LAST_VALUE_SHARING;
    internal static bool DEFAULT_RELATIVE_OFFSETS;
    internal static bool DEFAULT_TINYNODE;
    internal static int SEEN_HASH_THRESHOLD;
    internal static int INITIAL_OPS;
    internal static int OUT_BUFFER_SIZE;
    internal static Byte[] ONE;
    internal static Byte[] ZERO;
    internal Int32[][] m_keys;
    internal Int32[][] m_keysLastSeenValue;
    internal bool m_keysNeedReset;
    private Int32[] m_seenHash;
    private int m_seenHashSize;
    private int m_keyI;
    private int m_keyJ;
    internal String[] m_distinctKeys;
    internal int m_distinctKeysSize;
    internal Byte[] m_keyHeap;
    internal int m_keyHeapSize;
    internal Int32[] m_keyHeapOffsets;
    internal Int32[] m_fidMap;
    private SortedDictionary`2<BigKey, int> bigKeys;
    private int bigKeysHeapSize;
    private AtomicInt keylen;
    internal int m_numOps;
    internal Byte[] m_ops;
    internal Int32[] m_nextSiblings;
    internal Int32[] m_fieldIDs;
    internal Byte[] m_depths;
    internal Int32[] m_valueIndex;
    internal Int32[] m_numChildren;
    internal Int32[] m_offsets;
    internal int m_treeSegmentSize;
    internal Byte[] m_valueHeap;
    internal int m_valueHeapSize;
    internal int m_tinyNodeCount;
    internal short m_headerFlags;
    internal Int32[] m_opStack;
    internal byte m_depth;
    internal int m_previousSiblingIdx;
    internal Int32[] m_temporaryIntArray;
    internal Int64[] m_temporaryLongArray;
    internal StreamContext m_ctx;
    internal BinaryWriter m_outWriter;
    internal Byte[] m_outBuffer;
    internal int m_outBufferPos;
    internal bool m_relativeOffsets;
    internal bool m_simpleValueSharing;
    internal bool m_lastValueSharing;
    internal int m_opNull;
    internal int m_opTrue;
    internal int m_opFalse;
    internal int m_opZero;
    internal int m_opOne;
    internal int m_opEmptyString;
    internal int m_opEmptyObject;
    internal int m_opEmptyArray;
    internal int m_opLastValue;
    internal OsonGeneratorStatePool m_pool;
    internal OsonGeneratorState(OsonGeneratorStatePool pool, Stream outStream);
    private static OsonGeneratorState();
    internal bool IsEqualArrays(Byte[] a1, Byte[] a2);
    internal void WriteNumber(Byte[] bytes);
    internal void Push(int opIndex);
    internal void AddOp(int op);
    internal void ExpandOp();
    internal void PreOp();
    internal void PostOp(bool shareable);
    internal void AddValue(Byte[] bytes);
    internal void AddValueNoCheck(Byte[] bytes);
    internal bool Equals(Byte[] a1, int a1Start, Byte[] a2, int a2Start, int len);
    internal void ExpandValueHeap(int len);
    internal void InitializeKeyHeap();
    public IExceptionFactory GetExceptionFactory();
    internal int WriteString(string value, Byte[] destination, int destinationPos);
    internal int WriteUTF8String(Byte[] source, int sourceOffset, int len, Byte[] destination, int destinationPos);
    internal int SlowWriteString(string value, Byte[] destination, int destinationPos);
    internal void WriteHeader();
    internal void WriteTreeSegmentSize();
    internal void WriteNameDictionary();
    internal int ProcessBucket(int offIdx, int hash);
    internal void SortBucket(Int32[] bucket);
    internal int Memcmp(int i, int j, int length);
    internal void WriteNameDictionary2();
    internal void writeTreeNodeSegment();
    internal void PackOffsets(int index, int childCt, Int64[] packedArray);
    internal bool SharesFields(int op);
    internal bool IsReferredTo(int op);
    internal void TryFieldIdSharing(int primaryIndex);
    internal int FirstChild(int index);
    internal bool SameFieldIds(int p1, int p2);
    internal bool IsArray(int op);
    internal bool IsObject(int op);
    internal bool IsStructure(int op);
    internal void WriteChildOffsets(int childCt, Int64[] arr, int fixedOffset);
    internal void WriteChildOffsets(int childCt, Int32[] arr, int fixedOffset);
    internal void InitTemporaryLongArray(int ct);
    internal void InitTemporaryIntArray(int ct);
    internal void ComputeOffsets();
    internal bool IsShared(int opIndex);
    internal void CountTiny(int i, int size);
    internal bool IsFirstChildObjectOfArray(int i);
    internal int SizeOfOp(int index, int offsetSize);
    internal int BytesForNum(int i);
    internal int FlagObject(int op, int numChildren);
    internal int FlagObjectOrArray(int op, int numChildren);
    internal void writeUb2Array(Int32[] arr, int len);
    internal void WriteUb4Array(Int32[] arr, int len);
    internal void WriteInt(int value);
    internal void WriteUInt(UInt32 value);
    internal void WriteShort(int value);
    internal void WriteByte(int b);
    internal void FlushBuffer();
    internal void Write(Byte[] bytes, int start, int len);
    internal void WriteOpAndData(int op, Byte[] bytes, int start, int len);
    internal void Reset(Stream outStream);
    internal void InitKeysLastSeenValue(int i);
    internal void SetTinyNodeStat(bool value);
    internal void SetUseRelativeOffsets(bool value);
    internal void SetSimpleValueSharing(bool value);
    internal void SetLastValueSharing(bool value);
    internal void WriteTimestamp(Byte[] raw);
    internal void WriteDate(Byte[] raw);
    internal void WriteIntervalYM(Byte[] raw);
    internal void WriteIntervalDS(Byte[] raw);
    internal void FixedBinary(int op, int len, Byte[] bytes);
    public void Close();
    internal void WriteString(string value);
    internal bool CheckStringDuplicate(int len);
    internal void WriteUTF8String(Byte[] array, int offset, int len);
    internal void WriteStringOp(int newPos, int len);
    internal void WriteStartObject();
    internal void WriteStartArray();
    public void WriteEnd();
    internal void WriteDouble(double value);
    internal void WriteBoolean(bool value);
    internal void WriteOraNumber(OracleJsonDecimal value);
    internal void WriteDecimal(decimal value);
    internal void WriteDecimal(Byte[] bytes);
    internal void WriteDecimal(BigInteger value);
    internal void WriteSB4(int value);
    internal void MarkDuplicate(int index, int replacingIndex);
    internal bool TryMarkDuplicate(int op, Byte[] bytes);
    internal void AddOpAndValue(int op, Byte[] raw);
    internal void AddOpAndValueNoPostOp(int op, Byte[] raw);
    public void WriteSB8(long value);
    internal void WriteNumberAsString(decimal bd);
    internal void WriteBytes(Byte[] bytes);
    internal void WriteId(Byte[] bytes);
    internal void WriteFloat(float value);
    internal void WriteKey(string key);
    internal void WriteNull();
}
internal class OracleInternal.Json.Binary.OsonGeneratorStatePool : object {
    internal WeakReference`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_queue;
    internal OsonGeneratorState GetState(Stream outStream);
    internal void PutState(OsonGeneratorState state);
    internal ConcurrentQueue`1<OsonGeneratorState> GetQueue();
}
internal class OracleInternal.Json.Binary.OsonHeader : object {
    private static Byte[][] UTF8_MAPPING;
    private int version;
    private short flags;
    private short flags2;
    private int uniqueFields;
    private Int32[] hashIdArray;
    private String[] fieldNames;
    private int fieldHeapSize;
    private int uniqueFields2;
    private Int32[] hashIdArray2;
    private String[] fieldNames2;
    private int fieldHeapSize2;
    private int ubFieldId;
    private int treeSegmentSize;
    internal int treeSegmentOffset;
    private int tinyNodeCount;
    internal int updateFlags;
    internal int extendedTreeSegmentOffset;
    internal Dictionary`2<int, int> forwardingAddress;
    private static OsonHeader();
    internal OsonHeader(OsonBuffer b, IExceptionFactory f);
    internal void ReadHeader(OsonBuffer b, IExceptionFactory f);
    private void ReadDictionary(OsonBuffer b);
    private void ReadDictionary2(OsonBuffer b);
    internal string GetFieldName(int fid);
    private void ReadUpdateHeader(OsonBuffer b, IExceptionFactory f);
    internal bool IsScalar();
    internal bool IsTinyNodeCount();
    private void Ub1(OsonBuffer s, Int32[] arr);
    private void Ub2(OsonBuffer s, Int32[] arr);
    private void Ub4int(OsonBuffer s, Int32[] arr);
    internal int GetTreeSegmentOffset();
    internal int GetFieldHeapSize();
    internal String[] GetFields();
    internal Int32[] HashIds();
    private bool IsSet(int f);
    private bool IsSet2(int f);
    private bool IsSetUpd(int f);
    internal bool FieldsSorted();
    internal bool RelativeOffsets();
    internal int GetFieldId(string key);
    internal int GetFieldId(string key, Int32[] hashIdArray, String[] fieldNames);
    internal static int Ohash(string key, AtomicInt length);
    internal static int Ohash(Byte[] key);
    private static int Utf8len(string key);
    private static long HashUtf8(long hash, Byte[] bytes);
    internal static int Ub1hash(string key);
    internal int NumFieldIdBytes();
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Json.Binary.OsonObject : OsonAbstractObject {
    private int m_iter;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OracleJsonValue Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<OracleJsonValue> Values { get; }
    public KeyValuePair`2<string, OracleJsonValue> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal OsonObject(OsonContext ctx, int pos);
    internal OracleJsonValue Get(object key);
    public virtual string ToJsonString();
    internal Byte[] GetBytes(string key);
    internal Byte[] GetBytes(string key, Byte[] d);
    internal double GetDouble(string key);
    internal double GetDouble(string key, double d);
    private OracleJsonNumber GetNumeric(int childOffset);
    internal long GetLong(string key, long d);
    internal decimal GetBigDecimal(string key, decimal d);
    internal long GetLong(string key);
    internal decimal GetBigDecimal(string key);
    internal DateTime GetDateTime(string key);
    internal DateTime GetDateTime(string key, DateTime defaultValue);
    internal OracleJsonValue Put(string name, string value);
    internal OracleJsonValue Put(string name, int value);
    internal OracleJsonValue Put(string name, long value);
    internal OracleJsonValue PPt(string name, decimal value);
    internal OracleJsonValue Put(string name, double value);
    internal OracleJsonValue Put(string name, bool value);
    internal OracleJsonValue PutNull(string name);
    internal OracleJsonValue Put(string name, DateTime defaultValue);
    internal OracleJsonValue Put(string name, Byte[] values);
    internal OracleJsonValue Put(string key, OracleJsonValue value);
    internal OracleJsonValue Remove(object key);
    private NotSupportedException CreateNotModifiable();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, OracleJsonValue item);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool TryGetValue(string key, OracleJsonValue& value);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(string key);
    public sealed virtual OracleJsonValue get_Item(string key);
    public sealed virtual void set_Item(string key, OracleJsonValue value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<OracleJsonValue> get_Values();
    public sealed virtual void Add(KeyValuePair`2<string, OracleJsonValue> item);
    public sealed virtual bool Remove(KeyValuePair`2<string, OracleJsonValue> item);
    public sealed virtual bool Contains(KeyValuePair`2<string, OracleJsonValue> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, OracleJsonValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,OracleInternal.Json.Sql.OracleJsonValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual KeyValuePair`2<string, OracleJsonValue> get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class OracleInternal.Json.Binary.OsonPrimitiveConversions : object {
    private static int HUNDIGMAX;
    private static int BIGINTARRAYMAX;
    private static int BIGLENMAX;
    private static byte DIGEND;
    private static int LNXSGNBT;
    private static byte LNXDIGS;
    private static int LNXBASE;
    private static int LNXEXPMX;
    private static byte LNXEXPBS;
    private static int LNXEXPMN;
    private static byte ODIGEND;
    internal static int SIZE_TIMESTAMP;
    internal static int SIZE_TIMESTAMP_NOFRAC;
    internal static int SIZE_TIMESTAMPTZ;
    internal static int SIZE_DATE;
    private static int TZ_OFFSET_HOURS;
    private static int TZ_OFFSET_MINUTES;
    private static int MAXYEAR;
    private static int INTERVAL_BYTE_OFFSET;
    private static UInt32 INTERVAL_INT_OFFSET;
    private static int SECONDS_PER_DAY;
    private static int HOURS_PER_DAY;
    private static int MINUTES_PER_HOUR;
    private static int SECONDS_PER_MINUTE;
    private static OsonPrimitiveConversions();
    private static int Nanos(Byte[] bytes);
    private static void YearError(IExceptionFactory f, int year);
    internal static bool IsPosInf(Byte[] b);
    internal static bool IsNegInf(Byte[] b, int len, int offset);
    private static int TruncateZeros(int i);
    private static void AppendInt(StringBuilder result, int n, int i);
    internal static string TimestampToString(IExceptionFactory f, Byte[] bytes);
    internal static string TimestampTZToString(IExceptionFactory f, Byte[] bytes);
    internal static DateTime DateToLocalDateTime(IExceptionFactory f, Byte[] bytes);
    internal static DateTime TimestampToLocalDateTime(IExceptionFactory f, Byte[] bytes);
    internal static Byte[] ToOracleDate(IExceptionFactory f, DateTime local);
    internal static Byte[] ToOracleTimestamp(IExceptionFactory f, DateTime local);
    internal static string DateToString(IExceptionFactory f, Byte[] bytes);
    internal static TimeSpan IntervalDSToDuration(Byte[] raw);
    internal static string SerializeIntervalDS(IExceptionFactory f, Byte[] raw);
    internal static Byte[] DurationToIntervalDS(TimeSpan duration);
    private static void WriteIntervalInt(long value, int offset, Byte[] bytes);
    private static int GetDaysFromIntervalDS(Byte[] bytes);
    private static int GetHoursFromIntervalDS(Byte[] bytes);
    private static int GetMinutesFromIntervalDS(Byte[] bytes);
    private static int GetSecondsFromIntervalDS(Byte[] bytes);
    private static long GetNanosFromIntervalDS(Byte[] bytes);
    internal static Period IntervalYMToPeriod(Byte[] raw);
    internal static Byte[] PeriodToIntervalYM(IExceptionFactory f, Period p);
    private static int GetMonthFromIntervalYM(Byte[] raw);
    private static int GetYearFromIntervalYM(Byte[] raw);
    internal static string SerializeIntervalYM(IExceptionFactory f, Byte[] raw);
    internal static Byte[] DateTimeToTimestamp(IExceptionFactory f, DateTime instant);
    internal static Byte[] DateTimeToDate(IExceptionFactory f, DateTime instant);
    private static int GetNanos(Byte[] buffer, int off);
    private static int GetJavaYear(int cent, int decade);
    internal static Byte[] DoubleToCanonicalFormatBytes(double _d);
    internal static double CanonicalFormatBytesToDouble(Byte[] b);
    internal static Byte[] FloatToCanonicalFormatBytes(float _f);
    internal static float CanonicalFormatBytesToFloat(Byte[] b);
    internal static Byte[] GetOracleNumberFromDecimal(decimal dec);
    internal static Byte[] ToNumber(decimal BigDecNum);
    internal static Byte[] ToNumber(BigInteger BigIntNum);
    internal static Byte[] ToNumber(long value);
    private static Byte[] _makeZero();
    private static Byte[] _toLnxFmt(Byte[] num, bool pos);
    private static Byte[] ToNumber(int value);
    private static int Log100(long longNum);
    private static void LnxminEncodeP1(int digit, int exponent, Byte[] dst, int offset);
    private static void LnxminEncodeN1(int digit, int exponent, Byte[] dst, int offset);
    private static void LnxminEncodeP(long val, int exponent, int digits, int leastDigit, Byte[] dst, int offset);
    private static void LnxminEncodeN(long val, int exponent, int digits, int leastDigit, Byte[] dst, int offset);
    internal static decimal ToBigDecimal(Byte[] num);
    private static bool _isZero(Byte[] num);
    private static bool _isInf(Byte[] num);
    private static bool _isPositive(Byte[] num);
    private static Byte[] _fromLnxFmt(Byte[] num);
}
internal abstract class OracleInternal.Json.Binary.OsonStructure : OracleJsonValue {
    protected OsonContext m_ctx;
    protected int m_pos;
    protected int m_size;
    protected byte m_childOffsetUb;
    protected int m_childArrayOffset;
    internal OsonStructure(OsonContext ctx);
    internal int Size();
    internal bool IsEmpty();
    protected virtual void Init(int pos);
    protected void InitChildOffseUb(int op);
    internal bool GetBooleanInternal(int offset);
    internal string GetStringInternal(int offset);
    internal bool IsNullInternal(int childOffset);
    internal object GetValueInternal(int offset);
    internal static object GetValueInternal(int offset, OracleOsonValueFactory factory, OsonContext ctx);
    private static object GetForwardedValue(int relativeOffset, OracleOsonValueFactory factory, OsonContext ctx);
    private static object GetOverflowValue(int absoluteOffset, OracleOsonValueFactory factory, OsonContext ctx);
    private static Byte[] ReadRaw(int offset, int len, OsonContext ctx);
    protected static Byte[] ReadTimestamp(OsonBuffer b, int offset);
    protected static Byte[] ReadTimestampTZ(OsonBuffer b, int offset);
    protected static Byte[] ReadVector(OsonBuffer b, int offset);
    protected OsonAbstractArray GetArrayInternal(int childOffset);
    protected OsonAbstractObject GetJsonObjectInternal(int childOffset);
    protected abstract virtual int GetChildOffset(int child);
    internal ByteBuffer GetBuffer();
}
internal abstract class OracleInternal.Json.Binary.OsonValueFactory : object {
    internal abstract virtual OsonAbstractArray CreateArray(OsonContext ctx, int pos);
    internal abstract virtual OsonAbstractObject CreateObject(OsonContext ctx, int pos);
    internal abstract virtual object CreateString(OsonContext ctx, int pos, int len);
    internal abstract virtual OracleJsonNumber CreateNumber(Byte[] raw, TargetType type);
    internal abstract virtual OracleJsonNumber CreateStringNumber(string value);
    internal abstract virtual OracleJsonNumber CreateDouble(double value);
    internal abstract virtual object CreateBinary(Byte[] values, bool isId);
    internal abstract virtual object CreateTimestamp(Byte[] raw);
    internal abstract virtual object CreateTimestampTZ(Byte[] raw);
    internal abstract virtual OracleJsonNumber CreateFloat(float flt);
    internal abstract virtual object CreateDate(Byte[] raw);
    internal abstract virtual object CreateIntervalYM(Byte[] raw);
    internal abstract virtual object CreateIntervalDS(Byte[] raw);
    internal abstract virtual object CreateVector(Byte[] raw);
    internal abstract virtual object CreateTrue();
    internal abstract virtual object CreateFalse();
    internal abstract virtual object CreateNull();
}
internal class OracleInternal.Json.Binary.StreamContext : object {
    internal int m_depth;
    internal BitSet m_stack;
    private BitSet m_hasChildren;
    internal bool m_pendingKey;
    internal bool m_done;
    internal IExceptionFactory m_exceptionFactory;
    internal StreamContext(IExceptionFactory exceptionFactory);
    internal void Init();
    internal void StartObject();
    internal void PendingKey();
    internal void StartArray();
    internal void End();
    internal void Primitive();
    private void BeginValue();
    internal bool InObject();
    internal bool HasChildren();
    internal void Close();
    internal void SetExceptionFactory(IExceptionFactory f);
}
internal class OracleInternal.Json.Binary.UTF8JsonOutput : object {
    internal static char MIN_HIGH_SURROGATE;
    internal static char MAX_HIGH_SURROGATE;
    private Byte[] m_buffer;
    private BinaryWriter m_outWriter;
    private int m_pos;
    private Char[] m_cbuffer;
    internal UTF8JsonOutput(Stream stream);
    public sealed virtual void Close();
    public sealed virtual void Flush();
    private int EnsureCapacity(int count);
    public sealed virtual void WriteAscii(Char[] value);
    public sealed virtual void WriteAscii(Char[] value, int pos, int count);
    public sealed virtual void WriteAscii(char value);
    public void WriteAscii(Byte[] value, int pos, int count);
    public sealed virtual void WriteAscii(byte value);
    public sealed virtual void WriteAscii(string value);
    public sealed virtual void WriteAscii(string value, int pos, int count);
    public sealed virtual void Write(char c);
    public sealed virtual void Write(Char[] value, int pos, int count);
    public sealed virtual void Write(string value);
    public sealed virtual void Write(string value, int pos, int count);
    public sealed virtual void WriteSurrogates(char c1, char c2);
    public sealed virtual void Utf8(Byte[] array, int offset, int len);
    public sealed virtual bool Utf8();
}
internal class OracleInternal.Json.Binary.WriterJsonOutput : object {
    private Char[] m_buffer;
    private int m_pos;
    private TextWriter m_writer;
    internal WriterJsonOutput(TextWriter writer);
    public sealed virtual void Close();
    public sealed virtual void Flush();
    private int EnsureCapacity(int count);
    public sealed virtual void WriteAscii(Char[] value);
    public sealed virtual void WriteAscii(Char[] value, int pos, int count);
    public sealed virtual void WriteAscii(char value);
    public void WriteAscii(Byte[] value, int pos, int count);
    public sealed virtual void WriteAscii(byte value);
    public sealed virtual void WriteAscii(string value);
    public sealed virtual void WriteAscii(string value, int pos, int count);
    public sealed virtual void Write(char c);
    public sealed virtual void Write(Char[] value, int pos, int count);
    public sealed virtual void Write(string value);
    public sealed virtual void Write(string value, int pos, int count);
    public sealed virtual void WriteSurrogates(char c1, char c2);
    public sealed virtual bool Utf8();
    public sealed virtual void Utf8(Byte[] array, int offset, int len);
}
internal interface OracleInternal.Json.Common.IExceptionFactory {
    public abstract virtual RuntimeException CreateJsonException(string message);
    public abstract virtual RuntimeException CreateGenerationException(string message);
}
internal interface OracleInternal.Json.Common.IJsonOutput {
    public abstract virtual void Flush();
    public abstract virtual void Write(char c);
    public abstract virtual void Write(Char[] str, int pos, int count);
    public abstract virtual void Write(string str);
    public abstract virtual void Write(string value, int pos, int count);
    public abstract virtual void WriteAscii(char c);
    public abstract virtual void WriteAscii(Char[] value);
    public abstract virtual void WriteAscii(Char[] value, int pos, int count);
    public abstract virtual void WriteAscii(byte value);
    public abstract virtual void WriteAscii(string str);
    public abstract virtual void WriteAscii(string str, int pos, int count);
    public abstract virtual void WriteSurrogates(char c1, char c2);
    public abstract virtual bool Utf8();
    public abstract virtual void Utf8(Byte[] array, int offset, int len);
    public abstract virtual void Close();
}
internal class OracleInternal.Json.Common.IllegalStateException : RuntimeException {
    internal IllegalStateException(string message);
}
internal interface OracleInternal.Json.Common.IOracleJsonArray {
}
internal interface OracleInternal.Json.Common.IOracleJsonGenerator {
    public abstract virtual IOracleJsonGenerator WriteStartObject();
    public abstract virtual IOracleJsonGenerator WriteStartObject(string key);
    public abstract virtual IOracleJsonGenerator WriteStartArray();
    public abstract virtual IOracleJsonGenerator WriteStartArray(string key);
    public abstract virtual IOracleJsonGenerator WriteKey(string key);
    public abstract virtual IOracleJsonGenerator Write(OracleJsonValue value);
    public abstract virtual IOracleJsonGenerator Write(string key, OracleJsonValue value);
    public abstract virtual IOracleJsonGenerator Write(string value);
    public abstract virtual IOracleJsonGenerator Write(string key, string value);
    public abstract virtual IOracleJsonGenerator Write(decimal value);
    public abstract virtual IOracleJsonGenerator Write(string key, decimal value);
    public abstract virtual IOracleJsonGenerator Write(BigInteger value);
    public abstract virtual IOracleJsonGenerator Write(string key, BigInteger value);
    public abstract virtual IOracleJsonGenerator Write(int value);
    public abstract virtual IOracleJsonGenerator Write(string key, int value);
    public abstract virtual IOracleJsonGenerator Write(long value);
    public abstract virtual IOracleJsonGenerator Write(string key, long value);
    public abstract virtual IOracleJsonGenerator Write(double value);
    public abstract virtual IOracleJsonGenerator Write(string key, double value);
    public abstract virtual IOracleJsonGenerator Write(float value);
    public abstract virtual IOracleJsonGenerator Write(string key, float value);
    public abstract virtual IOracleJsonGenerator Write(bool value);
    public abstract virtual IOracleJsonGenerator Write(string key, bool value);
    public abstract virtual IOracleJsonGenerator Write(DateTime value);
    public abstract virtual IOracleJsonGenerator Write(string key, DateTime value);
    public abstract virtual IOracleJsonGenerator Write(Period value);
    public abstract virtual IOracleJsonGenerator Write(string key, Period value);
    public abstract virtual IOracleJsonGenerator Write(TimeSpan value);
    public abstract virtual IOracleJsonGenerator Write(string key, TimeSpan value);
    public abstract virtual IOracleJsonGenerator Write(Byte[] value);
    public abstract virtual IOracleJsonGenerator WriteId(Byte[] value);
    public abstract virtual IOracleJsonGenerator Write(string key, Byte[] value);
    public abstract virtual IOracleJsonGenerator WriteNull();
    public abstract virtual IOracleJsonGenerator WriteNull(string key);
    public abstract virtual IOracleJsonGenerator WriteEnd();
    public abstract virtual IOracleJsonGenerator WriteParser(Utf8JsonReader parser);
    public abstract virtual void Close();
    public abstract virtual void Flush();
}
internal interface OracleInternal.Json.Common.IOracleJsonObject {
}
internal interface OracleInternal.Json.Common.IOracleJsonStructure {
}
internal interface OracleInternal.Json.Common.IOracleJsonValue {
    public abstract virtual OracleJsonType GetOracleJsonType();
    public abstract virtual string ToJsonString();
    public abstract virtual IOracleJsonObject AsJsonObject();
    public abstract virtual IOracleJsonArray AsJsonArray();
    public abstract virtual OracleJsonString AsJsonString();
    public abstract virtual OracleJsonDecimal AsJsonDecimal();
    public abstract virtual OracleJsonDouble AsJsonDouble();
    public abstract virtual OracleJsonFloat AsJsonFloat();
    public abstract virtual OracleJsonNumber AsJsonNumber();
    public abstract virtual OracleJsonIntervalDS AsJsonIntervalDS();
    public abstract virtual OracleJsonIntervalYM AsJsonIntervalYM();
    public abstract virtual OracleJsonTimestamp AsJsonTimestamp();
    public abstract virtual OracleJsonDate AsJsonDate();
    public abstract virtual OracleJsonBinary AsJsonBinary();
}
internal class OracleInternal.Json.Common.JsonpExceptionFactory : object {
    internal static JsonpExceptionFactory INSTANCE;
    private static JsonpExceptionFactory();
    public sealed virtual RuntimeException CreateJsonException(string message);
    public sealed virtual RuntimeException CreateGenerationException(string message);
}
internal class OracleInternal.Json.Common.JsonpGeneratorWrapper : object {
    private IOracleJsonGenerator m_wrapped;
    public JsonpGeneratorWrapper(IOracleJsonGenerator wrapped);
    public void Close();
    public void Flush();
    public JsonpGeneratorWrapper WriteKey(string key);
    private JsonException Translate(OracleJsonException e);
    public void WriteJsonParser(Utf8JsonReader parser);
    public JsonpGeneratorWrapper Write(string arg);
    public JsonpGeneratorWrapper Write(decimal arg);
    public JsonpGeneratorWrapper Write(BigInteger arg);
    public JsonpGeneratorWrapper Write(int arg);
    public JsonpGeneratorWrapper Write(long arg);
    public JsonpGeneratorWrapper Write(double arg);
    public JsonpGeneratorWrapper Write(bool arg);
    public JsonpGeneratorWrapper Write(string key, string arg);
    public JsonpGeneratorWrapper Write(string key, BigInteger arg);
    public JsonpGeneratorWrapper Write(string key, decimal arg);
    public JsonpGeneratorWrapper Write(string key, int arg);
    public JsonpGeneratorWrapper Write(string key, long arg);
    public JsonpGeneratorWrapper Write(string key, double arg);
    public JsonpGeneratorWrapper Write(string key, bool arg);
    public JsonpGeneratorWrapper WriteEnd();
    public JsonpGeneratorWrapper WriteNull();
    public JsonpGeneratorWrapper WriteNull(string key);
    public JsonpGeneratorWrapper WriteStartArray();
    public JsonpGeneratorWrapper WriteStartArray(string key);
    public JsonpGeneratorWrapper WriteStartObject();
    public JsonpGeneratorWrapper WriteStartObject(string key);
}
internal class OracleInternal.Json.Common.OracleExceptionFactory : object {
    public sealed virtual RuntimeException CreateJsonException(string message);
    public sealed virtual RuntimeException CreateGenerationException(string message);
}
internal class OracleInternal.Json.Common.OracleJsonException : RuntimeException {
    private static long s_serialVersionUID;
    internal OracleJsonException(string message);
}
internal class OracleInternal.Json.Common.OracleJsonExceptions : object {
    internal static IExceptionFactory ORACLE_FACTORY;
    internal static OracleJsonExceptions IO;
    internal static OracleJsonExceptions BAD_YEAR;
    internal static OracleJsonExceptions NOT_IMPLEMENTED;
    internal static OracleJsonExceptions CORRUPT;
    internal static OracleJsonExceptions UNSUPPORTED_VERSION;
    internal static OracleJsonExceptions LONG_KEY;
    internal static OracleJsonExceptions IMAGE_TOO_BIG;
    internal static OracleJsonExceptions CORRUPT2;
    internal static OracleJsonExceptions NO_DAYS_ALLOWED;
    internal static OracleJsonExceptions BAD_WRAP;
    internal static OracleJsonExceptions GENERATION_INCOMPLETE;
    internal static OracleJsonExceptions MISSING_KEY;
    internal static OracleJsonExceptions EXTRA_EVENTS;
    internal static OracleJsonExceptions BAD_END;
    internal static OracleJsonExceptions BAD_KEY;
    internal static OracleJsonExceptions EXPECTED_VALUE;
    internal static OracleJsonExceptions KEY_TOO_LONG;
    internal static OracleJsonExceptions OVERFLOW;
    internal static OracleJsonExceptions BAD_PARSER_STATE;
    internal static OracleJsonExceptions BAD_PARSER_STATE3;
    internal static OracleJsonExceptions BAD_PARSER_STATE_VALUE;
    internal static OracleJsonExceptions OBJ_NOT_MUTABLE;
    internal static OracleJsonExceptions ARR_NOT_MUTABLE;
    protected string m_key;
    protected OracleJsonExceptions(string key);
    private static OracleJsonExceptions();
    internal virtual RuntimeException Create(IExceptionFactory f, Object[] args);
    internal string GetMessage(Object[] args);
}
internal class OracleInternal.Json.Common.OracleJsonGenerationException : OracleJsonException {
    private static long s_serialVersionUID;
    internal OracleJsonGenerationException(string message);
}
internal class OracleInternal.Json.Common.OracleJsonGenerationExceptions : OracleJsonExceptions {
    internal OracleJsonGenerationExceptions(string key);
    internal virtual RuntimeException Create(IExceptionFactory f, Object[] args);
}
internal class OracleInternal.Json.Common.OracleJsonIllegalStateExceptions : OracleJsonExceptions {
    internal OracleJsonIllegalStateExceptions(string key);
    internal virtual RuntimeException Create(IExceptionFactory f, Object[] args);
}
internal class OracleInternal.Json.Common.OracleJsonUnsupportedExceptions : OracleJsonExceptions {
    internal OracleJsonUnsupportedExceptions(string key);
    internal virtual RuntimeException Create(IExceptionFactory f, Object[] args);
}
internal class OracleInternal.Json.Common.Period : object {
    private int m_months;
    private int m_years;
    private int m_days;
    internal int Months { get; }
    internal int Years { get; }
    internal int Days { get; }
    internal Period(int years, int months);
    internal Period(int years, int months, int days);
    internal int get_Months();
    internal int get_Years();
    internal int get_Days();
}
internal class OracleInternal.Json.Common.RuntimeException : SystemException {
    internal RuntimeException(string message);
}
internal class OracleInternal.Json.Common.UnsupportedException : RuntimeException {
    internal UnsupportedException(string message);
}
internal enum OracleInternal.Json.Sql.NumberType : Enum {
    public int value__;
    public static NumberType NONE;
    public static NumberType SB4;
    public static NumberType SB8;
    public static NumberType DEC128;
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Json.Sql.OracleJsonArray : OracleJsonValue {
    private List`1<OracleJsonValue> m_list;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OracleJsonValue Item { get; public set; }
    internal OracleJsonArray(IOracleJsonArray other);
    public virtual OracleJsonType GetOracleJsonType();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual OracleJsonValue get_Item(int index);
    public sealed virtual void set_Item(int index, OracleJsonValue value);
    public sealed virtual int IndexOf(OracleJsonValue item);
    public sealed virtual void Insert(int index, OracleJsonValue item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(OracleJsonValue item);
    public sealed virtual void Add(OracleJsonValue item);
    public sealed virtual bool Contains(OracleJsonValue item);
    public sealed virtual void CopyTo(OracleJsonValue[] array, int arrayIndex);
    private sealed virtual override IEnumerator`1<OracleJsonValue> System.Collections.Generic.IEnumerable<OracleInternal.Json.Sql.OracleJsonValue>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool IsEmpty();
    public Enumerator<OracleJsonValue> Iterator();
    public Object[] ToArray();
    public sealed virtual void Clear();
    public OracleJsonValue Get(int index);
    public int IndexOf(object o);
    internal int LastIndexOf(object o);
    internal string GetString(int index);
    internal int GetInt(int index);
    internal double GetDouble(int index);
    internal decimal GetBigDecimal(int index);
    internal long GetLong(int index);
    internal bool GetBoolean(int index);
    internal OracleJsonObject GetObject(int index);
    internal OracleJsonArray GetArray(int index);
    internal bool IsNull(int index);
    internal DateTime GetInstant(int index);
    internal Byte[] GetBytes(int index);
    internal OracleJsonArray SubList(int fromIndex, int toIndex);
    internal void Add(double value);
    internal void Add(long value);
    internal void Add(decimal value);
    internal void Add(bool value);
    internal void Add(string value);
    internal void Add(int value);
    internal bool AddAll(List`1<OracleJsonValue> c);
    internal OracleJsonValue Set(int index, bool value);
    internal void Add(int index, OracleJsonValue element);
    private void CheckNull(OracleJsonValue element);
    internal OracleJsonValue Remove(int index);
    internal OracleJsonValue Set(int index, int value);
    internal OracleJsonValue Set(int index, double value);
    internal OracleJsonValue Set(int index, long value);
    internal OracleJsonValue Set(int index, decimal value);
    internal OracleJsonValue SetNull(int index);
    internal void DDNull();
    internal OracleJsonValue Set(int index, DateTime value);
    internal void Add(DateTime value);
    internal OracleJsonValue Set(int index, Byte[] value);
    internal void Add(Byte[] value);
    public virtual string ToJsonString();
}
internal class OracleInternal.Json.Sql.OracleJsonBinary : OracleJsonValue {
    protected static Char[] HEX_UPPER;
    protected static Char[] HEX_LOWER;
    private Byte[] m_bytes;
    private bool m_isId;
    internal OracleJsonBinary(Byte[] bytes, bool isId);
    private static OracleJsonBinary();
    public virtual OracleJsonType GetOracleJsonType();
    internal bool IsId();
    public virtual string ToJsonString();
    internal Byte[] GetBytes();
    internal string GetJsonString();
    internal static string GetJsonString(Byte[] bytes, bool isId);
    private static Char[] SerializeBinary(Byte[] bytes, Char[] hex);
}
internal class OracleInternal.Json.Sql.OracleJsonDate : OracleJsonValue {
    private Byte[] m_raw;
    internal OracleJsonDate(Byte[] raw);
    internal OracleJsonDate(DateTime i);
    public virtual OracleJsonType GetOracleJsonType();
    public virtual string ToJsonString();
    internal DateTime GetDateTime();
    internal string GetJsonString();
    internal Byte[] Raw();
    internal OracleJsonDate getDATE();
    internal IExceptionFactory GetExceptionFactory();
}
internal class OracleInternal.Json.Sql.OracleJsonDecimal : OracleJsonNumber {
    internal static string NEGATIVE_INF;
    internal static string POSITIVE_INF;
    private Byte[] m_raw;
    private TargetType m_targetType;
    internal OracleJsonDecimal(decimal value);
    internal OracleJsonDecimal(long value);
    internal OracleJsonDecimal(int value);
    internal OracleJsonDecimal(Byte[] raw, TargetType type);
    private static OracleJsonDecimal();
    public virtual OracleJsonType GetOracleJsonType();
    internal void Reset(Byte[] raw, TargetType type);
    internal virtual decimal BigDecimalValue();
    internal Byte[] Raw();
    internal virtual string GetJsonString();
    internal bool IsDec();
    internal bool IsSB4();
    internal bool IsSB8();
    internal virtual TargetType GetTargetType();
}
internal class OracleInternal.Json.Sql.OracleJsonDouble : OracleJsonNumber {
    internal static string NAN;
    private double m_value;
    internal OracleJsonDouble(double value);
    private static OracleJsonDouble();
    public virtual OracleJsonType GetOracleJsonType();
    internal virtual decimal BigDecimalValue();
    internal virtual double DoubleValue();
    internal virtual string GetJsonString();
    internal OracleJsonDouble GetDOUBLE();
}
internal class OracleInternal.Json.Sql.OracleJsonFactory : object {
    private static bool DISABLE_GENERATOR_POOL;
    private static int DEFAULT_BUFFER_SIZE;
    private OsonGeneratorStatePool generatorPool;
    public OracleJsonValue createJsonBinaryValue(Stream inStream);
    public OracleJsonValue createJsonBinaryValue(ByteBuffer inBuffer);
    public OracleJsonGenerator createJsonBinaryGenerator(Stream outStream);
    public OracleJsonGenerator createJsonTextGenerator(Stream outStream);
    public OracleJsonGenerator createJsonTextGenerator(TextWriter outWriter);
    public OracleJsonObject createObject();
    public OracleJsonArray createArray();
    public OracleJsonObject createObject(OracleJsonObject other);
    public OracleJsonArray createArray(OracleJsonArray other);
    public OracleJsonString createString(string value);
    public OracleJsonDecimal createDecimal(decimal value);
    public OracleJsonDecimal createDecimal(int value);
    public OracleJsonDecimal createDecimal(long value);
    public OracleJsonFloat createFloat(float value);
    public OracleJsonDouble createDouble(double value);
    public OracleJsonBinary createBinary(Byte[] value);
    public OracleJsonValue createBoolean(bool value);
    public OracleJsonValue createNull();
    public OracleJsonTimestamp createTimestamp(DateTime value);
    public OracleJsonDate createDate(DateTime i);
    public OracleJsonIntervalDS createIntervalDS(TimeSpan d);
    public OracleJsonIntervalYM createIntervalYM(Period p);
    private static Byte[] readInputStream(Stream inStream);
}
internal class OracleInternal.Json.Sql.OracleJsonFloat : OracleJsonNumber {
    private static string s_NAN;
    private float m_value;
    internal OracleJsonFloat(float value);
    public virtual OracleJsonType GetOracleJsonType();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual decimal BigDecimalValue();
    internal virtual float FloatValue();
    internal virtual string GetJsonString();
}
internal class OracleInternal.Json.Sql.OracleJsonIntervalDS : OracleJsonValue {
    internal static int INTERVALDS_LEN;
    private Byte[] m_raw;
    internal OracleJsonIntervalDS(Byte[] raw);
    internal OracleJsonIntervalDS(TimeSpan d);
    public virtual OracleJsonType GetOracleJsonType();
    public virtual string ToJsonString();
    internal string GetJsonString();
    internal Byte[] Raw();
    internal TimeSpan GetDuration();
    internal static string SerializeDuration(TimeSpan d, IExceptionFactory f);
    internal OracleJsonIntervalDS GetINTERVALDS();
}
internal class OracleInternal.Json.Sql.OracleJsonIntervalYM : OracleJsonValue {
    internal static int INTERVALYM_LEN;
    private Byte[] m_raw;
    internal OracleJsonIntervalYM(Byte[] raw);
    internal OracleJsonIntervalYM(Period p);
    public virtual OracleJsonType GetOracleJsonType();
    public virtual string ToJsonString();
    internal string GetJsonString();
    internal Byte[] Raw();
    internal Period GetPeriod();
    internal static string SerializePeriod(Period p, IExceptionFactory f);
    internal OracleJsonIntervalYM GetINTERVALYM();
}
internal abstract class OracleInternal.Json.Sql.OracleJsonNumber : OracleJsonValue {
    internal abstract virtual decimal BigDecimalValue();
    internal bool IsIntegral();
    internal int IntValue();
    internal int IntValueExact();
    internal long LongValue();
    internal long LongValueExact();
    internal virtual double DoubleValue();
    public virtual string ToJsonString();
    internal abstract virtual string GetJsonString();
    internal virtual float FloatValue();
    protected IExceptionFactory GetExceptionFactory();
}
[DefaultMemberAttribute("Item")]
internal class OracleInternal.Json.Sql.OracleJsonObject : OracleJsonStructure {
    internal Dictionary`2<string, OracleJsonValue> m_map;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public OracleJsonValue Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<OracleJsonValue> Values { get; }
    internal OracleJsonObject(IOracleJsonObject other);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(KeyValuePair`2<string, OracleJsonValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, OracleJsonValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, OracleJsonValue> item);
    public sealed virtual bool Remove(string key);
    public sealed virtual OracleJsonValue get_Item(string key);
    public sealed virtual void set_Item(string key, OracleJsonValue value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<OracleJsonValue> get_Values();
    public sealed virtual void Add(string key, OracleJsonValue value);
    public sealed virtual bool ContainsKey(string key);
    public bool Remove1(string key);
    public sealed virtual bool TryGetValue(string key, OracleJsonValue& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, OracleJsonValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,OracleInternal.Json.Sql.OracleJsonValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual OracleJsonType GetOracleJsonType();
    private void CheckNull(OracleJsonValue v);
    internal int Size();
    internal bool IsEmpty();
    internal OracleJsonValue Get(string key);
    internal OracleJsonValue Put(string key, OracleJsonValue value);
    internal void PutAll(Dictionary`2<string, OracleJsonValue> m);
    internal string GetJsonString(string name);
    internal string GetJsonString(string name, string defaultValue);
    internal int GetInt(string name);
    internal int GetInt(string name, int defaultValue);
    internal double GetDouble(string name);
    internal long GetLong(string key);
    internal decimal GetBigDecimal(string key);
    internal double GetDouble(string name, double defaultValue);
    internal long GetLong(string key, long defaultValue);
    internal decimal GetBigDecimal(string key, decimal defaultValue);
    internal bool GetBoolean(string name);
    internal bool GetBoolean(string name, bool defaultValue);
    internal bool IsNull(string name);
    internal DateTime GetDateTime(string name);
    internal DateTime GetDateTime(string name, DateTime defaultValue);
    internal OracleJsonObject GetObject(string name);
    internal OracleJsonArray GetArray(string name);
    internal Byte[] GetBytes(string name);
    internal Byte[] GetBytes(string name, Byte[] defaultValue);
    internal OracleJsonValue Put(string name, Byte[] value);
    internal OracleJsonValue Put(string name, string value);
    internal OracleJsonValue Put(string name, int value);
    internal OracleJsonValue Put(string name, long value);
    internal OracleJsonValue Put(string name, decimal value);
    internal OracleJsonValue Put(string name, double value);
    internal OracleJsonValue Put(string name, bool value);
    internal OracleJsonValue PutNull(string name);
    internal OracleJsonValue Put(string name, DateTime value);
    public virtual string ToJsonString();
}
internal class OracleInternal.Json.Sql.OracleJsonString : OracleJsonValue {
    private Char[] m_value;
    private int strLen;
    internal OracleJsonString(Char[] value);
    internal OracleJsonString(Char[] value, int length);
    internal string GetJsonString();
    internal int GetStringLen();
    internal Char[] GetCharArrRep();
    public virtual OracleJsonType GetOracleJsonType();
    public virtual string ToJsonString();
    protected IExceptionFactory GetExceptionFactory();
}
internal class OracleInternal.Json.Sql.OracleJsonStringNumber : OracleJsonDecimal {
    private string m_value;
    internal OracleJsonStringNumber(string value);
    internal virtual string GetJsonString();
    public virtual OracleJsonType GetOracleJsonType();
    internal virtual decimal BigDecimalValue();
    internal void Serialize(StringBuilder s);
    internal virtual TargetType GetTargetType();
}
internal class OracleInternal.Json.Sql.OracleJsonStructure : OracleJsonValue {
}
internal class OracleInternal.Json.Sql.OracleJsonTimestamp : OracleJsonValue {
    internal Byte[] m_raw;
    internal OracleJsonTimestamp(Byte[] raw);
    internal OracleJsonTimestamp(DateTime instant);
    public virtual OracleJsonType GetOracleJsonType();
    internal string GetJsonString();
    public virtual string ToJsonString();
    internal DateTime GetDateTime();
    internal Byte[] Raw();
    internal IExceptionFactory GetExceptionFactory();
}
internal class OracleInternal.Json.Sql.OracleJsonTimestampTZ : OracleJsonValue {
    internal Byte[] m_raw;
    internal OracleJsonTimestampTZ(Byte[] raw);
    internal OracleJsonTimestampTZ(DateTime instant);
    public virtual OracleJsonType GetOracleJsonType();
    internal string GetJsonString();
    public virtual string ToJsonString();
    internal DateTime GetDateTime();
    internal Byte[] Raw();
    internal IExceptionFactory GetExceptionFactory();
}
internal enum OracleInternal.Json.Sql.OracleJsonType : Enum {
    public int value__;
    public static OracleJsonType ARRAY;
    public static OracleJsonType OBJECT;
    public static OracleJsonType NULL;
    public static OracleJsonType TRUE;
    public static OracleJsonType FALSE;
    public static OracleJsonType STRING;
    public static OracleJsonType DECIMAL;
    public static OracleJsonType FLOAT;
    public static OracleJsonType DOUBLE;
    public static OracleJsonType TIMESTAMP;
    public static OracleJsonType TIMESTAMPTZ;
    public static OracleJsonType DATE;
    public static OracleJsonType INTERVALYM;
    public static OracleJsonType INTERVALDS;
    public static OracleJsonType BINARY;
    public static OracleJsonType VECTOR;
}
internal class OracleInternal.Json.Sql.OracleJsonValue : object {
    internal OracleJsonType m_type;
    internal string m_str;
    internal static OracleJsonValue NULL;
    internal static OracleJsonValue TRUE;
    internal static OracleJsonValue FALSE;
    internal OracleJsonValue(OracleJsonType jsonType, string jsonValue);
    private static OracleJsonValue();
    public virtual OracleJsonType GetOracleJsonType();
    public virtual string ToJsonString();
    public sealed virtual IOracleJsonObject AsJsonObject();
    public sealed virtual IOracleJsonArray AsJsonArray();
    public sealed virtual OracleJsonString AsJsonString();
    public sealed virtual OracleJsonDecimal AsJsonDecimal();
    public sealed virtual OracleJsonDouble AsJsonDouble();
    public sealed virtual OracleJsonFloat AsJsonFloat();
    public sealed virtual OracleJsonNumber AsJsonNumber();
    public sealed virtual OracleJsonIntervalDS AsJsonIntervalDS();
    public sealed virtual OracleJsonIntervalYM AsJsonIntervalYM();
    public sealed virtual OracleJsonTimestamp AsJsonTimestamp();
    public sealed virtual OracleJsonDate AsJsonDate();
    public sealed virtual OracleJsonBinary AsJsonBinary();
}
internal class OracleInternal.Json.Sql.OracleJsonVector : OracleJsonValue {
    private Byte[] m_raw;
    internal OracleJsonVector(Byte[] raw);
    public virtual OracleJsonType GetOracleJsonType();
    public virtual string ToJsonString();
    internal string GetJsonString();
}
internal enum OracleInternal.Json.Sql.TargetType : Enum {
    public int value__;
    public static TargetType INT;
    public static TargetType LONG;
    public static TargetType DECIMAL;
    public static TargetType NONE;
}
internal class OracleInternal.MTS.CCPFWPSPEManager : FWPSPEManager {
    internal CCPFWPSPEManager(OracleConnectionImpl connImpl, Transaction txn, MTSTxnRM txnRM, MTSTxnBranch txnBranch);
    internal virtual void InitialPSPEConn(Transaction txn, OracleConnectionImpl connImpl);
    internal virtual void ResetForPromotedTxn(OracleConnectionImpl connImpl, Transaction txn, string txnLocalId);
}
internal class OracleInternal.MTS.CCPMTSTxnBranch : MTSTxnBranch {
    internal CCPMTSTxnBranch(MTSTxnRM txnRM, int branchNum);
    internal virtual OracleConnectionImpl GetConnection(bool bMustMatch, Boolean& bMatchFound);
    internal virtual void ReleaseConnection(string txnOperation, OracleConnectionImpl connImpl, TransXID txnXID);
    internal virtual bool CanResetConnection(bool bMatchConn, TxnBranchState branchState);
}
internal class OracleInternal.MTS.CCPMTSTxnCtx : MTSTxnCtx {
}
internal class OracleInternal.MTS.CCPMTSTxnRM : MTSTxnRM {
    protected virtual override void Finalize();
    internal virtual void ReleaseRPs(SyncQueueList`1<ConnectionString> csList, Transaction txn);
    internal virtual void ReleaseRP(ConnectionString cs, Transaction txn);
    internal virtual void MTSTransactionCompleted(object sender, TransactionEventArgs e);
    internal virtual void UnRegisteringTxnEvent(Transaction txn);
}
internal class OracleInternal.MTS.DTCDebugConfig : object {
    internal static string DTC_DEBUG_EVENT_TAG;
    internal static UInt32 DTC_DEFAULT_ABORT_TIMEOUT;
    internal static DTCDebugEvent s_DTCDbgEvt;
    private static DTCDebugConfig();
}
internal enum OracleInternal.MTS.DTCDebugEvent : Enum {
    public int value__;
    public static DTCDebugEvent FAILPHASE2;
    public static DTCDebugEvent MTSConfig;
}
internal enum OracleInternal.MTS.EnlistedState : Enum {
    public int value__;
    public static EnlistedState Local;
    public static EnlistedState Distributed;
}
internal abstract class OracleInternal.MTS.FWPSPEManager : PSPEManager {
    private static MethodInfo s_promoteMethod;
    internal FWPSPEManager(OracleConnectionImpl connImpl, Transaction txn, MTSTxnRM txnRM, MTSTxnBranch txnBranch);
    internal static void InitPromoteAndEnlistMethod(MethodInfo promoteMethod);
    internal virtual Byte[] InternalPromote(Guid& txnGuid);
    internal virtual bool InternalCommit();
    internal virtual bool InternalRollback();
    internal virtual void InternalHandlePromoteError();
}
internal class OracleInternal.MTS.MTSError : object {
    internal static int DBERROR_TXN_NOT_EXIST;
    internal static int DBERROR_INVALID_TXNBRANCHLEN;
}
internal class OracleInternal.MTS.MTSFreeTxnBranches : object {
    private object m_lock;
    internal SyncDictionary`2<string, TxnBranchesByDBInst> m_freeBranchesByUserAuth;
    internal int Count { get; }
    internal void ClearBranches();
    internal int get_Count();
    internal void EnqueueBranch(MTSTxnBranch txnBranch);
    internal bool DequeueBranch(ConnectionString cs, string dbInstance, MTSTxnBranch& txnBranch);
}
internal class OracleInternal.MTS.MTSProxy : object {
    private MTSTxnRMPool m_CCPRMs;
    private MTSTxnRMPool m_OCPRMs;
    private string m_dbEasyConnectName;
    private object m_lock;
    internal MTSProxy(string easyConnectName);
    internal MTSTxnRM GetRM(bool bIsCCP, string serviceName, string pdbName, Transaction txn);
    internal void RemoveRM(bool bIsCCP, string txnLocalID);
}
internal class OracleInternal.MTS.MTSProxyPool : object {
    private static MTSProxies s_dbProxies;
    private static object s_lock;
    private static MTSProxyPool();
    internal static MTSTxnRM GetRM(bool bIsCCP, string easyConnectName, string serviceName, string pdbName, Transaction txn);
    internal static void ReleaseRM(bool bIsCCP, string dataSource, Transaction txn);
}
internal class OracleInternal.MTS.MTSRMManager : object {
    private static MTSRMManager();
    private static string CompressedIPv6(IPAddress address);
    private static Exception HandleException(Exception ex);
    private static void CheckPromotionRule(OracleConnectionImpl connImpl);
    internal static void EnlistPromotedTransaction(OracleConnectionImpl connImpl, Transaction txn, MTSTxnRM txnRM, MTSTxnBranch txnBranch, Guid sysTxnXID);
    internal static void CCPEnlistDistributedTxnToSysTxn(OracleConnectionImpl connImpl, Transaction txn, MTSTxnRM txnRM, MTSTxnBranch txnBranch);
    internal static void CCPEnlistTransaction(OracleConnectionImpl connImpl, Transaction transaction, OracleConnection connRefForCriteria);
    internal static void CCPEnlistTransaction(OracleConnectionImpl connImpl, Transaction transaction, MTSTxnRM txnRM, MTSTxnBranch txnBranch);
}
internal abstract class OracleInternal.MTS.MTSTxnBranch : object {
    internal static int ORA_ERR_SET_TXN_ISOLATIONLVL;
    protected MTSTxnRM m_mtsTxnRM;
    internal string m_txnLocalID;
    protected TransXID m_xid;
    internal OpoDTCTxnCtx m_opoDTCTxnCtx;
    internal ConnectionString m_connCreds;
    protected int m_branchNum;
    internal bool m_bNew;
    internal IsolationLevel m_txnIsolationLvl;
    internal string m_dbInstance;
    protected TxnBranchState m_branchState;
    private object m_lock;
    internal int BranchNumber { get; }
    internal TransXID TxnID { get; }
    internal TxnBranchState State { get; }
    internal bool IsInTxn { get; }
    internal MTSTxnBranch(MTSTxnRM txnRM, int branchNum);
    internal static MTSTxnBranch CreateTxnBranch(bool bIsCCP, MTSTxnRM txnRM, int branchNum);
    protected virtual override void Finalize();
    internal int get_BranchNumber();
    internal TransXID get_TxnID();
    internal TxnBranchState get_State();
    internal bool get_IsInTxn();
    internal abstract virtual OracleConnectionImpl GetConnection(bool bMustMatch, Boolean& bMatchFound);
    internal abstract virtual bool CanResetConnection(bool bMatchConn, TxnBranchState branchState);
    internal virtual void ReleaseConnection(string txnOperation, OracleConnectionImpl connImpl, TransXID txnXID);
    internal virtual void SetConnection(OracleConnectionImpl connImpl);
    internal void Set(string txnLocalID, Guid txnXID, IsolationLevel txnIsolationLvl);
    internal void StartDistributedTransaction(OracleConnectionImpl connImpl);
    internal void PromoteDistributedTransaction(OracleConnectionImpl connImpl);
    internal void Detach();
    internal void Detach(OracleConnectionImpl connImpl);
    internal TxnState Prepare();
    internal TxnState Commit();
    internal TxnState Abort();
}
internal class OracleInternal.MTS.MTSTxnBranches : SyncQueueList`1<MTSTxnBranch> {
    internal void ClearBranches();
}
internal class OracleInternal.MTS.MTSTxnCtx : object {
    internal MTSTxnType m_txnType;
    internal string m_txnLocalID;
    internal OracleTransactionImpl m_localTxn;
    internal MTSTxnBranch m_mtsTxnBranch;
    private long m_connImplId;
    internal static MTSTxnCtx CreateMTSTxnCtx(OracleConnectionImpl connImpl);
    internal virtual void SetCtx(OracleConnectionImpl connImpl);
    internal virtual void SetTxnState(bool bState);
    protected void Reset();
    internal virtual void Reset(OracleConnectionImpl connImpl);
    internal void SetLocalCtx(string txnLocalID, OracleTransactionImpl localTxn, long connImplId);
    internal void SetDistributedCtx(string txnLocalID, MTSTxnBranch mtsTxnBranch, long connImplId);
    internal void DelistTransaction(OracleConnectionImpl connImpl);
}
internal abstract class OracleInternal.MTS.MTSTxnRM : object {
    internal static int MaxNumOfBranches;
    internal Guid m_RMGuid;
    internal Transaction m_sysTxn;
    internal string m_txnLocalID;
    internal SyncQueueList`1<ConnectionString> m_connStrs;
    internal string m_serviceName;
    internal string m_pdbName;
    internal string m_dbEasyConnectName;
    internal string m_txnAffInstanceName;
    protected RMTxnState m_state;
    internal EnlistedState m_enlistedState;
    internal bool m_bIgnoreIsolationLvl;
    internal int m_branchNum;
    private MTSTxnBranches m_txnBranches;
    private MTSTxnBranches m_NotUsedBranches;
    private MTSFreeTxnBranches m_freeTxnBranches;
    private MTSTxnRMWorker m_RMWorker;
    private object m_lock;
    private object m_branchLock;
    internal object m_txnAffinityLock;
    internal bool m_bIsCCP;
    internal MTSTxnRM(bool bIsCCP);
    private static MTSTxnRM();
    protected virtual override void Finalize();
    internal abstract virtual void ReleaseRPs(SyncQueueList`1<ConnectionString> csList, Transaction txn);
    internal abstract virtual void ReleaseRP(ConnectionString cs, Transaction txn);
    internal virtual void UnRegisteringTxnEvent(Transaction txn);
    internal virtual void MTSTransactionCompleted(object sender, TransactionEventArgs e);
    internal void Initialize(string easyConnectName, string serviceName, string pdbName, Transaction txn);
    internal void Reset();
    internal void ReleaseRM();
    public sealed virtual void SinglePhaseCommit(SinglePhaseEnlistment singlePhaseEnlistment);
    public sealed virtual void Prepare(PreparingEnlistment preparingEnlistment);
    public sealed virtual void Commit(Enlistment enlistment);
    public sealed virtual void Rollback(Enlistment enlistment);
    public sealed virtual void InDoubt(Enlistment enlistment);
    private RMTxnState doPrepare();
    private RMTxnState doCommit();
    internal RMTxnState doAbort();
    private void doSinglePhaseCommit(object sender, OnSinglePhaseEventArgs e);
    private void doPrepare(object sender, OnPrepareEventArgs e);
    private void doCommit(object sender, OnCommitEventArgs e);
    private void doAbort(object sender, OnAbortEventArgs e);
    internal void EnlistToSysTransaction();
    internal TxnBranchesByDBInst GetFreeBranches(ConnectionString cs);
    internal MTSTxnBranch GetTxnBranch(ConnectionString cs, string dbInst);
    internal void ReleaseTxnBranch(MTSTxnBranch txnBranch);
    internal void FreeTxnBranch(MTSTxnBranch txnBranch);
    internal void AddBranch(OracleConnectionImpl connImpl, MTSTxnBranch txnBranch, Guid sysTxnXID);
    internal void DetachBranches();
    public virtual string ToString();
}
internal class OracleInternal.MTS.MTSTxnRMCache : object {
    private static SyncQueueList`1<MTSTxnRM> m_CCPTxnRMs;
    private static MTSTxnRMCache();
    internal static MTSTxnRM GetRM(bool bIsCCP);
    internal static void PutRM(MTSTxnRM txnRM);
}
internal class OracleInternal.MTS.MTSTxnRMWorker : object {
    [CompilerGeneratedAttribute]
private OnPrepareEventHandler PrepareEvent;
    [CompilerGeneratedAttribute]
private OnCommitEventHandler CommitEvent;
    [CompilerGeneratedAttribute]
private OnAbortEventHandler AbortEvent;
    [CompilerGeneratedAttribute]
private OnSinglePhaseEventHandler SinglePhaseEvent;
    [CompilerGeneratedAttribute]
public void add_PrepareEvent(OnPrepareEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PrepareEvent(OnPrepareEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CommitEvent(OnCommitEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CommitEvent(OnCommitEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AbortEvent(OnAbortEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AbortEvent(OnAbortEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SinglePhaseEvent(OnSinglePhaseEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SinglePhaseEvent(OnSinglePhaseEventHandler value);
    protected virtual override void Finalize();
    public void OnPrepare(OnPrepareEventArgs e);
    public void OnCommit(OnCommitEventArgs e);
    public void OnAbort(OnAbortEventArgs e);
    public void OnSinglePhase(OnSinglePhaseEventArgs e);
}
internal enum OracleInternal.MTS.MTSTxnType : Enum {
    public int value__;
    public static MTSTxnType None;
    public static MTSTxnType Local;
    public static MTSTxnType Distributed;
}
internal class OracleInternal.MTS.OnAbortEventArgs : OnCommitEventArgs {
    internal OnAbortEventArgs(Enlistment enlistment);
}
internal class OracleInternal.MTS.OnAbortEventHandler : MulticastDelegate {
    public OnAbortEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OnAbortEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OnAbortEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class OracleInternal.MTS.OnCommitEventArgs : EventArgs {
    private Enlistment m_enlistment;
    internal Enlistment Enlistment { get; }
    internal OnCommitEventArgs(Enlistment enlistment);
    internal Enlistment get_Enlistment();
}
internal class OracleInternal.MTS.OnCommitEventHandler : MulticastDelegate {
    public OnCommitEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OnCommitEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OnCommitEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class OracleInternal.MTS.OnPrepareEventArgs : EventArgs {
    private PreparingEnlistment m_preparingEnlistment;
    internal PreparingEnlistment Enlistment { get; }
    internal OnPrepareEventArgs(PreparingEnlistment enlistment);
    internal PreparingEnlistment get_Enlistment();
}
internal class OracleInternal.MTS.OnPrepareEventHandler : MulticastDelegate {
    public OnPrepareEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OnPrepareEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OnPrepareEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class OracleInternal.MTS.OnSinglePhaseEventArgs : EventArgs {
    private SinglePhaseEnlistment m_singlePhaseEnlistment;
    internal SinglePhaseEnlistment Enlistment { get; }
    internal OnSinglePhaseEventArgs(SinglePhaseEnlistment enlistment);
    internal SinglePhaseEnlistment get_Enlistment();
}
internal class OracleInternal.MTS.OnSinglePhaseEventHandler : MulticastDelegate {
    public OnSinglePhaseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OnSinglePhaseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OnSinglePhaseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class OracleInternal.MTS.OpoDTCTxnCtx : object {
    internal OpoDTCTxnXIDRefCtx m_opoDTCTxnXID;
    internal Byte[] m_txnCtx;
    internal long m_applicationValue;
    internal OpoDTCTxnCtx(OpoDTCTxnXIDRefCtx opoDTCTxnXID);
}
internal class OracleInternal.MTS.OpoDTCTxnXIDRefCtx : object {
    internal int m_formatID;
    internal int m_gtrid_length;
    internal int m_bqual_length;
    internal Byte[] m_data;
}
internal abstract class OracleInternal.MTS.PSPEManager : PSPETxnManagerBase {
    internal static bool s_bUseDotNetAPIForPromotion;
    internal static string s_promotableMethodName;
    internal OracleConnectionImpl m_connImpl;
    protected ConnectionString m_connStr;
    protected Transaction m_sysTxn;
    protected MTSTxnRM m_mtsTxnRM;
    private MTSTxnBranch m_promotedTxnBranch;
    internal PSPEManager(OracleConnectionImpl connImpl, Transaction txn, MTSTxnRM txnRM, MTSTxnBranch txnBranch);
    private static PSPEManager();
    internal abstract virtual Byte[] InternalPromote(Guid& txnGuid);
    internal abstract virtual bool InternalCommit();
    internal abstract virtual bool InternalRollback();
    internal abstract virtual void InternalHandlePromoteError();
    internal abstract virtual void InitialPSPEConn(Transaction txn, OracleConnectionImpl connImpl);
    internal abstract virtual void ResetForPromotedTxn(OracleConnectionImpl connImpl, Transaction txn, string txnLocalId);
    internal static PSPEManager Create(OracleConnectionImpl connImpl, Transaction txn, MTSTxnRM txnRM, MTSTxnBranch txnBranch);
    internal void ReleaseRM(ConnectionString cs);
    public virtual void Initialize();
    public virtual Byte[] Promote();
    public virtual void SinglePhaseCommit(SinglePhaseEnlistment singlePhaseEnlistment);
    public virtual void Rollback(SinglePhaseEnlistment singlePhaseEnlistment);
}
internal abstract class OracleInternal.MTS.PSPETxnManagerBase : object {
    internal OracleTransaction m_oraTransaction;
    internal OracleCredential m_orclCredential;
    internal OracleOpaqueString m_opaquePassw;
    internal OracleOpaqueString m_opaqueProxyPassw;
    internal bool m_bLocalTxnPromoted;
    internal string m_localTxnIdentifier;
    internal bool m_bConnectionClosed;
    public abstract virtual void Initialize();
    public abstract virtual void Rollback(SinglePhaseEnlistment singlePhaseEnlistment);
    public abstract virtual void SinglePhaseCommit(SinglePhaseEnlistment singlePhaseEnlistment);
    public abstract virtual Byte[] Promote();
}
internal enum OracleInternal.MTS.RMTxnState : Enum {
    public int value__;
    public static RMTxnState Invalid;
    public static RMTxnState Started;
    public static RMTxnState Enlisted;
    public static RMTxnState Preparing;
    public static RMTxnState Prepared_OnePhase;
    public static RMTxnState Prepared_ToCommit;
    public static RMTxnState Prepared_ReadOnly;
    public static RMTxnState Prepared_Failed;
    public static RMTxnState Committing;
    public static RMTxnState Committed;
    public static RMTxnState Commit_Failed;
    public static RMTxnState RollingBack;
    public static RMTxnState RolledBack;
    public static RMTxnState Rollback_Failed;
}
internal class OracleInternal.MTS.TransXID : object {
    private static int ORAMTSTXNFORMAT;
    private static int MSDTCTXNFORMAT;
    internal static int ORAXIDSIZE;
    internal static int GUIDLEN;
    internal static int MAXBRANCHGUILD_LEN;
    internal static int BRANCHREQ_LEN;
    internal static int MAXRRECOHOSTNAME_LEN;
    internal OpoDTCTxnXIDRefCtx m_opoDTCTxnXID;
    private Guid m_rmGuid;
    private Guid m_txnGuid;
    private int m_branchNum;
    private static TransXID();
    private TransXID(int oraMTSFormatID, int MSDTCFormatID, Guid txnGuid, Guid rmGuid, int branchNum, string machineName, ushort port);
    protected virtual override void Finalize();
    internal static TransXID CreateOracleXID(Guid txnGuid, Guid rmGuid, int branchNum);
    public virtual string ToString();
}
internal class OracleInternal.MTS.TxnBranchesByDBInst : TxnBranchesByString {
}
internal class OracleInternal.MTS.TxnBranchesByString : SyncDictionary`2<string, MTSTxnBranches> {
    private object m_lock;
    internal int BranchCount { get; }
    internal void ClearBranches();
    internal int get_BranchCount();
    internal void EnqueueBranch(string dbInstance, MTSTxnBranch txnBranch);
    internal bool DequeueBranch(string dbInstance, MTSTxnBranch& txnBranch);
}
internal enum OracleInternal.MTS.TxnBranchState : Enum {
    public int value__;
    public static TxnBranchState NotValid;
    public static TxnBranchState InUse;
    public static TxnBranchState Free;
    public static TxnBranchState Done;
}
internal enum OracleInternal.MTS.TxnState : Enum {
    public int value__;
    public static TxnState K2CMDprepare;
    public static TxnState K2CMDrqcommit;
    public static TxnState K2CMDcommit;
    public static TxnState K2CMDabort;
    public static TxnState K2CMDrdonly;
    public static TxnState K2CMDforget;
    public static TxnState K2CMDrecovered;
    public static TxnState K2CMDtimeout;
    public static TxnState Error;
    public static TxnState NotStarted;
    public static TxnState Started;
    public static TxnState XStarted;
    public static TxnState Detached;
}
internal class OracleInternal.Network.AcceptPacket : Packet {
    internal Byte[] m_AcceptData;
    private Byte[] m_UUID;
    private bool m_FastAuthEnabled;
    private int m_ACFL2;
    private bool m_AcceptDataOF;
    internal Byte[] UUID { get; }
    internal AcceptPacket(Packet pkt);
    internal AcceptPacket(SessionContext sessCtx, string AcceptData);
    internal Byte[] get_UUID();
    internal virtual void Send();
}
internal class OracleInternal.Network.AddressResolution : object {
    private NVPair m_dlist;
    private static int length_of_alias_prefix;
    internal static int DEFAULT_DATABASE_PORT;
    internal static Char[] colonORslash;
    internal static string POOLED_SERVER;
    internal static string SHARED_SERVER;
    internal static string DEDICATED_SERVER;
    internal static string DEFAULT_CONNECT_PROTOCOL;
    internal static List`1<string> All_PROTOCOLS;
    internal static string DEFAULT_CONNECT_PROTOCOL_LOWERCASE;
    internal static string SSL_CONNECT_PROTOCOL;
    internal static string SSL_CONNECT_PROTOCOL_LOWERCASE;
    internal static string ANO_CONNECT_PROTOCOL;
    internal static string ANO_CONNECT_PROTOCOL_LOWERCASE;
    internal static string WEBSOCK_CONNECT_PROTOCOL;
    internal static string WEBSOCK_CONNECT_PROTOCOL_LOWERCASE;
    internal static string WEBSOCK_SECURE_CONNECT_PROTOCOL;
    internal static string WEBSOCK_SECURE_CONNECT_PROTOCOL_LOWERCASE;
    internal static string BEGIN_DBL_SLASH;
    internal static string OPENING_SQUARE_BRACE;
    internal static string BEG_CID;
    internal static string BEG_USER;
    internal static string BEG_ADDR;
    internal static string BEG_HOST;
    internal static string BEG_PORT;
    internal static string BEG_DESC;
    internal static string BEG_CCLS;
    internal static string BEG_PURE;
    internal static string BEG_STAG;
    internal static string BEG_SRVR;
    internal static string BEG_TUNL;
    internal static string BEG_INST;
    internal static string BEG_SKEY;
    internal static string BEG_SSKEY;
    internal static string BEG_PROGRAM;
    internal static string BEG_CONDATA;
    internal static string BEG_CONDATA_SVC;
    internal static string BEG_CONNECTION_ID;
    internal static string BEG_CONNECTION_ID_PREFIX;
    internal static string END_THREE_BRACES;
    internal static string END_TWO_BRACES;
    internal static string END_ONE_BRACE;
    internal static string ALIAS;
    internal static string CID;
    internal static string SID;
    internal static string INSTANCE_NAME;
    internal static string SERVICE_NAME;
    internal static string SERVER;
    internal static string PROTOCOL;
    internal static string ADDRESS;
    internal static string CONNECT_DATA;
    internal static string ADDRESS_LIST;
    internal static string FAILOVER_MODE;
    internal static string HOST;
    internal static string PORT;
    internal static string IP;
    internal static string SDU;
    internal static string TDU;
    internal static string SBS;
    internal static string RBS;
    internal static string SendBufSize;
    internal static string RecvBufSize;
    internal static string DESCRIPTION;
    internal static string SOURCE_ROUTE;
    internal static string DESCRIPTION_LIST;
    internal static string RETRY_COUNT;
    internal static string RETRY_DELAY;
    internal static string TRANSPORT_CONNECT_TO;
    internal static string SECURITY;
    internal static string SSL_VERSION;
    internal static string WALLETDIR;
    internal static string WALLETLOC;
    internal static string SSLServerDN;
    internal static string SSLServerDNMatch;
    internal static string READONLY_CHUNK_OK;
    internal static string SSL_CERT_TPRNT;
    internal static string SSL_CERT_ALIAS;
    internal static string EncryptionClient;
    internal static string EncryptionTypesClient;
    internal static string CryptoChecksumClient;
    internal static string CryptoChecksumTypesClient;
    internal static string AllowWeakCrypto;
    internal static string TokenAuth;
    internal static string TokenLocation;
    internal static string PasswAuth;
    internal static string OCIIAMURL;
    internal static string OCITenancy;
    internal static string OCICompartment;
    internal static string OCIDatabase;
    internal static string OciConfigFile;
    internal static string OciProfile;
    internal static string DatabaseApplicationIdUri;
    internal static string TenantId;
    internal static string ClientId;
    internal static string ClientCertificate;
    internal static string RedirectUri;
    internal static string SID_ENV;
    internal static string HTTPS_PROXY;
    internal static string HTTPS_PROXY_PORT;
    internal static string WEBSOCK_URI;
    internal static string WEBSOCK_UNAME;
    internal static string ENABLE;
    internal static string EXPIRE_TIME;
    internal static string DEFAULT_ADDRESS;
    internal static string HOSTNAME;
    internal static string USERNAME;
    internal static string PROGRAMNAME;
    internal static NVPair nvp_CID;
    internal static string val_CID;
    internal static string ful_CID;
    internal bool connection_revised;
    internal bool connection_redirected;
    internal bool useAddrResConnectString;
    internal string m_tnsAddress;
    private NVPair m_desc;
    private string m_instanceName;
    private string m_ShardingKey;
    private string m_SuperShardingKey;
    internal ConnectionOption m_ConnectionOption;
    private SqlNetOraConfig m_SNOConfig;
    private Hashtable m_ObTnsHT;
    private Hashtable m_obLdpHT;
    private string m_ServerIs;
    private static SqlNetOraConfig m_SNOConfig_static;
    private bool DynNamingAdapterList;
    private string m_NamesDirectoryPath;
    private static char NLNVBEGDE;
    private static char NLNVENDDE;
    private static char NLNVASNOP;
    private static TNSNames m_TNSNames;
    private static LDAP m_LDAP;
    private static List`1<INamingAdapter> _NamingAdapters;
    private List`1<INamingAdapter> _NamingAdaptersDyn;
    private List`1<INamingAdapter> _CurNamingAdapters;
    private static INamingAdapter _DataSourcesAdapter;
    private List`1<string> HN;
    private List`1<string> EL;
    private int HNIndex;
    private string m_uniqueConnectionId;
    private string m_oraConConIdPrefix;
    private object m_TraceObj;
    private bool m_Tunnel;
    private static String[] LDAP_URL_SCHEMES;
    private static Char[] NCS;
    private static Char[] reservedNCS;
    internal static Byte[] ValidChars;
    internal string UniqueConnectionId { get; internal set; }
    internal object TraceObj { get; internal set; }
    unknown bool Tunnel {internal set; }
    private static AddressResolution();
    internal AddressResolution(string TNSAlias, SqlNetOraConfig SNOConfig, string oraConConIdPrefix, string uniqueConnectionId, object traceObj, Hashtable ObTnsHT, string ObTnsPt, Hashtable ObLdpHT, string NamesDirectoryPath, string instanceName, ConnectionOption CO, string ShardingKeyB64, string SuperShardingKeyB64, string ServerIs);
    internal string get_UniqueConnectionId();
    internal void set_UniqueConnectionId(string value);
    internal object get_TraceObj();
    internal void set_TraceObj(object value);
    internal void set_Tunnel(bool value);
    private static void SetupValidChars();
    internal static string VetCIDValue(string CIDValue);
    internal static void UpdateCID();
    internal static void SetNewTNSHT(Hashtable HT);
    internal static void SetNewLDAP(Hashtable SQLNetHT, Hashtable LdapHT);
    internal static void SetNewNDP(String[] adapters);
    public static void RefreshNamingAdapters();
    [IteratorStateMachineAttribute("OracleInternal.Network.AddressResolution/<NamingAdapters>d__163")]
public static IEnumerable NamingAdapters();
    [IteratorStateMachineAttribute("OracleInternal.Network.AddressResolution/<NamingAdapterMaps>d__164")]
public static IEnumerable NamingAdapterMaps();
    internal void ParseFailoverMode(NVPair FM, ConnectionOption co);
    private void addInstance(NVPair desc, ConnectionOption co, bool addCID);
    private void HandleAddress(NVPair cnvp, NVPair desc, Int32& cur, Int32& end);
    private void HandleList(NVPair list);
    private void CheckBadIP(NVPair desc);
    private void DeleteAddress_and_AL(NVPair list);
    private static bool GetValueNVP(NVPair NVP, string Name, bool def);
    internal NVPair BuildSR(NVPair AL, NVPair ADR);
    [IteratorStateMachineAttribute("OracleInternal.Network.AddressResolution/<HandleSRAL>d__173")]
public IEnumerable HandleSRAL(NVPair NewAL, NVPair OrigDesc, NVPair AL);
    [IteratorStateMachineAttribute("OracleInternal.Network.AddressResolution/<HandleSR>d__174")]
public IEnumerable HandleSR(NVPair OrigDesc, NVPair OrigOrigNVPair, NVPair AL, bool SourceRouteAL, bool UpperSourceRoute);
    [IteratorStateMachineAttribute("OracleInternal.Network.AddressResolution/<handleAddressList>d__175")]
public IEnumerable handleAddressList(NVPair OrigDesc, NVPair OrigOrigDesc, NVPair AL, bool UpperSourceRoute);
    [IteratorStateMachineAttribute("OracleInternal.Network.AddressResolution/<GetEnumerator>d__176")]
public sealed virtual IEnumerator GetEnumerator();
    private void GetRetries(NVPair m_desc, Int32& retries, Int32& delay);
    private NVNavigator getAddressContainer(NVPair m_desc);
    internal string Resolve(string TNSAlias, ConnectionOption& CO, Exception& inner, string instanceName, string ServerIs);
    private void CheckNewList();
    internal ConnectionOption ResolveConnectionString();
    private string GetValue(string TNSdesc, Int32& POS);
    private ConnectionOption ResolveSimple(string TNSdesc);
    private ConnectionOption ResolveAddr(string TNSdesc);
    internal void BuildCO_Redirect(string cndr, ConnectionOption& co);
    internal void BuildCO_Addr(NVPair addr, ConnectionOption& co);
    internal static int ConvExpTimetoMilli(string TO);
    internal static int TOConvert2Milli(string TO);
    private ConnectionOption BuildCO(NVPair desc, NVPair addr, bool addAddrToDesc, NVPair SRAddressList);
}
internal class OracleInternal.Network.Ano : object {
    internal static ushort NAUZTK5_ADDRTYPE_INET;
    internal static ushort NAUZTK5_ADDRTYPE_CHAOS;
    internal static ushort NAUZTK5_ADDRTYPE_XNS;
    internal static ushort NAUZTK5_ADDRTYPE_ISO;
    internal static ushort NAUZTK5_ADDRTYPE_DDP;
    internal static ushort NAUZTK5_ADDRTYPE_INET6;
    internal static int NSINAWANTED;
    internal static int NSINAINTCHG;
    internal static int NSINADISABLEFORCONNECTION;
    internal static int NSINANOSERVICES;
    internal static int NSINAREQUIRED;
    internal static int NSINAAUTHWANTED;
    internal static int NUM_SERVICES;
    internal SessionContext m_sessionContext;
    internal AnoCommunication m_anoComm;
    internal int m_naFlags;
    internal Byte[] clientPK;
    internal Byte[] OldIV;
    internal Byte[] NewIV;
    internal Byte[] skey;
    internal Byte[] kkey;
    internal bool foldedinkey;
    internal bool KRB;
    internal bool NTS;
    private static string KERBEROS_DLL_FULL_NAME;
    internal DataIntegrityAlgorithm dataIntegrityAlg;
    internal AnoService[] m_listOfServices;
    internal static int VERSION;
    internal static int RELEASE;
    internal static int UPDATE;
    internal static int PORT;
    internal bool EncUseOLD;
    internal bool DaIUseOLD;
    internal bool KrbUseOLD;
    public void Initialize(SessionContext sessCtx);
    internal void StartNegotiation();
    private void KerberosHandshake(AuthenticationService AS, string KRB5Conf, string KRB5CCName);
    internal void SendANOHeader(int pktLength, int numServices, short errorFlags);
    internal Int32[] ReceiveANOHeader();
    internal bool AllowWeakCrypto(ConnectionOption m_conops);
    internal void BreakUPVersion(long fullVersion, Int32& VERSION, Int32& UPDATE);
    internal bool NewNA(long FullVersion);
    internal bool UseOLD(SessionContext sessCtx, Ano m_ano, long SVRVersion);
    internal void setClientPK(Byte[] clientPK);
    internal void setOldIV(Byte[] iv);
    internal void setNewIV(Byte[] iv);
    internal void setSessionKey(Byte[] skey);
    internal Byte[] getInitializationVector();
    internal Byte[] getSessionKey();
}
internal class OracleInternal.Network.AnoCommunication : object {
    internal static int STRING_TYPE;
    internal static int RAW_TYPE;
    internal static int UB1_TYPE;
    internal static int UB2_TYPE;
    internal static int UB4_TYPE;
    internal static int VERSION_TYPE;
    internal static int STATUS_TYPE;
    internal static int ARRAY_TYPE;
    internal static int MIN_TYPE;
    internal static int MAX_TYPE;
    internal static int UB1_LENGTH;
    internal static int UB2_LENGTH;
    internal static int UB4_LENGTH;
    internal static int VERSION_LENGTH;
    internal static int STATUS_LENGTH;
    internal static int NA_MAGIC_SIZE;
    internal static long DEADBEEF;
    internal static int NA_HEADER_SIZE;
    internal static int ARRAY_PACKET_HEADER_LENGTH;
    internal static int SERVICE_HEADER_LENGTH;
    internal static int SUBPACKET_LENGTH;
    internal static long NA_MAGIC;
    internal static int VERSION;
    internal static int RELEASE;
    internal static int UPDATE;
    internal static int PORT;
    internal static int PORTUPDATE;
    internal static short NO_ERROR;
    internal SessionContext sessCtx;
    internal AnoCommunication(SessionContext sessCtx);
    internal long GetVersion();
    internal void FlushData();
    internal void SendUB1(short num);
    internal void SendUB2(int num);
    internal void SendUB4(long num);
    internal void SendUB2Array(Int32[] nArray);
    internal void SendStatus(int status);
    internal void SendVersion();
    internal void SendString(string str);
    internal void SendRaw(Byte[] rawData);
    internal void SendPacketHeader(int length, int type);
    internal void WriteVersion();
    internal void WriteUB1(short num);
    internal void WriteUB2(int num);
    internal void WriteUB4(long num);
    internal byte Value2Buffer(int value, Byte[] tmpBuffer);
    internal short ReceiveUB1();
    internal int ReceiveUB2();
    internal long ReceiveUB4();
    internal Int32[] receiveUB2Array();
    internal int ReceiveStatus();
    internal long ReceiveVersion();
    internal string ReceiveString();
    internal Byte[] ReceiveRaw();
    internal short ReadUB1();
    internal int ReadUB2();
    internal long ReadUB4();
    internal Byte[] ReceiveByteArray(int size);
    internal int ReceiveByteArray(Byte[] buffer, int offset, int length);
    internal int ReceivePacketHeader(int type);
    internal void ValidateReceivedType(int length, int receivedType, int type);
    internal long Buffer2Value(Byte[] tmpBuffer);
    internal void ValidateType(int length, int type);
}
internal class OracleInternal.Network.AnoService : object {
    internal static int ACCEPTED;
    internal static int REJECTED;
    internal static int REQUESTED;
    internal static int REQUIRED;
    internal static string AUTHENTICATION_NTS;
    internal static string AUTHENTICATION_RADIUS;
    internal static string AUTHENTICATION_KERBEROS5;
    internal static string AUTHENTICATION_TCPS;
    internal static string ENCRYPTION_RC4_40;
    internal static string ENCRYPTION_RC4_56;
    internal static string ENCRYPTION_RC4_128;
    internal static string ENCRYPTION_RC4_256;
    internal static string ENCRYPTION_DES40C;
    internal static string ENCRYPTION_DES56C;
    internal static string ENCRYPTION_3DES112;
    internal static string ENCRYPTION_3DES168;
    internal static string ENCRYPTION_AES128;
    internal static string ENCRYPTION_AES192;
    internal static string ENCRYPTION_AES256;
    internal static string CHECKSUM_MD5;
    internal static string CHECKSUM_SHA1;
    internal static string CHECKSUM_SHA512;
    internal static string CHECKSUM_SHA256;
    internal static string CHECKSUM_SHA384;
    internal static string ANO_ACCEPTED;
    internal static string ANO_REJECTED;
    internal static string ANO_REQUESTED;
    internal static string ANO_REQUIRED;
    internal AnoCommunication m_anoComm;
    internal SessionContext m_sessCtx;
    internal List`1<int> m_userChoiceDriversId;
    internal Byte[] m_selectedDrivers;
    internal int m_service;
    internal long m_version;
    internal int m_level;
    internal int m_algID;
    internal virtual int Initialize(SessionContext sessCtx);
    internal virtual void ReceiveServiceData(int numSubPackets);
    internal virtual void ValidateResponse();
    internal int NumberOfBytesNeeded();
    internal virtual int GetServiceDataLength();
    internal void SendHeader(int serviceSubPackets);
    internal virtual void SendServiceData();
    internal static Int32[] ReceiveHeader(AnoCommunication anoComm);
    internal void ReceiveSelection(int numSubPackets);
    internal virtual void ActivateAlgorithm();
    internal void createDriversListWithLevel(List`1& userChoiceDriversId, int level);
    internal static int translateAnoValue(string level);
    internal static String[] RemoveOldALGs(String[] userList, String[] oldALGs, bool auth);
    internal static String[] ValidateUserChoiceDrivers(String[] userList, String[] availList, bool defaultIsAll, bool auth);
    internal byte GetDriverID(String[] driverClasses, string str);
}
internal class OracleInternal.Network.AnoStream : Stream {
    private ITransportAdapter m_trns;
    private Stream m_strm;
    private SessionContext m_sess;
    private DataPacket m_wpac;
    private static Byte[] Initial_Header;
    private static int NS_HEADER_LEN;
    private static int NA_HEADER_LEN_OFFSET;
    private static int SSPI_OFFSET;
    private static Byte[] First_Packet;
    private static Byte[] Subsq_Packets;
    private static Byte[] Length_Packet;
    private static Byte[] EOF_Packet;
    private Byte[] what_is_this;
    private int read_offset;
    private int bytes_read;
    private int send_packet;
    private bool new_send;
    private bool neg_msg_sent;
    private bool auth_msg_sent;
    private int my_slough;
    private int SSPI_Offset;
    private Byte[] recv_buf;
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    internal AnoStream(ITransportAdapter Trans, SessionContext SessCtx);
    private static AnoStream();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    public void Dispose();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual void SetLength(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private void flush_write_data();
    private void Process_write(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal class OracleInternal.Network.AuthenticationService : AnoService {
    internal static int NAU_OK;
    internal static int NAU_DONT_USE_AUTH;
    internal static int NAU_AUTH_NOT_REQUIRED;
    internal static int NAU_AUTH_REQUIRED;
    internal static int NAU_NO_DRIVERS_LINKED_IN;
    internal static int NAU_USE_IMPLICIT_AUTH;
    internal static int NAU_PROXY_NO_AUTH;
    internal static int NAU_AUTH_DISABLED;
    internal static int NAUCX_CLIENT_SERVER;
    internal static String[] AUTH_ORACLE_NAME;
    internal static String[] AUTH_ORACLE_NAME_nix;
    internal static String[] AUTH_ORACLE_NAME_win;
    internal static Byte[] AUTH_ORACLE_ID;
    internal static Byte[] AUTH_ORACLE_ID_nix;
    internal static Byte[] AUTH_ORACLE_ID_win;
    internal bool m_authenticationActivated;
    internal int m_status;
    internal string m_authenticationService;
    private static AuthenticationService();
    internal virtual int Initialize(SessionContext sessCtx);
    internal virtual int GetServiceDataLength();
    internal virtual void SendServiceData();
    internal virtual void ReceiveServiceData(int numSubPackets);
    internal virtual void ValidateResponse();
    internal virtual void ActivateAlgorithm();
}
internal class OracleInternal.Network.BadIPCache : object {
    private static long TenMinutes;
    private static Hashtable Cache;
    private static Hashtable Hosts;
    private static Hashtable Times;
    private static Hashtable HTime;
    private static BadIPCache();
    internal static Nullable`1<bool> Bad(string IP);
    internal static Nullable`1<bool> BadHost(string host);
    internal static void Insert(string IP, bool host);
    internal static void Delete(string IP, Hashtable theCache, Hashtable theTimes);
    private static Nullable`1<bool> BadIPorHost(string IP, Hashtable theCache, Hashtable theTimes);
    private static void InsertIPorHost(string IP, Hashtable theCache, Hashtable theTimes);
}
internal class OracleInternal.Network.ConnectionOption : object {
    internal static int NSPDFSDULN;
    internal static int NSPDFTDULN;
    internal static int NSPMNSDULN;
    internal static int NSPMNTDULN;
    internal static int NSPOLDMXSDULN;
    internal static int NSPOLDMXTDULN;
    internal static int NSPMXSDULN;
    internal static int NSPMXTDULN;
    internal static int NSPINSDULN;
    internal int m_portNumber;
    private int m_TDUSize;
    private int m_SDUSize;
    private int m_transportConnectTO;
    private string m_protocol;
    private string m_host;
    private string m_IP;
    private int m_SBS;
    private int m_RBS;
    private string m_sid;
    private string m_addr;
    private string m_server;
    private string m_service_name;
    private string m_instance_name;
    private string m_conn_data;
    private string m_https_proxy;
    private int m_https_proxy_port;
    private string m_websock_uri;
    private string m_websock_uname;
    private string m_oraConConIdPrefix;
    private string m_uniqueConnectionId;
    private string m_connectionId;
    private bool m_inAddr_Any;
    internal bool READONLY_CHUNK_OK;
    internal Nullable`1<int> m_FailoverDelay;
    internal Nullable`1<int> m_FailoverRetries;
    internal Nullable`1<bool> m_FailoverOverride;
    internal Nullable`1<OracleFailoverTypeInternal> m_FailoverType;
    internal Nullable`1<OracleFailoverMethod> m_FailoverMethod;
    internal Nullable`1<OracleFailoverRestoreInternal> m_FailoverRestore;
    internal List`1<List`1<HostPort>> HostPortPairsContainer;
    internal List`1<HostPort> HostPortPairs;
    internal string Hostname;
    internal int Retries;
    internal int RetryDelay;
    private string m_ssl_version;
    private string m_wallet_directory;
    private string m_sslServerDN;
    private Nullable`1<bool> m_sslServerDNMatching;
    private bool m_DNMatchingIsOn;
    private Byte[] m_SSLWallet;
    private string m_SSLCertTPrnt;
    private string m_SSLCertAlias;
    internal object AsyncBufferInitArg;
    internal ConOraBufPool AsyncBufferPool;
    internal bool m_KeepAlive;
    internal int m_KeepAliveTime;
    internal int m_KeepAliveInterval;
    internal bool m_KeepAliveAddressET;
    internal string m_encryption;
    internal string m_encryption_types;
    internal string m_crypto_checksum;
    internal string m_crypto_checksum_types;
    internal Nullable`1<bool> m_allow_weak_crypto;
    internal string m_SqlNetAuthenticationServices;
    internal bool m_AllowCertSelectionUI;
    internal string m_TokenAuth;
    internal string m_TokenLocation;
    internal string m_DatabaseApplicationIdUri;
    internal string m_TenantId;
    internal string m_ClientId;
    internal string m_ClientCertificate;
    internal string m_RedirectUri;
    internal string m_PasswAuth;
    internal string m_OCIIAMURL;
    internal string m_OCITenancy;
    internal string m_OCICompartment;
    internal string m_OCIDatabase;
    internal string m_OciConfigFile;
    internal string m_OciProfile;
    internal SqlNetOraConfig m_SNOConfig;
    internal object m_TraceObj;
    internal bool OnRedirect;
    internal Nullable`1<int> theFailoverDelay { get; internal set; }
    internal Nullable`1<int> theFailoverRetries { get; internal set; }
    internal Nullable`1<bool> theFailoverOverride { get; internal set; }
    internal Nullable`1<OracleFailoverTypeInternal> theFailoverType { get; internal set; }
    internal Nullable`1<OracleFailoverMethod> theFailoverMethod { get; internal set; }
    internal Nullable`1<OracleFailoverRestoreInternal> theFailoverRestore { get; internal set; }
    internal SqlNetOraConfig SNOConfig { get; internal set; }
    internal Byte[] SSLWallet { get; internal set; }
    internal bool AllowCertificateSelectionUI { get; internal set; }
    internal string Encryption { get; internal set; }
    internal string SqlNetAuthenticationServices { get; internal set; }
    internal string EncryptionTypes { get; internal set; }
    internal string CryptoChecksum { get; internal set; }
    internal string CryptoChecksumTypes { get; internal set; }
    internal Nullable`1<bool> AllowWeakCrypto { get; internal set; }
    internal bool KeepAlive { get; internal set; }
    internal int KeepAliveTime { get; internal set; }
    internal int KeepAliveInterval { get; internal set; }
    internal string TokenAuth { get; internal set; }
    internal string TokenLocation { get; internal set; }
    internal string DatabaseApplicationIdUri { get; internal set; }
    internal string TenantId { get; internal set; }
    internal string ClientId { get; internal set; }
    internal string ClientCertificate { get; internal set; }
    internal string RedirectUri { get; internal set; }
    internal string PasswAuth { get; internal set; }
    internal string OCIIAMURL { get; internal set; }
    internal string OCITenancy { get; internal set; }
    internal string OCICompartment { get; internal set; }
    internal string OCIDatabase { get; internal set; }
    internal string OciConfigFile { get; internal set; }
    internal string OciProfile { get; internal set; }
    internal bool inAddr_Any { get; internal set; }
    internal string SSL_Version { get; internal set; }
    internal string SSL_WALLET_DIRECTORY { get; internal set; }
    internal string SSLServerDN { get; internal set; }
    internal Nullable`1<bool> SSLServerDNMatching { get; internal set; }
    internal bool DNMatchingIsOn { get; internal set; }
    internal string SSLCertTPrnt { get; internal set; }
    internal string SSLCertAlias { get; internal set; }
    internal string IP { get; internal set; }
    internal int SBS { get; internal set; }
    internal int RBS { get; internal set; }
    internal int Port { get; internal set; }
    internal int TransportDataUnitSize { get; internal set; }
    internal int TransportConnectTO { get; internal set; }
    internal int SessionDataUnitSize { get; internal set; }
    internal string Protocol { get; internal set; }
    internal string Host { get; internal set; }
    internal string SID { get; internal set; }
    internal string Server { get; internal set; }
    internal string ServiceName { get; internal set; }
    internal string InstanceName { get; internal set; }
    internal string Address { get; internal set; }
    internal string ConnectData { get; internal set; }
    internal string HTTPS_PROXY { get; internal set; }
    internal int HTTPS_PROXY_PORT { get; internal set; }
    internal string WEBSOCK_URI { get; internal set; }
    internal string WEBSOCK_UNAME { get; internal set; }
    internal string ConnectionId { get; internal set; }
    internal string OraConConIdPrefix { get; internal set; }
    internal string UniqueConnectionId { get; internal set; }
    internal object TraceObj { get; internal set; }
    internal ConnectionOption(SqlNetOraConfig SNOConfig);
    private static ConnectionOption();
    public ConnectionOption Clone();
    private sealed virtual override object System.ICloneable.Clone();
    internal Nullable`1<int> get_theFailoverDelay();
    internal void set_theFailoverDelay(Nullable`1<int> value);
    internal Nullable`1<int> get_theFailoverRetries();
    internal void set_theFailoverRetries(Nullable`1<int> value);
    internal Nullable`1<bool> get_theFailoverOverride();
    internal void set_theFailoverOverride(Nullable`1<bool> value);
    internal Nullable`1<OracleFailoverTypeInternal> get_theFailoverType();
    internal void set_theFailoverType(Nullable`1<OracleFailoverTypeInternal> value);
    internal Nullable`1<OracleFailoverMethod> get_theFailoverMethod();
    internal void set_theFailoverMethod(Nullable`1<OracleFailoverMethod> value);
    internal Nullable`1<OracleFailoverRestoreInternal> get_theFailoverRestore();
    internal void set_theFailoverRestore(Nullable`1<OracleFailoverRestoreInternal> value);
    private void SetSBSRBS();
    internal SqlNetOraConfig get_SNOConfig();
    internal void set_SNOConfig(SqlNetOraConfig value);
    internal Byte[] get_SSLWallet();
    internal void set_SSLWallet(Byte[] value);
    internal bool get_AllowCertificateSelectionUI();
    internal void set_AllowCertificateSelectionUI(bool value);
    internal string get_Encryption();
    internal void set_Encryption(string value);
    internal string get_SqlNetAuthenticationServices();
    internal void set_SqlNetAuthenticationServices(string value);
    internal string get_EncryptionTypes();
    internal void set_EncryptionTypes(string value);
    internal string get_CryptoChecksum();
    internal void set_CryptoChecksum(string value);
    internal string get_CryptoChecksumTypes();
    internal void set_CryptoChecksumTypes(string value);
    internal Nullable`1<bool> get_AllowWeakCrypto();
    internal void set_AllowWeakCrypto(Nullable`1<bool> value);
    internal bool get_KeepAlive();
    internal void set_KeepAlive(bool value);
    internal int get_KeepAliveTime();
    internal void set_KeepAliveTime(int value);
    internal int get_KeepAliveInterval();
    internal void set_KeepAliveInterval(int value);
    internal string get_TokenAuth();
    internal void set_TokenAuth(string value);
    internal string get_TokenLocation();
    internal void set_TokenLocation(string value);
    internal string get_DatabaseApplicationIdUri();
    internal void set_DatabaseApplicationIdUri(string value);
    internal string get_TenantId();
    internal void set_TenantId(string value);
    internal string get_ClientId();
    internal void set_ClientId(string value);
    internal string get_ClientCertificate();
    internal void set_ClientCertificate(string value);
    internal string get_RedirectUri();
    internal void set_RedirectUri(string value);
    internal string get_PasswAuth();
    internal void set_PasswAuth(string value);
    internal string get_OCIIAMURL();
    internal void set_OCIIAMURL(string value);
    internal string get_OCITenancy();
    internal void set_OCITenancy(string value);
    internal string get_OCICompartment();
    internal void set_OCICompartment(string value);
    internal string get_OCIDatabase();
    internal void set_OCIDatabase(string value);
    internal string get_OciConfigFile();
    internal void set_OciConfigFile(string value);
    internal string get_OciProfile();
    internal void set_OciProfile(string value);
    internal bool get_inAddr_Any();
    internal void set_inAddr_Any(bool value);
    internal string get_SSL_Version();
    internal void set_SSL_Version(string value);
    internal string get_SSL_WALLET_DIRECTORY();
    internal void set_SSL_WALLET_DIRECTORY(string value);
    internal string get_SSLServerDN();
    internal void set_SSLServerDN(string value);
    internal Nullable`1<bool> get_SSLServerDNMatching();
    internal void set_SSLServerDNMatching(Nullable`1<bool> value);
    internal bool get_DNMatchingIsOn();
    internal void set_DNMatchingIsOn(bool value);
    internal string get_SSLCertTPrnt();
    internal void set_SSLCertTPrnt(string value);
    internal string get_SSLCertAlias();
    internal void set_SSLCertAlias(string value);
    internal string get_IP();
    internal void set_IP(string value);
    internal int get_SBS();
    internal void set_SBS(int value);
    internal int get_RBS();
    internal void set_RBS(int value);
    internal int get_Port();
    internal void set_Port(int value);
    internal int get_TransportDataUnitSize();
    internal void set_TransportDataUnitSize(int value);
    internal int get_TransportConnectTO();
    internal void set_TransportConnectTO(int value);
    internal int get_SessionDataUnitSize();
    internal void set_SessionDataUnitSize(int value);
    internal string get_Protocol();
    internal void set_Protocol(string value);
    internal string get_Host();
    internal void set_Host(string value);
    internal string get_SID();
    internal void set_SID(string value);
    internal string get_Server();
    internal void set_Server(string value);
    internal string get_ServiceName();
    internal void set_ServiceName(string value);
    internal string get_InstanceName();
    internal void set_InstanceName(string value);
    internal string get_Address();
    internal void set_Address(string value);
    internal string get_ConnectData();
    internal void set_ConnectData(string value);
    internal string get_HTTPS_PROXY();
    internal void set_HTTPS_PROXY(string value);
    internal int get_HTTPS_PROXY_PORT();
    internal void set_HTTPS_PROXY_PORT(int value);
    internal string get_WEBSOCK_URI();
    internal void set_WEBSOCK_URI(string value);
    internal string get_WEBSOCK_UNAME();
    internal void set_WEBSOCK_UNAME(string value);
    internal string get_ConnectionId();
    internal void set_ConnectionId(string value);
    internal string get_OraConConIdPrefix();
    internal void set_OraConConIdPrefix(string value);
    internal string get_UniqueConnectionId();
    internal void set_UniqueConnectionId(string value);
    internal object get_TraceObj();
    internal void set_TraceObj(object value);
}
internal class OracleInternal.Network.ConnectPacket : Packet {
    internal static int NSPMXTPKTLEN;
    private bool m_bConnDataOverFlow;
    private string m_connectData;
    private static int maxLen;
    internal ConnectPacket(SessionContext sessCtx, bool onRedirect);
    internal ConnectPacket(SessionContext sessCtx, int size);
    private static ConnectPacket();
    internal virtual void Send();
    internal virtual void Receive();
}
internal class OracleInternal.Network.ControlPacket : Packet {
    internal static int NSPCTLCMD;
    internal static int NSPCTLDAT;
    internal bool m_isResetMarker;
    internal bool m_isBreakMarker;
    internal int m_markerData;
    internal ControlPacket(Packet pkt);
    private static ControlPacket();
}
internal class OracleInternal.Network.DataIntegrityService : AnoService {
    private static String[] DATAINTEGRITY_ANO_ID_OLD;
    private static String[] DATAINTEGRITY_ANO_ID_NEW;
    private static String[] DATAINTEGRITY_ANO_ID;
    private static Byte[] DATAINTEGRITY_ORACLE_ID;
    private int i;
    private bool checkSummingActivated;
    private Byte[] clientPK;
    private bool AWC;
    private static DataIntegrityService();
    internal virtual int Initialize(SessionContext sessCtx);
    internal virtual int GetServiceDataLength();
    internal virtual void ReceiveServiceData(int numSubPackets);
    internal virtual void ActivateAlgorithm();
    internal virtual void ValidateResponse();
}
internal class OracleInternal.Network.DataPacket : Packet {
    internal static int NSPDAFZER;
    internal static int NSPDAFTKN;
    internal static int NSPDAFRCF;
    internal static int NSPDAFCFM;
    internal static int NSPDAFRSV;
    internal static int NSPDAFMOR;
    internal static int NSPDAFEOF;
    internal static int NSPDAFIMM;
    internal static int NSPDAFRTS;
    internal static int NSPDAFRNT;
    internal static int NSPDAFCMP;
    internal static int NSPDAFAPP;
    internal static int NSPDAFAPP2;
    internal static int NSPDAFAPP3;
    internal static int NSPDAFPRTN;
    internal static int NSPDAFRTN;
    internal static int NSPDAFCLS;
    internal int m_packetOffset;
    internal int m_dataFlags;
    internal int m_availableBytesToSend;
    internal int m_availableBytesToRead;
    internal bool m_isBufferFull;
    internal bool m_isBufferEmpty;
    internal DataPacket(SessionContext sessCtx, int pktLength);
    internal DataPacket(SessionContext sessCtx);
    private static DataPacket();
    internal static void setLength(Byte[] hdr, int length, bool useLSD);
    internal static void InitForSend(Byte[] hdr, int length, bool useLSD, int DAFlag);
    internal virtual void Receive();
    internal virtual void Send();
    internal void Send(int dataFlags);
    internal void Initialize(int length);
    internal void Initialize();
    internal void SetBufferLength(int length);
    internal int PutDataInBuffer(Byte[] userBuffer, int offset, int length);
    internal int getDataFromBuffer(Byte[] userBuffer, int offset, int length);
}
internal class OracleInternal.Network.DataSources : object {
    private static Hashtable _Map;
    private static ReaderWriterLockSlim myLock;
    public string ID { get; }
    public Hashtable Map { get; }
    private static DataSources();
    public sealed virtual string get_ID();
    public sealed virtual Hashtable get_Map();
    public sealed virtual string Resolve(string TNSAlias, ConnectionOption& CO, string OraConConIdPrefix, string UniqueConnectionId, object TraceObj, string InstanceName, string ServerIs);
    public sealed virtual void Refresh();
}
internal class OracleInternal.Network.EncryptionService : AnoService {
    internal Byte[] drivers;
    private int m_resp;
    private int i;
    internal static String[] ENCRYPTION_ANO_ID_OLD;
    internal static String[] ENCRYPTION_ANO_ID_NEW;
    internal static String[] ENCRYPTION_ANO_ID;
    internal static int ENCRYPTION_NULL_ID;
    internal static int ENCRYPTION_RC4_BAS_ID;
    internal static int ENCRYPTION_RC4__56_ID;
    internal static int ENCRYPTION_RC4_128_ID;
    internal static int ENCRYPTION_RC4_256_ID;
    internal static int ENCRYPTION_DES__40_ID;
    internal static int ENCRYPTION_DES__56_ID;
    internal static int ENCRYPTION_DES_112_ID;
    internal static int ENCRYPTION_DES_168_ID;
    internal static int ENCRYPTION_AES_128_ID;
    internal static int ENCRYPTION_AES_192_ID;
    internal static int ENCRYPTION_AES_256_ID;
    private Byte[] ENCRYPTION_ORACLE_ID;
    private bool AWC;
    private static EncryptionService();
    internal virtual int Initialize(SessionContext sessCtx);
    internal virtual void SendServiceData();
    internal virtual int GetServiceDataLength();
    internal virtual void ReceiveServiceData(int numSubPackets);
    internal virtual void ValidateResponse();
    internal virtual void ActivateAlgorithm();
}
internal class OracleInternal.Network.ErrorMessages : object {
    internal static int OC_NOT_IN_BREAK_MODE;
    internal static int OC_CONNECT_FAILURE_OR_CONNECT_STR_PARSE_ERR;
    internal static int OC_UNINITIALIZED_LISTEN_ENDPOINT;
    internal static int NA_KERBEROS_ERROR;
    internal static int NA_NTS_KERBEROS_ERROR;
    internal static int INVALID_ENCRYPTION_PARAMETER;
    internal static int SUPERVISOR_STATUS_FAILURE;
    internal static int AUTHENTICATION_STATUS_FAILURE;
    internal static int SERVICE_CLASSES_NOT_INSTALLED;
    internal static int INVALID_DRIVER;
    internal static int ARRAY_HEADER_ERROR;
    internal static int INVALID_NA_PACKET_TYPE_LENGTH;
    internal static int INVALID_NA_PACKET_TYPE;
    internal static int UNEXPECTED_NA_PACKET_TYPE_RECVD;
    internal static int INVALID_SERVICES_FROM_SERVER;
    internal static int INCOMPLETE_SERVICES_FROM_SERVER;
    internal static int INVALID_LEVEL;
    internal static int NA_NTS_INVALID_SSPI_PROTOCOL;
    internal static int NA_NTS_INVALID_SSPI_PACKET;
    internal static int NAERROR_PACKET_RECEIVE_FAILED;
    internal static int NAERROR_DISABLED_BUT_REQUIRED;
    internal static int NAERROR_UNSUPPORTED_ENC_DI_VERSION;
    internal static int NAERROR_PARAM_UNKNOWN_ALGORITHM;
    internal static int NAERROR_INVALID_PACKET_RECEIVED;
    internal static int NAERROR_UNSUPPORTED_ENC_DI_VERSION_CLIENT;
    internal static int NAERROR_UNSUPPORTED_ENC_DI_VERSION_SERVER;
    internal static int NT_SSL_FAILURE_PARSING_WALLET_LOC;
    internal static int NT_TCP_ADDRESS_CONNECT_FAILURE;
    internal static int NT_WS_BAD_HANDSHAKE_REQUEST;
    internal static int NT_WS_BAD_HANDSHAKE_RESPONSE;
    internal static int NT_WS_HANDSHAKE_FAILURE;
    internal static int NT_WS_PROTOCOL_ERROR;
    internal static int NT_WS_ERROR;
    internal static int NL_ORABUF_SEGMENTS_MUST_MONOTONICALLY_INCREASE;
    internal static int NL_TNS_CONNECT_STRING_MISSING;
    internal static int NL_ORABUF_OVERFLOW;
    internal static int NL_ORABUF_MUST_HAVE_ONE_SEGMENT;
    internal static int NLNV_SYNTAX_ERROR;
    internal static int NLNV_PREMATURE_END_OF_STRING;
    internal static int NN_LDAP_NO_SERVER_CONFIGURED;
    internal static int IFCR_BRK;
    internal static int IFCR_UFL;
    internal static int IFCR_OFL;
    internal static int IFCR_EOF;
    internal static int IFCR_CLC;
    internal static int IFCR_CTO;
    internal static int IFCR_RTO;
    internal static int IFCR_INP;
    internal static int IFCR_RQF;
    internal static int IFCR_STO;
    internal static int NTZSSLHANDSHAKEFAIL;
    internal static int NTZSSLVERSIONFAIL;
    internal static int NSGMOBF;
    internal static int NSGMOSF;
    internal static int NSGMONC;
    internal static int NSGMORINV;
    internal static int NSGMOSNF;
    internal static int NSGMOSLF;
    internal static int NSGMOLBSIDF;
    internal static int NSGMOSACL;
    internal static int NSGMOALF;
    internal static int NSGMOCLF;
    internal static int NSGMORDF;
    internal static int NSGMODIU;
    internal static int NSGMODST;
    internal static int NSGMODNA;
    internal static int NSGMODDP;
    internal static int NSGMOSVF;
    internal static int NSGMOLBSNF;
    internal static int NSGM0PRE;
    internal static int NSGMONOHDLRPS;
    internal static int NSGMOLBHPSF;
    internal static int NSGMONODHOFF;
    internal static int NSGMODHOFFERR;
    internal static int NSGMONOHANDLER;
    internal static int NSGMOLBHF;
    internal static int NSGMONOHDLRSER;
    internal static int NSGMOLBHTF;
    internal static int NSGMOLBHTNF;
    internal static int NSGMOINF;
    internal static int NSGMOLBINF;
    internal static int NSGMOLBINRF;
    internal static int NSGMOLBIRF;
    internal static int NSGMOLBIF;
    internal static int NSGMOLBHNF;
    internal static int NSGMOCTO;
    internal static int NSGMOLBRIF;
    internal static int NSGMOLBBRIF;
    internal static int NSGMOLBBIF;
    internal static int NSGMOLBRFR;
    internal static int NSGMOLRLR;
    internal static int NSGMOBADVSN;
    internal static int NTZSSLDNMISMATCH;
    internal static int NIRECRA;
    internal static int NIQECTO;
    internal static int NSEBASE;
    internal static int NSEALLOCATE;
    internal static int NSEINVARG;
    internal static int NSEADDRESS;
    internal static int NSENOTSUPPORTED;
    internal static int NSETIMEDOUT;
    internal static int NSEWOULDBLOCK;
    internal static int NSEENDOFFILE;
    internal static int NSENODRIVER;
    internal static int NSESIZE;
    internal static int NSELIMIT;
    internal static int NSENOLISTENER;
    internal static int NSELISTENERALREADY;
    internal static int NSEUNREACHABLE;
    internal static int NSENOTTHERE;
    internal static int NSEACCESSDENIED;
    internal static int NSELOSTCONTACT;
    internal static int NSEPARTIAL;
    internal static int NSERESOURCE;
    internal static int NSESYNTAX;
    internal static int NSEKEYWORD;
    internal static int NSEINTERRUPTED;
    internal static int NSEWORKING;
    internal static int NSENOPRIVILEGE;
    internal static int NSENOCALLER;
    internal static int NSENOTLOADABLE;
    internal static int NSENOTLOADED;
    internal static int NSEEVPOSTED;
    internal static int NSENT;
    internal static int NSEERROR;
    internal static int NSEBADGBH;
    internal static int NSEREFUSE;
    internal static int NSENORESPONSE;
    internal static int NSEPROTOCOL;
    internal static int NSEUSERABORT;
    internal static int NSESYSABORT;
    internal static int NSECHECKSUM;
    internal static int NSEREADER;
    internal static int NSEWRITER;
    internal static int NSENOREDIRECT;
    internal static int NSEDHCTXBUSY;
    internal static int NSEDHNOTSUPPORTED;
    internal static int NSEVECTOREDIO;
    internal static int NSEWALLETOPNFAIL;
    internal static int NSEINVOPN;
    internal static int NSENOREADER;
    internal static int NSETRUNCATED;
    internal static int NSERESEND;
    internal static int NSEREDIRECT;
    internal static int NSENOTBEQABLE;
    internal static int NSENOBUFFER;
    internal static int NSEEVNOTFN;
    internal static int NSEBADPACKET;
    internal static int NSEREGNONE;
    internal static int NSEREFDUMDAT;
    internal static int NSENOCONFIRM;
    internal static int NSEINCONSISTENT;
    internal static int NSECXDINUSE;
    internal static int NSEBANNERREGISTRATIONFAILED;
    internal static int NSECRYPTCHKSUM;
    internal static int NSENLSOPENFAILED;
    internal static int NSEINFOFLAGSCHECKFAILED;
    internal static int NSECPLIMIT;
    internal static int NSEEVPOSTFAIL;
    internal static int NSEAPPTIMEOUT;
    internal static int NSECONNTIMEOUT;
    internal static int NSEPINGTIMEOUT;
    internal static int NSESENDTIMEOUT;
    internal static int NSERECVTIMEOUT;
    internal static int NSESESSION;
    internal static int NSENONPORTABLE;
    internal static int NSEBUSY;
    internal static int NSEBUFFER;
    internal static int NSENOTCONNECTED;
    internal static int NSEPREEMPT;
    internal static int NSESETSIG;
    internal static int NSEWHAT;
    internal static int NSEVERSION;
    internal static int NSEOPTION;
    internal static int NSECHAR;
    internal static int NSEREADAHEAD;
    internal static int NSEHOMOEVVIO;
    internal static int NSESTATE;
    internal static int NSEREGALREADY;
    internal static int NSEMISSING;
    internal static int NSEBADEVENT;
    internal static int NSEDIRECT;
    internal static int NSENOCALLBACK;
    internal static int NSENOTEST;
}
internal class OracleInternal.Network.EZConnect : object {
    private static Char[] ampersand;
    private static Char[] equalSign;
    private static Char[] colonORslash;
    private static Char[] commaORcolon;
    private static Char[] slashORqmark;
    private static Char[] commaORsemicolon;
    private static Char[] commaORsemicolonORcolon;
    private static Char[] commaColonORslash;
    private static Char[] colonSlashORqmark;
    private static string BEGIN_DBL_SLASH;
    private static int DEFAULT_DATABASE_PORT;
    internal SqlNetOraConfig SNOConfig;
    public string ID { get; }
    public Hashtable Map { get; }
    private static EZConnect();
    public sealed virtual string get_ID();
    public sealed virtual Hashtable get_Map();
    public sealed virtual string Resolve(string TNSAlias, ConnectionOption& CO, string OraConCOnIdPrefix, string UniqueConnectionId, object TraceObj, string InstanceName, string ServerIs);
    private static string GetValue(string TNSdesc, Int32& POS, Char[] EndChars);
    private void BadIPandDNSExpansion(HostPort temp, List`1<HostPort> list);
    private ConnectionOption ResolveSimple(string TNSdesc, string OraConCOnIdPrefix, string UniqueConnectionId, object TraceObj, string InstanceName, string ServerIs);
    public sealed virtual void Refresh();
}
internal interface OracleInternal.Network.INamingAdapter {
    public string ID { get; }
    public Hashtable Map { get; }
    public abstract virtual string get_ID();
    public abstract virtual Hashtable get_Map();
    public abstract virtual string Resolve(string TNSname, ConnectionOption& CO, string OraConConIdPrefix, string UniqueConnectionId, object TraceObj, string InstanceName, string ServerIs);
    public abstract virtual void Refresh();
}
internal interface OracleInternal.Network.ITransportAdapter {
    unknown ConOraBufPool OraBufPool {public set; }
    public bool Connected { get; }
    public bool NeedReneg { get; }
    public abstract virtual ValueTask ConnectAsync(ConnectionOption conOption, bool bAsync);
    public abstract virtual void Connect(ConnectionOption conOption, bool bAsync);
    public abstract virtual Stream ConnectIterate();
    public abstract virtual void Listen(ConnectionOption conOption);
    public abstract virtual ITransportAdapter Answer(ConnectionOption conOption);
    public abstract virtual void Disconnect();
    public abstract virtual Stream GetStream();
    public abstract virtual Socket GetSocket();
    public abstract virtual Socket GetTestSocket();
    public abstract virtual bool UrgentDataSupported();
    public abstract virtual void SendUrgent(Byte[] data, int offset, int length);
    public abstract virtual void Send(OraBuf OB);
    public abstract virtual void BeginAsyncReceives(AsyncReceiveCallback Callback, int AsyncBufferSize);
    public abstract virtual void set_OraBufPool(ConOraBufPool value);
    public abstract virtual bool get_Connected();
    public abstract virtual bool get_NeedReneg();
    public abstract virtual void Renegotiate(ConnectionOption conOption);
}
internal class OracleInternal.Network.LDAP : object {
    internal static string m_ID;
    private static string m_OracleContext;
    private static string m_LdapFilter;
    private static string m_orclNetDescStringAttr;
    private static string m_aliasObjectNameStringAttr;
    private static String[] m_AttributesToReturn;
    private static string CNEQUALS;
    private static string DCEQUALS;
    private static string CEQUALS;
    private static string OEQUALS;
    private static string OUEQUALS;
    private static char EQUALCHAR;
    private static char ATCHAR;
    private static char DOTCHAR;
    private static char COMMACHAR;
    private static int m_PageSize;
    private static string SYNTAXERROR;
    private static string NOLDAPSERVERCONFIGURED;
    private LdapConfig m_LdapConfig;
    private SqlNetOraConfig d_SNOConfig;
    private Hashtable d_ObLdapHT;
    private static LdapConfig s_LdapConfig;
    private object m_TraceObj;
    public string ID { get; }
    public Hashtable Map { get; }
    internal LDAP(SqlNetOraConfig SNOConfig, Hashtable ObLdapHT);
    private static LDAP();
    private void LDAPinitialize();
    private void _LDAP(Hashtable dsMap);
    private string ExtractKey(string distinguishedName);
    private LdapConnection CreateLdapConnection(LdapDirectoryIdentifier ldapDirectoryId);
    private static string Attribute2String(DirectoryAttribute directoryAttribute);
    private bool VerifyServerCertificateCallback(LdapConnection ldapConn, X509Certificate serverCert);
    public sealed virtual string get_ID();
    public sealed virtual Hashtable get_Map();
    public sealed virtual string Resolve(string TNSname, ConnectionOption& CO, string OraConConIdPrefix, string UniqueConnectionId, object TraceObj, string IN, string ServerIs);
    private string Convert2rdns(string alias, bool useDC);
    public sealed virtual void Refresh();
}
internal class OracleInternal.Network.LdapConfig : object {
    internal static String[] LDAP_URL_SCHEMES;
    internal static string DIRECTORY_SERVERS;
    internal static string DIRECTORY_SERVER_TYPE;
    internal static string DEFAULT_ADMIN_CONTEXT;
    internal static string CONTEXT_MAP;
    internal static string m_OracleContext;
    private static string ACTIVE_DIRECTORY_TYPE;
    private static string OID_TYPE;
    private static string OUD_TYPE;
    private static int DefaultPort;
    private static int DefaultSslPort;
    private static Char[] charsToTrim;
    private static string CNSTRING;
    private static string DCEQUALS;
    private static string CEQUALS;
    private static string OEQUALS;
    private static string SCHEME_AUTHORITY_DELIMITER;
    private static string HOST_PORT_DELIMITER;
    private static string HOST_DELIMITER;
    private static string CN_DELIMITER;
    private static string PARAMETER_DELIMITER;
    private static Char[] PARAM_DELIMITERS;
    private static string ORACLE_LDAP_CLIENT_DN;
    private static string ORACLE_LDAP_CLIENT_PASSW;
    private static string DIRECTORY_SERVERS_ERROR;
    private static string DIRECTORY_SERVERS_MISSING;
    private static string DIRECTORY_SERVER_TYPE_ERROR;
    private static string AUTHENTICATE_BIND;
    private static string AUTHENTICATE_BIND_METHOD;
    private static string AUTHENTICATE_BIND_METHOD_NONE;
    private static string LDAP_CONN_TIMEOUT;
    private static string WALLET_LOCATION;
    private static string UNABLE_TO_ADD_LDAP_SERVER;
    private static string UNABLE_TO_RESOLVE_LDAP_SERVER_ADDRESS;
    private static string LDAPS_SIMPLE_AUTH_ERROR;
    private static string LDAP_URL_ERROR;
    private static string LDAP_URL_INVALID_PARAM;
    private static string LDAP_URL_PARAM_SYNTAX;
    private static X509Certificate2Collection m_RootLocalMachineCAs;
    private List`1<LdapDirectoryIdentifier> m_LdapDirectoryIdentifiers;
    private AuthType m_AuthType;
    private NetworkCredential m_Credential;
    private X509Certificate2Collection m_X509Collection;
    private X509Certificate2Collection m_x509collection;
    private bool m_SSL;
    private bool m_SimpleBind;
    private DirectoryServerTypes m_DirectoryServerType;
    private bool m_bDirectoryType_accessed;
    private bool m_WithC;
    private bool m_WithO;
    private bool m_WithDC;
    private bool m_DACparsed;
    private bool m_bDefaultAdminContext_accessed;
    private string m_DefaultAdminContext;
    private bool m_LDAPCTimeOut_accessed;
    private int m_LDAPCTimeOut;
    private Hashtable m_LDAPconfigParameters;
    private SqlNetOraConfig m_SNOConfig;
    private bool m_bLdapUrl;
    private Hashtable m_SNOconfigParameters;
    private string m_tnsname;
    internal X509Certificate2Collection RootLocalMachineCAs { get; }
    internal SqlNetOraConfig SNOConfig { get; }
    internal Hashtable LDAPconfigParameters { get; }
    internal string DirectoryServers { get; }
    internal string DefaultAdminContext { get; }
    internal DirectoryServerTypes DirectorySeverType { get; }
    internal List`1<LdapDirectoryIdentifier> LdapDirectoryIdentifiers { get; }
    internal AuthType Authtype { get; }
    internal NetworkCredential Credential { get; }
    internal X509Certificate2Collection X509CollectionAll { get; }
    internal X509Certificate2Collection X509Collection { get; }
    internal bool useSSL { get; }
    internal bool useSimpleBind { get; }
    internal bool DACwithC { get; }
    internal bool DACwithO { get; }
    internal bool DACwithDC { get; }
    internal string TNSname { get; }
    internal int LDAPCTimeout { get; }
    private bool NamesLdapAuthenticateBind { get; }
    private string NamesLdapAuthenticateBindMethod { get; }
    internal LdapConfig(SqlNetOraConfig SNOConfig, Hashtable ObLdapHT);
    internal LdapConfig(SqlNetOraConfig SNOConfig, string LdapUrl);
    private static LdapConfig();
    internal void _LdapConfig(SqlNetOraConfig SNOConfig, Hashtable ObLdapHT);
    internal X509Certificate2Collection get_RootLocalMachineCAs();
    internal SqlNetOraConfig get_SNOConfig();
    internal Hashtable get_LDAPconfigParameters();
    internal string get_DirectoryServers();
    internal string get_DefaultAdminContext();
    internal DirectoryServerTypes get_DirectorySeverType();
    internal List`1<LdapDirectoryIdentifier> get_LdapDirectoryIdentifiers();
    internal AuthType get_Authtype();
    internal NetworkCredential get_Credential();
    internal X509Certificate2Collection get_X509CollectionAll();
    internal X509Certificate2Collection get_X509Collection();
    internal bool get_useSSL();
    internal bool get_useSimpleBind();
    internal bool get_DACwithC();
    internal bool get_DACwithO();
    internal bool get_DACwithDC();
    internal string get_TNSname();
    internal int get_LDAPCTimeout();
    private bool get_NamesLdapAuthenticateBind();
    private string get_NamesLdapAuthenticateBindMethod();
    private void ParseDAC();
    internal void Refresh();
    private void ParseLdapUrl(string LdapUrl);
    private void _LdapConfig1();
    private void ConfigError(string errMsg, OracleTraceClassName className, OracleTraceFuncName funcName);
    private void ADorOIDdiscovery();
}
internal class OracleInternal.Network.MarkerPacket : Packet {
    internal static int NSPMKTD0;
    internal static int NSPMKTD1;
    internal static byte NIQBMARK;
    internal static byte NIQRMARK;
    internal static byte NIQIMARK;
    internal bool m_isResetMarker;
    internal bool m_isBreakMarker;
    internal int m_markerData;
    internal MarkerPacket(SessionContext sessCtx, int markerType);
    internal MarkerPacket(Packet pkt);
    private static MarkerPacket();
}
internal class OracleInternal.Network.NetEnvironment : object {
    public static bool gotIPv4;
    public static bool gotIPv6;
    private static NetEnvironment();
}
internal class OracleInternal.Network.NetworkException : DbException {
    internal int m_errorCode;
    public int ErrorCode { get; }
    public int Number { get; }
    internal NetworkException(int errorCode);
    internal NetworkException(int errorCode, Exception inner);
    internal NetworkException(int errorCode, Exception inner, Object[] inpParams);
    internal NetworkException(int errorCode, Object[] inpParams);
    protected NetworkException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    public int get_Number();
    internal static string sprintf(string input, Object[] inpVars);
}
internal class OracleInternal.Network.NVFactory : object {
    internal static NVPair CreateNVPair(string nvString);
    private static NVPair ReadTopLevelNVPair(NVTokens nvt);
    private static NVPair ReadNVPair(NVTokens nvt);
    private static NVPair ReadRightHandSide(NVPair nvp, NVTokens nvt);
    private static string ReadNVLiteral(NVTokens nvt);
    private static string ReadNVAtom(NVTokens nvt);
    private static void ReadNVList(NVTokens nvt, NVPair parent);
    private static string GetContext(NVTokens nvt);
}
internal class OracleInternal.Network.NVNavigator : object {
    private string m_SearchName;
    private int m_cursor;
    private NVPair m_nvp;
    internal NVNavigator(NVPair nvp);
    internal static NVPair FindNVPairRecurse(NVPair nvp, string name);
    [IteratorStateMachineAttribute("OracleInternal.Network.NVNavigator/<FindAllNVPairsRecurse>d__5")]
internal static IEnumerable`1<NVPair> FindAllNVPairsRecurse(NVPair nvp, string name);
    internal void SetFindString(string name);
    internal NVPair FindNVPair();
    internal static NVPair FindNVPair(NVPair nvp, string name);
    internal static NVPair FindNVPair(NVPair nvp, String[] names);
}
internal class OracleInternal.Network.NVPair : object {
    internal static int RHS_NONE;
    internal static int RHS_ATOM;
    internal static int RHS_LIST;
    internal static int LIST_REGULAR;
    internal static int LIST_COMMASEP;
    private string m_sName;
    private int m_rhsType;
    private string m_sAtom;
    internal ArrayList m_list;
    private int m_iListType;
    private NVPair m_parent;
    internal string Name { get; internal set; }
    internal NVPair Parent { get; }
    internal int RHSType { get; }
    internal int ListType { get; internal set; }
    internal string Atom { get; internal set; }
    internal int ListSize { get; }
    internal NVPair(string name);
    internal NVPair(string name, string atom);
    internal NVPair(string name, NVPair child);
    private static NVPair();
    internal string get_Name();
    internal void set_Name(string value);
    internal NVPair get_Parent();
    internal int get_RHSType();
    internal int get_ListType();
    internal void set_ListType(int value);
    internal string get_Atom();
    internal void set_Atom(string value);
    internal int get_ListSize();
    private void SetParent(NVPair parent);
    private bool ContainsComment(string str);
    internal NVPair Clone();
    internal NVPair GetListElement(int pos);
    internal void AddListElement(NVPair pair);
    internal int AddListElementI(NVPair pair);
    internal void AddListElement(int after, NVPair pair);
    internal void RemoveListElement(int pos);
    internal string ValueToString();
    public virtual string ToString();
}
internal class OracleInternal.Network.NVTokens : object {
    internal static int TKN_NONE;
    internal static int TKN_LPAREN;
    internal static int TKN_RPAREN;
    internal static int TKN_COMMA;
    internal static int TKN_EQUAL;
    internal static int TKN_LITERAL;
    internal static int TKN_EOS;
    private static char TKN_LPAREN_VALUE;
    private static char TKN_RPAREN_VALUE;
    private static char TKN_COMMA_VALUE;
    private static char TKN_EQUAL_VALUE;
    private static char TKN_BKSLASH_VALUE;
    private static char TKN_DQUOTE_VALUE;
    private static char TKN_SQUOTE_VALUE;
    private static char TKN_EOS_VALUE;
    private static char TKN_SPC_VALUE;
    private static char TKN_TAB_VALUE;
    private static char TKN_LF_VALUE;
    private static char TKN_CR_VALUE;
    private ArrayList m_tkType;
    private ArrayList m_tkValue;
    private int m_numTokens;
    private int m_tkPos;
    internal int Token { get; }
    internal string Literal { get; }
    internal int get_Token();
    internal string get_Literal();
    private static bool IsWhiteSpace(char it);
    private static string TrimWhiteSpace(string it);
    internal bool ParseTokens(string nvString);
    internal string PopLiteral();
    internal void EatToken();
    private void AddToken(int tk, char tk_char);
    private void AddToken(int tk, string tk_val);
}
internal class OracleInternal.Network.OraArraySegment : object {
    internal OraBuf OB;
    internal int Count;
    internal int Offset;
    internal Byte[] Array;
    internal int m_maxRowNum;
    internal bool m_bInUseByTTCLayer;
    internal int m_responseCount;
    internal bool m_bIgnoreMaxRow;
    internal object m_sync;
    internal bool m_bMultipleResponses;
    internal OraArraySegment(OraBuf ob, Byte[] array, int offset, int count);
}
internal class OracleInternal.Network.OraBuf : object {
    internal int InbandErr;
    internal string InbandErrMsg;
    internal static int OAS_StartSize;
    internal Byte[] m_buf;
    internal int m_size;
    private int m_cursor;
    internal int m_curlen;
    internal int m_length;
    private int m_ASegs_cursor;
    private OraArraySegment[] m_ASegs;
    internal int Sub;
    internal int DAFlags;
    private ConOraBufPool myPool;
    private bool useLSD;
    private int SDU;
    internal DataPacket m_packet;
    private OraBuf m_secondary;
    private Byte[] m_hdrbuf;
    internal static int RecvSzMultiplier;
    private static object m_sync;
    private static int m_sId;
    internal int m_id;
    internal object m_syncObject;
    internal int m_responseCount;
    internal bool m_bResponseCountIncreasedByPreviousExecution;
    internal int the_ByteSegments_Count { get; }
    internal OraArraySegment[] the_ByteSegments { get; }
    internal int size { get; }
    internal Byte[] buf { get; }
    internal int cursor { get; }
    internal int Space { get; }
    internal OraBuf(OracleCommunication OC, int size);
    internal OraBuf(OracleCommunication OC, int size, bool ReceiveBuf);
    internal OraBuf(Byte[] Buf, object traceObj);
    private static OraBuf();
    private OraArraySegment GetNewOAS(Byte[] array, int offset, int count);
    private void Initialize(OracleCommunication OC, int size, bool ReceiveBuf);
    internal void AddForReceive(Byte[] buf, int offset, int count);
    internal void AddForReceive(int offset, int count);
    private void AddIt(OraArraySegment NewAS);
    internal void Add(Byte[] array, int offset, int count);
    internal void Add(int size);
    internal void InitForSend(int DAFlag);
    internal void ReturnToPool(object traceObj);
    internal void Clear();
    internal void ReInit(bool forReceive);
    internal void ResetPipeliningPoolingState();
    internal int get_the_ByteSegments_Count();
    internal OraArraySegment[] get_the_ByteSegments();
    internal int get_size();
    internal Byte[] get_buf();
    internal int get_cursor();
    internal int get_Space();
}
internal class OracleInternal.Network.OracleCommunication : object {
    internal InbandNotification m_inbandNotification;
    internal object m_InbandErrContext;
    private ConnectionOption m_connOption;
    internal SessionContext m_sessionCtx;
    internal Ano m_anoObject;
    private bool m_NAHandshake;
    private string m_InstanceName;
    private ConOraBufPool m_oraBufPool;
    private Hashtable m_ObCfgHT;
    private Hashtable m_ObTnsHT;
    private Hashtable m_ObLdpHT;
    private string m_ObCfgWL;
    private string m_ObTnsPt;
    private string m_ServerIs;
    private Byte[] m_SSLWallet;
    private string m_ShardingKeyB64;
    private string m_SuperShardingKeyB64;
    private bool m_RAW;
    private string m_NamesDirectoryPath;
    private string m_SqlNetAuthenticationServices;
    private string m_SSLCertificateThumbprint;
    private bool m_AllowCertSelectionUI;
    internal bool m_KeepAlive;
    internal int m_KeepAliveTime;
    internal int m_KeepAliveInterval;
    internal int m_SDU;
    private SqlNetOraConfig SNOConfig;
    private DataPacket m_DataPacket;
    private Byte[] m_AcceptData;
    private bool m_Tunnel;
    private Byte[] m_UUID;
    private string m_UniqueConnectionId;
    private string m_OraConConIdPrefix;
    private object m_TraceObj;
    internal bool FastAuthEnabled { get; }
    internal bool NTS { get; }
    internal Byte[] UUID { get; }
    unknown bool Tunnel {internal set; }
    internal Byte[] AcceptData { get; }
    internal Socket Socket { get; }
    internal Stream SocketStream { get; }
    internal bool RAW { get; internal set; }
    internal bool AllowCertificateSelectionUI { get; internal set; }
    internal string NamesDirectoryPath { get; internal set; }
    internal string SSLCertificateThumbprint { get; internal set; }
    internal string SqlNetAuthenticationServices { get; internal set; }
    unknown bool SecureTrace {internal set; }
    internal string ServerIs { get; internal set; }
    internal string ShardingKeyB64 { get; internal set; }
    internal string SuperShardingKeyB64 { get; internal set; }
    internal string ObCfgWL { get; internal set; }
    internal Hashtable ObCfgHT { get; internal set; }
    internal string ObTnsPt { get; internal set; }
    internal Hashtable ObTnsHT { get; internal set; }
    internal Hashtable ObLdpHT { get; internal set; }
    internal int DynamicSDU { get; internal set; }
    internal bool KeepAlive { get; internal set; }
    internal int KeepAliveTime { get; internal set; }
    internal int KeepAliveInterval { get; internal set; }
    internal InbandNotification InbandNotifier { get; internal set; }
    internal object InbandNotifContext { get; internal set; }
    internal bool READONLY_CHUNK_OK { get; }
    internal string ConnectDescriptor { get; }
    internal ConOraBufPool OraBufPool { get; internal set; }
    internal ConnectionOption ConnectionOption { get; }
    unknown Byte[] SSLWallet {internal set; }
    internal int SDU { get; }
    internal string Server { get; }
    internal bool TransportAliveNoSend { get; }
    internal bool TransportAlive { get; }
    internal string ConnectionID { get; }
    internal string UniqueConnectionId { get; internal set; }
    internal string OraConConIdPrefix { get; internal set; }
    internal object TraceObj { get; internal set; }
    internal OracleCommunication(ConOraBufPool oraBufPool);
    internal OracleCommunication(OracleCommunication lsnrEP, ConOraBufPool oraBufPool, object traceObj);
    [AsyncStateMachineAttribute("OracleInternal.Network.OracleCommunication/<ConnectViaCOAsync>d__0")]
private ValueTask ConnectViaCOAsync(ConnectionOption connOption, AddressResolution addrRes, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.Network.OracleCommunication/<ConnectAsync>d__1")]
internal ValueTask ConnectAsync(string tnsDescriptor, bool doNAHandshake, string IName, ConnectionOption CO, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.Network.OracleCommunication/<DoConnectAsync>d__2")]
private ValueTask DoConnectAsync(string tnsDescriptor, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.Network.OracleCommunication/<SendConnectPacketAndProcessResponseAsync>d__3")]
private ValueTask SendConnectPacketAndProcessResponseAsync(AddressResolution addrRes, bool bAsync);
    internal static void ClearX509Cache();
    internal static void GetSEPSUserIDandPW(string ConnectString, String& U, OracleOpaqueString& PW, String& WP, String& WF, SqlNetOraConfig DynSNOConfig, string WalletLocation);
    internal void GetInbandNotification(Int32& InbandEMFI, Int32& InbandErr1, Int32& InbandErr2, String& InbandErrMsg);
    internal bool get_FastAuthEnabled();
    internal bool get_NTS();
    internal Byte[] get_UUID();
    internal void set_Tunnel(bool value);
    internal Byte[] get_AcceptData();
    internal Socket get_Socket();
    internal Stream get_SocketStream();
    internal bool get_RAW();
    internal void set_RAW(bool value);
    internal bool get_AllowCertificateSelectionUI();
    internal void set_AllowCertificateSelectionUI(bool value);
    internal string get_NamesDirectoryPath();
    internal void set_NamesDirectoryPath(string value);
    internal string get_SSLCertificateThumbprint();
    internal void set_SSLCertificateThumbprint(string value);
    internal string get_SqlNetAuthenticationServices();
    internal void set_SqlNetAuthenticationServices(string value);
    internal void set_SecureTrace(bool value);
    internal string get_ServerIs();
    internal void set_ServerIs(string value);
    internal string get_ShardingKeyB64();
    internal void set_ShardingKeyB64(string value);
    internal string get_SuperShardingKeyB64();
    internal void set_SuperShardingKeyB64(string value);
    internal string get_ObCfgWL();
    internal void set_ObCfgWL(string value);
    internal Hashtable get_ObCfgHT();
    internal void set_ObCfgHT(Hashtable value);
    internal string get_ObTnsPt();
    internal void set_ObTnsPt(string value);
    internal Hashtable get_ObTnsHT();
    internal void set_ObTnsHT(Hashtable value);
    internal Hashtable get_ObLdpHT();
    internal void set_ObLdpHT(Hashtable value);
    internal int get_DynamicSDU();
    internal void set_DynamicSDU(int value);
    internal bool get_KeepAlive();
    internal void set_KeepAlive(bool value);
    internal int get_KeepAliveTime();
    internal void set_KeepAliveTime(int value);
    internal int get_KeepAliveInterval();
    internal void set_KeepAliveInterval(int value);
    internal InbandNotification get_InbandNotifier();
    internal void set_InbandNotifier(InbandNotification value);
    internal object get_InbandNotifContext();
    internal void set_InbandNotifContext(object value);
    internal bool get_READONLY_CHUNK_OK();
    internal string get_ConnectDescriptor();
    internal ConOraBufPool get_OraBufPool();
    internal void set_OraBufPool(ConOraBufPool value);
    internal ConnectionOption get_ConnectionOption();
    internal void set_SSLWallet(Byte[] value);
    internal bool InBreakResetMode();
    internal int get_SDU();
    internal string get_Server();
    internal bool get_TransportAliveNoSend();
    internal bool get_TransportAlive();
    internal string get_ConnectionID();
    internal string get_UniqueConnectionId();
    internal void set_UniqueConnectionId(string value);
    internal string get_OraConConIdPrefix();
    internal void set_OraConConIdPrefix(string value);
    internal object get_TraceObj();
    internal void set_TraceObj(object value);
    private void InitConOption(ConnectionOption connOption);
    private void checkNARequired(Ano m_ano);
    private void ConnectViaCO(ConnectionOption connOption, AddressResolution addrRes, bool bAsync);
    internal void Connect(string tnsDescriptor, ConnectionOption CO);
    internal void Connect(string tnsDescriptor, bool doNAHandshake, ConnectionOption CO);
    internal void Connect(string tnsDescriptor, bool doNAHandshake, string IName, ConnectionOption CO, bool bAsync);
    private void DoConnect(string tnsDescriptor, bool bAsync);
    internal string Answer();
    internal void Accept(string AcceptData);
    internal void Listen(string tnsDescriptor, bool inAddr_Any);
    internal void Listen(string tnsDescriptor);
    internal void SendNSNull();
    internal void Disconnect();
    internal string Resolve(string tnsAlias, ConnectionOption& CO);
    internal bool IsNAEInUse();
    internal void SendMarker(int markerType);
    internal void Break();
    internal void Reset();
    private void SendConnectPacketAndProcessResponse(AddressResolution addrRes, bool bAsync);
    internal bool SetFoldInKey(Byte[] Key, bool ExternalAuth, bool Sys, bool SvrVerifFailed, bool twoSessionPrxy);
    internal ITransportAdapter GetTransportAdapter(string protocol);
}
internal static class OracleInternal.Network.OracleConnectionId : object {
    private static int m_MaxrUniqueIdLenght;
    private static int m_MaxPrefixLenght;
    internal static string GetUniqueConnectionId();
    internal static string CreateConnectionId(string prefix, string conId, bool replace);
    private static bool IsPrefixValid(string prefix);
}
internal class OracleInternal.Network.Packet : object {
    internal static int NSPCHS_SZ;
    internal static int NSPFIF_SZ;
    internal static int NSPOVR_SZ;
    internal static int NSPSID_SZ;
    internal static int NSPFSID;
    internal static int NSPFRDS;
    internal static int NSPFRDR;
    internal static int NSPFSRN;
    internal static int NSPFPRB;
    internal TNSPacketType m_type;
    internal int m_length;
    internal int m_flags;
    protected int m_dataLength;
    protected int m_dataOffset;
    internal int m_totalLength;
    internal Byte[] m_dataBuffer;
    internal SessionContext m_sessionCtx;
    internal Packet(SessionContext sessCtx);
    internal Packet(SessionContext sessCtx, int bufferSize);
    internal Packet(SessionContext sessCtx, Byte[] buf);
    internal Packet(SessionContext sessCtx, int bufferSize, int pktType, int pktFlags);
    internal Packet(Packet pkt);
    private static Packet();
    internal void CreateBuffer(int pktSize, int pktType, int pktFlags, SessionContext SCtx);
    internal virtual void Send();
    internal virtual void Receive();
    internal static void GetHeaderValues(Byte[] DataBuf, Int32& Length, Int32& Flags, TNSPacketType& Type, SessionContext SCtx);
    internal Byte[] ExtractData(bool AcceptPacket);
}
internal class OracleInternal.Network.ReaderStream : object {
    protected ConnectionOption m_conOpt;
    protected SessionContext m_sessionCtx;
    protected DataPacket m_dataPacket;
    protected bool m_secureTrace;
    internal bool m_EOF;
    protected OraBuf m_OraBuf;
    private Byte[] m_oneByteBuffer;
    private Byte[] m_PacketHeader;
    private int m_PacketHeaderLen;
    private int m_PacketLength;
    private int DAFlags;
    private int m_HeaderFlags;
    private TNSPacketType m_PacketType;
    private int m_remainder;
    private object m_listlock;
    unknown bool SecureTrace {internal set; }
    internal ReaderStream(SessionContext sessCtx, ConnectionOption ConOpt);
    internal void set_SecureTrace(bool value);
    internal void CheckInBandNotif_Migration();
    private void ProcessHeaderData(OraBuf OB, Int32& Length, Int32& Offset, int headerLen);
    [AsyncStateMachineAttribute("OracleInternal.Network.ReaderStream/<ProcessOBAsync>d__20")]
private ValueTask ProcessOBAsync(OraBuf OB, bool bAsync);
    private void ProcessOB(OraBuf OB, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.Network.ReaderStream/<ReadItAsync>d__22")]
private ValueTask ReadItAsync(OraBuf OB, int len, int offset, bool bAsync);
    private void ReadIt(OraBuf OB, int len, int offset, bool bAsync);
    internal void WaitForReset();
    [AsyncStateMachineAttribute("OracleInternal.Network.ReaderStream/<asyncRead>d__25")]
internal Task`1<int> asyncRead(OraBuf OB);
    internal int Read(OraBuf OB, Int32& InbandErr, String& InbandErrMsg);
    [AsyncStateMachineAttribute("OracleInternal.Network.ReaderStream/<ReadwithCryptoAsync>d__27")]
private ValueTask`1<int> ReadwithCryptoAsync(OraBuf OB, bool bAsync);
    private int ReadwithCrypto(OraBuf OB, bool bAsync);
    private void HandleCrypto(OraBuf OB);
    internal int Read();
    internal int ReadOne();
    internal int Read(Byte[] userBuffer);
    internal int Read(Byte[] userBuffer, int offset, int length);
    internal void getNextPacket();
}
internal class OracleInternal.Network.RedirectPacket : Packet {
    internal string redirectAddress;
    internal string redirectConnectData;
    internal RedirectPacket(Packet pkt);
}
internal class OracleInternal.Network.RefusePacket : Packet {
    internal int m_userReason;
    internal int m_systemReason;
    private string m_data;
    internal string Data { get; }
    internal RefusePacket(Packet pkt);
    internal string get_Data();
}
internal class OracleInternal.Network.SEPS : object {
    private static UInt32 X509_ASN_ENCODING;
    private static UInt32 PKCS_7_ASN_ENCODING;
    private static UInt32 X509_SEQUENCE_OF_ANY;
    private static UInt32 PKCS_CONTENT_INFO;
    private static UInt32 PKCS_CONTENT_INFO_SEQUENCE_OF_ANY;
    private static UInt32 X509_OCTET_STRING;
    private static UInt32 X509_OBJECT_IDENTIFIER;
    private static UInt32 ENCODING;
    private static UInt32 HASH_BLOCK_SIZE;
    private static byte MSB;
    private static string pkcs_12_secretBag;
    private static string oracleOID;
    private static string pbeWithSHAAnd3_KeyTripleDES_CBC;
    private static string pbeWithSHAAnd40BitRC2_CBC;
    private static string pbeS2;
    private static string szOID_PKCS_7_DATA;
    private static string szOID_PKCS_7_ENCRYPTED;
    private static string WALLETFILENAME;
    private static int allocs;
    private static bool CryptDecodeObject(UInt32 dwCertEncodingType, string lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, UInt32 dwFlags, IntPtr pvStructInfo, UInt32& pcbStructInfo);
    private static bool CryptDecodeObject(UInt32 dwCertEncodingType, UInt32 lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, UInt32 dwFlags, IntPtr pvStructInfo, UInt32& pcbStructInfo);
    private static IntPtr Alloc(int len);
    private static void Free(IntPtr ptr);
    internal static Byte[] GetWalletBytes(SqlNetOraConfig SNOConfig, String& WalletPassw, String& WP, String& WF, bool trcOn, string passedWalletDir);
    internal static Byte[] GetEncodedBags(Byte[] pbPKCS12, string WalletPassw, bool trcOn);
    internal static void GetSEPSUandP(string ConnectString, String& Userid, OracleOpaqueString& PW, String& WP, String& WF, SqlNetOraConfig DynSNOConfig, string WalletLocation);
    internal static string GetValue(SqlNetOraConfig SNOConfig, string Key, string passedWalletDir, string passedWalletPW);
    private static SortedList GetListOfSecretBags(Byte[] EncodedBags);
    private static bool ExtractDataAndKeyParametersFromPFX(Byte[] pbPKCS12, UInt32 dwPKCS12, Byte[]& EncryptedData, Byte[]& Salt, Int32& dwIterationCount, PbeAlgorithmType& AlgType, Byte[]& IV, Int32& KeySize);
    public static void FillBuffer(Byte[] From, Byte[] To);
    public static ICryptoTransform GeneratePbeSHA1Decryptor(string passw, Byte[] salt, int sha1iterations, PbeAlgorithmType AlgType, SymmetricAlgorithm& SA);
    private static bool AllocAndDecode(UInt32 lpszStructType, Byte[] pbByteEncoded, IntPtr& pvStructInfo);
    private static bool AllocAndDecode(string lpszStructType, Byte[] pbByteEncoded, IntPtr& pvStructInfo);
    private static bool AllocAndDecode(UInt32 lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, IntPtr& pvStructInfo);
    private static bool AllocAndDecode(string lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, IntPtr& pvStructInfo);
    public static string DecodeOID(Byte[] pbEncodedOID);
    public static Byte[] ASNDecodeData(Byte[] pbData);
    public static object ASNDecodeUTF8String(Byte[] pbData, bool bReturnOpaqueString);
    public static Byte[] ASNDecodeInteger(Byte[] pbData);
    public static int CalculateInteger(Byte[] pbData);
}
internal class OracleInternal.Network.SEPSASN1 : object {
    internal static void GetAlgParams(Byte[] tryit, Byte[] tryit3, Byte[]& IV, Byte[]& Salt, Int32& KeySize, Int32& Iterations);
}
internal class OracleInternal.Network.SessionContext : object {
    internal static int NSVSNDHS;
    internal static int NSVSNRDS;
    internal static int NSVSNRDR;
    internal static int NSVSNDHO;
    internal static int NSVSNDHE;
    internal static int NSVSNIP6;
    internal static int NSVSNSRN;
    internal static int NSVSNPPP;
    internal static int NSVSNLSD;
    internal static int NSVSNCMP;
    internal static int NSVSNCMN;
    internal static int NSVSNHAN;
    internal static int NSVSNAPN;
    internal static int NSVSNOOB;
    internal static int NSVSNUID;
    internal static int NSVSNFAT;
    internal int m_portNo;
    internal string m_instanceName;
    internal string m_hostName;
    internal IPAddress m_ipAddress;
    internal string m_protocol;
    internal string m_serviceName;
    internal Byte[] m_SID;
    internal Stream m_socketStream;
    internal Socket m_socket;
    internal Socket m_testSocket;
    internal string m_connectData;
    internal ConnectionOption m_conops;
    internal long writeTimeStamp;
    internal int m_myversion;
    internal int m_loversion;
    internal int m_options;
    internal int m_negotiatedOptions;
    internal int m_negotiatedOptions2;
    internal ushort m_ourone;
    internal ushort m_hisone;
    internal string m_reconAddr;
    internal Ano m_ano;
    internal bool m_bAnoEnabled;
    internal bool cryptoNeeded;
    internal EncryptionAlgorithm encryptionAlg;
    internal int cryptoBlockSize;
    internal int m_ACFL0;
    internal int m_ACFL1;
    internal int m_sessionDataUnit;
    internal int m_transportDataUnit;
    internal ReaderStream m_readerStream;
    internal WriterStream m_writerStream;
    internal ITransportAdapter m_transportAdapter;
    internal bool m_NSHandshakeComplete;
    internal bool m_usingAsyncReceives;
    internal bool isNTConnected;
    internal bool m_onBreakReset;
    internal bool m_gotReset;
    internal bool m_gotInBandNotif;
    internal int m_InBandNotifCmd;
    internal int m_InBandNotifEMFI;
    internal int m_InBandNotifErr1;
    internal int m_InBandNotifErr2;
    internal InbandNotification m_InbandNotification;
    internal object m_inbandErrContext;
    internal OracleCommunication OC;
    internal SessionContext(int sduSize, int tduSize, OracleCommunication theOC);
    private static SessionContext();
}
internal class OracleInternal.Network.SupervisorService : AnoService {
    internal static int NAS_OK;
    internal static int NAS_CLIENT_SERVICES_UNAVAILABLE;
    internal static int NAS_SERVER_SERVICES_UNAVAILABLE;
    internal static int NAS_NO_SERVICES_AVAILABLE;
    internal static int NAS_SERVICE_REQUIRED;
    internal static int NAS_REQUIRED_SERVICE_UNAVAILABL;
    internal static int NAS_SERVICE_UNAVAILABLE;
    private Byte[] m_cid;
    private Int32[] m_servicesArray;
    private Int32[] m_serverServices;
    private int m_servicesValidated;
    private int m_servicesWanted;
    internal virtual int Initialize(SessionContext sessCtx);
    internal Byte[] CreateCID();
    internal virtual void SendServiceData();
    internal virtual int GetServiceDataLength();
    internal virtual void ReceiveServiceData(int numSubPackets);
    internal virtual void ValidateResponse();
}
internal class OracleInternal.Network.TcpsTransportAdapter : TcpTransportAdapter {
    private static int SSL_VERSION_TLS12;
    private static int SSL_VERSION_TLS13;
    private static string OneWayTLS;
    protected bool DNMatching;
    protected SslStream m_sslstream;
    protected bool m_DNMatched;
    private static X509Certificate2Collection RootLocalMachineCAs;
    private static Hashtable UISelections;
    private static Hashtable TPSelections;
    private string Hash;
    private X509Certificate2 x509;
    private X509Certificate2Collection x509Collection;
    private static Hashtable Certificates;
    private static Queue`1<string> CacheQ;
    private static int MaxCacheSz;
    public bool NeedReneg { get; }
    internal TcpsTransportAdapter(NameValueCollection socketOptions);
    internal TcpsTransportAdapter(ConnectionOption conOption, TcpClient tcpClient);
    private static TcpsTransportAdapter();
    internal static void ClearX509Cache();
    private static void InsertCert(Hashtable HT, string Hash, X509Certificate2 Selection);
    internal static void InsertCert(string WalletDirectory, X509Certificate2Collection X509s);
    private static void DeleteCert(string WalletDirectory);
    internal static X509Certificate2Collection GetCert(string WalletDirectory);
    public virtual void Renegotiate(ConnectionOption conOption);
    public virtual bool get_NeedReneg();
    public virtual void Connect(ConnectionOption conOption, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.Network.TcpsTransportAdapter/<ConnectAsync>d__26")]
public virtual ValueTask ConnectAsync(ConnectionOption conOption, bool bAsync);
    public virtual Stream ConnectIterate();
    public virtual ITransportAdapter Answer(ConnectionOption conOption);
    public virtual void Disconnect();
    public virtual Stream GetStream();
    public virtual Socket GetSocket();
    public virtual Socket GetTestSocket();
    public virtual void Send(OraBuf OB);
    internal void HandleMCSSelection(X509Certificate2& x509, ConnectionOption conOption, String& tprnt);
    private void Get1WayCerts(String& WalletMethod, X509Certificate2Collection& x509Collection);
    private void Negotiate(ConnectionOption conOption);
    private bool ValidateRemoteCertificate(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors pErrs);
    public virtual void BeginAsyncReceives(AsyncReceiveCallback Callback, int AsyncBufferSize);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private ValueTask <>n__0(ConnectionOption conOption, bool bAsync);
}
internal class OracleInternal.Network.TcpTransportAdapter : object {
    protected TcpClient m_client;
    protected TcpListener m_listener;
    protected string m_host;
    protected int m_portNo;
    protected bool m_Connected;
    protected ConnectionOption m_conOption;
    protected AsyncReceiveCallback m_AsyncRecvCB;
    protected ConOraBufPool m_OraBufPool;
    protected int m_OraBufSize;
    protected object m_OraBufInitArg;
    protected IAsyncResult m_ar;
    private IPAddress[] addresses;
    private bool https_proxy;
    private int iterator;
    protected Socket[] m_listsocks;
    protected bool m_v6OnlyOff;
    protected bool m_DblListen;
    private static int m_DefListenBacklog;
    private IAsyncResult[] m_AcceptARs;
    protected Byte[] m_AsyncBuffer;
    protected OraBuf m_OraBuf;
    protected object m_discLock;
    private static int BytesPerLong;
    private static int BitsPerByte;
    unknown ConOraBufPool OraBufPool {public set; }
    public bool Connected { get; }
    public bool NeedReneg { get; }
    internal TcpTransportAdapter(NameValueCollection socketOptions);
    internal TcpTransportAdapter(ConnectionOption conOption, TcpClient tcpClient);
    private static TcpTransportAdapter();
    [AsyncStateMachineAttribute("OracleInternal.Network.TcpTransportAdapter/<ConnectAsync>d__24")]
public virtual ValueTask ConnectAsync(ConnectionOption conOption, bool bAsync);
    public virtual void Connect(ConnectionOption conOption, bool bAsync);
    public virtual Stream ConnectIterate();
    private void Initialize(ConnectionOption conOption);
    private void StartListening(IPAddress addr, int i);
    public sealed virtual void Listen(ConnectionOption conOption);
    private Socket DblListenAccept();
    public virtual ITransportAdapter Answer(ConnectionOption conOption);
    public virtual void Disconnect();
    public virtual Stream GetStream();
    public virtual Socket GetSocket();
    public virtual Socket GetTestSocket();
    public virtual bool UrgentDataSupported();
    private void Send(OraArraySegment[] OAS, int OASLength);
    public virtual void Send(OraBuf OB);
    public virtual void BeginAsyncReceives(AsyncReceiveCallback myCallback, int AsyncBufferSize);
    public sealed virtual void SendUrgent(Byte[] data, int offset, int length);
    public sealed virtual void set_OraBufPool(ConOraBufPool value);
    public sealed virtual bool get_Connected();
    public virtual bool get_NeedReneg();
    public virtual void Renegotiate(ConnectionOption conOption);
    internal void Handle_HTTPS_PROXY(ConnectionOption co);
    private bool SetKeepAlive(Socket sock, int time, int interval);
}
internal class OracleInternal.Network.TNSNames : object {
    private static ReaderWriterLockSlim myLock;
    private static Hashtable m_TNSNamesMap;
    internal Hashtable m_TNSNamesMapDyn;
    private object m_TraceObj;
    public string ID { get; }
    public Hashtable Map { get; }
    private static TNSNames();
    public sealed virtual string get_ID();
    public sealed virtual Hashtable get_Map();
    internal void SetNewHT(Hashtable HT);
    public sealed virtual string Resolve(string TNSAlias, ConnectionOption& CO, string OraConConIdPrefix, string UniqueConnectionId, object TraceObj, string InstanceName, string ServerIs);
    public sealed virtual void Refresh();
}
internal class OracleInternal.Network.TNSPacketOffsets : object {
    internal static byte NSPHDLEN;
    internal static byte NSPHDPSM;
    internal static byte NSPHDTYP;
    internal static byte NSPHDFLGS;
    internal static byte NSPHDHSM;
    internal static byte NSPSIZHD;
    internal static byte NSPCNVSN;
    internal static byte NSPCNLOV;
    internal static byte NSPCNOPT;
    internal static byte NSPCNSDU;
    internal static byte NSPCNTDU;
    internal static byte NSPCNNTC;
    internal static byte NSPCNTNA;
    internal static byte NSPCNONE;
    internal static byte NSPCNLEN;
    internal static byte NSPCNOFF;
    internal static byte NSPCNMXC;
    internal static byte NSPCNFL0;
    internal static byte NSPCNFL1;
    internal static byte NSPCNNUL;
    internal static byte NSPCNTMO;
    internal static byte NSPCNTCK;
    internal static byte NSPCNADL;
    internal static byte NSPCNADF;
    internal static byte NSPCNDAT;
    internal static byte NSPCNLSD;
    internal static byte NSPCNLTD;
    internal static byte NSPCNCFL;
    internal static byte NSPCNFL2;
    internal static byte NSPCNV315DAT;
    internal static byte NSPCNV318DAT;
    internal static byte NSPACVSN;
    internal static byte NSPACOPT;
    internal static byte NSPACSDU;
    internal static byte NSPACTDU;
    internal static byte NSPACONE;
    internal static byte NSPACLEN;
    internal static byte NSPACOFF;
    internal static byte NSPACFL0;
    internal static byte NSPACFL1;
    internal static byte NSPACTMO;
    internal static byte NSPACTCK;
    internal static byte NSPACADL;
    internal static byte NSPACAOF;
    internal static byte NSPACDAT;
    internal static byte NSPACLSD;
    internal static byte NSPACLTD;
    internal static byte NSPACCFL;
    internal static byte NSPACFL2;
    internal static int NSGPCHKSCMD;
    internal static int NSGENBAPPF3;
    internal static int NSGPXYCON;
    internal static int NSGDISSRN;
    internal static int NSGENBFAT;
    internal static byte NSPACUID;
    internal static byte NSPACCFON;
    internal static byte NSPACCFAT;
    internal static byte NSPACCFNT;
    internal static byte NSPACV315DAT;
    internal static byte NSPACV318DAT;
    internal static byte NSPACV319DAT;
    internal static byte NSPRFURS;
    internal static byte NSPRFSRS;
    internal static byte NSPRFLEN;
    internal static byte NSPRFDAT;
    internal static byte NSPRDLEN;
    internal static byte NSPRDDAT;
    internal static short NSPDAFLG;
    internal static short NSPDADAT;
    internal static short NSPMKTYP;
    internal static short NSPMKODT;
    internal static short NSPMKDAT;
    internal static int NSPCTLCMD;
    internal static int NSPCTLDAT;
    internal static int NSPCTLEMFI;
    internal static int NSPCTLERR1;
    internal static int NSPCTLERR2;
    internal static ushort NSGDONTCARE;
    internal static ushort NSGHDX;
    internal static ushort NSGFDX;
    internal static ushort NSGHDRCHKSUM;
    internal static ushort NSGPAKCHKSUM;
    internal static ushort NSGCHKSUM;
    internal static ushort NSGBROKEN;
    internal static ushort NSGUSEVIO;
    internal static ushort NSGOSAUTHOK;
    internal static ushort NSGSENDATTN;
    internal static ushort NSGRECVATTN;
    internal static ushort NSGNOATTNPR;
    internal static ushort NSGRAW;
    internal static ushort NSGMLTPLX;
    internal static ushort NSGDHANDOFF;
    internal static ushort NSGNEVER;
    internal static ushort NSPMXCDATA;
    internal static byte NSINADISABLEFORCONNECTION;
    private static TNSPacketOffsets();
}
internal enum OracleInternal.Network.TNSPacketType : Enum {
    public int value__;
    public static TNSPacketType CONNECT;
    public static TNSPacketType ACCEPT;
    public static TNSPacketType ACK;
    public static TNSPacketType REFUSE;
    public static TNSPacketType REDIRECT;
    public static TNSPacketType DATA;
    public static TNSPacketType NULL;
    public static TNSPacketType ABORT;
    public static TNSPacketType RESEND;
    public static TNSPacketType MARKER;
    public static TNSPacketType ATTN;
    public static TNSPacketType CTRL;
    public static TNSPacketType HIGHEST;
}
internal class OracleInternal.Network.WebSocketStream : Stream {
    private static string CRLF;
    private static string HTTP_METHOD;
    private static string HTTP_VERSION;
    private static string HOST_HEADER;
    private static string ORACLE_WEBSOCKET_SERVER_HEADER;
    private static string UPGRADE_HEADER;
    private static string CONNECTION_HEADER;
    private static string CONNECTION_CLOSE_HEADER;
    private static string AUTHORIZATION_HEADER;
    private static string SWITCH_PROTOCOL_STATUS;
    private static string BAD_REQUEST_STATUS;
    private static string WEBSOCK_KEY_HEADER;
    private static string WEBSOCK_ACCEPT_HEADER;
    private static string WEBSOCK_PROTO_HEADER;
    private static string WEBSOCK_VER_HEADER;
    private static string SERVER_HEADER;
    private static string DATE_HEADER;
    private static string CONTENT_TYPE_HEADER;
    private static string WEBSOCK_SERVER_UUID;
    private static int SEC_WEBSOCKET_KEY_LENGTH;
    private static int SEC_WEBSOCKET_KEY_HASH_LENGTH;
    private static string HTTP_MESSAGE_HEADER_END;
    private static string HTTP_BAD_REQUEST_MESSAGE;
    private static string HTTP_BAD_REQUEST_MESSAGE_END;
    private static string DEFAUL_SUBPROTOCOL;
    private static int WEBSOCKET_BUFFER_LENGTH;
    private WebSocketRoles m_WebSocketRole;
    private ConnectionOption m_conOption;
    private Stream m_TcpStream;
    private WebSocketState m_WebSocketState;
    private Byte[] m_Sec_WebSocket_Key;
    private string m_b64_Sec_WebSocket_Key;
    private Byte[] m_WebSocket_Buffer;
    private WebSocketDataFrame m_rcv_frame_buf;
    private WebSocketDataFrame m_snd_frame_buf;
    internal WebSocketRoles WebSocketRole { get; }
    internal WebSocketState State { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal WebSocketStream(ConnectionOption conOption, Stream TcpStream);
    internal void SetStream(Stream TcpStream);
    internal void Handshake(WebSocketRoles role);
    internal WebSocketRoles get_WebSocketRole();
    internal WebSocketState get_State();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    private void SendHandshakeRequest();
    private void ParseHandshakeRequest();
    private void SendHandshakeResponse();
    private void SendBadRequestResponse();
    private void ParseHandshakeResponse();
    private List`1<string> GetHandshakeMessage();
    private int GetIndexOfFirstAlphaNumeric(string message, int index);
    private string GenerateResponseKey(string keyString);
    private void SendControlFrame(WebSocketDataFrameOpcode opCode, Byte[] controlData, int offset, int count);
}
internal class OracleInternal.Network.WriterStream : object {
    protected SessionContext m_sessionCtx;
    protected bool m_secureTrace;
    internal DataPacket m_dataPacket;
    private Byte[] m_oneByteBuffer;
    unknown bool SecureTrace {internal set; }
    internal WriterStream(SessionContext sessCtx);
    internal void set_SecureTrace(bool value);
    private void GetReadyToWrite(OraBuf& OB, int DAFlag);
    internal Task AsyncWrite(OraBuf OB, int DAFlag);
    internal void Write(OraBuf OB, int DAFlag);
    private void EncryptOraBuf(OraBuf& OB);
    private void TraceOB(OraBuf OB);
    internal void Write(byte val);
    internal void Write(Byte[] inputBuffer);
    internal void Write(Byte[] inputBuffer, int offset, int length);
    internal void Flush();
    internal void DiscardData();
}
internal class OracleInternal.Network.WssTransportAdapter : object {
    internal static string WSS_PROTOCOL;
    internal static string WS_PROTOCOL;
    protected bool m_Connected;
    protected bool m_WSS;
    protected ConOraBufPool m_OraBufPool;
    protected ConnectionOption m_conOption;
    protected WebSocketStream m_WebSocketStream;
    private ITransportAdapter m_TcpConnection;
    unknown ConOraBufPool OraBufPool {public set; }
    public bool Connected { get; }
    public bool NeedReneg { get; }
    internal WssTransportAdapter(NameValueCollection socketOptions);
    internal WssTransportAdapter(ConnectionOption conOption, ITransportAdapter tcpConnection, WebSocketStream webSocketStream);
    [AsyncStateMachineAttribute("OracleInternal.Network.WssTransportAdapter/<ConnectAsync>d__10")]
public sealed virtual ValueTask ConnectAsync(ConnectionOption conOption, bool bAsync);
    public sealed virtual void Connect(ConnectionOption conOption, bool bAsync);
    public sealed virtual Stream ConnectIterate();
    public sealed virtual void Listen(ConnectionOption conOption);
    public sealed virtual ITransportAdapter Answer(ConnectionOption conOption);
    public sealed virtual void Disconnect();
    public sealed virtual Stream GetStream();
    public sealed virtual Socket GetSocket();
    public sealed virtual Socket GetTestSocket();
    public sealed virtual bool UrgentDataSupported();
    public sealed virtual void SendUrgent(Byte[] data, int offset, int length);
    public sealed virtual void Send(OraBuf OB);
    public sealed virtual void BeginAsyncReceives(AsyncReceiveCallback Callback, int AsyncBufferSize);
    public sealed virtual void set_OraBufPool(ConOraBufPool value);
    public sealed virtual bool get_Connected();
    public sealed virtual bool get_NeedReneg();
    public sealed virtual void Renegotiate(ConnectionOption conOption);
    private void CreateTcpConnection(ConnectionOption conOption);
}
internal interface OracleInternal.NotificationServices.CallBack {
    public abstract virtual void notification_callback(Notification n);
}
internal class OracleInternal.NotificationServices.CallBackThread : ThreadClass {
    private static int THREADPERCB;
    protected internal CallBackThread(Subscriber subs, CallBack cbo, Notification not);
    public virtual void Run();
    protected internal virtual void set_shutdown();
}
internal class OracleInternal.NotificationServices.Concurrency : object {
    protected internal long scanTime;
    protected internal int index;
    protected internal int assignedIndex;
    protected internal int scanIndex;
    protected internal bool active;
    protected internal bool listFailed;
    unknown long ScanTime {protected internal set; }
    protected internal Concurrency(int myIndex);
    protected internal virtual void set_ScanTime(long value);
    protected internal virtual void assign(Connection connection);
    protected internal virtual void connected();
    protected internal virtual void clear();
    protected internal virtual void setListFailed();
}
internal class OracleInternal.NotificationServices.Connection : object {
    private ONS ons;
    private NodeList nodeList;
    private int listIndex;
    private int concurrencyIndex;
    private string host;
    private int port;
    private string id;
    private object socketlock;
    private int waiters;
    private int serverVersion;
    protected static string RequestPrefix;
    protected static string RequestFormFactor;
    protected static string RequestSuffix;
    protected static string ResponseOK;
    internal ONSTcpClient socket;
    internal ReceiverThread receiver;
    internal SenderThread sender;
    internal long scanDelay;
    internal bool shutdown;
    protected internal int ConcurrencyIndex { get; protected internal set; }
    unknown long ScanDelay {protected internal set; }
    public string Id { get; }
    public int ServerVersion { get; public set; }
    protected internal int ListIndex { get; }
    unknown ReceiverThread ClientReceiver {protected internal set; }
    unknown SenderThread ClientSender {protected internal set; }
    unknown bool ClientShutdown {protected internal set; }
    internal Connection(NodeList cList, string cHost, int cPort, int index);
    private static Connection();
    protected internal virtual int get_ConcurrencyIndex();
    protected internal virtual void set_ConcurrencyIndex(int value);
    protected internal virtual void set_ScanDelay(long value);
    public virtual string get_Id();
    public virtual int get_ServerVersion();
    public virtual void set_ServerVersion(int value);
    protected internal virtual int get_ListIndex();
    protected internal virtual void set_ClientReceiver(ReceiverThread value);
    protected internal virtual void set_ClientSender(SenderThread value);
    protected internal virtual void set_ClientShutdown(bool value);
    protected internal virtual ONSTcpClient getClientSocket(bool block);
    protected internal virtual void setClientSocket(ONSTcpClient sock);
    protected internal virtual void closeClientSocket();
    protected internal virtual ONSTcpClient connect();
    private static bool ValidateRemoteCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors policyErrors);
}
internal class OracleInternal.NotificationServices.Constants : object {
    public static string ONS_EMPTY_SUBSCRIPTION;
    public static string ONS_REGISTER_NOTIFICATION;
    public static string ONS_STATUS_NOTIFICATION;
    public static string ONS_RPC_PING_NOTIFICATION;
    public static string ONS_RPC_PING_REPLY_NOTIFICATION;
    public static string ONS_RPC_REQUEST_NOTIFICATION;
    public static string ONS_REGISTER_ID_PREFIX;
    public static string ONS_REGISTER_ID;
    public static string ONS_SUBSCRIBER_ID;
    public static string ONS_REGISTER_GROUP;
    public static string ONS_DIRECT_ROUTE;
    public static string ONS_BACK_ROUTE;
    public static string ONS_TRACE_ROUTE;
    public static string ONS_DIRECT_SOURCE;
    public static string ONS_BROADCAST_ID;
    public static string ONS_RESULT;
    public static string ONS_MESSAGE;
    public static string ONS_RPC_REQUEST;
    public static long RPC_SERVER_REGISTRATION_TIMEOUT;
}
internal class OracleInternal.NotificationServices.InputBuffer : object {
    public static string END_OF_STREAM_MESSAGE;
    private Stream inputStream;
    protected internal string NextString { get; }
    protected internal InputBuffer(Stream inputStream);
    protected internal virtual string get_NextString();
    protected internal virtual int getBytes(SByte[] buf, int len);
    protected internal virtual int skipBytes(int len);
}
internal interface OracleInternal.NotificationServices.IThreadRunnable {
    public abstract virtual void Run();
}
internal class OracleInternal.NotificationServices.NodeList : object {
    private object publishLock;
    private List`1<Notification> publishQueue;
    private object connLock;
    private Connection[] connections;
    private bool connCheck;
    private List`1<ReceiverThread> staleReceivers;
    private int concurrency;
    private int senderIndex;
    private SenderThread senderThread;
    private string id;
    private bool failedOver_Renamed_Field;
    private bool shutdown;
    private Concurrency[] concurrencies;
    private Hashtable notifications;
    private long lastCleanupTime;
    protected internal ONS ons;
    protected internal NodeList failOverList;
    protected internal bool active;
    protected internal long shutdownTimeout;
    private static long ConnectionDelay;
    private static char ONS_HP_SEPARATOR;
    unknown NodeList FailOver {protected internal set; }
    public string Id { get; }
    unknown long Shutdown {protected internal set; }
    public NodeList(string listId, string listNodes, int listConcurrency, bool listActive, ONS listONS);
    public string getId();
    protected internal virtual void set_FailOver(NodeList value);
    public virtual string get_Id();
    protected internal virtual void set_Shutdown(long value);
    protected internal virtual void start(bool force);
    private void startConnection(Connection conn);
    private SenderThread getSenderThread(bool wakeNew);
    protected internal virtual Notification getFirstPublished(SenderThread st);
    protected internal virtual void removeFirstPublished(Notification re, SenderThread st);
    protected internal virtual void clearPublishedSender(SenderThread st);
    protected internal virtual void send(SubscriptionNotification se);
    private void buildConnectionArray(string hplist);
    private String[] scanNodes(string hpList);
    private void nodesRandomize(String[] nodes);
    protected internal virtual void checkConnections(Connection conn);
    private void replaceConnection(Connection oConn, Connection nConn, int index);
    private void stopConnection(Connection conn);
    private void joinConnection(Connection conn, bool shutdownState);
    protected internal virtual void establishedConnection(Connection conn);
    protected internal virtual void failedOver(NodeList failOver, int cIndex);
    protected internal virtual void fallBack(int cIndex);
    private void joinStaleRecievers(ReceiverThread caller);
    protected internal virtual void stop();
    protected internal virtual void join();
    private void setConnectionsBusy();
    private void clearConnectionsBusy();
    protected internal virtual void deliver(Notification e);
    private bool isDupNotification(Notification e);
    private void cleanupNotificationTable(string key, NotificationInformation elem);
    private void cleanupNotificationTable(long currentTime);
}
internal class OracleInternal.NotificationServices.Notification : object {
    protected internal static SByte[] eventmessageline;
    protected internal static SByte[] poststring;
    protected internal static SByte[] headerseparator;
    protected internal static SByte[] crlf;
    protected internal static SByte[] versionheader;
    protected internal static SByte[] versionheaderid;
    protected internal static SByte[] typeheader;
    protected internal static SByte[] affectedcomponentsheader;
    protected internal static SByte[] affectednodesheader;
    protected internal static SByte[] generatingcomponentheader;
    protected internal static SByte[] generatingnodeheader;
    protected internal static SByte[] generatingprocessheader;
    protected internal static SByte[] idheader;
    protected internal static SByte[] clusteridheader;
    protected internal static SByte[] clusternameheader;
    protected internal static SByte[] instanceidheader;
    protected internal static SByte[] instancenameheader;
    protected internal static SByte[] creationtimeheader;
    protected internal static SByte[] contentlengthheader;
    protected internal static SByte[] numpropertiesheader;
    protected internal static SByte[] localonlyheader;
    protected internal static SByte[] stampheader;
    protected internal static SByte[] hostname;
    protected internal static SByte[] truestring;
    protected internal static SByte[] falsestring;
    protected internal static SByte[] versionheaderid3;
    protected internal static SByte[] versionheaderid6;
    protected internal static SByte[] clusteronlyheader;
    internal static string CONTENT_LENGTH;
    private SByte[] body_Renamed_Field;
    protected internal bool localonly;
    protected internal long deliveryTime_Renamed_Field;
    protected internal string generatingComponent_Renamed_Field;
    protected internal string generatingNode_Renamed_Field;
    protected internal string generatingProcess_Renamed_Field;
    protected internal string id_Renamed_Field;
    protected internal long creationTime_Renamed_Field;
    protected internal string clusterId_Renamed_Field;
    protected internal string clusterName_Renamed_Field;
    protected internal string instanceId_Renamed_Field;
    protected internal string instanceName_Renamed_Field;
    protected internal ONS oems;
    protected internal Int32[] recipients;
    protected internal Notification(InputBuffer ibuf, ONS oems);
    private static Notification();
    protected internal virtual void send(OutputBuffer obuf, ONS oems, Connection connection);
    public virtual string type();
    public virtual SByte[] body();
}
internal class OracleInternal.NotificationServices.NotificationInformation : object {
    internal long timestamp;
    internal int count;
    internal int Count { get; }
    internal long Timestamp { get; }
    internal NotificationInformation(long stamp);
    internal virtual int get_Count();
    internal virtual long get_Timestamp();
    internal virtual void addCount();
}
internal class OracleInternal.NotificationServices.NotificationQueue : object {
    private ONS ons;
    private QueueElement head;
    private QueueElement tail;
    private object lock_Renamed;
    private object closelock;
    private int waiters_Renamed_Field;
    private int count_Renamed_Field;
    private bool closed;
    private bool closing;
    private int closewaiters;
    protected internal static int DEFAULT_PRIORITY;
    protected internal static int LOW_PRIORITY;
    protected internal static int HIGH_PRIORITY;
    internal NotificationQueue(ONS myONS);
    private static NotificationQueue();
    protected internal virtual void enqueue(object e);
    protected internal virtual void push(object e, int p);
    protected internal virtual void close();
    protected internal virtual object dequeue(bool blocking);
    private object internalDequeue(bool blocking, long wait);
    protected internal virtual void wake();
    protected internal virtual void drain_and_close(long timeout);
}
internal class OracleInternal.NotificationServices.ONS : object {
    private static object lock_Renamed;
    private static ONS myoems;
    private object myLock;
    private Hashtable subscribers;
    private Hashtable pendingSubscriptions;
    private int subscriberId;
    private int publisherId;
    private int numPublishers;
    private long startTime;
    private string processId_Renamed_Field;
    private string hostname_Renamed_Field;
    private NameValueCollection properties;
    private object nodeLock;
    protected List`1<NodeList> nodeLists;
    protected internal string walletfile;
    protected internal string passw;
    protected internal string clusterid;
    protected internal string clustername;
    protected internal string instanceid;
    protected internal string instancename;
    protected internal string oraclehome;
    protected internal bool localConn;
    protected internal bool defaultList;
    protected internal bool useSCAN;
    protected internal bool shutdown_Renamed_Field;
    protected internal long shutdowntimeout;
    protected internal long notificationtimeout;
    private int maxconcurrency;
    protected internal int remoteIOtimeout;
    protected internal static int ONS_REMOTE_MIN_TIMEOUT;
    protected internal static int ONS_REMOTE_MAX_TIMEOUT;
    protected internal static int ONS_REMOTE_DFLT_TIMEOUT;
    protected internal static int ONS_REMOTE_SUBSCRIBER_ID;
    protected internal static string ONS_REMOTE_SUBSCRIPTION;
    protected internal static string ONS_SSL_CONTEXT_PROTOCOL;
    protected internal static string ONS_SSL_KEY_MANAGEMENT;
    protected internal static string ONS_NODES;
    protected internal static string ONS_WALLET_FILE;
    protected internal static string ONS_PASSW;
    protected internal static string ONS_FILE_STRING;
    protected internal static string ONS_REMOTE_TIMEOUT;
    protected internal static string ONS_MAXCONNECTIONS;
    protected internal static string ONS_ACTIVELIST;
    protected internal static string ONS_LIST_LOCAL_ID;
    protected internal static string ONS_LIST_DEFAULT_ID;
    protected internal static char ONS_CONFIG_SEPARATOR;
    public static string ONS_PERM_STRING;
    public static int ONS_ORACLE_HOME;
    public static int ONS_CONFIG_FILE;
    public static int ONS_ORACLE_INSTANCE;
    public static int ONS_PROTOCOL_VERSION;
    private static string SYSPROP_ORACLEHOME;
    private static string SYSPROP_ORACLECONFIGHOME;
    private static string SYSPROP_ORACLEINSTANCE;
    private static string SYSPROP_MAXCONNECTIONS;
    private static string SYSPROP_ACTIVELIST;
    private static string SYSPROP_SHUTDOWNTIMEOUT;
    private static string SYSPROP_IGNORESCANVIP;
    private static string SYSPROP_NODES;
    private static string SYSPROP_REMOTETIMEOUT;
    private static string SYSPROP_WALLETFILE;
    private static string SYSPROP_WALLETPASSW;
    private static string SYSPROP_DEBUG;
    private string HostName { get; }
    public ONS(string config);
    private static ONS();
    private string get_HostName();
    private void scanNodeLists(string config);
    private void configNodeLists(string config);
    private void addNodeList(string id, string nodes, int concurrency, bool active);
    protected internal virtual bool nodeListFailOver(NodeList caller, int cIndex);
    protected internal virtual void nodeListFallBack(NodeList caller, int cIndex);
    private string getMyProperty(string pKey);
    private string getConfig(string pKey, bool pSys, string cKey, string config);
    private string getValue(string config, string key);
    private void onsInit();
    protected internal virtual void addSubscriber(Subscriber s, long timeout);
    protected internal virtual void removeSubscriber(int id);
    protected internal virtual Subscriber lookupSubscriber(int id);
    private void closeSubscribers();
    protected internal virtual void addPublisher(Publisher p);
    protected internal virtual void removePublisher(Publisher p);
    public virtual void shutdown(long timeout);
    public virtual void shutdown();
    protected internal virtual string processId();
    protected internal virtual void deliver(Notification e);
    protected internal virtual void handleSubscriptionReply(int sid, bool success, string message);
    protected internal virtual void resendSubscriptions(SenderThread st);
    public virtual Subscriber createNewSubscriber(string s, string c, long timeout);
}
internal class OracleInternal.NotificationServices.ONSException : SystemException {
    protected internal ONSException(string s);
    protected ONSException(SerializationInfo info, StreamingContext context);
}
internal class OracleInternal.NotificationServices.ONSTcpClient : object {
    protected Stream sockStream;
    private Socket sock;
    internal ONSTcpClient(Socket sock, Stream sockStream);
    internal Stream GetStream();
    internal void Close();
}
internal class OracleInternal.NotificationServices.OutputBuffer : object {
    private static int BUFFERSIZE;
    private Stream ostr;
    private SByte[] buffer;
    private int spaceleft;
    private int position;
    internal int m_serverVersion;
    protected internal OutputBuffer(Stream o, int serverVersion);
    protected internal virtual void putBytes(SByte[] b, int len);
    protected internal virtual void putString(string s);
    protected internal virtual void putByte(sbyte b);
    protected internal virtual void flush();
}
internal class OracleInternal.NotificationServices.PropertyElement : object {
    protected internal string name;
    protected internal string value_Renamed;
    protected internal PropertyElement next;
    protected internal PropertyElement(string n, string v);
}
internal class OracleInternal.NotificationServices.PropertyList : object {
    internal PropertyElement head;
    internal int numelems;
    internal PropertyList(int n, InputBuffer ibuf);
    protected internal virtual void put(string name, string value_Renamed);
    internal virtual void write(OutputBuffer obuf);
    internal virtual int num();
}
internal class OracleInternal.NotificationServices.Publisher : object {
    private int id_Renamed_Field;
    private ONS oems;
    public Publisher(ONS o, string c);
    private void realStartup(string c);
    public virtual void close();
    protected internal virtual void id(int i);
}
internal class OracleInternal.NotificationServices.QueueElement : object {
    public object obj;
    public QueueElement next;
    public int priority;
    public QueueElement(object o);
    public QueueElement(object o, int p);
}
internal class OracleInternal.NotificationServices.ReceiverThread : ThreadClass {
    private ONS oems;
    private NodeList nodeList;
    private Connection connection;
    private object lock_Renamed;
    private bool shutdown_Renamed_Field;
    private ONSTcpClient s;
    private string id_Renamed_Field;
    private static SByte[] connectmessage3;
    private static SByte[] connectmessage;
    private static SByte[] connectmessage6;
    private static SByte[] selfid;
    private static SByte[] endconnect;
    protected internal ReceiverThread(NodeList list, Connection co);
    private static ReceiverThread();
    private bool establishConnection(bool first);
    public virtual void Run();
    internal bool ConnectionTimeoutError(Exception ex);
    protected internal virtual void shutdown();
    private bool readStatusMessage(InputBuffer ibuf);
    private Notification readNotificationMessage(InputBuffer ibuf);
}
internal class OracleInternal.NotificationServices.SendElement : object {
    protected internal Notification e;
    protected internal SubscriptionNotification s;
    protected internal SendElement(Notification ev);
    protected internal SendElement(SubscriptionNotification se);
}
internal class OracleInternal.NotificationServices.SenderThread : ThreadClass {
    private ONS oems;
    private NodeList nodeList;
    private Connection connection;
    private bool shutdown_Renamed_Field;
    private bool quiescent_Renamed_Field;
    private bool waitQ;
    private NotificationQueue q;
    private string id_Renamed_Field;
    private object lock_Renamed;
    protected internal SenderThread(NodeList list, Connection co);
    public virtual void Run();
    private void runRemote();
    protected internal virtual void send(SubscriptionNotification e);
    protected internal virtual void send(SubscriptionNotification e, int p);
    protected internal virtual void shutdown();
    protected internal virtual void quiescent(bool status);
    protected internal virtual void wakeThread();
    protected internal virtual void flushSenderQueue();
}
internal class OracleInternal.NotificationServices.Subscriber : object {
    private string subscription_Renamed_Field;
    private string component_Renamed_Field;
    private Publisher pub;
    private ONS oems;
    private int id_Renamed_Field;
    protected internal NotificationQueue queue;
    private CallBack cb;
    private int cbmode;
    private object cblock;
    private int numcbthreads;
    public static int CBMODE_ONETHREAD;
    public static int CBMODE_THREADPERCB;
    unknown int ID {protected internal set; }
    internal Subscriber(ONS o, string s, string c, long timeout);
    protected internal virtual void set_ID(int value);
    private void realStartup(string s, string c, long timeout);
    public virtual Notification receive(bool blocking);
    public virtual void close();
    public virtual string subscription();
    public virtual int id();
    protected internal virtual void deliver(Notification n);
    public virtual void cancel_callback();
}
internal class OracleInternal.NotificationServices.SubscriptionException : SystemException {
    protected internal SubscriptionException(string s);
    protected SubscriptionException(SerializationInfo info, StreamingContext context);
}
internal class OracleInternal.NotificationServices.SubscriptionNotification : object {
    protected internal int subsid;
    protected internal string subscription;
    protected internal object lock_Renamed;
    protected internal bool waiter;
    protected internal SubscriptionException ex;
    protected internal bool success;
    private bool replyrecvd;
    private static SByte[] subsmessageline;
    private static SByte[] subsidheader;
    private static SByte[] subsheader;
    private static SByte[] contentlengthline;
    protected internal SubscriptionNotification(int sid, string subs, bool w);
    private static SubscriptionNotification();
    protected internal virtual void waitForReply(long timeout);
    protected internal virtual void wakeup(bool s, SubscriptionException sexcept);
    protected internal virtual void send(OutputBuffer obuf);
}
internal class OracleInternal.NotificationServices.SupportClass : object {
    public static Byte[] ToByteArray(SByte[] sbyteArray);
    public static Byte[] ToByteArray(string sourceString);
    public static SByte[] ToSByteArray(Byte[] byteArray);
}
internal class OracleInternal.Secure.Encryption.PBKDF2Impl : object {
    private HMAC a;
    private Byte[] b;
    private int c;
    private int d;
    private UInt32 e;
    private Byte[] f;
    private int g;
    private int h;
    private string i;
    internal PBKDF2Impl(HMAC A_0, Byte[] A_1, int A_2);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal void b();
    internal Byte[] GetBytes(int cb);
    private Byte[] a();
    private static Byte[] a(UInt32 A_0);
}
internal class OracleInternal.Secure.Encryption.WorkBench : object {
    private static Byte[] a;
    private static Int32[] b;
    private static Int32[] c;
    private static int d;
    private static int e;
    private string f;
    private static WorkBench();
    internal static Byte[] a();
    internal Byte[] NormO(string user, string password, bool bServerMultiByte);
    internal Byte[] b(string A_0, Char[] A_1, int A_2, int A_3, bool A_4);
    private Byte[] a(Byte[] A_0);
    private Byte[] a(Byte[] A_0, Byte[] A_1);
    internal Byte[] b(Byte[] A_0, Byte[] A_1);
    private Byte[] a(string A_0, Char[] A_1, int A_2, int A_3, bool A_4);
    private Byte[] a(string A_0, string A_1, bool A_2);
    internal Byte[] c(Byte[] A_0, Byte[] A_1);
    private int a(Char[] A_0, int A_1, int A_2, Byte[] A_3, int A_4, bool A_5);
    private int a(string A_0, Byte[] A_1, int A_2, bool A_3);
    private int a(Int32[] A_0, char A_1);
}
internal class OracleInternal.Secure.Logon.O5LogonHelper : object {
    private static byte a;
    private static byte b;
    private static int c;
    private static int d;
    private static string e;
    private static Byte[] f;
    private static byte g;
    private static byte h;
    private static long i;
    private static long j;
    private static long k;
    private static long l;
    private static long m;
    private static long n;
    private static long o;
    private static long p;
    internal static int q;
    internal static int r;
    internal static int s;
    internal static int t;
    internal static int u;
    internal static int v;
    internal static Byte[] w;
    private string x;
    private static O5LogonHelper();
    internal static bool DoLogonProcessing(Conv dbCharSetConv, int verifierType, Byte[] salt, byte logonCompatibility, string noQuotesUser, SecureString securePassword, Byte[] encryptedSK, Byte[] pbkdf2_csk_salt, int pbkdf2_vgen_count, int auth_pbkdf2_sder_count, bool bSvrCSMultibyte, Byte[]& encryptedKB, Byte[]& encryptedPassword, Byte[]& newKey, Byte[]& confounder, Byte[]& pbkdf2_speedy_key);
    internal static void ProcessNewPassword(Conv dbCharSetConv, string pwdEncStr, SecureString secureNewPassword, Byte[] encKey, Byte[]& password, Byte[]& confounder);
    internal static Byte[] EvaluateServerResponse(string cipherStr, Byte[] key, Byte[] msgHex);
    internal static Byte[] EncryptOraAuthJDWPValue(bool bExternalAuthentication, ushort serverOne, Byte[] key, Byte[] valueToEncrypt);
    private static bool a(Conv A_0, int A_1, Byte[] A_2, byte A_3, string A_4, SecureString A_5, Byte[] A_6, Byte[] A_7, int A_8, int A_9, bool A_10, Byte[]& A_11, Byte[]& A_12, Byte[]& A_13, Byte[]& A_14, Byte[]& A_15);
    private static Byte[] a(int A_0, Byte[] A_1, int A_2, Byte[] A_3, int A_4, Byte[] A_5, int A_6, byte A_7);
    private static Byte[] b(string A_0, Byte[] A_1, Byte[] A_2);
    private static Byte[] a(string A_0, Byte[] A_1, Byte[] A_2);
    private static void a(Conv A_0, string A_1, SecureString A_2, Byte[] A_3, Byte[]& A_4, Byte[]& A_5);
    internal static string b(string A_0);
    private static Byte[] a(bool A_0, ushort A_1, Byte[] A_2, Byte[] A_3);
    private static byte a(byte A_0);
    private static void a(Byte[] A_0, Byte[] A_1, int A_2);
    private static Byte[] a(string A_0);
    private static string a(Byte[] A_0);
}
internal class OracleInternal.Secure.Network.AES : EncryptionAlgorithm {
    internal static int a;
    internal static int b;
    internal static int c;
    internal static int d;
    internal static int AES_128;
    internal static int AES_192;
    internal static int AES_256;
    internal static int MODE_CBC;
    internal static int e;
    protected internal static byte f;
    protected internal static byte g;
    internal int h;
    internal int i;
    internal static byte j;
    internal static int k;
    internal static int l;
    internal bool m;
    internal bool n;
    internal int o;
    internal int p;
    private a q;
    private a r;
    private a s;
    internal bool t;
    internal Byte[] u;
    internal Byte[] v;
    internal Byte[] w;
    internal static Byte[] x;
    internal static Byte[] y;
    internal static UInt32[] z;
    internal static UInt32[] aa;
    internal static UInt32[] ab;
    internal static UInt32[] ac;
    private static UInt32[] ad;
    private static UInt32[] ae;
    private static UInt32[] af;
    private static UInt32[] ag;
    private static UInt32[] ah;
    private static UInt32[] ai;
    private static UInt32[] aj;
    private static UInt32[] ak;
    private static Byte[] al;
    private static Byte[] am;
    private string an;
    public AES(int A_0, int A_1, bool A_2);
    public AES(int A_0, int A_1, int A_2, Byte[] A_3, Byte[] A_4, bool A_5);
    private static AES();
    public virtual void init(Byte[] key, Byte[] _iv);
    public void renewKey();
    public virtual void setSessionKey(Byte[] key, Byte[] iv);
    public virtual Byte[] decrypt(Byte[] ebuffer);
    public virtual Byte[] decrypt(Byte[] ebuffer, int length);
    public virtual Byte[] encrypt(Byte[] buffer);
    public virtual Byte[] encrypt(Byte[] buffer, int length);
    public Byte[] a(Byte[] A_0, byte A_1);
    public virtual int maxDelta();
    private static void a(Byte[][] A_0, int A_1, UInt32 A_2);
    private static UInt32 a(Byte[][] A_0, int A_1);
    private static UInt32 a(Byte[] A_0, int A_1);
    private static UInt32 a(UInt32 A_0, int A_1);
    private static void i();
    private static void h();
    private static void g();
    private static void f();
    private static void e();
    private static void d();
    private static void c();
    private static void b();
    private static void a();
}
public abstract class OracleInternal.Secure.Network.DataIntegrityAlgorithm : object {
    private static int a;
    private static int b;
    private AES c;
    private RC4 d;
    private bool e;
    private Byte[] f;
    private Byte[] g;
    private string h;
    internal g i;
    internal bool j;
    unknown string k;
    private static DataIntegrityAlgorithm();
    public void init(Byte[] k, Byte[] iv, string a, bool uo);
    private void a(Byte[] A_0, Byte[] A_1, string A_2, bool A_3);
    public bool compare(Byte[] b, int l, Byte[] xs, int off);
    private bool a(Byte[] A_0, int A_1, Byte[] A_2, int A_3);
    public Byte[] compute(Byte[] s, int off, int l);
    private Byte[] a(Byte[] A_0, int A_1, int A_2);
    public int takeSessionKey(Byte[] key, Byte[] iv);
    public void renew();
    public int size();
}
public class OracleInternal.Secure.Network.DES112 : DES168 {
    unknown string a;
    public virtual void init(Byte[] key, Byte[] iv);
    public virtual void setSessionKey(Byte[] key, Byte[] iv);
}
public class OracleInternal.Secure.Network.DES168 : EncryptionAlgorithm {
    internal static int a;
    internal static int b;
    internal static int c;
    internal static byte d;
    internal static byte e;
    internal Byte[] f;
    internal Byte[] g;
    internal Byte[] h;
    private UInt32[] i;
    private UInt32[] j;
    private UInt32[] k;
    private UInt32[] l;
    private UInt32[] m;
    private UInt32[] n;
    private Byte[] o;
    internal bool p;
    private static Int16[] q;
    private static UInt32[] r;
    private static UInt32[] s;
    private static Byte[] t;
    private static Byte[] u;
    private static Byte[] v;
    private static Byte[] w;
    private static UInt32[] x;
    private static UInt32[] y;
    private static UInt32[] z;
    private static UInt32[] aa;
    private static UInt32[] ab;
    private static UInt32[] ac;
    private static UInt32[] ad;
    private static UInt32[] ae;
    unknown string af;
    private static DES168();
    public virtual void init(Byte[] key, Byte[] iv);
    public virtual void setSessionKey(Byte[] key, Byte[] iv);
    public virtual Byte[] decrypt(Byte[] ebuffer);
    public virtual Byte[] decrypt(Byte[] ebuffer, int length);
    public virtual Byte[] encrypt(Byte[] buffer);
    public virtual Byte[] encrypt(Byte[] buffer, int len);
    public virtual int maxDelta();
    internal void a(Byte[] A_0, Byte[] A_1, Byte[] A_2, byte A_3);
    internal UInt32[] b(Byte[] A_0, byte A_1);
    private UInt32[] a(UInt32[] A_0);
    private Byte[] a(Byte[] A_0, byte A_1);
    internal void a(Byte[] A_0, Byte[] A_1, Byte[] A_2, int A_3);
    internal void a(Byte[] A_0, UInt32[] A_1);
    internal void b(Byte[] A_0, UInt32[] A_1);
    internal void a(UInt32[] A_0, Byte[] A_1);
    internal void a(UInt32[] A_0, UInt32[] A_1);
}
internal class OracleInternal.Secure.Network.DiffieHellman : object {
    private static int a;
    private Byte[] b;
    private int c;
    private Byte[] d;
    private int e;
    private Byte[] f;
    private Byte[] g;
    private ushort h;
    private ushort i;
    private UInt16[] j;
    private UInt16[] k;
    private Byte[] l;
    private int m;
    private int n;
    private int o;
    private Byte[] p;
    private static UInt16[] q;
    private static UInt16[] r;
    private static UInt16[] s;
    private static UInt16[] t;
    private static Byte[] u;
    private static Byte[] v;
    private static Byte[] w;
    private static Byte[] x;
    private static Byte[][] y;
    private static Byte[][] z;
    private string aa;
    private DiffieHellman(int A_0);
    public DiffieHellman(Byte[] A_0, Byte[] A_1, int A_2);
    public DiffieHellman(Byte[] A_0, Byte[] A_1, ushort A_2, ushort A_3);
    private static DiffieHellman();
    private void a(Byte[] A_0, Byte[] A_1, int A_2);
    public Byte[] getPublicKey();
    public Byte[] getSessionKey(Byte[] pkey_data, int pkey_size);
    private void b(Byte[] A_0, int A_1);
    private void a(int A_0);
    private void a();
    private void a(Byte[] A_0, int A_1);
}
public abstract class OracleInternal.Secure.Network.EncryptionAlgorithm : object {
    internal static int NAE_40_KEY_SIZE_BITS;
    internal static int NAE_56_KEY_SIZE_BITS;
    internal static int NAE_128_KEY_SIZE_BITS;
    internal static int NAE_256_KEY_SIZE_BITS;
    internal static int NAE_CBC_0;
    internal static int NAE_CBC_8;
    internal static int NAE_RAW_0;
    internal static int NAE_RAW_8;
    internal static int a;
    internal static int RC4_40;
    internal static int RC4_56;
    internal static int RC4_128;
    internal static int RC4_256;
    internal static int DES_40_RAW_0;
    internal static int DES_56_RAW_0;
    internal static int DES_40_RAW_8;
    internal static int DES_56_RAW_8;
    internal static int DES_40_CBC_0;
    internal static int DES_56_CBC_0;
    internal static int DES_40_CBC_8;
    internal static int DES_56_CBC_8;
    unknown string b;
    public abstract virtual void init(Byte[] key, Byte[] iv);
    public abstract virtual Byte[] decrypt(Byte[] ebuf);
    public abstract virtual Byte[] decrypt(Byte[] ebuf, int length);
    public abstract virtual Byte[] encrypt(Byte[] buffer);
    public abstract virtual Byte[] encrypt(Byte[] buffer, int length);
    public abstract virtual int maxDelta();
    public abstract virtual void setSessionKey(Byte[] key, Byte[] iv);
}
public class OracleInternal.Secure.Network.MD5 : DataIntegrityAlgorithm {
    unknown string a;
}
internal class OracleInternal.Secure.Network.RC4 : EncryptionAlgorithm {
    private static byte a;
    private static byte b;
    private static int c;
    private static int d;
    private static int e;
    private static int f;
    internal bool g;
    private a h;
    private a i;
    private a j;
    private bool k;
    private bool l;
    private int m;
    private string n;
    public RC4(bool A_0, int A_1);
    public RC4(int A_0, Byte[] A_1, Byte[] A_2);
    public RC4(int A_0, Byte[] A_1, Byte[] A_2, bool A_3, bool A_4);
    public virtual void init(Byte[] key, Byte[] iv);
    public virtual Byte[] decrypt(Byte[] ciphertext);
    public virtual Byte[] decrypt(Byte[] buffer, int length);
    public virtual Byte[] encrypt(Byte[] buffer, int length);
    public virtual Byte[] encrypt(Byte[] plaintext);
    public virtual int maxDelta();
    public virtual void setSessionKey(Byte[] key, Byte[] iv);
    internal void a();
}
public class OracleInternal.Secure.Network.SHA1 : DataIntegrityAlgorithm {
    unknown string a;
}
public class OracleInternal.Secure.Network.SHA256 : DataIntegrityAlgorithm {
    unknown string a;
    internal static string b(string A_0, int A_1);
}
public class OracleInternal.Secure.Network.SHA384 : DataIntegrityAlgorithm {
    unknown string a;
}
public class OracleInternal.Secure.Network.SHA512 : DataIntegrityAlgorithm {
    unknown string a;
}
internal class OracleInternal.Secure.Network.WalletReader : object {
    internal static Byte[] a;
    internal static Byte[] b;
    internal static Byte[] c;
    internal static int d;
    internal static int e;
    internal static int f;
    internal static int g;
    internal static byte h;
    internal static byte i;
    internal static int j;
    internal static int k;
    internal static int l;
    internal static int m;
    internal static Byte[] n;
    internal static int o;
    internal static int p;
    internal static int q;
    internal static int r;
    internal static int s;
    internal static Byte[] t;
    private string u;
    private static WalletReader();
    internal static Byte[] ReadWallet(string WD, String& WP);
    private static Byte[] a(Byte[] A_0, String& A_1);
    internal static Byte[] ReadWallet(Byte[] AllData, String& WP);
    internal static Byte[] a(string A_0, String& A_1);
    internal static Byte[] a(string A_0);
    internal static bool CompareX509(object C1, object C2);
    internal static bool a(X509Certificate2 A_0, X509Certificate2 A_1);
}
internal static class OracleInternal.ServiceObjects.ACConstants : object {
    internal static string RECONNECT_DELAY_PROPERTY;
    internal static string RECONNECT_RETRIES_PROPERTY;
    internal static string FAILOVER_TYPE_PROPERTY;
    internal static int FAILOVER_TYPE_SESSION;
    internal static int FAILOVER_TYPE_SELECT;
    internal static int FAILOVER_TYPE_TRANSACTION;
    internal static int FAILOVER_TYPE_AUTO;
    internal static int SESSION_STATE_CONSISTENCY_STATIC;
    internal static string SESSION_STATE_PROPERTY;
    internal static string FAILOVER_RESTORE_PROPERTY;
    internal static int FAILOVER_RESTORE_NONE;
    internal static int FAILOVER_RESTORE_LEVEL1;
    internal static int FAILOVER_RESTORE_AUTO;
    internal static int FAILOVER_RESTORE_LEVEL2;
    internal static string INITIATION_TIMEOUT_PROPERTY;
    private static ACConstants();
}
internal class OracleInternal.ServiceObjects.AdapterFillState : object {
    internal DataSet m_DSToFill;
    internal DataTable[] m_DTArrayToFill;
    internal DataTable m_DTToFill;
    internal Dictionary`2<int, List`1<List`1<GetPSCallsState>>> m_rsVsRead;
    internal List`1<List`1<GetPSCallsState>> m_readCalls;
    internal int m_currentRSIndexInOriginalCall;
    internal int m_currentRSIndexInReplay;
    internal long m_numReadsOnCurrentRS;
    internal short m_numNextResultCalls;
    internal DataTableMappingCollection m_dtMappingColl;
    internal bool m_bSkipsDoneInReplay;
}
internal class OracleInternal.ServiceObjects.AQNotificationDetails : object {
    internal string registrationString;
    internal int nameSpace;
    internal Byte[] payload;
    internal string queueName;
    internal Byte[] messageId;
    internal Byte[][] grpMsgId;
    internal string consumerName;
    internal string queueWithSchemaName;
    internal OracleAQMessage msgProp;
    internal bool isReady;
    internal short databaseVersion;
    internal Byte[] m_notificationInfoBuffer;
    internal short m_csId;
    internal Conv m_dbCharSetConv;
    internal bool m_bCanUseSecureCQN;
    internal OracleNotificationType m_type;
    internal OracleNotificationSource m_source;
    internal OracleNotificationInfo m_info;
    internal String[] m_resources;
    internal DataTable m_details;
    internal ByteBuffer m_byteBuffer;
    private ArrayList resourceNamesList;
    internal List`1<long> m_queryIdList;
    internal int m_regIdFromServer;
    internal OracleAQNotificationType m_notifType;
    internal AQNotificationDetails(short csId, Conv dbCharSetConv, int regIdFromServer, Byte[] notifInfo, bool bCanUseSecureCQN, OracleAQNotificationType notifType);
    internal void ParseNotificationInfo();
}
internal class OracleInternal.ServiceObjects.AsyncSynchronizerEvent : object {
    private static object lockObj;
    private static Task s_completed;
    private Queue`1<TaskCompletionSource`1<bool>> m_waits;
    private bool m_signaled;
    public AsyncSynchronizerEvent(bool value);
    private static AsyncSynchronizerEvent();
    public Task WaitAsync();
    public void Set();
    public void Reset();
    public bool IsSet();
}
internal class OracleInternal.ServiceObjects.CachedStatement : object {
    internal int m_cursorId;
    internal Accessor[] m_accessors;
    internal DataUnmarshaller m_dataUnmarshaller;
    internal Int64[] m_scnFromExecution;
    internal ArrayList m_placeHolderCollection;
    internal bool m_bBindParamPresent;
    internal long m_numRowsFetchArrayCanAccomodate;
    internal Accessor[] m_bindAccessors;
    internal ColumnDescribeInfo[] m_bindParamMetadata;
    internal bool m_bDisableCompressedFetch;
    internal ColumnDescribeInfo[] m_columnDefines;
    internal long m_internalInitialLOBFS;
    internal long m_clientInitialLOBFS;
    internal bool m_bDefinesDone;
    internal int m_longFetchSize;
    internal BindDirection[] m_bindDirections;
    internal bool m_bAllInBinds;
    internal bool m_bAllOutBinds;
    internal SQLMetaData statementdata;
    internal SQLInfo sqlInfo;
    internal bool m_bSqlIdFetched;
    internal string m_sqlIDFromDB;
    internal ulong m_lastUsedCount;
    internal bool m_hasExclusiveOwnershipOfCursorInfo;
    internal bool m_bIsPooled;
}
internal class OracleInternal.ServiceObjects.CallHistoryRecord : object {
    internal bool m_bAlreadyEnqueuedInQueue;
    internal WeakReference m_instanceWeakRef;
    internal object m_instanceWrapper;
    internal object m_resultWrapper;
    internal object m_clonedInstance;
    internal object m_methodInfo;
    internal Object[] m_args;
    internal Object[] m_clonedArgs;
    internal OracleParameterCollection m_listOfOriginalParameterObjects;
    internal Object[] m_parameterOriginalValues;
    internal int m_rowsToFetch;
    internal ColumnDescribeInfo[] m_columnDefines;
    internal IsolationLevel m_isolationLvl;
    internal WeakReference m_resultWeakRef;
    internal OracleClob m_clobForXmlTextReader;
    internal CallStatus m_callStatus;
    internal AdapterFillState m_adptFillState;
    internal AppContCtlCtx[] m_appContCtlCtx;
    internal bool m_serverAsksToEnqueue;
    internal Exception m_callException;
    internal ArrayList m_listOfDMLsForUpdate;
    internal object m_instance { get; internal set; }
    internal object m_result { get; internal set; }
    internal CallHistoryRecord(object instance, object clonedInstance, object method, Object[] args, CallStatus status);
    internal object get_m_instance();
    internal void set_m_instance(object value);
    internal object get_m_result();
    internal void set_m_result(object value);
}
internal enum OracleInternal.ServiceObjects.CallStatus : Enum {
    public int value__;
    public static CallStatus STARTED;
    public static CallStatus COMPLETE;
    public static CallStatus INCOMPLETE;
}
internal class OracleInternal.ServiceObjects.ClientInitiatedConnection : object {
    internal static int CIC_MAX_CONNECT_RETRIES;
    internal static int CIC_INCREMENTAL_DELAY;
    private OraclePoolManager m_opm;
    internal OracleConnectionImpl m_orclConnImpl;
    private TTCAQNotification m_aqNotif;
    private string m_listenerClientId;
    internal List`1<int> m_cqnRegistrations;
    internal bool m_bShutDown;
    internal ClientInitiatedConnection(string clientId, OraclePoolManager opm);
    private static ClientInitiatedConnection();
    internal void ReconnectCallback();
    internal void Reconnect(object state);
    internal void NotifyRegistrationEndToAll();
    internal void Connect();
    internal void ShutDownListener();
}
internal class OracleInternal.ServiceObjects.ConnectionCookie : object {
    internal string m_cookieKey;
    internal byte m_serverProtocol;
    internal Byte[] m_protocolServerString;
    internal short m_serverCharSet;
    internal byte m_serverFlags;
    internal short m_serverNCharSet;
    internal Byte[] m_serverCompiletimeCapabilities;
    internal Byte[] m_serverRuntimeCapabilities;
}
internal class OracleInternal.ServiceObjects.DataUnmarshaller : object {
    private static int TTCC_MXL;
    internal static int TTCC_ESC;
    internal static int TTCC_LNG;
    internal static int TTCC_ERR;
    internal static int TTCC_MXIN_NEW;
    internal static int TTCC_MXIN_OLD;
    internal int m_effectiveTTCC_MXIN;
    internal bool m_bUseBigCLRChunks;
    internal TTCTypeRepresentation m_typeRepresentation;
    private OraArraySegment m_currentSegment;
    internal int m_currentSegmentIndex;
    internal Byte[] m_currentSegmentArray;
    internal int m_positionInCurrentSegment;
    internal List`1<ArraySegment`1<byte>> m_dataSegments;
    internal long m_DataLeftInCurrentSegment;
    internal bool m_bAccumulateByteSegments;
    internal Int32[] m_colDataStartOffset;
    internal Int32[] m_indexOfOASArray;
    internal OraArraySegment[] m_oraArrSegWithColRowInfo;
    internal int m_oraArrSegCount;
    internal int m_oraArrSegWithColRowInfoIndex;
    internal int m_bFirstNonNullOraArrSegWithColInfoEntry;
    internal int m_indexOfLastOraArrSegUsed;
    internal OraColumnData[] m_duplicateDataStore;
    internal int m_columnCount;
    internal Char[] m_charArrayForConversion;
    internal Char[] m_charArrayForBigDataConversion;
    internal DataUnmarshaller(MarshallingEngine mEngine);
    internal Char[] GetCharArrayForConversion(long numBytesFetched, Conv conversion);
    internal short UnmarshalUB1();
    internal int UnmarshalUB2();
    internal long UnmarshalUB4();
    internal int UnmarshalSB4();
    internal long UnmarshalSB8();
    private long BufferToValue(byte repOffset);
    internal void UnmarshalCLR_ScanOnly(int maxSize, Int32& length);
    internal void UnmarshalCLR(int maxSize, Byte[] buffer, Int32& length);
    internal int UnmarshalBuffer_ScanOnly(int len);
    internal int UnmarshalBuffer(Byte[] buffer, int offset, int len);
    internal bool EscapeSequenceNull(int bytes);
    internal int Read(Byte[] userBuffer, int offset, int length);
    internal bool ReadLengthAndData(byte repOffset, byte typeRep, Byte[]& dataBuffer, Int32& offset, Int32& bufLength);
    private void MoveToNextArraySegment();
    internal int GetData(Byte[] userBuffer, int offset, int length);
    internal bool DuplicateDataExistsForLastRow(int colIndex);
    internal void SaveAllDuplicateColumnsFromLastRow(TTCRowData rowData, Accessor[] accessors, int noOfRowsFetchedLastTime);
    internal bool NextRowHasDuplicateData(int currentRow, int columnIndex);
    internal void SaveColumnData(int currentRow, int columnIndex, Byte[] rawData, object netTypeData, bool bCopyRawData);
    internal bool TryGetValueIfDuplicate(int currentRow, int columnIndex, OraColumnData& oraColData);
    internal bool TryGetValueIfDuplicateInDataSet(int currentRow, int columnIndex, DataTable table, string columnName, Object& oraColData);
    internal void StartAccumulatingColumnData(int currentRow, int columnIndex, List`1<ArraySegment`1<byte>> rowDataSegments);
    internal void StopAccumulatingColumnData();
    internal static void ReleaseAllOBs(OraArraySegment[] oasArray, int arrLength, OracleCommunication orclComm, bool bPipeliningEnabled);
    internal void TryOraBufRelease(int currRowNum, OracleCommunication orclComm, bool bPipeliningEnabled);
}
internal class OracleInternal.ServiceObjects.DBServiceProperties : object {
    internal Nullable`1<OracleFailoverTypeInternal> m_failoverType;
    internal OracleFailoverRestoreInternal m_failoverRestore;
    internal OracleFailoverMethod m_failoverMethod;
    internal bool m_bACEnabled;
    internal bool m_bTAFEnabled;
    internal int m_reconnectDelay;
    internal int m_reconnectRetries;
    internal bool m_bAutoACEnabled;
    internal bool m_bTransactionReplayEnabled;
    internal bool m_bReplayInDynamicMode;
    internal int m_replayInitiationTimeout;
    internal string m_strACPropValues;
}
internal class OracleInternal.ServiceObjects.DirectPathContext : object {
    internal long m_tableCursor;
    internal long m_sDBAOfBits;
    internal long m_sDBABits;
    internal long m_DBABits;
    internal ColumnDescribeInfo[] m_columnsMetaData;
}
internal class OracleInternal.ServiceObjects.DotNetXmlImpl : object {
    internal static string ConvertXmlReaderToString(XmlReader reader);
    internal static string ConvertXmlDocToString(XmlDocument xmlDoc);
    internal static string GetRootElement(XmlDocument xmlDoc);
    internal static string Extract(XmlDocument xmlDoc, string xpathExpr, string nsMap);
    internal static string Extract(XmlDocument xmlDoc, string xpathExpr, XmlNamespaceManager nsMgr);
    internal static bool IsExists(XmlDocument xmlDoc, string xpathExpr, XmlNamespaceManager nsMgr);
    internal static bool IsExists(XmlDocument xmlDoc, string xpathExpr, string nsMap);
    internal static string Transform(XmlReader xslReader, XmlDocument xmlDoc, string paramMap);
    internal static string Transform(OracleXmlType xslDoc, XmlDocument xmlDoc, string paramMap);
    internal static string Transform(string xslDoc, XmlDocument xmlDoc, string paramMap);
    internal static void Update(XmlDocument xmlDoc, string xpathExpr, XmlNamespaceManager nsMgr, string val, Boolean& bValueIsFragment);
    internal static void Update(XmlDocument xmlDoc, string xpathExpr, string nsMap, string val, Boolean& bValueIsFragment);
    internal static XmlDocument GetXmlDocument(XmlTypeReader xmlReader, string value, XmlDocumentFragment& xmlDocFragmentInternal, Boolean& bIsFragment, bool bThrowException);
    internal static string NsMgrToString(XmlNamespaceManager nsMgr);
    internal static XmlNamespaceManager StringToNsMgr(XmlNameTable nameTable, string nsMap);
}
internal class OracleInternal.ServiceObjects.DotNetXmlValidator : object {
    internal Exception m_validatingException;
    internal bool m_bHasError;
    internal XmlReaderSettings m_readerSettings;
    internal DotNetXmlValidator(string xslSchema);
    internal XmlReaderSettings CreateReaderValidationSettings(string xslSchema);
    internal bool Validate(XmlReader xmlReaderToValidate);
    private void ValidationEventHandler(object sender, ValidationEventArgs e);
}
internal class OracleInternal.ServiceObjects.GetPSCallsState : object {
    internal string m_fnName;
    internal int m_argValue;
    internal object m_returnedValue;
    internal GetPSCallsState(string fnName, int argValue, object returnValue);
}
internal class OracleInternal.ServiceObjects.InvokingInstanceWrapper : object {
    internal WeakReference m_invokingInstanceWeakRef;
    internal InvokingInstanceWrapper(object instance);
}
internal class OracleInternal.ServiceObjects.MTSTransactionImpl : object {
    internal static void Start(OracleConnectionImpl connImpl, OpoDTCTxnCtx opoTxnCtx, UInt32 timeout);
    internal static void Resume(OracleConnectionImpl connImpl, OpoDTCTxnCtx opoTxnCtx, UInt32 timeout);
    internal static void Promote(OracleConnectionImpl connImpl, OpoDTCTxnCtx opoTxnCtx, UInt32 timeout);
    internal static void Detach(OracleConnectionImpl connImpl, OpoDTCTxnCtx opoTxnCtx, UInt32 timeout);
    internal static TxnState Prepare(OracleConnectionImpl connImpl, OpoDTCTxnCtx opoTxnCtx, UInt32 timeout, bool bMatchConn);
    internal static TxnState Commit(OracleConnectionImpl connImpl, OpoDTCTxnCtx opoTxnCtx, UInt32 timeout, bool bMatchConn);
    internal static TxnState Abort(OracleConnectionImpl connImpl, OpoDTCTxnCtx opoTxnCtx, UInt32 timeout, bool bMatchConn);
}
internal class OracleInternal.ServiceObjects.NameSpace : object {
    internal string m_nameSpace;
    internal Dictionary`2<string, string> m_keyValues;
    internal bool m_bClear;
    internal NameSpace(string nameSpace);
    internal void Clear();
    internal void SetKeyValues(Dictionary`2<string, string> keyValues);
}
internal class OracleInternal.ServiceObjects.NotificationBufferManager : PoolManager`3<OraclePoolManager, OraclePool, OracleConnectionImpl> {
    private static int s_maxListCapacity;
    private static int s_maxOraBufPoolsInBuffer;
    public Hashtable m_htOfOraBufPools;
    internal object m_htSyncLock;
    private static NotificationBufferManager();
    public void GetNotificationOraBufPool(OracleCommunication orclCommunication);
    public void PutNotificationOraBufPool(OracleCommunication orclCommunication);
}
internal class OracleInternal.ServiceObjects.NotificationContext : object {
    internal long m_regIdFromServer;
    internal int m_payloadType;
    internal int m_payloadFlag;
    internal Byte[] m_payLoad;
    internal bool m_bLastNotification;
    internal NotificationHeader m_ntfHdr;
    internal NotificationMessageProperties m_ntfMsgProp;
    internal NotificationMessagePayload m_ntfMsgPayload;
    internal bool m_bAQEvent;
    internal Conv m_dbCharSetConv;
    internal OracleConnectionImpl m_orclConnImpl;
    internal static bool m_bStartedNotifPropogationThread;
    internal static object syncObject;
    internal static ConcurrentQueue`1<NotificationContext> m_lstOfNormalNotifs;
    internal static ConcurrentQueue`1<NotificationContext> m_lstOfTimeoutNotifs;
    internal static ManualResetEventSlim m_dataAvailableEvnt;
    internal static ManualResetEventSlim m_dataEnqueuedEvnt;
    internal NotificationContext(OracleConnectionImpl orclConnImpl, long regId, Conv dbCharSetConv, int payloadType, int payloadFlag, Byte[] payload, bool bLastNotification, NotificationHeader ntfHdr, NotificationMessageProperties ntfMsgProp, NotificationMessagePayload ntfMsgPayload);
    private static NotificationContext();
    internal static void EnqueueNotification(OracleConnectionImpl orclConnImpl, long regIdFromServer, Conv dbCharSetConv, int payloadType, int payloadFlag, Byte[] rawPayload, bool bLastNotification, NotificationHeader ntfHdr, NotificationMessageProperties ntfMsgProp, NotificationMessagePayload ntfMsgPayload);
    internal static void PropagateNotifications();
}
internal class OracleInternal.ServiceObjects.NotificationDetails : object {
    private static byte TBL_OPCODE_ALLROWS;
    private static byte TBL_OPCODE_ALLOPS;
    private static byte TBL_OPCODE_INSERT;
    private static byte TBL_OPCODE_UPDATE;
    private static byte TBL_OPCODE_DELETE;
    private static byte TBL_OPCODE_ALTER;
    private static byte TBL_OPCODE_DROP;
    private static byte TBL_OPCODE_UNKNOWN;
    private Byte[] m_notificationInfoBuffer;
    private short m_csId;
    internal Conv m_dbCharSetConv;
    internal bool m_bCanUseSecureCQN;
    internal OracleNotificationType m_type;
    internal OracleNotificationSource m_source;
    internal OracleNotificationInfo m_info;
    internal String[] m_resources;
    internal DataTable m_details;
    internal ByteBuffer m_byteBuffer;
    private ArrayList resourceNamesList;
    internal List`1<long> m_queryIdList;
    internal int m_regIdFromServer;
    internal NotificationDetails(short csId, Conv dbCharSetConv, int regIdFromServer, Byte[] notifInfo, bool bCanUseSecureCQN);
    internal void ParseNotificationInfo();
    private void ReadQueryInfo(ArrayList resourceNamesList);
    internal void ReadTableInfo(long queryId, ArrayList resourceNamesList);
    internal void ReadRowInfo(long queryId, string tableName);
    internal void AddRowDetail(string name, OracleNotificationInfo info, string rowid, long queryid);
    internal void SetNotificationTypeSourceInfo(int notifId);
}
internal class OracleInternal.ServiceObjects.NotificationHandler : object {
    private static int NS_HEADER_SIZE;
    private static int INTERRUPT_SIGNAL;
    private static int NSPTCN;
    private static int NSPTDA;
    private int m_indexOfArraySegmentToBeRead;
    internal OracleCommunication m_dataEP;
    private ByteBuffer m_NSPacketDataBuffer;
    private ConcurrentQueue`1<OraBuf> m_lstOfOraBufs;
    private ConcurrentQueue`1<NotificationInfo> m_lstOfNormalNotifs;
    private ConcurrentQueue`1<NotificationInfo> m_lstOfTimeoutNotifs;
    private bool m_bNotifSendingThreadActive;
    private bool m_bNoDataAvailInNetwork;
    internal OraBuf m_currentOB;
    private OraArraySegment[] m_lstOfArraySegments;
    private int m_lstOfArraySegments_Count;
    private ManualResetEventSlim m_dataAvailableEvnt;
    private ManualResetEventSlim m_dataEnqueuedEvnt;
    internal static NotificationBufferManager m_bufMgr;
    internal NotificationHandler(OracleCommunication dataEndPoint);
    private static NotificationHandler();
    internal void ProcessBufferedNSDataPackets();
    private void SendProcessedNotifications();
    internal void ProcessNotification();
    internal void ReadFromNetwork();
    internal bool ReadFromBufferedData();
    internal void UnmarshalNSDataPacket();
    private byte ReadByte();
    private short ReadShort();
    private int ReadInt();
    private void ReadBuffer(Byte[] buff, int offset, int length);
    [CompilerGeneratedAttribute]
private void <UnmarshalNSDataPacket>b__24_0(object obj);
}
internal class OracleInternal.ServiceObjects.NotificationInfo : object {
    internal short m_csId;
    internal Int32[] m_regId;
    internal bool m_bTimeoutEvent;
    internal Byte[] m_notifInfo;
    internal int m_numOfRegistrations;
    internal bool m_bAQEvent;
    internal int m_nameSpace;
    internal int m_serverRegID;
    internal OracleAQNotificationType m_notifType;
    internal NotificationInfo(short csId, int numOfRegistrations, Int32[] regId, bool bTimeout, Byte[] notifInfo, int nameSpace, OracleAQNotificationType notifType, int serverRegID);
}
internal class OracleInternal.ServiceObjects.NotificationListener : object {
    internal bool m_bListenerStarted;
    private object m_syncObject;
    private Thread m_lsnrThread;
    internal OracleCommunication m_lsnrEP;
    private OraBufPool m_oraBufPoolForListener;
    internal static NotificationListener m_ntfLister;
    private static NotificationListener();
    internal static NotificationListener CreateListener();
    internal bool Start(Int32& portNo, object traceObj);
    internal void ListenerThreadFunction();
    internal static bool IsPortAvailable(int portNo, object traceObj);
    internal static int FindFreePort(object traceObj);
}
internal class OracleInternal.ServiceObjects.NotificationRegistrationDetails : object {
    internal string m_clientHost;
    internal string m_clientID;
    internal string m_subscriptionName;
    internal int m_clientTCPPort;
    internal bool m_isPurgeOnNTF;
    internal string m_username;
    internal int m_nameSpace;
    internal int m_jdbcRegId;
    internal string m_dbName;
    internal short m_databaseVersion;
    internal NotificationRegistrationDetails(int _jdbcRegId, int _namespace, bool _jdbcGetsNotification, string _dbName, string _clientHost, int _clientTCPPort, string _username, short _databaseVersion, string _subscriptionName, string _clientID);
    internal int GetNameSpace();
    internal int GetDatabaseVersion();
}
internal class OracleInternal.ServiceObjects.OracleAQQueueImpl : object {
    private OracleAQQueue m_aq;
    private OracleConnection m_conn;
    private OracleConnectionImpl m_connImpl;
    private TTCAQEnqueue m_ttcAqEnqueue;
    private TTCAQDequeue m_ttcAqDequeue;
    private TTCAQArray m_ttcAqArray;
    internal Byte[] m_udtValInBytes;
    internal Object[] m_saveUdtValue;
    internal OracleParameterImpl m_paramImpl;
    internal OracleAQQueueImpl(OracleAQQueue aq);
    internal void init();
    internal void Enqueue(string queueName, OracleAQEnqueueOptions enqueueOptions, OracleAQMessage messageProperties, Byte[] payloadTOID, bool isRawPayload);
    internal bool Dequeue(string queueName, OracleAQDequeueOptions dequeueOptions, OracleAQMessage messageProperties, Byte[] payloadTOID, bool isRawQueue, OracleAQMessageType messageType);
    internal int EnqueueArray(string queueName, OracleAQEnqueueOptions enqueueOptions, OracleAQMessage[] messageProperties, OracleAQMessageType messageType, Byte[] payloadTOID, bool isRawPayload);
    internal OracleAQMessage[] DequeueArray(string queueName, OracleAQDequeueOptions dequeueOptions, int size, Byte[] payloadTOID, bool isRawQueue, OracleAQMessageType messageType, string udtTypeName);
    internal static OracleAQAgent Listen(OracleConnection conn, OracleAQAgent[] agents, int waitTime);
    internal int GetUDTBytesFromCustomObject(OracleConnection conn, string udtTypeName, object udtPayLoad, Byte[]& toid);
    internal object GetCustomObjectFromUDTBytes(OracleConnection conn, string udtTypeName, Byte[] udtPayLoad);
    internal UDTNamedType GetUDTType(OracleConnection conn, string udtTypeName);
}
internal class OracleInternal.ServiceObjects.OracleBFileImpl : object {
    internal OracleConnectionImpl m_connectionImpl;
    internal Byte[] m_lobLocator;
    internal TTCBFile m_ttcBFile;
    internal AsyncSynchronizerEvent m_cancelExecutionEvent;
    internal AutoResetEvent m_continueCancel;
    internal long m_executionId;
    internal bool m_bFetching;
    internal object m_lockCancel;
    internal bool m_bAsyncCallInProgress;
    internal object TraceObj { get; }
    internal OracleBFileImpl(OracleConnectionImpl connImpl, Byte[] lobLocator);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBFileImpl/<GetLengthAsync>d__0")]
internal ValueTask`1<long> GetLengthAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBFileImpl/<ReadAsync>d__1")]
internal ValueTask`1<OBFRead_RefAndOutParamArgCtx> ReadAsync(long locatorOffset, long numBytesToRead, long outBufferOffset, OBFRead_RefAndOutParamArgCtx obfRead_refOutCtx, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBFileImpl/<CopyToAsync>d__2")]
internal ValueTask`1<long> CopyToAsync(Byte[] destLobLocator, long srcOffset, long dstOffset, long dataLen, bool bAsync, CallHistoryRecord currentCHR);
    internal object get_TraceObj();
    internal void Cancel(long cancelExecutionId);
    internal void SetDirFileName(string directoryName, string fileName);
    internal bool OpenFile(CallHistoryRecord currentCHR);
    internal bool CloseFile(CallHistoryRecord currentCHR, bool bNonRequestCall);
    internal bool FileExists(CallHistoryRecord currentCHR);
    internal long GetLength(CallHistoryRecord currentCHR, bool bAsync);
    internal OBFRead_RefAndOutParamArgCtx Read(long locatorOffset, long numBytesToRead, long outBufferOffset, OBFRead_RefAndOutParamArgCtx obfRead_refOutCtx, bool bAsync, CallHistoryRecord currentCHR);
    internal long CopyTo(Byte[] destLobLocator, long srcOffset, long dstOffset, long dataLen, bool bAsync, CallHistoryRecord currentCHR);
}
internal class OracleInternal.ServiceObjects.OracleBlobImpl : object {
    internal OracleConnectionImpl m_connectionImpl;
    internal Byte[] m_lobLocator;
    internal string m_lobId;
    internal TTCBlob m_ttcBlob;
    internal bool m_caching;
    internal int m_chunkSize;
    internal long m_totalLobSize;
    internal bool m_bDbVaryingWidth;
    internal short m_clobCharSet;
    internal byte m_clobFormOfUse;
    internal long m_lobDataLength;
    internal bool m_isTemporaryLob;
    internal bool m_doneTempLobCreate;
    internal bool m_isEmpty;
    internal Byte[] m_lobPrefetchData;
    private string m_id;
    internal int m_refCount;
    private object m_lock;
    internal AsyncSynchronizerEvent m_cancelExecutionEvent;
    internal AutoResetEvent m_continueCancel;
    internal long m_executionId;
    internal bool m_bFetching;
    internal object m_lockCancel;
    internal bool m_bAsyncCallInProgress;
    internal CallHistoryRecord m_callHistoryRecord;
    internal bool IsValueLob { get; }
    internal bool IsQuasiLobLocator { get; }
    internal object TraceObj { get; }
    internal OracleBlobImpl(OracleConnectionImpl connImpl, Byte[] lobLocator, bool bCaching);
    internal OracleBlobImpl(OracleConnectionImpl connImpl, Byte[] lobLocator);
    internal OracleBlobImpl(int currentRow, OracleConnectionImpl connImpl, TTCLobAccessor lobAccessor);
    internal OracleBlobImpl(OracleConnectionImpl connImpl, TTCLobAccessor lobAccessor, DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBlobImpl/<GetLengthAsync>d__0")]
internal ValueTask`1<long> GetLengthAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBlobImpl/<CreateTemporaryLobAsync>d__1")]
internal ValueTask CreateTemporaryLobAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBlobImpl/<GetCompleteBlobDataAsync>d__2")]
internal static ValueTask`1<OBGetCompleteBlobData_RefAndOutParamArgCtx> GetCompleteBlobDataAsync(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCLobAccessor lobAccessor, OBGetCompleteBlobData_RefAndOutParamArgCtx refOutCtx, bool bAsync, CallHistoryRecord chr);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBlobImpl/<ReadDataFromDBAsync>d__3")]
internal ValueTask`1<Byte[]> ReadDataFromDBAsync(long locatorOffset, long numBytesToRead, long outBufferOffset, Byte[] outBuffer, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBlobImpl/<ReadAsync>d__4")]
internal ValueTask`1<OBRead_RefAndOutParamArgCtx> ReadAsync(long locatorOffset, long numBytesToRead, long outBufferOffset, OBRead_RefAndOutParamArgCtx obRead_refOutCtx, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBlobImpl/<WriteAsync>d__5")]
internal ValueTask`1<long> WriteAsync(long locatorOffset, Byte[] inBuffer, long inBufferOffset, long numBytesToWrite, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleBlobImpl/<CopyToAsync>d__6")]
internal ValueTask`1<long> CopyToAsync(Byte[] destLobLocator, long srcOffset, long dstOffset, long dataLen, bool bAsync, CallHistoryRecord currentCHR);
    internal bool get_IsValueLob();
    internal bool get_IsQuasiLobLocator();
    internal object get_TraceObj();
    internal void Cancel(long cancelExecutionId);
    internal long SetLength(long newLength, CallHistoryRecord currentCHR);
    internal bool IsTemporaryLob();
    internal long GetChunkSize(CallHistoryRecord currentCHR);
    internal bool Open(CallHistoryRecord currentCHR);
    internal bool Close(CallHistoryRecord currentCHR);
    internal static long CopyBlobDataInBytes(int currentRow, OracleConnectionImpl connImpl, TTCLobAccessor lobAccessor, long locatorOffset, Byte[] outBuffer, int outBufferOffset, int numBytesToCopy);
    internal static Byte[] GetCompleteBlobData(int currentRow, TTCLobAccessor lobAccessor);
    internal long Erase(long locatorOffset, long numBytesToErase, CallHistoryRecord currentCHR);
    internal void Append(Byte[] srcLobLocator, CallHistoryRecord currentCHR);
    internal void AddRef();
    internal void RelRef();
    internal int GetRefCount();
    internal static bool IsTemporaryLob(Byte[] lobLocator);
    internal static Byte[] GetLobId(Byte[] lobLocator);
    internal static string GetLobIdString(Byte[] lobLocator);
    internal long GetLength(CallHistoryRecord currentCHR, bool bAsync);
    internal void CreateTemporaryLob(CallHistoryRecord currentCHR, bool bAsync);
    internal static OBGetCompleteBlobData_RefAndOutParamArgCtx GetCompleteBlobData(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCLobAccessor lobAccessor, OBGetCompleteBlobData_RefAndOutParamArgCtx refOutCtx, bool bAsync, CallHistoryRecord chr);
    internal Byte[] ReadDataFromDB(long locatorOffset, long numBytesToRead, long outBufferOffset, Byte[] outBuffer, bool bAsync, CallHistoryRecord currentCHR);
    internal OBRead_RefAndOutParamArgCtx Read(long locatorOffset, long numBytesToRead, long outBufferOffset, OBRead_RefAndOutParamArgCtx obRead_refOutCtx, bool bAsync, CallHistoryRecord currentCHR);
    internal long Write(long locatorOffset, Byte[] inBuffer, long inBufferOffset, long numBytesToWrite, bool bAsync, CallHistoryRecord currentCHR);
    internal long CopyTo(Byte[] destLobLocator, long srcOffset, long dstOffset, long dataLen, bool bAsync, CallHistoryRecord currentCHR);
}
internal class OracleInternal.ServiceObjects.OracleBulkCopyImpl : object {
    private OracleBulkCopy m_bulkCopy;
    private OracleConnectionImpl m_connImpl;
    private TTCDirectPathPrepare m_ttcDPPrepare;
    private TTCDirectPathLoadStream m_ttcDPLoadStream;
    private TTCDirectPathMOP m_ttcDPMOP;
    private DirectPathContext m_DPContext;
    private IBulkCopyDataSource m_dataSource;
    private OracleBulkCopyColumnMappingCollection m_internalColumnMappings;
    private string m_schemaName;
    private string m_tableName;
    private string m_partitionName;
    private int m_numOfRowsToNotify;
    private int m_totalNumOfRowsToBeCopied;
    private bool m_resetAutoCommit;
    private bool m_bAllFastColumns;
    private DirectPathStream m_stream;
    internal OracleBulkCopyImpl(OracleBulkCopy bulkCopy);
    internal static string ConvertToTTCDBObjName(string inputName);
    internal static string ConvertToDPDBObjName(string inputName);
    internal void Init(IBulkCopyDataSource dataSource, OracleBulkCopyColumnMappingCollection internalColumnMappings, string schemaName, string tableName, string partitionName);
    internal ColumnDescribeInfo[] Prepare();
    internal void LoadRows(BulkCopyRows rows);
    internal void LoadStream(DirectPathStream dpStream);
    internal BulkCopyResult ProcessBatch(int numOfRows);
    private int GetInternalBatchSize(int reqBatchSize);
    internal BulkCopyResult InternalProcessBatch(int numOfRows, bool bUseArray);
    internal void Commit();
    internal void Abort();
}
internal class OracleInternal.ServiceObjects.OracleChunkNotificationManager : OracleONSNotificationManager {
    internal OracleChunkNotificationManager(object traceObj);
    protected virtual string GetEventTypeForNotification(string eventTypeFromDb, string serviceName);
    protected virtual void HandleEvent(object notification);
    private static string StringArrayToString(String[] strArray);
}
internal class OracleInternal.ServiceObjects.OracleClobImpl : object {
    internal OracleConnectionImpl m_connectionImpl;
    internal Byte[] m_lobLocator;
    internal string m_lobId;
    internal TTCClob m_ttcClob;
    internal bool m_isNClob;
    internal bool m_bCache;
    internal int m_chunkSize;
    internal int m_optimumChunkSize;
    internal long m_totalLobSize;
    internal bool m_bDbVaryingWidth;
    internal short m_clobCharSet;
    internal byte m_clobFormOfUse;
    internal int m_lobDataLength;
    internal bool m_isTemporaryLob;
    internal bool m_doneTempLobCreate;
    internal bool m_isEmpty;
    internal Byte[] m_lobPrefetchData;
    private string m_id;
    internal int m_refCount;
    private object m_lock;
    internal AsyncSynchronizerEvent m_cancelExecutionEvent;
    internal AutoResetEvent m_continueCancel;
    internal long m_executionId;
    internal bool m_bFetching;
    internal object m_lockCancel;
    internal bool m_bAsyncCallInProgress;
    internal List`1<OraBuf> m_tempOBList;
    internal bool IsCompleteDataPrefetched { get; }
    internal bool IsValueLob { get; }
    internal bool IsQuasiLobLocator { get; }
    internal object TraceObj { get; }
    internal OracleClobImpl(OracleConnectionImpl connImpl, Byte[] lobLocator, bool bNClob, bool bCache);
    internal OracleClobImpl(OracleConnectionImpl connImpl, Byte[] lobLocator, bool bNClob);
    internal OracleClobImpl(int currentRow, OracleConnectionImpl connImpl, TTCLobAccessor lobAccessor);
    internal OracleClobImpl(OracleConnectionImpl connImpl, TTCLobAccessor lobAccessor, DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<GetLengthAsync>d__0")]
internal ValueTask`1<long> GetLengthAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<CreateTemporaryLobAsync>d__1")]
internal ValueTask CreateTemporaryLobAsync(CallHistoryRecord currentCHR, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<GetCompleteClobDataAsync>d__2")]
internal static ValueTask`1<OCGetCompleteClobData_RefAndOutParamArgCtx> GetCompleteClobDataAsync(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCLobAccessor lobAccessor, OCGetCompleteClobData_RefAndOutParamArgCtx refOutCtx, bool bAsync, CallHistoryRecord chr);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<ReadDataFromDBAsync>d__3")]
internal ValueTask ReadDataFromDBAsync(long locatorOffset, long numCharsToRead, List`1<ArraySegment`1<byte>> dataSegments, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<ReadAsync>d__4")]
internal ValueTask`1<OCReadChar_RefAndOutParamArgCtx> ReadAsync(long locatorOffset, long numCharsToRead, long outBufferOffset, OCReadChar_RefAndOutParamArgCtx ocReadChar_refOutCtx, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<ReadAsync>d__5")]
internal ValueTask`1<OCRead_RefAndOutParamArgCtx> ReadAsync(long position, long locatorOffset, long numChars, long outBufferOffset, OCRead_RefAndOutParamArgCtx ocRead_refOutCtx, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<WriteAsync>d__6")]
internal ValueTask`1<long> WriteAsync(long locatorOffset, bool bIsNClob, Byte[] inBuffer, int inBufferOffset, int numBytesToWrite, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<WriteAsync>d__7")]
internal ValueTask`1<long> WriteAsync(long locatorOffset, bool bIsNClob, Char[] inBuffer, long inBufferOffset, long numCharsToWrite, bool bAsync, CallHistoryRecord currentCHR);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleClobImpl/<CopyToAsync>d__8")]
internal ValueTask`1<long> CopyToAsync(Byte[] destLobLocator, long srcOffset, long dstOffset, long dataLen, bool bAsync, CallHistoryRecord currentCHR);
    internal bool get_IsCompleteDataPrefetched();
    internal bool get_IsValueLob();
    internal bool get_IsQuasiLobLocator();
    internal object get_TraceObj();
    internal void Cancel(long cancelExecutionId);
    internal long SetLength(long newLength, CallHistoryRecord currentCHR);
    internal bool Open(CallHistoryRecord currentCHR);
    internal bool Close(CallHistoryRecord currentCHR);
    internal bool IsTemporaryLob();
    internal long GetChunkSize(CallHistoryRecord currentCHR);
    internal static long GetClobDataInChars(int currentRow, OracleConnectionImpl connImpl, Byte[] lobLocator, TTCLobAccessor lobAccessor, long locatorOffset, Char[] outBuffer, int outBufferOffset, int numCharsToCopy);
    internal static string GetCompleteClobData(int currentRow, DataUnmarshaller dataUnmarshaller, OracleConnectionImpl connImpl, Byte[] lobLocator, TTCLobAccessor lobAccessor);
    internal int ConvertBytesToChars(Byte[] dataBuffer, int dataStartIdx, int numBytesToConvert, Char[] outBuffer, int outBufferOffset, bool bVariableWidthChar);
    internal long Erase(long locatorOffset, long numCharsToErase, CallHistoryRecord currentCHR);
    internal void Append(Byte[] srcLobLocator, CallHistoryRecord currentCHR);
    internal void AddRef();
    internal void RelRef();
    internal int GetRefCount();
    internal static bool IsTemporaryLob(Byte[] lobLocator);
    internal static Byte[] GetLobId(Byte[] lobLocator);
    internal static string GetLobIdString(Byte[] lobLocator);
    internal void SaveOBsWithParameterData();
    internal long GetLength(CallHistoryRecord currentCHR, bool bAsync);
    internal void CreateTemporaryLob(CallHistoryRecord currentCHR, bool bAsync);
    internal static OCGetCompleteClobData_RefAndOutParamArgCtx GetCompleteClobData(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCLobAccessor lobAccessor, OCGetCompleteClobData_RefAndOutParamArgCtx refOutCtx, bool bAsync, CallHistoryRecord chr);
    internal void ReadDataFromDB(long locatorOffset, long numCharsToRead, List`1<ArraySegment`1<byte>> dataSegments, bool bAsync, CallHistoryRecord currentCHR);
    internal OCReadChar_RefAndOutParamArgCtx Read(long locatorOffset, long numCharsToRead, long outBufferOffset, OCReadChar_RefAndOutParamArgCtx ocReadChar_refOutCtx, bool bAsync, CallHistoryRecord currentCHR);
    internal OCRead_RefAndOutParamArgCtx Read(long position, long locatorOffset, long numChars, long outBufferOffset, OCRead_RefAndOutParamArgCtx ocRead_refOutCtx, bool bAsync, CallHistoryRecord currentCHR);
    internal long Write(long locatorOffset, bool bIsNClob, Byte[] inBuffer, int inBufferOffset, int numBytesToWrite, bool bAsync, CallHistoryRecord currentCHR);
    internal long Write(long locatorOffset, bool bIsNClob, Char[] inBuffer, long inBufferOffset, long numCharsToWrite, bool bAsync, CallHistoryRecord currentCHR);
    internal long CopyTo(Byte[] destLobLocator, long srcOffset, long dstOffset, long dataLen, bool bAsync, CallHistoryRecord currentCHR);
}
internal class OracleInternal.ServiceObjects.OracleCommandImpl : object {
    private static string s_SendReExecuteRequest;
    private static string s_SendExecuteRequest;
    internal string m_commandText;
    internal string m_pooledCmdText;
    internal CommandType m_commandType;
    internal OracleDataReader m_cachedReader;
    internal bool m_cmdTxtModified;
    internal int m_rowsAffected;
    internal bool m_designTimeVisible;
    internal int m_commandTimeout;
    internal OracleParameterCollection m_parameters;
    internal bool m_modified;
    internal int m_initialLongFS;
    internal int m_clientInitialLOBFS;
    internal UpdateRowSource m_updatedRowSource;
    internal bool m_bExecuteInProgress;
    internal bool m_bAsyncCallInProgress;
    internal bool m_bInternalAsyncToAsyncCall;
    internal OracleNotificationRequest m_NTFNReq;
    internal bool m_NTFNAutoEnlist;
    internal OracleRefCursor[] m_implicitRefCursors;
    internal bool m_returnPSTypes;
    internal Type[] m_expectedColumnTypes;
    internal bool m_cmd_addRowId;
    internal bool m_cmd_addToStatementCache;
    internal int m_cmd_arrayBindCount;
    internal bool m_cmd_bBindByName;
    internal long m_cmd_fetchSize;
    internal OracleXmlCommandType m_xmlCommandType;
    internal OracleXmlQueryProperties m_xmlQueryProperties;
    internal OracleXmlSaveProperties m_xmlSaveProperties;
    internal WeakReference m_lastReaderWeakRef;
    private static int ROWS_TO_FETCH;
    internal SqlStatementType m_sqlStatementType;
    private Byte[] m_commandTextByteStream;
    internal SQLMetaData m_sqlMetaData;
    private int m_rowsToFetch;
    internal Accessor[] m_bindAccessors;
    internal BindDirection[] m_bindDirectionsFromServer;
    internal List`1<OraBuf> m_tempOBList;
    internal bool m_bHasReturningClause;
    internal long m_executionId;
    internal bool m_bServerExecutionComplete;
    internal object m_lockCancel;
    internal AutoResetEvent m_continueCancel;
    internal CancellationTokenSource m_cancelExecution;
    internal List`1<TTCResultSet> m_implicitRSList;
    internal int m_numReturningParams;
    internal long m_fetchSize;
    internal int m_arrayBindCount;
    internal bool m_bBindByName;
    internal bool m_bFetchSqlId;
    internal string m_sqlIDFromDB;
    internal Int64[] m_rowsAffectedPerBind;
    internal static int m_clientRegistrationId;
    internal OracleIntervalDS m_sessionTimeZone;
    internal bool m_addToStatementCache;
    internal bool m_addRowid;
    internal bool m_addRowidDoneImplicitly;
    internal bool m_foundExplicitRowidInSql;
    internal bool m_bPooled;
    internal bool m_bExecutingForFill;
    internal bool m_bReturnPSTypes;
    internal Nullable`1<bool> m_bNextCallIsNonRequest;
    internal bool m_bCheckImplicitRBOnClose;
    internal bool m_bNoPiggybackToBeSent;
    internal bool m_bExecutingAC_SPs;
    internal bool m_bAdapterUpdateStarted;
    internal CallHistoryRecord m_callHistoryRecord;
    internal CachedStatement m_cachedStmt;
    internal string m_cachedCmdTxt;
    internal OracleCommandImpl(bool bCreateCancelEvent);
    private static OracleCommandImpl();
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleCommandImpl/<ExecuteNonQueryAsync>d__0")]
internal ValueTask`1<ENQ_RefAndOutParamArgCtx> ExecuteNonQueryAsync(string commandText, OracleParameterCollection paramColl, CommandType commandType, OracleConnectionImpl connectionImpl, int longFetchSize, long clientInitialLOBFS, OracleDependencyImpl orclDependencyImpl, OracleConnection connection, ENQ_RefAndOutParamArgCtx enq_refOutArgCtx, bool isFromEF, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleCommandImpl/<ExecuteXmlQueryAsync>d__1")]
internal ValueTask`1<EXQ_RefAndOutParamArgCtx> ExecuteXmlQueryAsync(string commandText, OracleParameterCollection paramColl, CommandType commandType, OracleXmlCommandType xmlCommandType, OracleConnectionImpl connectionImpl, int longFetchSize, long clientInitialLOBFS, OracleDependencyImpl orclDependencyImpl, OracleConnection connection, EXQ_RefAndOutParamArgCtx exqRefOutArgs, bool isFromEF, bool wantResult, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleCommandImpl/<ExecuteXmlSaveAsync>d__2")]
internal ValueTask`1<EXS_RefAndOutParamArgCtx> ExecuteXmlSaveAsync(string commandText, OracleParameterCollection paramColl, CommandType commandType, OracleXmlCommandType xmlCommandType, OracleConnectionImpl connectionImpl, int longFetchSize, long clientInitialLOBFS, OracleDependencyImpl orclDependencyImpl, OracleConnection connection, EXS_RefAndOutParamArgCtx exsRefOutArgs, bool isFromEF, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleCommandImpl/<ExecuteReaderAsync>d__3")]
internal ValueTask`1<ER_RefAndOutParamArgCtx> ExecuteReaderAsync(string commandText, OracleParameterCollection paramColl, CommandType commandType, OracleConnectionImpl connectionImpl, int longFetchSize, long clientInitialLOBFS, OracleDependencyImpl orclDependencyImpl, Int64[] scnForExecution, long internalInitialJSONFS, OracleConnection connection, ER_RefAndOutParamArgCtx er_refOutCtx, bool isDescribeOnly, bool isFromEF, bool bAsync);
    internal OracleCommandImpl DeepCloneForReplay();
    private void InitMigratedFieldsToDefault();
    internal void Init();
    internal void Copy(OracleCommandImpl orclCmdImpl);
    internal int SqlIdBufferLength(OracleConnectionImpl connImpl);
    private bool CanUseOptimizeExecute(SqlStatementType stmtType, long numRowsToFetch, long numIterations, bool bsnapshot, bool bChangeNtfReq, object traceObj);
    internal void Cancel(OracleConnectionImpl connImpl, long cancelExecutionId);
    internal static void ValidateStatementCacheSize(OracleConnectionImpl connectionImpl);
    private void ValidateMaxOpenCursorLimit(OracleConnectionImpl connectionImpl, OracleParameterCollection paramColl);
    internal int VerifyExecution(OracleConnectionImpl connectionImpl, Int32& cursorId, bool bThrowArrayBindRelatedErrors, OracleException& exceptionForArrayBindDML, Boolean& hasMoreRowsInDB, bool bFirstIterationDone);
    internal static void TrimCommentsFromSQL(String& cmdText, object traceObj);
    internal static void TrimStringsFromSQL(String& cmdText, object traceObj);
    internal void SaveOBsWithParameterData(OracleConnectionImpl connectionImpl);
    internal ENQ_RefAndOutParamArgCtx ExecuteNonQuery(string commandText, OracleParameterCollection paramColl, CommandType commandType, OracleConnectionImpl connectionImpl, int longFetchSize, long clientInitialLOBFS, OracleDependencyImpl orclDependencyImpl, OracleConnection connection, ENQ_RefAndOutParamArgCtx enq_refOutArgCtx, bool isFromEF, bool bAsync);
    internal EXQ_RefAndOutParamArgCtx ExecuteXmlQuery(string commandText, OracleParameterCollection paramColl, CommandType commandType, OracleXmlCommandType xmlCommandType, OracleConnectionImpl connectionImpl, int longFetchSize, long clientInitialLOBFS, OracleDependencyImpl orclDependencyImpl, OracleConnection connection, EXQ_RefAndOutParamArgCtx exqRefOutArgs, bool isFromEF, bool wantResult, bool bAsync);
    internal EXS_RefAndOutParamArgCtx ExecuteXmlSave(string commandText, OracleParameterCollection paramColl, CommandType commandType, OracleXmlCommandType xmlCommandType, OracleConnectionImpl connectionImpl, int longFetchSize, long clientInitialLOBFS, OracleDependencyImpl orclDependencyImpl, OracleConnection connection, EXS_RefAndOutParamArgCtx exsRefOutArgs, bool isFromEF, bool bAsync);
    internal ER_RefAndOutParamArgCtx ExecuteReader(string commandText, OracleParameterCollection paramColl, CommandType commandType, OracleConnectionImpl connectionImpl, int longFetchSize, long clientInitialLOBFS, OracleDependencyImpl orclDependencyImpl, Int64[] scnForExecution, long internalInitialJSONFS, OracleConnection connection, ER_RefAndOutParamArgCtx er_refOutCtx, bool isDescribeOnly, bool isFromEF, bool bAsync);
    internal OracleDataReaderImpl GetReaderImplWithSchemaOnly(OracleConnectionImpl connectionImpl, CommandType commandType, string commandText, Nullable`1<bool> gotSqlMetadata, SQLMetaData sqlMetaData);
    private void ProcessParameters(OracleParameterCollection paramColl, OracleConnectionImpl connectionImpl, ColumnDescribeInfo[] cachedParamMetadata, Boolean& bBindMetadataModified, bool isEFSelectStatement, MarshalBindParameterValueHelper& marshalBindValuesHelper);
    private ICollection InitializeParamInfo(ICollection paramColl, OracleConnectionImpl connectionImpl, ColumnDescribeInfo[] cachedParamMetadata, Boolean& bMetadataModified, bool isEFSelectStatement, MarshalBindParameterValueHelper& marshalBindValuesHelper);
    internal static SqlStatementType GetSqlStatementType(string cmdText, Nullable`1& bIsDefineInSelect, object traceObj);
    private void CheckForReturningClause(string cmdTextWithoutComments, SqlStatementType statementType, SQLInfo sqlInfo, CommandType commandType, OracleParameterCollection paramCollection, ArrayList placeholderCollection, bool bBindParamPresent, string originalCmdText, object traceObj);
    private static bool HasReturningClause(string cmdText, SqlStatementType stmtType, OracleParameterCollection paramCollection, ArrayList placeholderCollection, bool bBindParamPresent, object traceObj);
    internal void ExtractAccessorValuesIntoParam(OracleParameterCollection paramColl, OracleConnection connection, int paramCount, string commandText, long longFetchSize, long clientInitialLOBFS, long internalInitialLOBFS, long internalInitialJSONFS, Int64[] scnFromExecution, bool bIsFromEF, bool bCallFromExecuteReader);
    internal OracleClob ExtractXMLValuesIntoParam(OracleParameterCollection& paramColl, OracleConnection connection, int paramIndex, bool wantResult, bool transform, OracleXmlQueryProperties xmlQueryProperties);
    internal int ExtractXMLSaveValuesIntoParam(OracleParameterCollection& paramColl, bool transform);
    internal void RetrieveMetadata(string commandText, CommandType commandType, OracleParameterCollection paramColl, OracleConnectionImpl connectionImpl, OracleConnection con, SQLMetaData& sqlMetadata, Int32& hiddenColumnCount);
    private string GetSqlId(CachedStatement cachedStmt, RER_RefAndOutParamArgCtx rer_refOutArgCtx);
    internal void ParseCommandText(string commandText, Boolean& bBindParamPresent, ArrayList& placeHolderCollection, object traceObj);
    private string GetPlaceHolderName(string commandText, int index, int strLength);
    private OracleParameterCollection ReorderBindByNameBasedParameterCollectionForStoredProcedure(OracleParameterCollection orclParamColl);
    internal OracleParameterCollection GetBindByPositionBasedParameterCollection(OracleParameterCollection orclParamColl, ArrayList placeHolderCollection, bool bXmlQuerySave);
    internal void CloseImplicitRefCursors(OracleConnectionImpl connectionImpl);
    private void BuildXmlQueryCommandText(bool wantResult, string resultParamName, string commandText, OracleParameterCollection parameters, OracleXmlCommandType xmlCommandType, OracleXmlQueryProperties xmlQueryProperties);
    private void BuildXmlSaveCommandText(OracleConnection connection, string commandText, OracleXmlCommandType xmlCommandType, OracleXmlSaveProperties xmlSaveProperties);
    private void Build8iXslCommandTextForXmlSave(StringBuilder strBldr, string xsltParams, string commandText, OracleXmlSaveProperties xmlSaveProperties);
    private void Build9iXslCommandTextForXmlGen(StringBuilder strBldr, bool wantResult, string xsltParams, string commandText, OracleXmlCommandType xmlCommandType, OracleXmlQueryProperties xmlQueryProperties, OracleXmlSaveProperties xmlSaveProperties);
    private int ParseXsltParams(string xsltParams, String[]& xsltParamNames, String[]& xsltParamValues);
}
internal class OracleInternal.ServiceObjects.OracleConnectionImpl : PoolResource`3<OraclePoolManager, OraclePool, OracleConnectionImpl> {
    private static string s_Connect;
    private static string s_DisConnect;
    internal object lockOnWeakReferenceObjList;
    internal int m_verifierType;
    internal bool m_bCanUseSecureCQN;
    internal bool m_bClientInitiatedConnection;
    internal string m_listenerClientId;
    internal bool m_bProxyAuthDidKeyFoldin;
    internal long m_clientPrefetchRows;
    internal string m_strAllowedLogonVersion;
    internal List`1<WeakReference> listofWeakReferenceObj;
    internal bool bSkipGetOutcome;
    internal PSPEManager m_pspeManager;
    internal TTCAQNotificationDeq m_TTCAQNotificationDeq;
    internal Timer m_flushPiggybackTimer;
    internal static long PIGGYBACK_WAIT_TIMER_INTERVAL;
    private string m_ociIamUrl;
    private string m_ociTenancy;
    private string m_ociCompartment;
    private string m_ociDatabase;
    private string m_iamUserId;
    private OracleOpaqueString m_opaqueIamPassw;
    private ITokenAuthenticationProvider m_tokenProvider;
    internal Dictionary`2<string, NameSpace> m_namespaces;
    private ObxmlProcessor m_obxmlProcessor;
    internal CacheWithLRUList`2<ulong, ObxmlToken> m_ElementAttributeTokens;
    internal CacheWithLRUList`2<ulong, ObxmlToken> m_NamespaceTokens;
    private object m_readerImplLock;
    internal bool m_preferredReaderImplTaken;
    private OracleDataReaderImpl m_preferredReaderImpl;
    private object m_commandImplLock;
    internal bool m_preferredCommandImplTaken;
    private OracleCommandImpl m_preferredCommandImpl;
    internal static int Default_DotNetCharSet;
    internal static int Default_DotNetNCharSet;
    internal static int TDM_SYSDBA_ERROR;
    internal static string SERVER_POOLED;
    internal static Char[] delim;
    internal static HashSet`1<string> dbsRegisteredForHA;
    internal static HashSet`1<string> servicesRegisteredForRLB;
    internal static HashSet`1<string> shardDBRegisteredForChunk;
    internal static SyncDictionary`2<string, ConnectionCookie> s_connectionCookie;
    internal static long TTIEOCFRO;
    internal static long TTIEOCCUR;
    internal static long TTIEOCDON;
    internal static long TTIEOCECT;
    internal static long TTIEOCFSE;
    internal static long TTIEOCFPR;
    internal static long TTIEOCFSW;
    internal static long TTIEOCFMF;
    internal static long TTIEOCETS;
    internal static long TTIEOCFCP;
    internal static long TTIEOCFTI;
    internal static long TTIEOCFIV;
    internal static byte END_TO_END_CID_INDEX;
    internal static byte END_TO_END_MODULE_INDEX;
    internal static byte END_TO_END_ACTION_INDEX;
    internal static byte END_TO_END_CLINFO_INDEX;
    internal static byte END_TO_END_STATE_INDEX_MAX;
    internal bool m_bConnected;
    internal WeakReference m_connWeakReference;
    internal Hashtable StCfgHT;
    internal Hashtable ObCfgHT;
    internal Hashtable ObTnsHT;
    internal Hashtable ObLdpHT;
    internal string m_TNS_ADMIN;
    internal OracleCommunication m_oracleCommunication;
    internal MarshallingEngine m_marshallingEngine;
    protected Hashtable m_proxySessionProperties;
    internal Hashtable m_sessionProperties;
    internal SemaphoreSlim m_connectionFreeToUseEvent;
    internal SemaphoreSlim m_writeQueue;
    internal AsyncSynchronizerEvent m_readQueue;
    internal object m_tuningLock;
    private Dictionary`2<string, int> m_samples;
    internal static object m_lockForONSSubscriptions;
    internal bool m_autoCommit;
    internal bool m_bRequestBoundaryToBeSet;
    internal bool m_bSetRequestBoundaryPiggybackSent;
    internal bool m_bRequestBoundaryToBeReset;
    internal static int DIRECTIVE_REPLAY_ENABLED;
    internal List`1<ReplayMode> m_replayModes;
    internal Byte[] m_thinACCurrentLTXID;
    internal AppContCtlCtx[] m_thinACAppContCtlCtxReceived;
    internal int m_thinACAppContCtlCtxReceivedCurrent;
    internal AppContCtlCtx m_thinACLastAppContCtlCtxReceived;
    internal AppContCtlCtx[] m_appContCtlCtxArr;
    internal int m_appContCtlCtxOffset;
    internal DatabaseSessionState m_sessionState;
    internal Byte[] m_thinACLastLtxid;
    internal int m_thinACLastLtxidHash;
    internal short m_executingRPCCode;
    internal string m_executingRPCSQL;
    internal DatabaseSessionState m_sessionStateOut;
    internal DBServiceProperties m_dbSvcProps;
    internal OracleFailoverMgrImpl m_failoverMgrImpl;
    internal long m_osessstateFlags;
    internal IsolationLevel m_currentIsolationLvl;
    internal TTCProtocolNegotiation m_protoNeg;
    internal TTCDataTypeNegotiation m_dtyNeg;
    internal TTCAuthenticate m_ttcAuth;
    internal TTCVersion m_ttcVersion;
    private TTCExecuteSql m_executeSql;
    private TTCFetch m_ttcFetch;
    private TTCSimpleOperations m_ttcSimplOp;
    private TTCOPing m_ttcOPing;
    private TTCNotification m_ttcNotification;
    private TTCClose m_ttcClose;
    private TTCCancel m_ttcCancel;
    private TTCSwitchSession m_ttcSwitchSession;
    private TTCEndToEndMetrics m_ttcEndToEndMetrics;
    private TTCTransactionSE m_ttcTransactionSE;
    private TTCTransactionEN m_ttcTransactionEN;
    private TTCSessionGet m_ttcSessionGet;
    private TTCSessionRelease m_ttcSessionRelease;
    private TTCSessionState m_ttcSessState;
    private TTCChunkInfo m_ttcChunkInfo;
    private TTCPipeline m_ttcPipeline;
    private TTCOkeyVal m_okeyVal;
    internal bool m_sendShardingInfoPiggyback;
    internal string m_shardingKey;
    internal string m_superShardingKey;
    internal string m_chunkName;
    private TTCAppContinuityReplay m_ttcAppContinuityReplay;
    private TTCSessionTemplate m_ttcSessionTemplate;
    internal long m_logonMode;
    internal short m_serverCharacterSet;
    internal short m_serverNCharSet;
    internal byte m_serverFlags;
    internal Byte[] m_serverCompiletimeCapabilities;
    internal Byte[] m_serverRuntimeCapabilities;
    internal bool m_b32kTypeSupported;
    internal long m_endOfCallStatus;
    internal bool m_bSvrSupportRequestBoundary;
    internal String[] m_endToEndMetrics;
    internal Boolean[] m_endToEndMetricsModified;
    internal object m_lockForLists;
    internal ArrayList m_tempLOBsToBeFreed;
    internal ArrayList m_cursorsToBeClosed;
    internal ArrayList m_cursorsToBeCancelled;
    internal StatementCache m_statementCache;
    internal OracleGlobalizationImpl m_oracleGlobalizationImpl;
    internal Transaction m_lastEnlistedTransaction;
    internal string m_onsConfigFromDb;
    internal string m_onsHASubscrPatter;
    internal string m_onsRLBSubscPatter;
    internal int m_maxIdentifierLength;
    internal string m_editionName;
    internal string m_drcpConnectionClass;
    internal string m_drcpTagName;
    internal bool m_bDRCPUseMultitag;
    internal string m_drcpSessionPurity;
    internal string m_drcpPLSQLCallback;
    internal Hashtable m_temporaryLobReferences;
    internal Nullable`1<OracleTimeZoneInfo> m_dbTimeZoneInfo;
    internal int m_lastErrorNum;
    internal bool m_isNewConnection;
    internal bool m_bBindByName;
    internal int m_commandTimeout;
    internal long m_fetchSize;
    internal int m_maxStatementCacheSize;
    internal bool m_bMaxStatementCacheSize_IsUserDefined;
    internal bool m_bPipelining;
    internal string m_serviceRelocationTimeout;
    internal bool m_bUseClientInitiatedCQN;
    internal bool m_bSuppressGetDecimalInvalidCastException;
    internal OracleTransactionImpl m_oracleTransactionImpl;
    private string m_UniqueConnectionId;
    private TraceParameters m_traceObj;
    internal bool CurrentlyInTransaction { get; }
    internal TTCProtocolNegotiation ProtocolNegotiationObject { get; }
    internal TTCDataTypeNegotiation DataTypeNegotiationObject { get; }
    internal TTCSessionState SessionStateObject { get; }
    internal TTCChunkInfo TTCChunkInfoObject { get; }
    internal TTCAppContinuityReplay AppContinuityReplayObject { get; }
    internal TTCSessionTemplate SessionTemplateObject { get; }
    internal TTCPipeline TTCPipelineObject { get; }
    internal TTCOkeyVal TTCOkeyValObject { get; }
    internal TTCAuthenticate AuthenticateObject { get; }
    internal TTCExecuteSql ExecuteSqlObject { get; }
    internal TTCSimpleOperations SimpleOperationsObject { get; }
    internal TTCClose TTCCloseObject { get; }
    internal TTCCancel TTCCancelObject { get; }
    internal TTCNotification TTCNotificationObject { get; }
    internal TTCSwitchSession TTCSwitchSessionObject { get; }
    internal TTCSessionGet TTCSessionGetObject { get; }
    internal TTCSessionRelease TTCSessionReleaseObject { get; }
    internal TTCOPing TTCOPingObject { get; }
    internal TTCEndToEndMetrics TTCEndToEndMetricsObject { get; }
    internal TTCFetch TTCFetchObject { get; }
    internal TTCTransactionSE TTCTransactionSE { get; }
    internal TTCTransactionEN TTCTransactionEN { get; }
    internal bool IsServerUsingBigSCN { get; }
    internal bool IsSupportPromotableTransaction { get; }
    internal int DatabaseMajorVersion { get; }
    internal int DatabaseMinorVersion { get; }
    internal int DatabasePatchsetVersion { get; }
    internal bool IsTZDataSentAsLocalTime { get; }
    internal Byte[] GetLogicalTransactionId { get; }
    internal bool IsNewConnection { get; internal set; }
    internal string ConnectionId { get; }
    private string UniqueConnectionId { get; }
    internal object TraceObj { get; }
    internal Byte[] ConectionUUID { get; }
    internal Nullable`1<OracleFailoverTypeInternal> FailoverTypeValue { get; }
    internal bool NTS { get; }
    internal bool DRCPConnection { get; }
    internal string DRCPConnectionClass { get; internal set; }
    internal string DRCPtagName { get; internal set; }
    internal bool CanSendRequestBoundary { get; }
    private string TraceCursorIDForClosing { get; }
    private string TraceCursorIDForCancelling { get; }
    internal int SessionId { get; internal set; }
    internal int SerialNumber { get; internal set; }
    internal int ProxySessionId { get; }
    internal int ProxySerialNumber { get; }
    internal SessionType SessionType { get; }
    internal string EditionName { get; }
    internal string ErrorOnOverlapValue { get; }
    internal string RowArchivalValue { get; }
    internal string SessionRoles { get; }
    internal string PdbName { get; }
    internal int MaxIdentifierLength { get; }
    internal int MaxOpenCursors { get; }
    internal string OnsConfigFromDB { get; }
    internal string OnsHASubscriberPattern { get; }
    internal string OnsRLBSubscriberPattern { get; }
    internal long FailoverTypeVal { get; }
    internal string InstanceName { get; }
    internal string ServiceName { get; }
    internal string DatabaseDomainName { get; }
    internal string DatabaseUniqueName { get; }
    internal string HostName { get; }
    internal string DatabaseId { get; internal set; }
    internal string DatabaseMountId { get; internal set; }
    internal string GloballyUniqueDatabaseId { get; internal set; }
    internal string PDBUniqueId { get; internal set; }
    internal string ConnectedUserName { get; }
    private static OracleConnectionImpl();
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<ConnectAsync>d__0")]
public virtual ValueTask ConnectAsync(ConnectionString cs, bool bOpenEndUserSession, OracleConnection connRefForCriteria, string instanceName, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<DoProtocolNegotiationAsync>d__1")]
internal ValueTask DoProtocolNegotiationAsync(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<DoDataTypeNegotiationAsync>d__2")]
internal ValueTask DoDataTypeNegotiationAsync(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<DoAuthenticationAsync>d__3")]
internal ValueTask`1<bool> DoAuthenticationAsync(OracleConnection connRefForCriteria, string userId, OracleOpaqueString opaquePassw, string proxyUserId, OracleOpaqueString opaqueProxyPassw, OracleOpaqueString opaqueNewPassw, bool bDoExternalAuth, OracleAccessToken accessToken, bool bOpenEndUserSession, bool bAsync, bool bUsingFastConnect);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<HandleProxyConectionAsync>d__4")]
private ValueTask`1<bool> HandleProxyConectionAsync(OracleConnection connRef, string userId, OracleOpaqueString opaquePassw, string proxyUserId, OracleOpaqueString opaqueProxyPassw, OracleAccessToken accesToken, bool bDoExternalAuth, bool bOpenEndUserSession, bool bAsync, bool bUsingFastConnect);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<OpenProxySessionAsync>d__5")]
private ValueTask`1<bool> OpenProxySessionAsync(OracleConnection connRefForCriteria, string userId, string proxyUserId, OracleOpaqueString opaqueProxyPassw, OracleAccessToken accesToken, bool bDoExternalAuth, bool bVerifyResponseFromServer, bool bAsync, bool bUsingFastConnect);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<OpenEndUserSessionAsync>d__6")]
internal ValueTask OpenEndUserSessionAsync(string userId, OracleOpaqueString opaquePassw, OracleConnection connRefForCriteria, bool bAsync, bool bUsingFastConnect);
    internal void RegisterForConnectionClose(object obj);
    internal void DeregisterForConnectionClose(object obj);
    internal void UpdateConnectedObjectsForTAF(OracleConnection failoverConnection);
    internal void FireConnectionCloseEvent();
    internal ObxmlDecodeStream GetDecodeStream(OracleConnection conn, OracleBlob csxBlob);
    internal void DisposeDecodeStream();
    internal void CloseDecodeStream(ObxmlDecodeContext decodeContext);
    internal OracleDataReaderImpl GetInitializedDataReaderImpl(Accessor[] defineAccessors, SQLMetaData sqlMetaData, int cursorId, int noOfRowsFetched, CachedStatement cachedStmt, OracleIntervalDS sessionTimeZone, long initialLongFS, long clientInitialLOBFS, long internalInitialLOBFS, long internalInitialJSONFS, Int64[] snapshotSCN, bool metadataHasImplicitROWIDcolumn, bool bInitialLongFetchSizeModified);
    internal OracleDataReaderImpl GetInitializedDataReaderImpl(List`1<OracleRefCursor> refCursors, long longFetchSize, Int64[] snapshotSCN);
    internal OracleCommandImpl getCommandImpl();
    internal void SetReplayOperations(ReplayOperation opSet);
    internal void BeginNonRequestCalls();
    internal void EndNonRequestCalls();
    internal void SetReplayingMode(bool replaying);
    internal void HandleAppContCtlCtx(AppContCtlCtx replayCtx);
    internal bool IsStateUnrestorable();
    internal void UpdateSessionState(StateSignatures stateSig, TemplateOverflow templateOF);
    internal void SendSessionStateFlags();
    internal bool get_CurrentlyInTransaction();
    internal TTCProtocolNegotiation get_ProtocolNegotiationObject();
    internal TTCDataTypeNegotiation get_DataTypeNegotiationObject();
    internal TTCSessionState get_SessionStateObject();
    internal TTCChunkInfo get_TTCChunkInfoObject();
    internal TTCAppContinuityReplay get_AppContinuityReplayObject();
    internal TTCSessionTemplate get_SessionTemplateObject();
    internal TTCPipeline get_TTCPipelineObject();
    internal TTCOkeyVal get_TTCOkeyValObject();
    internal TTCAuthenticate get_AuthenticateObject();
    internal TTCExecuteSql get_ExecuteSqlObject();
    internal TTCSimpleOperations get_SimpleOperationsObject();
    internal TTCClose get_TTCCloseObject();
    internal TTCCancel get_TTCCancelObject();
    internal TTCNotification get_TTCNotificationObject();
    internal TTCSwitchSession get_TTCSwitchSessionObject();
    internal TTCSessionGet get_TTCSessionGetObject();
    internal TTCSessionRelease get_TTCSessionReleaseObject();
    internal TTCOPing get_TTCOPingObject();
    internal TTCEndToEndMetrics get_TTCEndToEndMetricsObject();
    internal TTCFetch get_TTCFetchObject();
    internal TTCTransactionSE get_TTCTransactionSE();
    internal TTCTransactionEN get_TTCTransactionEN();
    internal bool get_IsServerUsingBigSCN();
    internal bool get_IsSupportPromotableTransaction();
    internal int get_DatabaseMajorVersion();
    internal int get_DatabaseMinorVersion();
    internal int get_DatabasePatchsetVersion();
    internal bool get_IsTZDataSentAsLocalTime();
    internal Byte[] get_GetLogicalTransactionId();
    internal bool get_IsNewConnection();
    internal void set_IsNewConnection(bool value);
    internal string get_ConnectionId();
    private string get_UniqueConnectionId();
    internal object get_TraceObj();
    internal void SwitchIsolationLevel(IsolationLevel isolationLevel, bool skipTxnContextValidation, CallHistoryRecord callHistoryRecord);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<WaitForConnectionForExecutionAsync>d__269")]
internal ValueTask`1<int> WaitForConnectionForExecutionAsync(bool noCancellation, OracleCommandImpl cmdImpl, bool bPipeliningLocks, bool bAsync);
    internal int WaitForConnectionForExecution(bool noCancellation, OracleCommandImpl cmdImpl, bool bPipeliningLocks, bool bAsync);
    internal void AcquireConnectionLocks(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<AcquireConnectionLocksAsync>d__272")]
internal ValueTask AcquireConnectionLocksAsync(bool bAsync);
    internal void ReleaseConnectionLocks(bool bAcquiredSendLock, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<AcquirePipeliningLocks>d__274")]
internal ValueTask AcquirePipeliningLocks(bool bAsync);
    internal void ReleasePipeliningLocks(bool bAcquiredSendLock, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleConnectionImpl/<ReleaseExecuteAndAcquireReceiveLock>d__276")]
internal ValueTask`1<bool> ReleaseExecuteAndAcquireReceiveLock();
    internal virtual bool PingServer();
    internal void ExecuteBasicSQL(string sqlText, bool skipTxnContextValidation, CallHistoryRecord callHistoryRecord);
    internal int VerifyExecution(Int32& cursorId, bool bThrowArrayBindRelatedErrors, SqlStatementType sqlStatementType, int arrayBindCount, OracleException& exceptionForArrayBindDML, Boolean& hasMoreRowsInDB, bool bFirstIterationDone);
    internal void OnOra01000Exception();
    internal Hashtable HandleObBasedConfig(OracleConnection OC);
    internal Hashtable HandleObBasedConfig(string tnsAdmin);
    internal Byte[] get_ConectionUUID();
    internal string GetAllowedLogonVersionValue(OracleConnection conn, SqlNetOraConfig snoConfig);
    public virtual void Connect(ConnectionString cs, bool bOpenEndUserSession, OracleConnection connRefForCriteria, string instanceName, bool bAsync);
    internal void PrepareFirstConnetionOptimization(OracleConnection conn);
    internal ConnectionCookie GetConnectionCookie(String& connCookieKey, ConnectionCookie& connCookieObject);
    internal bool PrepareCookieBasedOptimization(ConnectionCookie connCookieObject, Boolean& bAddCookieOnOpenSuccess, String& connCookieKey);
    internal OracleAccessToken GetAccessTokenForAuthentication(OracleConnection connRefForCriteria, ConnectionString cs, string userId, OracleOpaqueString opaquePassw, SqlNetOraConfig snoConfig, bool WalletOverride);
    private OracleAccessToken GetBearerToken(OracleConnection connRefForCriteria, OracleCommunication m_oracleCommunication, string userId, OracleOpaqueString opaquePassw);
    private void GetRefreshedAccessToken(OracleRefreshAccessTokenEventArgs eventArgs);
    private void GetNewAzureToken(OracleRefreshAccessTokenEventArgs e);
    private void GetNewOciToken(OracleRefreshAccessTokenEventArgs e);
    internal void StartSecureCQNListener(OraclePoolManager opm);
    internal void InitializeTAF(OracleConnection conn);
    internal void InitializeAC(OracleConnection conn, ConnectionReplacement connReplacement, MTSTxnType txnType, bool bStartRB);
    internal Nullable`1<OracleFailoverTypeInternal> get_FailoverTypeValue();
    internal void InitializeDBSvcProperties();
    internal void AddApplicationContext(string nameSpace, Dictionary`2<string, string> keyValues);
    internal void ClearApplicationContext(string nameSpace);
    public void SetAppContCtlCtx(AppContCtlCtx[] contexts);
    internal void SetLastAppContCtlCtx(AppContCtlCtx rCtx);
    internal AppContCtlCtx GetLastAppContCtlCtx();
    internal void ClearAllReplayContext(bool bForReplay);
    internal AppContCtlCtx[] GetAppContCtlCtx();
    internal static void TransferState(OracleConnectionImpl src, OracleConnectionImpl dest);
    internal virtual void UpdateAttributes();
    internal virtual bool AlterSession(Boolean[] alterConnectionTuple, OracleConnection connRefForCriteria);
    internal virtual bool get_NTS();
    internal static void SubscribeONSEvents(object state);
    internal void Logoff();
    internal void AlterSessionOnConnect(OracleConnection con);
    internal void GetGlobalizationValues(OracleGlobalizationImpl locGlobObj, OracleConnection con, bool isDB12101nAbove);
    public virtual bool Dump();
    internal bool get_DRCPConnection();
    internal void set_DRCPConnectionClass(string value);
    internal string get_DRCPConnectionClass();
    internal void set_DRCPtagName(string value);
    internal string get_DRCPtagName();
    public virtual void DetachServerProcess(string drcpTagName, bool bUseDRCPMultiTag);
    public virtual void AttachServerProcess(long sessionFlags, bool bUseDRCPMultiTag, Int64& s2cSessionFlags);
    internal void NewDRCPSessionAttached();
    public virtual void DisConnect(OracleConnection connRefForCriteria);
    internal void ClearState(bool isRequestFofHA);
    internal void DoProtocolNegotiation(bool bAsync);
    internal void PostProtocolNegotiationProcessing(MarshallingEngine mEngine, short serverCharSet, short serverNCharSet, byte serverFlags, Byte[] serverCTC, Byte[] serverRTC);
    internal void PostDataTypeNegotiationProcessing(MarshallingEngine mEngine, Byte[] serverCompileTimeCap, Byte[] serverRunTimeCap, short serverCharacterSet, short serverNCharSet, byte serverFlags);
    internal void DoDataTypeNegotiation(bool bAsync);
    internal static bool HasServerCompileTimeCapability(Byte[] serverCapabilities, int index, byte capabilityToCheck);
    internal void ValidateServerLogonCapabilityBasedOnALV(Byte[] serverCTCapabilities);
    internal void ValidateVerifierTypeBasedOnALV(OracleAllowedLogonVersionClient alvc);
    internal void ValidateVerifierTypeBasedOnALV(string strAllowedLogonVersion);
    internal bool DoAuthentication(OracleConnection connRefForCriteria, string userId, OracleOpaqueString opaquePassw, string proxyUserId, OracleOpaqueString opaqueProxyPassw, OracleOpaqueString opaqueNewPassw, bool bDoExternalAuth, OracleAccessToken accessToken, bool bOpenEndUserSession, bool bAsync, bool bUsingFastConnect);
    internal void SetAutoCommit(bool bAutoCommitOn);
    internal void AddTempLOBsToBeFreed(Byte[] lobLocator);
    internal void AddCursorIdToBeClosed(long cursorId);
    internal void AddCursorIdsToBeClosed(List`1<long> cursorIds);
    internal void AddCursorIdToBeCancelled(long cursorId);
    internal bool PendingPiggybacksToBeSent(bool bInvokeOnAppThread);
    internal void FlushPendingPiggybackMessages();
    internal static void FlushPiggybacksTimerCallback(object source);
    internal void FlushPendingPiggybackMessages(bool bInvokedOnAppThread);
    internal virtual void BeginRequest(bool bNoOpenHandles);
    internal void EndRequest(bool bImplicit);
    internal virtual void EndRequest();
    internal void DisableReplay();
    internal void AddRequestBoundaryPiggyback();
    internal bool get_CanSendRequestBoundary();
    internal void SetShardingInfoForPiggyback(string shardingKey, string superShardingKey, string chunkName);
    private string get_TraceCursorIDForClosing();
    private string get_TraceCursorIDForCancelling();
    internal void AddAllPiggyBackRequests(bool ensureCleanChannel, bool bSendPipeliningPiggyback);
    internal void ResetEndToEndMetrics();
    internal void ResetMTSTxnCtx();
    internal string GetServerVersion();
    internal void EvaluateDbMajorMinorPatchsetVersion();
    internal static void CheckForAnyErrorFromDB(TTCError ttcOER, object traceObj);
    internal Nullable`1<OracleTimeZoneInfo> GetDBTimeZoneBytes();
    internal void set_SessionId(int value);
    internal int get_SessionId();
    internal void set_SerialNumber(int value);
    internal int get_SerialNumber();
    internal int get_ProxySessionId();
    internal int get_ProxySerialNumber();
    private bool HandleProxyConection(OracleConnection connRef, string userId, OracleOpaqueString opaquePassw, string proxyUserId, OracleOpaqueString opaqueProxyPassw, OracleAccessToken accesToken, bool bDoExternalAuth, bool bOpenEndUserSession, bool bAsync, bool bUsingFastConnect);
    private bool OpenProxySession(OracleConnection connRefForCriteria, string userId, string proxyUserId, OracleOpaqueString opaqueProxyPassw, OracleAccessToken accesToken, bool bDoExternalAuth, bool bVerifyResponseFromServer, bool bAsync, bool bUsingFastConnect);
    internal void OpenEndUserSession(string userId, OracleOpaqueString opaquePassw, OracleConnection connRefForCriteria, bool bAsync, bool bUsingFastConnect);
    internal void CloseEndUserSession();
    internal SessionType get_SessionType();
    internal string GetCorrespondingAuthAttrName(int keyword);
    internal void UpdateSessionAttributes(TTCKeywordValuePair[] al8KeyVals, Hashtable sProperties);
    internal virtual string get_EditionName();
    internal string get_ErrorOnOverlapValue();
    internal string get_RowArchivalValue();
    internal string get_SessionRoles();
    internal virtual string get_PdbName();
    internal string GetPDBName(bool bMakeRoundtripIfRequired);
    internal virtual void GetConStrDefaults();
    internal virtual string GetDefaultEditionName();
    private int ExecuteNonQueryWithBind(OracleCommandImpl cmdImpl, string cmdText, OracleParameterCollection m_parameters, CommandType m_commandType);
    internal void ExtractAccessorValuesIntoParam(OracleCommandImpl cmdImpl, OracleParameterCollection paramColl, OracleConnectionImpl connImpl, int paramCount, string commandText, long longFetchSize, long clientInitialLOBFS, long internalInitialLOBFS, Int64[] scnFromExecution, bool bCallFromExecuteReader);
    internal int get_MaxIdentifierLength();
    internal int get_MaxOpenCursors();
    internal string get_OnsConfigFromDB();
    internal string get_OnsHASubscriberPattern();
    internal string get_OnsRLBSubscriberPattern();
    internal long get_FailoverTypeVal();
    internal string get_InstanceName();
    internal virtual string get_ServiceName();
    internal string get_DatabaseDomainName();
    internal string get_DatabaseUniqueName();
    internal string get_HostName();
    internal string get_DatabaseId();
    internal void set_DatabaseId(string value);
    internal string get_DatabaseMountId();
    internal void set_DatabaseMountId(string value);
    internal string get_GloballyUniqueDatabaseId();
    internal void set_GloballyUniqueDatabaseId(string value);
    internal string get_PDBUniqueId();
    internal void set_PDBUniqueId(string value);
    internal string get_ConnectedUserName();
    internal void PurgeStatementCache(int targetSize);
    internal bool GetLastWarning(String& warningMsg, Int32& errorCode);
    public bool IsConnectionAlive();
    internal static bool IsErrorRecoverable(int errNum);
    public static bool IsConnectionAlive(int errNum);
    internal object TemporaryLobReferenceGet(string lobId);
    internal void TemporaryLobReferenceAdd(string lobId, object lobImpl, bool bumpRefCount);
    internal void TemporaryLobReferenceRemove(string lobId);
    internal virtual bool TransportAlive();
    internal void InbandNotificationProcessing(int InbandErr1, int InbandErr2, int InbandEMFI, string InbandErrMsg, object InbandErrContext);
    internal static void ReturnOBToPool(List`1<OraBuf> obList);
    internal static void ReturnOBToPool(List`1<OraBuf> obList, bool bPipeliningEnabled);
}
internal class OracleInternal.ServiceObjects.OracleDatabaseImpl : object {
    private OracleConnection m_conn;
    private OracleConnectionImpl m_connImpl;
    private TTCStartupShutdown m_ttcStartupShutdown;
    private TTCSpfp m_ttcSpfp;
    internal OracleDatabaseImpl(OracleConnection conn);
    internal void init();
    internal void doShutdown(OracleDBShutdownMode mode);
    internal void doStartup(OracleDBStartupMode mode);
}
internal class OracleInternal.ServiceObjects.OracleDataReaderImpl : object {
    private static string s_SendExecuteRequest;
    internal long m_fetchSize;
    internal int m_maxRowSize;
    internal int m_initialLongFetchSize;
    internal CommandBehavior m_commandBehavior;
    internal bool m_bDisposed;
    internal OracleRefCursor m_refCursor;
    internal int m_recordsAffected;
    internal bool m_bBeginingOfFile;
    internal bool m_bEndOfFile;
    internal int m_fieldCount;
    internal bool m_bDoneReadOne;
    internal bool m_bHasRows;
    internal int m_internalRowCounter;
    internal string m_commandText;
    internal CommandType m_commandType;
    internal bool m_returnPSTypes;
    internal string m_storedProcName;
    internal DataTable m_dataTableEx;
    internal DataTable m_dataTable;
    internal SqlStatementType m_sqlStatementType;
    internal bool m_noMoreResults;
    internal bool m_fillReader;
    internal ArrayList m_dataTableList;
    internal bool m_bInternalCall;
    internal Type[] m_expectedColumnTypes;
    internal bool m_isFromEF;
    internal bool m_isFromEFCore;
    internal bool m_bMapNumberToBoolean;
    internal int m_edmMappingMaxBOOL;
    internal bool m_bMapNumberToByte;
    internal int m_edmMappingMaxBYTE;
    internal int m_edmMappingMaxINT16;
    internal int m_edmMappingMaxINT32;
    internal int m_edmMappingMaxINT64;
    internal Object[] m_LobImplCache;
    internal int m_RowNumber;
    internal Int64[] m_LastCachedRowNumber;
    internal ArrayList m_tempLobFromCurrentFetch;
    internal TimeSpan m_LocalTimeAdjustment;
    internal OracleBlobImpl m_tempOraBlobImpl;
    internal OracleClobImpl m_tempOraClobImpl;
    internal object m_dataTablesReferenceForFill;
    internal int m_currentDataTableIndex;
    internal DataTable m_currentDataTableForFill;
    internal bool m_bUseDataSetAsDupStore;
    internal int m_initialRowCnt;
    internal bool m_isRowAddedToDatatable;
    internal int m_numExplicitBoundRefCursors;
    internal object m_lockDataReader;
    internal bool m_bSuppressGetDecimalInvalidCastException;
    internal NumberFormatInfo m_nfi;
    internal string m_formatNumericCharacters;
    internal string m_formatTimeStamp;
    internal string m_formatTimeStampTZ;
    internal string m_formatDate;
    internal Accessor[] m_accessors;
    internal OracleConnectionImpl m_connectionImpl;
    internal int m_cursorId;
    private int m_rowsFetchedLastTime;
    internal List`1<object> m_oraBufReleaseInfoList;
    internal List`1<OraBuf> m_tempOBList;
    internal SQLMetaData m_sqlMetaData;
    internal bool m_bForRefCursor;
    private bool m_bFetchForRefCursorFirstTime;
    internal Int64[] m_snapshotSCN;
    private bool m_bInitialLongFetchSizeModified;
    internal long m_initialLongFS;
    internal long m_clientInitialLOBFS;
    internal long m_internalInitialLOBFS;
    internal long m_internalInitialJSONFS;
    internal int m_rowsFetched;
    internal bool m_bHasMoreRowsInDB;
    private List`1<OracleRefCursor> m_refCursors;
    internal int m_currentRefCursorIndex;
    private CachedStatement m_cachedStmt;
    internal OracleIntervalDS m_sessionTimeZone;
    internal int m_numberOfHiddenColumns;
    internal DataUnmarshaller m_dataUnmarshaller;
    internal bool m_bPooled;
    private object m_lock;
    internal bool m_closed;
    internal WeakReference m_oraDataRdrWeakRef;
    internal bool m_bFetching;
    internal bool m_bCancelled;
    internal Nullable`1<bool> m_bNextCallIsNonRequest;
    internal CallHistoryRecord m_callHistoryRecord;
    internal bool bOracleDataReaderDtorExecuting;
    internal string m_sqlId;
    internal OracleDataReaderImpl(OracleConnection conn);
    private static OracleDataReaderImpl();
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleDataReaderImpl/<FetchMoreRowsAsync>d__0")]
internal ValueTask`1<int> FetchMoreRowsAsync(int noOfRowsToFetch, bool fillReader, bool returnPSTypes, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleDataReaderImpl/<DoLobArrayReadAsync>d__1")]
internal ValueTask DoLobArrayReadAsync(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleDataReaderImpl/<LobArrayFetchAsync>d__2")]
internal ValueTask LobArrayFetchAsync(TTCLobAccessor[] lobAccessors, int lobColCount, bool bAsync);
    internal void Close();
    private void InitMigratedFieldsToDefault();
    internal void Init(List`1<OracleRefCursor> refCursors, long longFetchSize, Int64[] snapshotSCN, bool bSuppressGetDecimalInvalidCastException);
    internal void Init(Accessor[] defineAccessors, SQLMetaData sqlMetaData, int cursorId, int noOfRowsFetched, CachedStatement cachedStmt, OracleIntervalDS sessionTimeZone, long initialLongFS, long clientInitialLOBFS, long internalInitialLOBFS, long internalInitialJSONFS, Int64[] snapshotSCN, bool bSuppressGetDecimalInvalidCastException, bool metadataHasImplicitROWIDcolumn, bool bInitialLongFetchSizeModified);
    internal static int CountHiddenColumns(bool metadataHasImplicitROWIDcolumn);
    internal void ReleaseCursor(string commandText);
    internal void ValidateConnectionStateBeforeRoundtrip();
    internal void Cancel();
    internal Byte[] GetByteRepresentation(int currentRow, int columnIndex);
    internal Byte[] GetLobLocator(int currentRow, int columnIndex);
    internal double GetDouble(int currentRow, int columnIndex, Byte[]& byteRep);
    internal float GetFloat(int currentRow, int columnIndex, Byte[]& byteRep);
    internal bool IsCompleteDataForLongAvailable(int currentRow, int columnIndex);
    internal int GetColumnOrdinal(string colName);
    internal long GetBytes(int currentRow, int columnIndex, long fieldOffset, Byte[] buffer, int bufferOffset, int length, Byte[] lobLocator, bool bLOBArrayReadDone, OracleBlobImpl& tempBlobImpl, CallHistoryRecord chr);
    internal long GetBytes(OracleConnection connection, int currentRow, int columnIndex, long fieldOffset, Byte[] buffer, int bufferOffset, int length, CallHistoryRecord chr);
    internal long GetChars(int currentRow, int columnIndex, long fieldOffset, Char[] buffer, int bufferOffset, int length, Byte[] lobLocator, bool bLOBArrayReadDone, OracleClobImpl& tempClobImpl, CallHistoryRecord chr);
    internal long GetChars(OracleConnection connection, int currentRow, int columnIndex, long fieldOffset, Char[] buffer, int bufferOffset, int length);
    internal bool ConfigureNextResult();
    internal void CollectTempLOBsToBeFreed(int rowNumber, ArrayList tempLOBArrayList);
    internal void ReleaseUDTInsts(bool bClose);
    internal void SaveOBsWithParameterData();
    internal int FetchMoreRows(int noOfRowsToFetch, bool fillReader, bool returnPSTypes, bool bAsync);
    internal void DoLobArrayRead(bool bAsync);
    internal void LobArrayFetch(TTCLobAccessor[] lobAccessors, int lobColCount, bool bAsync);
}
internal class OracleInternal.ServiceObjects.OracleDependencyImpl : object {
    internal static int m_portForlistening;
    internal static string s_machineAddress;
    internal bool m_bIsRegistered;
    internal long m_clientRegistrationId;
    internal int m_RegIdFromServer;
    internal bool m_bIsEnabled;
    internal object m_syncList;
    internal ArrayList m_queryIDList;
    internal bool m_bIsNotifiedOnce;
    internal bool m_bIsPersistent;
    internal long m_timeout;
    internal bool m_bExcludeRowId;
    internal bool m_bIncludeRowId;
    internal bool m_bQueryBasedNTFN;
    internal ArrayList m_regList;
    internal static bool m_bIsAddressConfigured;
    internal string m_clientId;
    internal string m_listenerAddress;
    internal string m_guid;
    private object m_traceObj;
    internal object TraceObj { get; }
    internal OracleDependencyImpl(bool isNotifiedOnce, long timeout, bool isPersistent, object traceObj);
    private static OracleDependencyImpl();
    internal object get_TraceObj();
    internal static string GetMachineAddress(object traceObj);
    internal static string GetAddress(string hostName);
    internal void SetRegisterInfo(bool isNotifiedOnce, bool isPersistent, long timeout);
}
internal class OracleInternal.ServiceObjects.OracleFailoverMgrImpl : object {
    private static string BEGIN_REPLAY;
    private static string END_REPLAY;
    private static string PREPARE_REPLAY;
    internal static long SIG_FLAGS_NO_CHANGES;
    internal static long SIG_FLAGS_CLIENT_RESTORABLE_CHANGES;
    internal static long SIG_FLAGS_SERVER_RESTORABLE_CHANGES;
    internal static long SIG_FLAGS_SIDE_EFFECT_CHANGES;
    internal static long SIG_FLAGS_CAN_CHANGE_STATE;
    internal static long SIG_FLAGS_UNRESTORABLE_CHANGES;
    internal static long SIG_FLAGS_OVERFLOW_FULL;
    internal static int DIRECTIVE_ENQUEUE_CALL;
    internal static int DIRECTIVE_REQ_SCOPE_CRSR;
    internal static int DIRECTIVE_REPLAY_ENABLED;
    internal static int DIRECTIVE_EMPTY_QUEUE;
    internal ReplayLifecycle m_lifecycle;
    internal object m_replayResult;
    internal DateTime m_requestStartTime;
    internal long m_replayInitiationTimeout;
    internal static int REPLAY_RETRIES;
    internal int m_replayRetries;
    internal List`1<CallHistoryRecord> m_callHistory;
    internal CallHistoryRecord m_tail;
    internal CallHistoryRecord m_currentlyReplayingCHR;
    internal Byte[] m_ltxid;
    internal Byte[] m_oldLtxidForPrepareReplay;
    internal Byte[] m_ltxidAtOriginalOutage;
    internal AppContCtlCtx[] m_appContCtlCtxArray;
    internal AppContCtlCtx m_cxtBeforePrepareReplay;
    internal WeakReference m_originalConnWeakRef;
    internal ArrayList m_tempListOfWeakRefObjects;
    internal int m_lastCxtLenAtOriginalOutage;
    internal int m_replayErrorCode;
    internal string m_replayErrorMessage;
    internal string m_replayDisablingCall;
    internal bool m_bExecutingEndReplayBeforeReplayingFailedCall;
    internal bool m_bEndReplayCompleted;
    private OracleException m_connDeadException;
    internal bool m_doNotAbortConn;
    internal bool m_isReplayInDynamicMode;
    internal OracleFailoverRestoreInternal m_stateRestorationType;
    internal bool m_isAutoAC;
    private bool m_savedAutoCommit;
    private string m_savedEditionName;
    private string m_savedPdbName;
    private string m_savedServiceName;
    internal string m_savedSchema;
    internal string m_savedRoles;
    private OracleGlobalization m_savedGlobalizationObj;
    internal bool m_needStateSignatureSyncUp;
    internal DatabaseSessionState m_savedDatabaseSessionState;
    internal bool m_seenRoundtripCallInRequest;
    internal bool m_didReplayingLastCallDisableReplay;
    internal short m_nestedLevelOfTopLevelCalls;
    internal bool m_callingDisableFromEndRequest;
    internal bool m_lobStreamInRequest;
    internal static int MIN_READ_TIMEOUT_RAC_DG;
    internal int m_requestSizeLimit;
    internal int m_requestSize;
    internal bool m_bSvrSupportsSignature;
    internal String[] m_endToEndMetrics;
    internal OracleConnection m_originalConn { get; internal set; }
    internal bool ReplayDisabled { get; }
    internal OracleFailoverMgrImpl(OracleConnection orclConn);
    private static OracleFailoverMgrImpl();
    internal OracleConnection get_m_originalConn();
    internal void set_m_originalConn(OracleConnection value);
    internal void Reinit(OracleConnection conn);
    internal void BeginReplay(OracleConnection conn, Exception origException);
    internal void EndReplay(OracleConnection conn, Exception origException);
    internal bool PrepareReplay(OracleConnection conn, Exception origException, bool ac, short fncode, string sqlString);
    private OracleDecimal longToUB8(long orig);
    internal void SaveNLSSessionState(OracleConnection oconn);
    internal void CaptureSessionState(OracleConnection oconn);
    internal void SaveAutoCommitAndStateSignatures(OracleConnection oconn);
    internal void BeginRequest(bool bNoOpenHandles);
    internal void EndRequest(bool bImplicit);
    internal void DriverDisableReplay(int errorCode);
    internal void DisableReplay();
    internal static void DisableReplayByApplicationCall(OracleConnection conn, string methodName);
    internal void DisableReplayAndThrowException(int errCode, string errMesg, Exception ex);
    internal void ThrowReplayExceptionInternal(int errCode, string errMesg, Exception ex);
    internal void DisableReplayInternal(int errCode, string errMesg, Exception origException);
    internal bool IsStateUnrestorable();
    internal bool IsStateUnrestorable(StateSignatures sessSigs);
    internal void SetStateSignatureSyncUp();
    internal void CheckStateSignatureSyncUp();
    internal bool CheckACChange(OracleConnection oconn);
    internal void InvokeConnectionInitializationCallback(OracleConnection newConnection, Exception ex);
    internal void SessionRestoreAfterReconnect(OracleConnection newConnection, Exception ex);
    internal void RestoreCommonSessionState(OracleConnection newConnection);
    internal static void RestoreErrorOnOverlap(OracleConnection connection, string oldConnErrorOnOverlap);
    internal static void RestoreRowArchivalValue(OracleConnection connection, string oldConnRowArchivalValue);
    internal static void RestoreEditionName(OracleConnection connection, string oldConnEditionName);
    internal static void RestoreRoles(OracleConnection connection, string oldConnRoles);
    internal static void RestoreCurrentSchema(OracleConnection connection, string oldConnSchema);
    internal static void RestorePdbAndSvcName(OracleConnection oconn, string pdbName, string svcName);
    internal static void RestoreNLSSettings(OracleConnection oconn, OracleGlobalization globalizationObj);
    internal static void RestoreE2EMetrics(OracleConnection newConnection, String[] endToEndMetrics);
    internal void RestoreAutoCommit(OracleConnection newConnection);
    internal static CallHistoryRecord GetFunctionEntryRecord(OracleConnection connection, object instance, object method, Object[] args, Boolean& bCanRecordNewCall, Boolean& bThisCallIsRecorded);
    internal static void EnqueueCallRecord(OracleConnectionImpl connImpl, CallHistoryRecord chr);
    internal static bool CanThrowWhileReplaying(OracleConnection connection);
    internal static bool Replaying(OracleConnection connection);
    internal static void RecordFunctionExit(OracleConnection connection, CallHistoryRecord chr, object result, bool bThisCallIsRecorded, Boolean& bCanRecordNewCall);
    internal CallHistoryRecord PreForAll(object instance, object method, Object[] args, object clonedInstance);
    internal CallHistoryRecord CreateCallRecord(object instance, object method, Object[] argList, CallStatus status, object clonedInstance);
    internal void PostForAll(CallHistoryRecord chr, object instance, object method, object result, string status);
    internal void UpdateCallRecordOnError(CallHistoryRecord chr, Exception ex);
    internal void UpdateCallRecordOnExit(CallHistoryRecord chr, CallStatus callStatus, object result);
    internal void DoPostWhileRecording(CallHistoryRecord chr, object result, Exception ex);
    internal void UpdateCallRecord(CallHistoryRecord callHisRec);
    internal void UpdateCallRecord(CallHistoryRecord callHisRec, object method, CallStatus callStatus, object result, Exception ex);
    internal void DoPostWhileReplaying(CallHistoryRecord chr, object method, object result, Exception ex);
    internal bool get_ReplayDisabled();
    internal static string GetACErrorMessage(int errCode, string replayDisablingCall);
    internal void ThrowReplayDisabledError(OracleException oex);
    internal static object OnError(OracleConnection connection, CallHistoryRecord chr, object mi, Exception ex, bool bTopLevelCall, Boolean& bCanRecordNewCall);
    internal object OnErrorForAll(object method, OracleException oex);
    internal object HandleOutage(object method, OracleException orig_oex);
    internal object HandleOutageInternal(Exception origException, int currentRetries);
    internal bool NoRoundTripFromAdapterUpdate(CallHistoryRecord entry);
    internal object ReplayAllBeforeLastCall(Exception origException);
    internal bool AdapterUpdateCall(CallHistoryRecord entry);
    internal object ReplayLastCall(OracleConnection newConnection, Exception origException, Boolean& bEndReplayAfterLastCallReplay);
    internal static string GetMethodName(object mi);
    internal object ReplayOneCall(CallHistoryRecord chr, Exception origException);
    internal object InvokeThroughReflection(object instance, object toInvoke, object parameters);
    private bool IsSessionStateConsistencyDynamic();
    internal void SetSessionStateConsistency(bool isStatic);
}
internal class OracleInternal.ServiceObjects.OracleGlobalizationImpl : object {
    private static string DEFAULT_LANGUAGE_TERRITORY;
    private static string DEFAULT_LANGUAGE;
    internal string m_calendar;
    internal string m_comparison;
    internal string m_currency;
    internal string m_dateFormat;
    internal string m_dateLanguage;
    internal string m_dualCurrency;
    internal string m_isoCurrency;
    internal string m_language;
    internal string m_lengthSemantics;
    internal bool m_nCharConvException;
    internal string m_numericCharacters;
    internal string m_sort;
    internal string m_territory;
    internal string m_timeStampFormat;
    internal string m_timeStampTZFormat;
    internal string m_timeZone;
    internal string m_timeFormat;
    internal string m_timeTZFormat;
    private string m_error_msg;
    private int m_error_code;
    private OracleCommand m_cmd;
    internal OracleGlobalizationImpl(int lcid);
    internal static string GetNLSLANG(int lcid);
    internal static void GetLocaleSpecificNLSValues(int lcid, String& language, String& territory, String& timezone, Int32& zoneID, bool b_setUseHourOffset, object traceObj);
    internal static string CreateAlterSessionBlockForOAUTH(int lcid, Int32& zoneID, bool b_setUseHourOffset, object traceObj);
    internal void RefreshFrom(OracleGlobalizationImpl oraGlob);
    internal void AlterSession(OracleGlobalizationImpl oraGlob, OracleConnection con);
    internal void SelectNLSValues(OracleConnection con);
    internal void CreateSingleAlterSessionBlock(StringBuilder sqlCmd, OracleGlobalizationImpl oraGlob);
    internal void CreateDerivedSelectBlock(OracleGlobalizationImpl oraGlob, StringBuilder sqlCmd, bool onConnect, bool nls_lang, bool nls_territory);
    public bool Equals(OracleGlobalizationImpl oraGlob);
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
}
internal class OracleInternal.ServiceObjects.OracleHANotificationManager : OracleONSNotificationManager {
    private static string EvntTypeForService;
    private static string EvntTypeForHost;
    private static string PerServiceEventType;
    private string m_serviceName;
    private Hashtable serviceNamesTable;
    internal object locking;
    private static DateTimeFormatInfo s_dfi;
    private static OracleHANotificationManager();
    internal OracleHANotificationManager(object traceObj);
    protected virtual string GetEventTypeForNotification(string eventTypeFromDb, string serviceName);
    protected virtual void HandleEvent(object notification);
}
internal class OracleInternal.ServiceObjects.OracleJsonImpl : object {
    internal static int JSON_MAX_SIZE;
    internal static int JSON_DEFAULT_PREFETCH_SIZE;
    internal static int JSON_AVG_Size;
    internal static Byte[] GetBytes(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCJsonAccessor jsonAccessor, OracleBlobImpl& oraBlobImpl);
    internal static string GetJsonString(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCJsonAccessor jsonAccessor, OracleBlobImpl& oraBlobImpl);
    internal static string Decode(Byte[] oson);
    internal static Byte[] Encode(string jsonStr);
}
internal class OracleInternal.ServiceObjects.OracleNotificationManager : object {
    internal static NotificationListener m_ntfLsnr;
    private static List`1<string> m_lstOfDbsRegd;
    internal static SendNtfDetailsToUpperLayer s_sendNtfDetailsToUpperLayer;
    private static object m_syncObjForMode;
    private static object m_syncObjForPort;
    internal static bool m_bAqNotification;
    private static Hashtable m_ntfRegistrations;
    internal static ConcurrentDictionary`2<int, NotificationRegistrationDetails> m_ntfRegistations;
    internal static object m_syncRegDict;
    internal static ConcurrentDictionary`2<int, int> m_serverIdToNotificationTypeMap;
    internal static ConcurrentDictionary`2<int, OracleAQQueue> s_serverRegIDToOracleAQQueueMap;
    private static OracleNotificationManager();
    internal static void StartListener(Int32& portNo, object traceObj);
    internal static bool IsListenerRunning(object traceObj);
    internal static void SetCallbackForNotification(SendNtfDetailsToUpperLayer callBackFn);
    internal static void RegisterForChangeNotification(OracleConnectionImpl connectionImpl, OracleDependencyImpl orclDependencyImpl, bool bIncludeRowId);
    private static void SendRegistrationInfo(OracleConnectionImpl connectionImpl, OracleDependencyImpl orclDependencyImpl, bool bIncludeRowId, string listenerClientId);
    internal static void UnRegisterFromChangeNotification(OracleConnectionImpl connectionImpl, int dbChangeRegistrationId, string listenerClientId);
    internal static void HandleNotification(OracleCommunication dataEP);
    internal static void RegisterForAQNotification(OracleConnectionImpl connectionImpl, OracleDependencyImpl orclDependencyImpl, string queueName, String[] notificationConsumers, OracleNotificationRequest ntfnReq, OracleAQQueue oracleAQQueue);
    private static void SendAQRegistrationInfo(OracleConnectionImpl connectionImpl, OracleDependencyImpl orclDependencyImpl, String[] subscriptionName, string listenerClientId, OracleNotificationRequest ntfnReq);
    private static void DoStartAQNotificationForCIC(int aqRegistrationId, string queueName, string aqConnectionId, int qosFlag, OracleConnectionImpl connectionImpl);
    internal static void UnRegisterFromAQNotification(OracleConnectionImpl connectionImpl, int dbChangeRegistrationId, string listenerClientId, string queueName, String[] notificationConsumers);
    internal static void UnregisterFromAQNotificationInternal(OracleConnectionImpl connectionImpl, int dbChangeRegistrationId, string listenerClientId, string queueName, String[] notificationConsumers);
}
internal class OracleInternal.ServiceObjects.OracleONSNotificationManager : object {
    private string m_serviceName;
    private static string EvntTypeForService;
    private static string EvntTypeForHost;
    private bool m_bListeningOnDefaultNodes;
    private object m_traceObj;
    internal object TraceObj { get; internal set; }
    internal object get_TraceObj();
    internal void set_TraceObj(object value);
    internal static OracleONSNotificationManager GetNotificationManager(NotificationType type, object traceObj);
    internal void RegisterForNotification(string serviceName, string databaseName, int timeout, string eventTypeFromDb, string onsConfigFromDb);
    private void StartSubscription(object subscriberObj);
    protected virtual string GetEventTypeForNotification(string eventTypeFromDb, string serviceName);
    protected virtual void HandleEvent(object notification);
}
internal class OracleInternal.ServiceObjects.OracleParameterImpl : object {
    internal static byte InvalidPrecision;
    internal static byte InvalidScale;
    internal Byte[] m_paramValInBytes;
    internal Byte[][] m_paramValForArrayBindInBytes;
    internal byte m_precision;
    internal byte m_scale;
    internal int m_curSize;
    internal Int32[] m_curArrayBindSize;
    internal OracleParameterStatus[] m_arrayBindStatus;
    internal OracleParameterStatus m_status;
    internal Object[] m_saveValue;
    internal Byte[] m_qLocatorData;
    internal Byte[][] m_qLocatorDataForArrayBind;
    internal bool m_bSkipConversionToLocalTime;
    internal OracleParameterImpl DeepCloneForReplay();
    private object ExtractDecimalFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow, bool bSuppressGetDecimalInvalidCastException);
    private object ExtractDoubleFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow);
    private object ExtractSingleFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow);
    private object ExtractIntFromAccessor(Accessor accessor, PrmEnumType enumType, OracleDbType oraDbType, int currentRow);
    private object ExtractRefCursorFromAccessor(OracleConnection conn, Accessor accessor, long fetchSize, PrmEnumType enumType, OracleIntervalDS sessionTimeZone, string commandText, string paramPosOrName, long longFetchSize, long clientInitialLOBFS, long internalInitialLOBFS, long internalInitialJSONFS, Int64[] scnFromExecution, int currentRow, bool bIsFromEF, bool bCallFromExecuteReader);
    private object ExtractLongFromAccessor(object accessor, PrmEnumType enumType, int currentRow);
    private object ExtractBDoubleFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow);
    private object ExtractBFloatFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow);
    private object ExtractCharFromAccessor(Accessor accessor, PrmEnumType enumType, byte charSetForm, int maxSizeRequested, int currentRow, Char[] charArrayFromPooler, Int32& length);
    private object ExtractRawFromAccessor(Accessor accessor, PrmEnumType enumType, int maxLength, int currentRow, Int32& length);
    private object ExtractDateFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow);
    private object ExtractTimeStampFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow);
    private object ExtractTimeStampTZFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow, OracleConnectionImpl connImpl, bool asDateTimeOffset);
    private object ExtractTimeStampLTZFromAccessor(Accessor accessor, PrmEnumType enumType, OracleConnectionImpl connImpl, int currentRow);
    private object ExtractIntervalYMFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow);
    private object ExtractIntervalDSFromAccessor(Accessor accessor, PrmEnumType enumType, int currentRow);
    internal ColumnDescribeInfo GetParameterMetaData(OracleParameter parameter, ColumnDescribeInfo cachedParamMetadata, Boolean& bMetadataModified);
    internal int SetCharDataArrayInBytes(OracleConnectionImpl connImpl, object paramValue, Int32[] bindSize, int offset, int noOfElems, Boolean[] nullIndicatorsForArrayBind, bool bByteSemantics, int maxSize, SqlStatementType stmtType, byte charSetForm);
    internal void SetRawDataArrayInBytes(object paramValue, Int32[] bindSize, int offset, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal int SetCharDataInBytes(OracleConnectionImpl connImpl, object paramValue, int size, int offset, bool bByteSemantics, int maxSize, SqlStatementType stmtType, byte charSetForm);
    internal int SetCharDataInBytes(OracleConnectionImpl connImpl, object paramValue, int size, int offset, Byte[]& charByteArray, bool bByteSemantics, int maxSize, SqlStatementType stmtType, byte charSetForm);
    internal bool IsJsonDataNullValue(object paramValue);
    internal bool IsVectorDataNullValue(object paramValue, bool bIsNull);
    internal int SetJsonDataInBytes(OracleConnectionImpl connImpl, object paramValue);
    internal void SetVectorDataInBytes(OracleConnectionImpl connImpl, OracleDbType vectorDbType, object paramValue);
    internal int SetJsonDataInBytes(OracleConnectionImpl connImpl, object paramValue, Byte[]& oson);
    internal void SetVectorDataInBytes(OracleConnectionImpl connImpl, OracleDbType vectorDbType, object paramValue, Byte[]& vectorImage);
    internal int SetJsonArrayInBytes(OracleConnectionImpl connImpl, object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetVectorArrayInBytes(OracleConnectionImpl connImpl, OracleDbType vectorDbType, object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal bool IsUDTDataNullValue(object paramValue, bool bIsNull);
    internal int SetUDTDataInBytes(OracleConnection conn, UDTNamedType udtType, object paramValue);
    internal int SetUDTDataInBytes(OracleConnection conn, UDTNamedType udtType, object paramValue, Byte[]& udtImage, Object& saveValue);
    internal int SetUDTArrayInBytes(OracleConnection conn, UDTNamedType udtType, object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal object GetUDTFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, UDTNamedType udtType);
    internal object GetUDTArrayFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, UDTNamedType udtType, int bindElemCnt);
    internal object GetUDTAsJsonFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, UDTNamedType udtType);
    internal object GetUDTAsJsonArrayFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, UDTNamedType udtType, int bindElemCnt);
    private object ExtractUDTFromAccessor(OracleConnection conn, Accessor accessor, PrmEnumType enumType, UDTNamedType udtType, OracleParameterStatus& status, int currentRow);
    private object ExtractUDTAsJsonFromAccessor(OracleConnection conn, Accessor accessor, PrmEnumType enumType, UDTNamedType udtType, OracleParameterStatus& status, int currentRow);
    internal bool IsREFDataNullValue(object paramValue, bool bIsNull);
    internal int SetREFDataInBytes(object paramValue);
    internal int SetREFDataInBytes(object paramValue, Byte[]& refLocator);
    internal int SetREFArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal object GetRefFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput);
    internal object GetRefArrayFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput, int bindElemCnt);
    private object ExtractRefFromAccessor(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput, OracleParameterStatus& status, int currentRow);
    internal void SetInt32DataInBytes(object paramValue);
    internal void SetInt32DataInBytes(object paramValue, Byte[]& int32ByteArray);
    internal void SetPlsqlBooleanDataInBytes(object paramValue);
    internal void SetPlsqlBooleanDataInBytes(object paramValue, Byte[]& byteArray);
    internal void SetInt64DataInBytes(object paramValue);
    internal void SetInt64DataInBytes(object paramValue, Byte[]& int64ByteArray);
    internal void SetInt32ArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetInt64ArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetBinaryDoubleArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetClobArrayDataInBytes(OracleConnectionImpl connImpl, bool bIsNClob, object paramValue, int offset, int maxSize, Int32[] maxArrayBindSize, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetBlobArrayDataInBytes(OracleConnectionImpl connImpl, object paramValue, int offSet, int maxSize, Int32[] maxArrayBindSize, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetBFileArrayInBytes(OracleConnectionImpl connImpl, object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetTimeStampArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetTimeStampLTZArrayInBytes(OracleConnectionImpl connImpl, object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetTimeStampTZArrayInBytes(OracleConnectionImpl connImpl, object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetIntervalYMArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetIntervalDSArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetBinaryFloatArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetDecimalArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetDateArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetPlsqlBooleanArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetRefCursorArrayInBytes(OracleConnectionImpl connImpl, object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetDecimalDataInBytes(object paramValue);
    internal void SetDecimalDataInBytes(object paramValue, Byte[]& decimalByteArray);
    internal void SetBinaryDoubleInBytes(object paramValue);
    internal void SetBinaryDoubleInBytes(object paramValue, Byte[]& bdoubleByteArray);
    internal void SetDoubleInBytes(object paramValue);
    internal void SetDoubleInBytes(object paramValue, Byte[]& doubleByteArray);
    internal void SetDoubleArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetSingleInBytes(object paramValue);
    internal void SetSingleInBytes(object paramValue, Byte[]& singeByteArray);
    internal void SetSingleArrayInBytes(object paramValue, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    internal void SetBinaryFloatInBytes(object paramValue);
    internal void SetBinaryFloatInBytes(object paramValue, Byte[]& bfloatByteArray);
    internal void SetTimeStampInBytes(object bindValue);
    internal void SetTimeStampInBytes(object bindValue, Byte[]& timeStampByteArray);
    internal void SetTimeStampLTZInBytes(OracleConnectionImpl connImpl, object bindValue);
    internal void SetTimeStampLTZInBytes(OracleConnectionImpl connImpl, object bindValue, Byte[]& timeStampTZByteArray);
    internal void SetTimeStampTZInBytes(OracleConnectionImpl connImpl, object bindValue);
    internal void SetTimeStampTZInBytes(OracleConnectionImpl connImpl, object bindValue, Byte[]& timeStampLTZByteArray);
    internal void SetIntervalDSInBytes(object paramValue);
    internal void SetIntervalDSInBytes(object paramValue, Byte[]& intervalDSByteArray);
    internal void SetIntervalYMInBytes(object paramValue);
    internal void SetIntervalYMInBytes(object paramValue, Byte[]& intervalYMByteArray);
    internal void SetRawDataInBytes(object paramValue, int size, int offSet);
    internal void SetRawDataInBytes(object paramValue, int size, int offSet, Byte[]& rawByteArray);
    internal void SetDateInBytes(object paramValue);
    internal void SetDateInBytes(object paramValue, Byte[]& dateByteArray);
    internal void SetBlobDataInBytes(OracleConnectionImpl connImpl, object paramValue, int offSet, int maxSize, Int32[] maxArrayBindSize);
    internal void SetBlobDataInBytes(OracleConnectionImpl connImpl, object paramValue, int index, int offSet, int maxSize, Int32[] maxArrayBindSize, Byte[]& blobDataInBytes, Byte[]& qLocatorData, Object& saveValue);
    internal void SetBFileDataInBytes(OracleConnectionImpl connectionImpl, object paramValue);
    internal void SetBFileDataInBytes(OracleConnectionImpl connectionImpl, object paramValue, Byte[]& bfileByteArray);
    internal void SetRefCursorDataInBytes(OracleConnectionImpl connImpl, object paramValue);
    internal void SetRefCursorDataInBytes(OracleConnectionImpl connImpl, object paramValue, Byte[]& refCursorByteArray);
    internal void SetClobDataInBytes(OracleConnectionImpl connImpl, bool bIsNClob, object paramValue, int offset, int maxSize, Int32[] maxArrayBindSize);
    internal void SetClobDataInBytes(OracleConnectionImpl connImpl, bool bIsNClob, object paramValue, int index, int offset, int maxSize, Int32[] maxArrayBindSize, Byte[]& clobByteArray, Byte[]& qLocatorData, Object& saveValue);
    internal void SetXmlTypeInBytes(OracleConnectionImpl connImpl, object paramValue, int offset, int maxSize, Int32[] maxArrayBindSize);
    internal void SetXmlTypeInBytes(OracleConnectionImpl connImpl, object paramValue, int offset, int maxSize, Int32[] maxArrayBindSize, Byte[]& bytes);
    internal void SetXmlTypeArrayInBytes(OracleConnectionImpl connImpl, object paramValue, int offset, int maxSize, Int32[] maxArrayBindSize, int noOfElems, Boolean[] nullIndicatorsForArrayBind);
    private Char[] GetPreBindBuffer_Char(object parameterValue, bool bArraybind, int index);
    private string GetPreBindBuffer_Str(object bindValue);
    private int GetBindingSize(Array buffer, bool bArrayBind, int idx, int offset, int maxSize, Int32[] maxArrayBindSize);
    private Byte[] GetPreBindBuffer_Raw(object parameterValue, bool bArrayBind, int index);
    internal object GetCharDataFromBytes(Accessor accessor, PrmEnumType enumType, byte charSetForm, int maxSize, Char[] charArrayFromPooler);
    internal object GetRefCursorFromBytes(OracleConnection conn, Accessor accessor, long fetchSize, PrmEnumType enumType, OracleIntervalDS sessionTimeZone, string commandText, string paramPosOrName, long longFetchSize, long clientInitialLOBFS, long internalInitialLOBFS, long internalInitialJSONFS, Int64[] scnFromExecution, bool bIsFromEF, bool bCallFromExecuteReader);
    internal void GetLobDataFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput, byte charSetForm);
    private void ExtractLobDataFromAccessor(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput, byte charSetForm, Int32& curSize, OracleParameterStatus& status, int currentRow);
    internal object GetJsonFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType);
    internal object GetJsonArrayFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    private object ExtractJsonFromAccessor(OracleConnection conn, Accessor accessor, PrmEnumType enumType, Int32& curSize, OracleParameterStatus& status, int currentRow);
    internal object GetVectorFromBytes(OracleConnection conn, Accessor accessor, OracleDbType oraDbType, PrmEnumType enumType);
    internal object GetVectorArrayFromBytes(OracleConnection conn, Accessor accessor, OracleDbType oraDbType, PrmEnumType enumType, int bindElemCnt);
    private object ExtractVectorFromAccessor(OracleConnection conn, Accessor accessor, OracleDbType oraDbType, PrmEnumType enumType, Int32& curSize, OracleParameterStatus& status, int currentRow);
    internal void GetXmlTypeArrayFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput, int bindElemCnt);
    private void ExtractXmlTypeDataFromAccessor(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput, Int32& curSize, OracleParameterStatus& status, int currentRow);
    internal object GetTimeStampFromBytes(Accessor accessor, PrmEnumType enumType);
    internal object GetTimeStampLTZFromBytes(OracleConnectionImpl connImpl, Accessor accessor, PrmEnumType enumType);
    internal object GetTimeStampTZFromBytes(OracleConnectionImpl connImpl, Accessor accessor, PrmEnumType enumType, bool asDateTimeOffset);
    internal object GetRawDataFromBytes(Accessor accessor, PrmEnumType enumType, int maxSize);
    internal object GetRawDataFromBytesInPlSqlArray(Accessor accessor, PrmEnumType enumType);
    internal object GetDecimalArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt, bool bSuppressGetDecimalInvalidCastException);
    internal object GetBinaryDoubleArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetBinaryFloatArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetIntArrayFromBytes(Accessor accessor, PrmEnumType enumType, OracleDbType oraDbType, int bindElemCnt);
    internal object GetPlsqlBooleanArrayFromBytes(Accessor accessor, PrmEnumType enumType, OracleDbType oraDbType, int bindElemCnt);
    internal object GetCharArrayFromBytes(Accessor accessor, PrmEnumType enumType, byte charSetForm, Int32[] maxArrayBindSize, int bindElemCnt, Char[] charArrayFromPooler);
    internal object GetDateArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetDoubleArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetIntervalDSArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetIntervalYMArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal void GetLobArrayFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput, byte charSetForm, int bindElemCnt);
    internal object GetLongArrayFromBytes(object accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetRawArrayFromBytes(Accessor accessor, PrmEnumType enumType, Int32[] maxArrayBindSize, int bindElemCnt);
    internal object GetRefCursorArrayFromBytes(OracleConnection conn, Accessor accessor, long fetchSize, PrmEnumType enumType, OracleIntervalDS sessionTimeZone, string commandText, string paramPosOrName, long longFetchSize, long clientInitialLOBFS, long internalInitialLOBFS, long internalInitialJSONFS, Int64[] scnFromExecution, int bindElemCnt, bool bIsFromEF, bool bCallFromExecuteReader);
    internal object GetSingleArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetTimeStampArrayFromBytes(Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetTimeStampLTZArrayFromBytes(OracleConnectionImpl connImpl, Accessor accessor, PrmEnumType enumType, int bindElemCnt);
    internal object GetTimeStampTZArrayFromBytes(OracleConnectionImpl connImpl, Accessor accessor, PrmEnumType enumType, int bindElemCnt, bool asDateTimeOffset);
    internal object GetDecimalFromBytes(Accessor accessor, PrmEnumType enumType, bool bSuppressGetDecimalInvalidCastException);
    internal object GetIntFromBytes(Accessor accessor, PrmEnumType enumType, OracleDbType oraDbType);
    internal object GetPlsqlBooleanFromBytes(Accessor accessor, PrmEnumType enumType, OracleDbType oraDbType, int currentRow);
    internal object GetLongFromBytes(object accessor, PrmEnumType enumType);
    internal object GetSingleFromBytes(Accessor accessor, PrmEnumType enumType);
    internal object GetBinaryFloatFromBytes(Accessor accessor, PrmEnumType enumType);
    internal object GetDoubleFromBytes(Accessor accessor, PrmEnumType enumType);
    internal object GetBinaryDoubleFromBytes(Accessor accessor, PrmEnumType enumType);
    internal object GetDateFromBytes(Accessor accessor, PrmEnumType enumType);
    internal object GetIntervalDSFromBytes(Accessor accessor, PrmEnumType enumType);
    internal object GetIntervalYMFromBytes(Accessor accessor, PrmEnumType enumType);
    internal void GetXmlTypeDataFromBytes(OracleConnection conn, Accessor accessor, PrmEnumType enumType, OraType oraType, Object& value, bool isInputOutput);
    internal object GetCharDataFromBytesInPLSQLArray(OracleConnectionImpl connImpl, Accessor accessor, PrmEnumType enumType, Int32[] elemSizesToBeReturned, byte charSetForm, Char[] charArrayFromPooler);
    internal object GetDoubleFromBytesInPLSQLArray(Accessor accessor, PrmEnumType enumType);
    internal object GetSingleFromBytesInPLSQLArray(Accessor accessor, PrmEnumType enumType);
    internal object GetBinaryDoubleFromBytesInPLSQLArray(Accessor accessor, PrmEnumType enumType);
    internal object GetBinaryFloatFromBytesInPLSQLArray(Accessor accessor, PrmEnumType enumType);
    internal object GetInt32FromBytesInPLSQLArray(Accessor accessor, PrmEnumType enumType);
    internal object GetDecimalFromBytesInPLSQLArray(Accessor accessor, PrmEnumType enumType, bool bSuppressGetDecimalInvalidCastException);
    internal object GetLongFromBytesInPLSQLArray(object accessor, PrmEnumType enumType);
    internal object GetDateFromBytesInPLSQLArray(Accessor accessor, PrmEnumType enumType);
}
internal class OracleInternal.ServiceObjects.OracleRefCursorImpl : object {
    internal SQLMetaData m_sqlMetaData;
    internal int m_cursorId;
    internal Accessor[] m_accessors;
    internal OracleRefCursorImpl(TTCResultSet resultSet);
}
internal class OracleInternal.ServiceObjects.OracleRLBNotificationManager : OracleONSNotificationManager {
    private string m_serviceName;
    internal OracleRLBNotificationManager(object traceObj);
    protected virtual string GetEventTypeForNotification(string eventTypeFromDb, string serviceName);
    protected virtual void HandleEvent(object notification);
}
internal class OracleInternal.ServiceObjects.OracleTransactionImpl : object {
    internal bool m_completed;
    internal bool m_bClosed;
    internal OracleConnectionImpl m_connectionImpl;
    internal IsolationLevel m_isolationLevel;
    internal CallHistoryRecord m_callHistoryRecord;
    internal OracleTransactionImpl(OracleConnectionImpl connectionImpl, IsolationLevel isolationLevel);
    internal void Commit(OracleConnection connection, OracleLogicalTransaction& oracleLogicalTransaction);
    internal void Rollback(OracleConnection connection, OracleLogicalTransaction& oracleLogicalTransaction);
    internal void Rollback(OracleConnection connection, string savepointName);
    internal void Save(OracleConnection connection, string savepointName);
}
internal class OracleInternal.ServiceObjects.OracleVectorImpl : OracleJsonImpl {
    internal static int VECTOR_MAX_DIM;
    internal static int VECTOR_HEADER_SIZE;
    internal static int VECTOR_MAX_SIZE;
    internal static int VECTOR_DEFAULT_PREFETCH_SIZE;
    internal static int VECTOR_AVG_SIZE;
    internal static string VECTOR_START;
    internal static string VECTOR_END;
    internal static string VECTOR_EMPTY;
    internal static string VECTOR_STR;
    internal static string VECTOR_STAR;
    internal static string VECTOR_INT8;
    internal static string VECTOR_FLOAT32;
    internal static string VECTOR_FLOAT64;
    private static HashSet`1<Type> NumericTypes;
    private static OracleVectorImpl();
    public static bool IsNumericType(Type type);
    internal static bool IsVectorType(OracleDbType oraDbType);
    internal static VectorNumFormat GetVectorNumFormat(Type elementType);
    internal static OracleDbType GetVectorNumOraDbType(VectorNumFormat vectorNumType);
    internal static OracleDbType GetVectorOraDbType(VectorNumFormat vectorNumType);
    internal static string GetVectorDataTypeName(VectorNumFormat numFormat, int dimensions);
    internal static VectorNumFormat GetVectorNumFormat(OracleDbType vectorOraDbType);
    internal static string ConvertToString(Array nums);
    internal static Byte[] GetVectorBytes(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCVectorAccessor vectorAccessor, OracleBlobImpl& oraBlobImpl);
    internal static OracleDbType GetVectorNumOraDbType(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCVectorAccessor vectorAccessor, OracleBlobImpl& oraBlobImpl);
    internal static object GetVector(VectorNumFormat reqNumFormat, int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCVectorAccessor vectorAccessor, OracleBlobImpl& oraBlobImpl);
    internal static string GetVectorAsString(int currentRow, int columnIndex, OracleConnectionImpl connImpl, Byte[] lobLocator, DataUnmarshaller dataUnmarshaller, TTCVectorAccessor vectorAccessor, OracleBlobImpl& oraBlobImpl);
    internal static string GetVectorAsString(Byte[] vectorImage);
    internal static string GetVectorAsString(TTCVectorAccessor vectorAccessor, Byte[] vectorImage);
    internal static OracleString GetVectorAsOracleString(TTCVectorAccessor vectorAccessor, Byte[] vectorImage);
    internal static object GetVector(OracleDbType vectorBindingDbType, TTCVectorAccessor vectorAccessor, Byte[] vectorImage);
    internal static Byte[] GetVectorImage(OracleDbType vectorBindingDbType, VectorNumFormat valueNumFormat, Array nums);
    internal static Byte[] GetVectorImage(OracleDbType vectorBindingDbType, VectorNumFormat valueNumFormat, string vectorString);
}
internal class OracleInternal.ServiceObjects.OracleXmlStreamImpl : object {
    internal object m_syncLock;
    internal OracleConnectionImpl m_connImpl;
    internal OraXmlTypeData m_xmlTypeData;
    internal OracleXmlTypeImpl m_xmlTypeImplObj;
    private long m_streamDataLength;
    internal string m_xmlStr;
    internal Char[] m_xmlChars;
    internal OracleClob m_xmlClob;
    internal StringBuilder m_xmlBlobText;
    internal int m_oddByteValue;
    internal TypeOfXmlData m_xmlStreamType;
    private bool m_bInitialized;
    internal bool m_bAsyncCallInProgress;
    internal bool m_bInternalAsyncToAsyncCall;
    internal bool m_bFetching;
    internal bool m_bCancelled;
    internal OracleXmlStreamImpl(OracleConnectionImpl connImpl, OracleXmlTypeImpl xmlTypeImplObj);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleXmlStreamImpl/<GetLengthAsync>d__0")]
internal ValueTask`1<long> GetLengthAsync(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleXmlStreamImpl/<ReadAsync>d__1")]
internal ValueTask`1<OXSRead_RefAndOutParamArgCtx> ReadAsync(Char[] buffer, int offset, int count, OXSRead_RefAndOutParamArgCtx oxsRead_refOutCtx, CancellationToken cancellationToken, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.ServiceObjects.OracleXmlStreamImpl/<ReadAsync>d__2")]
internal ValueTask`1<OXSRead_RefAndOutParamArgCtx> ReadAsync(Byte[] buffer, int offset, int count, OXSRead_RefAndOutParamArgCtx oxsRead_refOutCtx, CancellationToken cancellationToken, bool bAsync);
    internal void Cancel();
    private void Initialize();
    internal string GetValue();
    private int ReadFromStringBuilder(Byte[] buffer, int offset, int count, Int64& position);
    private int ReadFromStringValue(Byte[] buffer, int offset, int count, Int64& position);
    private int ReadByte(int charOffset);
    internal void Dispose();
    internal long GetLength(bool bAsync);
    internal OXSRead_RefAndOutParamArgCtx Read(Char[] buffer, int offset, int count, OXSRead_RefAndOutParamArgCtx oxsRead_refOutCtx, CancellationToken cancellationToken, bool bAsync);
    internal OXSRead_RefAndOutParamArgCtx Read(Byte[] buffer, int offset, int count, OXSRead_RefAndOutParamArgCtx oxsRead_refOutCtx, CancellationToken cancellationToken, bool bAsync);
}
internal class OracleInternal.ServiceObjects.OracleXmlTypeImpl : object {
    internal object m_syncLock;
    internal OracleConnectionImpl m_connImpl;
    internal OraXmlTypeData m_xmlTypeData;
    internal Byte[] m_schemaID;
    internal Byte[] m_schElem;
    internal Byte[] m_snapshot;
    internal TypeOfXmlType m_typeOfXmlType;
    internal UInt32 m_xmlFlag;
    internal Hashtable m_namespacesFromXmlDoc;
    internal string m_schemaUrlFromXmlDoc;
    internal string m_schemaNSFromXmlDoc;
    internal bool m_bIsFragment;
    internal bool m_bGotFragmentProp;
    internal bool m_bGotSchemaInfo;
    internal XmlDocumentFragment m_xmlDocFragmentInternal;
    internal bool m_bHasTargetNamespaceProp;
    internal int m_kpsnpLen;
    internal OracleXmlTypeImpl(OracleConnectionImpl connImpl);
    internal OracleXmlTypeImpl(OracleConnectionImpl connImpl, TypeOfXmlType typeOfXmlType, TypeOfXmlData typeOfXmlData, object xmlValue);
    internal OracleXmlTypeImpl(OracleConnectionImpl connImpl, TTCXmlTypeAccessor XmlTypeAccessor, DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal OracleXmlTypeImpl(OracleConnectionImpl connImpl, OraXmlTypeHeader xmlTypeHeader, OraXmlTypeData xmlTypeData);
    internal static int GetKpsnpLen(OracleConnectionImpl connImpl);
    internal void PopulateXmlHeader(OraXmlTypeHeader xmlTypeHeader);
    internal void Set(OracleConnectionImpl connImpl, OraXmlTypeHeader xmlTypeHeader, OraXmlTypeData xmlTypeData);
    internal void Initialize(OracleConnection conn);
    internal void Dispose();
    internal OracleXmlTypeImpl Clone();
    internal bool IsEmptyXmlTypeData();
    internal void GetXmlDataForPickling(TypeOfXmlData& typeOfXmlData, Object& xmlData);
    internal string GetBinXmlDecodedString(OracleBlob blobCSX);
    internal StringBuilder GetBinXmlDecodedStringBuilder(OracleBlob blobCSX);
    internal string GetString();
    internal void GetXmlSchemaProp(String& schemaURL, Byte[]& schemaID, Boolean& bHasTargetNamespace);
    internal XmlDocument GetXmlDocument(bool bInternalUse, bool bThrowException);
    internal XmlReader GetXmlReader(XmlReaderSettings readerSettings);
    internal void Invalidate(bool bOriginalFragmentValue, bool bValueIsFragment, Boolean& bGotRootElement);
}
internal class OracleInternal.ServiceObjects.OraColumnData : object {
    internal Byte[] m_rawData;
    internal object m_netTypeData;
    internal int m_rowNum;
}
internal class OracleInternal.ServiceObjects.OraXmlBlobWithText : object {
    internal OracleBlob m_xmlBlob;
    internal int m_csid;
    internal bool m_bGetValue;
    internal bool m_bGetIsEmpty;
    internal string m_strValue;
    internal bool m_bIsEmpty;
    internal bool IsEmpty { get; }
    internal string Value { get; }
    internal OraXmlBlobWithText(OracleConnection conn, Byte[] lobLocator, int csid);
    internal OraXmlBlobWithText(OracleBlob blob, int csid);
    internal bool get_IsEmpty();
    internal string get_Value();
    internal OraXmlBlobWithText Clone();
    internal void Dispose();
}
internal class OracleInternal.ServiceObjects.OraXmlImpl : object {
    internal static string GetRootElement(OracleCommand cmd, OracleXmlType xmlType);
    internal static OracleXmlType Extract(OracleCommand cmd, OracleXmlType xmlType, string xpathExpr, string nsMap);
    internal static OracleXmlType Extract(OracleCommand cmd, OracleXmlType xmlType, string xpathExpr, XmlNamespaceManager nsMgr);
    internal static bool IsExists(OracleCommand cmd, OracleXmlType xmlType, string xpathExpr, string nsMap);
    internal static bool IsExists(OracleCommand cmd, OracleXmlType xmlType, string xpathExpr, XmlNamespaceManager nsMgr);
    internal static bool IsFragment(OracleCommand cmd, OracleXmlType xmlType);
    internal static OracleXmlType Transform(OracleCommand cmd, OracleXmlType xmlType, OracleXmlType xslDoc, string paramMap);
    internal static void Update(OracleCommand cmd, OracleXmlType xmlType, string xpathExpr, string nsMap, string val);
    internal static void Update(OracleCommand cmd, OracleXmlType xmlType, string xpathExpr, XmlNamespaceManager nsMgr, string val);
    internal static void Update(OracleCommand cmd, OracleXmlType xmlType, string xpathExpr, string nsMap, OracleXmlType newXmlTypeVal);
    internal static void Update(OracleCommand cmd, OracleXmlType xmlType, string xpathExpr, XmlNamespaceManager nsMgr, OracleXmlType newXmlTypeVal);
    internal static bool Validate(OracleCommand cmd, OracleXmlType xmlType, string schemaUrl);
    internal static string GetSchemaURL(OracleCommand cmd, OracleXmlType xmlType);
    internal static void GetSchema(OracleCommand cmd, OracleXmlType xmlType, string schemaUrl, OracleClob& schemaInfo, Byte[]& schemaId);
    internal static void GetSchema(OracleCommand cmd, OracleXmlType xmlType, Byte[] schemaId, OracleClob& schemaInfo, String& schemaUrl);
}
internal class OracleInternal.ServiceObjects.OraXmlTypeData : object {
    internal Char[] m_xmlChars;
    internal string m_xmlStr;
    internal OracleClob m_xmlClob;
    internal XmlDocument m_xmlDocInternal;
    internal OraXmlBlobWithText m_xmlBlobText;
    internal int m_csid;
    internal Byte[] m_xmlLobLocator;
    internal OracleBlob m_xmlBlobCSX;
    internal TypeOfXmlData m_typeOfXmlData;
    internal OraXmlTypeData(TypeOfXmlData typeOfXmlData, object value);
    internal void Dispose();
    internal OraXmlTypeData Clone();
}
internal class OracleInternal.ServiceObjects.OraXmlTypeHeader : object {
    internal TypeOfXmlType m_typeOfXmlType;
    internal UInt32 m_xmlFlag;
    internal long m_dataLength;
    internal int m_headerLength;
    internal Byte[] m_schoid;
    internal Byte[] m_schElem;
    internal Byte[] m_snapshot;
    internal bool HasSchema();
    internal bool IsFragment();
}
internal static class OracleInternal.ServiceObjects.ReplayDatabaseError : object {
    public static int TXN_REPLAY_FAILED;
    public static int TXN_ACTIVE_AFTER_TAF_CALLBACK;
    public static int REPLAY_INITIATION_TIMEOUT;
    public static int REPLAY_DISABLED_BY_CALL;
    public static int REPLAY_DISABLED_BY_USER_REQ;
    public static int NO_REPLAY_NESTED_TOPLEVEL_CALL;
    public static int REPLAY_ERROR_SET_CONTAINER;
    public static int NO_REPLAY_INSUFFICIENT_MEMORY;
    public static int GETLTXID_CALLED_IN_REPLAY_INIT_CALLBACK;
    public static int NO_REPLAY_RECONNECT_AC_CHANGED;
    public static int EOJ_NO_REPLAY;
    public static int NO_REPLAY_ACTIVE_TXN;
    public static int NO_REPLAY_NONREPLAYABLE_CALL;
    public static int NO_REPLAY_LAST_CALL_PLSQL;
    public static int NO_REPLAY_TXN_MONITORING_FAILED;
    public static int NO_REPLAY_BEGIN_REPLAY_FAILED;
    public static int NO_REPLAY_END_REPLAY_FAILED;
    public static int NO_REPLAY_INITIATION_TIMEOUT_EXCEEDED;
    public static int NO_REPLAY_RETRIES_EXCEEDED;
    public static int NO_REPLAY_INIT_CALLBACK_FAILURE;
    public static int NO_REPLAY_ACTIVE_TXN_IN_INIT_CALLBACK;
    public static int NO_REPLAY_AFTER_ENDREQUEST;
    public static int NO_REPLAY_RECONNECT_RETRIES_EXCEEDED;
    public static int NO_REPLAY_GET_REPLAY_CONTEXT_FAILED;
    public static int NO_REPLAY_SERVER_CM_DISABLED;
    public static int NO_REPLAY_PREPARE_REPLAY_FAILED;
    public static int NO_REPLAY_EMBEDDED_COMMIT;
    public static int NO_REPLAY_LOCAL_TXN_PROMOTED;
    public static int EOJ_REPLAY_ERROR;
    public static int REPLAY_ERROR_CHECKSUM_MISMATCH;
    public static int REPLAY_ERROR_ERRCODES_MESG_MISMATCH;
    public static int REPLAY_ERROR_ACTIVE_TXN;
    public static int BEGIN_REQUEST_CALLED_DURING_REQUEST;
    public static int BEGIN_REQUEST_CALLED_WITH_OPEN_TXN;
    public static int END_REQUEST_CALLED_WITH_OPEN_TXN;
    public static int SVR_TOO_OLD_TO_SUPPORT_REPLAY;
    public static int REPLAY_SUPPORT_UNAVAILABLE_IN_SVR;
    public static int SVR_FAILOVER_TYPE_NOT_TRANSACTION;
    public static int NO_REPLAY_CONCRETE_CLASSES;
    public static int NO_REPLAY_SVR_NOREPLAY_FORCE;
    public static int NO_REPLAY_SVR_DIRECTIVE_MISMATCH;
    public static int SPECIAL_SVR_RECOVERABLE_ERROR;
    public static int TXN_IN_READONLY_REPLAY_ERROR;
    public static int SET_CONTAINER_AFTER_PREPARE;
    public static int SVR_NO_REPLAY_ERROR_CODE;
    private static ReplayDatabaseError();
}
internal class OracleInternal.ServiceObjects.SqlData : object {
    internal string m_data;
    internal UInt32 m_id;
    internal UInt32 m_tag;
    internal SqlData(string data, UInt32 id, UInt32 tag);
}
internal enum OracleInternal.ServiceObjects.SqlMacTokTyp : Enum {
    public int value__;
    public static SqlMacTokTyp A_SELECT;
    public static SqlMacTokTyp A_ALL;
    public static SqlMacTokTyp A_UNIQUE;
    public static SqlMacTokTyp A_DISTINCT;
    public static SqlMacTokTyp A_AS;
    public static SqlMacTokTyp A_FROM;
    public static SqlMacTokTyp A_COLUMN;
    public static SqlMacTokTyp A_COLALIAS;
    public static SqlMacTokTyp A_TABLE;
    public static SqlMacTokTyp A_TABALIAS;
    public static SqlMacTokTyp A_COMMA;
    public static SqlMacTokTyp A_AFTERFROM;
    public static SqlMacTokTyp A_PSEUDOCOL;
    public static SqlMacTokTyp A_OTHERS;
    public static SqlMacTokTyp A_UNKNOWN;
    public static SqlMacTokTyp A_CASE;
}
internal enum OracleInternal.ServiceObjects.SqlMicTokTyp : Enum {
    public int value__;
    public static SqlMicTokTyp I_UNKNOWN;
    public static SqlMicTokTyp I_COMMA;
    public static SqlMicTokTyp I_DOT;
    public static SqlMicTokTyp I_AT;
    public static SqlMicTokTyp I_BPAREN;
    public static SqlMicTokTyp I_EPAREN;
    public static SqlMicTokTyp I_COMMENT;
    public static SqlMicTokTyp I_ASTERISK;
    public static SqlMicTokTyp I_NUMLIT;
    public static SqlMicTokTyp I_NCHARLIT;
    public static SqlMicTokTyp I_CHARLIT;
    public static SqlMicTokTyp I_VARCHAR;
    public static SqlMicTokTyp I_OPER;
    public static SqlMicTokTyp I_HINT;
    public static SqlMicTokTyp I_ERROR;
    public static SqlMicTokTyp I_FINITO;
}
internal class OracleInternal.ServiceObjects.SQLParser : object {
    private static UInt32 SQL_TOKTYP_EXTRACTOR;
    private static UInt32 SQL_TOKATR_EXTRACTOR;
    private static UInt32 SQL_TOKATR_WILDCARD;
    private static UInt32 SQL_TOKATR_PSEUDOCOL;
    private static UInt32 SQL_TOKATR_NORMALCOL;
    private static int dotRowIdLen;
    internal static string SQL_COLUMN_ROWID;
    private static ushort UCS2_HASH;
    private static ushort UCS2_DOLLAR;
    private static ushort UCS2_UNDERSCORE;
    private static bool SqlPreLocalBuild(string commandText, bool addRowid, List`1& sqlTokList, List`1& tableList, UInt32& numberOfTables, Boolean& distinct, Boolean& wildcard, Boolean& onlyWildcard, Boolean& rowIdCol, Boolean& parseFailed);
    private static bool SqlLocalParse(string commandText, Boolean& bFoundRowidInSql, Boolean& wildcard, Boolean& onlyWildcard, Boolean& distinct, UInt32& numberOfTables, List`1& tableList, List`1& sqlTokList);
    private static bool SqlParse(string sqlStmt, List`1& sqlDataList);
    private static void SqlReadSQLTokenList(List`1<SqlData> tokenList, List`1& tableList, UInt32& numberOfTables, Boolean& wildCard, Boolean& onlyWildCard, Boolean& distinct, Boolean& bFoundRowidInSql);
    private static SqlMicTokTyp SqlGetNextToken(string sqlString, int sqlStringLen, String& tokenString, Int32& pos);
    private static SqlMacTokTyp SqlGetMacroTokenType(string token);
    private static bool IsJoinKeyword(string token);
    private static bool IsValidJoin(string firstToken, string secondToken);
    internal static bool DoSqlLocalProcessing(String& commandText, bool addRowid, Boolean& bFoundRowidInSql, OracleConnectionImpl connImpl, OracleConnection conn);
    internal static bool GetSchemaMetaData(SQLMetaData sqlMetInfo, OracleConnection conn, OracleConnectionImpl connImpl, bool metadataHasImplicitROWIDColumn);
    private static bool SqlLocalBuildEx(OracleConnectionImpl connImpl, SQLMetaData sqlMetaData, List`1<SqlData> tableList, UInt32 numberOfTables, List`1<SqlData> sqlTokList, bool onlyWildcard, UInt32 noOfpMeta, bool metadataHasImplicitROWIDColumn, bool parseFailed);
    private static bool SqlPopulateTableSchemaInfo(SQLLocalParsePrimaryKeyInfo& sqlParseInfo, List`1<SqlData> tableList);
    private static void SqlGetTableName(List`1<SqlData> tabList, UInt32 TableNum, SqlMacTokTyp AliasOrActual, String& tabName, UInt32& idAliasOrActual);
    public static void SplitTableString(string inStr, String& schema_Name, String& table_Name, String& dbLink);
    private static bool SqlFillMetaAttr(string commandText, SQLMetaData& sqlMetadata, List`1<SqlData> tabList, UInt32 NoOfTables, bool bOnlyWildcard, UInt32 NoOfpMeta, bool metadataHasImplicitROWIDColumn, object traceObj);
    private static void splitColumnString(string inStr, String& schemaName, String& tableName, String& columnName);
    private static bool SqlRebuildSQL(List`1<SqlData> sqlTokList, List`1<SqlData> tabList, String& newSQL, UInt32 NoOfTables, bool bOnlyWildcard, bool bAddRowid, OracleConnectionImpl connImpl, OracleConnection conn, Dictionary`2& tableColumnsMap);
    private static void SqlAddColNames(StringBuilder& newSQLBuilder, Dictionary`2<string, List`1<SqlData>> tableColumnsMap, List`1<SqlData> tabList, string tabName, string schemaName);
    private static bool SqlGetTableIndex(List`1<SqlData> tabList, string tabName, UInt32& index, UInt32& idAliasOrActual, bool tokenizeTableName);
    private static bool SqlFixColTabSch(SQLMetaData& sqlMetadata, UInt32 NoOfTables, List`1<SqlData> tabList, UInt32 NoOfpMeta, Boolean& bUnresolvedColumn);
    private static bool SqlGetResolveAllCols(SQLLocalParsePrimaryKeyInfo& sqlParseInfo, List`1<SqlData> tabList, Dictionary`2<string, List`1<SqlData>> tableColumnMap, UInt32 NoOfTables, UInt32 NoOfpMeta);
    private static bool SqlIsColumnInList(List`1<SqlData> columnList, string colName);
    private static bool SqlGetColumnsForAllTables(OracleConnectionImpl connImpl, OracleConnection conn, List`1<SqlData> tableList, Dictionary`2& tableColumnMap, bool addQuotes);
    private static bool SqlGetColumns(OracleConnectionImpl connImpl, OracleConnection conn, string tableName, List`1& columnList, bool addQuotes);
    private static bool SqlAppendRowid(StringBuilder& newSQLBuilder, List`1<SqlData> tabList);
}
internal enum OracleInternal.ServiceObjects.SqlState : Enum {
    public int value__;
    public static SqlState S_BEGSQL;
    public static SqlState S_SELECT;
    public static SqlState S_INCOLUMN;
    public static SqlState S_NEWCOLUMN;
    public static SqlState S_FROM;
    public static SqlState S_INTABLE;
    public static SqlState S_NEWTABLE;
    public static SqlState S_ENDSQL;
    public static SqlState S_UNKNOWN;
    public static SqlState S_INJOIN;
}
internal enum OracleInternal.ServiceObjects.TypeOfXmlData : Enum {
    public int value__;
    public static TypeOfXmlData NoData;
    public static TypeOfXmlData String;
    public static TypeOfXmlData Clob;
    public static TypeOfXmlData Chars;
    public static TypeOfXmlData XmlDoc;
    public static TypeOfXmlData StringAndXmlDoc;
    public static TypeOfXmlData ClobAndString;
    public static TypeOfXmlData BlobWithText;
    public static TypeOfXmlData BlobWithTextAndString;
    public static TypeOfXmlData BlobCSX;
    public static TypeOfXmlData BlobCSXAndString;
}
internal enum OracleInternal.ServiceObjects.TypeOfXmlType : Enum {
    public UInt32 value__;
    public static TypeOfXmlType Null;
    public static TypeOfXmlType String;
    public static TypeOfXmlType Clob;
    public static TypeOfXmlType BlobCSX;
    public static TypeOfXmlType BlobWithText;
    public static TypeOfXmlType Object;
    public static TypeOfXmlType XQ_SEQ_DMFM;
}
public class OracleInternal.ServiceObjects.XmlTypeReader : XmlTextReader {
    internal Hashtable m_namespaces;
    private bool m_bGetSchema;
    internal bool m_bHasTargetNamespace;
    internal string m_schemaURL;
    internal string m_schemaXmlns;
    internal static string XMLNSNotation;
    internal static string XSINotation;
    internal static string SchemaLocationNotatation;
    internal static string NSSchemaLocationNotatation;
    public Hashtable CollectedNamespaces { get; }
    public XmlTypeReader(TextReader textReader);
    public XmlTypeReader(Stream clob);
    public Hashtable get_CollectedNamespaces();
    public virtual bool Read();
}
internal class OracleInternal.Sharding.Chunk : object {
    private SortedDictionary`2<int, HashSet`1<string>> instancesByPriority;
    private SortedDictionary`2<string, int> priorityByInstances;
    private SortedDictionary`2<ChunkStatus, HashSet`1<string>> instancesByStatus;
    private SortedDictionary`2<string, ChunkStatus> statusByInstances;
    private HashSet`1<string> allInstances;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UniqueId>k__BackingField;
    internal string Name { get; internal set; }
    internal string AbsoluteName { get; }
    internal int Id { get; internal set; }
    internal int UniqueId { get; internal set; }
    internal HashSet`1<string> AllInstances { get; }
    internal HashSet`1<string> HighestPriorityInstances { get; }
    internal List`1<string> AllHighestPriorityInstances { get; }
    internal Chunk(string name);
    internal static bool GetIdFromName(string name, Int32& id);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    internal string get_AbsoluteName();
    [CompilerGeneratedAttribute]
internal int get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(int value);
    [CompilerGeneratedAttribute]
internal int get_UniqueId();
    [CompilerGeneratedAttribute]
internal void set_UniqueId(int value);
    internal HashSet`1<string> get_AllInstances();
    internal HashSet`1<string> get_HighestPriorityInstances();
    internal List`1<string> get_AllHighestPriorityInstances();
    internal bool HasInstance(string instance);
    internal int GetInstancePriority(string instance);
    internal ChunkStatus GetInstanceStatus(string instance);
    internal void SetInstanceStatus(string instance, ChunkStatus newStatus);
    internal void AddInstance(string instance, int priority, ChunkStatus status);
    internal bool RemoveInstance(string instance);
    private void AddInstanceStatus(string instance, ChunkStatus status);
    private bool RemoveInstanceStatus(string instance);
    public virtual string ToString();
}
internal class OracleInternal.Sharding.ChunkInfo : object {
    [CompilerGeneratedAttribute]
private List`1<InstanceInfo> <PriorityInstances>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChunkName>k__BackingField;
    internal List`1<InstanceInfo> PriorityInstances { get; internal set; }
    internal string ChunkName { get; internal set; }
    internal ChunkInfo(string chunkName, List`1<InstanceInfo> priorityInstances);
    [CompilerGeneratedAttribute]
internal List`1<InstanceInfo> get_PriorityInstances();
    [CompilerGeneratedAttribute]
internal void set_PriorityInstances(List`1<InstanceInfo> value);
    [CompilerGeneratedAttribute]
internal string get_ChunkName();
    [CompilerGeneratedAttribute]
internal void set_ChunkName(string value);
}
public enum OracleInternal.Sharding.ChunkStatus : Enum {
    public int value__;
    public static ChunkStatus Up;
    public static ChunkStatus ReadOnly;
    public static ChunkStatus Down;
}
internal class OracleInternal.Sharding.DotnetToDotnetConverter : object {
    private static Dictionary`2<Key, ConvertDel> CONVERTERS;
    private static DotnetToDotnetConverter();
    public static Byte[] convert(object src, Type target, OracleConnection conn, object srcExtra, object targetExtra);
}
internal class OracleInternal.Sharding.HashRangeShardingKeys : ShardingKeys {
    private List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> m_keys;
    [CompilerGeneratedAttribute]
private OracleShardingKeyImpl <KeyHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private OracleShardingKeyImpl <KeyLow>k__BackingField;
    internal OracleShardingKeyImpl KeyHigh { get; internal set; }
    internal OracleShardingKeyImpl KeyLow { get; internal set; }
    internal List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> Keys { get; internal set; }
    internal HashRangeShardingKeys(OracleShardingKeyImpl keyHigh, OracleShardingKeyImpl keyLow);
    [CompilerGeneratedAttribute]
internal OracleShardingKeyImpl get_KeyHigh();
    [CompilerGeneratedAttribute]
internal void set_KeyHigh(OracleShardingKeyImpl value);
    [CompilerGeneratedAttribute]
internal OracleShardingKeyImpl get_KeyLow();
    [CompilerGeneratedAttribute]
internal void set_KeyLow(OracleShardingKeyImpl value);
    internal virtual List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> get_Keys();
    internal virtual void set_Keys(List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal List`1<ShardingKeys> Split(OracleShardingKeyImpl boundaryHash);
}
internal class OracleInternal.Sharding.InstanceInfo : object {
    [CompilerGeneratedAttribute]
private string <InstanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChunkName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ChunkId>k__BackingField;
    [CompilerGeneratedAttribute]
private ChunkStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    internal string InstanceName { get; internal set; }
    internal string ChunkName { get; internal set; }
    internal int ChunkId { get; internal set; }
    internal ChunkStatus Status { get; internal set; }
    internal int Priority { get; internal set; }
    internal InstanceInfo(string instanceName, string chunkName, int chunkId, ChunkStatus chunkStatus, int chunkPriority);
    [CompilerGeneratedAttribute]
internal string get_InstanceName();
    [CompilerGeneratedAttribute]
internal void set_InstanceName(string value);
    [CompilerGeneratedAttribute]
internal string get_ChunkName();
    [CompilerGeneratedAttribute]
internal void set_ChunkName(string value);
    [CompilerGeneratedAttribute]
internal int get_ChunkId();
    [CompilerGeneratedAttribute]
internal void set_ChunkId(int value);
    [CompilerGeneratedAttribute]
internal ChunkStatus get_Status();
    [CompilerGeneratedAttribute]
internal void set_Status(ChunkStatus value);
    [CompilerGeneratedAttribute]
internal int get_Priority();
    [CompilerGeneratedAttribute]
internal void set_Priority(int value);
}
internal class OracleInternal.Sharding.KggHashGenerator : object {
    internal static int hash(Byte[] buffer);
    internal static int hash(Byte[] k, int start, int end, int thebase);
}
internal class OracleInternal.Sharding.ListShardingKeys : ShardingKeys {
    private List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> m_keys;
    internal List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> Keys { get; internal set; }
    internal ListShardingKeys(List`1<OracleShardingKeyImpl> keys);
    internal virtual List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> get_Keys();
    internal virtual void set_Keys(List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> value);
    internal virtual bool Contains(OracleShardingKeyImpl key);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class OracleInternal.Sharding.ListSuperShardingKeys : SuperShardingKeys {
    private List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> m_keys;
    internal List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> Keys { get; internal set; }
    internal ListSuperShardingKeys(List`1<OracleShardingKeyImpl> keys);
    internal virtual List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> get_Keys();
    internal virtual void set_Keys(List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> value);
    public virtual int GetHashCode();
    internal virtual bool Contains(OracleShardingKeyImpl key);
    public virtual bool Equals(object obj);
}
internal class OracleInternal.Sharding.OracleShardingKeyImpl : object {
    private static int DEFAULT_CHAR_CHARSET;
    private static int DEFAULT_NCHAR_CHARSET;
    internal static long DEFAULT_ORA_HASH;
    private static long ORA_HASH_MAX_VALUE;
    internal int m_hashCode;
    internal ArrayList m_data;
    internal ArrayList m_oracleDbType;
    internal ArrayList m_subKeys;
    internal ArrayList m_defaultSubKeyMetadata;
    internal long m_shardKeyOraHash;
    [CompilerGeneratedAttribute]
private bool <IsSuperShardingKey>k__BackingField;
    private static NullShardingKeyType NULL_SHARD_KEY_LOW;
    private static NullShardingKeyType NULL_SHARD_KEY_HIGH;
    internal long ShardKeyOraHash { get; internal set; }
    internal bool IsSuperShardingKey { get; internal set; }
    private static OracleShardingKeyImpl();
    internal void Init();
    internal long get_ShardKeyOraHash();
    internal void set_ShardKeyOraHash(long value);
    [CompilerGeneratedAttribute]
internal bool get_IsSuperShardingKey();
    [CompilerGeneratedAttribute]
internal void set_IsSuperShardingKey(bool value);
    internal void SetShardingKey(OracleDbType oracleDbType, object data);
    internal void Build();
    internal bool IsValid(ShardingMetadata shardingMetadata);
    internal long ComputeShardKeyOraHash(ShardingMetadata metadata);
    public virtual int GetHashCode();
    private int GetBytesHashCode(Byte[] data);
    public virtual bool Equals(object obj);
    private sealed virtual override int System.IComparable<OracleInternal.Sharding.OracleShardingKeyImpl>.CompareTo(OracleShardingKeyImpl other);
    private int CompareBytes(Byte[] m, Byte[] n);
    public virtual string ToString();
    internal static int getInternalType(OracleDbType dataType);
    internal static OracleDbType getExternalType(int dataType);
    private static int getDefaultSubKeyCharSet(OracleDbType dataType);
    private static Byte[] EncodeInDBCharset(Byte[] subKey, OracleDbType oracleDbType, int dbCharset);
    private static Byte[] DecodeInStandardCharset(Byte[] dbEncodedKey, int dbCharSet, OracleDbType dbDataType);
    private static Type getSubKeyDataClass(OracleDbType dataType);
    internal string EncodeKeyinB64Format();
    internal static List`1<OracleShardingKeyImpl> DecodeKeys(Stream keysData, ShardingMetadata metadata, bool isSuperKey, bool isKeyHigh);
    internal static List`1<OracleShardingKeyImpl> DecodeKeys(List`1<Byte[]> subKeysByteArr, ShardingMetadata metadata, bool isSuperKey, bool isKeyHigh);
}
internal class OracleInternal.Sharding.RangeMap`2 : object {
    private List`1<K> rangeMapKeys;
    private List`1<RangeMapValue`2<K, V>> rangeMapValues;
    internal int Count { get; }
    internal void Put(K keyFloor, K keyCeiling, V value);
    internal void Put(K keyFloor, K keyCeiling, List`1<V> values);
    internal List`1<V> Get(K key);
    internal List`1<V> Get(K keyFloor, K keyCeiling);
    internal void Replace(K keyFloor, K keyCeiling, V oldValue, V newValue);
    internal void Remove(K keyFloor, K keyCeiling, V value);
    internal int get_Count();
    internal void Add(K keyFloor, K keyCeiling, List`1<V> values);
    internal void Add(K keyFloor, K keyCeiling, List`1<RangeMap`2<K, V>> nestedRanges, List`1<V> values);
    internal void Insert(K keyFloor, K keyCeiling, List`1<V> values);
    internal void Insert(K keyFloor, K keyCeiling, List`1<RangeMap`2<K, V>> nestedRanges, List`1<V> values);
    internal void Insert(K key, RangeMapValue`2<K, V> value);
    internal void Remove(K key);
    internal void AddRange(List`1<RangeMapValue`2<K, V>> range);
    internal void RemoveRange(int index, int count);
    internal void RemoveAt(int index);
    internal void Clear();
    internal List`1<RangeMapValue`2<K, V>> Submap(K fromKey, K toKey);
    internal void RemoveSubmap(List`1<RangeMapValue`2<K, V>> subMap);
    private bool isOneSameRange(List`1<RangeMapValue`2<K, V>> subMap, K keyFloor, K keyCeiling);
    private bool isOneLargerRange(List`1<RangeMapValue`2<K, V>> subMap, K keyFloor, K keyCeiling);
    private bool isOneSmallerRange(List`1<RangeMapValue`2<K, V>> subMap, K keyFloor, K keyCeiling);
    internal RangeMapValue`2<K, V> FloorEntry(K key);
    internal int FloorEntryIndex(K key);
}
internal class OracleInternal.Sharding.RangeMapValue`2 : object {
    [CompilerGeneratedAttribute]
private K <KeyFloor>k__BackingField;
    [CompilerGeneratedAttribute]
private K <KeyCeiling>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RangeMap`2<K, V>> <NestedRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<V> <Values>k__BackingField;
    internal K KeyFloor { get; internal set; }
    internal K KeyCeiling { get; internal set; }
    internal List`1<RangeMap`2<K, V>> NestedRanges { get; internal set; }
    internal List`1<V> Values { get; internal set; }
    internal RangeMapValue`2(K keyFloor, K keyCeiling, List`1<V> values);
    internal RangeMapValue`2(K keyFloor, K keyCeiling, List`1<RangeMap`2<K, V>> nestedRanges, List`1<V> values);
    [CompilerGeneratedAttribute]
internal K get_KeyFloor();
    [CompilerGeneratedAttribute]
internal void set_KeyFloor(K value);
    [CompilerGeneratedAttribute]
internal K get_KeyCeiling();
    [CompilerGeneratedAttribute]
internal void set_KeyCeiling(K value);
    [CompilerGeneratedAttribute]
internal List`1<RangeMap`2<K, V>> get_NestedRanges();
    [CompilerGeneratedAttribute]
internal void set_NestedRanges(List`1<RangeMap`2<K, V>> value);
    [CompilerGeneratedAttribute]
internal List`1<V> get_Values();
    [CompilerGeneratedAttribute]
internal void set_Values(List`1<V> value);
}
internal class OracleInternal.Sharding.RangeShardingKeys : ShardingKeys {
    private List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> m_keys;
    [CompilerGeneratedAttribute]
private OracleShardingKeyImpl <KeyHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private OracleShardingKeyImpl <KeyLow>k__BackingField;
    internal OracleShardingKeyImpl KeyHigh { get; internal set; }
    internal OracleShardingKeyImpl KeyLow { get; internal set; }
    internal List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> Keys { get; internal set; }
    internal RangeShardingKeys(OracleShardingKeyImpl keyHigh, OracleShardingKeyImpl keyLow);
    [CompilerGeneratedAttribute]
internal OracleShardingKeyImpl get_KeyHigh();
    [CompilerGeneratedAttribute]
internal void set_KeyHigh(OracleShardingKeyImpl value);
    [CompilerGeneratedAttribute]
internal OracleShardingKeyImpl get_KeyLow();
    [CompilerGeneratedAttribute]
internal void set_KeyLow(OracleShardingKeyImpl value);
    internal virtual List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> get_Keys();
    internal virtual void set_Keys(List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class OracleInternal.Sharding.RangeSuperShardingKeys : SuperShardingKeys {
    private List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> m_keys;
    [CompilerGeneratedAttribute]
private OracleShardingKeyImpl <KeyHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private OracleShardingKeyImpl <KeyLow>k__BackingField;
    internal OracleShardingKeyImpl KeyHigh { get; internal set; }
    internal OracleShardingKeyImpl KeyLow { get; internal set; }
    internal List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> Keys { get; internal set; }
    internal RangeSuperShardingKeys(OracleShardingKeyImpl keyHigh, OracleShardingKeyImpl keyLow);
    [CompilerGeneratedAttribute]
internal OracleShardingKeyImpl get_KeyHigh();
    [CompilerGeneratedAttribute]
internal void set_KeyHigh(OracleShardingKeyImpl value);
    [CompilerGeneratedAttribute]
internal OracleShardingKeyImpl get_KeyLow();
    [CompilerGeneratedAttribute]
internal void set_KeyLow(OracleShardingKeyImpl value);
    internal virtual List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> get_Keys();
    internal virtual void set_Keys(List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class OracleInternal.Sharding.RoutingKey : object {
    private int hashCode;
    [CompilerGeneratedAttribute]
private SuperShardingKeys <SuperShardingKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardingKeys <ShardingKeys>k__BackingField;
    internal SuperShardingKeys SuperShardingKeys { get; internal set; }
    internal ShardingKeys ShardingKeys { get; internal set; }
    internal RoutingKey(ShardingKeys keys, SuperShardingKeys superShardingKeys);
    [CompilerGeneratedAttribute]
internal SuperShardingKeys get_SuperShardingKeys();
    [CompilerGeneratedAttribute]
internal void set_SuperShardingKeys(SuperShardingKeys value);
    [CompilerGeneratedAttribute]
internal ShardingKeys get_ShardingKeys();
    [CompilerGeneratedAttribute]
internal void set_ShardingKeys(ShardingKeys value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RoutingKey other);
    public virtual string ToString();
}
internal abstract class OracleInternal.Sharding.ShardingKeys : object {
    [CompilerGeneratedAttribute]
private List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> <Keys>k__BackingField;
    internal List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> Keys { get; internal set; }
    [CompilerGeneratedAttribute]
internal virtual List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> get_Keys();
    [CompilerGeneratedAttribute]
internal virtual void set_Keys(List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> value);
    internal virtual bool Contains(OracleShardingKeyImpl key);
    internal virtual int CompareTo(ShardingKeys shardingKeys);
    public static bool Equals(object objA, object objB);
    public virtual string ToString();
}
internal class OracleInternal.Sharding.ShardingMetadata : object {
    internal static int SUPER_SHARDING_KEY_LEVEL;
    internal static int SHARDING_KEY_LEVEL;
    [CompilerGeneratedAttribute]
private ShardingType <ShardingType>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardingType <SuperShardingType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SubKeyMetadata> <ShardingKeyColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SubKeyMetadata> <SuperShardingKeyColumns>k__BackingField;
    internal ShardingType ShardingType { get; internal set; }
    internal ShardingType SuperShardingType { get; internal set; }
    internal List`1<SubKeyMetadata> ShardingKeyColumns { get; internal set; }
    internal List`1<SubKeyMetadata> SuperShardingKeyColumns { get; internal set; }
    internal ShardingMetadata(ShardingType shardingType, ShardingType superShardingType, List`1<SubKeyMetadata> keyColumns, List`1<SubKeyMetadata> superKeyColumns);
    private static ShardingMetadata();
    [CompilerGeneratedAttribute]
internal ShardingType get_ShardingType();
    [CompilerGeneratedAttribute]
internal void set_ShardingType(ShardingType value);
    [CompilerGeneratedAttribute]
internal ShardingType get_SuperShardingType();
    [CompilerGeneratedAttribute]
internal void set_SuperShardingType(ShardingType value);
    [CompilerGeneratedAttribute]
internal List`1<SubKeyMetadata> get_ShardingKeyColumns();
    [CompilerGeneratedAttribute]
internal void set_ShardingKeyColumns(List`1<SubKeyMetadata> value);
    [CompilerGeneratedAttribute]
internal List`1<SubKeyMetadata> get_SuperShardingKeyColumns();
    [CompilerGeneratedAttribute]
internal void set_SuperShardingKeyColumns(List`1<SubKeyMetadata> value);
}
internal class OracleInternal.Sharding.ShardingRangeMap : object {
    private ShardRoutingCache m_shardRoutingCache;
    private RangeMap`2<OracleShardingKeyImpl, RangeMap`2<long, Chunk>> hashRangeMap;
    private RangeMap`2<long, Chunk> defaultHashRangeMap;
    private RangeMap`2<OracleShardingKeyImpl, RangeMap`2<OracleShardingKeyImpl, Chunk>> rangeMap;
    private RangeMap`2<OracleShardingKeyImpl, Chunk> defaultRangeMap;
    internal ShardingRangeMap(ShardRoutingCache shardRoutingCache);
    internal void Put(RoutingKey routingKey, Chunk chunk);
    internal List`1<Chunk> Get(OracleShardingKeyImpl superShardingKey, OracleShardingKeyImpl shardingKey);
    internal HashSet`1<Chunk> Get(RoutingKey routingKey);
    internal void Replace(RoutingKey routingKey, Chunk oldChunk, Chunk newChunk);
    internal void Remove(RoutingKey routingKey, Chunk chunk);
    internal void Clear();
}
internal enum OracleInternal.Sharding.ShardingType : Enum {
    public int value__;
    public static ShardingType NONE;
    public static ShardingType HASH;
    public static ShardingType LIST;
    public static ShardingType RANGE;
}
internal class OracleInternal.Sharding.ShardRoutingCache : object {
    private ShardingMetadata shardingMetadata;
    private ShardingRangeMap shardingRangeMap;
    private Dictionary`2<RoutingKey, Chunk> keysToChunks;
    private Dictionary`2<Chunk, HashSet`1<RoutingKey>> chunksToKeys;
    private Dictionary`2<Tuple`2<string, string>, HashSet`1<RoutingKey>> instsAndChunkNamesToKeys;
    private Dictionary`2<Tuple`2<string, string>, HashSet`1<Chunk>> instsAndChunkAbsNamesToChunks;
    private List`1<string> m_instances;
    private ReaderWriterLockSlim rwLock;
    private static int rwLockTimeout;
    internal void OnConnectionCreation(OracleConnectionImpl connImpl);
    internal void OnConnectionCreation(OracleConnection conn);
    internal void OnErrorInvalidateChunk(string instanceName, string chunkName);
    internal void OnErrorInvalidateChunkForInstance(string instanceName, string chunkName);
    internal void OnAddChunk(OracleChunkEventArgs chunkEventArgs);
    internal void OnAddChunkValues(OracleChunkEventArgs chunkEventArgs);
    internal void OnDropChunk(OracleChunkEventArgs chunkEventArgs);
    internal void OnDropChunkValues(OracleChunkEventArgs chunkEventArgs);
    internal void OnMergeChunk(OracleChunkEventArgs chunkEventArgs);
    internal void OnInvalidateChunk(OracleChunkEventArgs chunkEventArgs);
    internal void OnMigrateChunk(OracleChunkEventArgs chunkEventArgs);
    internal void OnRemoveChunk(OracleChunkEventArgs chunkEventArgs);
    internal void OnSplitChunk(OracleChunkEventArgs chunkEventArgs);
    internal void OnSplitPartitionset(OracleChunkEventArgs chunkEventArgs);
    internal void OnNewPartitionset(OracleChunkEventArgs chunkEventArgs);
    internal void TraceTopologyForChunk(OracleChunkEventArgs chunkEventArgs, Chunk chunk, string chunkInstance, RoutingKey routingKey);
    internal String[] GetAllPriorityInstances(OracleShardingKeyImpl superShardingKey, OracleShardingKeyImpl shardingKey, bool bReadOnlyChunkOK, String& chunkName, Int32& chunkId, String[]& excludedInstances, InstanceInfo[]& includedInstanceInfos);
    internal List`1<string> GetAllInstances(OracleShardingKeyImpl superShardingKey, OracleShardingKeyImpl shardingKey);
    private bool ValidateShardKeys(OracleShardingKeyImpl superShardingKey, OracleShardingKeyImpl shardingKey);
    internal void ClearCache();
    private List`1<Chunk> GetChunks(OracleShardingKeyImpl superShardingKey, OracleShardingKeyImpl shardingKey);
    internal long GetShardKeyOraHash(OracleShardingKeyImpl key);
    private HashSet`1<Chunk> GetChunks(string instanceName, string chunkAbsName);
    private HashSet`1<Chunk> GetChunks(string chunkAbsName);
    private Chunk GetMatchingChunk(string instanceName, string chunkAbsName);
    private bool BuildTopologyForInstance(OracleConnection connection, string serviceName);
    private Chunk Update(RoutingKey routingKey, string chunkName, bool fUpdateName);
    private RoutingKey GetRoutingKeysForVersionedChunk(string instanceName, string chunkName);
    private void Put(RoutingKey routingKey, Chunk chunk);
    private void AddToInstanceRelatedCaches(string instanceName, Chunk chunk, RoutingKey routingKey);
    private void PutNameToKey(string instanceName, Chunk chunk, RoutingKey routingKey);
    private void PutNameToChunk(string instanceName, Chunk chunk);
    private void Replace(RoutingKey routingKey, Chunk oldChunk, Chunk newChunk);
    private Chunk Get(RoutingKey routingKey);
    private void Remove(Chunk chunk);
    private void RemoveFromInstanceRelatedCaches(string instanceName, Chunk chunk);
    private void RemoveNameToKey(string instanceName, Chunk chunk);
    private void RemoveNameToChunk(string instanceName, Chunk chunk);
    private void Cleanup();
    private RoutingKey MakeRoutingKey(Metadata chunkInfo, SuperShardingKeys defaultSSKeys, SuperShardingKeys preSplitSSKeys, int dbServerVersion);
    private RoutingKey DecodeUserShardingKeys(String[] sKeys, bool isSuperShardingKey, ShardingKeys shardingKeysParam);
    private List`1<Metadata> FetchInstanceChunksMetadata(OracleConnection conn, string serviceName);
    private void FetchShardingMetadata(OracleConnection conn, string serviceName);
}
internal class OracleInternal.Sharding.SubKeyMetadata : object {
    [CompilerGeneratedAttribute]
private int <ColIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private OracleDbType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CharSet>k__BackingField;
    internal int ColIndex { get; internal set; }
    internal OracleDbType DataType { get; internal set; }
    internal int CharSet { get; internal set; }
    internal SubKeyMetadata(int index, OracleDbType dataType, int charSet);
    [CompilerGeneratedAttribute]
internal int get_ColIndex();
    [CompilerGeneratedAttribute]
internal void set_ColIndex(int value);
    [CompilerGeneratedAttribute]
internal OracleDbType get_DataType();
    [CompilerGeneratedAttribute]
internal void set_DataType(OracleDbType value);
    [CompilerGeneratedAttribute]
internal int get_CharSet();
    [CompilerGeneratedAttribute]
internal void set_CharSet(int value);
    public sealed virtual int CompareTo(SubKeyMetadata o);
}
internal abstract class OracleInternal.Sharding.SuperShardingKeys : object {
    [CompilerGeneratedAttribute]
private List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> <Keys>k__BackingField;
    internal List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> Keys { get; internal set; }
    [CompilerGeneratedAttribute]
internal virtual List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> get_Keys();
    [CompilerGeneratedAttribute]
internal virtual void set_Keys(List`1<Tuple`2<OracleShardingKeyImpl, OracleShardingKeyImpl>> value);
    internal virtual bool Contains(OracleShardingKeyImpl key);
    internal virtual int CompareTo(SuperShardingKeys superKeys);
    public static bool Equals(object objA, object objB);
    public virtual string ToString();
}
internal abstract class OracleInternal.TTC.Accessors.Accessor : object {
    protected bool m_bForBind;
    internal bool m_bForReturningParameter;
    internal SqlStatementType m_statementType;
    internal OraType m_internalType;
    protected int m_internalTypeMaxLength;
    internal OraType m_definedColumnType;
    internal ColumnDescribeInfo m_colMetaData;
    internal MarshallingEngine m_marshallingEngine;
    protected int m_byteLength;
    internal int m_lastRowProcessed;
    internal List`1<ArraySegment`1<byte>> m_colDataSegments;
    internal List`1<List`1<ArraySegment`1<byte>>> m_RowDataSegments;
    internal List`1<int> m_totalLengthOfData;
    internal List`1<ArraySegment`1<byte>> m_LastRowDataSegments;
    internal int m_LastRowtotalLengthOfData;
    internal bool m_bNullByDescribe;
    internal bool m_bReceivedOutValueFromServer;
    internal bool NoRowsAffected { get; }
    internal Accessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal static Accessor CreateAccessorForDefine(MarshallingEngine mEngine, ColumnDescribeInfo colMetaData, int initialLongFetchSize, long initialLOBFetchSize, long initialJSONFetchSize, bool bDefineDone, bool bLOBArrayFetchRequired, int numRowsRequested);
    internal static Accessor CreateAccessorForBind(MarshallingEngine mEngine, ColumnDescribeInfo colMetaData, SqlStatementType stmtType, int initialLongFetchSize, long initialJSONFetchSize, int numRowsRequested);
    private static Accessor CreateAccessor(MarshallingEngine mEngine, ColumnDescribeInfo colMetaData, bool bForBind, int initialLongFetchSize, long initialLOBFetchSize, long initialJSONFetchSize, bool bDefineDone, bool bLOBArrayFetchRequired, int numRowsRequested);
    internal virtual void InitForDataAccess(int max_len);
    internal virtual void Unimplemented(string methodName);
    internal virtual string GetString(int currentRow, Char[] charArrayFromPooler);
    internal int GetCharsFromBuffer(Byte[] rawData, int rawDataLen, long fieldOffset, Char[] buffer, int bufferOffset, int noOfCharsReqd, byte charSetForm);
    internal string GetString(Byte[] rawBytesToConvert, int byteOffset, int length, byte charSetForm, Char[] charArrayForConversion);
    internal virtual string GetString(int currentRow, byte charSetForm, Char[] charArrayFromPooler);
    internal virtual string GetString(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual string GetString(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, byte charSetForm);
    internal virtual int GetInt(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual int GetInt(int currentRow);
    internal virtual double GetDouble(int currentRow);
    internal virtual double GetDouble(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual double GetDouble(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual float GetFloat(int currentRow);
    internal virtual float GetFloat(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual float GetFloat(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual decimal GetDecimal(int currentRow);
    internal virtual DateTime GetDateTime(int currentRow);
    internal virtual DateTime GetDateTime(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual DateTime GetDateTime(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual void GetInternalDataRef(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& dataByteRep, Int32& dataOffset, Int32& dataLength);
    internal virtual Byte[] GetByteRepresentation(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual Byte[] GetByteRepresentation(int currentRow);
    internal virtual bool IsNullIndicatorSet(int currentRow);
    internal virtual bool IsNullIndicatorSet(DataUnmarshaller dataUnmarshaller, int columnCount, int currentRow, int columnIndex);
    internal virtual void UnmarshalColumnData(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.Accessor/<UnmarshalColumnDataAsync>d__47")]
internal virtual ValueTask UnmarshalColumnDataAsync(bool bAsync);
    internal bool get_NoRowsAffected();
    internal void AddNullForData();
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.Accessor/<UnmarshalOneRowAsync>d__51")]
internal virtual ValueTask`1<bool> UnmarshalOneRowAsync(bool bAsync);
    internal virtual bool UnmarshalOneRow(bool bAsync);
    internal void CopyRow_ScanOnly();
    internal virtual object GetValue();
    internal static int CopyDataToUserBuffer(List`1<ArraySegment`1<byte>> dataSegments, int dataOffset, Byte[] userBuffer, int userBuffOffset, int dataLength);
    internal static byte GetValueAt(List`1<ArraySegment`1<byte>> dataSegments, int dataOffset);
    internal virtual void Initialize(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal void Initialize();
}
internal class OracleInternal.TTC.Accessors.LobPrefetchContext : object {
    internal int m_chunkSize;
    internal long m_totalLobSize;
    internal bool m_bDbVaryingWidth;
    internal short m_clobCharSet;
    internal byte m_clobFormOfUse;
    internal Byte[] m_lobPrefetchData;
    internal int m_lobDataLength;
}
internal class OracleInternal.TTC.Accessors.LobPrefetchInfo : object {
    internal int m_chunkSize;
    internal bool m_bDbVaryingWidth;
    internal short m_clobCharSet;
    internal byte m_clobFormOfUse;
    internal List`1[] m_prefetchedData;
    internal Int64[] m_totalLobSizeInDB;
    internal Int64[] m_prefetchedDataLength;
    internal LobPrefetchInfo(int numRowsRequested);
    internal void ReInit(int numRowsRequested);
}
internal class OracleInternal.TTC.Accessors.riddef : ValueType {
    internal UInt32 ridobjnum;
    internal ushort idfilenum;
    internal byte filler;
    internal UInt32 ridblocknum;
    internal ushort ridslotnum;
}
internal class OracleInternal.TTC.Accessors.TTCBinaryDoubleAccessor : Accessor {
    internal static int BINARY_DOUBLE_MAX_LENGTH;
    internal TTCBinaryDoubleAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    private static TTCBinaryDoubleAccessor();
    internal virtual void InitForDataAccess(int max_len);
    internal double GetValue(int currentRow);
    internal double GetValue(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal double GetValue(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual double GetDouble(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual double GetDouble(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual double GetDouble(int currentRow);
    internal static double GetDoubleFromByteArray(Byte[] byteVal, int startOffset);
    internal static bool DoubleToCanonicalFormatBytes(double d, Byte[] b);
    public static Byte[] DoubleToCanonicalFormatBytes(double d);
}
internal class OracleInternal.TTC.Accessors.TTCBinaryFloatAccessor : Accessor {
    internal static int BINARY_FLOAT_MAX_LENGTH;
    internal TTCBinaryFloatAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    private static TTCBinaryFloatAccessor();
    internal virtual void InitForDataAccess(int max_len);
    internal static float GetFloatFromByteArray(Byte[] byteVal, int startOffset);
    internal float GetValue(int currentRow);
    internal float GetValue(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal float GetValue(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual float GetFloat(int currentRow);
    internal virtual float GetFloat(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual float GetFloat(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    public static bool FloatToCanonicalFormatBytes(float f, Byte[] b);
    public static Byte[] FloatToCanonicalFormatBytes(float f);
}
internal class OracleInternal.TTC.Accessors.TTCDateTimeAccessor : Accessor {
    internal static int ORACLE_CENTURY;
    internal static int ORACLE_YEAR;
    internal static int ORACLE_MONTH;
    internal static int ORACLE_DAY;
    internal static int ORACLE_HOUR;
    internal static int ORACLE_MIN;
    internal static int ORACLE_SEC;
    internal static int ORACLE_NANO1;
    internal static int ORACLE_NANO2;
    internal static int ORACLE_NANO3;
    internal static int ORACLE_NANO4;
    internal static int ORACLE_TZ1;
    internal static int ORACLE_TZ2;
    internal static int MAX_DATE_LENGTH;
    internal static int MAX_TIMESTAMP_LENGTH;
    internal static int MAX_TIMESTAMP_LTZ_LENGTH;
    internal static int MAX_TIMESTAMP_TZ_LENGTH;
    internal static byte MinMinute;
    internal static byte MinHour;
    internal static byte MinDay;
    internal static byte MinMonth;
    internal static short MinYear;
    internal static byte MaxMinute;
    internal static byte MaxHour;
    internal static byte MaxDay;
    internal static byte MaxMonth;
    internal TTCDateTimeAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal virtual void InitForDataAccess(int max_len);
    internal virtual Byte[] GetByteRepresentation(int currentRow);
    internal virtual Byte[] GetByteRepresentation(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual DateTime GetDateTime(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual DateTime GetDateTime(int currentRow);
    internal static void GetOracleDate(Byte[] byteRep, DateTime paramVal);
}
internal class OracleInternal.TTC.Accessors.TTCIntervalTypeAccessor : Accessor {
    internal static int INTERVALTYPE_MAX_LENGTH;
    internal TTCIntervalTypeAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    private static TTCIntervalTypeAccessor();
    internal virtual void InitForDataAccess(int max_len);
}
internal class OracleInternal.TTC.Accessors.TTCJsonAccessor : TTCLobAccessor {
    internal TTCJsonAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind, long internalInitialJSONFS, bool bDefineDone, bool bJSONArrayFetchRequired, int numRowsRequested);
}
internal class OracleInternal.TTC.Accessors.TTCLobAccessor : Accessor {
    internal static int MAX_LENGTH;
    internal long m_internalInitialLOBFS;
    private LobPrefetchContext m_lobPrefetchCtx;
    internal bool m_isDefineDone;
    private Int32[] m_tempIntArr;
    internal List`1[] m_lobLocators;
    internal LobPrefetchInfo m_prefetchInfo;
    internal List`1[] m_dataThroughLobArrayRead;
    private bool m_bLOBArrayFetchRequired;
    internal TTCLobAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind, long internalInitialLOBFS, bool bDefineDone, bool bLOBArrayFetchRequired, int numRowsRequested);
    internal virtual void Initialize(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal void ReInit(bool bLOBArrayFetchRequired, long initialLOBFetchSize, int numRowsRequested);
    internal virtual void InitForDataAccess(int max_len);
    internal virtual bool IsNullIndicatorSet(int currentRow);
    internal void ReadPrefetchInformation(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCLobAccessor/<ReadPrefetchInformationAsync>d__15")]
internal ValueTask ReadPrefetchInformationAsync(bool bAsync);
    internal void ReadPrefetchInformation(DataUnmarshaller dataUnmarshaller, bool bNotNull, int currentRow, bool bIgnorePrefetchData);
    internal virtual void UnmarshalColumnData(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCLobAccessor/<UnmarshalColumnDataAsync>d__18")]
internal virtual ValueTask UnmarshalColumnDataAsync(bool bAsync);
    internal virtual bool UnmarshalOneRow(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCLobAccessor/<UnmarshalOneRowAsync>d__20")]
internal virtual ValueTask`1<bool> UnmarshalOneRowAsync(bool bAsync);
    internal Byte[] GetLobLocator(int currentRow);
    internal bool AbstractOrTempLOB(int currentRow);
    internal virtual Byte[] GetByteRepresentation(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal void GetLobData(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& lobLocator, LobPrefetchContext& prefetchCtx);
    internal long GetTotalLobLengthInDB(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, bool bLOBArrayReadDone);
    internal void GetLOBInfoForArrayRead(int rowIdx, Int64& prefetchedDataLength, Byte[]& lobLocator, Int64& dataLengthInDB);
    internal void GetLOBPrefetchInfo(int rowIdx, List`1& prefetchedData, Int64& prefetchedDataLength, Int64& dataLengthInDB, Boolean& bIsNClob);
}
internal class OracleInternal.TTC.Accessors.TTCLongAccessor : Accessor {
    internal static int MAX_LENGTH;
    internal static int DEFAULT_FETCH_SIZE;
    internal int m_longFetchSize;
    private int m_escapeSequence;
    private bool m_readHeader;
    private bool m_readAsNonStream;
    internal TTCLongAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind, int initialLongFetchSize);
    internal virtual void Initialize(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal int UnmarshalHelper(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    private int ReadStreamLocally(DataUnmarshaller dataUnmarshaller);
    internal long FillDataInUserBuffer(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, long fieldOffset, Byte[] buffer, int bufferOffset, int length);
    internal long FillDataInUserBuffer(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, long fieldOffset, Char[] buffer, int bufferOffset, int numCharsToCopy);
    internal virtual Byte[] GetByteRepresentation(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual string GetString(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual string GetString(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, byte charSetForm);
    internal long GetBytes(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, long fieldOffset, Byte[] buffer, int bufferOffset, int length);
    internal long GetChars(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, long fieldOffset, Char[] buffer, int bufferOffset, int length);
    internal virtual void UnmarshalColumnData(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCLongAccessor/<UnmarshalColumnDataAsync>d__18")]
internal virtual ValueTask UnmarshalColumnDataAsync(bool bAsync);
    internal virtual bool UnmarshalOneRow(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCLongAccessor/<UnmarshalOneRowAsync>d__20")]
internal virtual ValueTask`1<bool> UnmarshalOneRowAsync(bool bAsync);
    private int ReadStreamFromWire_ScanOnly(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCLongAccessor/<ReadStreamFromWire_ScanOnlyAsync>d__22")]
private ValueTask`1<int> ReadStreamFromWire_ScanOnlyAsync(bool bAsync);
    internal bool IsCompleteDataAvailable(int currentRow);
    internal int AvailableDataSize(int currentRow);
}
internal class OracleInternal.TTC.Accessors.TTCNamedTypeAccessor : Accessor {
    internal static int CharacterSetId;
    internal static int MaxLength;
    internal string m_typeName;
    internal TTCNamedTypeAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind, string typeName);
    internal TTCNamedTypeAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal void UnmarshalColumnData(int dataLength, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCNamedTypeAccessor/<UnmarshalColumnDataAsync>d__6")]
internal Task UnmarshalColumnDataAsync(int dataLength, bool bAsync);
    internal virtual void UnmarshalColumnData(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCNamedTypeAccessor/<UnmarshalColumnDataAsync>d__8")]
internal virtual ValueTask UnmarshalColumnDataAsync(bool bAsync);
    internal virtual bool UnmarshalOneRow(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCNamedTypeAccessor/<UnmarshalOneRowAsync>d__10")]
internal virtual ValueTask`1<bool> UnmarshalOneRowAsync(bool bAsync);
    internal virtual bool IsNullIndicatorSet(int currentRow);
}
internal class OracleInternal.TTC.Accessors.TTCNumberAccessor : Accessor {
    internal static int NUM_MAX_LENGTH;
    internal TTCNumberAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal virtual void InitForDataAccess(int max_len);
    internal virtual Byte[] GetByteRepresentation(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual Byte[] GetByteRepresentation(int currentRow);
    internal virtual int GetInt(int currentRow);
    internal virtual double GetDouble(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual double GetDouble(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual double GetDouble(int currentRow);
    internal virtual float GetFloat(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual float GetFloat(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, Byte[]& byteRep);
    internal virtual float GetFloat(int currentRow);
}
internal class OracleInternal.TTC.Accessors.TTCPLSQLAssociativeArrayAccessor : Accessor {
    internal int m_noOfElements;
    internal List`1[] m_plsqlAssociativeArray;
    internal Int32[] m_sizeOfEachElement;
    internal TTCPLSQLAssociativeArrayAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine);
    internal virtual bool UnmarshalOneRow(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCPLSQLAssociativeArrayAccessor/<UnmarshalOneRowAsync>d__5")]
internal virtual ValueTask`1<bool> UnmarshalOneRowAsync(bool bAsync);
    internal List`1[] GetPlSqlAssociativeArray();
    internal Int32[] GetElementSizes();
}
internal class OracleInternal.TTC.Accessors.TTCPLSQLBooleanAccessor : Accessor {
    internal static int MAX_BOOLEAN_LENGTH;
    internal static Byte[] TRUE_VAL_BYTES;
    internal static Byte[] FALSE_VAL_BYTES;
    internal TTCPLSQLBooleanAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    private static TTCPLSQLBooleanAccessor();
    internal object GetBooleanValue(int currentRow);
}
internal class OracleInternal.TTC.Accessors.TTCRawAccessor : Accessor {
    internal TTCRawAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal virtual Byte[] GetByteRepresentation(int currentRow);
    internal virtual Byte[] GetByteRepresentation(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal long GetDataInBuffer(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, long fieldOffset, Byte[] buffer, int bufferOffset, int length);
    internal long GetDataLen(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
}
internal class OracleInternal.TTC.Accessors.TTCRefAccessor : Accessor {
    internal static int MAXLENGTH;
    internal string m_typeName;
    internal TTCRefAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal virtual Byte[] GetByteRepresentation(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual void UnmarshalColumnData(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCRefAccessor/<UnmarshalColumnDataAsync>d__5")]
internal virtual ValueTask UnmarshalColumnDataAsync(bool bAsync);
    internal virtual bool UnmarshalOneRow(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCRefAccessor/<UnmarshalOneRowAsync>d__7")]
internal virtual ValueTask`1<bool> UnmarshalOneRowAsync(bool bAsync);
    private int UnmarshalCLRForRef_ScanOnly(MarshallingEngine mEngine, short firstByteLength, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCRefAccessor/<UnmarshalCLRForRef_ScanOnlyAsync>d__9")]
private ValueTask`1<int> UnmarshalCLRForRef_ScanOnlyAsync(MarshallingEngine mEngine, short firstByteLength, bool bAsync);
    private int UnmarshalCLRForRef_ScanOnly(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
}
internal class OracleInternal.TTC.Accessors.TTCRefCursorAccessor : Accessor {
    internal List`1<TTCResultSet> m_TTCResultSetList;
    internal bool m_bAccessedByReader;
    unknown Accessor[] DefineAccessorForCurrentRow {internal set; }
    internal SQLMetaData SqlMetaDataForCurrentRow { get; }
    internal TTCRefCursorAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine);
    internal virtual void Initialize(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal virtual Byte[] GetByteRepresentation(int currentRow);
    internal virtual bool IsNullIndicatorSet(int currentRow);
    internal TTCResultSet GetResultSet(int currentRow);
    internal void set_DefineAccessorForCurrentRow(Accessor[] value);
    internal SQLMetaData get_SqlMetaDataForCurrentRow();
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCRefCursorAccessor/<UnmarshalColumnDataAsync>d__11")]
internal virtual ValueTask UnmarshalColumnDataAsync(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCRefCursorAccessor/<UnmarshalOneRowAsync>d__12")]
internal virtual ValueTask`1<bool> UnmarshalOneRowAsync(bool bAsync);
    internal virtual void UnmarshalColumnData(bool bAsync);
    internal virtual bool UnmarshalOneRow(bool bAsync);
}
internal class OracleInternal.TTC.Accessors.TTCResultSet : object {
    private SQLMetaData m_sqlMetaData;
    private int m_cursorId;
    private Accessor[] m_defineAccessor;
    internal SQLMetaData SqlMetaData { get; }
    internal int CursorId { get; internal set; }
    internal Accessor[] DefineAccessors { get; internal set; }
    internal SQLMetaData get_SqlMetaData();
    internal int get_CursorId();
    internal void set_CursorId(int value);
    internal Accessor[] get_DefineAccessors();
    internal void set_DefineAccessors(Accessor[] value);
}
internal class OracleInternal.TTC.Accessors.TTCRowIdAccessor : Accessor {
    private RowIdType m_rowidType;
    private Int32[] m_temp;
    internal static int ROWID_MAX_LENGTH;
    internal static int KGRD_RESTRICTED_BLOCK;
    internal static int KGRD_RESTRICTED_FILE;
    internal static int KGRD_RESTRICTED_SLOT;
    internal static int KGRD_EXTENDED_OBJECT;
    internal static int KGRD_EXTENDED_BLOCK;
    internal static int KGRD_EXTENDED_FILE;
    internal static int KGRD_EXTENDED_SLOT;
    internal static int KD4_UBRIDLEN_TYPEIND;
    internal static int KD4_UBRIDLEN_PHYSOBJD;
    internal static int KD4_UBRIDLEN_PHYSFNO;
    internal static int KD4_UBRIDLEN_PHYSBNO;
    internal static int KD4_UBRIDLEN_PHYSSNO;
    internal static int FILENUMBEROFFSET;
    internal static int BLOCKNUMBEROFFSET;
    internal static int SLOTNUMBEROFFSET;
    internal static ushort physicalRowID;
    internal static int typeOfRowIdIndex;
    internal static Byte[] KGRD_BASIS_64;
    internal static Byte[] KGRD_INDBYTE_CHAR;
    internal static SByte[] KGRD_INDEX_64;
    internal TTCRowIdAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    private static TTCRowIdAccessor();
    internal virtual void InitForDataAccess(int max_len);
    internal virtual void UnmarshalColumnData(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCRowIdAccessor/<UnmarshalColumnDataAsync>d__27")]
internal virtual ValueTask UnmarshalColumnDataAsync(bool bAsync);
    internal virtual bool UnmarshalOneRow(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.Accessors.TTCRowIdAccessor/<UnmarshalOneRowAsync>d__29")]
internal virtual ValueTask`1<bool> UnmarshalOneRowAsync(bool bAsync);
    private Byte[] ROWIDToByteArray(long rba, long partitionID, long blockNumber, long slotNumber);
    private int kgrd42b(Byte[] charsAsBytes, long value, int size, int offset);
    private Byte[] PhysicalROWIDToByteArray(Byte[] byteStream);
    private void ConvertToExtendedFormat(riddef ridRowID, Byte[] byteArray);
    private Byte[] LogicalROWIDToByteArray(Byte[] byteStream);
    private void PopulateRowIdStructFromByteStream(Byte[] bytes, riddef& rowId);
    private ushort Get2Bytes(Byte[] bytes, int offset);
    private UInt32 Get4Bytes(Byte[] bytes, int offset);
    private void ConvertToRestrictedFormat(riddef ridRowId, Byte[] bytes);
    private void kgrdub2c(Byte[] bytes, int size, int offset, Byte[] dstBytes, int dstOffset);
    internal int UnmarshalHelper(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual string GetString(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, byte charSetForm);
    internal long GetChars(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, long fieldOffset, Char[] buffer, int bufferOffset, int noOfCharsReqd);
}
internal class OracleInternal.TTC.Accessors.TTCUdtAccessor : TTCNamedTypeAccessor {
    private UDTPickleContextReader m_imageReader;
    private IUDTPickleNamedInst m_cacheUdtInst;
    private Utf8JsonWriter m_jsonWriter;
    private MemoryStream m_jsonStream;
    internal bool m_bSuppressGetDecimalInvalidCastException;
    internal TTCUdtAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    private IUDTPickleNamedInst GetUDTInst(OracleConnection conn, UDTNamedType udtType, UDTPickleContextReader imageReader, bool bForBind);
    private UDTPickleContextReader GetUDTReader(List`1<ArraySegment`1<byte>> dataSegments, int length);
    private Utf8JsonWriter GetJsonWriter();
    private object GetCustomObject(OracleConnection conn, UDTNamedType udtType, UDTPickleContextReader imageReader, bool bFromBind);
    private string GetUDTJsonString(OracleConnection conn, UDTNamedType udtType, UDTPickleContextReader imageReader, bool bFromBind);
    internal object GetCustomObject(OracleConnection conn, UDTNamedType udtType, DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal string GetUDTJsonString(OracleConnection conn, UDTNamedType udtType, DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal object GetCustomObject(OracleConnection conn, UDTNamedType udtType, int currentRow);
    internal object GetUDTJsonString(OracleConnection conn, UDTNamedType udtType, int currentRow);
    internal void ReleaseUDT(bool bClose);
}
internal class OracleInternal.TTC.Accessors.TTCVarcharAccessor : Accessor {
    internal TTCVarcharAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal virtual Byte[] GetByteRepresentation(int currentRow);
    internal virtual string GetString(int currentRow, byte charSetForm, Char[] charArrayFromPooler);
    internal virtual string GetString(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex);
    internal virtual string GetString(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, byte charSetForm);
    internal int GetCharsFromBuffer(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, long fieldOffset, Char[] buffer, int bufferOffset, int noOfCharsReqd, byte charSetForm);
    internal int GetCharLengthFromBuffer(DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, long fieldOffset, byte charSetForm);
}
internal class OracleInternal.TTC.Accessors.TTCVectorAccessor : TTCJsonAccessor {
    private VectorImageReader m_imageReader;
    internal TTCVectorAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind, long internalInitialJSONFS, bool bDefineDone, bool bJSONArrayFetchRequired, int numRowsRequested);
    internal VectorImageReader GetImageReader(Byte[] vectorImage);
}
internal class OracleInternal.TTC.Accessors.TTCXmlTypeAccessor : TTCNamedTypeAccessor {
    internal TTCXmlTypeAccessor(ColumnDescribeInfo colMetaData, MarshallingEngine marshallingEngine, bool bForBind);
    internal void UnpickleXmlType(OracleConnectionImpl connImpl, DataUnmarshaller dataUnmarshaller, int currentRow, int columnIndex, OraXmlTypeHeader xmlTypeHeader, OraXmlTypeData& xmlTypeData);
    internal void UnpickleXmlType(OracleConnectionImpl connImpl, int currentRow, OraXmlTypeHeader xmlTypeHeader, OraXmlTypeData& xmlTypeData);
    internal static void UnpickleXmlType(OracleConnectionImpl connImpl, UDTPickleContextReader imageReader, OraXmlTypeHeader xmlTypeHeader, OraXmlTypeData& xmlTypeData);
    internal static void UnpickleXmlData(OracleConnectionImpl connImpl, UDTPickleContextReader imageReader, OraXmlTypeHeader xmlTypeHeader, OraXmlTypeData xmlTypeData);
}
internal class OracleInternal.TTC.AppContCtlCtx : object {
    internal long m_flags_kpdxcAppContCtl;
    internal short m_queue_kpdxcAppContCtl;
    internal Byte[] m_replayctx_kpdxcAppContCtl;
    internal long m_errcode_kpdxcAppContCtl;
    internal AppContCtlCtx(long flags_kpdxcAppContCtl, short queue_kpdxcAppContCtl, Byte[] replayctx_kpdxcAppContCtl, long errcode_kpdxcAppContCtl);
}
internal class OracleInternal.TTC.AQMessage : object {
    private MarshallingEngine m_mEngine;
    internal OracleAQMessage properties;
    internal Byte[] senderAgentName;
    internal int senderAgentNameLength;
    internal Byte[] senderAgentAddress;
    internal int senderAgentAddressLength;
    internal byte senderAgentProtocol;
    internal Byte[] originalMsgId;
    internal AQMessage(MarshallingEngine mEngine);
    internal void Receive();
    internal OracleAQMessage GetAqMessageProperties();
}
internal class OracleInternal.TTC.DatabaseSessionState : object {
    internal StateSignatures m_stateSignatures;
    internal BigInteger m_templateId;
    internal Byte[] m_fullOverflow;
    internal ArrayList m_deltaOverflows;
    internal DatabaseSessionState Copy();
    internal void Update(StateSignatures stateSignatures, TemplateOverflow templateOverflow);
    internal string toString();
}
internal class OracleInternal.TTC.DirectPathStream : object {
    internal List`1<DirectPathRow> m_dpRows;
    internal List`1<BulkCopyBindingRow> m_bindingRows;
    internal DirectPathRow m_dpRowToAdd;
    internal BulkCopyBindingRow m_bindingRowToAdd;
    internal int m_streamSize;
    internal void Reset();
    internal void ResetForNextStream();
    internal bool Add(DirectPathRow dpRow, BulkCopyBindingRow bindingRow);
}
internal class OracleInternal.TTC.MarshallingEngine : object {
    private static int TTCC_MXL;
    internal static int TTCC_ESC;
    internal static int TTCC_LNG;
    internal static int TTCC_ERR;
    internal static int TTCC_MXIN_NEW;
    internal static int TTCC_MXIN_OLD;
    internal int m_effectiveTTCC_MXIN;
    internal static byte TTCLXMULTI;
    internal static byte TTCLXMCONV;
    private static int FLUSH_DATA_SIZE_THRESHOLD;
    internal int m_numOBThresholdForSends;
    private int m_DBVersion;
    private bool m_bHasFSAPCapability;
    internal bool m_hasEOCSCapability;
    internal bool m_bUseBigCLRChunks;
    internal bool m_bServerUsingBigSCN;
    internal bool m_bServerHasAutoSessRestoreCapability;
    internal TTCTypeRepresentation m_typeRepresentation;
    internal OracleCommunication m_oracleCommunication;
    internal byte m_negotiatedTTCVersion;
    internal long m_endOfCallStatus;
    private byte m_sequenceNumber;
    internal bool m_bDRCPConnection;
    internal bool m_bDRCPSessionAttached;
    internal int m_endToEndECIDSequenceNumber;
    internal Byte[] ignored;
    internal Byte[] tmpBuffer2;
    internal Byte[] tmpBuffer4;
    internal Byte[] tmpBuffer6;
    internal Byte[] tmpBuffer8;
    internal Int32[] retLen;
    internal byte m_currentTTCSeqNumber;
    private TTCError m_ttcError;
    internal OraBufReader m_oraBufRdr;
    internal OraBufWriter m_oraBufWriter;
    internal Nullable`1<bool> m_bFastNegotiationRejectedByServer;
    internal TTCSessionGet m_drcpSessionGet;
    internal TTCSessionRelease m_drcpSessionRelease;
    internal TTCSessionReturnValues m_drcpSessionReturnValues;
    internal Conv m_dbCharSetConv;
    internal Conv m_nCharSetConv;
    internal bool m_bSvrCSMultibyte;
    internal CharArrayPooler m_charArrayPooler;
    internal OracleConnectionImpl m_connImplReference;
    private static Byte[] NULL_PTR;
    private static Byte[] NOTNULL_PTR;
    internal byte NegotiatedTTCVersion { get; internal set; }
    internal TTCError TTCErrorObject { get; internal set; }
    internal bool HasFSAPCapability { get; internal set; }
    internal bool HasEOCSCapability { get; internal set; }
    internal int DBVersion { get; internal set; }
    internal long endOfCallStatus { get; internal set; }
    internal MarshallingEngine(OracleCommunication communication, OracleConnectionImpl connImplReference);
    private static MarshallingEngine();
    internal byte GetNextSequenceNumber();
    internal byte get_NegotiatedTTCVersion();
    internal void set_NegotiatedTTCVersion(byte value);
    internal TTCError get_TTCErrorObject();
    internal void set_TTCErrorObject(TTCError value);
    internal void set_HasFSAPCapability(bool value);
    internal bool get_HasFSAPCapability();
    internal void set_HasEOCSCapability(bool value);
    internal bool get_HasEOCSCapability();
    internal void set_DBVersion(int value);
    internal int get_DBVersion();
    internal void set_endOfCallStatus(long value);
    internal long get_endOfCallStatus();
    internal void MarshalUB1(short val);
    internal byte getNextSeqNumber();
    internal void MarshalUB2(int val);
    internal void MarshalNativeUB2(int val);
    internal void MarshalUWORD(long value);
    internal void MarshalUB4(long val);
    internal void MarshalO2U(bool notnull);
    internal void MarshalPointer();
    internal void MarshalNullPointer();
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalSWORDAsync>d__75")]
internal ValueTask`1<int> UnmarshalSWORDAsync(bool bAsync);
    internal void MarshalKPDKV(Byte[][] textValues, Byte[][] binaryValues, Int32[] keywords);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalUB1Async>d__77")]
internal ValueTask`1<short> UnmarshalUB1Async(bool bAsync, bool bIgnoreData);
    internal void MarshalSB2(short val);
    internal void MarshalSB4(int val);
    internal void MarshalUB8ForAC(ulong value);
    internal void MarshalUB8(BigInteger val);
    internal void MarshalSB8(long val);
    internal void MarshalSWORD(int value);
    internal void AddPtr(byte value);
    internal void MarshalDALC(Byte[] buffer);
    internal void MarshalCHR(Byte[] value);
    internal void MarshalCHR(Byte[] value, int offset, int length);
    internal void MarshalBytes(Byte[] value, int offset, int length);
    internal void MarshalUB4Array(Int64[] value);
    internal void MarshalKEYVAL(Byte[][] keys, Byte[][] values, Byte[] kvalflg, int nb);
    internal void MarshalCLR(Byte[] value, int valueLen);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalCLRAsync>d__92")]
internal ValueTask`1<Byte[]> UnmarshalCLRAsync(int buflen, Int32[] intArray, bool bAsync);
    internal void MarshalCLR(Byte[] value, int offset, int valueLen);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalCLRAsync>d__94")]
internal ValueTask UnmarshalCLRAsync(Byte[] bytes, int offsetRow, Int32[] intArray, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalCLRAsync>d__95")]
internal ValueTask UnmarshalCLRAsync(Byte[] bytes, int offsetRow, Int32[] intArray, int maxSize, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalCLRAsync>d__96")]
internal ValueTask UnmarshalCLRAsync(Byte[] bytes, int offsetRow, Int32[] intArray, int maxSize, int ignoreNBytes, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalBufferAsync>d__97")]
internal ValueTask`1<int> UnmarshalBufferAsync(Byte[] _byteValue, int offset, int len, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalSB4Async>d__98")]
internal ValueTask`1<int> UnmarshalSB4Async(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalSB8Async>d__99")]
internal ValueTask`1<long> UnmarshalSB8Async(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalUB8Async>d__100")]
internal ValueTask`1<BigInteger> UnmarshalUB8Async(bool bIgnoreData, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalKPDKVAsync>d__101")]
internal ValueTask UnmarshalKPDKVAsync(Byte[][] textValues, Int32[] textValuesLength, Byte[][] binaryValues, Int32[] keywords, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalKEYVALAsync>d__102")]
internal ValueTask`1<Int32[]> UnmarshalKEYVALAsync(Byte[][] keys, Byte[][] values, int nb, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalSB1Async>d__103")]
internal ValueTask`1<byte> UnmarshalSB1Async(bool bAsync);
    internal void MarshalB1Array(Byte[] inputBuffer);
    internal void MarshalB1Array(Byte[] value, int off, int len);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalSB2Async>d__106")]
internal ValueTask`1<short> UnmarshalSB2Async(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalUB2Async>d__107")]
internal ValueTask`1<int> UnmarshalUB2Async(bool bAsync, bool bIgnoreData);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalUB4Async>d__108")]
internal ValueTask`1<long> UnmarshalUB4Async(bool bAsync, bool bIgnoreData);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalTEXTAsync>d__109")]
internal ValueTask`1<Byte[]> UnmarshalTEXTAsync(int length, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalCHRAsync>d__110")]
internal ValueTask`1<Byte[]> UnmarshalCHRAsync(int retLength, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<GetNBytesAsync>d__111")]
internal ValueTask`1<int> GetNBytesAsync(Byte[] buf, int off, int len, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<GetNBytesAsync>d__112")]
internal ValueTask`1<Byte[]> GetNBytesAsync(int n, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalNBytesAsync>d__113")]
internal ValueTask`1<Byte[]> UnmarshalNBytesAsync(int length, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalNBytesAsync>d__114")]
internal ValueTask`1<int> UnmarshalNBytesAsync(Byte[] buf, int off, int n, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalUCS2Async>d__115")]
internal ValueTask`1<int> UnmarshalUCS2Async(Byte[] ucs2Char, long offset);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalDALCAsync>d__116")]
internal ValueTask`1<Byte[]> UnmarshalDALCAsync(bool bIgnoreData, Int32[] actualLen, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalCLRforREFSAsync>d__117")]
internal ValueTask`1<Byte[]> UnmarshalCLRforREFSAsync(bool bAsync, bool bIgnoreData);
    private void AddPointer(byte val);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<BufferToValueAsync>d__119")]
private ValueTask`1<long> BufferToValueAsync(byte repOffset, bool bAsync, bool bIgnoreData);
    internal byte GetNoOfBytesToBeWritten(int value, byte repOffset);
    private byte ValueToBuffer(long value, Byte[] outBuffer, byte repOffset);
    internal bool EscapeSequenceNull(int bytes);
    private void ReverseArray(Byte[] buffer, int bytes, int offset);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<ProcessIndicatorAsync>d__124")]
internal ValueTask`1<int> ProcessIndicatorAsync(bool isNull, int dataSize, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalCLR_ColDataAsync>d__125")]
internal ValueTask UnmarshalCLR_ColDataAsync(int maxSize, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalCLR_ScanOnlyAsync>d__127")]
internal ValueTask`1<UnmarshalCLR_ScanOnlyCtx> UnmarshalCLR_ScanOnlyAsync(int maxSize, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<GetNBytes_ScanOnlyAsync>d__128")]
internal ValueTask`1<int> GetNBytes_ScanOnlyAsync(int len, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalNBytes_ScanOnlyAsync>d__129")]
internal ValueTask`1<int> UnmarshalNBytes_ScanOnlyAsync(int n, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<UnmarshalBuffer_ScanOnlyAsync>d__130")]
internal ValueTask`1<int> UnmarshalBuffer_ScanOnlyAsync(int len, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.MarshallingEngine/<ProcessResetAsync>d__131")]
internal ValueTask ProcessResetAsync(bool bAsync);
    internal int UnmarshalSWORD(bool bAsync);
    internal short UnmarshalUB1(bool bAsync, bool bIgnoreData);
    internal Byte[] UnmarshalCLR(int buflen, Int32[] intArray, bool bAsync);
    internal void UnmarshalCLR(Byte[] bytes, int offsetRow, Int32[] intArray, bool bAsync);
    internal void UnmarshalCLR(Byte[] bytes, int offsetRow, Int32[] intArray, int maxSize, bool bAsync);
    internal void UnmarshalCLR(Byte[] bytes, int offsetRow, Int32[] intArray, int maxSize, int ignoreNBytes, bool bAsync);
    internal int UnmarshalBuffer(Byte[] _byteValue, int offset, int len, bool bAsync);
    internal int UnmarshalSB4(bool bAsync);
    internal long UnmarshalSB8(bool bAsync);
    internal BigInteger UnmarshalUB8Sync(bool bIgnoreData, bool bAsync);
    internal void UnmarshalKPDKV(Byte[][] textValues, Int32[] textValuesLength, Byte[][] binaryValues, Int32[] keywords, bool bAsync);
    internal Int32[] UnmarshalKEYVAL(Byte[][] keys, Byte[][] values, int nb, bool bAsync);
    internal byte UnmarshalSB1(bool bAsync);
    internal short UnmarshalSB2(bool bAsync);
    internal int UnmarshalUB2(bool bAsync, bool bIgnoreData);
    internal long UnmarshalUB4(bool bAsync, bool bIgnoreData);
    internal Byte[] UnmarshalTEXT(int length, bool bAsync);
    internal Byte[] UnmarshalCHR(int retLength, bool bAsync);
    internal int GetNBytes(Byte[] buf, int off, int len, bool bAsync);
    internal Byte[] GetNBytes(int n, bool bAsync);
    internal Byte[] UnmarshalNBytes(int length, bool bAsync);
    internal int UnmarshalNBytes(Byte[] buf, int off, int n, bool bAsync);
    internal int UnmarshalUCS2(Byte[] ucs2Char, long offset);
    internal Byte[] UnmarshalDALC(bool bIgnoreData, Int32[] actualLen, bool bAsync);
    internal Byte[] UnmarshalCLRforREFS(bool bAsync, bool bIgnoreData);
    private long BufferToValue(byte repOffset, bool bAsync, bool bIgnoreData);
    internal int ProcessIndicator(bool isNull, int dataSize, bool bAsync);
    internal void UnmarshalCLR_ColData(int maxSize, bool bAsync);
    internal UnmarshalCLR_ScanOnlyCtx UnmarshalCLR_ScanOnly(int maxSize, bool bAsync);
    internal int GetNBytes_ScanOnly(int len, bool bAsync);
    internal int UnmarshalNBytes_ScanOnly(int n, bool bAsync);
    internal int UnmarshalBuffer_ScanOnly(int len, bool bAsync);
    internal void ProcessReset(bool bAsync);
}
internal class OracleInternal.TTC.NotificationHeader : object {
    internal int m_messageType;
    private OracleConnectionImpl m_orclConnImpl;
    internal long m_regId;
    internal int m_errorCode;
    internal Byte[] m_notificationQueue;
    internal string m_notificationQueueName;
    internal Byte[] m_consumerName;
    internal string m_consumerNameString;
    internal static int STOP_TFN_KPDNRNF;
    internal static int CONS_CLOSE_ERR;
    internal static int DEST_CLOSE_ERR;
    internal NotificationHeader(OracleConnectionImpl orclConnImpl);
    private static NotificationHeader();
    internal void Receive();
    internal string GetNotificationQueue();
    internal long GetRegistrationId();
    internal string GetConsumerName();
}
internal class OracleInternal.TTC.NotificationMessagePayload : object {
    private OracleConnectionImpl m_orclConnImpl;
    internal int m_payloadType;
    internal int m_payloadFlag;
    internal Byte[] m_rawPayload;
    private Byte[] toid;
    internal int KPDNRPAYRAW;
    internal int KPDNRPAYADT;
    private TTCtoh toh;
    private MarshallingEngine mEngine;
    internal NotificationMessagePayload(OracleConnectionImpl orclConnImpl);
    internal void Receive(long regIdFromServer);
}
internal class OracleInternal.TTC.NotificationMessageProperties : object {
    private MarshallingEngine m_mEngine;
    private AQMessage m_aqm;
    internal OracleAQMessage m_properties;
    internal NotificationMessageProperties(MarshallingEngine mEngine);
    internal void Receive();
}
internal class OracleInternal.TTC.OraBufReader : object {
    private OraBufWriter m_oraBufWriter;
    private ReaderStream m_readerStream;
    internal OraBuf m_currentOB;
    internal OraArraySegment[] m_currentArrSegments;
    internal int m_segmentCount;
    internal OraArraySegment m_currentSegment;
    internal int m_currentSegmentIndex;
    internal Byte[] m_currentSegmentArray;
    internal int m_positionInCurrentSegment;
    private Byte[] m_tempOneByte;
    internal List`1<ArraySegment`1<byte>> m_dataSegments;
    internal List`1<OraBuf> m_tempOBList;
    internal long m_DataLeftInCurrentSegment;
    internal bool m_bAccumulateByteSegments;
    internal bool m_bParsingColumnData;
    internal bool m_bMarkStartOffsetForColData;
    internal int m_colDataStartOffsetIndexToUpdate;
    internal Int32[] m_colDataStartOffset;
    internal Int32[] m_indexOfOASArray;
    internal OraArraySegment[] m_oraArrSegWithColRowInfo;
    internal int m_oraArrSegWithColRowInfoIndex;
    internal bool m_bHoldOBTemporarily;
    internal Byte[] m_dataBuffer;
    internal int m_offset;
    internal int m_bufLength;
    internal bool m_bDisableReInit;
    internal OraBufReader(ReaderStream rdrStream, OraBufWriter obWriter);
    internal void ClearState();
    internal void FreeTempOBList();
    [AsyncStateMachineAttribute("OracleInternal.TTC.OraBufReader/<ReadAsync>d__29")]
internal ValueTask`1<int> ReadAsync(bool bAsync, bool bIgnoreData);
    [AsyncStateMachineAttribute("OracleInternal.TTC.OraBufReader/<ReadAsync>d__30")]
internal ValueTask`1<int> ReadAsync(Byte[] userBuffer, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.OraBufReader/<ReadAsync>d__31")]
internal ValueTask`1<int> ReadAsync(Byte[] userBuffer, int offset, int length, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.OraBufReader/<ReadLengthAndDataAsync>d__32")]
internal Task`1<bool> ReadLengthAndDataAsync(byte repOffset, byte typeRep, bool bAsync, bool IgnoreData);
    [AsyncStateMachineAttribute("OracleInternal.TTC.OraBufReader/<GetDataFromNetworkAsync>d__33")]
private ValueTask GetDataFromNetworkAsync(bool bAsync);
    internal bool DataAvailableInOraBuf();
    internal int GetData(Byte[] userBuffer, int offset, int length);
    private void AssignColRowInfoSegment();
    [AsyncStateMachineAttribute("OracleInternal.TTC.OraBufReader/<StartAccumulatingRowDataAsync>d__37")]
internal ValueTask StartAccumulatingRowDataAsync(bool bAsync);
    internal void UpdateOASMaxRow(int lastRowNum);
    internal void StopAccumulatingRowData();
    internal void StartAccumulatingMyData(List`1[] rowDataSegments, int rowCounter);
    internal bool StartAccumulatingColumnData(List`1<List`1<ArraySegment`1<byte>>> rowDataSegments, int rowCounter);
    internal void StartAccumulatingColumnData(List`1<ArraySegment`1<byte>> dataSegments);
    internal void StopAccumulatingColumnData();
    internal int Read(bool bAsync, bool bIgnoreData);
    internal int Read(Byte[] userBuffer, bool bAsync);
    internal int Read(Byte[] userBuffer, int offset, int length, bool bAsync);
    internal bool ReadLengthAndData(byte repOffset, byte typeRep, bool bAsync, bool IgnoreData);
    private void GetDataFromNetwork(bool bAsync);
    internal void StartAccumulatingRowData(bool bAsync);
}
internal class OracleInternal.TTC.OraBufWriter : object {
    internal MarshallingEngine m_marshallingEngine;
    private WriterStream m_writerStream;
    private Byte[] m_oneByteBuffer;
    internal OracleCommunication m_oracleComm;
    internal OraBuf m_currentOB;
    internal Byte[] m_currentObBuffer;
    internal int m_positionInCurrentOB;
    internal int m_startIdxForDataSegment;
    internal int m_lengthForDataSegment;
    internal bool m_bFabricateMsgMode;
    internal OraBuf m_fabricatedMsgOB;
    internal ArrayList m_fabricatedMsgOBList;
    internal bool m_bPipeliningSendDataFlags;
    internal bool m_bPipeliningBeginSent;
    internal OraBufWriter(MarshallingEngine mEngine, WriterStream writerStream, OracleCommunication oracleComm);
    internal void Initialize();
    internal void Write(byte val);
    internal void Write(Byte[] inputBuffer);
    internal void Write(Byte[] inputBuffer, int offset, int length);
    internal void WriteLengthAndDataToOraBuf(bool bWritePrefixLength, int prefixLength, Byte[] userBuffer, int offset, int length);
    internal int WriteDataToOraBuf(Byte[] userBuffer, int offset, int length);
    internal void FlushData(bool bEndOfRPC, bool bStartOfRPC);
    [AsyncStateMachineAttribute("OracleInternal.TTC.OraBufWriter/<SendOBAsync>d__22")]
internal ValueTask SendOBAsync(OraBuf ob);
    internal void SendOB(OraBuf ob, bool bEndOfRPC, bool bStartOfRPC);
    internal void SaveFabricatedMsgOB();
}
internal class OracleInternal.TTC.StateSignatures : object {
    internal long m_signatureFlags;
    internal BigInteger m_clientSignature;
    internal BigInteger m_serverSignature;
    internal long m_version;
    internal StateSignatures(long signatureFlags, BigInteger clientSignature, BigInteger serverSignature);
    internal StateSignatures(long signatureFlags, BigInteger clientSignature, BigInteger serverSignature, long version);
    internal StateSignatures Copy();
}
internal class OracleInternal.TTC.TemplateOverflow : object {
    internal BigInteger m_templateId;
    internal Byte[] m_overflow;
    internal bool m_bComplete;
    internal BigInteger m_overflowSignature;
    internal TemplateOverflow(BigInteger templateId, Byte[] overflow, bool complete, BigInteger overflowSignature);
}
internal class OracleInternal.TTC.TTCAppContinuityReplay : TTCFunction {
    internal TTCAppContinuityReplay(MarshallingEngine mEngine);
    internal void Write(AppContCtlCtx replayCtx);
}
internal class OracleInternal.TTC.TTCAQArray : TTCFunction {
    internal static int AQXDEF_ENQ;
    internal static int AQXDEF_DEQ;
    internal static int AQXDEF_ARR;
    internal static int AQXDEF_RETMID;
    internal static int AQXDEF_DYNDAT;
    internal static int AQXDEF_ORGMID;
    private TTCAQArrayInParams[] aqiArray;
    private TTCAQArrayOutParams[] aqoArray;
    internal long aqxrflg;
    internal int aqxaqopt;
    internal long aqxiters;
    internal OracleAQMessage[] messageProperties;
    internal OracleAQMessage[] aqMesgs;
    internal OracleAQEnqueueOptions aqEnqueueOptions;
    internal OracleAQDequeueOptions aqDequeueOptions;
    internal bool m_autoCommit;
    internal TTCAQArray(MarshallingEngine mEngine, bool bautoCommit);
    internal int WriteEnqueueArrayPayload(string _queueName, OracleAQEnqueueOptions _aqEnqueueOptions, OracleAQMessage[] _messageProperties, Byte[] _payloadToid, int _messageVersion, bool _isRawQueue);
    internal OracleAQMessage[] ReadDequeueArrayPayload(string _queueName, OracleAQDequeueOptions _aqDequeueOptions, Byte[] _tdo, int _version, int _size, OracleAQMessage[] _messageProperties, bool _isRawQueue);
    private void setFlag();
    internal void WriteMessage();
    internal void Marshal();
    internal void ReadResponse();
    private void ReadRPA();
    private void Unmarshal();
}
internal class OracleInternal.TTC.TTCAQArrayInParams : object {
    internal static int AQIVER_DEFAULT;
    internal static int AQIVER_12_2;
    internal static int AQIVER_12_1;
    internal static int AQTTC_ENQ_STREAMING_DISABLED;
    internal static int AQTTC_ENQ_STREAMING_ENABLED;
    internal static int AQTCC_OCI_ONE_PIECE;
    internal static int AQTCC_OCI_FIRST_PIECE;
    internal static int AQTCC_OCI_NEXT_PIECE;
    internal static int AQTCC_OCI_LAST_PIECE;
    private MarshallingEngine m_marshallingEngine;
    internal TTCAQMessage aqm;
    internal TTCtoh toh;
    private OracleAQMessage messageProperties;
    private OracleAQEnqueueOptions aqEnqueueOptions;
    private OracleAQDequeueOptions aqDequeueOptions;
    private int aqxaqopt;
    private Byte[] aqmcorBytes;
    private Byte[] aqmeqnBytes;
    private Byte[] senderAgentName;
    private Byte[] senderAgentAddress;
    private byte senderAgentProtocol;
    private Byte[] queueNameBytes;
    private OracleAQAgent[] attrRecipientList;
    private Byte[][] recipientTextValues;
    private Byte[][] recipientBinaryValues;
    private Int32[] recipientKeywords;
    private Byte[] consumerNameBytes;
    private Byte[] correlationBytes;
    private Byte[] conditionBytes;
    private int nbExtensions;
    private Byte[][] extensionTextValues;
    private Byte[][] extensionBinaryValues;
    private Int32[] extensionKeywords;
    private Byte[] messageOid;
    private int aqiver;
    private Byte[] messageData;
    internal bool isRawQueue;
    internal bool isJSONQueue;
    private bool bStreamingMode;
    private int blockSize;
    private StreamReader payloadStream;
    internal int aqiflg;
    private bool useEnqOpt;
    private bool lcrx2y;
    internal bool m_autoCommit;
    internal TTCAQArrayInParams(MarshallingEngine mEngine, int _aqxaqopt, string _queueName, OracleAQEnqueueOptions _aqEnqueueOptions, OracleAQMessage _messageProperties, OracleAQDequeueOptions _aqDequeueOptions, Byte[] _tdo, int _version, bool _isRawQueue, bool _autoCommit);
    internal void InitCommon(MarshallingEngine mEngine, int _aqxaqopt, string _queueName, OracleAQMessage _messageProperties);
    internal void InitFlag();
    internal void MarshalPropagation();
    internal void MarshalHeader();
    internal void MarshalData();
    private void MarshalAQM();
    internal void MarshalDone();
    internal void Marshal();
    private void setStreamingMode(bool flag);
    private void setBlockSize(int _blockSize);
    private void setInputStream(StreamReader inputStream);
    internal void writeFirst(Byte[] _byteArray, int length);
    internal void writeNext(Byte[] _byteArray, int length);
    internal void writeLast(Byte[] _byteArray, int length);
}
internal class OracleInternal.TTC.TTCAQArrayOutParams : object {
    private MarshallingEngine m_marshallingEngine;
    private TTCAQMessage aqm;
    private TTCtoh toh;
    internal Byte[] payload;
    internal OracleAQMessage aqMessageProperties;
    internal Byte[] outMsgId;
    internal int aqxaqopt;
    internal bool isAQMsg;
    internal OracleAQEnqueueOptions aqEnqueueOptions;
    internal OracleAQDequeueOptions aqDequeueOptions;
    internal bool isRawQueue;
    internal bool isJSONQueue;
    internal TTCAQArrayOutParams(MarshallingEngine mEngine, int _aqxaqopt, OracleAQEnqueueOptions _aqEnqueueOptions, OracleAQMessage _aqMessageProperties, OracleAQDequeueOptions _aqDequeueOptions, bool _isRawQueue, bool _isJSONQueue);
    private void InitCommon(MarshallingEngine mEngine, int _aqxaqopt, OracleAQMessage _aqMessageProperties, bool _isRawQueue, bool _isJSONQueue);
    internal void Unmarshal();
    internal Byte[] getMsgId();
    internal Byte[] getPayload();
}
internal class OracleInternal.TTC.TTCAQDequeue : TTCFunction {
    private TTCAQMessage aqm;
    private TTCtoh toh;
    private bool m_autoCommit;
    private static int AQDVER_DEFAULT;
    private string queueName;
    private OracleAQDequeueOptions dequeueOptions;
    private Byte[] payloadToid;
    private Byte[] queueNameBytes;
    private Byte[] consumerNameBytes;
    private Byte[] correlationBytes;
    private Byte[] conditionBytes;
    private int nbExtensions;
    private Byte[][] extensionTextValues;
    private Byte[][] extensionBinaryValues;
    private Int32[] extensionKeywords;
    private Byte[] payload;
    internal bool hasAMessageBeenDequeued;
    private Byte[] dequeuedMessageId;
    private int aqdver;
    private bool isRawQueue;
    private bool isJsonQueue;
    private OracleAQMessage properties;
    internal TTCAQDequeue(MarshallingEngine mEngine, bool bautoCommit);
    internal void ReadDequeuePayload(string _queueName, OracleAQDequeueOptions _dequeueOptions, Byte[] _payloadToid, int _payloadVersion, bool _isRawQueue, OracleAQMessage _properties);
    internal void WriteMessage();
    private void Marshal();
    internal Byte[] getPayload();
    internal Byte[] getDequeuedMessageId();
    internal void ReadRPA();
    internal void ReadResponse();
}
internal class OracleInternal.TTC.TTCAQEnqueue : TTCFunction {
    internal static int KPD_AQ_BUFMSG;
    internal static int KPD_AQ_EITHER;
    internal static int OCI_COMMIT_ON_SUCCESS;
    internal static int ATTR_TRANSFORMATION;
    internal static int AQEVER_DEFAULT;
    internal TTCAQMessage aqm;
    internal TTCtoh toh;
    private bool m_autoCommit;
    internal static int AQTTC_DEQ_OPTS_DEFAULT;
    internal static int AQTTC_DEQ_OPTS_ON_COMMIT;
    internal static int AQTTC_DEQ_OPTS_IMMEDIATE;
    internal static int AQTTC_DEQ_OPTS_FOREVER;
    internal static int AQTTC_DEQ_OPTS_BROWSE;
    internal static int AQTTC_DEQ_OPTS_LOCKED;
    internal static int AQTTC_DEQ_OPTS_REMOVE;
    internal static int AQTTC_DEQ_OPTS_REMOVE_NO_DATA;
    internal static int AQTTC_DEQ_OPTS_BUFFERED;
    internal static int AQTTC_DEQ_OPT_PERS_BUFF;
    internal static int AQTCC_DEQ_STREAMING_ENABLED;
    internal static int AQDEQVER_DEFAULT;
    internal static int AQDEQVER_12_2;
    internal static int AQDEQVER_12_1;
    private Byte[] queueNameBytes;
    private OracleAQEnqueueOptions enqueueOptions;
    private OracleAQMessage messageProperties;
    private Byte[] messageData;
    private Byte[] payloadToid;
    private int aqever;
    private bool isRawQueue;
    private int nbExtensions;
    private Byte[][] extensionTextValues;
    private Byte[][] extensionBinaryValues;
    private Int32[] extensionKeywords;
    private OracleAQAgent[] attrRecipientList;
    private Byte[][] recipientTextValues;
    private Byte[][] recipientBinaryValues;
    private Int32[] recipientKeywords;
    private Byte[] aqmcorBytes;
    private Byte[] aqmeqnBytes;
    private bool retrieveMessageId;
    private Byte[] outMsgid;
    private Byte[] senderAgentName;
    private Byte[] senderAgentAddress;
    private byte senderAgentProtocol;
    private bool isJsonQueue;
    private int messageDataLength;
    internal TTCAQEnqueue(MarshallingEngine mEngine, bool bautoCommit);
    internal void WriteEnqueuePayload(string _queueName, OracleAQEnqueueOptions _enqueueOptions, OracleAQMessage _messageProperties, Byte[] _messageData, Byte[] _payloadToid, int _messageVersion, bool _isRawQueue);
    internal void WriteMessage();
    internal void Marshal();
    internal Byte[] getMessageId();
    internal void ReadResponse();
    private void ReadRPA();
}
internal class OracleInternal.TTC.TTCAQMessage : object {
    internal static int ATTR_ORIGINAL_MSGID;
    internal static byte ATTR_AGENT_NAME;
    internal static byte ATTR_AGENT_ADDRESS;
    internal static byte ATTR_AGENT_PROTOCOL;
    internal static int AQM_MSG_NO_DELAY;
    internal static int AQM_MSG_NO_EXPIRATION;
    internal static int INVALID_SHARD_ID;
    internal int aqmpri;
    internal int aqmdel;
    internal int aqmexp;
    internal Byte[] aqmcorBytes;
    internal int aqmcorBytesLength;
    internal int aqmatt;
    internal Byte[] aqmeqnBytes;
    internal int aqmeqnBytesLength;
    internal int aqmsta;
    private Byte[] aqmeqtBuffer;
    private Int32[] retInt;
    internal OracleTimeStamp aqmeqt;
    internal Byte[] aqmetiBytes;
    internal Byte[] senderAgentName;
    internal int senderAgentNameLength;
    internal Byte[] senderAgentAddress;
    internal int senderAgentAddressLength;
    internal byte senderAgentProtocol;
    internal Byte[] originalMsgId;
    internal TTCtoh toh;
    internal int aqmcsn;
    internal int aqmdsn;
    internal int aqmflg;
    internal int aqmshardNum;
    private MarshallingEngine mEngine;
    internal TTCAQMessage(MarshallingEngine mar, TTCtoh _toh);
    private static TTCAQMessage();
    internal void initToDefaultValues();
    internal void Marshal();
    internal void receive();
}
internal class OracleInternal.TTC.TTCAQNotification : TTCFunction {
    internal static short INIT_KPDNRREQ;
    internal static short COMMIT_KPDNRREQ;
    internal static short ROLLBACK_KPDNRREQ;
    internal static short REINIT_KPDNRREQ;
    internal OracleConnectionImpl m_orclConnImpl;
    private string m_client_id;
    internal bool m_bShutDown;
    internal long m_server_id;
    internal TTCAQNotification(OracleConnectionImpl orclConnImpl);
    private static TTCAQNotification();
    internal virtual void ReInit(MarshallingEngine marshallingEngine);
    internal void SendRequest(short registrationOpCode, string clientId);
    internal void ReceiveResponse(object state);
    internal void ReceiveONSEvents();
}
internal class OracleInternal.TTC.TTCAQNotificationAck : object {
    internal Byte[] acknowledgmentQueue;
    internal long acknowledgementRegistrationId;
    internal Byte[] lastReceivedMessageId;
    private MarshallingEngine m_marshallingEngine;
    internal TTCAQNotificationAck(MarshallingEngine mar);
    internal void Send(Byte[] _acknowledgmentQueue, long _acknowledgementRegistrationId, Byte[] _lastReceivedMessageId);
    internal void Marshal();
}
internal class OracleInternal.TTC.TTCAQNotificationDeq : TTCFunction {
    private static short COMMIT_KPNAQDEQ;
    private static short ROLLBACK_KPNAQDEQ;
    private Byte[] clientIdBytes;
    private short opCode;
    private Int64[] registrationIdArr;
    private Byte[][] messageIdArr;
    private Byte[][] queueNameBytesArr;
    private int noOfAck;
    private TTCAQNotificationAck notificationAck;
    internal TTCAQNotificationDeq(MarshallingEngine mEngine);
    internal void SendAQEnomDequeue(string clientId, short _opCode, Byte[][] messageIds, Int64[] registrationIds, String[] queues);
    internal void WriteMessage();
    internal void Marshal();
    internal void ReadResponse();
}
internal class OracleInternal.TTC.TTCArrayBindError : ValueType {
    internal int m_errorCode;
    internal int m_rowOffset;
    internal Byte[] m_errorMsg;
    internal int m_errorLength;
}
internal class OracleInternal.TTC.TTCAuthenticate : TTCFunction {
    private static int TTCC_LNG;
    internal static int KPZ_LOGON;
    internal static int KPZ_CPW;
    private static int KPZ_PROXY_AUTH;
    private static int KPZ_PASSW_ENCRYPTED;
    internal static byte DEFAULT_LOGON_COMPATIBILITY;
    internal static int KPZ_LOGON_SYSDBA;
    internal static int KPZ_LOGON_SYSOPER;
    internal static int KPZ_LOGON_SYSASM;
    internal static int KPZ_LOGON_SYSBKP;
    internal static int KPZ_LOGON_SYSDGD;
    internal static int KPZ_LOGON_SYSKMT;
    internal static int KPZ_LOGON_SYSRAC;
    internal static int KPZ_LOGON_PRELIMAUTH;
    internal static int KZTVT_ORCL_7;
    internal static int KZTVT_SSH1;
    internal static int KZTVT_SHA512;
    internal static int KZTVT_MD5;
    internal static int KZTVT_SH1;
    internal static int KZTVT_SMD5;
    internal static int KPZ_CPW_AUTH;
    internal static int KPZ_OPASSW_ENCRYPTED;
    internal static int KPZ_NPASSW_ENCRYPTED;
    internal static int KPZ_NPASSW_OBFUSCATE;
    internal static int KOLRUG_ENABLE;
    internal static int KOLRUG_NSURWT;
    internal static int KOLRUG_LOCMAP;
    internal static int KOLRUG_CLNRCE;
    internal static int KZTV_MAX_SALTL;
    internal static int PBKDF2_VGEN_COUNT_MIN;
    internal static int PBKDF2_VGEN_COUNT_DEFAULT;
    internal static int PBKDF2_VGEN_COUNT_MAX;
    internal static int PBKDF2_SDER_COUNT_MIN;
    internal static int PBKDF2_SDER_COUNT_DEFAULT;
    internal static int PBKDF2_SDER_COUNT_MAX;
    private static string AUTH_PBKDF2_CSK_SALT;
    private static string AUTH_PBKDF2_SDER_COUNT;
    private static string AUTH_PBKDF2_VGEN_COUNT;
    private static string AUTH_PBKDF2_SPEEDY_KEY;
    private Byte[] m_auth_pbkdf2_csk_salt;
    private Byte[] m_auth_pbkdf2_sder_count;
    private Byte[] m_auth_pbkdf2_vgen_count;
    private Byte[] m_auth_pbkdf2_speedy_key;
    private Byte[] m_pbkdf2_cskSalt;
    private int m_pbkdf2_vgen_count;
    private int m_pbkdf2_sder_count;
    internal int m_serverVersion;
    private static string AUTH_TOKEN;
    private static string AUTH_HEADER;
    private static string AUTH_SIGNATURE;
    internal static string AUTH_HEADER_DATE_FORMATTER;
    private static Char[] m_versionSeparator;
    private static string DOUBLE_QUOTE;
    internal static string AUTH_VERSION_NO;
    private static string AUTH_TERMINAL;
    private static string AUTH_PROGRAM_NM;
    private static string AUTH_MACHINE;
    private static string AUTH_PID;
    private static string AUTH_SID;
    private static string AUTH_PASSW;
    private static string AUTH_NEWPASSW;
    private static string AUTH_SESSKEY;
    private static string AUTH_VFR_DATA;
    private static string AUTH_SVR_RESPONSE;
    private static string AUTH_ALTER_SESSION;
    private static string AUTH_PROXY_CLIENT_NAME;
    private static string AUTH_CONNECT_STRING;
    internal static string AUTH_SERIAL_NUM;
    internal static string AUTH_SESSION_ID;
    internal static string AUTH_ORA_DEBUG_JDWP;
    internal static string AUTH_ORA_EDITION;
    internal static string AUTH_INSTANCENAME;
    internal static string AUTH_DBNAME;
    internal static string AUTH_INSTANCE_NO;
    internal static string AUTH_FAILOVER_TYPE;
    internal static string AUTH_DB_MOUNT_ID;
    internal static string AUTH_DB_MOUNT_ID2;
    internal static string AUTH_DB_ID;
    internal static string AUTH_DB_ID2;
    internal static string AUTH_PDB_UID;
    internal static string AUTH_PDB_UID2;
    internal static string AUTH_GLOBALLY_UNIQUE_DBID;
    internal static string AUTH_GLOBALLY_UNIQUE_DBID2;
    internal static string AUTH_SC_SERVER_HOST;
    internal static string AUTH_SC_INSTANCE_NAME;
    internal static string AUTH_SC_INSTANCE_ID;
    internal static string AUTH_SC_INSTANCE_START_TIME;
    internal static string AUTH_SC_DBUNIQUE_NAME;
    internal static string AUTH_SC_DB_DOMAIN;
    internal static string AUTH_SC_SERVICE_NAME;
    internal static string AUTH_SC_SVC_FLAGS;
    internal static string AUTH_ONS_CONFIG;
    internal static string AUTH_ONS_RLB_SUBSCR_PATTERN;
    internal static string AUTH_ONS_HA_SUBSCR_PATTERN;
    internal static string AUTH_MAX_OPEN_CURSORS;
    internal static string AUTH_MAX_IDEN_LENGTH;
    internal static string AUTH_CLIENT_PREFETCH_ROWS;
    internal static string AUTH_SESSION_CLIENT_CSET;
    internal static string AUTH_SESSION_CLIENT_LTYPE;
    internal static string AUTH_SESSION_CLIENT_DRVNM;
    internal static string AUTH_SESSION_CLIENT_VSN;
    private static string SESSION_CLIENT_LOBATTR;
    internal static string AUTH_NLS_LXLAN;
    internal static string AUTH_NLS_LXCTERRITORY;
    internal static string AUTH_NLS_LXCCURRENCY;
    internal static string AUTH_NLS_LXCISOCURR;
    internal static string AUTH_NLS_LXCNUMERICS;
    internal static string AUTH_NLS_LXCDATEFM;
    internal static string AUTH_NLS_LXCDATELANG;
    internal static string AUTH_NLS_LXCSORT;
    internal static string AUTH_NLS_LXCCALENDAR;
    internal static string AUTH_NLS_LXCUNIONCUR;
    internal static string AUTH_NLS_LXCTIMEFM;
    internal static string AUTH_NLS_LXCSTMPFM;
    internal static string AUTH_NLS_LXCTTZNFM;
    internal static string AUTH_NLS_LXCSTZNFM;
    private static string AUTH_KPPL_CONN_CLASS;
    private static string AUTH_KPPL_PURITY;
    private static string AUTH_KPPL_TAG;
    private static string AUTH_KPPL_IS_MULTIPROP_TAG;
    private static string AUTH_KPPL_FIXUP_CB;
    private static string AUTH_KPPL_WAIT;
    private static string KPPL_PURITY_DEFAULT;
    private static string KPPL_PURITY_NEW;
    private static string KPPL_PURITY_SELF;
    private static string SESS_PURITY_DEFAULT;
    private static string SESS_PURITY_NEW;
    private static string SESS_PURITY_SELF;
    private static string SESSION_CLIENT_LIB_TYPE_VALUE;
    internal static string SESSION_TIME_ZONE;
    internal static string SESSION_NLS_LXCCHARSET;
    internal static string SESSION_NLS_LXCNLSLENSEM;
    internal static string SESSION_NLS_LXCNCHAREXCP;
    internal static string SESSION_NLS_LXCNCHARIMP;
    private static string CLIENT_DRIVER_NAME;
    private Byte[] m_authTerminal;
    private Byte[] m_authProgramName;
    private Byte[] m_authMachine;
    private Byte[] m_authPid;
    private Byte[] m_authSid;
    private Byte[] m_authPassw;
    private Byte[] m_authNewPassw;
    private Byte[] m_authSessionKey;
    private Byte[] m_authVerifierData;
    private Byte[] m_authAlterSession;
    private Byte[] m_authProxyClientName;
    private Byte[] m_authSessionId;
    private Byte[] m_authSerialNum;
    private Byte[] m_authDebugJDWPValue;
    private Byte[] m_authConnectString;
    private Byte[] m_sessionClientCharSet;
    private Byte[] m_sessionClientLibType;
    private Byte[] m_sessionClientDriverName;
    private Byte[] m_sessionClientVersion;
    private Byte[] m_sessionClientLobAttr;
    private Byte[] m_authOraEditionAttr;
    private Byte[] m_authToken;
    private Byte[] m_authHeader;
    private Byte[] m_authSignature;
    private Byte[] m_drcpConnectionClass;
    private Byte[] m_drcpTag;
    private Byte[] m_drcpMultipropTag;
    private Byte[] m_drcpSessionPurity;
    private Byte[] m_drcpFixupCB;
    private static Byte[] KZSR_SVR_RESPONSE;
    private static Byte[] KZSR_CLI_RESPONSE;
    private static Byte[] m_clientLobAttr;
    internal Hashtable m_sessionProperties;
    private Byte[] m_terminalName;
    private Byte[] m_programName;
    private Byte[] m_hostName;
    private Byte[] m_userName;
    private Byte[] m_processId;
    private Byte[] m_connectstring;
    private Byte[] m_clientCharSet;
    private Byte[] m_clientLibType;
    private Byte[] m_clientDriverName;
    private Byte[] m_clientVersion;
    private Byte[] m_encryptedSK;
    private Byte[] m_alterSessionSql;
    private int m_verifierType;
    private Byte[] m_salt;
    private Byte[] m_encryptedKB;
    internal Byte[] m_xoredKaAndKb;
    private Byte[] m_conFounder;
    private Byte[] m_encryptedPassw;
    private Byte[] m_newEncryptedPassw;
    private Byte[] m_pbkdf2_speedy_key;
    internal TTCProtocolNegotiation m_ttcPro;
    internal TTCDataTypeNegotiation m_ttcDty;
    internal bool m_bSendEndOfRPCFlagWithNextRPC;
    private static TTCAuthenticate();
    internal TTCAuthenticate(MarshallingEngine marshallingEngine, int lcid, bool b_setUseHourOffset);
    internal void ReInit(MarshallingEngine marshallingEngine, int lcid, bool b_setUseHourOffset);
    internal void WriteOSessKeyMessage(string userName, long logonMode);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCAuthenticate/<ReadOSessKeyResponseAsync>d__195")]
internal ValueTask ReadOSessKeyResponseAsync(bool bAsync);
    internal void ReadOSessKeyResponse(bool bAsync);
    internal void EncryptNewPassword(OracleOpaqueString opaqueNewPassw);
    internal void WriteOAuthMessage(string userName, OracleOpaqueString opaquePassw, string proxyClientName, bool bProxyAuth, int sessionId, int serialNum, long logonMode, OracleOpaqueString opaqueNewPassw, byte logonCompatibility, bool bExternalAuth, bool bSendJDWP, string clientCharSet, OracleAccessToken accessToken, bool bUsingFastConnect);
    private void DoMarshalOauth(Byte[] userName, long logonMode, string proxyClientName, bool bProxyAuth, int sessionId, int serialNum, bool bExternalAuth, bool bSendJDWP, string clientCharSet, OracleAccessToken accessToken, bool bUsingFastConnect);
    internal static string ConvertVersionIntToString(MarshallingEngine mEngine, int dbRawVersion, Int32& dbMajorVer, Int32& dbMinorVer, Int32& dbPatchsetVer);
    internal int ClientVersionStringToInt(string driverVersion);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCAuthenticate/<ReceiveOAuthResponseAsync>d__202")]
internal ValueTask`1<bool> ReceiveOAuthResponseAsync(bool bAsync);
    internal bool ReceiveOAuthResponse(bool bAsync);
}
internal class OracleInternal.TTC.TTCBFile : TTCLob {
    internal static int KOLBLXFXL;
    internal static int KOLBLNAML;
    internal static int KOLBLNMXL;
    internal static int KOLBLLENL;
    internal static int KOLBLVSNL;
    internal static int KOLBLFLGL;
    internal static int KOLBLBYTL;
    internal static int KOLBLFIDB;
    internal static int KOLBLXSPRB;
    internal static int KOLBLDRLB;
    internal static int KOLBLDIRB;
    internal static int KOLBLBYTB;
    internal TTCBFile(MarshallingEngine mEngine);
    internal virtual CreateTemporaryLobTTC_RefAndOutParamArgCtx CreateTemporaryLob(bool bCache, bool bNClob, int duration, CreateTemporaryLobTTC_RefAndOutParamArgCtx ctlTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCBFile/<CreateTemporaryLobAsync>d__14")]
internal virtual ValueTask`1<CreateTemporaryLobTTC_RefAndOutParamArgCtx> CreateTemporaryLobAsync(bool bCache, bool bNClob, int duration, CreateTemporaryLobTTC_RefAndOutParamArgCtx ctlTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal Byte[] SetDirFileName(string directoryName, string fileName);
    internal bool Open(Byte[] lobLocator, int mode);
    internal bool Close(Byte[] lobLocator);
    internal bool Exists(Byte[] lobLocator);
}
internal class OracleInternal.TTC.TTCBlob : TTCLob {
    internal TTCBlob(MarshallingEngine mEngine);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCBlob/<CreateTemporaryLobAsync>d__1")]
internal virtual ValueTask`1<CreateTemporaryLobTTC_RefAndOutParamArgCtx> CreateTemporaryLobAsync(bool bCache, bool bNClob, int duration, CreateTemporaryLobTTC_RefAndOutParamArgCtx ctlTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal virtual CreateTemporaryLobTTC_RefAndOutParamArgCtx CreateTemporaryLob(bool bCache, bool bNClob, int duration, CreateTemporaryLobTTC_RefAndOutParamArgCtx ctlTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal bool Open(Byte[] lobLocator, int mode);
    internal bool Close(Byte[] lobLocator);
}
internal class OracleInternal.TTC.TTCCancel : TTCFunction {
    internal TTCCancel(MarshallingEngine mEngine);
    internal void Write(ArrayList cursorIdList);
}
internal class OracleInternal.TTC.TTCChunkInfo : TTCFunction {
    private static int KPDXSHCHUNKINFOFLAGS_KEY;
    private static int KPDXSHCHUNKINFOFLAGS_CHUNK;
    private static int KPDXSHCHUNKINFOFLAGS_SGKEY;
    internal TTCChunkInfo(MarshallingEngine mEngine);
    private static TTCChunkInfo();
    internal void AddAsPiggyback(string shardingKey, string superShardingKey, string chunkName);
}
internal class OracleInternal.TTC.TTCClob : TTCLob {
    internal bool m_bLittleEndianClob;
    internal TTCClob(MarshallingEngine mEngine);
    internal OCReadTTC_RefAndOutParamArgCtx Read(Byte[] lobLocator, long locatorOffset, long numCharsToRead, bool bVariableWidthChar, OCReadTTC_RefAndOutParamArgCtx ocReadTTC_refOutctx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCClob/<ReadAsync>d__4")]
internal ValueTask`1<OCReadTTC_RefAndOutParamArgCtx> ReadAsync(Byte[] lobLocator, long locatorOffset, long numCharsToRead, bool bVariableWidthChar, OCReadTTC_RefAndOutParamArgCtx ocReadTTC_refOutctx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal bool Read(Byte[] lobLocator, long locatorOffset, long numCharsToRead, List`1<ArraySegment`1<byte>> dataSegments, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCClob/<ReadAsync>d__6")]
internal ValueTask`1<bool> ReadAsync(Byte[] lobLocator, long locatorOffset, long numCharsToRead, List`1<ArraySegment`1<byte>> dataSegments, OracleConnectionImpl connectionImpl, bool bAsync);
    internal OCWriteTTC_RefAndOutParamArgCtx Write(Byte[] lobLocator, bool bIsNClob, short serverNCharSet, long locatorOffset, Char[] inBuffer, long inBufferOffset, long numCharsToWrite, OCWriteTTC_RefAndOutParamArgCtx ocWriteTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCClob/<WriteAsync>d__8")]
internal ValueTask`1<OCWriteTTC_RefAndOutParamArgCtx> WriteAsync(Byte[] lobLocator, bool bIsNClob, short serverNCharSet, long locatorOffset, Char[] inBuffer, long inBufferOffset, long numCharsToWrite, OCWriteTTC_RefAndOutParamArgCtx ocWriteTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal OCWriteTTC_RefAndOutParamArgCtx Write(Byte[] lobLocator, bool bIsNClob, short serverNCharSet, long locatorOffset, Byte[] inBuffer, long inBufferOffset, long numCharsToWrite, bool bVariableWidthChar, OCWriteTTC_RefAndOutParamArgCtx ocWriteTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCClob/<WriteAsync>d__11")]
internal ValueTask`1<OCWriteTTC_RefAndOutParamArgCtx> WriteAsync(Byte[] lobLocator, bool bIsNClob, short serverNCharSet, long locatorOffset, Byte[] inBuffer, long inBufferOffset, long numCharsToWrite, bool bVariableWidthChar, OCWriteTTC_RefAndOutParamArgCtx ocWriteTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal virtual CreateTemporaryLobTTC_RefAndOutParamArgCtx CreateTemporaryLob(bool bCache, bool bNClob, int duration, CreateTemporaryLobTTC_RefAndOutParamArgCtx ctlTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCClob/<CreateTemporaryLobAsync>d__13")]
internal virtual ValueTask`1<CreateTemporaryLobTTC_RefAndOutParamArgCtx> CreateTemporaryLobAsync(bool bCache, bool bNClob, int duration, CreateTemporaryLobTTC_RefAndOutParamArgCtx ctlTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal bool Open(Byte[] lobLocator, int mode);
    internal bool Close(Byte[] lobLocator);
}
internal class OracleInternal.TTC.TTCClose : TTCFunction {
    internal TTCClose(MarshallingEngine mEngine);
    internal void Write(ArrayList cursorIdList);
}
internal class OracleInternal.TTC.TTCColumnInfo : object {
    internal static int UDSFCOL_IS_IDENTITY;
    internal static int UDSFCOL_IS_GEN_ALWAYS;
    internal static int UDSFCOL_IS_GEN_BY_DEFAULT_ON_NULL;
    internal static int UDSFCOL_IS_JSON;
    internal static int UDSFCOL_IS_VALUELOB;
    internal static int UDSFCOL_IS_OSON;
    internal static int UDSFCOL_HAS_DOMAIN;
    internal static int UDSFCOL_HAS_ANNOTATIONS;
    private static TTCColumnInfo();
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCColumnInfo/<ReadMessageAsync>d__8")]
internal static ValueTask ReadMessageAsync(MarshallingEngine mEngine, ColumnDescribeInfo colMetaData, bool bIgnoreMetadata, bool bAsync);
    internal static void ReadMessage(MarshallingEngine mEngine, ColumnDescribeInfo colMetaData, bool bIgnoreMetadata, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCColumnInfo/<ReadTagsAnnotationsValuesAsync>d__10")]
internal static ValueTask`1<List`1<Hashtable>> ReadTagsAnnotationsValuesAsync(MarshallingEngine mEngine, bool bAsync);
    internal static List`1<Hashtable> ReadTagsAnnotationsValues(MarshallingEngine mEngine);
}
internal class OracleInternal.TTC.TTCColumnMetaData : object {
    internal static short UACFIND;
    internal static short UACFALN;
    internal static short UACFRCP;
    internal static short UACFBBV;
    internal static short UACFNCP;
    internal static short UACFBLP;
    internal static short UACFARR;
    internal static short UACFIGN;
    internal static int UACFNSCL;
    internal static int UACFBUC;
    internal static int UACFSKP;
    internal static int UACFCHRCNT;
    internal static int UACFNOADJ;
    internal static int UACFCUS;
    internal static int UACFLSZ;
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCColumnMetaData/<ReadMessageAsync>d__15")]
internal static ValueTask ReadMessageAsync(MarshallingEngine mEngine, ColumnDescribeInfo colMetaData, bool bIgnoreMetadata, bool bAsync);
    internal static void ReadMessage(MarshallingEngine mEngine, ColumnDescribeInfo colMetaData, bool bIgnoreMetadata);
    internal static void WriteMessage(MarshallingEngine mEngine, ColumnDescribeInfo colMetaData);
}
internal static class OracleInternal.TTC.TTCCookie : object {
    internal static byte s_cookieVersion;
    private static TTCCookie();
    internal static void WriteMessage(MarshallingEngine mEngine, ConnectionCookie connCookie);
}
internal class OracleInternal.TTC.TTCDataTypeNegotiation : TTCMessage {
    internal static byte TTC_FLD_VSN_820;
    internal static byte TTC_FLD_VSN_902;
    internal static byte TTC_FLD_VSN_1000;
    internal static byte TTC_FLD_VSN_1020;
    internal static byte TTC_FLD_VSN_1100;
    internal static byte TTC_FLD_VSN_1120;
    internal static byte TTC_FLD_VSN_1200;
    internal static byte TTC_FLD_VSN_1220;
    internal static byte TTC_FLD_VSN_1220_EXT1;
    internal static byte TTC_FLD_VSN_18_1;
    internal static byte TTC_FLD_VSN_18_1_EXT1;
    internal static byte TTC_FLD_VSN_20_1;
    internal static byte TTC_FLD_VSN_19_1;
    internal static byte TTC_FLD_VSN_19_3;
    internal static byte TTC_FLD_VSN_20_1_EXT1;
    internal static byte TTC_FLD_VSN_21_1;
    internal static byte TTC_FLD_VSN_23_1;
    internal static byte TTC_FLD_VSN_23_1_EXT1;
    internal static byte TTC_FLD_VSN_23_1_EXT2;
    internal static byte TTC_FLD_VSN_23_1_EXT3;
    internal static byte TTC_FLD_VSN_23_1_EXT4;
    internal static byte TTC_FLD_VSN_23_1_EXT5;
    internal static byte TTC_FLD_VSN_23_1_EXT6;
    internal static byte TTC_FLD_VSN_23_4;
    internal static byte TTC_FLD_VSN_MAX;
    internal static byte KPCCAP_TTC_VSN_OFFSET;
    private static byte KPULMAXL;
    internal static byte KPCCAP_CTB_TTC1_EOCS;
    private static byte KPCCAP_CTB_TTC1_INRC;
    private static byte KPCCAP_CTB_TTC1_FBVC;
    internal static byte KPCCAP_CTB_OCI1_FSAP;
    private static byte KPCCAP_CTB_OCI1_APCTX;
    private static byte KOLE_LOB_CAP_UB8_SIZE;
    private static byte KPCCAP_CTB_OCI3_OCSSYNC;
    private static byte KPCCAP_CTB_OCI3_APPCONT_AUTO;
    private static byte KOLE_LOB_CAP_ENCS;
    private static byte KOLE_LOB_CAP_DIL;
    private static byte KOLE_LOB_CAP_TMPLOC_SZ;
    private static byte KOLE_LOB_CAP_ARRAY;
    private static byte KOLE_LOB_CAP_PRFCH;
    private static byte KOLE_LOB_CAP_12C;
    private static byte KOLE_LOB2_CAP_QUASI;
    private static byte KOLE_LOB_CAP_ALL;
    private static int KPCCAP_KOLE_LOB_OFFSET;
    private static byte KOLE_LOB2_CAP_ALL;
    private static int KPCCAP_CT_LLOB2_OFFSET;
    private static int KPCCAP_CT_AQ_OFFSET;
    private static byte KPCCAP_CT_AQ_PROP_DQA;
    private static byte KPCCAP_CT_AQ_BUFQ;
    private static byte KPCCAP_CT_AQ_BPROP_RCV;
    private static byte KPCCAP_CT_AQ_ENQ_OPT;
    private static byte KPCCAP_CT_AQ_NTFN_QPT;
    private static byte KPCCAP_CT_AQ_NTFN_GRP;
    private static byte KOPT_VNFT;
    private static byte KPCCAP_CTB_TTC2_ZLNP;
    private static byte KPCCAP_CTB_TTC2_NCPR;
    private static byte ZTVOV_KPCLOG_O30L;
    private static byte ZTVOV_KPCLOG_O3L;
    internal static byte ZTVOV_KPCLOG_O5L_NP;
    private static byte ZTVOV_KPCLOG_O4L;
    internal static byte ZTVOV_KPCLOG_O5L;
    private static byte ZTVOV_KPCLOG_O6L;
    internal static byte KZTVOV_KPCLOG_O7L_MR;
    private static int KZTVOV_KPCLOG_O8L_LI;
    private static int KZTVOV_KPCLOG_09L_LP;
    internal static int KPCCAP_CTB_TTC3_COLMETADATA;
    private static byte KPCCAP_CTB_TTC3_TZVER;
    internal static int KPCCAP_CTB_TTC3_LTXID;
    internal static int KPCCAP_CTB_TTC3_IMPLRES;
    internal static int KPCCAP_CTB_TTC3_BIGCHUNK_CLR;
    internal static int KPCCAP_CTB_TTC3_KEEP_OUT_ORDER;
    internal static byte KPCCAP_CT_DTYSESSSIGN_REC_VSN;
    internal static int KPCCAP_CT_DTYSESSSIGN_REC_VSN_OFFSET;
    internal static int KPCCAP_CTB_TTC4_RENEG;
    internal static byte KPCCAP_CTB_TTC4_FASTRENEG;
    internal static int KPCCAP_CTB_TTC4_IBNM;
    internal static int KPCCAP_CTB_TTC4_BIG_TZTC;
    internal static int KPCCAP_CTB_TTC4_EXPL_BOUND;
    internal static int KPCCAP_CT_UB2DTY;
    internal static int KPCCAP_CTB_TTC3;
    internal static int KPCCAP_CTB_XML;
    internal static int KPCCAP_CTB_XML_UNSET;
    internal static int KPCCAP_CTB_XML_CSXXMLT;
    internal static int KPCCAP_CTB_XML_LOBSTR_IMG_ONLY;
    internal static int KPCCAP_CTB_DDL_NTFN;
    internal static int KPCCAP_CTB_PREFETCH_ROWS;
    internal static int KPCCAP_CTB_IMPLICIT_POOL;
    internal static int KPCCAP_CTB_XML_LOBTOKENBASED_IMG_ONLY;
    internal static int KPCCAP_CTB_OCI2;
    internal static int KPCCAP_CTB_OCI2_SCTAF;
    internal static int KPCCAP_CTB_OCI2_FTHDR;
    internal static int KPCCAP_CTB_OCI2_CQC;
    internal static int KPCCAP_CTB_OCI2_EDITION;
    internal static int KPCCAP_CTB_OCI2_SRVCP;
    internal static int KPCCAP_RTB_TTC_SESSSTATEOPS;
    internal static int KPCCAP_CTB_TTC5_VECTOR_OFFSET;
    internal static byte KPCCAP_CTB_TTC5_VECTOR;
    internal static byte KPCCAP_CTB_TTC5_VECTOR_UNSET;
    private static int KPCCAP_RTB_TTC;
    private static int KPCCAP_RTB_TTC_ZCPY;
    private static byte KPCCAP_RTB_TTC_TZLT;
    private static byte KPCCAP_RTB_TTC_32K;
    private static short DTYEXPBASE;
    private static short DTY0;
    private static short DTYCHR;
    private static short DTYNUM;
    private static short DTYINT;
    private static short DTYFLT;
    private static short DTYSTR;
    private static short DTYVNU;
    private static short DTYPDN;
    private static short DTYLNG;
    private static short DTYVCS;
    private static short DTYTI5;
    private static short DTYRID;
    private static short DTYDAT;
    private static short DTYIDT;
    private static short DTYIJU;
    private static short DTYVBI;
    private static short DTYDIF;
    private static short DTYDOF;
    private static short DTYDTZ;
    private static short DTYDYN;
    private static short DTYDPC;
    private static short DTYBFLOAT;
    private static short DTYBDOUBLE;
    internal static short DTYBIN;
    internal static short KKCN_CTX_RAW;
    private static short DTYUB1;
    private static short DTYLBI;
    private static short DTYUB2;
    private static short DTYUB4;
    private static short DTYB1;
    private static short DTYB2;
    private static short DTYB4;
    private static short DTYSB4;
    private static short DTYWORD;
    private static short DTYUWORD;
    private static short DTYIIN;
    private static short DTYCURID;
    private static short DTYAMID;
    private static short DTYDBA;
    private static short DTYPTN;
    private static short DTYPB;
    private static short DTYPW;
    private static short DTYOER8;
    private static short DTYFUN;
    private static short DTYAUA;
    private static short DTYRXH7;
    private static short DTYNA6;
    private static short DTYOAC;
    private static short DTYAMS;
    private static short DTYBRN;
    private static short DTYBRP;
    private static short DTYBRV;
    private static short DTYKVA;
    private static short DTYCLS;
    private static short DTYCUI;
    private static short DTYDFN;
    private static short DTYDQR;
    private static short DTYDSC;
    private static short DTYEXE;
    private static short DTYFCH;
    private static short DTYGBV;
    private static short DTYGEM;
    private static short DTYGIV;
    private static short DTYOKG;
    private static short DTYHMI;
    private static short DTYINO;
    private static short DTYOPQ;
    private static short DTYLNF;
    private static short DTYONT;
    private static short DTYOPE;
    private static short DTYOSQ;
    private static short DTYSFE;
    private static short DTYSPF;
    private static short DTYVSN;
    private static short DTYUD7;
    private static short DTYDSA;
    private static short DTYUIN;
    private static short DTYBRI;
    private static short DTY70;
    private static short DTYPIN;
    private static short DTYPFN;
    private static short DTYPPT;
    private static short DTYOCU;
    private static short DTYSTO;
    private static short DTY76;
    private static short DTYARC;
    private static short DTYMRS;
    private static short DTYMRT;
    private static short DTYMRG;
    private static short DTYMRR;
    private static short DTYMRC;
    private static short DTYVER;
    private static short DTYLON2;
    private static short DTYINO2;
    private static short DTYALL;
    private static short DTYUDB;
    private static short DTYAQI;
    private static short DTYULB;
    private static short DTYULD;
    private static short DTYSLS;
    private static short DTYSID;
    private static short DTYNA7;
    private static short DTYLVC;
    private static short DTYLVB;
    private static short DTYAFC;
    private static short DTYAVC;
    private static short DTYAL7;
    private static short DTYK2RPC;
    private static short DTYIBFLOAT;
    private static short DTYIBDOUBLE;
    private static short DTYCUR;
    private static short DTYXDP;
    private static short DTYRDD;
    private static short DTYARR;
    private static short DTYVAR;
    private static short DTYLAB;
    private static short DTYOSL;
    private static short DTYOKO8;
    private static short DTYNTY;
    private static short DTYINTY;
    private static short DTYREF;
    private static short DTYIREF;
    private static short DTYCLOB;
    private static short DTYBLOB;
    private static short DTYBFIL;
    private static short DTYFILE;
    private static short DTYCFIL;
    private static short DTYRSET;
    private static short DTYCWD;
    private static short DTYSVT;
    private static short DTYJSON;
    private static short DTYNAC122;
    private static short DTYADT;
    private static short DTYNTB;
    private static short DTYNAR;
    private static short DTYVEC;
    private static short DTYUD12;
    private static short DTYAL8;
    private static short DTYLFOP;
    private static short DTYFCRT;
    private static short DTYDNY;
    private static short DTYOPR;
    private static short DTYPLS;
    private static short DTYXID;
    private static short DTYTXN;
    private static short DTYDCB;
    private static short DTYCCA;
    private static short DTYWRN;
    private static short DTYOBJ;
    private static short DTYTLH121;
    private static short DTYTOH121;
    private static short DTYFOI;
    private static short DTYSID2;
    private static short DTYTCH;
    private static short DTYPII;
    private static short DTYPFI;
    private static short DTYPPU;
    private static short DTYPTE;
    private static short DTYCLV;
    private static short DTYBLV;
    private static short DTYRXH8;
    private static short DTYTN12;
    private static short DTYAUTH;
    private static short DTYKVAL;
    private static short DTYDTR;
    private static short DTYDUN;
    private static short DTYDOP;
    private static short DTYVST;
    private static short DTYODT;
    private static short DTYFGI;
    private static short DTYDSY;
    private static short DTYDSYR8;
    private static short DTYDSYH8;
    private static short DTYDSYL;
    private static short DTYDSYT8;
    private static short DTYDSYV8;
    private static short DTYDSYP;
    private static short DTYDSYF;
    private static short DTYDSYK;
    private static short DTYDSYY;
    private static short DTYDSYQ;
    private static short DTYDSYC;
    private static short DTYDSYA;
    private static short DTYOT8;
    private static short DTYDOL;
    private static short DTYDSYTY;
    private static short DTYAQE;
    private static short DTYKV;
    private static short DTYAQD;
    private static short DTYAQ8;
    private static short DTYTIME;
    private static short DTYTTZ;
    private static short DTYSTAMP;
    private static short DTYSTZ;
    private static short DTYIYM;
    private static short DTYIDS;
    private static short DTYEDATE;
    private static short DTYETIME;
    private static short DTYETTZ;
    private static short DTYESTAMP;
    private static short DTYESTZ;
    private static short DTYEIYM;
    private static short DTYEIDS;
    private static short DTYLDIIF;
    private static short DTYLDIOF;
    private static short DTYRFS;
    private static short DTYRXH10;
    private static short DTYDCLOB;
    private static short DTYDBLOB;
    private static short DTYDBFIL;
    private static short DTYDJSON;
    private static short DTYDVEC;
    private static short DTYKPN;
    private static short DTYKPDNR;
    private static short DTYDSYD;
    private static short DTYDSYS;
    private static short DTYDSYR;
    private static short DTYDSYH;
    private static short DTYDSYT;
    private static short DTYDSYV;
    private static short DTYAQM;
    private static short DTYOER11;
    private static short DTYBURI;
    private static short DTYPSR;
    private static short DTYAQL;
    private static short DTYOTC;
    private static short DTYKFNO;
    private static short DTYKFNP;
    private static short DTYOKGT8;
    private static short DTYRASB4;
    private static short DTYRAUB2;
    private static short DTYRAUB1;
    private static short DTYRATXT;
    private static short DTYRSSB4;
    private static short DTYRSUB2;
    private static short DTYRSUB1;
    private static short DTYRSTXT;
    private static short DTYRIDL;
    private static short DTYGLRDD;
    private static short DTYGLRDG;
    private static short DTYGLRDC;
    private static short DTYOKO;
    private static short DTYDPP;
    private static short DTYDPLS;
    private static short DTYDPMOP;
    private static short DTYSITZ;
    private static short DTYESITZ;
    private static short DTYUB8;
    private static short DTYSTAT;
    private static short DTYRFX;
    private static short DTYFAL;
    private static short DTYCKV;
    private static short DTYDRCX;
    private static short DTYKGH;
    private static short DTYAQO;
    private static short DTYPNTY;
    private static short DTYOKGT;
    private static short DTYKPFC;
    private static short DTYFE2;
    private static short DTYSPFP;
    private static short DTYDPULS;
    private static short DTY_T_VA;
    private static short DTY_T_TB;
    private static short DTYNLOB;
    private static short DTYREC;
    private static short DTYTAB;
    private static short DTYBOL;
    private static short DTYAQA;
    private static short DTYKPBF;
    private static short DTYDTY;
    private static short DTYTSM;
    private static short DTYMSS;
    private static short DTYABS;
    private static short DTYKPC;
    private static short DTYCRS;
    private static short DTYKKS;
    private static short DTYKSP;
    private static short DTYKSPTOP;
    private static short DTYKSPVAL;
    private static short DTYPSS;
    private static short DTYNLS;
    private static short DTYALS;
    private static short DTYKSDEVTVAL;
    private static short DTYKSDEVTTOP;
    private static short DTYKPSPP;
    private static short DTYKOL;
    private static short DTYLST;
    private static short DTYACX;
    private static short DTYSCS;
    private static short DTYRXH;
    private static short DTYKPDNS;
    private static short DTYKPDCN;
    private static short DTYKPNNS;
    private static short DTYKPNCN;
    private static short DTYKPS;
    private static short DTYAPINF;
    private static short DTYTEN;
    private static short DTYXSSCS;
    private static short DTYXSSSO;
    private static short DTYXSSAO;
    private static short DTYKSRPC;
    private static short DTYKVL;
    private static short DTYAQEO;
    private static short DTYSESSGET;
    private static short DTYSESSRLS;
    private static short DTYXSSSDEF;
    private static short DTYKPDQCINV;
    private static short DTYKPDQIDC;
    private static short DTYKPDQCSTA;
    private static short DTYKPRS;
    private static short DTYKPDQCID;
    private static short DTYTRCEVT;
    private static short DTYRTSTRM;
    private static short DTYSESSRET;
    private static short DTYSCN6;
    private static short DTYKECPA;
    private static short DTYKECPP;
    private static short DTYSXA;
    private static short DTYKVARR;
    private static short DTYKPNGN;
    private static short DTYXSNSOP;
    private static short DTYXSATTR;
    private static short DTYXSNS;
    private static short DTYTXT;
    private static short DTYXSSESSNS;
    private static short DTYXSATTOP;
    private static short DTYXSCREOP;
    private static short DTYXSDETOP;
    private static short DTYXSDESOP;
    private static short DTYXSSETSP;
    private static short DTYXSSIDP;
    private static short DTYXSPRIN;
    private static short DTYXSKVL;
    private static short DTYXSSSDEF2;
    private static short DTYXSNSOP2;
    private static short DTYXSNS2;
    private static short DTYIMPLRES;
    private static short DTYOER19;
    private static short DTYUB1ARRAY;
    private static short DTYSESSSTATE;
    private static short DTYAPPCONTREPLAY;
    private static short DTYAPPCONTCTL;
    private static short DTYKPDSSTEMPLATE;
    private static short DTYKPDNREQ;
    private static short DTYKPDNRNF;
    private static short DTYKPNGNC;
    private static short DTYKPNRI;
    private static short DTYAQENQ;
    private static short DTYAQDEQ;
    private static short DTYAQJMS;
    private static short DTYKPDNRPAY;
    private static short DTYKPDNRACK;
    private static short DTYKPDNRMP;
    private static short DTYKPDNRDQ;
    private static short DTYCHUNKINFO;
    private static short DTYSCN;
    private static short DTYSCN8;
    private static short DTYUD21;
    private static short DTYTNP;
    private static short DTYTLH;
    private static short DTYTOH;
    private static short DTYSNP;
    private static short DTYNAC;
    private static short DTYSESSSIGN;
    private static short DTYKPDXFT;
    private static short DTYKPDXST;
    private static short DTYKPDXSTPROT;
    private static short DTYKPDXSTTCP;
    private static short DTYOER;
    private static short DTYSHRDKEYSYNC;
    private static short DTYPLEND;
    private static short DTYPLBGN;
    private static short DTYPLBLK;
    private static short DTYUDS;
    private static short DTYPLOPN;
    private static short DTYMAX;
    private static short SCALAR;
    private static short RECORD;
    private static Int16[] typeAndRep;
    private static Int16[] typeAndRepFor1100;
    private static Int16[] typeAndRepFor1200;
    private Int16[] runtimeTypeAndRep;
    internal static int s_latestTZVersion;
    private static short UTF8_CHARACTER_SET_ID;
    internal short m_clientRemoteIn;
    internal short m_clientRemoteOut;
    internal short m_ncharSetId;
    internal Byte[] m_dbTimeZoneBytes;
    internal bool m_sendTZDataAsLocalTime;
    internal byte m_clientFlags;
    internal Byte[] m_CompileTimeCapabilities;
    private static byte KPCCAP_RT_TZ;
    private static byte KPCCAP_RT_COMPAT_UNK;
    private static byte KPCCAP_RT_COMPAT_80;
    private static byte KPCCAP_RT_COMPAT_81;
    private static byte KPCCAP_RT_TZ_EX;
    internal Byte[] m_RuntimeCapabilities;
    internal bool m_b32kTypeSupported;
    internal bool m_bSvrSupportRequestBoundary;
    private static TTCDataTypeNegotiation();
    internal TTCDataTypeNegotiation(MarshallingEngine marshallingEngine);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCDataTypeNegotiation/<ReadResponseAsync>d__0")]
internal ValueTask ReadResponseAsync(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCDataTypeNegotiation/<ValidateTypeRepresentationsAsync>d__1")]
private ValueTask`1<bool> ValidateTypeRepresentationsAsync(bool bAsync);
    private static void AddTypeRepresentation(short dty, short ttctype, short ndty, short rep);
    internal void Initialize(Byte[] serverCompileTimeCap, Byte[] serverRunTimeCap, short serverCharacterSet, short serverNCharSet, byte serverFlags);
    internal virtual void ReInit(MarshallingEngine marshallingEngine);
    private void MarshalTypeReps();
    internal void WriteMessage(Byte[] serverCompileTimeCap, Byte[] serverRunTimeCap, short serverCharacterSet, short serverNCharSet, byte serverFlags);
    internal static Byte[] GetTZBytes();
    internal void SetBasicTypeRepresentations(TTCTypeRepresentation types);
    internal void ReadResponse(bool bAsync);
    private bool ValidateTypeRepresentations(bool bAsync);
}
internal class OracleInternal.TTC.TTCDescribe : TTCFunction {
    private static byte OPERATIONFLAGS;
    private static long SQLPARSEVERSION;
    private static int INVALID_CURSOR_ID;
    internal static int DESCRIBE_SQLTEXT;
    private static bool UDSARRAYO2U;
    private static bool NUMUDSO2U;
    internal TTCDescribe(MarshallingEngine mEngine);
    private void WriteMessage(int cursorId, Byte[] sqltext);
    internal void WriteMessage(int cursor);
    internal void WriteMessage(Byte[] sqltext);
    internal void ReadMessage(SQLMetaData sqlMetaData);
}
internal class OracleInternal.TTC.TTCDescribeInfo : object {
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCDescribeInfo/<ReadMessageAsync>d__0")]
internal static ValueTask ReadMessageAsync(bool bForDescribe, bool bForRefCursor, MarshallingEngine mEngine, SQLMetaData sqlMetaData, bool bIgnoreMetadata, bool bAsync);
    internal static void ReadMessage(bool bForDescribe, bool bForRefCursor, MarshallingEngine mEngine, SQLMetaData sqlMetaData, bool bIgnoreMetadata, bool bAsync);
}
internal class OracleInternal.TTC.TTCDirectPathLoadStream : TTCFunction {
    private static short ODPLS;
    private static int DPLSDEF_IN_PARMCOUNT;
    private static int DPLSDEF_IN_FLAG;
    private static int DPLSDEF_IN_KLA_PARSE_RESET;
    private static int STREAM_VERSION;
    internal int m_DPLSVersion;
    private Int64[] m_dplsi4;
    private int m_dplsi4l;
    private Int64[] m_dplso4;
    internal DirectPathContext m_directPathCtx;
    internal TTCDirectPathLoadStream(MarshallingEngine mEngine);
    internal void Init(DirectPathContext DPCtx);
    internal void LoadStream(DirectPathStream dpStream);
    private void MarshalStream(DirectPathStream dpStream);
    internal void MarshalHeader(long streamSize);
    internal void ReadResponse();
    private void Process_RPA_Message();
}
internal class OracleInternal.TTC.TTCDirectPathMOP : TTCFunction {
    private static short ODPMOP;
    public static int DPMOPOPC_ABORT;
    public static int DPMOPOPC_FINISH;
    public static int DPMOPOPC_FLUSH;
    public static int DPMOPOPC_DATASAVE;
    public static int DPMOPOPC_SETIU;
    public static int DPMOPOPC_FINISH_ONLY;
    public static int DPMOPOPC_ABORT_ONLY;
    public static int DPMOPOPC_CALL_KDBLAI;
    public static int DPMOPDEF_DATASAVEOPT_SAVEONLY;
    public static int DPMOPDEF_DATASAVEOPT_FINISH;
    public static int DPMOPDEF_DATASAVEOPT_PARTIAL;
    public static int DPMOPDEF_IN_PARMCOUNT;
    public static int DPMOPDEF_OUT_PARMCOUNT;
    private DirectPathContext m_directPathContext;
    private Int64[] m_dpmopi4;
    private int m_dpmopi4l;
    private Int64[] m_dpmopo4;
    internal TTCDirectPathMOP(MarshallingEngine mEngine);
    internal void Init(DirectPathContext directPathCtx);
    internal void Commit();
    internal void Abort();
    internal void WriteMessage(int OpCode);
    internal void ReadResponse();
    private void Process_RPA_Message();
}
internal class OracleInternal.TTC.TTCDirectPathPrepare : TTCFunction {
    private static short ODPP;
    private static byte DPPOPC_LOAD;
    private static byte DPPOPC_UNLOAD;
    private static byte DPPOPC_CONVERT;
    private static int DPPDEF_IN_IVRSN;
    private static long INTERFACE_VERSION;
    private static int DPPDEF_KW_OBJ_NAME;
    private static int DPPDEF_KW_SUB_NAME;
    private static int DPPDEF_KW_SCHEMA_NAME;
    private static int DPPDEF_KW_COLUMN_NAME;
    private static int DPPDEF_KW_SORTED_INDEX;
    private static int DPPDEF_KW_PARALLEL_FILE;
    private static int DPPDEF_KW_ADTATTR_NAME;
    private static int DPPDEF_KW_ADTATTR_EXPR;
    private static int DPPDEF_KW_ADTATTR_OBJ_CNT;
    private static int DPPDEF_KW_ADTATTR_OPQ_CNT;
    private static int DPPDEF_KW_ADTATTR_REF_CNT;
    private static int DPPDEF_KW_ADTATTR_TYPE;
    private static int DPPDEF_KW_METADATA;
    private static int DPPDEF_KW_UNLOAD_SCN_BASE;
    private static int DPPDEF_KW_UNLOAD_SCN_WRAP;
    private static int DPPDEF_KW_GRANULE_SIZE;
    private static int DPPDEF_KW_SERVER_ROWS;
    private static int DPPDEF_KW_COMMIT_EXPR;
    private static int DPPDEF_KW_ADTATTR_EXPR_CNT;
    private static int DPPDEF_KW_SUBTYPE_BITVECTORS;
    private static int DPPDEF_KW_SUBTYPE_INDEX;
    private static int DPPDEF_KW_SERVER_SLOT_SIZE;
    private static int DPPDEF_KW_DROPCOL_BITVECTOR;
    private static int DPPDEF_IN_STRVRSN;
    private static long STREAM_VERSION;
    private static int DPPDEF_IN_XFRSIZE;
    private static int DPPDEF_IN_NOLOG;
    private static int DPPDEF_IN_PARALLEL;
    private static int DPPDEF_IN_SKIP_UNUSABLE_INDEX;
    private static int DPPDEF_IN_SKIP_INDEX_MAINT;
    private static int DPPDEF_IN_SINGLE_ROW_INDEX;
    private static int DPPDEF_IN_STORAGE_INIT;
    private static int DPPDEF_IN_STORAGE_NEXT;
    private static int DPPDEF_IN_NESTED_TBL;
    private static int DPPDEF_IN_NFOBJTBL_OIDPOS;
    private static int DPPDEF_IN_SUBST_OBJTBL;
    private static int DPPDEF_IN_DONT_SKIP_UNUSABLE_INDEX;
    private static int DPPDEF_IN_LOCK_WAIT;
    private static int DPPDEF_IN_VARRAY_TBL;
    private static int DPPDEF_IN_NFOBJTBL_SIDPOS;
    private static int DPPDEF_IN_NFOBJTBL_VAIPOS;
    private static int DPPDEF_IN_PARTCONOPT;
    private static int DPPDEF_IN_INTPARTUSED;
    private static int DPPDEF_IN_INTSUBPARTUSED;
    private static int DPPDEF_IN_RTNLEAVECASE;
    private static int DPPDEF_IN_PARALLEL_LOB_LOAD;
    private static int DPPDEF_IN_NO_INDEX_ERRORS;
    private static int DPPDEF_IN_PARTITION_MEMORY;
    private static int DPPDEF_IN_TABLE_PREEXISTS;
    private static int DPPDEF_IN_USE_ACTIVE_TRANS;
    private static int DPPDEF_IN_LONG_VARCHAR;
    private static int DPPDEF_IN_ISLDRCLIENT;
    private static int DPPDEF_IN_COLSEGCOL_LOBORDER;
    private static int DPPDEF_IN_INTCOL_LOBORDER;
    private static int DPPDEF_IN_COMPRESS_UNLOAD_BUFFS;
    private static int DPPDEF_IN_DPFLAGS;
    private static int DPPDEF_IN_DEFAULTS;
    private static int DPPDEF_IN_DEFAULT_EXPR_CACHE_SIZE;
    private static int DPPDEF_IN_CONTINUE_ON_ERRORS;
    private static int DPPDEF_IN_USE_PENDING_TRANS;
    private static int DPPDEF_IN_PARMCOUNT;
    private static int DPPDEF_OUT_IVRSN;
    private static int DPPDEF_OUT_STRVRSN;
    private static int DPPDEF_OUT_XFRSIZE;
    private static int DPPDEF_OUT_RETCURSOR;
    private static int DPPDEF_OUT_SDBA_SAME;
    private static int DPPDEF_OUT_SDBAOFBITS;
    private static int DPPDEF_OUT_SDBANFBITS;
    private static int DPPDEF_OUT_SDBABITS;
    private static int DPPDEF_OUT_DBABBITS;
    private static int DPPDEF_OUT_DBAFNEW;
    private static int DPPDEF_OUT_DBAFOLD;
    private static int DPPDEF_OUT_RTNLEAVECASE;
    private static int DPPDEF_OUT_IN_WORKER_PROCESS;
    private static int DPPDEF_OUT_LONG_VARCHAR;
    private static int DPPDEF_OUT_PARMCOUNT;
    internal string m_schemaName;
    internal string m_tableName;
    internal string m_partitionName;
    internal String[] m_columnNames;
    internal ColumnDescribeInfo[] m_columnsMetaData;
    private List`1<TTCKeywordValuePair> m_dppiparm;
    private Int64[] m_dppi4;
    private int m_dppi4l;
    private TTCKeywordValuePair[] m_dppoparm;
    private Int64[] m_dppo4;
    internal TTCDirectPathPrepare(MarshallingEngine mEngine, bool bInTxn);
    private void setI4Value(int key, long value);
    internal void Init(string schemaName, string tableName, string partitionName, String[] columnNames);
    internal void WriteMessage();
    internal void ReadResponse(DirectPathContext& directPathContext);
    internal void Prepare(DirectPathContext& dpContext);
    private void Process_RPA_Message(DirectPathContext& directPathContext);
    private long getO4Value(int key);
    internal void PopulateDPContext(DirectPathContext& DPContext);
}
internal class OracleInternal.TTC.TTCDirectPathStreamMarshaller : object {
    private MarshallingEngine m_Engine;
    private IBulkCopyDataSource m_dataSource;
    private ColumnDescribeInfo[] m_columnsMetaData;
    internal int m_numOfRowsToBeProcessed;
    internal bool m_bIsComplete;
    internal int m_numOfRowsProcessed;
    internal void Init(MarshallingEngine mEngine, IBulkCopyDataSource dataSource, ColumnDescribeInfo[] columnsMetaData, int batchSize);
    internal static int RowPieceHeaderLen(short flags);
    internal static int MarshalRowPieceHeader(MarshallingEngine mEngine, DirectPathRowPiece rowPiece);
    private static void MarshalColLength(MarshallingEngine mEngine, int length);
    internal static void MarshallRowPiece(MarshallingEngine mEngine, BulkCopyBindingRow row, DirectPathRowPiece rowPiece);
}
internal class OracleInternal.TTC.TTCEndToEndMetrics : TTCFunction {
    internal static short KPDUSR_CID_RESET;
    internal static short KPDUSR_PROXY_RESET;
    internal static short KPDUSR_PROXY_TKTSENT;
    internal static short KPDUSR_MODULE_RESET;
    internal static short KPDUSR_ACTION_RESET;
    internal static short KPDUSR_EXECID_RESET;
    internal static short KPDUSR_EXECSQ_RESET;
    internal static short KPDUSR_COLLCT_RESET;
    internal static short KPDUSR_CLINFO_RESET;
    internal TTCEndToEndMetrics(MarshallingEngine mEngine);
    internal void Write(String[] endToEndMetrics, Boolean[] endToEndMetricsModified);
}
internal class OracleInternal.TTC.TTCError : TTCMessage {
    internal static int OERFUPD;
    internal static int OERFEXIT;
    internal static int OERFNCF;
    internal static int OERwNVIC;
    internal static int OERwUDnW;
    internal static int OERwCPER;
    internal static int OERFPLSW;
    internal TTCArrayBindError[] m_bindErrors;
    internal long m_curRowNumber;
    internal int m_retCode;
    private int m_arrayElemWError;
    private int m_arrayElemErrno;
    private int m_currCursorID;
    internal short m_errorPosition;
    private short m_sqlType;
    private byte m_oerFatal;
    internal short m_flags;
    private short m_userCursorOpt;
    private short m_upiParam;
    internal short m_warningFlag;
    private int m_osError;
    private short m_stmtNumber;
    private short m_callNumber;
    private int m_pad1;
    private long m_successIters;
    private int m_partitionId;
    private short m_tableId;
    private int m_slotNumber;
    private long m_rba;
    private long m_blockNumber;
    private int m_warnLength;
    internal int m_TTIWRNFlag;
    internal int m_ttiwrnNumber;
    internal Byte[] m_ttiwrnMsg;
    private Int16[] m_errorLength;
    internal Byte[] m_errorMsg;
    internal int ErrorCode { get; }
    internal Byte[] ErrorMessage { get; }
    internal int CursorId { get; }
    internal short Flags { get; }
    internal TTCError(MarshallingEngine mEngine);
    internal int get_ErrorCode();
    internal Byte[] get_ErrorMessage();
    internal int get_CursorId();
    internal short get_Flags();
    internal void Initialize();
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCError/<ReadErrorMessageAsync>d__46")]
internal ValueTask`1<int> ReadErrorMessageAsync(bool bAsync);
    internal int ReadErrorMessage(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCError/<ReadWarningAsync>d__48")]
internal ValueTask ReadWarningAsync(bool bAsync);
    internal void ReadWarning(bool bAsync);
}
internal class OracleInternal.TTC.TTCExecuteSql : TTCFunction {
    private static int UOPF_PRS;
    private static int UOPF_BND;
    private static int UOPF_EXE;
    private static int UOPF_FEX;
    private static int UOPF_FCH;
    private static int UOPF_CAN;
    private static int UOPF_COM;
    private static int UOPF_DSY;
    private static int UOPF_SIO;
    private static int UOPF_NPL;
    private static int UOPF_DFN;
    private static int UOPF_NCF;
    private static int UOPF_BER;
    private static int UOPF_SCN;
    private static int KPUCXDSY;
    internal static int AL8KW_CURRENCY;
    internal static int AL8KW_ISOCURR;
    internal static int AL8KW_NUMERICS;
    internal static int AL8KW_DATEFM;
    internal static int AL8KW_DATELANG;
    internal static int AL8KW_TERRITORY;
    internal static int AL8KW_CHARSET;
    internal static int AL8KW_SORT;
    internal static int AL8KW_CALENDAR;
    internal static int AL8KW_LANGUAGE;
    internal static int AL8KW_NLSCOMP;
    internal static int AL8KW_UNIONCUR;
    internal static int AL8KW_TIMEFM;
    internal static int AL8KW_STMPFM;
    internal static int AL8KW_TTZNFM;
    internal static int AL8KW_STZNFM;
    internal static int AL8KW_NLSLENSEM;
    internal static int AL8KW_NCHAREXCP;
    internal static int AL8KW_NCHARIMP;
    internal static int AL8KW_MAXLANG;
    internal static int AL8KW_TIMEZONE;
    internal static int AL8KW_ERR_OVLAP;
    internal static int AL8KW_SESSION_ID;
    internal static int AL8KW_SERIAL_NUM;
    internal static int AL8KW_TAG_FOUND;
    internal static int AL8KW_SCHEMA_NAME;
    internal static int AL8KW_SCHEMA_ID;
    internal static int AL8KW_ENABLED_ROLES;
    internal static int AL8KW_AUX_SESSSTATE;
    internal static int AL8KW_EDITION;
    internal static int AL8KW_SQL_TXLP;
    internal static int AL8KW_FSQL_SNTX;
    internal static int AL8KW_OPENCURSORS;
    internal static int AL8KW_PDBUID;
    internal static int AL8KW_DBID;
    internal static int AL8KW_GUDBID;
    internal static int AL8KW_DBNAME;
    internal static int AL8KW_PDB_SDATE;
    internal static int AL8KW_PDB_STIME;
    internal static int AL8KW_MAX_IDEN_LENGTH;
    internal static int AL8KW_SERVICE_NAME;
    internal static int AL8KW_MODULE;
    internal static int AL8KW_ACTION;
    internal static int AL8KW_CLIENT_INFO;
    internal static int AL8KW_ROW_ARCHIVAL;
    internal static int AL8KW_FAILOVER_TYPE;
    internal static int AL8KW_FAILOVER_DELAY;
    internal static int AL8KW_FAILOVER_RETRIES;
    internal static int AL8KW_FAILOVER_METHOD;
    internal static int AL8KW_COMMIT_OUTCOME;
    internal static int AL8KW_SERVICE_FLAGS;
    internal static int AL8KW_SESSSTATE_CONS;
    internal static int AL8KW_REPLAY_TIMEOUT;
    internal static int AL8KW_FAILOVER_RESTORE;
    internal static int AL8KW_CONTAINER_NAME;
    internal static int AL8KW_CLIENT_ID;
    internal static int AL8KW_ENABLED_ROLE_NAMES;
    internal static int AL8KW_PREFETCH_ROWS;
    internal static string AL8KW_NLSCOMP_M;
    internal static int LONGLIMITFOR12G;
    internal static int LONGLIMITFORDBLESSTHAN12G;
    private static long AL8EX_GET_PIDMLRC;
    private static long AL8EX_IMPL_RESULTS_CLIENT;
    private Int64[] m_al8i4;
    private TTCRowHeader m_rowHeader;
    private TTCRowData m_rowData;
    private TTCReExecuteSql m_reExecuteSql;
    internal Byte[] m_sessionTimeZone;
    internal bool m_bSessionTimeZoneUpdated;
    internal TTCReExecuteSql ReExecuteSqlObject { get; }
    internal TTCExecuteSql(MarshallingEngine mEngine);
    internal virtual void ReInit(MarshallingEngine marshallingEngine);
    internal TTCReExecuteSql get_ReExecuteSqlObject();
    internal void SendReExecuteRequest(OracleConnectionImpl connImpl, int cursorId, long noOfRowsToFetch, bool bAutoCommit, bool bDisableCompressedFetch, SqlStatementType stmtType, int arrayBindCount, MarshalBindParameterValueHelper& marshalArrayBindValuesHelper, bool bAsync);
    internal void SendExecuteRequest(OracleConnectionImpl connImpl, Byte[] sqlStmtByteStream, bool bHasReturningClause, int cursorId, Byte[] describeInfoHash, long dbChangeRegistrationId, ColumnDescribeInfo[] columnDefines, long noOfRowsToFetch, bool parse, bool execute, bool fetch, bool define, bool bAutoCommit, bool bDisableCompressedFetch, SqlStatementType stmtType, int longFetchSize, int arrayBindCount, Int64[] scnForSnapshot, MarshalBindParameterValueHelper& marshalBindParamsHelper, int startIndex, bool bFetchSqlId, long sqlIdSize, bool skipTxnContextValidation, bool bAsync);
    private static void ValidateTransactionContext(OracleConnectionImpl connImpl);
    private void WriteOall8Message(Byte[] sqlStmtByteStream, int cursorId, Byte[] describeInfoHash, long dbChangeRegistrationId, long executeOptions, ColumnDescribeInfo[] colDefinesInfoArray, int longFetchSize, int arrayBindCount, int numDefineCols, long noOfRowsToFetch, SqlStatementType stmtType, MarshalBindParameterValueHelper& marshalBindParamsHelper, int startIndex, bool bFetchSqlId, long sqlIdSize, bool bAsync);
    private void WritePisdef(long executeOptions, int cursorId, Byte[] describeInfoHash, long dbChangeRegistrationId, Byte[] sqlStmtByteStream, int paramLength, int longFetchSize, int numDefineCols, long noOfRowsToFetch, int arrayBindCount, bool bFetchSqlId, long sqlIdSize, SqlStatementType stmtType);
    internal void WritePisdefData(long executeOptions, Byte[] describeInfoHash, Byte[] sqlStmtByteStream, ColumnDescribeInfo[] colDefinesInfoArray, int arrayBindCount, MarshalBindParameterValueHelper& marshalBindParamsHelper, int startIndex);
    internal static void MarshalValuesForArrayBind(MarshallingEngine mEngine, int arrayBindCount, int startIndex, MarshalBindParameterValueHelper& marshalArrayBindValuesHelper);
    private static void MarshalDefines(MarshallingEngine mEngine, ColumnDescribeInfo[] definesArray);
    private static void MarshalBindMetaData(MarshallingEngine mEngine, ColumnDescribeInfo[] paramCollInfoArray);
    internal static void MarshalBindValues(MarshallingEngine mEngine, MarshalBindParameterValueHelper& marshalBindValuesHelper);
    internal static void MarshalParameterValue(MarshallingEngine mEngine, object paramValue, Byte[] qLocatorData, OraType dataType);
    internal static void MarshalAssociativeArrayParameterValue(MarshallingEngine mEngine, object paramValue, OraType dataType);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCExecuteSql/<ProcessImplicitResultSetAsync>d__100")]
internal ValueTask`1<List`1<TTCResultSet>> ProcessImplicitResultSetAsync(List`1<TTCResultSet> implicitRSList, bool bAsync);
    internal List`1<TTCResultSet> ProcessImplicitResultSet(List`1<TTCResultSet> implicitRSList, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCExecuteSql/<ReceiveExecuteResponseAsync>d__103")]
internal ValueTask`1<RER_RefAndOutParamArgCtx> ReceiveExecuteResponseAsync(Accessor[] bindAccessors, bool bHasReturningParams, SqlStatementType statementType, long noOfRowsFetchedLastTime, int noOfRowsToFetch, int longFetchSize, long clientInitialLOBFetchSize, long initialLOBFetchSize, long initialJSONFetchSize, Int64[] scnFromExecution, bool bAllInputBinds, int arrayBindCount, bool bDefineDone, RER_RefAndOutParamArgCtx refOutArgCtx, bool bReadSqlId, bool bLOBArrayFetchRequired, bool bAsync);
    internal RER_RefAndOutParamArgCtx ReceiveExecuteResponse(Accessor[] bindAccessors, bool bHasReturningParams, SqlStatementType statementType, long noOfRowsFetchedLastTime, int noOfRowsToFetch, int longFetchSize, long clientInitialLOBFetchSize, long initialLOBFetchSize, long initialJSONFetchSize, Int64[] scnFromExecution, bool bAllInputBinds, int arrayBindCount, bool bDefineDone, RER_RefAndOutParamArgCtx refOutArgCtx, bool bReadSqlId, bool bLOBArrayFetchRequired, bool bAsync);
    private RER_RefAndOutParamArgCtx Process_RPA_Message(Int64[] scnFromExecution, SqlStatementType statementType, int arrayBindCount, RER_RefAndOutParamArgCtx refOutArgCtx, bool bReadSqlId, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCExecuteSql/<Process_RPA_MessageAsync>d__106")]
private ValueTask`1<RER_RefAndOutParamArgCtx> Process_RPA_MessageAsync(Int64[] scnFromExecution, SqlStatementType statementType, int arrayBindCount, RER_RefAndOutParamArgCtx refOutArgCtx, bool bReadSqlId, bool bAsync);
    private long GetExecuteOptions(bool parse, bool execute, bool fetch, bool bDoDefines, bool bAutoCommit, bool bDisableCompressedFetch, bool bHasReturningClause, int noOfParameters, int arrayBindCount, SqlStatementType stmtType);
    private Accessor[] CreateDefineAccessors(SQLMetaData sqlMetaData, int initialLongFetchSize, long clientInitialLobFetchsize, long initialLOBFetchSize, long initialJSONFetchSize, bool bDefineDone, bool bLOBArrayFetchRequired, int noOfRowsToFetch);
    internal static ColumnDescribeInfo[] InitDefines(ColumnDescribeInfo[] columnMetadataArray, long clientInitialLOBFetchSize, long initialLOBFetchSize, long initialJSONFetchsize);
    internal static long CalculateInternalILFS(long lobPrefetchSize, bool bForFill, bool bReturnPSTypes);
}
internal class OracleInternal.TTC.TTCFetch : TTCFunction {
    internal TTCFetch(MarshallingEngine mEngine);
    internal void WriteMessage(int cursorId, int noOfRowsToFetch, bool bAsync);
}
internal class OracleInternal.TTC.TTCFunction : TTCMessage {
    internal static short OOPEN;
    internal static short OEXEC;
    internal static short OFETCH;
    internal static short OCLOSE;
    internal static short OLOGOFF;
    internal static short OCOMON;
    internal static short OCOMOFF;
    internal static short OCOMMIT;
    internal static short OROLLBACK;
    internal static short OCANCEL;
    internal static short ODSCRARR;
    internal static short OVERSION;
    internal static short OK2RPC;
    internal static short OALL7;
    internal static short OSQL7;
    internal static short OEXFEN;
    internal static short O3LOGON;
    internal static short O3LOGA;
    internal static short OKOD;
    internal static short OALL8;
    internal static short OLOBOPS;
    internal static short ODNY;
    internal static short OTXSE;
    internal static short OTXEN;
    internal static short OCCA;
    internal static short O80SES;
    internal static short OAUTH;
    internal static short OSESSKEY;
    internal static short OCANA;
    internal static short OKPN;
    internal static short OSCID;
    internal static short OPING;
    internal static short OKEYVAL;
    internal static short OSESSGET;
    internal static short OSESSRLS;
    internal static short OSSTEMPLATE;
    internal static short OSESSSTATE;
    internal static short OAPPCONTREPLAY;
    internal static short OCHUNKINFO;
    internal static short OAQNFY;
    internal static short OAQEQ;
    internal static short OAQDQ;
    internal static short OAQGPS;
    internal static short OAQLS;
    internal static short OAQXQ;
    internal static short OAQEMNDEQ;
    internal static short OPLBGN;
    internal static short OPLEND;
    internal static short OPLBLK;
    internal static short OSPFPPUT;
    internal short m_functionCode;
    private Int32[] retLen;
    internal bool m_bUpdateFunctionCodeForReplay;
    internal TTCFunction(MarshallingEngine marshallingEngine, short functionCode, byte sequenceNumber);
    internal void WriteFunctionHeader();
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCFunction/<ProcessOCSSYNCMessageAsync>d__55")]
internal ValueTask ProcessOCSSYNCMessageAsync(Hashtable sProperties, bool bAsync);
    internal void ProcessOCSSYNCMessage(Hashtable sProperties, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCFunction/<ProcessServerSidePiggybackFunctionAsync>d__57")]
internal ValueTask ProcessServerSidePiggybackFunctionAsync(bool bAsync, byte opCode);
    internal void ProcessServerSidePiggybackFunction(bool bAsync, byte opCode);
}
internal class OracleInternal.TTC.TTCJson : TTCBlob {
    internal TTCJson(MarshallingEngine mEngine);
}
internal class OracleInternal.TTC.TTCKeywordValuePair : object {
    internal int m_keyword;
    internal Byte[] m_binaryValue;
    internal string m_textValueInString;
    internal TTCKeywordValuePair(int _keyword, string _textValue, Byte[] _binaryValue);
    internal void Marshal(MarshallingEngine mEngine);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCKeywordValuePair/<UnmarshalAsync>d__5")]
internal static ValueTask`1<TTCKeywordValuePair> UnmarshalAsync(MarshallingEngine mEngine, bool bAsync);
    internal static TTCKeywordValuePair Unmarshal(MarshallingEngine mEngine, bool bAsync);
}
internal abstract class OracleInternal.TTC.TTCLob : TTCFunction {
    internal static int KPLOB_NONE;
    internal static int KPLOB_GET_LEN;
    internal static int KPLOB_READ;
    internal static int KPLOB_COPY;
    internal static int KPLOB_ERASE;
    internal static int KPLOB_MK_NULL;
    internal static int KPLOB_TRIM;
    internal static int KPLOB_WRITE;
    internal static int KPLOB_APPEND;
    internal static int KPLOB_FILE_OPEN;
    internal static int KPLOB_FILE_CLOSE;
    internal static int KPLOB_FILE_ISOPEN;
    internal static int KPLOB_FILE_EXISTS;
    internal static int KPLOB_FILE_CLALL;
    internal static int KPLOB_LOAD_FROM_FILE;
    internal static int KPLOB_PAGE_SIZE;
    internal static int KPLOB_TMP_CREATE;
    internal static int KPLOB_TMP_FREE;
    internal static int KPLOB_TMP_CBK;
    internal static int KPLOB_OPEN;
    internal static int KPLOB_CLOSE;
    internal static int KPLOB_ISOPEN;
    internal static int KPLOB_WRITE_APPEND;
    internal static int KPLOB_GET_LIMIT;
    internal static int KPLOB_ARRAY_OPERATION;
    internal static int KPLOB_GET_OPTIONS;
    internal static int KPLOB_SET_OPTIONS;
    internal static int KPLOB_GET_SHARED_REG;
    internal static int KPLOB_FRAG_INSERT;
    internal static int KPLOB_FRAG_DELETE;
    internal static int KPLOB_FRAG_MOVE;
    internal static int KPLOB_FRAG_REPLACE;
    internal static int KPLOB_ARRAY_READ;
    internal static int KPLOB_ARRAY_TMPFR;
    internal static int KOLBLLENB;
    internal static int KOLBLVSNB;
    internal static byte QUASI_LOCATOR_VERSION;
    internal static byte KOLBLBLOB;
    internal static byte KOLBLCLOB;
    internal static byte KOLBLNLOB;
    internal static byte KOLBLBFIL;
    internal static byte KOLBLCFIL;
    internal static byte KOLBLNFIL;
    internal static byte KOLBLVBL;
    internal static byte KOLBLABS;
    internal static byte KOLBLPXY;
    internal static byte KOLBLPKEY;
    internal static byte KOLBLIMP;
    internal static byte KOLBLIDX;
    internal static byte KOLBLINI;
    internal static byte KOLBLEMP;
    internal static byte KOLBLVIEW;
    internal static byte KOLBL0FRM;
    internal static byte KOLBL1FRM;
    internal static byte KOLBLRDO;
    internal static byte KOLBLPART;
    internal static byte KOLBLCPD;
    internal static byte KOLBLDIL;
    internal static byte KOLBLBUF;
    internal static byte KOLBLBPS;
    internal static byte KOLBLMOD;
    internal static byte KOLBLVAR;
    internal static byte KOLBLTMP;
    internal static byte KOLBLCACHE;
    internal static byte KOLBLOPEN;
    internal static byte KOLBLRDWR;
    internal static byte KOLBLCLI;
    internal static byte KOLBLVLE;
    internal static byte ALLFLAGS;
    internal static byte KOLBLFLGB;
    internal static byte KOLLIVAR;
    internal static byte KOLLFLG;
    internal static byte KOLL1FLG;
    internal static byte KOLL2FLG;
    internal static byte KOLL3FLG;
    internal static byte KOLL4FLG;
    internal static int KOKL_ORDONLY;
    internal static int KOKL_ORDWR;
    internal static int KOLF_ORDONLY;
    internal static int MODE_READONLY;
    internal static int MODE_READWRITE;
    internal static int DURATION_SESSION;
    internal static int DURATION_CALL;
    internal static int DTYCLOB;
    internal static int DTYBLOB;
    internal static int KOIDSLEN;
    internal static int KOLBLPREL;
    internal static int KOLBLLIDL;
    internal static int KOLBLLIDB;
    internal static int KOLBLTLMXL;
    internal static int MAX_TEMP_LOBS_PER_REQUEST;
    internal TTCLobData m_lobData;
    protected Byte[] m_sourceLobLocator;
    protected Byte[] m_destinationLobLocator;
    protected long m_sourceOffset;
    protected long m_destinationOffset;
    protected int m_destinationLength;
    protected short m_characterSet;
    protected long m_lobAmount;
    protected bool m_bLobNull;
    protected long m_lobOperation;
    protected Int32[] m_lobSCN;
    protected int m_lobSCNLength;
    protected bool m_bSendLobAmount;
    protected Byte[] m_outBuffer;
    protected long m_outBufferOffset;
    protected Byte[] m_inBuffer;
    protected long m_lobBytesRead;
    protected bool m_bNullO2U;
    protected bool m_variableWidthChar;
    internal TTCLob(MarshallingEngine mEngine);
    internal static Byte[] CreateQuasiLocator(long lobDataLength);
    internal static Byte[] GetLocator(Byte[] lobBytes);
    internal abstract virtual CreateTemporaryLobTTC_RefAndOutParamArgCtx CreateTemporaryLob(bool bCache, bool bNClob, int duration, CreateTemporaryLobTTC_RefAndOutParamArgCtx ctlTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal abstract virtual ValueTask`1<CreateTemporaryLobTTC_RefAndOutParamArgCtx> CreateTemporaryLobAsync(bool bCache, bool bNClob, int duration, CreateTemporaryLobTTC_RefAndOutParamArgCtx ctlTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal virtual void FreeTemporaryLob(Byte[] lobLocator);
    internal bool OpenLob(Byte[] lobLocator, int mode, int lobOperation);
    internal bool CloseLob(Byte[] lobLocator, int lobOperation);
    internal static bool IsTemporaryLob(Byte[] lobLocator);
    internal long GetChunkSize(Byte[] lobLocator);
    internal GetLengthTTC_RefAndOutParamArgCtx GetLength(Byte[] lobLocator, GetLengthTTC_RefAndOutParamArgCtx refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLob/<GetLengthAsync>d__123")]
internal ValueTask`1<GetLengthTTC_RefAndOutParamArgCtx> GetLengthAsync(Byte[] lobLocator, GetLengthTTC_RefAndOutParamArgCtx refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal long Trim(Byte[] lobLocator, long newLength);
    internal static void FreeTempLobsPiggyBack(MarshallingEngine marshallingEngine, ArrayList lobLocators);
    internal bool LobArrayRead(TTCLobAccessor[] accessorForLOBCols, Byte[][] lobLocators, Int64[] lobAmounts, Int64[] lobOffsets, int numLobsToSend, int numOfLobColumns, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLob/<LobArrayReadAsync>d__127")]
internal ValueTask`1<bool> LobArrayReadAsync(TTCLobAccessor[] accessorForLOBCols, Byte[][] lobLocators, Int64[] lobAmounts, Int64[] lobOffsets, int numLobsToSend, int numOfLobColumns, OracleConnectionImpl connectionImpl, bool bAsync);
    internal OBReadTTC_RefAndOutParamArgCtx Read(Byte[] lobLocator, long locatorOffset, long numBytesToRead, long outBufferOffset, OBReadTTC_RefAndOutParamArgCtx obReadTTC_refOutctx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLob/<ReadAsync>d__130")]
internal ValueTask`1<OBReadTTC_RefAndOutParamArgCtx> ReadAsync(Byte[] lobLocator, long locatorOffset, long numBytesToRead, long outBufferOffset, OBReadTTC_RefAndOutParamArgCtx obReadTTC_refOutctx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal OBWriteTTC_RefAndOutParamArgCtx Write(Byte[] lobLocator, long locatorOffset, Byte[] inBuffer, long inBufferOffset, long numBytesToWrite, OBWriteTTC_RefAndOutParamArgCtx obWriteTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLob/<WriteAsync>d__133")]
internal ValueTask`1<OBWriteTTC_RefAndOutParamArgCtx> WriteAsync(Byte[] lobLocator, long locatorOffset, Byte[] inBuffer, long inBufferOffset, long numBytesToWrite, OBWriteTTC_RefAndOutParamArgCtx obWriteTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal void Append(Byte[] srcLobLocator, Byte[] destLobLocator);
    internal OBCopyTTC_RefAndOutParamArgCtx Copy(Byte[] srcLobLocator, Byte[] destLobLocator, long srcOffset, long destOffset, long srcLength, OBCopyTTC_RefAndOutParamArgCtx obCopyTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLob/<CopyAsync>d__137")]
internal ValueTask`1<OBCopyTTC_RefAndOutParamArgCtx> CopyAsync(Byte[] srcLobLocator, Byte[] destLobLocator, long srcOffset, long destOffset, long srcLength, OBCopyTTC_RefAndOutParamArgCtx obCopyTTC_refOutCtx, OracleConnectionImpl connectionImpl, bool bAsync);
    internal long Erase(Byte[] lobLocator, long locatorOffset, long numBytesToErase);
    internal void WriteLobArrayOperation(Byte[][] lobLocators, Int64[] lobAmounts, Int64[] lobOffsets, int numLobsToSend);
    internal void LobArrayReceiveResponse(TTCLobAccessor[] accessorForLOBCols, Byte[][] lobLocators, int numOfLobColumns, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLob/<LobArrayReceiveResponseAsync>d__141")]
internal ValueTask LobArrayReceiveResponseAsync(TTCLobAccessor[] accessorForLOBCols, Byte[][] lobLocators, int numOfLobColumns, bool bAsync);
    internal void WriteLobOperation();
    internal void ReceiveResponse(List`1<ArraySegment`1<byte>> dataSegments, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLob/<ReceiveResponseAsync>d__144")]
internal ValueTask ReceiveResponseAsync(List`1<ArraySegment`1<byte>> dataSegments, bool bAsync);
    private void Process_RPA_Message(Byte[][] lobLocators);
    internal void Initialize();
    internal static Byte[] GetLobId(Byte[] lobLocator);
    internal static string GetLobIdString(Byte[] lobLocator);
    internal static bool IsValueBasedLocator(Byte[] lobLocator);
    internal static bool IsQuasiLocator(Byte[] lobLocator);
    internal static bool IsReadOnly(Byte[] lobLocator);
    internal static bool IsQuasiOrTempVBL(Byte[] lobLocator);
}
internal class OracleInternal.TTC.TTCLobData : TTCMessage {
    internal static int LOBD_STATE0;
    internal static int LOBD_STATE1;
    internal static int LOBD_STATE2;
    internal static int LOBD_STATE3;
    internal static int LOBD_STATE_EXIT;
    internal static short TTCG_LNG;
    internal static short LOBDATALENGTH;
    internal TTCLobData(MarshallingEngine mEngine);
    internal void WriteLobData(Byte[] inBuffer, long inBufferOffset, long numBytes, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLobData/<WriteLobDataAsync>d__9")]
internal ValueTask WriteLobDataAsync(Byte[] inBuffer, long inBufferOffset, long numBytes, bool bAsync);
    internal long ReadLobData(Byte[] outBuffer, long outBufferOffset, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLobData/<ReadLobDataAsync>d__11")]
internal ValueTask`1<long> ReadLobDataAsync(Byte[] outBuffer, long outBufferOffset, bool bAsync);
    internal long ReadLobDataForArray(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCLobData/<ReadLobDataForArrayAsync>d__13")]
internal ValueTask`1<long> ReadLobDataForArrayAsync(bool bAsync);
}
internal class OracleInternal.TTC.TTCMessage : object {
    internal static byte TTIPRO;
    internal static byte TTIDTY;
    internal static byte TTIFUN;
    internal static byte TTIOER;
    internal static byte TTIRXH;
    internal static byte TTIRXD;
    internal static byte TTIRPA;
    internal static byte TTISTA;
    internal static byte TTIIOV;
    internal static byte TTISLG;
    internal static byte TTIOAC;
    internal static byte TTILOBD;
    internal static byte TTIWRN;
    internal static byte TTIDCB;
    internal static byte TTIPFN;
    internal static byte TTIFOB;
    internal static byte TTIBVC;
    internal static byte TTISPF;
    internal static byte TTIONEWAYFN;
    internal static byte TTIIMPLRES;
    internal static byte TTIRENEG;
    internal static byte TTICOOKIE;
    internal static byte TTIINIT;
    internal static byte OCQCINV;
    internal static byte OCOSPID;
    internal static byte OCTRCEVT;
    internal static byte OCSESSRET;
    internal static byte OCSSYNC;
    internal static byte OCXSSS;
    internal static byte OCLTXID;
    internal static byte OCAPPCONTCTL;
    internal static byte OCXSSS2;
    internal static byte OSESSSIGN;
    internal static byte OCSHRDKEY;
    internal static byte MAX_OCFN;
    internal static long TTIEOCREL;
    internal byte m_ttcCode;
    internal MarshallingEngine m_marshallingEngine;
    internal TTCMessage(MarshallingEngine marshallingEngine, byte ttcCode);
    internal void WriteTTCCode();
    internal virtual void ReInit(MarshallingEngine marshallingEngine);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCMessage/<ProcessTTISTAMessageAsync>d__41")]
internal ValueTask ProcessTTISTAMessageAsync(bool bAsync);
    internal void ProcessTTISTAMessage();
}
internal class OracleInternal.TTC.TTCNotification : TTCFunction {
    internal static int REGISTER_KPNDEF;
    internal static int UNREGISTER_KPNDEF;
    internal static int POST_KPNDEF;
    internal static int EXISTINGCLIENT_KPNDEF;
    internal static int NEWCLIENT_KPNDEF;
    internal static int USECLIENTADDR_KPNDEF;
    internal static int CLIENTCON_KPNDEF;
    internal static int ENABLE_KPNDEF;
    internal static int DISABLE_KPNDEF;
    internal static int KPD_NTFN_CONNID_LEN;
    internal static int KPUN_PRS_RAW;
    internal static int KPUN_VER_10200;
    internal static int KPUN_VER_12100;
    internal static int OCI_SUBSCR_NAMESPACE_ANONYMOUS;
    internal static int OCI_SUBSCR_NAMESPACE_AQ;
    internal static int OCI_SUBSCR_NAMESPACE_DBCHANGE;
    internal static int OCI_SUBSCR_NAMESPACE_MAX;
    internal static int KPD_CHNF_OPFILTER;
    internal static int KPD_CHNF_INSERT;
    internal static int KPD_CHNF_UPDATE;
    internal static int KPD_CHNF_DELETE;
    internal static int KPD_CHNF_ROWID;
    internal static int KPD_CQ_QUERYNF;
    internal static int KPD_CQ_BEST_EFFORT;
    internal static int KPD_CQ_CLQRYCACHE;
    internal static int KPD_CHNF_INVALID_REGID;
    internal static int KKCN_CTX_RAW;
    internal static int SUBSCR_QOS_RELIABLE;
    internal static int SUBSCR_QOS_PAYLOAD;
    internal static int SUBSCR_QOS_REPLICATE;
    internal static int SUBSCR_QOS_SECURE;
    internal static int SUBSCR_QOS_PURGE_ON_NTFN;
    internal static int SUBSCR_QOS_MULTICBK;
    internal static int OCI_SUBSCR_QOS_HAREG;
    internal static int SUBSCR_QOS_NONDURABLE;
    internal static int SUBSCR_QOS_ASYNC_DEQ;
    internal static int SUBSCR_QOS_TX_ACK;
    internal static int SUBSCR_QOS_AUTO_ACK;
    internal static int SUBSCR_NTFN_GROUPING_CLASS_NONE;
    internal static int SUBSCR_NTFN_GROUPING_CLASS_TIME;
    internal static int SUBSCR_NTFN_GROUPING_TYPE_SUMMARY;
    internal static int SUBSCR_NTFN_GROUPING_TYPE_LAST;
    internal int m_registrationId;
    internal string m_clientId;
    internal string m_listenerAddress;
    internal TTCNotification(MarshallingEngine mEngine);
    internal void WriteOKPNMessage(int opcode, int mode, string userName, string location, int numRegistrationInfo, Int32[] nameSpace, String[] registeredAgentName, Byte[][] kpdnrcx, Int32[] payloadType, Int32[] qosFlags, Int32[] timeout, Int32[] dbchangeOpFilter, Int32[] dbchangeTxnLag, Int32[] dbchangeRegistrationId, Byte[] kpdnrgrpcla, Int32[] kpdnrgrpval, Byte[] kpdnrgrptyp, Int32[] kpdnrgrprepcnt);
    internal void ReceiveOKPNResponse();
}
internal class OracleInternal.TTC.TTCOkeyVal : TTCFunction {
    internal static byte KVASET_KPDUSR;
    internal static byte KVACLA_KPDUSR;
    internal static int KVALDF_KVALKYL_MAX;
    internal static int KVALDF_KVALVLL_MAX;
    internal TTCOkeyVal(MarshallingEngine marshallingEngine);
    internal virtual void ReInit(MarshallingEngine marshallingEngine);
    internal void WriteMessage(NameSpace nameSpace);
}
internal class OracleInternal.TTC.TTCOPing : TTCFunction {
    internal TTCOPing(MarshallingEngine mEngine);
    internal void Write();
    internal void ReadResponse();
}
internal class OracleInternal.TTC.TTCPipeline : TTCFunction {
    internal TTCPipeline(MarshallingEngine mEngine);
    internal void AddAsPiggybackBlock(int blkErrorSetId, short blkErrorSetMode, short blkLevelMode);
}
internal class OracleInternal.TTC.TTCProtocolNegotiation : TTCMessage {
    internal static short ORACLE8_PROD_VERSION;
    internal static short ORACLE81_PROD_VERSION;
    internal static short MIN_OVERSION_SUPPORTED;
    internal static byte MIN_TTCVER_SUPPORTED;
    internal static byte V8_TTCVER_SUPPORTED;
    internal static byte MAX_TTCVER_SUPPORTED;
    internal short m_serverCharSet;
    internal short m_serverCharSetElem;
    internal byte m_serverFlags;
    internal short m_serverNCharSet;
    internal Byte[] m_protocolServerString;
    internal byte m_protocolServerVersion;
    private short m_oVersion;
    private static Byte[] m_protocolClientVersion;
    private static Byte[] m_protocolClientString;
    internal Byte[] m_serverCompiletimeCapabilities;
    internal Byte[] m_serverRuntimeCapabilities;
    internal short ServerCharacterSet { get; }
    internal short ServerNCharacterSet { get; }
    internal byte ServerFlags { get; }
    internal Byte[] ServerCompileTimeCapabilities { get; }
    internal Byte[] ServerRunTimeCapabilities { get; }
    internal TTCProtocolNegotiation(MarshallingEngine marshallingEngine);
    private static TTCProtocolNegotiation();
    internal virtual void ReInit(MarshallingEngine marshallingEngine);
    internal void WriteMessage();
    internal short get_ServerCharacterSet();
    internal short get_ServerNCharacterSet();
    internal byte get_ServerFlags();
    internal Byte[] get_ServerCompileTimeCapabilities();
    internal Byte[] get_ServerRunTimeCapabilities();
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCProtocolNegotiation/<ReadResponseAsync>d__30")]
internal ValueTask ReadResponseAsync(bool bAsync);
    internal void ReadResponse(bool bAsync);
}
internal class OracleInternal.TTC.TTCReExecuteSql : TTCFunction {
    internal static int EXE_COMMIT_ON_SUCCESS;
    internal TTCReExecuteSql(MarshallingEngine mEngine);
    internal void WriteMessage(short ttcCallCode, int cursorId, int exerof, int execFlags, long numIterations, bool bArrayBinding, MarshalBindParameterValueHelper& marshalBindParamsHelper);
}
internal class OracleInternal.TTC.TTCRowData : TTCMessage {
    internal static int COL_NULL_IND;
    internal static int DATA_STORED_IN_DUPLICATE_STORE;
    internal static int DUP_ROW_PADDING;
    internal BitArray m_bitArrayOfColumns;
    internal bool m_bitVectorFound;
    internal int m_numberOfColumns;
    internal TTCRowData(MarshallingEngine mEngine);
    internal void SetNumberOfColumns(int noOfColumns);
    internal void SetBitVector(Byte[] bitVec);
    internal bool ReadRow(Accessor[] accessors, int length, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCRowData/<ReadRowAsync>d__10")]
internal ValueTask`1<bool> ReadRowAsync(Accessor[] accessors, int length, bool bAsync);
    internal void ReadRowNew(DataUnmarshaller dataUnMarshaller, Accessor[] accessors, int rowNumber, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCRowData/<ReadRowNewAsync>d__12")]
internal ValueTask ReadRowNewAsync(DataUnmarshaller dataUnMarshaller, Accessor[] accessors, int rowNumber, bool bAsync);
    internal void ReadBVC(int nbOfColumnSent, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCRowData/<ReadBVCAsync>d__14")]
internal ValueTask ReadBVCAsync(int nbOfColumnSent, bool bAsync);
    internal void ReInitialize();
}
internal class OracleInternal.TTC.TTCRowHeader : TTCMessage {
    private short m_flags;
    internal int m_noOfRequests;
    internal int m_iterationNumber;
    internal int m_noOfIterations;
    private int m_uacBufferLength;
    internal TTCRowHeader(MarshallingEngine mEngine);
    internal void ReadMessage(TTCRowData rowData, bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCRowHeader/<ReadMessageAsync>d__7")]
internal ValueTask ReadMessageAsync(TTCRowData rowData, bool bAsync);
    internal void ReInitialize();
}
internal class OracleInternal.TTC.TTCSessionGet : TTCFunction {
    internal static short SESSGET_TAG_MISMATCH;
    internal static short SESSGET_PURITY_NEW;
    internal static short SESSGET_SESSION_CHANGED;
    internal static short SESSGET_STMTCACHE_DESTROY;
    internal static short SESSGET_INFLAGS_MATCHANY;
    private int m_c2sSessionGetflags;
    internal long m_s2cSessionGetflags;
    private string m_returnTag;
    internal TTCSessionGet(MarshallingEngine mEngine);
    internal void GetSession(long c2sSessionFlags, bool bUseDRCPMultiTag);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCSessionGet/<ReceiveResponse>d__10")]
internal ValueTask ReceiveResponse();
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCSessionGet/<ReadRPAMessage>d__11")]
internal ValueTask ReadRPAMessage();
}
internal class OracleInternal.TTC.TTCSessionRelease : TTCFunction {
    internal static short SESSRLS_DROPSESS;
    internal static short SESSRLS_DEAUTHENTICATE;
    internal static short SESSRLS_RETAG;
    internal static short SESSRLS_MULTIPROPERTY_TAG;
    private string m_sessrlstag;
    private long m_sessrlsmode;
    internal TTCSessionRelease(MarshallingEngine mEngine);
    internal void ReleaseSession(string drcpTagName, bool bUseDRCPMultiTag);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCSessionRelease/<ReceiveResponse>d__8")]
internal ValueTask ReceiveResponse();
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCSessionRelease/<ReadRPAMessage>d__9")]
internal ValueTask ReadRPAMessage();
}
internal class OracleInternal.TTC.TTCSessionReturnValues : TTCFunction {
    private long m_s2cSessionGetflags;
    private long m_newSesionId;
    private long m_newSerialNumber;
    private TTCKeywordValuePair[] m_sessProperties;
    internal TTCSessionReturnValues(MarshallingEngine mEngine);
    internal void Receive(bool bAsync);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCSessionReturnValues/<ReceiveAsync>d__6")]
internal ValueTask ReceiveAsync(bool bAsync);
}
internal class OracleInternal.TTC.TTCSessionState : TTCFunction {
    internal static long KPDSS_SESSSTATE_APPCONT_ENABLED;
    internal static long KPDSS_SESSSTATE_STATIC;
    internal static long KPDSS_SESSSTATE_REQUEST_BEGIN;
    internal static long KPDSS_SESSSTATE_REQUEST_END;
    internal static long KPDSS_SESSSTATE_NONREQUEST_CALL;
    internal static long KPDSS_SESSSTATE_NO_OPEN_HANDLES;
    internal static long KPDSS_SESSSTATE_EXPL_BOUND;
    internal static long KWFCSFLAGS_TXNAL;
    internal static long KWFCSFLAGS_STATIC;
    internal static long KWFCSFLAGS_AUTO;
    internal TTCSessionState(MarshallingEngine mEngine);
    internal void AddAsPiggyback(long sessStateOpsFlags);
}
internal class OracleInternal.TTC.TTCSessionTemplate : TTCFunction {
    internal TTCSessionTemplate(MarshallingEngine mEngine);
    internal void Write(DatabaseSessionState dbSessionState);
}
internal class OracleInternal.TTC.TTCSimpleOperations : TTCFunction {
    internal TTCSimpleOperations(MarshallingEngine mEngine);
    internal void SetFunctionCode(short _funCode);
    internal void WriteMessage();
    internal void ReadResponse();
}
internal class OracleInternal.TTC.TTCSpfp : TTCFunction {
    internal TTCSpfp(MarshallingEngine mEngine);
    internal void DoOSPFPPUT();
    internal void Marshal();
    internal void ReadRPA();
    internal void WriteMessage();
    internal void ReadResponse();
}
internal class OracleInternal.TTC.TTCStartupShutdown : TTCFunction {
    internal static short OV6STRT;
    internal static short OV6STOP;
    internal static int STOMFDBA;
    internal static int STOMFACA;
    internal static int STOMFALO;
    internal static int STOMFSHU;
    internal static int STOMFFRC;
    internal static int STOMFPOL;
    internal static int STOMFABO;
    internal static int STOMFATX;
    internal static int STOMFLTX;
    internal static int STOSDONE;
    internal static int STOSINPR;
    internal static int STOSERR;
    private int inmode;
    private long outmode;
    internal TTCStartupShutdown(MarshallingEngine mEngine);
    internal void doOV6STRT(int mode);
    internal void doOV6STOP(int mode);
    internal void Marshal();
    internal void ReadRPA();
    internal void WriteMessage();
    internal void ReadResponse();
}
internal class OracleInternal.TTC.TTCSwitchSession : TTCFunction {
    internal static int OSESSWS;
    internal static int OSESGID;
    internal static int OSESDET;
    internal static int OSESDEL;
    internal static int OSESCLN;
    internal static int OSESINI;
    internal static int OSESSWB;
    internal TTCSwitchSession(MarshallingEngine mEngine);
    private static TTCSwitchSession();
    internal void Write(int sessionId, int serialNum, int opCode);
}
internal class OracleInternal.TTC.TTCtoh : object {
    private static int TOPLVL_KPCTOH;
    private static Byte[] EOID_KOTTD;
    private static byte KORFPFNNL;
    private static byte EXTENT_OID;
    internal static Byte[] ANYDATA_TOID;
    internal static int KOIDFLEN;
    internal static int KOIDSLEN;
    internal Byte[] toid;
    private Byte[] oid;
    private Byte[] snapshot;
    private int versionNumber;
    internal int imageLength;
    private int flags;
    private Int32[] intArr;
    private TTCTTIksnp ksnp;
    private MarshallingEngine mEngine;
    internal TTCtoh(MarshallingEngine mar);
    private static TTCtoh();
    internal void Init(Byte[] _toid, int _imageLength);
    internal void Marshal(MarshallingEngine meg);
    internal void Unmarshal(MarshallingEngine meg);
}
internal class OracleInternal.TTC.TTCTransactionEN : TTCFunction {
    internal static int OTXCOMIT;
    internal static int OTXABORT;
    internal static int OTXPREPA;
    internal static int OTXFORGT;
    internal static int OTXRECOV;
    internal static int OTXMLPRE;
    internal TTCTransactionEN(MarshallingEngine mEngine);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCTransactionEN/<DoTransaction>d__7")]
private ValueTask`1<TxnState> DoTransaction(int txnOperation, OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 txnFlag, UInt32 timeout, TxnState transactionInState);
    internal TxnState Prepare(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, TxnState transactionInState);
    internal TxnState Commit(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, TxnState transactionInState);
    internal TxnState Abort(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, TxnState transactionInState);
    internal void WriteTxnOperation(int txnOpCode, OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 txnFlag, UInt32 timeout, TxnState transactionInState);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCTransactionEN/<ReadResponse>d__12")]
internal ValueTask`1<TxnState> ReadResponse();
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCTransactionEN/<Process_RPA_Message>d__13")]
private ValueTask`1<TxnState> Process_RPA_Message();
}
internal class OracleInternal.TTC.TTCTransactionSE : TTCFunction {
    internal static int OTXSTA;
    internal static int OTXDET;
    internal static int OCI_TRANS_NEW;
    internal static int OCI_TRANS_JOIN;
    internal static int OCI_TRANS_RESUME;
    internal static int OCI_TRANS_PROMOTE;
    internal static int OCI_TRANS_STARTMASK;
    internal static int OCI_TRANS_READONLY;
    internal static int OCI_TRANS_READWRITE;
    internal static int OCI_TRANS_SERIALIZABLE;
    internal static int OCI_TRANS_ISOLMASK;
    internal static int OCI_TRANS_LOOSE;
    internal static int OCI_TRANS_TIGHT;
    internal static int OCI_TRANS_TYPEMASK;
    internal static int OCI_TRANS_NOMIGRATE;
    internal static int OCI_TRANS_SEPARABLE;
    internal static int OCI_TRANS_OTSRESUME;
    internal TTCTransactionSE(MarshallingEngine mEngine);
    private Byte[] DoTransaction(int txnOperation, OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 txnFlag, UInt32 timeout, Int64& applicationValue, string connectionInternalName, string connectionExternalName);
    internal Byte[] Start(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, Int64& applicationValue);
    internal Byte[] Start(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, Int64& applicationValue, string connectionInternalName, string connectionExternalName);
    internal Byte[] Resume(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, Int64& applicationValue);
    internal Byte[] Resume(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, Int64& applicationValue, string connectionInternalName, string connectionExternalName);
    internal Byte[] Promote(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, Int64& applicationValue);
    internal Byte[] Promote(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, Int64& applicationValue, string connectionInternalName, string connectionExternalName);
    internal Byte[] Detach(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, Int64& applicationValue);
    internal Byte[] Detach(OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 timeout, Int64& applicationValue, string connectionInternalName, string connectionExternalName);
    internal void WriteTxnOperation(int txnOpCode, OpoDTCTxnXIDRefCtx xid, Byte[] txnCtx, UInt32 txnFlag, UInt32 timeout, long applicationValue, string connectionInternalName, string connectionExternalName);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCTransactionSE/<ReadResponse>d__29")]
internal ValueTask`1<RPAReturnValues> ReadResponse();
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCTransactionSE/<Process_RPA_Message>d__30")]
private ValueTask`1<RPAReturnValues> Process_RPA_Message();
}
internal class OracleInternal.TTC.TTCTTIksnp : object {
    private Byte[] snapshot;
    private Int32[] intArr;
    internal void init();
    internal void Marshal(MarshallingEngine meg);
    internal void Unmarshal(MarshallingEngine meg);
}
internal class OracleInternal.TTC.TTCTypeRepresentation : object {
    internal static byte NATIVE;
    internal static byte UNIVERSAL;
    internal static byte LSB;
    internal static byte MAXREP;
    internal static byte B1;
    internal static byte B2;
    internal static byte B4;
    internal static byte B8;
    internal static byte PTR;
    internal static byte MAXTYPE;
    internal static byte REPUNV;
    internal static byte REPBUNV;
    internal static byte REPCUNV;
    internal static byte REPIUNV;
    internal static byte REPNV51;
    internal static byte REPDV51;
    internal static byte REPAUNV;
    internal static byte REPRUNV;
    internal Byte[] m_representationArray;
    internal static byte NUMREPS;
    internal byte m_serverConvFlags;
    internal byte ServerConversionFlags { get; internal set; }
    internal bool ConversionRequired { get; }
    internal bool IsServerConversion { get; }
    internal byte get_ServerConversionFlags();
    internal void set_ServerConversionFlags(byte value);
    internal bool get_ConversionRequired();
    internal bool get_IsServerConversion();
}
internal class OracleInternal.TTC.TTCVersion : TTCFunction {
    internal static int VSN_BANNER_FORMAT_BASE;
    internal static int VSN_BANNER_FORMAT_FULL;
    private Byte[] m_rdbmsVersion;
    private int m_bufferLen;
    private int m_retVersionLength;
    internal long m_retVersionNumber;
    internal TTCVersion(MarshallingEngine marshallingEngine);
    internal virtual void ReInit(MarshallingEngine marshallingEngine);
    [AsyncStateMachineAttribute("OracleInternal.TTC.TTCVersion/<ReadResponse>d__8")]
internal ValueTask ReadResponse(bool bAsync);
    internal int GetVersionNumber();
    internal void WriteMessage();
}
internal class OracleInternal.TTC.TTCXmlTypePickler : object {
    internal static string TypeName;
    internal static Byte[] TOID;
    internal static int XMLTYPE_VERSION;
    internal static int XMLTYPE_LOB;
    internal static int XMLTYPE_OBJECT;
    internal static int XMLTYPE_STR;
    internal static int XMLTYPE_PTR;
    internal static int XMLTYPE_CSX;
    internal static int XMLTYPE_LOB_CSX;
    internal static int XMLTYPE_XQ_SEQ_DMFMT;
    internal static UInt32 XMLTYPE_FLAG_SKIP_NEXT_4;
    internal static UInt32 XMLTYPE_FLAG_SNAPSHOT;
    internal static UInt32 XMLTYPE_FLAG_SCHMOID;
    internal static UInt32 XMLTYPE_FLAG_NO_DOC_WRAP;
    internal static UInt32 XMLTYPE_FLAG_FRAGMENT;
    internal static UInt32 XMLTYPE_FLAG_NOXMLHDR;
    internal static UInt32 XMLTYPE_FLAG_GUID;
    internal static UInt32 XMLTYPE_FLAG_CSID;
    internal static int XMLTYPE_SCHMOIDLEN;
    internal static int XMLTYPE_ELEMNUMLEN;
    internal static int XMLTYPE_KOSNPLEN;
    internal static int XMLTYPE_KOSNPLEN_OLD;
    internal static int XMLTYPE_GUIDLEN;
    internal static int XMLTYPE_CSID_SIZE;
    internal static short KOPI20_IF_IS81;
    internal static short KOPI20_IF_CMSB;
    internal static short KOPI20_IF_CLSB;
    internal static short KOPI20_IF_DEGN;
    internal static short KOPI20_IF_COLL;
    internal static short KOPI20_IF_NOPS;
    internal static short KOPI20_IF_ANY;
    internal static short KOPI20_IF_NONL;
    internal static short KOPI20_VERSION;
    internal static short KOPI20_LN_MAXV;
    internal static short KOPI20_LN_5BLN;
    private static TTCXmlTypePickler();
    internal static long ReadIntInNativeFormat(Byte[] buf);
    internal static int ReadShortInNativeFormat(Byte[] buf);
    internal static int WriteInt2Bytes(Byte[] bytes, int index, int val);
    internal static int WriteShort2Bytes(Byte[] bytes, int index, int val);
    private static int WriteLength(Byte[] bytes, int index, long dataLength);
    private static int WriteBuffer(Byte[] destBytes, Byte[] srcBytes, int destIndex, int srcIndex, long dataLength);
    internal static void GetXmlHeaderLength(OracleXmlTypeImpl xmlTypeImpl, Int32& length);
    internal static void ReadNamedTypeHeader(UDTPickleContextReader imageReader, OraXmlTypeHeader xmlTypeHeader);
    internal static bool ReadXmlHeader(OracleConnectionImpl connImpl, UDTPickleContextReader imageReader, OraXmlTypeHeader xmlTypeHeader);
    internal static long GetLengthAndFlag(Conv dbCharSetConv, OracleXmlTypeImpl xmlTypeImpl, TypeOfXmlData typeOfXmlData, object xmlData, UInt32& xmlFlag);
    internal static long GetLengthAndFlag(Conv dbCharSetConv, TypeOfXmlType typeOfXmlType, TypeOfXmlData typeOfXmlData, int offset, int size, object xmlData, UInt32& xmlFlag);
    internal static Byte[] Pickle(Conv dbCharSetConv, OracleXmlTypeImpl xmlTypeImpl);
    internal static Byte[] Pickle(Conv dbCharSetConv, TypeOfXmlType typeOfXmlType, TypeOfXmlData typeOfXmlData, int offset, int size, object xmlData);
}
internal enum OracleInternal.UDT.Common.UDTDbType : Enum {
    public int value__;
    public static UDTDbType BFile;
    public static UDTDbType Blob;
    public static UDTDbType Byte;
    public static UDTDbType Char;
    public static UDTDbType Clob;
    public static UDTDbType Date;
    public static UDTDbType Number;
    public static UDTDbType Double;
    public static UDTDbType Long;
    public static UDTDbType LongRaw;
    public static UDTDbType Int16;
    public static UDTDbType Int32;
    public static UDTDbType Int64;
    public static UDTDbType IntervalDS;
    public static UDTDbType IntervalYM;
    public static UDTDbType NClob;
    public static UDTDbType NChar;
    public static UDTDbType NVarchar2;
    public static UDTDbType Raw;
    public static UDTDbType RefCursor;
    public static UDTDbType Float;
    public static UDTDbType TimeStamp;
    public static UDTDbType TimeStampLTZ;
    public static UDTDbType TimeStampTZ;
    public static UDTDbType Varchar2;
    public static UDTDbType XmlType;
    public static UDTDbType Array;
    public static UDTDbType Object;
    public static UDTDbType Ref;
    public static UDTDbType BinaryDouble;
    public static UDTDbType BinaryFloat;
    public static UDTDbType Boolean;
    public static UDTDbType Json;
    public static UDTDbType Opaque;
    public static UDTDbType Upt;
    public static UDTDbType Numeric;
}
internal class OracleInternal.UDT.Common.UDTSQLName : object {
    internal static string PublicRole;
    private static Regex NonWordIdentifierPattern;
    private string m_fullTypeName;
    private string m_schemaName;
    private string m_typeName;
    internal string FullTypeName { get; }
    internal string SchemaName { get; }
    internal string TypeName { get; }
    internal string QualifiedTypeName { get; }
    internal string QualifiedSchemaName { get; }
    internal string QualifiedFullTypeName { get; }
    internal UDTSQLName(string providedSchemaName, string providedTypeName);
    private static UDTSQLName();
    private static string ReplaceQuotes(string str);
    internal static bool Parse(string sql_name, String& schemaName, String& typeName, bool l_parseAllFormat);
    internal static bool GetSQLName(OracleConnection conn, string providedTypeName, String& schemaName, String& typeName, bool isUserProvidedTypeName);
    internal static string GetFullTypeName(string providedSchemaName, string providedTypeName);
    internal static bool NeedToQuoteIdentifier(string identifier);
    internal string get_FullTypeName();
    internal string get_SchemaName();
    internal string get_TypeName();
    internal string get_QualifiedTypeName();
    internal string get_QualifiedSchemaName();
    internal string get_QualifiedFullTypeName();
    internal bool IsSameOwner(OracleConnection conn);
    internal bool IsPublicRole();
}
internal class OracleInternal.UDT.Common.UDTTDSReader : object {
    private Byte[] m_tds;
    private long m_beginPos;
    private long m_pos;
    internal Byte[] TDS { get; }
    internal long RelativeOffset { get; }
    internal long AbsoluteOffset { get; }
    internal UDTTDSReader(Byte[] tds, long beginIndex);
    internal Byte[] get_TDS();
    internal long get_RelativeOffset();
    internal long get_AbsoluteOffset();
    internal void SkipBytes(int number);
    internal void CheckNextByte(byte value);
    internal byte ReadByte();
    internal int ReadUB2();
    internal long ReadLong();
    internal void SkipTo(long offset);
}
internal class OracleInternal.UDT.Types.AttrIndexByName : Dictionary`2<string, int> {
}
internal interface OracleInternal.UDT.Types.IUDTCustomBuiltInInst {
    public Byte[] OracleBytes { get; }
    public abstract virtual Byte[] get_OracleBytes();
}
internal interface OracleInternal.UDT.Types.IUDTCustomInst {
}
internal interface OracleInternal.UDT.Types.IUDTCustomNamedInst {
}
internal interface OracleInternal.UDT.Types.IUDTInst {
    public UDTBasedType UDTType { get; }
    public UDTDbType UDTDbType { get; }
    public bool IsNull { get; }
    public abstract virtual UDTBasedType get_UDTType();
    public abstract virtual UDTDbType get_UDTDbType();
    public abstract virtual bool get_IsNull();
    public abstract virtual void ReleaseResource();
}
internal interface OracleInternal.UDT.Types.IUDTPickleInst {
    public int PickleImageLength { get; }
    public abstract virtual int get_PickleImageLength();
    public abstract virtual void InitializePickleNull();
    public abstract virtual object GetCustomValue(OracleConnection conn, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    public abstract virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name);
    public abstract virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer);
    public abstract virtual void WriteJsonNull(OracleConnection conn, Utf8JsonWriter writer, string name);
    public abstract virtual void WriteJsonNull(OracleConnection conn, Utf8JsonWriter writer);
}
internal interface OracleInternal.UDT.Types.IUDTPickleNamedInst {
    public abstract virtual object GetCustomValue(OracleConnection conn);
    public abstract virtual void WriteUDTJson(OracleConnection conn, Utf8JsonWriter writer);
}
internal class OracleInternal.UDT.Types.PickleDataSegmentsImage : PickleImage {
    internal List`1<ArraySegment`1<byte>> m_dataSegments;
    internal PickleDataSegmentsImage(List`1<ArraySegment`1<byte>> dataSegments, int imageLen);
    internal void Initialize(List`1<ArraySegment`1<byte>> dataSegments, int imageLen);
    internal virtual void Reset();
}
internal abstract class OracleInternal.UDT.Types.PickleImage : object {
    protected int m_udtImageLen;
    protected PickleImage(int imageLen);
    internal abstract virtual void Reset();
}
internal abstract class OracleInternal.UDT.Types.UDTBasedType : object {
    internal UDTDbType m_udtDbType;
    protected CustomTypeCode m_customTypeCode;
    internal UDTDbType UDTTypeCode { get; }
    internal bool IsUDTType { get; }
    internal bool IsXmlType { get; }
    internal bool IsSupportedAttributeType { get; }
    internal bool MightHasResource { get; }
    internal string FullTypeName { get; }
    internal CustomTypeCode CustomTypeCode { get; internal set; }
    protected UDTBasedType(UDTDbType typecode);
    internal UDTDbType get_UDTTypeCode();
    internal abstract virtual bool get_IsUDTType();
    internal abstract virtual bool get_IsXmlType();
    internal abstract virtual bool get_IsSupportedAttributeType();
    internal abstract virtual bool get_MightHasResource();
    internal abstract virtual string get_FullTypeName();
    internal virtual CustomTypeCode get_CustomTypeCode();
    internal virtual void set_CustomTypeCode(CustomTypeCode value);
    internal abstract virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal abstract virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal abstract virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal abstract virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatusArray);
    internal abstract virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal IUDTCustomInst CreateNullCustomInstance();
    internal abstract virtual object GetNullCustomValue(OracleConnection conn, CustomTypeCode customTypeCode);
    internal object GetNullCustomValue(OracleConnection conn);
    internal abstract virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal object GetCustomValue(OracleConnection conn, IUDTPickleInst udtInst);
    internal abstract virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal abstract virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal bool IsNullValue(int attrIndex, object value, object udtStatusArray);
    internal abstract virtual bool IsNullCustomValue(OracleConnection conn, int attrIndex, object value, object udtStatusArray);
    internal abstract virtual int PickleNull(UDTPickleContextWriter ctx);
    internal abstract virtual int Pickle(OracleConnection conn, UDTPickleContextWriter pickleCtxWriter, IUDTCustomInst inst);
}
internal class OracleInternal.UDT.Types.UDTBDoubleType : UDTBuiltInFixedLenType {
    private static string TypeName;
    internal static int MaxBytesLength;
    internal int MaxFixedBytesLength { get; }
    private static UDTBDoubleType();
    internal static UDTBDoubleType CreateFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTBFileType : UDTBuiltInType {
    private static string TypeName;
    internal bool MightHasResource { get; }
    private static UDTBFileType();
    internal static UDTBFileType CreateFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual bool get_MightHasResource();
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTBFloatType : UDTBuiltInFixedLenType {
    private static string TypeName;
    internal static int MaxLength;
    internal int MaxFixedBytesLength { get; }
    private static UDTBFloatType();
    internal static UDTBFloatType CreateFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTBlobInst : UDTCustomBuiltInInst {
    internal OracleBlobImpl m_tempBlob;
    internal UDTBlobInst(OracleConnection conn, UDTBlobType blobType, OracleBlobImpl tempBlob);
    internal UDTBlobInst(OracleConnection conn, UDTBlobType blobType, OracleBlob blob);
    internal static OracleBlobImpl CreateTempBlob(OracleConnection conn, Byte[] bytes);
    internal static UDTBlobInst CreateBlobInst(OracleConnection conn, UDTBlobType udtType, Byte[] bytes);
    internal static UDTBlobInst CreateBlobInst(OracleConnection conn, UDTBlobType blobTyp, OracleBlob blob);
    public virtual void ReleaseResource();
}
internal class OracleInternal.UDT.Types.UDTBlobType : UDTBuiltInType {
    private static string TypeName;
    internal bool MightHasResource { get; }
    private static UDTBlobType();
    internal static UDTBlobType CreateFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual bool get_MightHasResource();
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatusArray);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal abstract class OracleInternal.UDT.Types.UDTBuiltInFixedLenType : UDTBuiltInType {
    internal int MaxFixedBytesLength { get; }
    protected UDTBuiltInFixedLenType(UDTDbType typeCode);
    protected UDTBuiltInFixedLenType(UDTDbType typeCode, string typeName);
    internal abstract virtual int get_MaxFixedBytesLength();
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
}
internal abstract class OracleInternal.UDT.Types.UDTBuiltInType : UDTBasedType {
    protected string m_typeName;
    internal string FullTypeName { get; }
    internal bool IsUDTType { get; }
    internal bool IsXmlType { get; }
    internal bool IsSupportedAttributeType { get; }
    internal bool MightHasResource { get; }
    protected UDTBuiltInType(UDTDbType typeCode);
    protected UDTBuiltInType(UDTDbType typeCode, string typeName);
    internal static Nullable`1[] ConvertCharsToNullableChars(Char[] chars, int length);
    internal static Nullable`1[] ConvertCharsToNullableChars(Char[] chars);
    internal static Char[] ConvertNullableCharsToChars(Nullable`1[] nullableChars);
    internal static Nullable`1[] ConvertBytesToNullableBytes(Byte[] bytes);
    internal static Byte[] ConvertNullableBytesToBytes(Nullable`1[] nullableBytes);
    internal virtual string get_FullTypeName();
    internal virtual bool get_IsUDTType();
    internal virtual bool get_IsXmlType();
    internal virtual bool get_IsSupportedAttributeType();
    internal virtual bool get_MightHasResource();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatusArray);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual object GetNullCustomValue(OracleConnection conn, CustomTypeCode customTypeCode);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual bool IsNullCustomValue(OracleConnection conn, int attrIndex, object value, object udtStatusArray);
    internal abstract virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
    internal object GetOracleValue(OracleConnection conn, object customValue);
    internal virtual int PickleNull(UDTPickleContextWriter ctx);
    internal virtual int Pickle(OracleConnection conn, UDTPickleContextWriter pickleCtxWriter, IUDTCustomInst builtInInst);
}
internal class OracleInternal.UDT.Types.UDTCharType : UDTBuiltInType {
    private short m_charForm;
    private short m_charSemantic;
    private int m_charset;
    private int m_length;
    internal UDTCharType(UDTDbType typecode);
    internal static UDTCharType CreateFromTDS(OracleConnection conn, UDTDbType typeCode, int index, UDTTDSReader tds);
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal bool isNCHAR();
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTClobInst : UDTCustomBuiltInInst {
    internal OracleClobImpl m_tempClob;
    internal UDTClobInst(OracleConnection conn, UDTClobType clobType, OracleClobImpl tempClob);
    internal UDTClobInst(OracleConnection conn, UDTClobType clobType, OracleClob clob);
    internal static OracleClobImpl CreateTempClob(OracleConnection conn, bool bIsNChar, Char[] chars);
    internal static UDTClobInst CreateClobInst(OracleConnection conn, UDTClobType udtType, Char[] chars);
    internal static UDTClobInst CreateClobInst(OracleConnection conn, UDTClobType udtType, OracleClob clob);
    public virtual void ReleaseResource();
}
internal class OracleInternal.UDT.Types.UDTClobType : UDTBuiltInType {
    private int m_charForm;
    internal bool MightHasResource { get; }
    internal static UDTClobType CreateFromTDS(OracleConnection conn, int charForm, int index, UDTTDSReader tds);
    internal virtual bool get_MightHasResource();
    internal void SetCharForm(int charForm);
    internal bool IsNChar();
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatusArray);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTCollectionInst : UDTNamedInst {
    internal long m_len;
    internal IUDTCustomInst[] m_elements;
    internal UDTCollectionInst(UDTCollectionType collType);
    public virtual void ReleaseResource();
    internal void SetElements(OracleConnection conn, Array elements, OracleUdtStatus[] elementStatusArray);
    internal void SetCollection(OracleConnection conn, object value, object udtStatusArray);
}
internal class OracleInternal.UDT.Types.UDTCollectionType : UDTNamedType {
    internal static byte COLL_PLSQL_INDEX_TABLE;
    internal static byte COLL_NESTED_TABLE;
    internal static byte COLL_VARRAY;
    private static string SQL_GetElementFromCurrentUser;
    private static string SQL_GetElementFromCurrentUserAndCurrentSynonym;
    private static string SQL_GetElementFromCurrentUserAndPublicSynonym;
    private static string SQL_GetElementFromOtherUserAndCurrentSynonym;
    private static string SQL_GetElementFromAllUser;
    private static string SQL_GetElementFromOtherUserAndAllSynonym;
    private static string SQL_GetElementFromOtherUserAndPublicSynonym;
    private static string SQL_CollLocatorGetBuiltInElements;
    private static string SQL_CollLocatorGetUDTElements;
    internal byte m_typeID;
    internal long m_maxSize;
    internal UDTBasedType m_elementType;
    private bool m_bCustomTypeDefined;
    internal bool IsSupportedAttributeType { get; }
    internal bool MightHasResource { get; }
    internal UDTBasedType ElementType { get; }
    private UDTCollectionType(OracleConnection conn, UDTNamedType parent, int idx);
    internal static UDTCollectionType CreatedFromTDS(OracleConnection conn, UDTNamedType parent, int index, UDTTDSReader tds);
    private static UDTSQLName GetElementTypeName(OracleDataReader attributes);
    internal static UDTSQLName GetElementTypeName(OracleConnection conn, UDTCollectionType collType);
    internal virtual bool get_IsSupportedAttributeType();
    internal virtual bool get_MightHasResource();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    protected virtual void GetMetaData(OracleConnection conn, OracleCommand getTypeCmd);
    internal UDTBasedType get_ElementType();
    protected virtual void DescribeCustomType(object customTypeFactory, OracleConnection conn);
    internal IUDTPickleNamedInst UnpickleCollection(OracleConnection conn, UDTPickleCollectionInst pickleCollInst, UDTPickleContextReader udtImageReader);
    internal virtual int PickleNull(UDTPickleContextWriter ctx);
    internal virtual int Pickle(OracleConnection conn, UDTPickleContextWriter pickleCtxWriter, IUDTCustomInst udtInst);
    internal int PickleCollectionLocator(OracleConnection conn, UDTPickleContextWriter pickleCtxWriter, UDTPickleCollectionLocatorInst collInst);
    internal virtual IUDTPickleNamedInst CreateUDTInstance(OracleConnection conn, IUDTPickleNamedInst pickleCollInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTCustomNamedInst CreateUDTInstance(OracleConnection conn, IOracleCustomType customObj);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatusArray);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual object GetNullCustomValue(OracleConnection conn, CustomTypeCode customTypeCode);
    internal Array GetCustomArray(OracleConnection conn, int numElements);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal object GetValue(OracleConnection conn, IUDTPickleInst udtInst, bool bFromCollectionInst, OracleUdtStatus[]& elemStatusArray);
    internal OracleDataReader GetDataReaderFromLocator(OracleConnection conn, UDTPickleCollectionLocatorInst udtInst, Int32& elementCount);
    internal object GetBuiltInElementFromReader(OracleDataReader elementsReader, CustomTypeCode customTypeCode, int index);
    internal object GetElementsFromReader(OracleConnection conn, IOracleArrayTypeFactory arrayTypeFactory, OracleDataReader elementsReader, int elementCount, OracleUdtStatus[]& elemStatusArray);
    internal object GetValueFromLocator(OracleConnection conn, UDTPickleCollectionLocatorInst udtInst, bool bFromCollectionInst, OracleUdtStatus[]& elemStatusArray);
    internal void WriteBuiltInElementFromReader(OracleDataReader elementsReader, Utf8JsonWriter writer, UDTBasedType udtType, int index);
    internal void WriteElementsFromReader(OracleConnection conn, Utf8JsonWriter writer, OracleDataReader elementsReader, int elementCount);
    internal void WriteJsonFromLocator(OracleConnection conn, Utf8JsonWriter writer, UDTPickleCollectionLocatorInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual bool IsNullCustomValue(OracleConnection conn, int attrIndex, object value, object udtStatusArray);
    internal IUDTCustomInst[] PopulateElements(OracleConnection conn, Array elements, OracleUdtStatus[] elemStatusArray);
    internal UDTCollectionInst CreateCollectionInstance(OracleConnection conn, Array elements, OracleUdtStatus[] elementStatusArray);
}
internal class OracleInternal.UDT.Types.UDTCustomBuiltInInst : UDTInst {
    protected bool m_bIsNull;
    protected Byte[] m_bytes;
    public bool IsNull { get; }
    public Byte[] OracleBytes { get; }
    internal UDTCustomBuiltInInst(UDTBasedType udtType, Byte[] image);
    public virtual bool get_IsNull();
    public sealed virtual Byte[] get_OracleBytes();
    public virtual void ReleaseResource();
}
internal class OracleInternal.UDT.Types.UDTDateType : UDTBuiltInFixedLenType {
    private static string TypeName;
    internal static int MaxLength;
    internal int MaxFixedBytesLength { get; }
    private UDTDateType(UDTDbType typecode);
    private static UDTDateType();
    internal static UDTDateType CreateFromTDS(OracleConnection conn, UDTDbType typeCode, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTFloatType : UDTBuiltInFixedLenType {
    internal static int MaxBytesLength;
    private static int DefaultPrecision;
    private byte m_precision;
    internal int MaxFixedBytesLength { get; }
    private static UDTFloatType();
    internal static UDTFloatType CreateFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal abstract class OracleInternal.UDT.Types.UDTInst : object {
    internal static long MaxJsonLength;
    protected UDTBasedType m_udtType;
    public bool IsNull { get; }
    public UDTDbType UDTDbType { get; }
    public UDTBasedType UDTType { get; }
    protected UDTInst(UDTBasedType udtType);
    private static UDTInst();
    public abstract virtual bool get_IsNull();
    public sealed virtual UDTDbType get_UDTDbType();
    public sealed virtual UDTBasedType get_UDTType();
    public abstract virtual void ReleaseResource();
}
internal class OracleInternal.UDT.Types.UDTIntervalType : UDTBuiltInFixedLenType {
    internal static int MaxBytesLength;
    internal static int MaxDSBytesLength;
    internal static int MaxYMBytesLength;
    private static int LDIINTYEARMONTH;
    private static int LDIINTDAYSECOND;
    private static int SIZE_INTERVAL_YM;
    private static int SIZE_INTERVAL_DS;
    private byte m_typeID;
    private byte m_DSFracSecondPrec;
    private byte m_DSDayPrec;
    private byte m_YMYearPrec;
    internal int MaxFixedBytesLength { get; }
    private UDTIntervalType(UDTDbType intervalDbType, byte typeID);
    private static UDTIntervalType();
    internal static UDTIntervalType CreateIntervalFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal abstract class OracleInternal.UDT.Types.UDTNamedInst : UDTInst {
    protected UDTState m_state;
    public bool IsNull { get; }
    protected UDTNamedInst(UDTNamedType udtType);
    public virtual bool get_IsNull();
    internal void SetState(UDTState state);
    public virtual void Reset();
}
internal abstract class OracleInternal.UDT.Types.UDTNamedType : UDTBasedType {
    internal static int KOPM_OTS_SQL_CHAR;
    internal static int KOPM_OTS_DATE;
    internal static int KOPM_OTS_DECIMAL;
    internal static int KOPM_OTS_DOUBLE;
    internal static int KOPM_OTS_FLOAT;
    internal static int KOPM_OTS_NUMBER;
    internal static int KOPM_OTS_SQL_VARCHAR2;
    internal static int KOPM_OTS_SINT32;
    internal static int KOPM_OTS_REF;
    internal static int KOPM_OTS_VARRAY;
    internal static int KOPM_OTS_UINT8;
    internal static int KOPM_OTS_SINT8;
    internal static int KOPM_OTS_UINT16;
    internal static int KOPM_OTS_UINT32;
    internal static int KOPM_OTS_LOB;
    internal static int KOPM_OTS_UROWID;
    internal static int KOPM_OTS_CANONICAL;
    internal static int KOPM_OTS_OCTET;
    internal static int KOPM_OTS_RAW;
    internal static int KOPM_OTS_ROWID;
    internal static int KOPM_OTS_STAMP;
    internal static int KOPM_OTS_TZSTAMP;
    internal static int KOPM_OTS_INTERVAL;
    internal static int KOPM_OTS_PTR;
    internal static int KOPM_OTS_SINT16;
    internal static int KOPM_OTS_UPT;
    internal static int KOPM_OTS_COLLECTION;
    internal static int KOPM_OTS_CLOB;
    internal static int KOPM_OTS_BLOB;
    internal static int KOPM_OTS_BFILE;
    internal static int KOPM_OTS_BINARY_INTEGE;
    internal static int KOPM_OTS_IMPTZSTAMP;
    internal static int KOPM_OTS_BFLOAT;
    internal static int KOPM_OTS_BDOUBLE;
    internal static int KOTTCOPQ;
    internal static int KOPT_OP_STARTEMBADT;
    internal static int KOPT_OP_ENDEMBADT;
    internal static int KOPT_OP_STARTADT;
    internal static int KOPT_OP_ENDADT;
    internal static int KOPT_OP_SUBTYPE_MARKER;
    internal static int KOPT_OP_EMBADT_INFO;
    internal static int KOPT_OPCODE_START;
    internal static int KOPT_OP_VERSION;
    internal static int STYLE_ARRAY_LENGTH;
    internal static int STYLE_DATUM;
    internal static int STYLE_JAVA;
    internal static int STYLE_RAWBYTE;
    internal static int STYLE_INT;
    internal static int STYLE_DOUBLE;
    internal static int STYLE_FLOAT;
    internal static int STYLE_LONG;
    internal static int STYLE_SHORT;
    internal static int STYLE_SKIP;
    private static int FORMAT_ADT_ATTR;
    private static int FORMAT_COLL_ELEM;
    private static int FORMAT_COLL_ELEM_NO_INDICATOR;
    private static int SQLCS_FLEXIBLE;
    private static int SQLCS_LIT_NULL;
    internal static int KOPT_V80;
    internal static int KOPT_V81;
    internal static int KOPT_VNFT;
    internal static int KOPT_VERSION;
    internal static int KOPT_NONE_FINAL_TYPE;
    internal static int KOPT_JAVA_OBJECT;
    internal static int TOID_SIZE;
    internal static int MaxLongRawSize;
    internal static string DBMSPICKLER_GETTYPESHAPE_RETURNVALUE;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_FULLTYPENANE;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_TOID;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_VERSION;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_TDS;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_ISINSTANTIABLE;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_SUPERTYPEOWNER;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_SUPERTYPENAME;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_TYPEMD;
    internal static string DBMSPICKLER_GETTYPESHAPE_PARAM_SUBTYPEMD;
    protected static string NullPropertyName;
    internal static Hashtable s_mapTypeNameToCustTypeCode;
    protected UDTSQLName m_sqlName;
    protected bool m_bHasMetaData;
    protected bool m_bCheckResource;
    protected bool m_bHasResource;
    protected bool m_bCheckSupportedAttribute;
    protected bool m_bIsSupportedAttribute;
    protected object m_metaDataLock;
    protected Byte[] m_toid;
    protected int m_version;
    protected bool m_bIsInstantiable;
    protected int m_tdsVersion;
    protected bool m_bIsSubType;
    protected bool m_bIsTDSAttr;
    protected bool m_bIsFinalType;
    protected object m_customTypeFactory;
    protected Type m_customType;
    protected object m_customTypeNullProperty;
    protected bool m_bIsCustomTypePopulated;
    internal int m_parseIndex;
    internal int m_parseOpcode;
    internal bool m_endOfAdt;
    protected string m_outputIdt;
    internal bool IsUDTType { get; }
    internal bool IsXmlType { get; }
    internal bool IsSupportedType { get; }
    internal bool HasMetaData { get; }
    internal int Version { get; }
    internal string OwnerName { get; }
    internal string TypeName { get; }
    internal string FullTypeName { get; }
    internal Byte[] TOID { get; }
    internal bool IsFinalType { get; }
    internal OracleDbType OraDbType { get; }
    private static UDTNamedType();
    protected UDTNamedType(string schemaName, string typeName, UDTDbType typeCode);
    protected UDTNamedType(OracleConnection conn, UDTNamedType parent, int idx, UDTDbType typeCode);
    internal static OracleCommand CreateGetUDTTypeCmd();
    internal static void ResetGetTypeCommand(OracleCommand getTypeCmd);
    internal static UDTSQLName GetSQLNameFromParent(OracleConnection conn, UDTNamedType parent, int idx, UDTDbType typeCode);
    protected static UDTNamedType AddParsedTypeToCache(OracleConnection conn, UDTObjectType parsedType);
    internal static string ConvertTOIDToString(Byte[] toid);
    internal virtual bool get_IsUDTType();
    internal virtual bool get_IsXmlType();
    internal bool get_IsSupportedType();
    internal bool get_HasMetaData();
    internal int get_Version();
    internal string get_OwnerName();
    internal string get_TypeName();
    internal virtual string get_FullTypeName();
    internal Byte[] get_TOID();
    internal bool get_IsFinalType();
    internal OracleDbType get_OraDbType();
    internal void CopyProperties(UDTNamedType srcType);
    internal void GetNamedTypeMetaData(OracleConnection conn, OracleCommand getTypeCmd);
    protected void GetCommonMetaData(OracleConnection conn, OracleCommand getTypeCmd);
    protected virtual void GetMetaData(OracleConnection conn, OracleCommand getTypeCmd);
    internal UDTBasedType GetAttrType(OracleConnection conn, UDTTDSReader tdsReader);
    internal bool IsSameOwner(OracleConnection conn);
    internal Type GetCustomType(OracleConnection conn);
    internal IOracleCustomType CreateCustomObject(OracleConnection conn);
    internal object GetCustomTypeFactory(OracleConnection conn);
    internal virtual void DescribeCustomType(OracleConnection conn);
    protected virtual void DescribeCustomType(object customTypeFactory, OracleConnection conn);
    internal virtual IUDTPickleNamedInst CreateUDTInstance(OracleConnection conn, IUDTPickleNamedInst pickleNamedInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTCustomNamedInst CreateUDTInstance(OracleConnection conn, IOracleCustomType customInstance);
    internal virtual object GetNullCustomValue(OracleConnection conn, CustomTypeCode customTypeCode);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual bool IsNullCustomValue(OracleConnection conn, int attrIndex, object value, object udtStatusArray);
    internal virtual int PickleNull(UDTPickleContextWriter ctx);
}
internal class OracleInternal.UDT.Types.UDTNumberType : UDTBuiltInFixedLenType {
    internal static int MaxBytesLength;
    internal static byte MaxPrecision;
    internal static byte InvalidPrecision;
    internal static int InvalidScale;
    internal byte m_precision;
    internal int m_scale;
    internal int MaxFixedBytesLength { get; }
    protected UDTNumberType(UDTDbType typecode);
    private static UDTNumberType();
    internal static UDTNumberType CreateFromTDS(OracleConnection conn, UDTDbType typeCode, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal void WriteNumberToJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTObjectInst : UDTNamedInst {
    internal IUDTCustomInst[] m_attributes;
    internal UDTObjectInst(UDTObjectType objType);
    public virtual void ReleaseResource();
    internal void SetAttributeValue(OracleConnection conn, int attrIndex, object attrValue, object udtStatusArray);
}
internal class OracleInternal.UDT.Types.UDTObjectType : UDTNamedType {
    private static string SQL_GetAttrFromCurrentUser;
    private static string SQL_GetAttrFromCurrentUserAndCurrentSynonym;
    private static string SQL_GetAttrFromCurrentUserAndPublicSynonym;
    private static string SQL_GetAttrFromOtherUserAndCurrentSynonym;
    private static string SQL_GetAttrFromOtherUser;
    private static string SQL_GetAttrFromOtherUserAndAllSynonym;
    private static string SQL_GetAttrFromOtherUserAndPublicSynonym;
    private static string SQL_GetAttrFromCurrentUserByTOID;
    private static string SQL_GetAttrFromAllUserByTOID;
    private static string SQL_GetSQLNameFromAllTypeDictByTOID;
    private static string SQL_GetSubTypesFromAllTypeDict;
    internal int m_flattenedAttrNum;
    internal String[] m_attributeNames;
    internal UDTBasedType[] m_attributeTypes;
    internal UDTSQLName[] m_attributeTypeNames;
    internal AttrIndexByName m_attrNameToIndex;
    internal Byte[][] m_attributeTOIDs;
    internal UDTSQLName m_superTypeName;
    internal Dictionary`2<string, UDTObjectType> m_subTypeNames;
    internal Dictionary`2<string, UDTSQLName> m_subTypeTOIDs;
    internal bool m_bGetSubTypeNames;
    internal int NumberOfAttributes { get; }
    internal bool IsSupportedAttributeType { get; }
    internal bool MightHasResource { get; }
    internal UDTObjectType(string schemaName, string typeName);
    private UDTObjectType(OracleConnection conn, UDTNamedType parent, int idx);
    internal static UDTObjectType CreatedFromTDS(OracleConnection conn, UDTNamedType parent, int index, UDTTDSReader tds, bool bEmbedded);
    internal static UDTObjectType Create(OracleConnection conn, UDTNamedType parent, int idx);
    internal static bool IsCollection(UDTObjectType udtType);
    internal static bool IsOpaque(UDTObjectType udtType);
    internal static bool IsXml(UDTObjectType udtType);
    internal static UDTNamedType GetUDTNamedType(OracleConnection conn, UDTObjectType udtType, bool bIsTopLevel);
    internal static UDTSQLName GetSQLNameFromTOID(OracleConnection conn, Byte[] toid);
    internal int get_NumberOfAttributes();
    internal virtual bool get_IsSupportedAttributeType();
    internal virtual bool get_MightHasResource();
    internal UDTTDSReader ParseTDS(OracleConnection conn, Byte[] tds, long index);
    protected virtual void GetMetaData(OracleConnection conn, OracleCommand getTypeCmd);
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    private bool GetAttrNamesAndTypeNames(OracleDataReader attributes);
    private bool GetAttrNamesAndTypeNamesUsingSQLName(OracleConnection conn);
    private bool GetAttrNamesAndTypeNamesUsingTOID(OracleConnection conn, Byte[] toid);
    internal void GetAttrNamesAndTypeNames(OracleConnection conn);
    internal void GetSubTypeNames(OracleConnection conn);
    internal bool IsSubType(OracleConnection conn, string fullTypeName);
    internal bool IsSubType(OracleConnection conn, IOracleCustomType customObj);
    internal UDTSQLName GetSubTypeName(OracleConnection conn, Byte[] toid);
    internal UDTObjectType GetSubType(OracleConnection conn, Byte[] toid);
    internal UDTObjectType GetSubType(OracleConnection conn, UDTSQLName subTypeName);
    internal UDTObjectType GetSubType(OracleConnection conn, IOracleCustomType customObj);
    internal AttrIndexByName CreateAttrNameMapping(String[] attrNames);
    internal UDTBasedType GetAttributeType(OracleConnection conn, int attrIndex);
    internal int GetAttributeIndex(OracleConnection conn, string attrName);
    private bool HasVersion();
    private bool ShouldHavePrefix();
    private bool NeedsToid();
    protected virtual void DescribeCustomType(object customTypeFactory, OracleConnection conn);
    internal UDTObjectType GetRealInstType(OracleConnection conn, UDTPickleContextReader udtImageReader, byte flags);
    internal IUDTPickleNamedInst UnpickleObject(OracleConnection conn, UDTPickleObjectInst pickleObjInst, UDTPickleContextReader udtImageReader);
    private UDTPickleObjectInst UnpickleAttrInst(OracleConnection conn, UDTPickleObjectInst pickleObjInst, UDTPickleContextReader udtImageReader, byte len_flags, byte immemb);
    private UDTPickleObjectInst UnpickleObjAttrInstAsNull(OracleConnection conn, UDTPickleObjectInst pickleObjInst, UDTPickleContextReader udtImageReader, byte lenFlags, byte immemb);
    protected int Pickle81Prefix(UDTPickleContextWriter context);
    private int PickleObjectAttributes(OracleConnection conn, UDTPickleContextWriter ctx, IUDTCustomInst data, int depth);
    internal virtual int PickleNull(UDTPickleContextWriter ctx);
    internal virtual int Pickle(OracleConnection conn, UDTPickleContextWriter pickleCtxWriter, IUDTCustomInst objInst);
    internal virtual IUDTPickleNamedInst CreateUDTInstance(OracleConnection conn, IUDTPickleNamedInst pickleObjInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTCustomNamedInst CreateUDTInstance(OracleConnection conn, IOracleCustomType customObj);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleObjInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleObjInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatusArray);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal void WriteJsonAttributes(OracleConnection conn, Utf8JsonWriter writer, UDTPickleObjectInst objInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    private bool CheckType(OracleConnection conn, IOracleCustomType customObj);
    internal virtual bool IsNullCustomValue(OracleConnection conn, int attrIndex, object value, object udtStatusArray);
}
internal class OracleInternal.UDT.Types.UDTOpaqueType : UDTNamedType {
    internal static long KOLOFLLB;
    internal static long KOLOFLCL;
    internal static long KOLOFLUB;
    internal static long KOLOFLFX;
    internal long m_flagBits;
    internal long m_maxLen;
    internal bool m_bIsXmlType;
    internal bool IsSupportedAttributeType { get; }
    internal bool MightHasResource { get; }
    protected UDTOpaqueType(OracleConnection conn, UDTNamedType parent, int idx);
    internal static UDTNamedType CreatedFromTDS(OracleConnection conn, UDTNamedType parent, int index, UDTTDSReader tds);
    internal static bool IsXml(string fullName);
    internal virtual bool get_IsSupportedAttributeType();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatus);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual bool get_MightHasResource();
    internal virtual int Pickle(OracleConnection conn, UDTPickleContextWriter pickleCtxWriter, IUDTCustomInst inst);
}
internal class OracleInternal.UDT.Types.UDTPickleBlobInst : UDTPickleBuiltInBytesInst {
    internal UDTDbType m_lobTypeCode;
    internal Byte[] m_lobLocator;
    internal OracleBlob m_blob;
    internal UDTPickleBlobInst(UDTBlobType blobType);
    private UDTPickleBlobInst(OracleConnection conn, UDTBlobType blobType, Byte[] lobLocator);
    internal static UDTPickleBlobInst CreateBlobInst(OracleConnection conn, UDTBasedType udtType, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal static UDTPickleBlobInst CreateBlobInst(OracleConnection conn, UDTBasedType udtType, UDTPickleContextReader udtImageReader);
    public virtual void InitializePickleNull();
    public virtual void Initialize(UDTPickleContextReader udtImageReader);
    public virtual void Initialize(UDTPickleContextReader udtImageReader, byte lenFlags);
    public virtual void ReleaseResource();
    internal Byte[] GetBytes(OracleConnection conn);
    internal Byte[] GetBytes(OracleConnection conn, long maxLength);
    internal OracleBlob GetOracleBlob(OracleConnection conn);
}
internal class OracleInternal.UDT.Types.UDTPickleBuiltInBytesInst : UDTPickleBuiltInInst {
    protected Byte[] m_bytes;
    internal bool m_bSuppressGetDecimalInvalidCastException;
    internal Byte[] OracleBytes { get; }
    protected internal UDTPickleBuiltInBytesInst(UDTBasedType udtType);
    protected UDTPickleBuiltInBytesInst(UDTBasedType udtType, Byte[] image);
    internal UDTPickleBuiltInBytesInst(UDTBasedType udtType, Byte[] image, int imageLen);
    internal static UDTPickleBuiltInBytesInst Create(UDTBasedType udtType, UDTPickleContextReader udtImageReader);
    internal static UDTPickleBuiltInBytesInst Create(UDTBasedType udtType, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal Byte[] get_OracleBytes();
    public virtual void InitializePickleNull();
    public virtual void Initialize(UDTPickleContextReader udtImageReader);
    public virtual void Initialize(UDTPickleContextReader udtImageReader, byte lenFlags);
    public virtual void ReleaseResource();
}
internal class OracleInternal.UDT.Types.UDTPickleBuiltInFixedBytesInst : UDTPickleBuiltInBytesInst {
    protected internal UDTPickleBuiltInFixedBytesInst(UDTBasedType udtType);
    internal UDTPickleBuiltInFixedBytesInst(UDTBasedType udtType, Byte[] image, int imageLen);
    internal static UDTPickleBuiltInFixedBytesInst Create(UDTBasedType udtType, UDTPickleContextReader udtImageReader);
    internal static UDTPickleBuiltInFixedBytesInst Create(UDTBasedType udtType, UDTPickleContextReader udtImageReader, byte lenFlags);
    public virtual void InitializePickleNull();
    public virtual void Initialize(UDTPickleContextReader udtImageReader);
    public virtual void Initialize(UDTPickleContextReader udtImageReader, byte lenFlags);
    public virtual void ReleaseResource();
}
internal abstract class OracleInternal.UDT.Types.UDTPickleBuiltInInst : UDTInst {
    protected int m_imageLen;
    protected bool m_bIsNull;
    public bool IsNull { get; }
    public int PickleImageLength { get; }
    protected UDTPickleBuiltInInst(UDTBasedType udtType);
    public virtual bool get_IsNull();
    public sealed virtual int get_PickleImageLength();
    protected void Reset();
    public abstract virtual void InitializePickleNull();
    public abstract virtual void Initialize(UDTPickleContextReader imageReader);
    public abstract virtual void Initialize(UDTPickleContextReader imageReader, byte lenFlags);
    public sealed virtual object GetCustomValue(OracleConnection conn, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    public virtual void WriteJsonNull(OracleConnection conn, Utf8JsonWriter writer, string name);
    public virtual void WriteJsonNull(OracleConnection conn, Utf8JsonWriter writer);
    public virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name);
    public virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer);
}
internal class OracleInternal.UDT.Types.UDTPickleBuiltInSegmentInst : UDTPickleBuiltInInst {
    private UDTPickleContextReader m_udtImageReader;
    private int m_imageOrgOffset;
    internal UDTPickleContextReader ImageReader { get; }
    internal UDTPickleBuiltInSegmentInst(UDTBuiltInType udtType);
    private UDTPickleBuiltInSegmentInst(UDTBuiltInType udtType, PickleImage image, long offset, long imageLength);
    internal static UDTPickleBuiltInSegmentInst Create(OracleConnection conn, UDTBasedType udtType, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal static UDTPickleBuiltInSegmentInst Create(OracleConnection conn, UDTBasedType udtType, UDTPickleContextReader udtImageReader);
    internal UDTPickleContextReader get_ImageReader();
    public virtual void InitializePickleNull();
    public virtual void Initialize(UDTPickleContextReader udtImageReader);
    public virtual void Initialize(UDTPickleContextReader udtImageReader, byte lenFlags);
    public virtual void ReleaseResource();
}
internal class OracleInternal.UDT.Types.UDTPickleClobInst : UDTPickleBuiltInBytesInst {
    internal Byte[] m_lobLocator;
    internal OracleClob m_clob;
    internal UDTPickleClobInst(UDTClobType clobType);
    private UDTPickleClobInst(OracleConnection conn, UDTClobType clobType, Byte[] lobLocator);
    internal static UDTPickleClobInst CreateClobInst(OracleConnection conn, UDTBasedType udtType, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal static UDTPickleClobInst CreateClobInst(OracleConnection conn, UDTBasedType udtType, UDTPickleContextReader udtImageReader);
    public virtual void InitializePickleNull();
    public virtual void Initialize(UDTPickleContextReader udtImageReader);
    public virtual void Initialize(UDTPickleContextReader udtImageReader, byte lenFlags);
    public virtual void ReleaseResource();
    internal string GetString(OracleConnection conn);
    internal string GetString(OracleConnection conn, long maxLength);
    internal OracleClob GetOracleClob(OracleConnection conn);
}
internal class OracleInternal.UDT.Types.UDTPickleCollectionInst : UDTPickleNamedInst {
    internal byte m_prefixFlags;
    internal IUDTPickleInst m_elementInst;
    internal byte PrefixFlag { get; internal set; }
    internal bool IsInLineImage { get; }
    internal UDTPickleCollectionInst(UDTCollectionType collType);
    internal UDTPickleCollectionInst(UDTCollectionType collType, PickleImage image, long offset, long imageLength);
    internal byte get_PrefixFlag();
    internal void set_PrefixFlag(byte value);
    internal bool get_IsInLineImage();
    public virtual void ReleaseResource();
    internal Array UnpickleElements(OracleConnection conn, OracleUdtStatus[]& elementStatusArray);
    internal void WriteUnpickleElements(OracleConnection conn, Utf8JsonWriter writer);
    protected virtual object GetValue(OracleConnection conn, bool bGetElements, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    internal object GetElements(OracleConnection conn, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    public virtual object GetCustomValue(OracleConnection conn, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    public virtual object GetCustomValue(OracleConnection conn);
    public virtual void WriteUDTJson(OracleConnection conn, Utf8JsonWriter writer);
}
internal class OracleInternal.UDT.Types.UDTPickleCollectionLocatorInst : UDTPickleCollectionInst {
    private Byte[] m_locator;
    internal Byte[] Locator { get; }
    internal UDTPickleCollectionLocatorInst(UDTCollectionType collType, PickleImage image, long offset, long imageLength);
    internal Byte[] get_Locator();
    internal virtual void InitUDTInstance(OracleConnection conn, PickleImage image, long offset, long length);
    public virtual void InitializePickleNull();
    protected virtual object GetValue(OracleConnection conn, bool bGetElements, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    public virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name);
}
internal abstract class OracleInternal.UDT.Types.UDTPickleContext : object {
    internal static short KOPI20_LN_ELNL;
    internal static short KOPI20_LN_5BLN;
    internal static short KOPI20_LN_ATMN;
    internal static short KOPI20_LN_IEMN;
    internal static short KOPI20_LN_MAXV;
    internal static short KOPI20_IF_IS81;
    internal static short KOPI20_IF_CMSB;
    internal static short KOPI20_IF_CLSB;
    internal static short KOPI20_IF_DEGN;
    internal static short KOPI20_IF_COLL;
    internal static short KOPI20_IF_NOPS;
    internal static short KOPI20_IF_ANY;
    internal static short KOPI20_IF_NONL;
    internal static short KOPI20_CF_CMSB;
    internal static short KOPI20_CF_CLSB;
    internal static short KOPI20_CF_INDX;
    internal static short KOPI20_CF_NOLN;
    internal static short KOPI20_VERSION;
    internal static byte KOPU_UPT_INDEX_TBL;
    internal static byte KOPU_UPT_NEST_TBL;
    internal static byte KOPU_UPT_VARRAY;
    internal static byte KOPU_UPT_ASSOC_ARRAY;
    internal static byte KOPUP_INLINE_COLL;
    internal static byte KOPUP_TYPEINFO_NONE;
    internal static byte KOPUP_TYPEINFO_TOID;
    internal static byte KOPUP_TYPEINFO_TOBJN;
    internal static byte KOPUP_TYPEINFO_TDS;
    internal static byte KOPUP_VSN_PRESENT;
    internal static bool IsInLineImage(int prefixFlag);
}
internal abstract class OracleInternal.UDT.Types.UDTPickleContextReader : UDTPickleContext {
    protected int m_imageLen;
    protected int m_imageOffset;
    protected int m_userCode;
    internal long Offset { get; internal set; }
    internal int AbsoluteOffset { get; internal set; }
    internal PickleImage Image { get; }
    protected UDTPickleContextReader(List`1<ArraySegment`1<byte>> dataSegmentsImage, int imageLen);
    protected UDTPickleContextReader(PickleImage pickleImage, int imageLen);
    internal static UDTPickleContextReader CreateUDTPickleReader();
    internal static UDTPickleContextReader CreateUDTPickleReader(List`1<ArraySegment`1<byte>> dataSegments, int imageLength);
    internal static UDTPickleContextReader CreateUDTPickleReader(PickleImage image, int offset, int imageLen);
    internal static bool Is81format(byte flag);
    internal static bool IsCollectionImage_pctx(byte flag);
    internal static bool IsDegenerateImage_pctx(byte flag);
    internal static bool HasPrefix(byte flag);
    internal static bool IsAtomicNull(byte flag);
    internal static bool IsImmediatelyEmbeddedNull(byte flag);
    internal static bool IsElementNull(byte flag);
    internal long get_Offset();
    internal void set_Offset(long value);
    internal int get_AbsoluteOffset();
    internal void set_AbsoluteOffset(int value);
    internal abstract virtual PickleImage get_Image();
    internal virtual void Reset();
    internal abstract virtual void Initialize(PickleImage image, long offset, long imageLen);
    internal abstract virtual void ReleaseResource();
    internal abstract virtual bool CheckNull();
    internal abstract virtual byte ReadByte();
    internal abstract virtual int ReadInt();
    internal abstract virtual void CopyToBuffer(Byte[] destBuf, int destOffset, int length);
    internal abstract virtual long ReadIntInNativeFormat();
    internal abstract virtual int ReadShortInNativeFormat();
    internal abstract virtual Char[] ReadChars(Conv conv, int length);
    internal abstract virtual string ConvertToString(OracleConnection conn, Conv conv, int length);
    internal void Initialize(long offset, long imageLen);
    internal bool ReadAndCheckVersion();
    internal int ReadLength();
    internal int ReadRestOfLength(byte len);
    internal void SkipRestOfLength(byte len);
    internal int ReadLength(bool exclude);
    internal Byte[] ReadDataValue();
    internal Byte[] ReadDataValue(byte byte1);
    internal Byte[] ReadBytes(int len);
    internal Byte[] ReadBytes(Byte[] bytes, int len);
    internal void SkipBytes(int b);
    internal void SkipTo(long offset);
    internal void SetCollectionUserCode(int userCode);
}
internal class OracleInternal.UDT.Types.UDTPickleContextStream : MemoryStream {
    internal long Offset { get; }
    internal long get_Offset();
    internal int WriteUB1(byte byte1);
    internal void Overwrite(int beginOff, Byte[] b, int off, int len);
    internal void Write(Byte[] val);
}
internal class OracleInternal.UDT.Types.UDTPickleContextWriter : UDTPickleContext {
    private UDTPickleContextStream m_outStream;
    private Byte[] m_byteBuffer;
    internal long Offset { get; }
    internal long get_Offset();
    internal int Set5bLengthBytes_pctx(int len);
    internal void PatchImageLen(int offset, int image_length);
    internal int WriteElementNull();
    internal int WriteAtomicNull();
    internal int WriteImmediatelyEmbeddedElementNull(byte null_adtno);
    internal int Write5bLengthBytes_pctx(int len);
    internal int WriteSB2(int len);
    internal int WriteLength(int len);
    internal int WriteData(byte b);
    internal int WriteData(Byte[] b);
    internal int WriteImageHeader(bool withPrefix);
    internal int WriteImageHeader(int image_length, bool withPrefix);
    internal int WriteCollImageHeader(int num_collection_items, int typeVersion, byte collTypeID);
    internal int WriteCollImageHeader(int image_length, int num_collection_items, int typeVersion, byte collTypeID);
    internal int WriteCollImageHeader(Byte[] prefix_segment);
    internal int WriteCollImageHeader(int image_length, Byte[] prefix_segment);
    internal Byte[] Stream2Bytes();
}
internal abstract class OracleInternal.UDT.Types.UDTPickleNamedInst : UDTNamedInst {
    protected int m_imageLen;
    protected int m_imageOrgOffset;
    protected UDTPickleContextReader m_udtImageReader;
    public int PickleImageLength { get; }
    protected UDTPickleNamedInst(UDTNamedType udtType);
    public sealed virtual int get_PickleImageLength();
    internal virtual void InitUDTInstance(OracleConnection conn, PickleImage image, long offset, long length);
    public virtual void Reset();
    public virtual void InitializePickleNull();
    public abstract virtual object GetCustomValue(OracleConnection conn, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    public abstract virtual object GetCustomValue(OracleConnection conn);
    public virtual void WriteJsonNull(OracleConnection conn, Utf8JsonWriter writer, string name);
    public virtual void WriteJsonNull(OracleConnection conn, Utf8JsonWriter writer);
    public virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name);
    public virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer);
    public abstract virtual void WriteUDTJson(OracleConnection conn, Utf8JsonWriter writer);
}
internal class OracleInternal.UDT.Types.UDTPickleObjectInst : UDTPickleNamedInst {
    private IUDTPickleInst[] m_attributes;
    internal bool m_bSuppressGetDecimalInvalidCastException;
    internal IUDTPickleInst[] Attributes { get; }
    internal bool HasAttributesPopulated { get; }
    internal UDTPickleObjectInst(UDTObjectType objType);
    internal UDTPickleObjectInst(UDTObjectType objType, PickleImage image, long offset, long imageLength);
    internal UDTPickleObjectInst(UDTObjectType objType, IUDTPickleInst[] attributes);
    internal IUDTPickleInst[] get_Attributes();
    internal bool get_HasAttributesPopulated();
    internal void PopulateAttrInstances(OracleConnection conn);
    internal object GetAttributeValue(OracleConnection conn, int attrIndex, OracleUdtStatus& attrStatus, OracleUdtStatus[]& elemArrayStatus);
    internal bool IsAttributeNull(OracleConnection conn, int attrIndex);
    internal void InitializeAttributes(IUDTPickleInst[] attributes);
    public virtual void ReleaseResource();
    public virtual object GetCustomValue(OracleConnection conn, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    public virtual object GetCustomValue(OracleConnection conn);
    public virtual void WriteJsonNull(OracleConnection conn, Utf8JsonWriter writer, string name);
    public virtual void WriteJsonNull(OracleConnection conn, Utf8JsonWriter writer);
    public virtual void WriteUDTJson(OracleConnection conn, Utf8JsonWriter writer);
}
internal class OracleInternal.UDT.Types.UDTPickleSegmentsReader : UDTPickleContextReader {
    private Byte[] m_byte4;
    private PickleDataSegmentsImage m_pickleImage;
    internal PickleImage Image { get; }
    internal UDTPickleSegmentsReader(List`1<ArraySegment`1<byte>> dataSegments, int imageLen);
    internal UDTPickleSegmentsReader(PickleImage image, long offset, int imageLen);
    internal virtual PickleImage get_Image();
    internal virtual void Initialize(PickleImage image, long offset, long imageLen);
    internal void Initialize(List`1<ArraySegment`1<byte>> dataSegments, long imageLen);
    internal virtual void ReleaseResource();
    internal virtual bool CheckNull();
    internal virtual byte ReadByte();
    internal virtual int ReadInt();
    internal virtual void CopyToBuffer(Byte[] buf, int offset, int length);
    internal virtual long ReadIntInNativeFormat();
    internal virtual int ReadShortInNativeFormat();
    internal virtual Char[] ReadChars(Conv conv, int length);
    internal virtual string ConvertToString(OracleConnection conn, Conv conv, int length);
}
internal class OracleInternal.UDT.Types.UDTPickleXmlTypeInst : UDTPickleNamedInst {
    private OracleXmlTypeImpl m_xmlTypeImpl;
    internal OracleXmlTypeImpl XmlValue { get; }
    internal UDTPickleXmlTypeInst(UDTXmlType xmlType);
    internal UDTPickleXmlTypeInst(OracleConnection conn, UDTXmlType xmlType, OracleXmlTypeImpl xmlImpl, PickleImage image, long offset, long imageLength);
    internal void InitializeXml(OracleConnection conn, OracleXmlTypeImpl xmlImpl, PickleImage image, long offset, long imageLength);
    internal OracleXmlTypeImpl get_XmlValue();
    public virtual void ReleaseResource();
    public virtual object GetCustomValue(OracleConnection conn, OracleUdtStatus& udtStatus, OracleUdtStatus[]& elemStatusArray);
    public virtual object GetCustomValue(OracleConnection conn);
    public virtual void WriteUDTJson(OracleConnection conn, Utf8JsonWriter writer);
}
internal class OracleInternal.UDT.Types.UDTRawType : UDTBuiltInType {
    private int m_length;
    internal static UDTRawType CreateFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTRefType : UDTBuiltInType {
    internal UDTSQLName m_sqlName;
    internal UDTRefType(OracleConnection conn, UDTNamedType parent, int idx);
    internal static UDTRefType CreatedFromTDS(OracleConnection conn, UDTNamedType parent, int index, UDTTDSReader tds);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal enum OracleInternal.UDT.Types.UDTSQLState : Enum {
    public int value__;
    public static UDTSQLState CURRENT_USER;
    public static UDTSQLState CURRENT_USER_CURRENT_SYNONYM;
    public static UDTSQLState CURRENT_USER_PUBLIC_SYNONYM;
    public static UDTSQLState OTHER_USER_CURRENT_SYNONYM;
    public static UDTSQLState OTHER_USER;
    public static UDTSQLState OTHER_USER_ALL_SYNONYM;
    public static UDTSQLState OTHER_USER_PUBLIC_SYNONYM;
    public static UDTSQLState BREAK;
}
internal enum OracleInternal.UDT.Types.UDTState : Enum {
    public int value__;
    public static UDTState Null;
    public static UDTState ContextReader;
    public static UDTState Attributes;
    public static UDTState Element;
    public static UDTState Locator;
    public static UDTState Xml;
}
internal class OracleInternal.UDT.Types.UDTTimeStampLTZType : UDTBuiltInFixedLenType {
    internal static int MaxBytesLength;
    private byte m_fracSecondPrec;
    internal int MaxFixedBytesLength { get; }
    private static UDTTimeStampLTZType();
    internal static UDTTimeStampLTZType CreateTimeStampLTZFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTTimeStampType : UDTBuiltInFixedLenType {
    internal static int MaxBytesLength;
    private byte m_fracSecondPrec;
    internal int MaxFixedBytesLength { get; }
    private static UDTTimeStampType();
    internal static UDTTimeStampType CreateTimeStampFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTTimeStampTZType : UDTBuiltInFixedLenType {
    internal static int MaxBytesLength;
    private byte m_fracSecondPrec;
    internal int MaxFixedBytesLength { get; }
    private static UDTTimeStampTZType();
    internal static UDTTimeStampTZType CreateFromTDS(OracleConnection conn, int index, UDTTDSReader tds);
    internal virtual int get_MaxFixedBytesLength();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetOracleValue(OracleConnection conn, CustomTypeCode customTypeCode, object customValue);
}
internal class OracleInternal.UDT.Types.UDTTypeCache : object {
    protected string m_cacheName;
    private OracleCommand m_getTypeCmd;
    private UDTTypesByName m_UDTTypeCache;
    private UDTTypeNamesByTOID m_UDTToidCache;
    private object m_typeCacheLock;
    internal UDTTypeCache(string cacheName);
    internal void GetMetaData(OracleConnection conn, UDTNamedType udtType);
    private UDTNamedType CreateUDTType(OracleConnection conn, string schemaName, string typeName);
    internal UDTNamedType AddUDTType(UDTNamedType udtType);
    internal UDTSQLName GetUDTSQLName(OracleConnection conn, Byte[] toid);
    internal UDTNamedType GetUDTType(OracleConnection conn, string schemaName, string typeName);
}
internal class OracleInternal.UDT.Types.UDTUPTType : UDTNamedType {
    internal static byte KOPU_UPT_ADT;
    internal static byte KOPU_UPT_COLL;
    internal static byte KOPU_UPT_REFCUR;
    internal byte m_typeID;
    internal UDTNamedType m_actualType;
    internal bool IsXmlType { get; }
    internal bool IsSupportedAttributeType { get; }
    internal bool MightHasResource { get; }
    internal CustomTypeCode CustomTypeCode { get; internal set; }
    private UDTUPTType(OracleConnection conn, UDTNamedType parent, int index);
    internal static UDTUPTType CreatedFromTDS(OracleConnection conn, UDTNamedType parent, int index, UDTTDSReader tds);
    internal virtual bool get_IsXmlType();
    internal virtual bool get_IsSupportedAttributeType();
    internal virtual bool get_MightHasResource();
    internal virtual CustomTypeCode get_CustomTypeCode();
    internal virtual void set_CustomTypeCode(CustomTypeCode value);
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    private IUDTPickleNamedInst UnpickleUPT(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual int PickleNull(UDTPickleContextWriter pickleCtxWriter);
    internal virtual int Pickle(OracleConnection conn, UDTPickleContextWriter pickleCtxWriter, IUDTCustomInst udtInst);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatus);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual object GetNullCustomValue(OracleConnection conn, CustomTypeCode customTypeCode);
    internal virtual bool IsNullCustomValue(OracleConnection conn, int attrIndex, object value, object udtStatusArray);
}
internal class OracleInternal.UDT.Types.UDTXmlType : UDTNamedType {
    internal static string PUBLIC_XMLTYPE_STRING_VALUE;
    internal static string SYS_XMLTYPE_STRING_VALUE;
    internal static string XMLTYPE_SYS_OWNER;
    internal static string XMLTYPE_PUBLIC_OWNER;
    internal static string XMLTYPE_NAME;
    internal static UDTXmlType s_UDTXmlType;
    internal long m_maxLen;
    internal long m_flagBits;
    internal bool IsXmlType { get; }
    internal bool IsSupportedAttributeType { get; }
    internal bool MightHasResource { get; }
    internal UDTXmlType(string schemaName, string typeName);
    internal static UDTXmlType GetUDTXmlType(OracleConnection conn, string schemaName, string typeName);
    internal virtual bool get_IsXmlType();
    internal virtual bool get_IsSupportedAttributeType();
    internal virtual bool get_MightHasResource();
    internal virtual void ParseTypeInfo(OracleConnection conn, int index, UDTTDSReader tdsReader);
    internal IUDTPickleNamedInst UnpickleXml(OracleConnection conn, UDTPickleXmlTypeInst xmlTypeInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleNamedInst CreateUDTInstance(OracleConnection conn, IUDTPickleNamedInst xmlTypeInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader);
    internal virtual IUDTPickleInst CreateAttrInstance(OracleConnection conn, IUDTPickleInst pickleInst, UDTPickleContextReader udtImageReader, byte lenFlags);
    internal virtual IUDTCustomInst CreateAttrInstance(OracleConnection conn, int attrIndex, object attrValue, object udtStatusArray);
    internal virtual IUDTPickleInst CreateNullPickleInstance(IUDTPickleInst pickleInst);
    internal virtual object GetNullCustomValue(OracleConnection conn, CustomTypeCode customTypeCode);
    internal virtual object GetCustomValue(OracleConnection conn, CustomTypeCode customTypeCode, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, string name, IUDTPickleInst udtInst);
    internal virtual void WriteJson(OracleConnection conn, Utf8JsonWriter writer, IUDTPickleInst udtInst);
    internal virtual bool IsNullCustomValue(OracleConnection conn, int attrIndex, object value, object udtStatusArray);
    internal virtual int PickleNull(UDTPickleContextWriter ctx);
    internal virtual int Pickle(OracleConnection conn, UDTPickleContextWriter pickleCtxWriter, IUDTCustomInst inst);
}
internal class OracleInternal.UDT.Types.UDTXmlTypeInst : UDTNamedInst {
    internal OracleXmlTypeImpl m_xmlTypeImpl;
    internal OracleXmlTypeImpl XmlValue { get; }
    internal UDTXmlTypeInst(UDTXmlType xmlType, OracleXmlTypeImpl xmlTypeImpl);
    internal OracleXmlTypeImpl get_XmlValue();
    public virtual void ReleaseResource();
}
internal class OracleInternal.Vector.VectorBytesImage : VectorImage {
    internal Byte[] m_bytes;
    internal VectorBytesImage(Byte[] bytes, int imageLen);
    internal void Initialize(Byte[] bytes, int imageLen);
    internal virtual void Reset();
}
internal class OracleInternal.Vector.VectorCommon : object {
    internal static byte ODP_SUPPORTED_MAX_VERSION;
    protected static byte LVECTOR_H_MAGIC;
    protected static byte LVECTOR_VER0;
    protected static UInt32 LVECTOR_MINIMUM_VECTOR_LEN;
    protected static UInt32 LVECTOR_MINIMUM_DATA_LEN;
    protected static UInt32 LVECTOR_UNKNOWN_DIMENSION;
    protected static ushort LVECTOR_H_FLAG1_OPTIONAL;
    protected static ushort LVECTOR_H_FLAG1_LITENDIAN;
    protected static ushort LVECTOR_H_FLAG1_NORM;
    protected static ushort LVECTOR_H_FLAG1_UKDIM;
    protected static ushort LVECTOR_H_FLAG1_IEEETYP;
    protected static ushort LVECTOR_H_FLAG1_NORMSRC;
    protected static UInt32 LVECTOR_H_FLAG2_NORM;
    internal static byte LVECTOR_FLEX;
    internal static byte LVECTOR_FLOAT16;
    internal static byte LVECTOR_FLOAT32;
    internal static byte LVECTOR_DOUBLE;
    internal static byte LVECTOR_INT8;
    internal static byte LVECTOR_TYPE_ERROR;
}
internal class OracleInternal.Vector.VectorDecoder : VectorCommon {
    private static Int16[] GetInt8s(VectorImageReader imageReader, VectorNumFormat vectorNumFormat, long count);
    private static short GetInt8(VectorImageReader imageReader, VectorNumFormat vectorNumFormat);
    private static float GetFloat(VectorImageReader imageReader, VectorNumFormat vectorNumFormat);
    private static Single[] GetFloat32s(VectorImageReader imageReader, VectorNumFormat vectorNumFormat, long count);
    private static double GetDouble(VectorImageReader imageReader, VectorNumFormat vectorNumFormat);
    private static Double[] GetDoubles(VectorImageReader imageReader, VectorNumFormat vectorNumFormat, long count);
    private static object GetNumeric(VectorImageReader reader, VectorNumFormat numFormat);
    internal static Array GetNumericArray(VectorImageReader imageReader, VectorNumFormat reqType, VectorNumFormat numFormat, long count);
    internal static VectorNumFormat GetNumFormat(VectorImageReader imageReader);
    internal static Array Decode(VectorImageReader imageReader, VectorNumFormat reqNumFormat, VectorNumFormat& vectorNumFormat);
    internal static Array Decode(VectorImageReader imageReader, VectorNumFormat reqNumFormat);
}
internal class OracleInternal.Vector.VectorEncoder : VectorCommon {
    private static bool WriteInt8s(VectorImageWriter imageWriter, Array nums, long count);
    private static bool WriteFloats(VectorImageWriter imageWriter, Array nums, long count);
    private static bool WriteDoubles(VectorImageWriter imageWriter, Array nums, long count);
    private static void WriteNumericArray(VectorImageWriter imageWriter, VectorNumFormat numFormat, Array numArray, long count);
    internal static void WriteImageHeader(VectorImageWriter imageWriter, VectorNumFormat numFormat, UInt32 dim, bool bNorm, double norm);
    private static UInt32 GetNumOfDimension(string vectorString, Byte[] vectorStrBytes);
    internal static Byte[] EncodeJsonStr(VectorImageWriter writer, VectorNumFormat vectorNumFormat, bool bNorm, double norm, string vectorString);
    internal static Byte[] Encode(VectorNumFormat reqVectorNumFormat, Array numArray);
    internal static Byte[] Encode(VectorNumFormat vectorNumFormat, string numArray);
}
internal abstract class OracleInternal.Vector.VectorImage : object {
    protected int m_imageLen;
    protected VectorImage(int imageLen);
    internal abstract virtual void Reset();
}
internal class OracleInternal.Vector.VectorImageHeader : VectorCommon {
    private byte m_version;
    private int m_flag;
    private bool m_bLittleEndian;
    private bool m_bUnknownDim;
    private UInt32 m_dimCount;
    private VectorNumFormat m_numFormat;
    private bool m_bNorm;
    internal bool HasNorm { get; }
    internal VectorNumFormat NumFormat { get; }
    internal UInt32 Dimension { get; }
    internal bool LittleEndian { get; }
    internal byte Version { get; }
    internal VectorImageHeader(VectorNumFormat numFormat, byte version, int flag, bool bLittleEndian, bool bUnknownDim, UInt32 dimCount, bool bNorm);
    internal bool get_HasNorm();
    internal VectorNumFormat get_NumFormat();
    internal UInt32 get_Dimension();
    internal bool get_LittleEndian();
    internal byte get_Version();
}
internal class OracleInternal.Vector.VectorImageReader : VectorCommon {
    private int m_imageOffset;
    private Byte[] m_2Bytes;
    private Byte[] m_4Bytes;
    private Byte[] m_8Bytes;
    private VectorBytesImage m_pickleImage;
    private VectorImageHeader m_imageHeader;
    internal VectorImageHeader ImageHeader { get; }
    internal VectorImageReader(Byte[] pickled_bytes, int imageLen);
    internal VectorImageHeader get_ImageHeader();
    internal void Initialize(long offset);
    internal void Initialize(Byte[] bytesImage, long imageLen);
    internal void Reset();
    internal void ReleaseResource();
    internal void CopyToBuffer(Byte[] destBuf, int destOffset, int length);
    internal void SkipBytes(int count);
    internal byte ReadByte();
    internal short ReadSByte();
    internal float ReadBinaryFloat();
    internal double ReadBinaryDouble();
    internal UInt32 ReadUInt(bool bLittleEndian);
    internal UInt32 ReadUShort(bool bLittleEndian);
    internal int ReadShortInNativeFormat();
}
internal class OracleInternal.Vector.VectorImageStream : MemoryStream {
    internal void Reset();
    internal int WriteUB1(byte byte1);
    internal int WriteSB1(sbyte sbyte1);
}
internal class OracleInternal.Vector.VectorImageWriter : object {
    private VectorImageStream m_outStream;
    private Byte[] m_byteBuffer;
    private Byte[] m_4Bytes;
    private Byte[] m_8Bytes;
    internal void Reset();
    internal int WriteSByte(sbyte b);
    internal int WriteByte(byte b);
    internal int WriteUB2(ushort val);
    internal int WriteUB4(UInt32 val);
    internal int WriteBinaryFloat(float flt);
    internal int WriteBinaryDouble(double dbl);
    internal int WriteZeros(int count);
    internal Byte[] GetBytes();
}
internal enum OracleInternal.Vector.VectorNumFormat : Enum {
    public int value__;
    public static VectorNumFormat Flex;
    public static VectorNumFormat Float16;
    public static VectorNumFormat Float32;
    public static VectorNumFormat Float64;
    public static VectorNumFormat Int8;
    public static VectorNumFormat Error;
    public static VectorNumFormat DotNetVector;
    public static VectorNumFormat BinaryDouble;
    public static VectorNumFormat BinaryFloat;
}
internal class resfinder : object {
}
[ExtensionAttribute]
internal static class StringExtensions : object {
    private static Char[] sCharsToMatch;
    private static String[] sStringsToReplaceWith;
    private static StringExtensions();
    [ExtensionAttribute]
internal static bool Contains(string str, string subString, StringComparison compareType);
    [ExtensionAttribute]
internal static string ReplaceXmlChars(string str);
    internal static int CompareWithAmpersand(Char[] strArray, int index, int length, int ampArrayIndex);
    internal static int CompareWithAmpersand(Char[] strArray, int index, int length, Int32& charsToSkip);
    private static string Replace(string str, Char[] charsToMatch, String[] stringsToReplaceWith);
    public static int IndexOfAny(Char[] strArray, int offset, Char[] charsToMatch, int inputLength);
    public static int Replace(StringBuilder sb, Char[] strArray, int offset, int arrayCount, Char[] charsToMatch, String[] stringsToReplaceWith);
}
