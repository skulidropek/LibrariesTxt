internal static class Consts : object {
    public static string AssemblyName;
    public static string PublicKey;
}
internal class Mono.ArgumentNullOrEmptyException : ArgumentException {
    public ArgumentNullOrEmptyException(string paramName);
}
public class Mono.Cecil.ArrayDimension : ValueType {
    private Nullable`1<int> lower_bound;
    private Nullable`1<int> upper_bound;
    public Nullable`1<int> LowerBound { get; public set; }
    public Nullable`1<int> UpperBound { get; public set; }
    public bool IsSized { get; }
    public ArrayDimension(Nullable`1<int> lowerBound, Nullable`1<int> upperBound);
    public Nullable`1<int> get_LowerBound();
    public void set_LowerBound(Nullable`1<int> value);
    public Nullable`1<int> get_UpperBound();
    public void set_UpperBound(Nullable`1<int> value);
    public bool get_IsSized();
    public virtual string ToString();
}
public class Mono.Cecil.ArrayMarshalInfo : MarshalInfo {
    internal NativeType element_type;
    internal int size_parameter_index;
    internal int size;
    internal int size_parameter_multiplier;
    public NativeType ElementType { get; public set; }
    public int SizeParameterIndex { get; public set; }
    public int Size { get; public set; }
    public int SizeParameterMultiplier { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_SizeParameterIndex();
    public void set_SizeParameterIndex(int value);
    public int get_Size();
    public void set_Size(int value);
    public int get_SizeParameterMultiplier();
    public void set_SizeParameterMultiplier(int value);
}
public class Mono.Cecil.ArrayType : TypeSpecification {
    private Collection`1<ArrayDimension> dimensions;
    public Collection`1<ArrayDimension> Dimensions { get; }
    public int Rank { get; }
    public bool IsVector { get; }
    public bool IsValueType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsArray { get; }
    public ArrayType(TypeReference type);
    public ArrayType(TypeReference type, int rank);
    public Collection`1<ArrayDimension> get_Dimensions();
    public int get_Rank();
    public bool get_IsVector();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsArray();
}
[FlagsAttribute]
public enum Mono.Cecil.AssemblyAttributes : Enum {
    public UInt32 value__;
    public static AssemblyAttributes PublicKey;
    public static AssemblyAttributes SideBySideCompatible;
    public static AssemblyAttributes Retargetable;
    public static AssemblyAttributes WindowsRuntime;
    public static AssemblyAttributes DisableJITCompileOptimizer;
    public static AssemblyAttributes EnableJITCompileTracking;
}
public class Mono.Cecil.AssemblyDefinition : object {
    private AssemblyNameDefinition name;
    internal ModuleDefinition main_module;
    private Collection`1<ModuleDefinition> modules;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    public AssemblyNameDefinition Name { get; public set; }
    public string FullName { get; }
    public MetadataToken MetadataToken { get; public set; }
    public Collection`1<ModuleDefinition> Modules { get; }
    public ModuleDefinition MainModule { get; }
    public MethodDefinition EntryPoint { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public AssemblyNameDefinition get_Name();
    public void set_Name(AssemblyNameDefinition value);
    public string get_FullName();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public Collection`1<ModuleDefinition> get_Modules();
    public ModuleDefinition get_MainModule();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual void Dispose();
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind);
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters);
    public static AssemblyDefinition ReadAssembly(string fileName);
    public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters);
    public static AssemblyDefinition ReadAssembly(Stream stream);
    public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters);
    private static AssemblyDefinition ReadAssembly(ModuleDefinition module);
    public void Write(string fileName);
    public void Write(string fileName, WriterParameters parameters);
    public void Write();
    public void Write(WriterParameters parameters);
    public void Write(Stream stream);
    public void Write(Stream stream, WriterParameters parameters);
    public virtual string ToString();
}
public enum Mono.Cecil.AssemblyHashAlgorithm : Enum {
    public UInt32 value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
    public static AssemblyHashAlgorithm Reserved;
}
public class Mono.Cecil.AssemblyLinkedResource : Resource {
    private AssemblyNameReference reference;
    public AssemblyNameReference Assembly { get; public set; }
    public ResourceType ResourceType { get; }
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags);
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference);
    public AssemblyNameReference get_Assembly();
    public void set_Assembly(AssemblyNameReference value);
    public virtual ResourceType get_ResourceType();
}
public class Mono.Cecil.AssemblyNameDefinition : AssemblyNameReference {
    public Byte[] Hash { get; }
    public AssemblyNameDefinition(string name, Version version);
    public virtual Byte[] get_Hash();
}
public class Mono.Cecil.AssemblyNameReference : object {
    private string name;
    private string culture;
    private Version version;
    private UInt32 attributes;
    private Byte[] public_key;
    private Byte[] public_key_token;
    private AssemblyHashAlgorithm hash_algorithm;
    private Byte[] hash;
    internal MetadataToken token;
    private string full_name;
    public string Name { get; public set; }
    public string Culture { get; public set; }
    public Version Version { get; public set; }
    public AssemblyAttributes Attributes { get; public set; }
    public bool HasPublicKey { get; public set; }
    public bool IsSideBySideCompatible { get; public set; }
    public bool IsRetargetable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public Byte[] PublicKey { get; public set; }
    public Byte[] PublicKeyToken { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public string FullName { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] Hash { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public AssemblyNameReference(string name, Version version);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public string get_Culture();
    public void set_Culture(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyAttributes get_Attributes();
    public void set_Attributes(AssemblyAttributes value);
    public bool get_HasPublicKey();
    public void set_HasPublicKey(bool value);
    public bool get_IsSideBySideCompatible();
    public void set_IsSideBySideCompatible(bool value);
    public bool get_IsRetargetable();
    public void set_IsRetargetable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public Byte[] get_PublicKey();
    public void set_PublicKey(Byte[] value);
    public Byte[] get_PublicKeyToken();
    public void set_PublicKeyToken(Byte[] value);
    private Byte[] HashPublicKey();
    public virtual MetadataScopeType get_MetadataScopeType();
    public string get_FullName();
    public static AssemblyNameReference Parse(string fullName);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public virtual Byte[] get_Hash();
    public virtual void set_Hash(Byte[] value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.AssemblyRefTable : MetadataTable`1<Row`9<ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.AssemblyResolutionException : FileNotFoundException {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolutionException(AssemblyNameReference reference);
    public AssemblyResolutionException(AssemblyNameReference reference, Exception innerException);
    public AssemblyNameReference get_AssemblyReference();
}
public class Mono.Cecil.AssemblyResolveEventArgs : EventArgs {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolveEventArgs(AssemblyNameReference reference);
    public AssemblyNameReference get_AssemblyReference();
}
public class Mono.Cecil.AssemblyResolveEventHandler : MulticastDelegate {
    public AssemblyResolveEventHandler(object object, IntPtr method);
    public virtual AssemblyDefinition Invoke(object sender, AssemblyNameReference reference);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyNameReference reference, AsyncCallback callback, object object);
    public virtual AssemblyDefinition EndInvoke(IAsyncResult result);
}
internal class Mono.Cecil.AssemblyTable : OneRowTable`1<Row`9<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.BaseAssemblyResolver : object {
    private static bool on_mono;
    private Collection`1<string> directories;
    internal static Lazy`1<Dictionary`2<string, string>> TrustedPlatformAssemblies;
    [CompilerGeneratedAttribute]
private AssemblyResolveEventHandler ResolveFailure;
    private static BaseAssemblyResolver();
    public void AddSearchDirectory(string directory);
    public void RemoveSearchDirectory(string directory);
    public String[] GetSearchDirectories();
    [CompilerGeneratedAttribute]
public void add_ResolveFailure(AssemblyResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ResolveFailure(AssemblyResolveEventHandler value);
    private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    private AssemblyDefinition SearchTrustedPlatformAssemblies(AssemblyNameReference name, ReaderParameters parameters);
    private static Dictionary`2<string, string> CreateTrustedPlatformAssemblyMap();
    protected virtual AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable`1<string> directories, ReaderParameters parameters);
    private static bool IsZero(Version version);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Mono.Cecil.ByReferenceType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsByReference { get; }
    public ByReferenceType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsByReference();
}
public class Mono.Cecil.CallSite : object {
    private MethodReference signature;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; }
    public MetadataToken MetadataToken { get; public set; }
    public string FullName { get; }
    public CallSite(TypeReference returnType);
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ModuleDefinition get_Module();
    public IMetadataScope get_Scope();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public string get_FullName();
    public virtual string ToString();
}
public class Mono.Cecil.Cil.AsyncMethodBodyDebugInformation : CustomDebugInformation {
    internal InstructionOffset catch_handler;
    internal Collection`1<InstructionOffset> yields;
    internal Collection`1<InstructionOffset> resumes;
    internal Collection`1<MethodDefinition> resume_methods;
    public static Guid KindIdentifier;
    public InstructionOffset CatchHandler { get; public set; }
    public Collection`1<InstructionOffset> Yields { get; }
    public Collection`1<InstructionOffset> Resumes { get; }
    public Collection`1<MethodDefinition> ResumeMethods { get; }
    public CustomDebugInformationKind Kind { get; }
    internal AsyncMethodBodyDebugInformation(int catchHandler);
    public AsyncMethodBodyDebugInformation(Instruction catchHandler);
    private static AsyncMethodBodyDebugInformation();
    public InstructionOffset get_CatchHandler();
    public void set_CatchHandler(InstructionOffset value);
    public Collection`1<InstructionOffset> get_Yields();
    public Collection`1<InstructionOffset> get_Resumes();
    public Collection`1<MethodDefinition> get_ResumeMethods();
    public virtual CustomDebugInformationKind get_Kind();
}
public class Mono.Cecil.Cil.BinaryCustomDebugInformation : CustomDebugInformation {
    private Byte[] data;
    public Byte[] Data { get; public set; }
    public CustomDebugInformationKind Kind { get; }
    public BinaryCustomDebugInformation(Guid identifier, Byte[] data);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual CustomDebugInformationKind get_Kind();
}
public enum Mono.Cecil.Cil.Code : Enum {
    public int value__;
    public static Code Nop;
    public static Code Break;
    public static Code Ldarg_0;
    public static Code Ldarg_1;
    public static Code Ldarg_2;
    public static Code Ldarg_3;
    public static Code Ldloc_0;
    public static Code Ldloc_1;
    public static Code Ldloc_2;
    public static Code Ldloc_3;
    public static Code Stloc_0;
    public static Code Stloc_1;
    public static Code Stloc_2;
    public static Code Stloc_3;
    public static Code Ldarg_S;
    public static Code Ldarga_S;
    public static Code Starg_S;
    public static Code Ldloc_S;
    public static Code Ldloca_S;
    public static Code Stloc_S;
    public static Code Ldnull;
    public static Code Ldc_I4_M1;
    public static Code Ldc_I4_0;
    public static Code Ldc_I4_1;
    public static Code Ldc_I4_2;
    public static Code Ldc_I4_3;
    public static Code Ldc_I4_4;
    public static Code Ldc_I4_5;
    public static Code Ldc_I4_6;
    public static Code Ldc_I4_7;
    public static Code Ldc_I4_8;
    public static Code Ldc_I4_S;
    public static Code Ldc_I4;
    public static Code Ldc_I8;
    public static Code Ldc_R4;
    public static Code Ldc_R8;
    public static Code Dup;
    public static Code Pop;
    public static Code Jmp;
    public static Code Call;
    public static Code Calli;
    public static Code Ret;
    public static Code Br_S;
    public static Code Brfalse_S;
    public static Code Brtrue_S;
    public static Code Beq_S;
    public static Code Bge_S;
    public static Code Bgt_S;
    public static Code Ble_S;
    public static Code Blt_S;
    public static Code Bne_Un_S;
    public static Code Bge_Un_S;
    public static Code Bgt_Un_S;
    public static Code Ble_Un_S;
    public static Code Blt_Un_S;
    public static Code Br;
    public static Code Brfalse;
    public static Code Brtrue;
    public static Code Beq;
    public static Code Bge;
    public static Code Bgt;
    public static Code Ble;
    public static Code Blt;
    public static Code Bne_Un;
    public static Code Bge_Un;
    public static Code Bgt_Un;
    public static Code Ble_Un;
    public static Code Blt_Un;
    public static Code Switch;
    public static Code Ldind_I1;
    public static Code Ldind_U1;
    public static Code Ldind_I2;
    public static Code Ldind_U2;
    public static Code Ldind_I4;
    public static Code Ldind_U4;
    public static Code Ldind_I8;
    public static Code Ldind_I;
    public static Code Ldind_R4;
    public static Code Ldind_R8;
    public static Code Ldind_Ref;
    public static Code Stind_Ref;
    public static Code Stind_I1;
    public static Code Stind_I2;
    public static Code Stind_I4;
    public static Code Stind_I8;
    public static Code Stind_R4;
    public static Code Stind_R8;
    public static Code Add;
    public static Code Sub;
    public static Code Mul;
    public static Code Div;
    public static Code Div_Un;
    public static Code Rem;
    public static Code Rem_Un;
    public static Code And;
    public static Code Or;
    public static Code Xor;
    public static Code Shl;
    public static Code Shr;
    public static Code Shr_Un;
    public static Code Neg;
    public static Code Not;
    public static Code Conv_I1;
    public static Code Conv_I2;
    public static Code Conv_I4;
    public static Code Conv_I8;
    public static Code Conv_R4;
    public static Code Conv_R8;
    public static Code Conv_U4;
    public static Code Conv_U8;
    public static Code Callvirt;
    public static Code Cpobj;
    public static Code Ldobj;
    public static Code Ldstr;
    public static Code Newobj;
    public static Code Castclass;
    public static Code Isinst;
    public static Code Conv_R_Un;
    public static Code Unbox;
    public static Code Throw;
    public static Code Ldfld;
    public static Code Ldflda;
    public static Code Stfld;
    public static Code Ldsfld;
    public static Code Ldsflda;
    public static Code Stsfld;
    public static Code Stobj;
    public static Code Conv_Ovf_I1_Un;
    public static Code Conv_Ovf_I2_Un;
    public static Code Conv_Ovf_I4_Un;
    public static Code Conv_Ovf_I8_Un;
    public static Code Conv_Ovf_U1_Un;
    public static Code Conv_Ovf_U2_Un;
    public static Code Conv_Ovf_U4_Un;
    public static Code Conv_Ovf_U8_Un;
    public static Code Conv_Ovf_I_Un;
    public static Code Conv_Ovf_U_Un;
    public static Code Box;
    public static Code Newarr;
    public static Code Ldlen;
    public static Code Ldelema;
    public static Code Ldelem_I1;
    public static Code Ldelem_U1;
    public static Code Ldelem_I2;
    public static Code Ldelem_U2;
    public static Code Ldelem_I4;
    public static Code Ldelem_U4;
    public static Code Ldelem_I8;
    public static Code Ldelem_I;
    public static Code Ldelem_R4;
    public static Code Ldelem_R8;
    public static Code Ldelem_Ref;
    public static Code Stelem_I;
    public static Code Stelem_I1;
    public static Code Stelem_I2;
    public static Code Stelem_I4;
    public static Code Stelem_I8;
    public static Code Stelem_R4;
    public static Code Stelem_R8;
    public static Code Stelem_Ref;
    public static Code Ldelem_Any;
    public static Code Stelem_Any;
    public static Code Unbox_Any;
    public static Code Conv_Ovf_I1;
    public static Code Conv_Ovf_U1;
    public static Code Conv_Ovf_I2;
    public static Code Conv_Ovf_U2;
    public static Code Conv_Ovf_I4;
    public static Code Conv_Ovf_U4;
    public static Code Conv_Ovf_I8;
    public static Code Conv_Ovf_U8;
    public static Code Refanyval;
    public static Code Ckfinite;
    public static Code Mkrefany;
    public static Code Ldtoken;
    public static Code Conv_U2;
    public static Code Conv_U1;
    public static Code Conv_I;
    public static Code Conv_Ovf_I;
    public static Code Conv_Ovf_U;
    public static Code Add_Ovf;
    public static Code Add_Ovf_Un;
    public static Code Mul_Ovf;
    public static Code Mul_Ovf_Un;
    public static Code Sub_Ovf;
    public static Code Sub_Ovf_Un;
    public static Code Endfinally;
    public static Code Leave;
    public static Code Leave_S;
    public static Code Stind_I;
    public static Code Conv_U;
    public static Code Arglist;
    public static Code Ceq;
    public static Code Cgt;
    public static Code Cgt_Un;
    public static Code Clt;
    public static Code Clt_Un;
    public static Code Ldftn;
    public static Code Ldvirtftn;
    public static Code Ldarg;
    public static Code Ldarga;
    public static Code Starg;
    public static Code Ldloc;
    public static Code Ldloca;
    public static Code Stloc;
    public static Code Localloc;
    public static Code Endfilter;
    public static Code Unaligned;
    public static Code Volatile;
    public static Code Tail;
    public static Code Initobj;
    public static Code Constrained;
    public static Code Cpblk;
    public static Code Initblk;
    public static Code No;
    public static Code Rethrow;
    public static Code Sizeof;
    public static Code Refanytype;
    public static Code Readonly;
}
internal class Mono.Cecil.Cil.CodeReader : BinaryStreamReader {
    internal MetadataReader reader;
    private int start;
    private MethodDefinition method;
    private MethodBody body;
    private int Offset { get; }
    public CodeReader(MetadataReader reader);
    private int get_Offset();
    public int MoveTo(MethodDefinition method);
    public void MoveBackTo(int position);
    public MethodBody ReadMethodBody(MethodDefinition method);
    public int ReadCodeSize(MethodDefinition method);
    private int ReadCodeSize();
    private void ReadMethodBody();
    private void ReadFatMethod();
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token);
    private void ReadCode();
    private OpCode ReadOpCode();
    private object ReadOperand(Instruction instruction);
    public string GetString(MetadataToken token);
    public ParameterDefinition GetParameter(int index);
    public VariableDefinition GetVariable(int index);
    public CallSite GetCallSite(MetadataToken token);
    private void ResolveBranches(Collection`1<Instruction> instructions);
    private Instruction GetInstruction(int offset);
    private static Instruction GetInstruction(Collection`1<Instruction> instructions, int offset);
    private void ReadSection();
    private void ReadSmallSection();
    private void ReadFatSection();
    private void ReadExceptionHandlers(int count, Func`1<int> read_entry, Func`1<int> read_length);
    private void ReadExceptionHandlerSpecific(ExceptionHandler handler);
    public MetadataToken ReadToken();
    private void ReadDebugInfo();
    private void ReadCustomDebugInformations(MethodDefinition method);
    private void ReadAsyncMethodBody(AsyncMethodBodyDebugInformation async_method);
    private void ReadStateMachineScope(StateMachineScopeDebugInformation state_machine_scope);
    private void ReadSequencePoints();
    private void ReadScopes(Collection`1<ScopeDebugInformation> scopes);
    private void ReadScope(ScopeDebugInformation scope);
    public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, Int32& code_size, MetadataToken& local_var_token);
    private void PatchRawFatMethod(ByteBuffer buffer, CodeWriter writer, Int32& code_size, MetadataToken& local_var_token);
    private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer);
    private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry);
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__26_0();
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__26_1();
}
internal class Mono.Cecil.Cil.CodeWriter : ByteBuffer {
    private UInt32 code_base;
    internal MetadataBuilder metadata;
    private Dictionary`2<UInt32, MetadataToken> standalone_signatures;
    private Dictionary`2<ByteBuffer, UInt32> tiny_method_bodies;
    private MethodBody body;
    public CodeWriter(MetadataBuilder metadata);
    public UInt32 WriteMethodBody(MethodDefinition method);
    private static bool IsEmptyMethodBody(MethodBody body);
    private static bool IsUnresolved(MethodDefinition method);
    private UInt32 WriteUnresolvedMethodBody(MethodDefinition method);
    private UInt32 WriteResolvedMethodBody(MethodDefinition method);
    private bool GetOrMapTinyMethodBody(ByteBuffer body, UInt32& rva);
    private void WriteFatHeader();
    private void WriteInstructions();
    private void WriteOpCode(OpCode opcode);
    private void WriteOperand(Instruction instruction);
    private int GetTargetOffset(Instruction instruction);
    private UInt32 GetUserStringIndex(string string);
    private static int GetVariableIndex(VariableDefinition variable);
    private int GetParameterIndex(ParameterDefinition parameter);
    private bool RequiresFatHeader();
    private void ComputeHeader();
    private void ComputeExceptionHandlerStackSize(Dictionary`2& stack_sizes);
    private static void AddExceptionStackSize(Instruction handler_start, Dictionary`2& stack_sizes);
    private static void ComputeStackSize(Instruction instruction, Dictionary`2& stack_sizes, Int32& stack_size, Int32& max_stack);
    private static void CopyBranchStackSize(Instruction instruction, Dictionary`2& stack_sizes, int stack_size);
    private static void CopyBranchStackSize(Dictionary`2& stack_sizes, Instruction target, int stack_size);
    private static void ComputeStackSize(Instruction instruction, Int32& stack_size);
    private static void ComputeStackDelta(Instruction instruction, Int32& stack_size);
    private static void ComputePopDelta(StackBehaviour pop_behavior, Int32& stack_size);
    private static void ComputePushDelta(StackBehaviour push_behaviour, Int32& stack_size);
    private void WriteExceptionHandlers();
    private static bool RequiresFatSection(Collection`1<ExceptionHandler> handlers);
    private static bool IsFatRange(Instruction start, Instruction end);
    private void WriteSmallSection(Collection`1<ExceptionHandler> handlers);
    private void WriteFatSection(Collection`1<ExceptionHandler> handlers);
    private void WriteExceptionHandlers(Collection`1<ExceptionHandler> handlers, Action`1<int> write_entry, Action`1<int> write_length);
    private void WriteExceptionHandlerSpecific(ExceptionHandler handler);
    public MetadataToken GetStandAloneSignature(Collection`1<VariableDefinition> variables);
    public MetadataToken GetStandAloneSignature(CallSite call_site);
    private MetadataToken GetStandAloneSignatureToken(UInt32 signature);
    private UInt32 BeginMethod();
    private void WriteMetadataToken(MetadataToken token);
    private void Align(int align);
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_0(int i);
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_1(int i);
}
public class Mono.Cecil.Cil.ConstantDebugInformation : DebugInformation {
    private string name;
    private TypeReference constant_type;
    private object value;
    public string Name { get; public set; }
    public TypeReference ConstantType { get; public set; }
    public object Value { get; public set; }
    public ConstantDebugInformation(string name, TypeReference constant_type, object value);
    public string get_Name();
    public void set_Name(string value);
    public TypeReference get_ConstantType();
    public void set_ConstantType(TypeReference value);
    public object get_Value();
    public void set_Value(object value);
}
public abstract class Mono.Cecil.Cil.CustomDebugInformation : DebugInformation {
    private Guid identifier;
    public Guid Identifier { get; }
    public CustomDebugInformationKind Kind { get; }
    internal CustomDebugInformation(Guid identifier);
    public Guid get_Identifier();
    public abstract virtual CustomDebugInformationKind get_Kind();
}
public enum Mono.Cecil.Cil.CustomDebugInformationKind : Enum {
    public int value__;
    public static CustomDebugInformationKind Binary;
    public static CustomDebugInformationKind StateMachineScope;
    public static CustomDebugInformationKind DynamicVariable;
    public static CustomDebugInformationKind DefaultNamespace;
    public static CustomDebugInformationKind AsyncMethodBody;
    public static CustomDebugInformationKind EmbeddedSource;
    public static CustomDebugInformationKind SourceLink;
}
public abstract class Mono.Cecil.Cil.DebugInformation : object {
    internal MetadataToken token;
    internal Collection`1<CustomDebugInformation> custom_infos;
    public MetadataToken MetadataToken { get; public set; }
    public bool HasCustomDebugInformations { get; }
    public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
}
public class Mono.Cecil.Cil.DefaultSymbolReaderProvider : object {
    private bool throw_if_no_symbol;
    public DefaultSymbolReaderProvider(bool throwIfNoSymbol);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
public class Mono.Cecil.Cil.DefaultSymbolWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
public class Mono.Cecil.Cil.Document : DebugInformation {
    private string url;
    private Guid type;
    private Guid hash_algorithm;
    private Guid language;
    private Guid language_vendor;
    private Byte[] hash;
    private Byte[] embedded_source;
    public string Url { get; public set; }
    public DocumentType Type { get; public set; }
    public Guid TypeGuid { get; public set; }
    public DocumentHashAlgorithm HashAlgorithm { get; public set; }
    public Guid HashAlgorithmGuid { get; public set; }
    public DocumentLanguage Language { get; public set; }
    public Guid LanguageGuid { get; public set; }
    public DocumentLanguageVendor LanguageVendor { get; public set; }
    public Guid LanguageVendorGuid { get; public set; }
    public Byte[] Hash { get; public set; }
    public Byte[] EmbeddedSource { get; public set; }
    public Document(string url);
    public string get_Url();
    public void set_Url(string value);
    public DocumentType get_Type();
    public void set_Type(DocumentType value);
    public Guid get_TypeGuid();
    public void set_TypeGuid(Guid value);
    public DocumentHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(DocumentHashAlgorithm value);
    public Guid get_HashAlgorithmGuid();
    public void set_HashAlgorithmGuid(Guid value);
    public DocumentLanguage get_Language();
    public void set_Language(DocumentLanguage value);
    public Guid get_LanguageGuid();
    public void set_LanguageGuid(Guid value);
    public DocumentLanguageVendor get_LanguageVendor();
    public void set_LanguageVendor(DocumentLanguageVendor value);
    public Guid get_LanguageVendorGuid();
    public void set_LanguageVendorGuid(Guid value);
    public Byte[] get_Hash();
    public void set_Hash(Byte[] value);
    public Byte[] get_EmbeddedSource();
    public void set_EmbeddedSource(Byte[] value);
}
public enum Mono.Cecil.Cil.DocumentHashAlgorithm : Enum {
    public int value__;
    public static DocumentHashAlgorithm None;
    public static DocumentHashAlgorithm MD5;
    public static DocumentHashAlgorithm SHA1;
    public static DocumentHashAlgorithm SHA256;
}
public enum Mono.Cecil.Cil.DocumentLanguage : Enum {
    public int value__;
    public static DocumentLanguage Other;
    public static DocumentLanguage C;
    public static DocumentLanguage Cpp;
    public static DocumentLanguage CSharp;
    public static DocumentLanguage Basic;
    public static DocumentLanguage Java;
    public static DocumentLanguage Cobol;
    public static DocumentLanguage Pascal;
    public static DocumentLanguage Cil;
    public static DocumentLanguage JScript;
    public static DocumentLanguage Smc;
    public static DocumentLanguage MCpp;
    public static DocumentLanguage FSharp;
}
public enum Mono.Cecil.Cil.DocumentLanguageVendor : Enum {
    public int value__;
    public static DocumentLanguageVendor Other;
    public static DocumentLanguageVendor Microsoft;
}
public enum Mono.Cecil.Cil.DocumentType : Enum {
    public int value__;
    public static DocumentType Other;
    public static DocumentType Text;
}
public class Mono.Cecil.Cil.EmbeddedPortablePdbReader : object {
    private PortablePdbReader reader;
    internal EmbeddedPortablePdbReader(PortablePdbReader reader);
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    public sealed virtual void Dispose();
}
public class Mono.Cecil.Cil.EmbeddedPortablePdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    private static Stream GetPortablePdbStream(ImageDebugHeaderEntry entry);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
public class Mono.Cecil.Cil.EmbeddedPortablePdbWriter : object {
    private Stream stream;
    private PortablePdbWriter writer;
    internal EmbeddedPortablePdbWriter(Stream stream, PortablePdbWriter writer);
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    public sealed virtual ImageDebugHeader GetDebugHeader();
    public sealed virtual void Write(MethodDebugInformation info);
    public sealed virtual void Dispose();
}
public class Mono.Cecil.Cil.EmbeddedPortablePdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
public class Mono.Cecil.Cil.EmbeddedSourceDebugInformation : CustomDebugInformation {
    internal Byte[] content;
    internal bool compress;
    public static Guid KindIdentifier;
    public Byte[] Content { get; public set; }
    public bool Compress { get; public set; }
    public CustomDebugInformationKind Kind { get; }
    public EmbeddedSourceDebugInformation(Byte[] content, bool compress);
    private static EmbeddedSourceDebugInformation();
    public Byte[] get_Content();
    public void set_Content(Byte[] value);
    public bool get_Compress();
    public void set_Compress(bool value);
    public virtual CustomDebugInformationKind get_Kind();
}
public class Mono.Cecil.Cil.ExceptionHandler : object {
    private Instruction try_start;
    private Instruction try_end;
    private Instruction filter_start;
    private Instruction handler_start;
    private Instruction handler_end;
    private TypeReference catch_type;
    private ExceptionHandlerType handler_type;
    public Instruction TryStart { get; public set; }
    public Instruction TryEnd { get; public set; }
    public Instruction FilterStart { get; public set; }
    public Instruction HandlerStart { get; public set; }
    public Instruction HandlerEnd { get; public set; }
    public TypeReference CatchType { get; public set; }
    public ExceptionHandlerType HandlerType { get; public set; }
    public ExceptionHandler(ExceptionHandlerType handlerType);
    public Instruction get_TryStart();
    public void set_TryStart(Instruction value);
    public Instruction get_TryEnd();
    public void set_TryEnd(Instruction value);
    public Instruction get_FilterStart();
    public void set_FilterStart(Instruction value);
    public Instruction get_HandlerStart();
    public void set_HandlerStart(Instruction value);
    public Instruction get_HandlerEnd();
    public void set_HandlerEnd(Instruction value);
    public TypeReference get_CatchType();
    public void set_CatchType(TypeReference value);
    public ExceptionHandlerType get_HandlerType();
    public void set_HandlerType(ExceptionHandlerType value);
}
public enum Mono.Cecil.Cil.ExceptionHandlerType : Enum {
    public int value__;
    public static ExceptionHandlerType Catch;
    public static ExceptionHandlerType Filter;
    public static ExceptionHandlerType Finally;
    public static ExceptionHandlerType Fault;
}
public enum Mono.Cecil.Cil.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
public interface Mono.Cecil.Cil.ICustomDebugInformationProvider {
    public bool HasCustomDebugInformations { get; }
    public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    public abstract virtual bool get_HasCustomDebugInformations();
    public abstract virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
}
public class Mono.Cecil.Cil.ILProcessor : object {
    private MethodBody body;
    private Collection`1<Instruction> instructions;
    public MethodBody Body { get; }
    internal ILProcessor(MethodBody body);
    public MethodBody get_Body();
    public Instruction Create(OpCode opcode);
    public Instruction Create(OpCode opcode, TypeReference type);
    public Instruction Create(OpCode opcode, CallSite site);
    public Instruction Create(OpCode opcode, MethodReference method);
    public Instruction Create(OpCode opcode, FieldReference field);
    public Instruction Create(OpCode opcode, string value);
    public Instruction Create(OpCode opcode, sbyte value);
    public Instruction Create(OpCode opcode, byte value);
    public Instruction Create(OpCode opcode, int value);
    public Instruction Create(OpCode opcode, long value);
    public Instruction Create(OpCode opcode, float value);
    public Instruction Create(OpCode opcode, double value);
    public Instruction Create(OpCode opcode, Instruction target);
    public Instruction Create(OpCode opcode, Instruction[] targets);
    public Instruction Create(OpCode opcode, VariableDefinition variable);
    public Instruction Create(OpCode opcode, ParameterDefinition parameter);
    public void Emit(OpCode opcode);
    public void Emit(OpCode opcode, TypeReference type);
    public void Emit(OpCode opcode, MethodReference method);
    public void Emit(OpCode opcode, CallSite site);
    public void Emit(OpCode opcode, FieldReference field);
    public void Emit(OpCode opcode, string value);
    public void Emit(OpCode opcode, byte value);
    public void Emit(OpCode opcode, sbyte value);
    public void Emit(OpCode opcode, int value);
    public void Emit(OpCode opcode, long value);
    public void Emit(OpCode opcode, float value);
    public void Emit(OpCode opcode, double value);
    public void Emit(OpCode opcode, Instruction target);
    public void Emit(OpCode opcode, Instruction[] targets);
    public void Emit(OpCode opcode, VariableDefinition variable);
    public void Emit(OpCode opcode, ParameterDefinition parameter);
    public void InsertBefore(Instruction target, Instruction instruction);
    public void InsertAfter(Instruction target, Instruction instruction);
    public void InsertAfter(int index, Instruction instruction);
    public void Append(Instruction instruction);
    public void Replace(Instruction target, Instruction instruction);
    public void Replace(int index, Instruction instruction);
    public void Remove(Instruction instruction);
    public void RemoveAt(int index);
    public void Clear();
}
public class Mono.Cecil.Cil.ImageDebugDirectory : ValueType {
    public static int Size;
    public int Characteristics;
    public int TimeDateStamp;
    public short MajorVersion;
    public short MinorVersion;
    public ImageDebugType Type;
    public int SizeOfData;
    public int AddressOfRawData;
    public int PointerToRawData;
}
public class Mono.Cecil.Cil.ImageDebugHeader : object {
    private ImageDebugHeaderEntry[] entries;
    public bool HasEntries { get; }
    public ImageDebugHeaderEntry[] Entries { get; }
    public ImageDebugHeader(ImageDebugHeaderEntry[] entries);
    public ImageDebugHeader(ImageDebugHeaderEntry entry);
    public bool get_HasEntries();
    public ImageDebugHeaderEntry[] get_Entries();
}
public class Mono.Cecil.Cil.ImageDebugHeaderEntry : object {
    private ImageDebugDirectory directory;
    private Byte[] data;
    public ImageDebugDirectory Directory { get; internal set; }
    public Byte[] Data { get; }
    public ImageDebugHeaderEntry(ImageDebugDirectory directory, Byte[] data);
    public ImageDebugDirectory get_Directory();
    internal void set_Directory(ImageDebugDirectory value);
    public Byte[] get_Data();
}
public enum Mono.Cecil.Cil.ImageDebugType : Enum {
    public int value__;
    public static ImageDebugType CodeView;
    public static ImageDebugType Deterministic;
    public static ImageDebugType EmbeddedPortablePdb;
}
public class Mono.Cecil.Cil.ImportDebugInformation : DebugInformation {
    internal ImportDebugInformation parent;
    internal Collection`1<ImportTarget> targets;
    public bool HasTargets { get; }
    public Collection`1<ImportTarget> Targets { get; }
    public ImportDebugInformation Parent { get; public set; }
    public bool get_HasTargets();
    public Collection`1<ImportTarget> get_Targets();
    public ImportDebugInformation get_Parent();
    public void set_Parent(ImportDebugInformation value);
}
public class Mono.Cecil.Cil.ImportTarget : object {
    internal ImportTargetKind kind;
    internal string namespace;
    internal TypeReference type;
    internal AssemblyNameReference reference;
    internal string alias;
    public string Namespace { get; public set; }
    public TypeReference Type { get; public set; }
    public AssemblyNameReference AssemblyReference { get; public set; }
    public string Alias { get; public set; }
    public ImportTargetKind Kind { get; public set; }
    public ImportTarget(ImportTargetKind kind);
    public string get_Namespace();
    public void set_Namespace(string value);
    public TypeReference get_Type();
    public void set_Type(TypeReference value);
    public AssemblyNameReference get_AssemblyReference();
    public void set_AssemblyReference(AssemblyNameReference value);
    public string get_Alias();
    public void set_Alias(string value);
    public ImportTargetKind get_Kind();
    public void set_Kind(ImportTargetKind value);
}
public enum Mono.Cecil.Cil.ImportTargetKind : Enum {
    public byte value__;
    public static ImportTargetKind ImportNamespace;
    public static ImportTargetKind ImportNamespaceInAssembly;
    public static ImportTargetKind ImportType;
    public static ImportTargetKind ImportXmlNamespaceWithAlias;
    public static ImportTargetKind ImportAlias;
    public static ImportTargetKind DefineAssemblyAlias;
    public static ImportTargetKind DefineNamespaceAlias;
    public static ImportTargetKind DefineNamespaceInAssemblyAlias;
    public static ImportTargetKind DefineTypeAlias;
}
public class Mono.Cecil.Cil.Instruction : object {
    internal int offset;
    internal OpCode opcode;
    internal object operand;
    internal Instruction previous;
    internal Instruction next;
    public int Offset { get; public set; }
    public OpCode OpCode { get; public set; }
    public object Operand { get; public set; }
    public Instruction Previous { get; public set; }
    public Instruction Next { get; public set; }
    internal Instruction(int offset, OpCode opCode);
    internal Instruction(OpCode opcode, object operand);
    public int get_Offset();
    public void set_Offset(int value);
    public OpCode get_OpCode();
    public void set_OpCode(OpCode value);
    public object get_Operand();
    public void set_Operand(object value);
    public Instruction get_Previous();
    public void set_Previous(Instruction value);
    public Instruction get_Next();
    public void set_Next(Instruction value);
    public int GetSize();
    public virtual string ToString();
    private static void AppendLabel(StringBuilder builder, Instruction instruction);
    public static Instruction Create(OpCode opcode);
    public static Instruction Create(OpCode opcode, TypeReference type);
    public static Instruction Create(OpCode opcode, CallSite site);
    public static Instruction Create(OpCode opcode, MethodReference method);
    public static Instruction Create(OpCode opcode, FieldReference field);
    public static Instruction Create(OpCode opcode, string value);
    public static Instruction Create(OpCode opcode, sbyte value);
    public static Instruction Create(OpCode opcode, byte value);
    public static Instruction Create(OpCode opcode, int value);
    public static Instruction Create(OpCode opcode, long value);
    public static Instruction Create(OpCode opcode, float value);
    public static Instruction Create(OpCode opcode, double value);
    public static Instruction Create(OpCode opcode, Instruction target);
    public static Instruction Create(OpCode opcode, Instruction[] targets);
    public static Instruction Create(OpCode opcode, VariableDefinition variable);
    public static Instruction Create(OpCode opcode, ParameterDefinition parameter);
}
internal class Mono.Cecil.Cil.InstructionCollection : Collection`1<Instruction> {
    private MethodDefinition method;
    internal InstructionCollection(MethodDefinition method);
    internal InstructionCollection(MethodDefinition method, int capacity);
    protected virtual void OnAdd(Instruction item, int index);
    protected virtual void OnInsert(Instruction item, int index);
    protected virtual void OnSet(Instruction item, int index);
    protected virtual void OnRemove(Instruction item, int index);
    private void RemoveSequencePoint(Instruction instruction);
    private void UpdateLocalScopes(Instruction removedInstruction, Instruction existingInstruction);
    private void UpdateLocalScope(ScopeDebugInformation scope, Instruction removedInstruction, Instruction existingInstruction, InstructionOffsetCache& cache);
    private InstructionOffset ResolveInstructionOffset(InstructionOffset inputOffset, InstructionOffsetCache& cache);
}
public class Mono.Cecil.Cil.InstructionOffset : ValueType {
    private Instruction instruction;
    private Nullable`1<int> offset;
    public int Offset { get; }
    public bool IsEndOfMethod { get; }
    internal bool IsResolved { get; }
    internal Instruction ResolvedInstruction { get; }
    public InstructionOffset(Instruction instruction);
    public InstructionOffset(int offset);
    public int get_Offset();
    public bool get_IsEndOfMethod();
    internal bool get_IsResolved();
    internal Instruction get_ResolvedInstruction();
}
public interface Mono.Cecil.Cil.ISymbolReader {
    public abstract virtual ISymbolWriterProvider GetWriterProvider();
    public abstract virtual bool ProcessDebugHeader(ImageDebugHeader header);
    public abstract virtual MethodDebugInformation Read(MethodDefinition method);
}
public interface Mono.Cecil.Cil.ISymbolReaderProvider {
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
public interface Mono.Cecil.Cil.ISymbolWriter {
    public abstract virtual ISymbolReaderProvider GetReaderProvider();
    public abstract virtual ImageDebugHeader GetDebugHeader();
    public abstract virtual void Write(MethodDebugInformation info);
}
public interface Mono.Cecil.Cil.ISymbolWriterProvider {
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
public class Mono.Cecil.Cil.MethodBody : object {
    internal MethodDefinition method;
    internal ParameterDefinition this_parameter;
    internal int max_stack_size;
    internal int code_size;
    internal bool init_locals;
    internal MetadataToken local_var_token;
    internal Collection`1<Instruction> instructions;
    internal Collection`1<ExceptionHandler> exceptions;
    internal Collection`1<VariableDefinition> variables;
    public MethodDefinition Method { get; }
    public int MaxStackSize { get; public set; }
    public int CodeSize { get; }
    public bool InitLocals { get; public set; }
    public MetadataToken LocalVarToken { get; public set; }
    public Collection`1<Instruction> Instructions { get; }
    public bool HasExceptionHandlers { get; }
    public Collection`1<ExceptionHandler> ExceptionHandlers { get; }
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public ParameterDefinition ThisParameter { get; }
    public MethodBody(MethodDefinition method);
    public MethodDefinition get_Method();
    public int get_MaxStackSize();
    public void set_MaxStackSize(int value);
    public int get_CodeSize();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public MetadataToken get_LocalVarToken();
    public void set_LocalVarToken(MetadataToken value);
    public Collection`1<Instruction> get_Instructions();
    public bool get_HasExceptionHandlers();
    public Collection`1<ExceptionHandler> get_ExceptionHandlers();
    public bool get_HasVariables();
    public Collection`1<VariableDefinition> get_Variables();
    public ParameterDefinition get_ThisParameter();
    private static ParameterDefinition CreateThisParameter(MethodDefinition method);
    public ILProcessor GetILProcessor();
}
public class Mono.Cecil.Cil.MethodDebugInformation : DebugInformation {
    internal MethodDefinition method;
    internal Collection`1<SequencePoint> sequence_points;
    internal ScopeDebugInformation scope;
    internal MethodDefinition kickoff_method;
    internal int code_size;
    internal MetadataToken local_var_token;
    public MethodDefinition Method { get; }
    public bool HasSequencePoints { get; }
    public Collection`1<SequencePoint> SequencePoints { get; }
    public ScopeDebugInformation Scope { get; public set; }
    public MethodDefinition StateMachineKickOffMethod { get; public set; }
    internal MethodDebugInformation(MethodDefinition method);
    public MethodDefinition get_Method();
    public bool get_HasSequencePoints();
    public Collection`1<SequencePoint> get_SequencePoints();
    public ScopeDebugInformation get_Scope();
    public void set_Scope(ScopeDebugInformation value);
    public MethodDefinition get_StateMachineKickOffMethod();
    public void set_StateMachineKickOffMethod(MethodDefinition value);
    public SequencePoint GetSequencePoint(Instruction instruction);
    public IDictionary`2<Instruction, SequencePoint> GetSequencePointMapping();
    public IEnumerable`1<ScopeDebugInformation> GetScopes();
    [IteratorStateMachineAttribute("Mono.Cecil.Cil.MethodDebugInformation/<GetScopes>d__22")]
private static IEnumerable`1<ScopeDebugInformation> GetScopes(IList`1<ScopeDebugInformation> scopes);
    public bool TryGetName(VariableDefinition variable, String& name);
}
public class Mono.Cecil.Cil.OpCode : ValueType {
    private byte op1;
    private byte op2;
    private byte code;
    private byte flow_control;
    private byte opcode_type;
    private byte operand_type;
    private byte stack_behavior_pop;
    private byte stack_behavior_push;
    public string Name { get; }
    public int Size { get; }
    public byte Op1 { get; }
    public byte Op2 { get; }
    public short Value { get; }
    public Code Code { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public OperandType OperandType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    internal OpCode(int x, int y);
    public string get_Name();
    public int get_Size();
    public byte get_Op1();
    public byte get_Op2();
    public short get_Value();
    public Code get_Code();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public OperandType get_OperandType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCode opcode);
    public static bool op_Equality(OpCode one, OpCode other);
    public static bool op_Inequality(OpCode one, OpCode other);
    public virtual string ToString();
}
internal static class Mono.Cecil.Cil.OpCodeNames : object {
    internal static String[] names;
    private static OpCodeNames();
}
public static class Mono.Cecil.Cil.OpCodes : object {
    internal static OpCode[] OneByteOpCode;
    internal static OpCode[] TwoBytesOpCode;
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem_Any;
    public static OpCode Stelem_Any;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tail;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode No;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
}
public enum Mono.Cecil.Cil.OpCodeType : Enum {
    public int value__;
    public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
public enum Mono.Cecil.Cil.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType InlineArg;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
    public static OperandType ShortInlineArg;
}
[ExtensionAttribute]
internal static class Mono.Cecil.Cil.PdbGuidMapping : object {
    private static Dictionary`2<Guid, DocumentLanguage> guid_language;
    private static Dictionary`2<DocumentLanguage, Guid> language_guid;
    private static Guid type_text;
    private static Guid hash_md5;
    private static Guid hash_sha1;
    private static Guid hash_sha256;
    private static Guid vendor_ms;
    private static PdbGuidMapping();
    private static void AddMapping(DocumentLanguage language, Guid guid);
    [ExtensionAttribute]
public static DocumentType ToType(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentType type);
    [ExtensionAttribute]
public static DocumentHashAlgorithm ToHashAlgorithm(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentHashAlgorithm hash_algo);
    [ExtensionAttribute]
public static DocumentLanguage ToLanguage(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentLanguage language);
    [ExtensionAttribute]
public static DocumentLanguageVendor ToVendor(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentLanguageVendor vendor);
}
public class Mono.Cecil.Cil.PortablePdbReader : object {
    private Image image;
    private ModuleDefinition module;
    private MetadataReader reader;
    private MetadataReader debug_reader;
    private bool IsEmbedded { get; }
    internal PortablePdbReader(Image image, ModuleDefinition module);
    private bool get_IsEmbedded();
    public sealed virtual ISymbolWriterProvider GetWriterProvider();
    public sealed virtual bool ProcessDebugHeader(ImageDebugHeader header);
    private static int ReadInt32(Byte[] bytes, int start);
    private void ReadModule();
    public sealed virtual MethodDebugInformation Read(MethodDefinition method);
    private void ReadSequencePoints(MethodDebugInformation method_info);
    private void ReadScope(MethodDebugInformation method_info);
    private void ReadStateMachineKickOffMethod(MethodDebugInformation method_info);
    private void ReadCustomDebugInformations(MethodDebugInformation info);
    public sealed virtual void Dispose();
}
public class Mono.Cecil.Cil.PortablePdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
    private ISymbolReader GetSymbolReader(ModuleDefinition module, Disposable`1<Stream> symbolStream, string fileName);
}
public class Mono.Cecil.Cil.PortablePdbWriter : object {
    private MetadataBuilder pdb_metadata;
    private ModuleDefinition module;
    private ImageWriter writer;
    private MetadataBuilder module_metadata;
    private bool IsEmbedded { get; }
    internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module);
    internal PortablePdbWriter(MetadataBuilder pdb_metadata, ModuleDefinition module, ImageWriter writer);
    private bool get_IsEmbedded();
    public sealed virtual ISymbolReaderProvider GetReaderProvider();
    public sealed virtual ImageDebugHeader GetDebugHeader();
    public sealed virtual void Write(MethodDebugInformation info);
    private void CheckMethodDebugInformationTable();
    public sealed virtual void Dispose();
    private void WritePdbFile();
    private void WritePdbHeap();
    private void WriteTableHeap();
}
public class Mono.Cecil.Cil.PortablePdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
    private ISymbolWriter GetSymbolWriter(ModuleDefinition module, Disposable`1<Stream> stream);
}
public class Mono.Cecil.Cil.ScopeDebugInformation : DebugInformation {
    internal InstructionOffset start;
    internal InstructionOffset end;
    internal ImportDebugInformation import;
    internal Collection`1<ScopeDebugInformation> scopes;
    internal Collection`1<VariableDebugInformation> variables;
    internal Collection`1<ConstantDebugInformation> constants;
    public InstructionOffset Start { get; public set; }
    public InstructionOffset End { get; public set; }
    public ImportDebugInformation Import { get; public set; }
    public bool HasScopes { get; }
    public Collection`1<ScopeDebugInformation> Scopes { get; }
    public bool HasVariables { get; }
    public Collection`1<VariableDebugInformation> Variables { get; }
    public bool HasConstants { get; }
    public Collection`1<ConstantDebugInformation> Constants { get; }
    public ScopeDebugInformation(Instruction start, Instruction end);
    public InstructionOffset get_Start();
    public void set_Start(InstructionOffset value);
    public InstructionOffset get_End();
    public void set_End(InstructionOffset value);
    public ImportDebugInformation get_Import();
    public void set_Import(ImportDebugInformation value);
    public bool get_HasScopes();
    public Collection`1<ScopeDebugInformation> get_Scopes();
    public bool get_HasVariables();
    public Collection`1<VariableDebugInformation> get_Variables();
    public bool get_HasConstants();
    public Collection`1<ConstantDebugInformation> get_Constants();
    public bool TryGetName(VariableDefinition variable, String& name);
}
public class Mono.Cecil.Cil.SequencePoint : object {
    internal InstructionOffset offset;
    private Document document;
    private int start_line;
    private int start_column;
    private int end_line;
    private int end_column;
    public int Offset { get; }
    public int StartLine { get; public set; }
    public int StartColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public bool IsHidden { get; }
    public Document Document { get; public set; }
    internal SequencePoint(int offset, Document document);
    public SequencePoint(Instruction instruction, Document document);
    public int get_Offset();
    public int get_StartLine();
    public void set_StartLine(int value);
    public int get_StartColumn();
    public void set_StartColumn(int value);
    public int get_EndLine();
    public void set_EndLine(int value);
    public int get_EndColumn();
    public void set_EndColumn(int value);
    public bool get_IsHidden();
    public Document get_Document();
    public void set_Document(Document value);
}
public class Mono.Cecil.Cil.SourceLinkDebugInformation : CustomDebugInformation {
    internal string content;
    public static Guid KindIdentifier;
    public string Content { get; public set; }
    public CustomDebugInformationKind Kind { get; }
    public SourceLinkDebugInformation(string content);
    private static SourceLinkDebugInformation();
    public string get_Content();
    public void set_Content(string value);
    public virtual CustomDebugInformationKind get_Kind();
}
public enum Mono.Cecil.Cil.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour PopAll;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
}
public class Mono.Cecil.Cil.StateMachineScope : object {
    internal InstructionOffset start;
    internal InstructionOffset end;
    public InstructionOffset Start { get; public set; }
    public InstructionOffset End { get; public set; }
    internal StateMachineScope(int start, int end);
    public StateMachineScope(Instruction start, Instruction end);
    public InstructionOffset get_Start();
    public void set_Start(InstructionOffset value);
    public InstructionOffset get_End();
    public void set_End(InstructionOffset value);
}
public class Mono.Cecil.Cil.StateMachineScopeDebugInformation : CustomDebugInformation {
    internal Collection`1<StateMachineScope> scopes;
    public static Guid KindIdentifier;
    public Collection`1<StateMachineScope> Scopes { get; }
    public CustomDebugInformationKind Kind { get; }
    private static StateMachineScopeDebugInformation();
    public Collection`1<StateMachineScope> get_Scopes();
    public virtual CustomDebugInformationKind get_Kind();
}
internal enum Mono.Cecil.Cil.SymbolKind : Enum {
    public int value__;
    public static SymbolKind NativePdb;
    public static SymbolKind PortablePdb;
    public static SymbolKind EmbeddedPortablePdb;
    public static SymbolKind Mdb;
}
internal static class Mono.Cecil.Cil.SymbolProvider : object {
    private static AssemblyName GetSymbolAssemblyName(SymbolKind kind);
    private static Type GetSymbolType(SymbolKind kind, string fullname);
    public static ISymbolReaderProvider GetReaderProvider(SymbolKind kind);
    private static string GetSymbolTypeName(SymbolKind kind, string name);
    private static string GetSymbolNamespace(SymbolKind kind);
}
public class Mono.Cecil.Cil.SymbolsNotFoundException : FileNotFoundException {
    public SymbolsNotFoundException(string message);
}
public class Mono.Cecil.Cil.SymbolsNotMatchingException : InvalidOperationException {
    public SymbolsNotMatchingException(string message);
}
[FlagsAttribute]
public enum Mono.Cecil.Cil.VariableAttributes : Enum {
    public ushort value__;
    public static VariableAttributes None;
    public static VariableAttributes DebuggerHidden;
}
public class Mono.Cecil.Cil.VariableDebugInformation : DebugInformation {
    private string name;
    private ushort attributes;
    internal VariableIndex index;
    public int Index { get; }
    public string Name { get; public set; }
    public VariableAttributes Attributes { get; public set; }
    public bool IsDebuggerHidden { get; public set; }
    internal VariableDebugInformation(int index, string name);
    public VariableDebugInformation(VariableDefinition variable, string name);
    public int get_Index();
    public string get_Name();
    public void set_Name(string value);
    public VariableAttributes get_Attributes();
    public void set_Attributes(VariableAttributes value);
    public bool get_IsDebuggerHidden();
    public void set_IsDebuggerHidden(bool value);
}
public class Mono.Cecil.Cil.VariableDefinition : VariableReference {
    public bool IsPinned { get; }
    public VariableDefinition(TypeReference variableType);
    public bool get_IsPinned();
    public virtual VariableDefinition Resolve();
}
internal class Mono.Cecil.Cil.VariableDefinitionCollection : Collection`1<VariableDefinition> {
    private MethodDefinition method;
    internal VariableDefinitionCollection(MethodDefinition method);
    internal VariableDefinitionCollection(MethodDefinition method, int capacity);
    protected virtual void OnAdd(VariableDefinition item, int index);
    protected virtual void OnInsert(VariableDefinition item, int index);
    protected virtual void OnSet(VariableDefinition item, int index);
    protected virtual void OnRemove(VariableDefinition item, int index);
    private void UpdateVariableIndices(int startIndex, int offset, VariableDefinition variableToRemove);
}
public class Mono.Cecil.Cil.VariableIndex : ValueType {
    private VariableDefinition variable;
    private Nullable`1<int> index;
    public int Index { get; }
    internal bool IsResolved { get; }
    internal VariableDefinition ResolvedVariable { get; }
    public VariableIndex(VariableDefinition variable);
    public VariableIndex(int index);
    public int get_Index();
    internal bool get_IsResolved();
    internal VariableDefinition get_ResolvedVariable();
}
public abstract class Mono.Cecil.Cil.VariableReference : object {
    internal int index;
    protected TypeReference variable_type;
    public TypeReference VariableType { get; public set; }
    public int Index { get; }
    internal VariableReference(TypeReference variable_type);
    public TypeReference get_VariableType();
    public void set_VariableType(TypeReference value);
    public int get_Index();
    public abstract virtual VariableDefinition Resolve();
    public virtual string ToString();
}
internal class Mono.Cecil.ClassLayoutTable : SortedTable`1<Row`3<ushort, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ushort, UInt32, UInt32> x, Row`3<ushort, UInt32, UInt32> y);
}
internal class Mono.Cecil.ConstantTable : SortedTable`1<Row`3<ElementType, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ElementType, UInt32, UInt32> x, Row`3<ElementType, UInt32, UInt32> y);
}
internal static class Mono.Cecil.CryptoService : object {
    public static Byte[] GetPublicKey(WriterParameters parameters);
    public static void StrongName(Stream stream, ImageWriter writer, WriterParameters parameters);
    private static void PatchStrongName(Stream stream, int strong_name_pointer, Byte[] strong_name);
    private static Byte[] CreateStrongName(WriterParameters parameters, Byte[] hash);
    private static Byte[] HashStream(Stream stream, ImageWriter writer, Int32& strong_name_pointer);
    private static void CopyStreamChunk(Stream stream, Stream dest_stream, Byte[] buffer, int length);
    public static Byte[] ComputeHash(string file);
    public static Byte[] ComputeHash(Stream stream);
    public static Byte[] ComputeHash(ByteBuffer[] buffers);
    public static Guid ComputeGuid(Byte[] hash);
}
[DebuggerDisplayAttribute("{AttributeType}")]
public class Mono.Cecil.CustomAttribute : object {
    internal CustomAttributeValueProjection projection;
    internal UInt32 signature;
    internal bool resolved;
    private MethodReference constructor;
    private Byte[] blob;
    internal Collection`1<CustomAttributeArgument> arguments;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public MethodReference Constructor { get; public set; }
    public TypeReference AttributeType { get; }
    public bool IsResolved { get; }
    public bool HasConstructorArguments { get; }
    public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    internal bool HasImage { get; }
    internal ModuleDefinition Module { get; }
    internal CustomAttribute(UInt32 signature, MethodReference constructor);
    public CustomAttribute(MethodReference constructor);
    public CustomAttribute(MethodReference constructor, Byte[] blob);
    public MethodReference get_Constructor();
    public void set_Constructor(MethodReference value);
    public sealed virtual TypeReference get_AttributeType();
    public bool get_IsResolved();
    public sealed virtual bool get_HasConstructorArguments();
    public sealed virtual Collection`1<CustomAttributeArgument> get_ConstructorArguments();
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    internal bool get_HasImage();
    internal ModuleDefinition get_Module();
    public Byte[] GetBlob();
    private void Resolve();
    [CompilerGeneratedAttribute]
private void <Resolve>b__35_0(CustomAttribute attribute, MetadataReader reader);
}
public class Mono.Cecil.CustomAttributeArgument : ValueType {
    private TypeReference type;
    private object value;
    public TypeReference Type { get; }
    public object Value { get; }
    public CustomAttributeArgument(TypeReference type, object value);
    public TypeReference get_Type();
    public object get_Value();
}
public class Mono.Cecil.CustomAttributeNamedArgument : ValueType {
    private string name;
    private CustomAttributeArgument argument;
    public string Name { get; }
    public CustomAttributeArgument Argument { get; }
    public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument);
    public string get_Name();
    public CustomAttributeArgument get_Argument();
}
internal class Mono.Cecil.CustomAttributeTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.CustomAttributeValueProjection : object {
    public AttributeTargets Targets;
    public CustomAttributeValueTreatment Treatment;
    public CustomAttributeValueProjection(AttributeTargets targets, CustomAttributeValueTreatment treatment);
}
internal enum Mono.Cecil.CustomAttributeValueTreatment : Enum {
    public int value__;
    public static CustomAttributeValueTreatment None;
    public static CustomAttributeValueTreatment AllowSingle;
    public static CustomAttributeValueTreatment AllowMultiple;
    public static CustomAttributeValueTreatment VersionAttribute;
    public static CustomAttributeValueTreatment DeprecatedAttribute;
}
internal class Mono.Cecil.CustomDebugInformationTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
}
public class Mono.Cecil.CustomMarshalInfo : MarshalInfo {
    internal Guid guid;
    internal string unmanaged_type;
    internal TypeReference managed_type;
    internal string cookie;
    public Guid Guid { get; public set; }
    public string UnmanagedType { get; public set; }
    public TypeReference ManagedType { get; public set; }
    public string Cookie { get; public set; }
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_UnmanagedType();
    public void set_UnmanagedType(string value);
    public TypeReference get_ManagedType();
    public void set_ManagedType(TypeReference value);
    public string get_Cookie();
    public void set_Cookie(string value);
}
internal class Mono.Cecil.DeclSecurityTable : SortedTable`1<Row`3<SecurityAction, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<SecurityAction, UInt32, UInt32> x, Row`3<SecurityAction, UInt32, UInt32> y);
}
public class Mono.Cecil.DefaultAssemblyResolver : BaseAssemblyResolver {
    private IDictionary`2<string, AssemblyDefinition> cache;
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    protected void RegisterAssembly(AssemblyDefinition assembly);
    protected virtual void Dispose(bool disposing);
}
public class Mono.Cecil.DefaultMetadataImporter : object {
    protected ModuleDefinition module;
    public DefaultMetadataImporter(ModuleDefinition module);
    private TypeReference ImportType(TypeReference type, ImportGenericContext context);
    protected virtual IMetadataScope ImportScope(TypeReference type);
    protected IMetadataScope ImportScope(IMetadataScope scope);
    public virtual AssemblyNameReference ImportReference(AssemblyNameReference name);
    private static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original);
    private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context);
    private FieldReference ImportField(FieldReference field, ImportGenericContext context);
    private MethodReference ImportMethod(MethodReference method, ImportGenericContext context);
    private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context);
    public virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    public virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    public virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}
public class Mono.Cecil.DefaultReflectionImporter : object {
    protected ModuleDefinition module;
    private static Dictionary`2<Type, ElementType> type_etype_mapping;
    public DefaultReflectionImporter(ModuleDefinition module);
    private static DefaultReflectionImporter();
    private TypeReference ImportType(Type type, ImportGenericContext context);
    private TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind);
    protected virtual IMetadataScope ImportScope(Type type);
    private static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind);
    private static bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind);
    private static bool IsNestedType(Type type);
    private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context);
    private static TypeReference ImportGenericParameter(Type type, ImportGenericContext context);
    private static string NormalizeMethodName(MethodBase method);
    private static string NormalizeTypeFullName(Type type);
    private TypeReference ImportGenericInstance(Type type, ImportGenericContext context);
    private static bool IsTypeSpecification(Type type);
    private static bool IsGenericInstance(Type type);
    private static ElementType ImportElementType(Type type);
    protected AssemblyNameReference ImportScope(Assembly assembly);
    public virtual AssemblyNameReference ImportReference(AssemblyName name);
    private bool TryGetAssemblyNameReference(AssemblyName name, AssemblyNameReference& assembly_reference);
    private FieldReference ImportField(FieldInfo field, ImportGenericContext context);
    private static FieldInfo ResolveFieldDefinition(FieldInfo field);
    private static MethodBase ResolveMethodDefinition(MethodBase method);
    private MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind);
    private static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments);
    private static bool IsMethodSpecification(MethodBase method);
    private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context);
    private static bool HasCallingConvention(MethodBase method, CallingConventions conventions);
    public virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    public virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}
internal class Mono.Cecil.DeferredModuleReader : ModuleReader {
    public DeferredModuleReader(Image image);
    protected virtual void ReadModule();
    public virtual void ReadSymbols(ModuleDefinition module);
    [CompilerGeneratedAttribute]
private void <ReadModule>b__1_0(ModuleDefinition _, MetadataReader reader);
}
internal class Mono.Cecil.DocumentTable : MetadataTable`1<Row`4<UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.EmbeddedResource : Resource {
    private MetadataReader reader;
    private Nullable`1<UInt32> offset;
    private Byte[] data;
    private Stream stream;
    public ResourceType ResourceType { get; }
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Byte[] data);
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream);
    internal EmbeddedResource(string name, ManifestResourceAttributes attributes, UInt32 offset, MetadataReader reader);
    public virtual ResourceType get_ResourceType();
    public Stream GetResourceStream();
    public Byte[] GetResourceData();
    private static Byte[] ReadStream(Stream stream);
}
[FlagsAttribute]
public enum Mono.Cecil.EventAttributes : Enum {
    public ushort value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
}
public class Mono.Cecil.EventDefinition : EventReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition add_method;
    internal MethodDefinition invoke_method;
    internal MethodDefinition remove_method;
    internal Collection`1<MethodDefinition> other_methods;
    public EventAttributes Attributes { get; public set; }
    public MethodDefinition AddMethod { get; public set; }
    public MethodDefinition InvokeMethod { get; public set; }
    public MethodDefinition RemoveMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public EventDefinition(string name, EventAttributes attributes, TypeReference eventType);
    public EventAttributes get_Attributes();
    public void set_Attributes(EventAttributes value);
    public MethodDefinition get_AddMethod();
    public void set_AddMethod(MethodDefinition value);
    public MethodDefinition get_InvokeMethod();
    public void set_InvokeMethod(MethodDefinition value);
    public MethodDefinition get_RemoveMethod();
    public void set_RemoveMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    private void InitializeMethods();
    public virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.EventReference : MemberReference {
    private TypeReference event_type;
    public TypeReference EventType { get; public set; }
    public string FullName { get; }
    protected EventReference(string name, TypeReference eventType);
    public TypeReference get_EventType();
    public void set_EventType(TypeReference value);
    public virtual string get_FullName();
    protected virtual IMemberDefinition ResolveDefinition();
    public abstract virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventTable : MetadataTable`1<Row`3<EventAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.ExportedType : object {
    private string namespace;
    private string name;
    private UInt32 attributes;
    private IMetadataScope scope;
    private ModuleDefinition module;
    private int identifier;
    private ExportedType declaring_type;
    internal MetadataToken token;
    public string Namespace { get; public set; }
    public string Name { get; public set; }
    public TypeAttributes Attributes { get; public set; }
    public IMetadataScope Scope { get; public set; }
    public ExportedType DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public int Identifier { get; public set; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsForwarder { get; public set; }
    public string FullName { get; }
    public ExportedType(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Name();
    public void set_Name(string value);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public IMetadataScope get_Scope();
    public void set_Scope(IMetadataScope value);
    public ExportedType get_DeclaringType();
    public void set_DeclaringType(ExportedType value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public int get_Identifier();
    public void set_Identifier(int value);
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public bool get_IsRuntimeSpecialName();
    public void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsForwarder();
    public void set_IsForwarder(bool value);
    public string get_FullName();
    public virtual string ToString();
    public TypeDefinition Resolve();
    internal TypeReference CreateReference();
}
internal class Mono.Cecil.ExportedTypeTable : MetadataTable`1<Row`5<TypeAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[FlagsAttribute]
public enum Mono.Cecil.FieldAttributes : Enum {
    public ushort value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes CompilerControlled;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PInvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
}
public class Mono.Cecil.FieldDefinition : FieldReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    private int offset;
    internal int rva;
    private Byte[] initial_value;
    private object constant;
    private MarshalInfo marshal_info;
    public bool HasLayoutInfo { get; }
    public int Offset { get; public set; }
    internal FieldDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public int RVA { get; }
    public Byte[] InitialValue { get; public set; }
    public FieldAttributes Attributes { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsInitOnly { get; public set; }
    public bool IsLiteral { get; public set; }
    public bool IsNotSerialized { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public int get_Offset();
    public void set_Offset(int value);
    internal FieldDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(FieldDefinitionProjection value);
    private void ResolveRVA();
    public int get_RVA();
    public Byte[] get_InitialValue();
    public void set_InitialValue(Byte[] value);
    public FieldAttributes get_Attributes();
    public void set_Attributes(FieldAttributes value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsInitOnly();
    public void set_IsInitOnly(bool value);
    public bool get_IsLiteral();
    public void set_IsLiteral(bool value);
    public bool get_IsNotSerialized();
    public void set_IsNotSerialized(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldDefinitionProjection : object {
    public FieldAttributes Attributes;
    public FieldDefinitionTreatment Treatment;
    public FieldDefinitionProjection(FieldDefinition field, FieldDefinitionTreatment treatment);
}
internal enum Mono.Cecil.FieldDefinitionTreatment : Enum {
    public int value__;
    public static FieldDefinitionTreatment None;
    public static FieldDefinitionTreatment Public;
}
internal class Mono.Cecil.FieldLayoutTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldMarshalTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
public class Mono.Cecil.FieldReference : MemberReference {
    private TypeReference field_type;
    public TypeReference FieldType { get; public set; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public FieldReference(string name, TypeReference fieldType);
    public FieldReference(string name, TypeReference fieldType, TypeReference declaringType);
    public TypeReference get_FieldType();
    public void set_FieldType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldRVATable : SortedTable`1<Row`2<UInt32, UInt32>> {
    internal int position;
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldTable : MetadataTable`1<Row`3<FieldAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.FileAttributes : Enum {
    public UInt32 value__;
    public static FileAttributes ContainsMetaData;
    public static FileAttributes ContainsNoMetaData;
}
internal class Mono.Cecil.FileTable : MetadataTable`1<Row`3<FileAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.FixedArrayMarshalInfo : MarshalInfo {
    internal NativeType element_type;
    internal int size;
    public NativeType ElementType { get; public set; }
    public int Size { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_Size();
    public void set_Size(int value);
}
public class Mono.Cecil.FixedSysStringMarshalInfo : MarshalInfo {
    internal int size;
    public int Size { get; public set; }
    public int get_Size();
    public void set_Size(int value);
}
public class Mono.Cecil.FunctionPointerType : TypeSpecification {
    private MethodReference function;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsFunctionPointer { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual ModuleDefinition get_Module();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
    public virtual TypeDefinition Resolve();
    public virtual TypeReference GetElementType();
}
public class Mono.Cecil.GenericInstanceMethod : MethodSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public bool IsGenericInstance { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public GenericInstanceMethod(MethodReference method);
    internal GenericInstanceMethod(MethodReference method, int arity);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual bool get_IsGenericInstance();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
}
public class Mono.Cecil.GenericInstanceType : TypeSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public GenericInstanceType(TypeReference type);
    internal GenericInstanceType(TypeReference type, int arity);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
}
internal class Mono.Cecil.GenericParamConstraintTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.GenericParameter : TypeReference {
    internal int position;
    internal GenericParameterType type;
    internal IGenericParameterProvider owner;
    private ushort attributes;
    private GenericParameterConstraintCollection constraints;
    private Collection`1<CustomAttribute> custom_attributes;
    public GenericParameterAttributes Attributes { get; public set; }
    public int Position { get; }
    public GenericParameterType Type { get; }
    public IGenericParameterProvider Owner { get; }
    public bool HasConstraints { get; }
    public Collection`1<GenericParameterConstraint> Constraints { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public IMetadataScope Scope { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public MethodReference DeclaringMethod { get; }
    public ModuleDefinition Module { get; }
    public string Name { get; }
    public string Namespace { get; public set; }
    public string FullName { get; }
    public bool IsGenericParameter { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    public bool IsNonVariant { get; public set; }
    public bool IsCovariant { get; public set; }
    public bool IsContravariant { get; public set; }
    public bool HasReferenceTypeConstraint { get; public set; }
    public bool HasNotNullableValueTypeConstraint { get; public set; }
    public bool HasDefaultConstructorConstraint { get; public set; }
    public GenericParameter(IGenericParameterProvider owner);
    public GenericParameter(string name, IGenericParameterProvider owner);
    internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module);
    public GenericParameterAttributes get_Attributes();
    public void set_Attributes(GenericParameterAttributes value);
    public int get_Position();
    public GenericParameterType get_Type();
    public IGenericParameterProvider get_Owner();
    public bool get_HasConstraints();
    public Collection`1<GenericParameterConstraint> get_Constraints();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public MethodReference get_DeclaringMethod();
    public virtual ModuleDefinition get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public bool get_IsNonVariant();
    public void set_IsNonVariant(bool value);
    public bool get_IsCovariant();
    public void set_IsCovariant(bool value);
    public bool get_IsContravariant();
    public void set_IsContravariant(bool value);
    public bool get_HasReferenceTypeConstraint();
    public void set_HasReferenceTypeConstraint(bool value);
    public bool get_HasNotNullableValueTypeConstraint();
    public void set_HasNotNullableValueTypeConstraint(bool value);
    public bool get_HasDefaultConstructorConstraint();
    public void set_HasDefaultConstructorConstraint(bool value);
    private static ElementType ConvertGenericParameterType(GenericParameterType type);
    public virtual TypeDefinition Resolve();
}
[FlagsAttribute]
public enum Mono.Cecil.GenericParameterAttributes : Enum {
    public ushort value__;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes NonVariant;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
internal class Mono.Cecil.GenericParameterCollection : Collection`1<GenericParameter> {
    private IGenericParameterProvider owner;
    internal GenericParameterCollection(IGenericParameterProvider owner);
    internal GenericParameterCollection(IGenericParameterProvider owner, int capacity);
    protected virtual void OnAdd(GenericParameter item, int index);
    protected virtual void OnInsert(GenericParameter item, int index);
    protected virtual void OnSet(GenericParameter item, int index);
    private void UpdateGenericParameter(GenericParameter item, int index);
    protected virtual void OnRemove(GenericParameter item, int index);
}
public class Mono.Cecil.GenericParameterConstraint : object {
    internal GenericParameter generic_parameter;
    internal MetadataToken token;
    private TypeReference constraint_type;
    private Collection`1<CustomAttribute> custom_attributes;
    public TypeReference ConstraintType { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MetadataToken MetadataToken { get; public set; }
    internal GenericParameterConstraint(TypeReference constraintType, MetadataToken token);
    public GenericParameterConstraint(TypeReference constraintType);
    public TypeReference get_ConstraintType();
    public void set_ConstraintType(TypeReference value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
}
internal class Mono.Cecil.GenericParameterConstraintCollection : Collection`1<GenericParameterConstraint> {
    private GenericParameter generic_parameter;
    internal GenericParameterConstraintCollection(GenericParameter genericParameter);
    internal GenericParameterConstraintCollection(GenericParameter genericParameter, int length);
    protected virtual void OnAdd(GenericParameterConstraint item, int index);
    protected virtual void OnInsert(GenericParameterConstraint item, int index);
    protected virtual void OnSet(GenericParameterConstraint item, int index);
    protected virtual void OnRemove(GenericParameterConstraint item, int index);
}
internal class Mono.Cecil.GenericParameterResolver : object {
    internal static TypeReference ResolveReturnTypeIfNeeded(MethodReference methodReference);
    internal static TypeReference ResolveFieldTypeIfNeeded(FieldReference fieldReference);
    internal static TypeReference ResolveParameterTypeIfNeeded(MethodReference method, ParameterReference parameter);
    internal static TypeReference ResolveVariableTypeIfNeeded(MethodReference method, VariableReference variable);
    private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance declaringGenericInstanceType, TypeReference parameterType);
    private static TypeReference ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericParameter genericParameterElement);
    private static ArrayType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ArrayType arrayType);
    private static ByReferenceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, ByReferenceType byReferenceType);
    private static GenericInstanceType ResolveIfNeeded(IGenericInstance genericInstanceMethod, IGenericInstance genericInstanceType, GenericInstanceType genericInstanceType1);
    private static bool ContainsGenericParameters(TypeReference typeReference);
}
public enum Mono.Cecil.GenericParameterType : Enum {
    public int value__;
    public static GenericParameterType Type;
    public static GenericParameterType Method;
}
internal class Mono.Cecil.GenericParamTable : MetadataTable`1<Row`4<ushort, GenericParameterAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public interface Mono.Cecil.IAssemblyResolver {
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
}
public interface Mono.Cecil.IConstantProvider {
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public abstract virtual bool get_HasConstant();
    public abstract virtual void set_HasConstant(bool value);
    public abstract virtual object get_Constant();
    public abstract virtual void set_Constant(object value);
}
public interface Mono.Cecil.ICustomAttribute {
    public TypeReference AttributeType { get; }
    public bool HasFields { get; }
    public bool HasProperties { get; }
    public bool HasConstructorArguments { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public abstract virtual TypeReference get_AttributeType();
    public abstract virtual bool get_HasFields();
    public abstract virtual bool get_HasProperties();
    public abstract virtual bool get_HasConstructorArguments();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    public abstract virtual Collection`1<CustomAttributeArgument> get_ConstructorArguments();
}
public interface Mono.Cecil.ICustomAttributeProvider {
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasCustomAttributes { get; }
    public abstract virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public abstract virtual bool get_HasCustomAttributes();
}
internal interface Mono.Cecil.IGenericContext {
    public bool IsDefinition { get; }
    public IGenericParameterProvider Type { get; }
    public IGenericParameterProvider Method { get; }
    public abstract virtual bool get_IsDefinition();
    public abstract virtual IGenericParameterProvider get_Type();
    public abstract virtual IGenericParameterProvider get_Method();
}
public interface Mono.Cecil.IGenericInstance {
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public abstract virtual bool get_HasGenericArguments();
    public abstract virtual Collection`1<TypeReference> get_GenericArguments();
}
public interface Mono.Cecil.IGenericParameterProvider {
    public bool HasGenericParameters { get; }
    public bool IsDefinition { get; }
    public ModuleDefinition Module { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public GenericParameterType GenericParameterType { get; }
    public abstract virtual bool get_HasGenericParameters();
    public abstract virtual bool get_IsDefinition();
    public abstract virtual ModuleDefinition get_Module();
    public abstract virtual Collection`1<GenericParameter> get_GenericParameters();
    public abstract virtual GenericParameterType get_GenericParameterType();
}
public interface Mono.Cecil.IMarshalInfoProvider {
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public abstract virtual bool get_HasMarshalInfo();
    public abstract virtual MarshalInfo get_MarshalInfo();
    public abstract virtual void set_MarshalInfo(MarshalInfo value);
}
public interface Mono.Cecil.IMemberDefinition {
    public string Name { get; public set; }
    public string FullName { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual void set_IsSpecialName(bool value);
    public abstract virtual bool get_IsRuntimeSpecialName();
    public abstract virtual void set_IsRuntimeSpecialName(bool value);
    public abstract virtual TypeDefinition get_DeclaringType();
    public abstract virtual void set_DeclaringType(TypeDefinition value);
}
public interface Mono.Cecil.IMetadataImporter {
    public abstract virtual AssemblyNameReference ImportReference(AssemblyNameReference reference);
    public abstract virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    public abstract virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    public abstract virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}
public interface Mono.Cecil.IMetadataImporterProvider {
    public abstract virtual IMetadataImporter GetMetadataImporter(ModuleDefinition module);
}
public interface Mono.Cecil.IMetadataResolver {
    public abstract virtual TypeDefinition Resolve(TypeReference type);
    public abstract virtual FieldDefinition Resolve(FieldReference field);
    public abstract virtual MethodDefinition Resolve(MethodReference method);
}
public interface Mono.Cecil.IMetadataScope {
    public MetadataScopeType MetadataScopeType { get; }
    public string Name { get; public set; }
    public abstract virtual MetadataScopeType get_MetadataScopeType();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public interface Mono.Cecil.IMetadataTokenProvider {
    public MetadataToken MetadataToken { get; public set; }
    public abstract virtual MetadataToken get_MetadataToken();
    public abstract virtual void set_MetadataToken(MetadataToken value);
}
public interface Mono.Cecil.IMethodSignature {
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public abstract virtual bool get_HasThis();
    public abstract virtual void set_HasThis(bool value);
    public abstract virtual bool get_ExplicitThis();
    public abstract virtual void set_ExplicitThis(bool value);
    public abstract virtual MethodCallingConvention get_CallingConvention();
    public abstract virtual void set_CallingConvention(MethodCallingConvention value);
    public abstract virtual bool get_HasParameters();
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    public abstract virtual TypeReference get_ReturnType();
    public abstract virtual void set_ReturnType(TypeReference value);
    public abstract virtual MethodReturnType get_MethodReturnType();
}
internal class Mono.Cecil.ImmediateModuleReader : ModuleReader {
    private bool resolve_attributes;
    public ImmediateModuleReader(Image image);
    protected virtual void ReadModule();
    public void ReadModule(ModuleDefinition module, bool resolve_attributes);
    private void ReadTypes(Collection`1<TypeDefinition> types);
    private void ReadType(TypeDefinition type);
    private void ReadInterfaces(TypeDefinition type);
    private void ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParameterConstraints(GenericParameter parameter);
    private void ReadSecurityDeclarations(ISecurityDeclarationProvider provider);
    private void ReadCustomAttributes(ICustomAttributeProvider provider);
    private void ReadFields(TypeDefinition type);
    private void ReadMethods(TypeDefinition type);
    private void ReadParameters(MethodDefinition method);
    private void ReadProperties(TypeDefinition type);
    private void ReadEvents(TypeDefinition type);
    public virtual void ReadSymbols(ModuleDefinition module);
    private void ReadTypesSymbols(Collection`1<TypeDefinition> types, ISymbolReader symbol_reader);
    private void ReadMethodsSymbols(TypeDefinition type, ISymbolReader symbol_reader);
    [CompilerGeneratedAttribute]
private void <ReadModule>b__2_0(ModuleDefinition module, MetadataReader reader);
}
public interface Mono.Cecil.IModifierType {
    public TypeReference ModifierType { get; }
    public TypeReference ElementType { get; }
    public abstract virtual TypeReference get_ModifierType();
    public abstract virtual TypeReference get_ElementType();
}
internal class Mono.Cecil.ImplMapTable : SortedTable`1<Row`4<PInvokeAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> x, Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.ImportGenericContext : ValueType {
    private Collection`1<IGenericParameterProvider> stack;
    public bool IsEmpty { get; }
    public ImportGenericContext(IGenericParameterProvider provider);
    public bool get_IsEmpty();
    public void Push(IGenericParameterProvider provider);
    public void Pop();
    public TypeReference MethodParameter(string method, int position);
    public string NormalizeMethodName(MethodReference method);
    public TypeReference TypeParameter(string type, int position);
    private static TypeReference GenericTypeFor(IGenericParameterProvider context);
    public static ImportGenericContext For(IGenericParameterProvider context);
}
internal class Mono.Cecil.ImportScopeTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.InterfaceImplementation : object {
    internal TypeDefinition type;
    internal MetadataToken token;
    private TypeReference interface_type;
    private Collection`1<CustomAttribute> custom_attributes;
    public TypeReference InterfaceType { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MetadataToken MetadataToken { get; public set; }
    internal InterfaceImplementation(TypeReference interfaceType, MetadataToken token);
    public InterfaceImplementation(TypeReference interfaceType);
    public TypeReference get_InterfaceType();
    public void set_InterfaceType(TypeReference value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
}
internal class Mono.Cecil.InterfaceImplementationCollection : Collection`1<InterfaceImplementation> {
    private TypeDefinition type;
    internal InterfaceImplementationCollection(TypeDefinition type);
    internal InterfaceImplementationCollection(TypeDefinition type, int length);
    protected virtual void OnAdd(InterfaceImplementation item, int index);
    protected virtual void OnInsert(InterfaceImplementation item, int index);
    protected virtual void OnSet(InterfaceImplementation item, int index);
    protected virtual void OnRemove(InterfaceImplementation item, int index);
}
internal class Mono.Cecil.InterfaceImplTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public interface Mono.Cecil.IReflectionImporter {
    public abstract virtual AssemblyNameReference ImportReference(AssemblyName reference);
    public abstract virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    public abstract virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public abstract virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}
public interface Mono.Cecil.IReflectionImporterProvider {
    public abstract virtual IReflectionImporter GetReflectionImporter(ModuleDefinition module);
}
public interface Mono.Cecil.ISecurityDeclarationProvider {
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public abstract virtual bool get_HasSecurityDeclarations();
    public abstract virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
}
public class Mono.Cecil.LinkedResource : Resource {
    internal Byte[] hash;
    private string file;
    public Byte[] Hash { get; }
    public string File { get; public set; }
    public ResourceType ResourceType { get; }
    public LinkedResource(string name, ManifestResourceAttributes flags);
    public LinkedResource(string name, ManifestResourceAttributes flags, string file);
    public Byte[] get_Hash();
    public string get_File();
    public void set_File(string value);
    public virtual ResourceType get_ResourceType();
}
internal class Mono.Cecil.LocalConstantTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.LocalScopeTable : MetadataTable`1<Row`6<UInt32, UInt32, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.LocalVariableTable : MetadataTable`1<Row`3<VariableAttributes, ushort, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[FlagsAttribute]
public enum Mono.Cecil.ManifestResourceAttributes : Enum {
    public UInt32 value__;
    public static ManifestResourceAttributes VisibilityMask;
    public static ManifestResourceAttributes Public;
    public static ManifestResourceAttributes Private;
}
internal class Mono.Cecil.ManifestResourceTable : MetadataTable`1<Row`4<UInt32, ManifestResourceAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.MarshalInfo : object {
    internal NativeType native;
    public NativeType NativeType { get; public set; }
    public MarshalInfo(NativeType native);
    public NativeType get_NativeType();
    public void set_NativeType(NativeType value);
}
internal class Mono.Cecil.MemberDefinitionCollection`1 : Collection`1<T> {
    private TypeDefinition container;
    internal MemberDefinitionCollection`1(TypeDefinition container);
    internal MemberDefinitionCollection`1(TypeDefinition container, int capacity);
    protected virtual void OnAdd(T item, int index);
    protected sealed virtual void OnSet(T item, int index);
    protected sealed virtual void OnInsert(T item, int index);
    protected sealed virtual void OnRemove(T item, int index);
    protected sealed virtual void OnClear();
    private void Attach(T element);
    private static void Detach(T element);
}
public abstract class Mono.Cecil.MemberReference : object {
    private string name;
    private TypeReference declaring_type;
    internal MetadataToken token;
    internal object projection;
    public string Name { get; public set; }
    public string FullName { get; }
    public TypeReference DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public bool IsWindowsRuntimeProjection { get; }
    internal bool HasImage { get; }
    public ModuleDefinition Module { get; }
    public bool IsDefinition { get; }
    public bool ContainsGenericParameter { get; }
    internal MemberReference(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public bool get_IsWindowsRuntimeProjection();
    internal bool get_HasImage();
    public virtual ModuleDefinition get_Module();
    public virtual bool get_IsDefinition();
    public virtual bool get_ContainsGenericParameter();
    internal string MemberFullName();
    public IMemberDefinition Resolve();
    protected abstract virtual IMemberDefinition ResolveDefinition();
    public virtual string ToString();
}
internal class Mono.Cecil.MemberRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Metadata.BlobHeap : Heap {
    public BlobHeap(Byte[] data);
    public Byte[] Read(UInt32 index);
    public void GetView(UInt32 signature, Byte[]& buffer, Int32& index, Int32& length);
}
internal class Mono.Cecil.Metadata.BlobHeapBuffer : HeapBuffer {
    private Dictionary`2<ByteBuffer, UInt32> blobs;
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public UInt32 GetBlobIndex(ByteBuffer blob);
    private void WriteBlob(ByteBuffer blob);
}
internal enum Mono.Cecil.Metadata.CodedIndex : Enum {
    public int value__;
    public static CodedIndex TypeDefOrRef;
    public static CodedIndex HasConstant;
    public static CodedIndex HasCustomAttribute;
    public static CodedIndex HasFieldMarshal;
    public static CodedIndex HasDeclSecurity;
    public static CodedIndex MemberRefParent;
    public static CodedIndex HasSemantics;
    public static CodedIndex MethodDefOrRef;
    public static CodedIndex MemberForwarded;
    public static CodedIndex Implementation;
    public static CodedIndex CustomAttributeType;
    public static CodedIndex ResolutionScope;
    public static CodedIndex TypeOrMethodDef;
    public static CodedIndex HasCustomDebugInformation;
}
internal class Mono.Cecil.Metadata.DataBuffer : ByteBuffer {
    public UInt32 AddData(Byte[] data);
}
internal enum Mono.Cecil.Metadata.ElementType : Enum {
    public byte value__;
    public static ElementType None;
    public static ElementType Void;
    public static ElementType Boolean;
    public static ElementType Char;
    public static ElementType I1;
    public static ElementType U1;
    public static ElementType I2;
    public static ElementType U2;
    public static ElementType I4;
    public static ElementType U4;
    public static ElementType I8;
    public static ElementType U8;
    public static ElementType R4;
    public static ElementType R8;
    public static ElementType String;
    public static ElementType Ptr;
    public static ElementType ByRef;
    public static ElementType ValueType;
    public static ElementType Class;
    public static ElementType Var;
    public static ElementType Array;
    public static ElementType GenericInst;
    public static ElementType TypedByRef;
    public static ElementType I;
    public static ElementType U;
    public static ElementType FnPtr;
    public static ElementType Object;
    public static ElementType SzArray;
    public static ElementType MVar;
    public static ElementType CModReqD;
    public static ElementType CModOpt;
    public static ElementType Internal;
    public static ElementType Modifier;
    public static ElementType Sentinel;
    public static ElementType Pinned;
    public static ElementType Type;
    public static ElementType Boxed;
    public static ElementType Enum;
}
internal class Mono.Cecil.Metadata.GuidHeap : Heap {
    public GuidHeap(Byte[] data);
    public Guid Read(UInt32 index);
}
internal class Mono.Cecil.Metadata.GuidHeapBuffer : HeapBuffer {
    private Dictionary`2<Guid, UInt32> guids;
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public UInt32 GetGuidIndex(Guid guid);
    private void WriteGuid(Guid guid);
}
internal abstract class Mono.Cecil.Metadata.Heap : object {
    public int IndexSize;
    internal Byte[] data;
    protected Heap(Byte[] data);
}
internal abstract class Mono.Cecil.Metadata.HeapBuffer : ByteBuffer {
    public bool IsLarge { get; }
    public bool IsEmpty { get; }
    protected HeapBuffer(int length);
    public bool get_IsLarge();
    public abstract virtual bool get_IsEmpty();
}
internal class Mono.Cecil.Metadata.PdbHeap : Heap {
    public Byte[] Id;
    public UInt32 EntryPoint;
    public long TypeSystemTables;
    public UInt32[] TypeSystemTableRows;
    public PdbHeap(Byte[] data);
    public bool HasTable(Table table);
}
internal class Mono.Cecil.Metadata.PdbHeapBuffer : HeapBuffer {
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
}
internal class Mono.Cecil.Metadata.ResourceBuffer : ByteBuffer {
    public UInt32 AddResource(Byte[] resource);
}
internal class Mono.Cecil.Metadata.Row`2 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    public Row`2(T1 col1, T2 col2);
}
internal class Mono.Cecil.Metadata.Row`3 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    public Row`3(T1 col1, T2 col2, T3 col3);
}
internal class Mono.Cecil.Metadata.Row`4 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    public Row`4(T1 col1, T2 col2, T3 col3, T4 col4);
}
internal class Mono.Cecil.Metadata.Row`5 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    public Row`5(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5);
}
internal class Mono.Cecil.Metadata.Row`6 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    public Row`6(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6);
}
internal class Mono.Cecil.Metadata.Row`9 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    internal T7 Col7;
    internal T8 Col8;
    internal T9 Col9;
    public Row`9(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9);
}
internal class Mono.Cecil.Metadata.RowEqualityComparer : object {
    public sealed virtual bool Equals(Row`2<string, string> x, Row`2<string, string> y);
    public sealed virtual int GetHashCode(Row`2<string, string> obj);
    public sealed virtual bool Equals(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`2<UInt32, UInt32> obj);
    public sealed virtual bool Equals(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`3<UInt32, UInt32, UInt32> obj);
}
internal class Mono.Cecil.Metadata.StringHeap : Heap {
    private Dictionary`2<UInt32, string> strings;
    public StringHeap(Byte[] data);
    public string Read(UInt32 index);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.StringHeapBuffer : HeapBuffer {
    protected Dictionary`2<string, UInt32> strings;
    public bool IsEmpty { get; }
    public sealed virtual bool get_IsEmpty();
    public virtual UInt32 GetStringIndex(string string);
    public UInt32[] WriteStrings();
    private static List`1<KeyValuePair`2<string, UInt32>> SortStrings(Dictionary`2<string, UInt32> strings);
    private static bool IsLowSurrogateChar(int c);
    protected virtual void WriteString(string string);
}
internal enum Mono.Cecil.Metadata.Table : Enum {
    public byte value__;
    public static Table Module;
    public static Table TypeRef;
    public static Table TypeDef;
    public static Table FieldPtr;
    public static Table Field;
    public static Table MethodPtr;
    public static Table Method;
    public static Table ParamPtr;
    public static Table Param;
    public static Table InterfaceImpl;
    public static Table MemberRef;
    public static Table Constant;
    public static Table CustomAttribute;
    public static Table FieldMarshal;
    public static Table DeclSecurity;
    public static Table ClassLayout;
    public static Table FieldLayout;
    public static Table StandAloneSig;
    public static Table EventMap;
    public static Table EventPtr;
    public static Table Event;
    public static Table PropertyMap;
    public static Table PropertyPtr;
    public static Table Property;
    public static Table MethodSemantics;
    public static Table MethodImpl;
    public static Table ModuleRef;
    public static Table TypeSpec;
    public static Table ImplMap;
    public static Table FieldRVA;
    public static Table EncLog;
    public static Table EncMap;
    public static Table Assembly;
    public static Table AssemblyProcessor;
    public static Table AssemblyOS;
    public static Table AssemblyRef;
    public static Table AssemblyRefProcessor;
    public static Table AssemblyRefOS;
    public static Table File;
    public static Table ExportedType;
    public static Table ManifestResource;
    public static Table NestedClass;
    public static Table GenericParam;
    public static Table MethodSpec;
    public static Table GenericParamConstraint;
    public static Table Document;
    public static Table MethodDebugInformation;
    public static Table LocalScope;
    public static Table LocalVariable;
    public static Table LocalConstant;
    public static Table ImportScope;
    public static Table StateMachineMethod;
    public static Table CustomDebugInformation;
}
[DefaultMemberAttribute("Item")]
internal class Mono.Cecil.Metadata.TableHeap : Heap {
    public long Valid;
    public long Sorted;
    public TableInformation[] Tables;
    public TableInformation Item { get; }
    public TableHeap(Byte[] data);
    public TableInformation get_Item(Table table);
    public bool HasTable(Table table);
}
internal class Mono.Cecil.Metadata.TableHeapBuffer : HeapBuffer {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    internal TableInformation[] table_infos;
    internal MetadataTable[] tables;
    private bool large_string;
    private bool large_blob;
    private bool large_guid;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    internal UInt32[] string_offsets;
    public bool IsEmpty { get; }
    public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata);
    public virtual bool get_IsEmpty();
    private int GetTableLength(Table table);
    public TTable GetTable(Table table);
    public void WriteBySize(UInt32 value, int size);
    public void WriteBySize(UInt32 value, bool large);
    public void WriteString(UInt32 string);
    public void WriteBlob(UInt32 blob);
    public void WriteGuid(UInt32 guid);
    public void WriteRID(UInt32 rid, Table table);
    private int GetCodedIndexSize(CodedIndex coded_index);
    public void WriteCodedRID(UInt32 rid, CodedIndex coded_index);
    public void WriteTableHeap();
    private void WriteRowCount();
    private void WriteTables();
    private ulong GetValid();
    public void ComputeTableInformations();
    private void ComputeTableInformations(TableHeapBuffer table_heap);
    private byte GetHeapSizes();
    private byte GetTableHeapVersion();
    public void FixupData(UInt32 data_rva);
}
internal class Mono.Cecil.Metadata.TableInformation : ValueType {
    public UInt32 Offset;
    public UInt32 Length;
    public UInt32 RowSize;
    public bool IsLarge { get; }
    public bool get_IsLarge();
}
internal class Mono.Cecil.Metadata.UserStringHeap : StringHeap {
    public UserStringHeap(Byte[] data);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.UserStringHeapBuffer : StringHeapBuffer {
    public virtual UInt32 GetStringIndex(string string);
    protected virtual void WriteString(string string);
}
internal class Mono.Cecil.MetadataBuilder : object {
    internal ModuleDefinition module;
    internal ISymbolWriterProvider symbol_writer_provider;
    internal ISymbolWriter symbol_writer;
    internal TextMap text_map;
    internal string fq_name;
    internal UInt32 timestamp;
    private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> type_ref_map;
    private Dictionary`2<UInt32, MetadataToken> type_spec_map;
    private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> member_ref_map;
    private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> method_spec_map;
    private Collection`1<GenericParameter> generic_parameters;
    internal CodeWriter code;
    internal DataBuffer data;
    internal ResourceBuffer resources;
    internal StringHeapBuffer string_heap;
    internal GuidHeapBuffer guid_heap;
    internal UserStringHeapBuffer user_string_heap;
    internal BlobHeapBuffer blob_heap;
    internal TableHeapBuffer table_heap;
    internal PdbHeapBuffer pdb_heap;
    internal MetadataToken entry_point;
    internal UInt32 type_rid;
    internal UInt32 field_rid;
    internal UInt32 method_rid;
    internal UInt32 param_rid;
    internal UInt32 property_rid;
    internal UInt32 event_rid;
    internal UInt32 local_variable_rid;
    internal UInt32 local_constant_rid;
    private TypeRefTable type_ref_table;
    private TypeDefTable type_def_table;
    private FieldTable field_table;
    private MethodTable method_table;
    private ParamTable param_table;
    private InterfaceImplTable iface_impl_table;
    private MemberRefTable member_ref_table;
    private ConstantTable constant_table;
    private CustomAttributeTable custom_attribute_table;
    private DeclSecurityTable declsec_table;
    private StandAloneSigTable standalone_sig_table;
    private EventMapTable event_map_table;
    private EventTable event_table;
    private PropertyMapTable property_map_table;
    private PropertyTable property_table;
    private TypeSpecTable typespec_table;
    private MethodSpecTable method_spec_table;
    internal MetadataBuilder metadata_builder;
    private DocumentTable document_table;
    private MethodDebugInformationTable method_debug_information_table;
    private LocalScopeTable local_scope_table;
    private LocalVariableTable local_variable_table;
    private LocalConstantTable local_constant_table;
    private ImportScopeTable import_scope_table;
    private StateMachineMethodTable state_machine_method_table;
    private CustomDebugInformationTable custom_debug_information_table;
    private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> import_scope_map;
    private Dictionary`2<string, MetadataToken> document_map;
    public MetadataBuilder(ModuleDefinition module, string fq_name, UInt32 timestamp, ISymbolWriterProvider symbol_writer_provider);
    public MetadataBuilder(ModuleDefinition module, PortablePdbWriterProvider writer_provider);
    public void SetSymbolWriter(ISymbolWriter writer);
    private TextMap CreateTextMap();
    private TTable GetTable(Table table);
    private UInt32 GetStringIndex(string string);
    private UInt32 GetGuidIndex(Guid guid);
    private UInt32 GetBlobIndex(ByteBuffer blob);
    private UInt32 GetBlobIndex(Byte[] blob);
    public void BuildMetadata();
    private void BuildModule();
    private void BuildAssembly();
    private void BuildModules();
    private void AddAssemblyReferences();
    private void AddModuleReferences();
    private void AddResources();
    private UInt32 AddLinkedResource(LinkedResource resource);
    private UInt32 AddEmbeddedResource(EmbeddedResource resource);
    private void AddExportedTypes();
    private MetadataToken GetExportedTypeScope(ExportedType exported_type);
    private void BuildTypes();
    private void AttachTokens();
    private void AttachTypeToken(TypeDefinition type);
    private void AttachNestedTypesToken(TypeDefinition type);
    private void AttachFieldsToken(TypeDefinition type);
    private void AttachMethodsToken(TypeDefinition type);
    private MetadataToken GetTypeToken(TypeReference type);
    private MetadataToken GetTypeSpecToken(TypeReference type);
    private MetadataToken AddTypeSpecification(TypeReference type, UInt32 row);
    private MetadataToken GetTypeRefToken(TypeReference type);
    private Row`3<UInt32, UInt32, UInt32> CreateTypeRefRow(TypeReference type);
    private MetadataToken GetScopeToken(TypeReference type);
    private static UInt32 MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index);
    private static UInt32 MakeCodedRID(MetadataToken token, CodedIndex index);
    private MetadataToken AddTypeReference(TypeReference type, Row`3<UInt32, UInt32, UInt32> row);
    private void AddTypes();
    private void AddType(TypeDefinition type);
    private void AddGenericParameters(IGenericParameterProvider owner);
    private void AddGenericParameters();
    private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table);
    private void AddInterfaces(TypeDefinition type);
    private void AddLayoutInfo(TypeDefinition type);
    private static bool HasNoInstanceField(TypeDefinition type);
    private void AddNestedTypes(TypeDefinition type);
    private void AddFields(TypeDefinition type);
    private void AddField(FieldDefinition field);
    private void AddFieldRVA(FieldDefinition field);
    private void AddFieldLayout(FieldDefinition field);
    private void AddMethods(TypeDefinition type);
    private void AddMethod(MethodDefinition method);
    private void AddParameters(MethodDefinition method);
    private void AddPInvokeInfo(MethodDefinition method);
    private void AddOverrides(MethodDefinition method);
    private static bool RequiresParameterRow(ParameterDefinition parameter);
    private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table);
    private void AddMarshalInfo(IMarshalInfoProvider owner);
    private void AddProperties(TypeDefinition type);
    private void AddProperty(PropertyDefinition property);
    private void AddOtherSemantic(IMetadataTokenProvider owner, Collection`1<MethodDefinition> others);
    private void AddEvents(TypeDefinition type);
    private void AddEvent(EventDefinition event);
    private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method);
    private void AddConstant(IConstantProvider owner, TypeReference type);
    private static ElementType GetConstantType(TypeReference constant_type, object constant);
    private static ElementType GetConstantType(Type type);
    private void AddCustomAttributes(ICustomAttributeProvider owner);
    private void AddSecurityDeclarations(ISecurityDeclarationProvider owner);
    private MetadataToken GetMemberRefToken(MemberReference member);
    private Row`3<UInt32, UInt32, UInt32> CreateMemberRefRow(MemberReference member);
    private MetadataToken AddMemberReference(MemberReference member, Row`3<UInt32, UInt32, UInt32> row);
    private MetadataToken GetMethodSpecToken(MethodSpecification method_spec);
    private void AddMethodSpecification(MethodSpecification method_spec, Row`2<UInt32, UInt32> row);
    private Row`2<UInt32, UInt32> CreateMethodSpecRow(MethodSpecification method_spec);
    private SignatureWriter CreateSignatureWriter();
    private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec);
    public UInt32 AddStandAloneSignature(UInt32 signature);
    public UInt32 GetLocalVariableBlobIndex(Collection`1<VariableDefinition> variables);
    public UInt32 GetCallSiteBlobIndex(CallSite call_site);
    public UInt32 GetConstantTypeBlobIndex(TypeReference constant_type);
    private SignatureWriter GetVariablesSignature(Collection`1<VariableDefinition> variables);
    private SignatureWriter GetConstantTypeSignature(TypeReference constant_type);
    private SignatureWriter GetFieldSignature(FieldReference field);
    private SignatureWriter GetMethodSignature(IMethodSignature method);
    private SignatureWriter GetMemberRefSignature(MemberReference member);
    private SignatureWriter GetPropertySignature(PropertyDefinition property);
    private SignatureWriter GetTypeSpecSignature(TypeReference type);
    private SignatureWriter GetConstantSignature(ElementType type, object value);
    private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute);
    private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration);
    private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner);
    private static Exception CreateForeignMemberException(MemberReference member);
    public MetadataToken LookupToken(IMetadataTokenProvider provider);
    public void AddMethodDebugInformation(MethodDebugInformation method_info);
    private void AddStateMachineMethod(MethodDebugInformation method_info);
    private void AddLocalScope(MethodDebugInformation method_info, ScopeDebugInformation scope);
    private void AddLocalVariables(ScopeDebugInformation scope);
    private void AddLocalConstants(ScopeDebugInformation scope);
    private SignatureWriter GetConstantSignature(ConstantDebugInformation constant);
    public void AddCustomDebugInformations(ICustomDebugInformationProvider provider);
    private void AddStateMachineScopeDebugInformation(ICustomDebugInformationProvider provider, StateMachineScopeDebugInformation state_machine_scope);
    private void AddAsyncMethodBodyDebugInformation(ICustomDebugInformationProvider provider, AsyncMethodBodyDebugInformation async_method);
    private void AddEmbeddedSourceDebugInformation(ICustomDebugInformationProvider provider, EmbeddedSourceDebugInformation embedded_source);
    private void AddSourceLinkDebugInformation(ICustomDebugInformationProvider provider, SourceLinkDebugInformation source_link);
    private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, SignatureWriter signature);
    private void AddCustomDebugInformation(ICustomDebugInformationProvider provider, CustomDebugInformation custom_info, UInt32 blob_index);
    private UInt32 AddImportScope(ImportDebugInformation import);
    private void AddImportTarget(ImportTarget target, SignatureWriter signature);
    private UInt32 GetUTF8StringBlobIndex(string s);
    public MetadataToken GetDocumentToken(Document document);
    private SignatureWriter GetDocumentNameSignature(Document document);
    private static bool TryGetDocumentNameSeparator(string path, Char& separator);
    private void AddSequencePoints(MethodDebugInformation info);
    public void ComputeDeterministicMvid();
}
public enum Mono.Cecil.MetadataKind : Enum {
    public int value__;
    public static MetadataKind Ecma335;
    public static MetadataKind WindowsMetadata;
    public static MetadataKind ManagedWindowsMetadata;
}
internal class Mono.Cecil.MetadataReader : ByteBuffer {
    internal Image image;
    internal ModuleDefinition module;
    internal MetadataSystem metadata;
    internal CodeReader code;
    internal IGenericContext context;
    private MetadataReader metadata_reader;
    public MetadataReader(ModuleDefinition module);
    public MetadataReader(Image image, ModuleDefinition module, MetadataReader metadata_reader);
    private int GetCodedIndexSize(CodedIndex index);
    private UInt32 ReadByIndexSize(int size);
    private Byte[] ReadBlob();
    private Byte[] ReadBlob(UInt32 signature);
    private UInt32 ReadBlobIndex();
    private void GetBlobView(UInt32 signature, Byte[]& blob, Int32& index, Int32& count);
    private string ReadString();
    private UInt32 ReadStringIndex();
    private Guid ReadGuid();
    private UInt32 ReadTableIndex(Table table);
    private MetadataToken ReadMetadataToken(CodedIndex index);
    private int MoveTo(Table table);
    private bool MoveTo(Table table, UInt32 row);
    public AssemblyNameDefinition ReadAssemblyNameDefinition();
    public ModuleDefinition Populate(ModuleDefinition module);
    private void InitializeAssemblyReferences();
    public Collection`1<AssemblyNameReference> ReadAssemblyReferences();
    public MethodDefinition ReadEntryPoint();
    public Collection`1<ModuleDefinition> ReadModules();
    private string GetModuleFileName(string name);
    private void InitializeModuleReferences();
    public Collection`1<ModuleReference> ReadModuleReferences();
    public bool HasFileResource();
    public Collection`1<Resource> ReadResources();
    private Row`3<FileAttributes, string, UInt32> ReadFileRecord(UInt32 rid);
    public Byte[] GetManagedResource(UInt32 offset);
    private void PopulateVersionAndFlags(AssemblyNameReference name);
    private void PopulateNameAndCulture(AssemblyNameReference name);
    public TypeDefinitionCollection ReadTypes();
    private void CompleteTypes();
    private void InitializeTypeDefinitions();
    private static bool IsNested(TypeAttributes attributes);
    public bool HasNestedTypes(TypeDefinition type);
    public Collection`1<TypeDefinition> ReadNestedTypes(TypeDefinition type);
    private void InitializeNestedTypes();
    private void AddNestedMapping(UInt32 declaring, UInt32 nested);
    private static Collection`1<TValue> AddMapping(Dictionary`2<TKey, Collection`1<TValue>> cache, TKey key, TValue value);
    private TypeDefinition ReadType(UInt32 rid);
    private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type);
    private Range ReadListRange(UInt32 current_index, Table current, Table target);
    public Row`2<short, int> ReadTypeLayout(TypeDefinition type);
    private void InitializeTypeLayouts();
    public TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    private TypeDefinition ReadTypeDefinition(UInt32 rid);
    private void InitializeTypeReferences();
    public TypeReference GetTypeReference(string scope, string full_name);
    private TypeReference GetTypeReference(UInt32 rid);
    private TypeReference ReadTypeReference(UInt32 rid);
    private IMetadataScope GetTypeReferenceScope(MetadataToken scope);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    private TypeReference GetTypeSpecification(UInt32 rid);
    private SignatureReader ReadSignature(UInt32 signature);
    public bool HasInterfaces(TypeDefinition type);
    public InterfaceImplementationCollection ReadInterfaces(TypeDefinition type);
    private void InitializeInterfaces();
    private void AddInterfaceMapping(UInt32 type, Row`2<UInt32, MetadataToken> interface);
    public Collection`1<FieldDefinition> ReadFields(TypeDefinition type);
    private void ReadField(UInt32 field_rid, Collection`1<FieldDefinition> fields);
    private void InitializeFields();
    private TypeReference ReadFieldType(UInt32 signature);
    public int ReadFieldRVA(FieldDefinition field);
    private Byte[] GetFieldInitializeValue(int size, UInt32 rva);
    private static int GetFieldTypeSize(TypeReference type);
    private void InitializeFieldRVAs();
    public int ReadFieldLayout(FieldDefinition field);
    private void InitializeFieldLayouts();
    public bool HasEvents(TypeDefinition type);
    public Collection`1<EventDefinition> ReadEvents(TypeDefinition type);
    private void ReadEvent(UInt32 event_rid, Collection`1<EventDefinition> events);
    private void InitializeEvents();
    public bool HasProperties(TypeDefinition type);
    public Collection`1<PropertyDefinition> ReadProperties(TypeDefinition type);
    private void ReadProperty(UInt32 property_rid, Collection`1<PropertyDefinition> properties);
    private void InitializeProperties();
    private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method);
    private static EventDefinition GetEvent(TypeDefinition type, MetadataToken token);
    private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token);
    private static TMember GetMember(Collection`1<TMember> members, MetadataToken token);
    private void InitializeMethodSemantics();
    public void ReadMethods(PropertyDefinition property);
    public void ReadMethods(EventDefinition event);
    public void ReadAllSemantics(MethodDefinition method);
    private void ReadAllSemantics(TypeDefinition type);
    public Collection`1<MethodDefinition> ReadMethods(TypeDefinition type);
    private void ReadPointers(Table ptr, Table table, Range range, Collection`1<TMember> members, Action`2<UInt32, Collection`1<TMember>> reader);
    private static bool IsDeleted(IMemberDefinition member);
    private void InitializeMethods();
    private void ReadMethod(UInt32 method_rid, Collection`1<MethodDefinition> methods);
    private void ReadParameters(MethodDefinition method, Range param_range);
    private void ReadParameterPointers(MethodDefinition method, Range range);
    private void ReadParameter(UInt32 param_rid, MethodDefinition method);
    private void ReadMethodSignature(UInt32 signature, IMethodSignature method);
    public PInvokeInfo ReadPInvokeInfo(MethodDefinition method);
    private void InitializePInvokes();
    public bool HasGenericParameters(IGenericParameterProvider provider);
    public Collection`1<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters);
    private void InitializeGenericParameters();
    private Dictionary`2<MetadataToken, Range[]> InitializeRanges(Table table, Func`1<MetadataToken> get_next);
    private static void AddRange(Dictionary`2<MetadataToken, Range[]> ranges, MetadataToken owner, Range range);
    public bool HasGenericConstraints(GenericParameter generic_parameter);
    public GenericParameterConstraintCollection ReadGenericConstraints(GenericParameter generic_parameter);
    private void InitializeGenericConstraints();
    private void AddGenericConstraintMapping(UInt32 generic_parameter, Row`2<UInt32, MetadataToken> constraint);
    public bool HasOverrides(MethodDefinition method);
    public Collection`1<MethodReference> ReadOverrides(MethodDefinition method);
    private void InitializeOverrides();
    private void AddOverrideMapping(UInt32 method_rid, MetadataToken override);
    public MethodBody ReadMethodBody(MethodDefinition method);
    public int ReadCodeSize(MethodDefinition method);
    public CallSite ReadCallSite(MetadataToken token);
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token, MethodDefinition method);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    private FieldDefinition LookupField(UInt32 rid);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    private MethodDefinition LookupMethod(UInt32 rid);
    private MethodSpecification GetMethodSpecification(UInt32 rid);
    private MethodSpecification ReadMethodSpecSignature(UInt32 signature, MethodReference method);
    private MemberReference GetMemberReference(UInt32 rid);
    private MemberReference ReadMemberReference(UInt32 rid);
    private MemberReference ReadTypeMemberReference(MetadataToken type, string name, UInt32 signature);
    private MemberReference ReadMemberReferenceSignature(UInt32 signature, TypeReference declaring_type);
    private MemberReference ReadMethodMemberReference(MetadataToken token, string name, UInt32 signature);
    private void InitializeMemberReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    private void InitializeConstants();
    public TypeReference ReadConstantSignature(MetadataToken token);
    public object ReadConstant(IConstantProvider owner);
    private object ReadConstantValue(ElementType etype, UInt32 signature);
    private string ReadConstantString(UInt32 signature);
    private object ReadConstantPrimitive(ElementType type, UInt32 signature);
    internal void InitializeCustomAttributes();
    public bool HasCustomAttributes(ICustomAttributeProvider owner);
    public Collection`1<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner);
    private void ReadCustomAttributeRange(Range range, Collection`1<CustomAttribute> custom_attributes);
    private static int RangesSize(Range[] ranges);
    public IEnumerable`1<CustomAttribute> GetCustomAttributes();
    public Byte[] ReadCustomAttributeBlob(UInt32 signature);
    public void ReadCustomAttributeSignature(CustomAttribute attribute);
    private void InitializeMarshalInfos();
    public bool HasMarshalInfo(IMarshalInfoProvider owner);
    public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner);
    private void InitializeSecurityDeclarations();
    public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner);
    public Collection`1<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner);
    private void ReadSecurityDeclarationRange(Range range, Collection`1<SecurityDeclaration> security_declarations);
    public Byte[] ReadSecurityDeclarationBlob(UInt32 signature);
    public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration);
    private void ReadXmlSecurityDeclaration(UInt32 signature, SecurityDeclaration declaration);
    public Collection`1<ExportedType> ReadExportedTypes();
    private IMetadataScope GetExportedTypeScope(MetadataToken token);
    private ModuleReference GetModuleReferenceFromFile(MetadataToken token);
    private void InitializeDocuments();
    public Collection`1<SequencePoint> ReadSequencePoints(MethodDefinition method);
    public Document GetDocument(UInt32 rid);
    private void InitializeLocalScopes();
    public ScopeDebugInformation ReadScope(MethodDefinition method);
    private static bool AddScope(Collection`1<ScopeDebugInformation> scopes, ScopeDebugInformation scope);
    private ScopeDebugInformation ReadLocalScope(Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32> record);
    private VariableDebugInformation ReadLocalVariable(UInt32 rid);
    private ConstantDebugInformation ReadLocalConstant(UInt32 rid);
    private void InitializeImportScopes();
    public string ReadUTF8StringBlob(UInt32 signature);
    private string ReadUnicodeStringBlob(UInt32 signature);
    private string ReadStringBlob(UInt32 signature, Encoding encoding);
    private ImportTarget ReadImportTarget(SignatureReader signature);
    private void InitializeStateMachineMethods();
    public MethodDefinition ReadStateMachineKickoffMethod(MethodDefinition method);
    private void InitializeCustomDebugInformations();
    public Collection`1<CustomDebugInformation> GetCustomDebugInformation(ICustomDebugInformationProvider provider);
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeGenericParameters>b__106_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeCustomAttributes>b__141_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeSecurityDeclarations>b__152_0();
}
public class Mono.Cecil.MetadataResolver : object {
    private IAssemblyResolver assembly_resolver;
    public IAssemblyResolver AssemblyResolver { get; }
    public MetadataResolver(IAssemblyResolver assemblyResolver);
    public IAssemblyResolver get_AssemblyResolver();
    public virtual TypeDefinition Resolve(TypeReference type);
    private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference);
    private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type);
    public virtual FieldDefinition Resolve(FieldReference field);
    private FieldDefinition GetField(TypeDefinition type, FieldReference reference);
    private static FieldDefinition GetField(Collection`1<FieldDefinition> fields, FieldReference reference);
    public virtual MethodDefinition Resolve(MethodReference method);
    private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference);
    public static MethodDefinition GetMethod(Collection`1<MethodDefinition> methods, MethodReference reference);
    private static bool AreSame(Collection`1<ParameterDefinition> a, Collection`1<ParameterDefinition> b);
    private static bool IsVarArgCallTo(MethodDefinition method, MethodReference reference);
    private static bool AreSame(TypeSpecification a, TypeSpecification b);
    private static bool AreSame(ArrayType a, ArrayType b);
    private static bool AreSame(IModifierType a, IModifierType b);
    private static bool AreSame(GenericInstanceType a, GenericInstanceType b);
    private static bool AreSame(GenericParameter a, GenericParameter b);
    private static bool AreSame(TypeReference a, TypeReference b);
}
public enum Mono.Cecil.MetadataScopeType : Enum {
    public int value__;
    public static MetadataScopeType AssemblyNameReference;
    public static MetadataScopeType ModuleReference;
    public static MetadataScopeType ModuleDefinition;
}
internal class Mono.Cecil.MetadataSystem : object {
    internal AssemblyNameReference[] AssemblyReferences;
    internal ModuleReference[] ModuleReferences;
    internal TypeDefinition[] Types;
    internal TypeReference[] TypeReferences;
    internal FieldDefinition[] Fields;
    internal MethodDefinition[] Methods;
    internal MemberReference[] MemberReferences;
    internal Dictionary`2<UInt32, Collection`1<UInt32>> NestedTypes;
    internal Dictionary`2<UInt32, UInt32> ReverseNestedTypes;
    internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> Interfaces;
    internal Dictionary`2<UInt32, Row`2<ushort, UInt32>> ClassLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldRVAs;
    internal Dictionary`2<MetadataToken, UInt32> FieldMarshals;
    internal Dictionary`2<MetadataToken, Row`2<ElementType, UInt32>> Constants;
    internal Dictionary`2<UInt32, Collection`1<MetadataToken>> Overrides;
    internal Dictionary`2<MetadataToken, Range[]> CustomAttributes;
    internal Dictionary`2<MetadataToken, Range[]> SecurityDeclarations;
    internal Dictionary`2<UInt32, Range> Events;
    internal Dictionary`2<UInt32, Range> Properties;
    internal Dictionary`2<UInt32, Row`2<MethodSemanticsAttributes, MetadataToken>> Semantics;
    internal Dictionary`2<UInt32, Row`3<PInvokeAttributes, UInt32, UInt32>> PInvokes;
    internal Dictionary`2<MetadataToken, Range[]> GenericParameters;
    internal Dictionary`2<UInt32, Collection`1<Row`2<UInt32, MetadataToken>>> GenericConstraints;
    internal Document[] Documents;
    internal Dictionary`2<UInt32, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>>> LocalScopes;
    internal ImportDebugInformation[] ImportScopes;
    internal Dictionary`2<UInt32, UInt32> StateMachineMethods;
    internal Dictionary`2<MetadataToken, Row`3[]> CustomDebugInformations;
    private static Dictionary`2<string, Row`2<ElementType, bool>> primitive_value_types;
    private static void InitializePrimitives();
    public static void TryProcessPrimitiveTypeReference(TypeReference type);
    public static bool TryGetPrimitiveElementType(TypeDefinition type, ElementType& etype);
    private static bool TryGetPrimitiveData(TypeReference type, Row`2& primitive_data);
    public void Clear();
    public AssemblyNameReference GetAssemblyNameReference(UInt32 rid);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    public void AddTypeDefinition(TypeDefinition type);
    public TypeReference GetTypeReference(UInt32 rid);
    public void AddTypeReference(TypeReference type);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    public void AddFieldDefinition(FieldDefinition field);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    public void AddMethodDefinition(MethodDefinition method);
    public MemberReference GetMemberReference(UInt32 rid);
    public void AddMemberReference(MemberReference member);
    public bool TryGetNestedTypeMapping(TypeDefinition type, Collection`1& mapping);
    public void SetNestedTypeMapping(UInt32 type_rid, Collection`1<UInt32> mapping);
    public void RemoveNestedTypeMapping(TypeDefinition type);
    public bool TryGetReverseNestedTypeMapping(TypeDefinition type, UInt32& declaring);
    public void SetReverseNestedTypeMapping(UInt32 nested, UInt32 declaring);
    public void RemoveReverseNestedTypeMapping(TypeDefinition type);
    public bool TryGetInterfaceMapping(TypeDefinition type, Collection`1& mapping);
    public void SetInterfaceMapping(UInt32 type_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping);
    public void RemoveInterfaceMapping(TypeDefinition type);
    public void AddPropertiesRange(UInt32 type_rid, Range range);
    public bool TryGetPropertiesRange(TypeDefinition type, Range& range);
    public void RemovePropertiesRange(TypeDefinition type);
    public void AddEventsRange(UInt32 type_rid, Range range);
    public bool TryGetEventsRange(TypeDefinition type, Range& range);
    public void RemoveEventsRange(TypeDefinition type);
    public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, Range[]& ranges);
    public void RemoveGenericParameterRange(IGenericParameterProvider owner);
    public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, Range[]& ranges);
    public void RemoveCustomAttributeRange(ICustomAttributeProvider owner);
    public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, Range[]& ranges);
    public void RemoveSecurityDeclarationRange(ISecurityDeclarationProvider owner);
    public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, Collection`1& mapping);
    public void SetGenericConstraintMapping(UInt32 gp_rid, Collection`1<Row`2<UInt32, MetadataToken>> mapping);
    public void RemoveGenericConstraintMapping(GenericParameter generic_parameter);
    public bool TryGetOverrideMapping(MethodDefinition method, Collection`1& mapping);
    public void SetOverrideMapping(UInt32 rid, Collection`1<MetadataToken> mapping);
    public void RemoveOverrideMapping(MethodDefinition method);
    public Document GetDocument(UInt32 rid);
    public bool TryGetLocalScopes(MethodDefinition method, Collection`1& scopes);
    public void SetLocalScopes(UInt32 method_rid, Collection`1<Row`6<UInt32, Range, Range, UInt32, UInt32, UInt32>> records);
    public ImportDebugInformation GetImportScope(UInt32 rid);
    public bool TryGetStateMachineKickOffMethod(MethodDefinition method, UInt32& rid);
    public TypeDefinition GetFieldDeclaringType(UInt32 field_rid);
    public TypeDefinition GetMethodDeclaringType(UInt32 method_rid);
    private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, UInt32 rid, bool field);
}
internal abstract class Mono.Cecil.MetadataTable : object {
    public int Length { get; }
    public bool IsLarge { get; }
    public abstract virtual int get_Length();
    public bool get_IsLarge();
    public abstract virtual void Write(TableHeapBuffer buffer);
    public abstract virtual void Sort();
}
internal abstract class Mono.Cecil.MetadataTable`1 : MetadataTable {
    internal TRow[] rows;
    internal int length;
    public int Length { get; }
    public sealed virtual int get_Length();
    public int AddRow(TRow row);
    private void Grow();
    public virtual void Sort();
}
public class Mono.Cecil.MetadataToken : ValueType {
    private UInt32 token;
    public static MetadataToken Zero;
    public UInt32 RID { get; }
    public TokenType TokenType { get; }
    public MetadataToken(UInt32 token);
    public MetadataToken(TokenType type);
    public MetadataToken(TokenType type, UInt32 rid);
    public MetadataToken(TokenType type, int rid);
    private static MetadataToken();
    public UInt32 get_RID();
    public TokenType get_TokenType();
    public int ToInt32();
    public UInt32 ToUInt32();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetadataToken other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(MetadataToken one, MetadataToken other);
    public static bool op_Inequality(MetadataToken one, MetadataToken other);
    public virtual string ToString();
}
public enum Mono.Cecil.MetadataType : Enum {
    public byte value__;
    public static MetadataType Void;
    public static MetadataType Boolean;
    public static MetadataType Char;
    public static MetadataType SByte;
    public static MetadataType Byte;
    public static MetadataType Int16;
    public static MetadataType UInt16;
    public static MetadataType Int32;
    public static MetadataType UInt32;
    public static MetadataType Int64;
    public static MetadataType UInt64;
    public static MetadataType Single;
    public static MetadataType Double;
    public static MetadataType String;
    public static MetadataType Pointer;
    public static MetadataType ByReference;
    public static MetadataType ValueType;
    public static MetadataType Class;
    public static MetadataType Var;
    public static MetadataType Array;
    public static MetadataType GenericInstance;
    public static MetadataType TypedByReference;
    public static MetadataType IntPtr;
    public static MetadataType UIntPtr;
    public static MetadataType FunctionPointer;
    public static MetadataType Object;
    public static MetadataType MVar;
    public static MetadataType RequiredModifier;
    public static MetadataType OptionalModifier;
    public static MetadataType Sentinel;
    public static MetadataType Pinned;
}
[FlagsAttribute]
public enum Mono.Cecil.MethodAttributes : Enum {
    public ushort value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes CompilerControlled;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PInvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
}
public enum Mono.Cecil.MethodCallingConvention : Enum {
    public byte value__;
    public static MethodCallingConvention Default;
    public static MethodCallingConvention C;
    public static MethodCallingConvention StdCall;
    public static MethodCallingConvention ThisCall;
    public static MethodCallingConvention FastCall;
    public static MethodCallingConvention VarArg;
    public static MethodCallingConvention Generic;
}
internal class Mono.Cecil.MethodDebugInformationTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.MethodDefinition : MethodReference {
    private ushort attributes;
    private ushort impl_attributes;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sem_attrs_ready;
    internal MethodSemanticsAttributes sem_attrs;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    internal UInt32 rva;
    internal PInvokeInfo pinvoke;
    private Collection`1<MethodReference> overrides;
    internal MethodBody body;
    internal MethodDebugInformation debug_info;
    internal Collection`1<CustomDebugInformation> custom_infos;
    public string Name { get; public set; }
    public MethodAttributes Attributes { get; public set; }
    public MethodImplAttributes ImplAttributes { get; public set; }
    public MethodSemanticsAttributes SemanticsAttributes { get; public set; }
    internal MethodDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public int RVA { get; }
    public bool HasBody { get; }
    public MethodBody Body { get; public set; }
    public MethodDebugInformation DebugInformation { get; public set; }
    public bool HasPInvokeInfo { get; }
    public PInvokeInfo PInvokeInfo { get; public set; }
    public bool HasOverrides { get; }
    public Collection`1<MethodReference> Overrides { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool HasCustomDebugInformations { get; }
    public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsFinal { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsHideBySig { get; public set; }
    public bool IsReuseSlot { get; public set; }
    public bool IsNewSlot { get; public set; }
    public bool IsCheckAccessOnOverride { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsUnmanagedExport { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsIL { get; public set; }
    public bool IsNative { get; public set; }
    public bool IsRuntime { get; public set; }
    public bool IsUnmanaged { get; public set; }
    public bool IsManaged { get; public set; }
    public bool IsForwardRef { get; public set; }
    public bool IsPreserveSig { get; public set; }
    public bool IsInternalCall { get; public set; }
    public bool IsSynchronized { get; public set; }
    public bool NoInlining { get; public set; }
    public bool NoOptimization { get; public set; }
    public bool AggressiveInlining { get; public set; }
    public bool IsSetter { get; public set; }
    public bool IsGetter { get; public set; }
    public bool IsOther { get; public set; }
    public bool IsAddOn { get; public set; }
    public bool IsRemoveOn { get; public set; }
    public bool IsFire { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsConstructor { get; }
    public bool IsDefinition { get; }
    public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public MethodAttributes get_Attributes();
    public void set_Attributes(MethodAttributes value);
    public MethodImplAttributes get_ImplAttributes();
    public void set_ImplAttributes(MethodImplAttributes value);
    public MethodSemanticsAttributes get_SemanticsAttributes();
    public void set_SemanticsAttributes(MethodSemanticsAttributes value);
    internal MethodDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(MethodDefinitionProjection value);
    internal void ReadSemantics();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public int get_RVA();
    public bool get_HasBody();
    public MethodBody get_Body();
    public void set_Body(MethodBody value);
    public MethodDebugInformation get_DebugInformation();
    public void set_DebugInformation(MethodDebugInformation value);
    public bool get_HasPInvokeInfo();
    public PInvokeInfo get_PInvokeInfo();
    public void set_PInvokeInfo(PInvokeInfo value);
    public bool get_HasOverrides();
    public Collection`1<MethodReference> get_Overrides();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsFinal();
    public void set_IsFinal(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsHideBySig();
    public void set_IsHideBySig(bool value);
    public bool get_IsReuseSlot();
    public void set_IsReuseSlot(bool value);
    public bool get_IsNewSlot();
    public void set_IsNewSlot(bool value);
    public bool get_IsCheckAccessOnOverride();
    public void set_IsCheckAccessOnOverride(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public bool get_IsUnmanagedExport();
    public void set_IsUnmanagedExport(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsIL();
    public void set_IsIL(bool value);
    public bool get_IsNative();
    public void set_IsNative(bool value);
    public bool get_IsRuntime();
    public void set_IsRuntime(bool value);
    public bool get_IsUnmanaged();
    public void set_IsUnmanaged(bool value);
    public bool get_IsManaged();
    public void set_IsManaged(bool value);
    public bool get_IsForwardRef();
    public void set_IsForwardRef(bool value);
    public bool get_IsPreserveSig();
    public void set_IsPreserveSig(bool value);
    public bool get_IsInternalCall();
    public void set_IsInternalCall(bool value);
    public bool get_IsSynchronized();
    public void set_IsSynchronized(bool value);
    public bool get_NoInlining();
    public void set_NoInlining(bool value);
    public bool get_NoOptimization();
    public void set_NoOptimization(bool value);
    public bool get_AggressiveInlining();
    public void set_AggressiveInlining(bool value);
    public bool get_IsSetter();
    public void set_IsSetter(bool value);
    public bool get_IsGetter();
    public void set_IsGetter(bool value);
    public bool get_IsOther();
    public void set_IsOther(bool value);
    public bool get_IsAddOn();
    public void set_IsAddOn(bool value);
    public bool get_IsRemoveOn();
    public void set_IsRemoveOn(bool value);
    public bool get_IsFire();
    public void set_IsFire(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public bool get_IsConstructor();
    public virtual bool get_IsDefinition();
    public virtual MethodDefinition Resolve();
}
internal class Mono.Cecil.MethodDefinitionProjection : object {
    public MethodAttributes Attributes;
    public MethodImplAttributes ImplAttributes;
    public string Name;
    public MethodDefinitionTreatment Treatment;
    public MethodDefinitionProjection(MethodDefinition method, MethodDefinitionTreatment treatment);
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodDefinitionTreatment : Enum {
    public int value__;
    public static MethodDefinitionTreatment None;
    public static MethodDefinitionTreatment Abstract;
    public static MethodDefinitionTreatment Private;
    public static MethodDefinitionTreatment Public;
    public static MethodDefinitionTreatment Runtime;
    public static MethodDefinitionTreatment InternalCall;
}
[FlagsAttribute]
public enum Mono.Cecil.MethodImplAttributes : Enum {
    public ushort value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
}
internal class Mono.Cecil.MethodImplTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public class Mono.Cecil.MethodReference : MemberReference {
    internal ParameterDefinitionCollection parameters;
    private MethodReturnType return_type;
    private bool has_this;
    private bool explicit_this;
    private MethodCallingConvention calling_convention;
    internal Collection`1<GenericParameter> generic_parameters;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    public MethodReference(string name, TypeReference returnType);
    public MethodReference(string name, TypeReference returnType, TypeReference declaringType);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    public virtual MethodReference GetElementMethod();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual MethodDefinition Resolve();
}
internal class Mono.Cecil.MethodReferenceComparer : EqualityComparer`1<MethodReference> {
    [ThreadStaticAttribute]
private static List`1<MethodReference> xComparisonStack;
    [ThreadStaticAttribute]
private static List`1<MethodReference> yComparisonStack;
    public virtual bool Equals(MethodReference x, MethodReference y);
    public virtual int GetHashCode(MethodReference obj);
    public static bool AreEqual(MethodReference x, MethodReference y);
    public static bool AreSignaturesEqual(MethodReference x, MethodReference y, TypeComparisonMode comparisonMode);
    public static int GetHashCodeFor(MethodReference obj);
}
public class Mono.Cecil.MethodReturnType : object {
    internal IMethodSignature method;
    internal ParameterDefinition parameter;
    private TypeReference return_type;
    public IMethodSignature Method { get; }
    public TypeReference ReturnType { get; public set; }
    internal ParameterDefinition Parameter { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ParameterAttributes Attributes { get; public set; }
    public string Name { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasDefault { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public MethodReturnType(IMethodSignature method);
    public IMethodSignature get_Method();
    public TypeReference get_ReturnType();
    public void set_ReturnType(TypeReference value);
    internal ParameterDefinition get_Parameter();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public string get_Name();
    public void set_Name(string value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
}
[FlagsAttribute]
public enum Mono.Cecil.MethodSemanticsAttributes : Enum {
    public ushort value__;
    public static MethodSemanticsAttributes None;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
internal class Mono.Cecil.MethodSemanticsTable : SortedTable`1<Row`3<MethodSemanticsAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<MethodSemanticsAttributes, UInt32, UInt32> x, Row`3<MethodSemanticsAttributes, UInt32, UInt32> y);
}
public abstract class Mono.Cecil.MethodSpecification : MethodReference {
    private MethodReference method;
    public MethodReference ElementMethod { get; }
    public string Name { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public ModuleDefinition Module { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool ContainsGenericParameter { get; }
    internal MethodSpecification(MethodReference method);
    public MethodReference get_ElementMethod();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual ModuleDefinition get_Module();
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    public virtual bool get_ContainsGenericParameter();
    public sealed virtual MethodReference GetElementMethod();
}
internal class Mono.Cecil.MethodSpecTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MethodTable : MetadataTable`1<Row`6<UInt32, MethodImplAttributes, MethodAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Mixin : object {
    public static Version ZeroVersion;
    public static int NotResolvedMarker;
    public static int NoDataMarker;
    internal static object NoValue;
    internal static object NotResolved;
    public static string mscorlib;
    public static string system_runtime;
    public static string system_private_corelib;
    public static string netstandard;
    public static int TableCount;
    public static int CodedIndexCount;
    private static Mixin();
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] self);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Collection`1<T> self);
    [ExtensionAttribute]
public static T[] Resize(T[] self, int length);
    [ExtensionAttribute]
public static T[] Add(T[] self, T item);
    public static Version CheckVersion(Version version);
    [ExtensionAttribute]
public static bool TryGetUniqueDocument(MethodDebugInformation info, Document& document);
    [ExtensionAttribute]
public static void ResolveConstant(IConstantProvider self, Object& constant, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasCustomAttributes(ICustomAttributeProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool ContainsGenericParameter(IGenericInstance self);
    [ExtensionAttribute]
public static void GenericInstanceFullName(IGenericInstance self, StringBuilder builder);
    [ExtensionAttribute]
public static bool GetHasGenericParameters(IGenericParameterProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<GenericParameter> GetGenericParameters(IGenericParameterProvider self, Collection`1& collection, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasMarshalInfo(IMarshalInfoProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static MarshalInfo GetMarshalInfo(IMarshalInfoProvider self, MarshalInfo& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetAttributes(UInt32 self, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetAttributes(UInt32 self, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetAttributes(ushort self, ushort attributes);
    [ExtensionAttribute]
public static ushort SetAttributes(ushort self, ushort attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(ushort self, ushort mask, UInt32 attributes);
    [ExtensionAttribute]
public static ushort SetMaskedAttributes(ushort self, ushort mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool HasImplicitThis(IMethodSignature self);
    [ExtensionAttribute]
public static void MethodSignatureFullName(IMethodSignature self, StringBuilder builder);
    public static void CheckModule(ModuleDefinition module);
    [ExtensionAttribute]
public static bool TryGetAssemblyNameReference(ModuleDefinition module, AssemblyNameReference name_reference, AssemblyNameReference& assembly_reference);
    private static bool Equals(Byte[] a, Byte[] b);
    private static bool Equals(T a, T b);
    private static bool Equals(AssemblyNameReference a, AssemblyNameReference b);
    [ExtensionAttribute]
public static ParameterDefinition GetParameter(MethodBody self, int index);
    [ExtensionAttribute]
public static VariableDefinition GetVariable(MethodBody self, int index);
    [ExtensionAttribute]
public static bool GetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics);
    [ExtensionAttribute]
public static void SetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics, bool value);
    [ExtensionAttribute]
public static bool IsVarArg(IMethodSignature self);
    [ExtensionAttribute]
public static int GetSentinelPosition(IMethodSignature self);
    public static void CheckName(object name);
    public static void CheckName(string name);
    public static void CheckFileName(string fileName);
    public static void CheckFullName(string fullName);
    public static void CheckStream(object stream);
    public static void CheckWriteSeek(Stream stream);
    public static void CheckReadSeek(Stream stream);
    public static void CheckType(object type);
    public static void CheckType(object type, Argument argument);
    public static void CheckField(object field);
    public static void CheckMethod(object method);
    public static void CheckParameters(object parameters);
    public static UInt32 GetTimestamp();
    [ExtensionAttribute]
public static bool HasImage(ModuleDefinition self);
    [ExtensionAttribute]
public static string GetFileName(Stream self);
    [ExtensionAttribute]
public static TargetRuntime ParseRuntime(string self);
    [ExtensionAttribute]
public static string RuntimeVersionString(TargetRuntime runtime);
    [ExtensionAttribute]
public static bool IsWindowsMetadata(ModuleDefinition module);
    [ExtensionAttribute]
public static Byte[] ReadAll(Stream self);
    public static void Read(object o);
    [ExtensionAttribute]
public static bool GetHasSecurityDeclarations(ISecurityDeclarationProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<SecurityDeclaration> GetSecurityDeclarations(ISecurityDeclarationProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
    [ExtensionAttribute]
public static TypeDefinition GetNestedType(TypeDefinition self, string fullname);
    [ExtensionAttribute]
public static bool IsPrimitive(ElementType self);
    [ExtensionAttribute]
public static string TypeFullName(TypeReference self);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference self, string namespace, string name);
    [ExtensionAttribute]
public static bool IsTypeSpecification(TypeReference type);
    [ExtensionAttribute]
public static TypeDefinition CheckedResolve(TypeReference self);
    [ExtensionAttribute]
public static bool TryGetCoreLibraryReference(ModuleDefinition module, AssemblyNameReference& reference);
    [ExtensionAttribute]
public static bool IsCoreLibrary(ModuleDefinition module);
    [ExtensionAttribute]
public static void KnownValueType(TypeReference type);
    private static bool IsCoreLibrary(AssemblyNameReference reference);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetCodeViewEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetDeterministicEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeader AddDeterministicEntry(ImageDebugHeader header);
    [ExtensionAttribute]
public static ImageDebugHeaderEntry GetEmbeddedPortablePdbEntry(ImageDebugHeader header);
    [ExtensionAttribute]
private static ImageDebugHeaderEntry GetEntry(ImageDebugHeader header, ImageDebugType type);
    public static string GetPdbFileName(string assemblyFileName);
    public static string GetMdbFileName(string assemblyFileName);
    public static bool IsPortablePdb(string fileName);
    public static bool IsPortablePdb(Stream stream);
    [ExtensionAttribute]
public static UInt32 ReadCompressedUInt32(Byte[] data, Int32& position);
    [ExtensionAttribute]
public static MetadataToken GetMetadataToken(CodedIndex self, UInt32 data);
    [ExtensionAttribute]
public static UInt32 CompressMetadataToken(CodedIndex self, MetadataToken token);
    [ExtensionAttribute]
public static int GetSize(CodedIndex self, Func`2<Table, int> counter);
    [ExtensionAttribute]
public static RSA CreateRSA(WriterParameters writer_parameters);
    private static bool TryGetKeyContainer(ISerializable key_pair, Byte[]& key, String& key_container);
}
[FlagsAttribute]
public enum Mono.Cecil.ModuleAttributes : Enum {
    public int value__;
    public static ModuleAttributes ILOnly;
    public static ModuleAttributes Required32Bit;
    public static ModuleAttributes ILLibrary;
    public static ModuleAttributes StrongNameSigned;
    public static ModuleAttributes Preferred32Bit;
}
[FlagsAttribute]
public enum Mono.Cecil.ModuleCharacteristics : Enum {
    public int value__;
    public static ModuleCharacteristics HighEntropyVA;
    public static ModuleCharacteristics DynamicBase;
    public static ModuleCharacteristics NoSEH;
    public static ModuleCharacteristics NXCompat;
    public static ModuleCharacteristics AppContainer;
    public static ModuleCharacteristics TerminalServerAware;
}
public class Mono.Cecil.ModuleDefinition : ModuleReference {
    internal Image Image;
    internal MetadataSystem MetadataSystem;
    internal ReadingMode ReadingMode;
    internal ISymbolReaderProvider SymbolReaderProvider;
    internal ISymbolReader symbol_reader;
    internal Disposable`1<IAssemblyResolver> assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    internal TypeSystem type_system;
    internal MetadataReader reader;
    private string file_name;
    internal string runtime_version;
    internal ModuleKind kind;
    private WindowsRuntimeProjections projections;
    private MetadataKind metadata_kind;
    private TargetRuntime runtime;
    private TargetArchitecture architecture;
    private ModuleAttributes attributes;
    private ModuleCharacteristics characteristics;
    private Guid mvid;
    internal ushort linker_version;
    internal ushort subsystem_major;
    internal ushort subsystem_minor;
    internal UInt32 timestamp;
    internal AssemblyDefinition assembly;
    private MethodDefinition entry_point;
    internal IReflectionImporter reflection_importer;
    internal IMetadataImporter metadata_importer;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<AssemblyNameReference> references;
    private Collection`1<ModuleReference> modules;
    private Collection`1<Resource> resources;
    private Collection`1<ExportedType> exported_types;
    private TypeDefinitionCollection types;
    internal Collection`1<CustomDebugInformation> custom_infos;
    internal MetadataBuilder metadata_builder;
    private object module_lock;
    public bool IsMain { get; }
    public ModuleKind Kind { get; public set; }
    public MetadataKind MetadataKind { get; public set; }
    internal WindowsRuntimeProjections Projections { get; }
    public TargetRuntime Runtime { get; public set; }
    public string RuntimeVersion { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public ModuleAttributes Attributes { get; public set; }
    public ModuleCharacteristics Characteristics { get; public set; }
    [ObsoleteAttribute("Use FileName")]
public string FullyQualifiedName { get; }
    public string FileName { get; }
    public Guid Mvid { get; public set; }
    internal bool HasImage { get; }
    public bool HasSymbols { get; }
    public ISymbolReader SymbolReader { get; }
    public MetadataScopeType MetadataScopeType { get; }
    public AssemblyDefinition Assembly { get; }
    internal IReflectionImporter ReflectionImporter { get; }
    internal IMetadataImporter MetadataImporter { get; }
    public IAssemblyResolver AssemblyResolver { get; }
    public IMetadataResolver MetadataResolver { get; }
    public TypeSystem TypeSystem { get; }
    public bool HasAssemblyReferences { get; }
    public Collection`1<AssemblyNameReference> AssemblyReferences { get; }
    public bool HasModuleReferences { get; }
    public Collection`1<ModuleReference> ModuleReferences { get; }
    public bool HasResources { get; }
    public Collection`1<Resource> Resources { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasTypes { get; }
    public Collection`1<TypeDefinition> Types { get; }
    public bool HasExportedTypes { get; }
    public Collection`1<ExportedType> ExportedTypes { get; }
    public MethodDefinition EntryPoint { get; public set; }
    public bool HasCustomDebugInformations { get; }
    public Collection`1<CustomDebugInformation> CustomDebugInformations { get; }
    internal object SyncRoot { get; }
    public bool HasDebugHeader { get; }
    internal ModuleDefinition(Image image);
    public bool get_IsMain();
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public MetadataKind get_MetadataKind();
    public void set_MetadataKind(MetadataKind value);
    internal WindowsRuntimeProjections get_Projections();
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public string get_RuntimeVersion();
    public void set_RuntimeVersion(string value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public ModuleAttributes get_Attributes();
    public void set_Attributes(ModuleAttributes value);
    public ModuleCharacteristics get_Characteristics();
    public void set_Characteristics(ModuleCharacteristics value);
    public string get_FullyQualifiedName();
    public string get_FileName();
    public Guid get_Mvid();
    public void set_Mvid(Guid value);
    internal bool get_HasImage();
    public bool get_HasSymbols();
    public ISymbolReader get_SymbolReader();
    public virtual MetadataScopeType get_MetadataScopeType();
    public AssemblyDefinition get_Assembly();
    internal IReflectionImporter get_ReflectionImporter();
    internal IMetadataImporter get_MetadataImporter();
    public IAssemblyResolver get_AssemblyResolver();
    public IMetadataResolver get_MetadataResolver();
    public TypeSystem get_TypeSystem();
    public bool get_HasAssemblyReferences();
    public Collection`1<AssemblyNameReference> get_AssemblyReferences();
    public bool get_HasModuleReferences();
    public Collection`1<ModuleReference> get_ModuleReferences();
    public bool get_HasResources();
    public Collection`1<Resource> get_Resources();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasTypes();
    public Collection`1<TypeDefinition> get_Types();
    public bool get_HasExportedTypes();
    public Collection`1<ExportedType> get_ExportedTypes();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomDebugInformations();
    public sealed virtual Collection`1<CustomDebugInformation> get_CustomDebugInformations();
    public sealed virtual void Dispose();
    public bool HasTypeReference(string fullName);
    public bool HasTypeReference(string scope, string fullName);
    public bool TryGetTypeReference(string fullName, TypeReference& type);
    public bool TryGetTypeReference(string scope, string fullName, TypeReference& type);
    private TypeReference GetTypeReference(string scope, string fullname);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    public IEnumerable`1<CustomAttribute> GetCustomAttributes();
    public TypeReference GetType(string fullName, bool runtimeName);
    public TypeDefinition GetType(string fullName);
    public TypeDefinition GetType(string namespace, string name);
    public IEnumerable`1<TypeDefinition> GetTypes();
    [IteratorStateMachineAttribute("Mono.Cecil.ModuleDefinition/<GetTypes>d__133")]
private static IEnumerable`1<TypeDefinition> GetTypes(Collection`1<TypeDefinition> types);
    private TypeDefinition GetNestedType(string fullname);
    internal FieldDefinition Resolve(FieldReference field);
    internal MethodDefinition Resolve(MethodReference method);
    internal TypeDefinition Resolve(TypeReference type);
    private static void CheckContext(IGenericParameterProvider context, ModuleDefinition module);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(Type type);
    public TypeReference ImportReference(Type type);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(Type type, IGenericParameterProvider context);
    public TypeReference ImportReference(Type type, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldInfo field);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldInfo field, IGenericParameterProvider context);
    public FieldReference ImportReference(FieldInfo field);
    public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodBase method);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodBase method, IGenericParameterProvider context);
    public MethodReference ImportReference(MethodBase method);
    public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(TypeReference type);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(TypeReference type, IGenericParameterProvider context);
    public TypeReference ImportReference(TypeReference type);
    public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldReference field);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldReference field, IGenericParameterProvider context);
    public FieldReference ImportReference(FieldReference field);
    public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodReference method);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodReference method, IGenericParameterProvider context);
    public MethodReference ImportReference(MethodReference method);
    public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
    public IMetadataTokenProvider LookupToken(int token);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    internal object get_SyncRoot();
    internal void Read(TItem item, Action`2<TItem, MetadataReader> read);
    internal TRet Read(TItem item, Func`3<TItem, MetadataReader, TRet> read);
    internal TRet Read(TRet& variable, TItem item, Func`3<TItem, MetadataReader, TRet> read);
    public bool get_HasDebugHeader();
    public ImageDebugHeader GetDebugHeader();
    public static ModuleDefinition CreateModule(string name, ModuleKind kind);
    public static ModuleDefinition CreateModule(string name, ModuleParameters parameters);
    private static AssemblyNameDefinition CreateAssemblyName(string name);
    public void ReadSymbols();
    public void ReadSymbols(ISymbolReader reader);
    public void ReadSymbols(ISymbolReader reader, bool throwIfSymbolsAreNotMaching);
    public static ModuleDefinition ReadModule(string fileName);
    public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters);
    private static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share);
    public static ModuleDefinition ReadModule(Stream stream);
    public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters);
    private static ModuleDefinition ReadModule(Disposable`1<Stream> stream, string fileName, ReaderParameters parameters);
    public void Write(string fileName);
    public void Write(string fileName, WriterParameters parameters);
    public void Write();
    public void Write(WriterParameters parameters);
    public void Write(Stream stream);
    public void Write(Stream stream, WriterParameters parameters);
}
public enum Mono.Cecil.ModuleKind : Enum {
    public int value__;
    public static ModuleKind Dll;
    public static ModuleKind Console;
    public static ModuleKind Windows;
    public static ModuleKind NetModule;
}
public class Mono.Cecil.ModuleParameters : object {
    private ModuleKind kind;
    private TargetRuntime runtime;
    private Nullable`1<UInt32> timestamp;
    private TargetArchitecture architecture;
    private IAssemblyResolver assembly_resolver;
    private IMetadataResolver metadata_resolver;
    private IMetadataImporterProvider metadata_importer_provider;
    private IReflectionImporterProvider reflection_importer_provider;
    public ModuleKind Kind { get; public set; }
    public TargetRuntime Runtime { get; public set; }
    public Nullable`1<UInt32> Timestamp { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public IMetadataImporterProvider MetadataImporterProvider { get; public set; }
    public IReflectionImporterProvider ReflectionImporterProvider { get; public set; }
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public Nullable`1<UInt32> get_Timestamp();
    public void set_Timestamp(Nullable`1<UInt32> value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public IMetadataImporterProvider get_MetadataImporterProvider();
    public void set_MetadataImporterProvider(IMetadataImporterProvider value);
    public IReflectionImporterProvider get_ReflectionImporterProvider();
    public void set_ReflectionImporterProvider(IReflectionImporterProvider value);
    private static TargetRuntime GetCurrentRuntime();
}
internal abstract class Mono.Cecil.ModuleReader : object {
    protected ModuleDefinition module;
    protected ModuleReader(Image image, ReadingMode mode);
    protected abstract virtual void ReadModule();
    public abstract virtual void ReadSymbols(ModuleDefinition module);
    protected void ReadModuleManifest(MetadataReader reader);
    private void ReadAssembly(MetadataReader reader);
    public static ModuleDefinition CreateModule(Image image, ReaderParameters parameters);
    private static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters);
    private static void GetMetadataKind(ModuleDefinition module, ReaderParameters parameters);
    private static ModuleReader CreateModuleReader(Image image, ReadingMode mode);
}
public class Mono.Cecil.ModuleReference : object {
    private string name;
    internal MetadataToken token;
    public string Name { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ModuleReference(string name);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public virtual MetadataScopeType get_MetadataScopeType();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.ModuleRefTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.ModuleTable : OneRowTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal static class Mono.Cecil.ModuleWriter : object {
    public static void WriteModule(ModuleDefinition module, Disposable`1<Stream> stream, WriterParameters parameters);
    private static void Write(ModuleDefinition module, Disposable`1<Stream> stream, WriterParameters parameters);
    private static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata);
    private static ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, WriterParameters parameters);
}
public enum Mono.Cecil.NativeType : Enum {
    public int value__;
    public static NativeType None;
    public static NativeType Boolean;
    public static NativeType I1;
    public static NativeType U1;
    public static NativeType I2;
    public static NativeType U2;
    public static NativeType I4;
    public static NativeType U4;
    public static NativeType I8;
    public static NativeType U8;
    public static NativeType R4;
    public static NativeType R8;
    public static NativeType LPStr;
    public static NativeType Int;
    public static NativeType UInt;
    public static NativeType Func;
    public static NativeType Array;
    public static NativeType Currency;
    public static NativeType BStr;
    public static NativeType LPWStr;
    public static NativeType LPTStr;
    public static NativeType FixedSysString;
    public static NativeType IUnknown;
    public static NativeType IDispatch;
    public static NativeType Struct;
    public static NativeType IntF;
    public static NativeType SafeArray;
    public static NativeType FixedArray;
    public static NativeType ByValStr;
    public static NativeType ANSIBStr;
    public static NativeType TBStr;
    public static NativeType VariantBool;
    public static NativeType ASAny;
    public static NativeType LPStruct;
    public static NativeType CustomMarshaler;
    public static NativeType Error;
    public static NativeType Max;
}
internal class Mono.Cecil.NestedClassTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal abstract class Mono.Cecil.OneRowTable`1 : MetadataTable {
    internal TRow row;
    public int Length { get; }
    public sealed virtual int get_Length();
    public sealed virtual void Sort();
}
public class Mono.Cecil.OptionalModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsOptionalModifier { get; }
    public bool ContainsGenericParameter { get; }
    public OptionalModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_ContainsGenericParameter();
}
[FlagsAttribute]
public enum Mono.Cecil.ParameterAttributes : Enum {
    public ushort value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Unused;
}
public class Mono.Cecil.ParameterDefinition : ParameterReference {
    private ushort attributes;
    internal IMethodSignature method;
    private object constant;
    private Collection`1<CustomAttribute> custom_attributes;
    private MarshalInfo marshal_info;
    public ParameterAttributes Attributes { get; public set; }
    public IMethodSignature Method { get; }
    public int Sequence { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public bool IsIn { get; public set; }
    public bool IsOut { get; public set; }
    public bool IsLcid { get; public set; }
    public bool IsReturnValue { get; public set; }
    public bool IsOptional { get; public set; }
    public bool HasDefault { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    internal ParameterDefinition(TypeReference parameterType, IMethodSignature method);
    public ParameterDefinition(TypeReference parameterType);
    public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public IMethodSignature get_Method();
    public int get_Sequence();
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsIn();
    public void set_IsIn(bool value);
    public bool get_IsOut();
    public void set_IsOut(bool value);
    public bool get_IsLcid();
    public void set_IsLcid(bool value);
    public bool get_IsReturnValue();
    public void set_IsReturnValue(bool value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParameterDefinitionCollection : Collection`1<ParameterDefinition> {
    private IMethodSignature method;
    internal ParameterDefinitionCollection(IMethodSignature method);
    internal ParameterDefinitionCollection(IMethodSignature method, int capacity);
    protected virtual void OnAdd(ParameterDefinition item, int index);
    protected virtual void OnInsert(ParameterDefinition item, int index);
    protected virtual void OnSet(ParameterDefinition item, int index);
    protected virtual void OnRemove(ParameterDefinition item, int index);
}
public abstract class Mono.Cecil.ParameterReference : object {
    private string name;
    internal int index;
    protected TypeReference parameter_type;
    internal MetadataToken token;
    public string Name { get; public set; }
    public int Index { get; }
    public TypeReference ParameterType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    internal ParameterReference(string name, TypeReference parameterType);
    public string get_Name();
    public void set_Name(string value);
    public int get_Index();
    public TypeReference get_ParameterType();
    public void set_ParameterType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
    public abstract virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParamTable : MetadataTable`1<Row`3<ParameterAttributes, ushort, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.PE.BinaryStreamReader : BinaryReader {
    public int Position { get; public set; }
    public int Length { get; }
    public BinaryStreamReader(Stream stream);
    public int get_Position();
    public void set_Position(int value);
    public int get_Length();
    public void Advance(int bytes);
    public void MoveTo(UInt32 position);
    public void Align(int align);
    public DataDirectory ReadDataDirectory();
}
internal class Mono.Cecil.PE.BinaryStreamWriter : BinaryWriter {
    public int Position { get; public set; }
    public BinaryStreamWriter(Stream stream);
    public int get_Position();
    public void set_Position(int value);
    public void WriteByte(byte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteBytes(Byte[] bytes);
    public void WriteDataDirectory(DataDirectory directory);
    public void WriteBuffer(ByteBuffer buffer);
    protected void Advance(int bytes);
    public void Align(int align);
}
internal class Mono.Cecil.PE.ByteBuffer : object {
    internal Byte[] buffer;
    internal int length;
    internal int position;
    public ByteBuffer(int length);
    public ByteBuffer(Byte[] buffer);
    public void Advance(int length);
    public byte ReadByte();
    public sbyte ReadSByte();
    public Byte[] ReadBytes(int length);
    public ushort ReadUInt16();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public int ReadInt32();
    public ulong ReadUInt64();
    public long ReadInt64();
    public UInt32 ReadCompressedUInt32();
    public int ReadCompressedInt32();
    public float ReadSingle();
    public double ReadDouble();
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteInt64(long value);
    public void WriteCompressedUInt32(UInt32 value);
    public void WriteCompressedInt32(int value);
    public void WriteBytes(Byte[] bytes);
    public void WriteBytes(int length);
    public void WriteBytes(ByteBuffer buffer);
    public void WriteSingle(float value);
    public void WriteDouble(double value);
    private void Grow(int desired);
}
internal class Mono.Cecil.PE.ByteBufferEqualityComparer : object {
    public sealed virtual bool Equals(ByteBuffer x, ByteBuffer y);
    public sealed virtual int GetHashCode(ByteBuffer buffer);
}
internal class Mono.Cecil.PE.DataDirectory : ValueType {
    public UInt32 VirtualAddress;
    public UInt32 Size;
    public bool IsZero { get; }
    public DataDirectory(UInt32 rva, UInt32 size);
    public bool get_IsZero();
}
internal class Mono.Cecil.PE.Image : object {
    public Disposable`1<Stream> Stream;
    public string FileName;
    public ModuleKind Kind;
    public string RuntimeVersion;
    public TargetArchitecture Architecture;
    public ModuleCharacteristics Characteristics;
    public ushort LinkerVersion;
    public ushort SubSystemMajor;
    public ushort SubSystemMinor;
    public ImageDebugHeader DebugHeader;
    public Section[] Sections;
    public Section MetadataSection;
    public UInt32 EntryPointToken;
    public UInt32 Timestamp;
    public ModuleAttributes Attributes;
    public DataDirectory Win32Resources;
    public DataDirectory Debug;
    public DataDirectory Resources;
    public DataDirectory StrongName;
    public StringHeap StringHeap;
    public BlobHeap BlobHeap;
    public UserStringHeap UserStringHeap;
    public GuidHeap GuidHeap;
    public TableHeap TableHeap;
    public PdbHeap PdbHeap;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    public bool HasTable(Table table);
    public int GetTableLength(Table table);
    public int GetTableIndexSize(Table table);
    public int GetCodedIndexSize(CodedIndex coded_index);
    public UInt32 ResolveVirtualAddress(UInt32 rva);
    public UInt32 ResolveVirtualAddressInSection(UInt32 rva, Section section);
    public Section GetSection(string name);
    public Section GetSectionAtVirtualAddress(UInt32 rva);
    private BinaryStreamReader GetReaderAt(UInt32 rva);
    public TRet GetReaderAt(UInt32 rva, TItem item, Func`3<TItem, BinaryStreamReader, TRet> read);
    public bool HasDebugTables();
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.PE.ImageReader : BinaryStreamReader {
    private Image image;
    private DataDirectory cli;
    private DataDirectory metadata;
    private UInt32 table_heap_offset;
    public ImageReader(Disposable`1<Stream> stream, string file_name);
    private void MoveTo(DataDirectory directory);
    private void ReadImage();
    private TargetArchitecture ReadArchitecture();
    private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem);
    private void ReadOptionalHeaders(UInt16& subsystem, UInt16& dll_characteristics);
    private string ReadAlignedString(int length);
    private string ReadZeroTerminatedString(int length);
    private void ReadSections(ushort count);
    private void ReadCLIHeader();
    private void ReadMetadata();
    private void ReadDebugHeader();
    private void ReadMetadataStream(Section section);
    private Byte[] ReadHeapData(UInt32 offset, UInt32 size);
    private void ReadTableHeap();
    private static void SetIndexSize(Heap heap, UInt32 sizes, byte flag);
    private int GetTableIndexSize(Table table);
    private int GetCodedIndexSize(CodedIndex index);
    private void ComputeTableInformations();
    private void ReadPdbHeap();
    public static Image ReadImage(Disposable`1<Stream> stream, string file_name);
    public static Image ReadPortablePdb(Disposable`1<Stream> stream, string file_name);
}
internal class Mono.Cecil.PE.ImageWriter : BinaryStreamWriter {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    private TextMap text_map;
    internal Disposable`1<Stream> stream;
    private string runtime_version;
    private ImageDebugHeader debug_header;
    private ByteBuffer win32_resources;
    private static UInt32 pe_header_size;
    private static UInt32 section_header_size;
    private static UInt32 file_alignment;
    private static UInt32 section_alignment;
    private static ulong image_base;
    internal static UInt32 text_rva;
    private bool pe64;
    private bool has_reloc;
    internal Section text;
    internal Section rsrc;
    internal Section reloc;
    private ushort sections;
    private ImageWriter(ModuleDefinition module, string runtime_version, MetadataBuilder metadata, Disposable`1<Stream> stream, bool metadataOnly);
    private void GetDebugHeader();
    private void GetWin32Resources();
    public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable`1<Stream> stream);
    public static ImageWriter CreateDebugWriter(ModuleDefinition module, MetadataBuilder metadata, Disposable`1<Stream> stream);
    private void BuildSections();
    private Section CreateSection(string name, UInt32 size, Section previous);
    private static UInt32 Align(UInt32 value, UInt32 align);
    private void WriteDOSHeader();
    private ushort SizeOfOptionalHeader();
    private void WritePEFileHeader();
    private Section LastSection();
    private void WriteOptionalHeaders();
    private void WriteZeroDataDirectory();
    private ushort GetSubSystem();
    private void WriteSectionHeaders();
    private void WriteSection(Section section, UInt32 characteristics);
    private UInt32 GetRVAFileOffset(Section section, UInt32 rva);
    private void MoveTo(UInt32 pointer);
    private void MoveToRVA(Section section, UInt32 rva);
    private void MoveToRVA(TextSegment segment);
    private void WriteRVA(UInt32 rva);
    private void PrepareSection(Section section);
    private void WriteText();
    private UInt32 GetMetadataLength();
    public void WriteMetadataHeader();
    private ushort GetStreamCount();
    private void WriteStreamHeader(UInt32& offset, TextSegment heap, string name);
    private static int GetZeroTerminatedStringLength(string string);
    private static Byte[] GetZeroTerminatedString(string string);
    private static Byte[] GetSimpleString(string string);
    private static Byte[] GetString(string string, int length);
    public void WriteMetadata();
    private void WriteHeap(TextSegment heap, HeapBuffer buffer);
    private void WriteDebugDirectory();
    private void WriteImportDirectory();
    private Byte[] GetRuntimeMain();
    private void WriteStartupStub();
    private void WriteRsrc();
    private void WriteReloc();
    public void WriteImage();
    private void BuildTextMap();
    public void BuildMetadataTextMap();
    private UInt32 GetStartupStubLength();
    private int GetMetadataHeaderLength(string runtimeVersion);
    private int GetStrongNameLength();
    public DataDirectory GetStrongNameSignatureDirectory();
    public UInt32 GetHeaderSize();
    private void PatchWin32Resources(ByteBuffer resources);
    private void PatchResourceDirectoryTable(ByteBuffer resources);
    private void PatchResourceDirectoryEntry(ByteBuffer resources);
    private void PatchResourceDataEntry(ByteBuffer resources);
}
internal class Mono.Cecil.PE.Section : object {
    public string Name;
    public UInt32 VirtualAddress;
    public UInt32 VirtualSize;
    public UInt32 SizeOfRawData;
    public UInt32 PointerToRawData;
}
internal class Mono.Cecil.PE.TextMap : object {
    private Range[] map;
    public void AddMap(TextSegment segment, int length);
    public void AddMap(TextSegment segment, int length, int align);
    public void AddMap(TextSegment segment, Range range);
    public Range GetRange(TextSegment segment);
    public DataDirectory GetDataDirectory(TextSegment segment);
    public UInt32 GetRVA(TextSegment segment);
    public UInt32 GetNextRVA(TextSegment segment);
    public int GetLength(TextSegment segment);
    private UInt32 GetStart(TextSegment segment);
    private UInt32 ComputeStart(int index);
    public UInt32 GetLength();
}
internal enum Mono.Cecil.PE.TextSegment : Enum {
    public int value__;
    public static TextSegment ImportAddressTable;
    public static TextSegment CLIHeader;
    public static TextSegment Code;
    public static TextSegment Resources;
    public static TextSegment Data;
    public static TextSegment StrongNameSignature;
    public static TextSegment MetadataHeader;
    public static TextSegment TableHeap;
    public static TextSegment StringHeap;
    public static TextSegment UserStringHeap;
    public static TextSegment GuidHeap;
    public static TextSegment BlobHeap;
    public static TextSegment PdbHeap;
    public static TextSegment DebugDirectory;
    public static TextSegment ImportDirectory;
    public static TextSegment ImportHintNameTable;
    public static TextSegment StartupStub;
}
public class Mono.Cecil.PinnedType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsPinned { get; }
    public PinnedType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPinned();
}
[FlagsAttribute]
public enum Mono.Cecil.PInvokeAttributes : Enum {
    public ushort value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdCall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
}
public class Mono.Cecil.PInvokeInfo : object {
    private ushort attributes;
    private string entry_point;
    private ModuleReference module;
    public PInvokeAttributes Attributes { get; public set; }
    public string EntryPoint { get; public set; }
    public ModuleReference Module { get; public set; }
    public bool IsNoMangle { get; public set; }
    public bool IsCharSetNotSpec { get; public set; }
    public bool IsCharSetAnsi { get; public set; }
    public bool IsCharSetUnicode { get; public set; }
    public bool IsCharSetAuto { get; public set; }
    public bool SupportsLastError { get; public set; }
    public bool IsCallConvWinapi { get; public set; }
    public bool IsCallConvCdecl { get; public set; }
    public bool IsCallConvStdCall { get; public set; }
    public bool IsCallConvThiscall { get; public set; }
    public bool IsCallConvFastcall { get; public set; }
    public bool IsBestFitEnabled { get; public set; }
    public bool IsBestFitDisabled { get; public set; }
    public bool IsThrowOnUnmappableCharEnabled { get; public set; }
    public bool IsThrowOnUnmappableCharDisabled { get; public set; }
    public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module);
    public PInvokeAttributes get_Attributes();
    public void set_Attributes(PInvokeAttributes value);
    public string get_EntryPoint();
    public void set_EntryPoint(string value);
    public ModuleReference get_Module();
    public void set_Module(ModuleReference value);
    public bool get_IsNoMangle();
    public void set_IsNoMangle(bool value);
    public bool get_IsCharSetNotSpec();
    public void set_IsCharSetNotSpec(bool value);
    public bool get_IsCharSetAnsi();
    public void set_IsCharSetAnsi(bool value);
    public bool get_IsCharSetUnicode();
    public void set_IsCharSetUnicode(bool value);
    public bool get_IsCharSetAuto();
    public void set_IsCharSetAuto(bool value);
    public bool get_SupportsLastError();
    public void set_SupportsLastError(bool value);
    public bool get_IsCallConvWinapi();
    public void set_IsCallConvWinapi(bool value);
    public bool get_IsCallConvCdecl();
    public void set_IsCallConvCdecl(bool value);
    public bool get_IsCallConvStdCall();
    public void set_IsCallConvStdCall(bool value);
    public bool get_IsCallConvThiscall();
    public void set_IsCallConvThiscall(bool value);
    public bool get_IsCallConvFastcall();
    public void set_IsCallConvFastcall(bool value);
    public bool get_IsBestFitEnabled();
    public void set_IsBestFitEnabled(bool value);
    public bool get_IsBestFitDisabled();
    public void set_IsBestFitDisabled(bool value);
    public bool get_IsThrowOnUnmappableCharEnabled();
    public void set_IsThrowOnUnmappableCharEnabled(bool value);
    public bool get_IsThrowOnUnmappableCharDisabled();
    public void set_IsThrowOnUnmappableCharDisabled(bool value);
}
public class Mono.Cecil.PointerType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsPointer { get; }
    public PointerType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPointer();
}
[FlagsAttribute]
public enum Mono.Cecil.PropertyAttributes : Enum {
    public ushort value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Unused;
}
public class Mono.Cecil.PropertyDefinition : PropertyReference {
    private Nullable`1<bool> has_this;
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition get_method;
    internal MethodDefinition set_method;
    internal Collection`1<MethodDefinition> other_methods;
    private object constant;
    public PropertyAttributes Attributes { get; public set; }
    public bool HasThis { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MethodDefinition GetMethod { get; public set; }
    public MethodDefinition SetMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public string FullName { get; }
    public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType);
    public PropertyAttributes get_Attributes();
    public void set_Attributes(PropertyAttributes value);
    public bool get_HasThis();
    public void set_HasThis(bool value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public MethodDefinition get_GetMethod();
    public void set_GetMethod(MethodDefinition value);
    public MethodDefinition get_SetMethod();
    public void set_SetMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private static Collection`1<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    public virtual string get_FullName();
    private void InitializeMethods();
    public virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.PropertyReference : MemberReference {
    private TypeReference property_type;
    public TypeReference PropertyType { get; public set; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    internal PropertyReference(string name, TypeReference propertyType);
    public TypeReference get_PropertyType();
    public void set_PropertyType(TypeReference value);
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    protected virtual IMemberDefinition ResolveDefinition();
    public abstract virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyTable : MetadataTable`1<Row`3<PropertyAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Range : ValueType {
    public UInt32 Start;
    public UInt32 Length;
    public Range(UInt32 index, UInt32 length);
}
public class Mono.Cecil.ReaderParameters : object {
    private ReadingMode reading_mode;
    internal IAssemblyResolver assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    internal IMetadataImporterProvider metadata_importer_provider;
    internal IReflectionImporterProvider reflection_importer_provider;
    private Stream symbol_stream;
    private ISymbolReaderProvider symbol_reader_provider;
    private bool read_symbols;
    private bool throw_symbols_mismatch;
    private bool projections;
    private bool in_memory;
    private bool read_write;
    public ReadingMode ReadingMode { get; public set; }
    public bool InMemory { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public IMetadataImporterProvider MetadataImporterProvider { get; public set; }
    public IReflectionImporterProvider ReflectionImporterProvider { get; public set; }
    public Stream SymbolStream { get; public set; }
    public ISymbolReaderProvider SymbolReaderProvider { get; public set; }
    public bool ReadSymbols { get; public set; }
    public bool ThrowIfSymbolsAreNotMatching { get; public set; }
    public bool ReadWrite { get; public set; }
    public bool ApplyWindowsRuntimeProjections { get; public set; }
    public ReaderParameters(ReadingMode readingMode);
    public ReadingMode get_ReadingMode();
    public void set_ReadingMode(ReadingMode value);
    public bool get_InMemory();
    public void set_InMemory(bool value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public IMetadataImporterProvider get_MetadataImporterProvider();
    public void set_MetadataImporterProvider(IMetadataImporterProvider value);
    public IReflectionImporterProvider get_ReflectionImporterProvider();
    public void set_ReflectionImporterProvider(IReflectionImporterProvider value);
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolReaderProvider get_SymbolReaderProvider();
    public void set_SymbolReaderProvider(ISymbolReaderProvider value);
    public bool get_ReadSymbols();
    public void set_ReadSymbols(bool value);
    public bool get_ThrowIfSymbolsAreNotMatching();
    public void set_ThrowIfSymbolsAreNotMatching(bool value);
    public bool get_ReadWrite();
    public void set_ReadWrite(bool value);
    public bool get_ApplyWindowsRuntimeProjections();
    public void set_ApplyWindowsRuntimeProjections(bool value);
}
public enum Mono.Cecil.ReadingMode : Enum {
    public int value__;
    public static ReadingMode Immediate;
    public static ReadingMode Deferred;
}
public class Mono.Cecil.RequiredModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsRequiredModifier { get; }
    public bool ContainsGenericParameter { get; }
    public RequiredModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_ContainsGenericParameter();
}
public class Mono.Cecil.ResolutionException : Exception {
    private MemberReference member;
    public MemberReference Member { get; }
    public IMetadataScope Scope { get; }
    public ResolutionException(MemberReference member);
    public ResolutionException(MemberReference member, Exception innerException);
    public MemberReference get_Member();
    public IMetadataScope get_Scope();
}
public abstract class Mono.Cecil.Resource : object {
    private string name;
    private UInt32 attributes;
    public string Name { get; public set; }
    public ManifestResourceAttributes Attributes { get; public set; }
    public ResourceType ResourceType { get; }
    public bool IsPublic { get; public set; }
    public bool IsPrivate { get; public set; }
    internal Resource(string name, ManifestResourceAttributes attributes);
    public string get_Name();
    public void set_Name(string value);
    public ManifestResourceAttributes get_Attributes();
    public void set_Attributes(ManifestResourceAttributes value);
    public abstract virtual ResourceType get_ResourceType();
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
}
public enum Mono.Cecil.ResourceType : Enum {
    public int value__;
    public static ResourceType Linked;
    public static ResourceType Embedded;
    public static ResourceType AssemblyLinked;
}
public class Mono.Cecil.SafeArrayMarshalInfo : MarshalInfo {
    internal VariantType element_type;
    public VariantType ElementType { get; public set; }
    public VariantType get_ElementType();
    public void set_ElementType(VariantType value);
}
public enum Mono.Cecil.SecurityAction : Enum {
    public ushort value__;
    public static SecurityAction Request;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
    public static SecurityAction PreJitGrant;
    public static SecurityAction PreJitDeny;
    public static SecurityAction NonCasDemand;
    public static SecurityAction NonCasLinkDemand;
    public static SecurityAction NonCasInheritance;
}
[DebuggerDisplayAttribute("{AttributeType}")]
public class Mono.Cecil.SecurityAttribute : object {
    private TypeReference attribute_type;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public TypeReference AttributeType { get; public set; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    private bool Mono.Cecil.ICustomAttribute.HasConstructorArguments { get; }
    private Collection`1<CustomAttributeArgument> Mono.Cecil.ICustomAttribute.ConstructorArguments { get; }
    public SecurityAttribute(TypeReference attributeType);
    public sealed virtual TypeReference get_AttributeType();
    public void set_AttributeType(TypeReference value);
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    private sealed virtual override bool Mono.Cecil.ICustomAttribute.get_HasConstructorArguments();
    private sealed virtual override Collection`1<CustomAttributeArgument> Mono.Cecil.ICustomAttribute.get_ConstructorArguments();
}
public class Mono.Cecil.SecurityDeclaration : object {
    internal UInt32 signature;
    private Byte[] blob;
    private ModuleDefinition module;
    internal bool resolved;
    private SecurityAction action;
    internal Collection`1<SecurityAttribute> security_attributes;
    public SecurityAction Action { get; public set; }
    public bool HasSecurityAttributes { get; }
    public Collection`1<SecurityAttribute> SecurityAttributes { get; }
    internal bool HasImage { get; }
    internal SecurityDeclaration(SecurityAction action, UInt32 signature, ModuleDefinition module);
    public SecurityDeclaration(SecurityAction action);
    public SecurityDeclaration(SecurityAction action, Byte[] blob);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public bool get_HasSecurityAttributes();
    public Collection`1<SecurityAttribute> get_SecurityAttributes();
    internal bool get_HasImage();
    public Byte[] GetBlob();
    private void Resolve();
}
public class Mono.Cecil.SentinelType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsSentinel { get; }
    public SentinelType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsSentinel();
}
internal class Mono.Cecil.SignatureReader : ByteBuffer {
    private MetadataReader reader;
    internal UInt32 start;
    internal UInt32 sig_length;
    private TypeSystem TypeSystem { get; }
    public SignatureReader(UInt32 blob, MetadataReader reader);
    private TypeSystem get_TypeSystem();
    private MetadataToken ReadTypeTokenSignature();
    private GenericParameter GetGenericParameter(GenericParameterType type, UInt32 var);
    private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index);
    private static void CheckGenericContext(IGenericParameterProvider owner, int index);
    public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance, UInt32 arity);
    private ArrayType ReadArrayTypeSignature();
    private TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeReference ReadTypeSignature();
    public TypeReference ReadTypeToken();
    private TypeReference ReadTypeSignature(ElementType etype);
    public void ReadMethodSignature(IMethodSignature method);
    public object ReadConstantSignature(ElementType type);
    public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection`1<ParameterDefinition> parameters);
    private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type);
    public void ReadCustomAttributeNamedArguments(ushort count, Collection`1& fields, Collection`1& properties);
    private void ReadCustomAttributeNamedArgument(Collection`1& fields, Collection`1& properties);
    private static Collection`1<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(Collection`1& collection);
    private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type);
    private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type);
    private object ReadCustomAttributeElementValue(TypeReference type);
    private object ReadPrimitiveValue(ElementType type);
    private TypeReference GetPrimitiveType(ElementType etype);
    private TypeReference ReadCustomAttributeFieldOrPropType();
    public TypeReference ReadTypeReference();
    private object ReadCustomAttributeEnum(TypeReference enum_type);
    public SecurityAttribute ReadSecurityAttribute();
    public MarshalInfo ReadMarshalInfo();
    private NativeType ReadNativeType();
    private VariantType ReadVariantType();
    private string ReadUTF8String();
    public string ReadDocumentName();
    public Collection`1<SequencePoint> ReadSequencePoints(Document document);
    public bool CanReadMore();
}
internal class Mono.Cecil.SignatureWriter : ByteBuffer {
    private MetadataBuilder metadata;
    public SignatureWriter(MetadataBuilder metadata);
    public void WriteElementType(ElementType element_type);
    public void WriteUTF8String(string string);
    public void WriteMethodSignature(IMethodSignature method);
    private UInt32 MakeTypeDefOrRefCodedRID(TypeReference type);
    public void WriteTypeToken(TypeReference type);
    public void WriteTypeSignature(TypeReference type);
    private void WriteArrayTypeSignature(ArrayType array);
    public void WriteGenericInstanceSignature(IGenericInstance instance);
    private void WriteModifierSignature(ElementType element_type, IModifierType type);
    private bool TryWriteElementType(TypeReference type);
    public void WriteConstantString(string value);
    public void WriteConstantPrimitive(object value);
    public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute);
    private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument);
    private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeValue(TypeReference type, object value);
    private void WritePrimitiveValue(object value);
    private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value);
    private void WriteCustomAttributeFieldOrPropType(TypeReference type);
    public void WriteCustomAttributeNamedArguments(CustomAttribute attribute);
    private static int GetNamedArgumentCount(ICustomAttribute attribute);
    private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute);
    private void WriteCustomAttributeNamedArguments(byte kind, Collection`1<CustomAttributeNamedArgument> named_arguments);
    private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument);
    private void WriteSecurityAttribute(SecurityAttribute attribute);
    public void WriteSecurityDeclaration(SecurityDeclaration declaration);
    public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration);
    private static string GetXmlSecurityDeclaration(SecurityDeclaration declaration);
    private void WriteTypeReference(TypeReference type);
    public void WriteMarshalInfo(MarshalInfo marshal_info);
    private void WriteNativeType(NativeType native);
    private void WriteVariantType(VariantType variant);
    public void WriteSequencePoints(MethodDebugInformation info);
}
internal abstract class Mono.Cecil.SortedTable`1 : MetadataTable`1<TRow> {
    public sealed virtual void Sort();
    protected static int Compare(UInt32 x, UInt32 y);
    public abstract virtual int Compare(TRow x, TRow y);
}
internal class Mono.Cecil.StandAloneSigTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.StateMachineMethodTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
public enum Mono.Cecil.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture I386;
    public static TargetArchitecture AMD64;
    public static TargetArchitecture IA64;
    public static TargetArchitecture ARM;
    public static TargetArchitecture ARMv7;
    public static TargetArchitecture ARM64;
}
public enum Mono.Cecil.TargetRuntime : Enum {
    public int value__;
    public static TargetRuntime Net_1_0;
    public static TargetRuntime Net_1_1;
    public static TargetRuntime Net_2_0;
    public static TargetRuntime Net_4_0;
}
public enum Mono.Cecil.TokenType : Enum {
    public UInt32 value__;
    public static TokenType Module;
    public static TokenType TypeRef;
    public static TokenType TypeDef;
    public static TokenType Field;
    public static TokenType Method;
    public static TokenType Param;
    public static TokenType InterfaceImpl;
    public static TokenType MemberRef;
    public static TokenType CustomAttribute;
    public static TokenType Permission;
    public static TokenType Signature;
    public static TokenType Event;
    public static TokenType Property;
    public static TokenType ModuleRef;
    public static TokenType TypeSpec;
    public static TokenType Assembly;
    public static TokenType AssemblyRef;
    public static TokenType File;
    public static TokenType ExportedType;
    public static TokenType ManifestResource;
    public static TokenType GenericParam;
    public static TokenType MethodSpec;
    public static TokenType GenericParamConstraint;
    public static TokenType Document;
    public static TokenType MethodDebugInformation;
    public static TokenType LocalScope;
    public static TokenType LocalVariable;
    public static TokenType LocalConstant;
    public static TokenType ImportScope;
    public static TokenType StateMachineMethod;
    public static TokenType CustomDebugInformation;
    public static TokenType String;
}
[FlagsAttribute]
public enum Mono.Cecil.TypeAttributes : Enum {
    public UInt32 value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes Forwarder;
}
internal enum Mono.Cecil.TypeComparisonMode : Enum {
    public int value__;
    public static TypeComparisonMode Exact;
    public static TypeComparisonMode SignatureOnly;
    public static TypeComparisonMode SignatureOnlyLoose;
}
public class Mono.Cecil.TypeDefinition : TypeReference {
    private UInt32 attributes;
    private TypeReference base_type;
    internal Range fields_range;
    internal Range methods_range;
    private short packing_size;
    private int class_size;
    private InterfaceImplementationCollection interfaces;
    private Collection`1<TypeDefinition> nested_types;
    private Collection`1<MethodDefinition> methods;
    private Collection`1<FieldDefinition> fields;
    private Collection`1<EventDefinition> events;
    private Collection`1<PropertyDefinition> properties;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    public TypeAttributes Attributes { get; public set; }
    public TypeReference BaseType { get; public set; }
    public string Name { get; public set; }
    public bool HasLayoutInfo { get; }
    public short PackingSize { get; public set; }
    public int ClassSize { get; public set; }
    public bool HasInterfaces { get; }
    public Collection`1<InterfaceImplementation> Interfaces { get; }
    public bool HasNestedTypes { get; }
    public Collection`1<TypeDefinition> NestedTypes { get; }
    public bool HasMethods { get; }
    public Collection`1<MethodDefinition> Methods { get; }
    public bool HasFields { get; }
    public Collection`1<FieldDefinition> Fields { get; }
    public bool HasEvents { get; }
    public Collection`1<EventDefinition> Events { get; }
    public bool HasProperties { get; }
    public Collection`1<PropertyDefinition> Properties { get; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsEnum { get; }
    public bool IsValueType { get; public set; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    internal TypeDefinitionProjection WindowsRuntimeProjection { get; internal set; }
    public TypeDefinition(string namespace, string name, TypeAttributes attributes);
    public TypeDefinition(string namespace, string name, TypeAttributes attributes, TypeReference baseType);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public TypeReference get_BaseType();
    public void set_BaseType(TypeReference value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public short get_PackingSize();
    public void set_PackingSize(short value);
    public int get_ClassSize();
    public void set_ClassSize(int value);
    public bool get_HasInterfaces();
    public Collection`1<InterfaceImplementation> get_Interfaces();
    public bool get_HasNestedTypes();
    public Collection`1<TypeDefinition> get_NestedTypes();
    public bool get_HasMethods();
    public Collection`1<MethodDefinition> get_Methods();
    public bool get_HasFields();
    public Collection`1<FieldDefinition> get_Fields();
    public bool get_HasEvents();
    public Collection`1<EventDefinition> get_Events();
    public bool get_HasProperties();
    public Collection`1<PropertyDefinition> get_Properties();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsEnum();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    internal TypeDefinitionProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(TypeDefinitionProjection value);
    protected virtual void ClearFullName();
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeDefinitionCollection : Collection`1<TypeDefinition> {
    private ModuleDefinition container;
    private Dictionary`2<Row`2<string, string>, TypeDefinition> name_cache;
    internal TypeDefinitionCollection(ModuleDefinition container);
    internal TypeDefinitionCollection(ModuleDefinition container, int capacity);
    protected virtual void OnAdd(TypeDefinition item, int index);
    protected virtual void OnSet(TypeDefinition item, int index);
    protected virtual void OnInsert(TypeDefinition item, int index);
    protected virtual void OnRemove(TypeDefinition item, int index);
    protected virtual void OnClear();
    private void Attach(TypeDefinition type);
    private void Detach(TypeDefinition type);
    public TypeDefinition GetType(string fullname);
    public TypeDefinition GetType(string namespace, string name);
}
internal class Mono.Cecil.TypeDefinitionProjection : object {
    public TypeAttributes Attributes;
    public string Name;
    public TypeDefinitionTreatment Treatment;
    public Collection`1<MethodDefinition> RedirectedMethods;
    public Collection`1<KeyValuePair`2<InterfaceImplementation, InterfaceImplementation>> RedirectedInterfaces;
    public TypeDefinitionProjection(TypeDefinition type, TypeDefinitionTreatment treatment, Collection`1<MethodDefinition> redirectedMethods, Collection`1<KeyValuePair`2<InterfaceImplementation, InterfaceImplementation>> redirectedInterfaces);
}
[FlagsAttribute]
internal enum Mono.Cecil.TypeDefinitionTreatment : Enum {
    public int value__;
    public static TypeDefinitionTreatment None;
    public static TypeDefinitionTreatment KindMask;
    public static TypeDefinitionTreatment NormalType;
    public static TypeDefinitionTreatment NormalAttribute;
    public static TypeDefinitionTreatment UnmangleWindowsRuntimeName;
    public static TypeDefinitionTreatment PrefixWindowsRuntimeName;
    public static TypeDefinitionTreatment RedirectToClrType;
    public static TypeDefinitionTreatment RedirectToClrAttribute;
    public static TypeDefinitionTreatment RedirectImplementedMethods;
    public static TypeDefinitionTreatment Abstract;
    public static TypeDefinitionTreatment Internal;
}
internal class Mono.Cecil.TypeDefTable : MetadataTable`1<Row`6<TypeAttributes, UInt32, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.TypeParser : object {
    private string fullname;
    private int length;
    private int position;
    private TypeParser(string fullname);
    private Type ParseType(bool fq_name);
    private static bool TryGetArity(Type type);
    private static bool TryGetArity(string name, Int32& arity);
    private static bool ParseInt32(string value, Int32& result);
    private static void TryAddArity(string name, Int32& arity);
    private string ParsePart();
    private static bool IsDelimiter(char chr);
    private void TryParseWhiteSpace();
    private String[] ParseNestedNames();
    private bool TryParse(char chr);
    private static void Add(T[]& array, T item);
    private Int32[] ParseSpecs();
    private Type[] ParseGenericArguments(int arity);
    private string ParseAssemblyName();
    public static TypeReference ParseType(ModuleDefinition module, string fullname, bool typeDefinitionOnly);
    private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info, bool type_def_only);
    private static TypeReference CreateSpecs(TypeReference type, Type type_info);
    private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info);
    public static void SplitFullName(string fullname, String& namespace, String& name);
    private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope);
    private static void AdjustGenericParameters(TypeReference type);
    private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info);
    private static bool TryGetDefinition(ModuleDefinition module, Type type_info, TypeReference& type);
    private static bool TryCurrentModule(ModuleDefinition module, Type type_info);
    public static string ToParseable(TypeReference type, bool top_level);
    private static void AppendNamePart(string part, StringBuilder name);
    private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level);
    private static string GetScopeFullName(TypeReference type);
    private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name);
    private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level);
}
public class Mono.Cecil.TypeReference : MemberReference {
    private string namespace;
    private bool value_type;
    internal IMetadataScope scope;
    internal ModuleDefinition module;
    internal ElementType etype;
    private string fullname;
    protected Collection`1<GenericParameter> generic_parameters;
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public bool IsValueType { get; public set; }
    public ModuleDefinition Module { get; }
    internal TypeReferenceProjection WindowsRuntimeProjection { get; internal set; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsNested { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsByReference { get; }
    public bool IsPointer { get; }
    public bool IsSentinel { get; }
    public bool IsArray { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericInstance { get; }
    public bool IsRequiredModifier { get; }
    public bool IsOptionalModifier { get; }
    public bool IsPinned { get; }
    public bool IsFunctionPointer { get; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    protected TypeReference(string namespace, string name);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual ModuleDefinition get_Module();
    internal TypeReferenceProjection get_WindowsRuntimeProjection();
    internal void set_WindowsRuntimeProjection(TypeReferenceProjection value);
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public bool get_IsNested();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsByReference();
    public virtual bool get_IsPointer();
    public virtual bool get_IsSentinel();
    public virtual bool get_IsArray();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_IsPinned();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    protected virtual void ClearFullName();
    public virtual TypeReference GetElementType();
    protected virtual IMemberDefinition ResolveDefinition();
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeReferenceEqualityComparer : EqualityComparer`1<TypeReference> {
    public virtual bool Equals(TypeReference x, TypeReference y);
    public virtual int GetHashCode(TypeReference obj);
    public static bool AreEqual(TypeReference a, TypeReference b, TypeComparisonMode comparisonMode);
    private static bool AreEqual(GenericParameter a, GenericParameter b, TypeComparisonMode comparisonMode);
    private static bool AreEqual(GenericInstanceType a, GenericInstanceType b, TypeComparisonMode comparisonMode);
    public static int GetHashCodeFor(TypeReference obj);
}
internal class Mono.Cecil.TypeReferenceProjection : object {
    public string Name;
    public string Namespace;
    public IMetadataScope Scope;
    public TypeReferenceTreatment Treatment;
    public TypeReferenceProjection(TypeReference type, TypeReferenceTreatment treatment);
}
internal enum Mono.Cecil.TypeReferenceTreatment : Enum {
    public int value__;
    public static TypeReferenceTreatment None;
    public static TypeReferenceTreatment SystemDelegate;
    public static TypeReferenceTreatment SystemAttribute;
    public static TypeReferenceTreatment UseProjectionInfo;
}
internal class Mono.Cecil.TypeRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.TypeResolver : object {
    private IGenericInstance _typeDefinitionContext;
    private IGenericInstance _methodDefinitionContext;
    public TypeResolver(GenericInstanceType typeDefinitionContext);
    public TypeResolver(GenericInstanceMethod methodDefinitionContext);
    public TypeResolver(GenericInstanceType typeDefinitionContext, GenericInstanceMethod methodDefinitionContext);
    public static TypeResolver For(TypeReference typeReference);
    public static TypeResolver For(TypeReference typeReference, MethodReference methodReference);
    public MethodReference Resolve(MethodReference method);
    public FieldReference Resolve(FieldReference field);
    public TypeReference ResolveReturnType(MethodReference method);
    public TypeReference ResolveParameterType(MethodReference method, ParameterReference parameter);
    public TypeReference ResolveVariableType(MethodReference method, VariableReference variable);
    public TypeReference ResolveFieldType(FieldReference field);
    public TypeReference Resolve(TypeReference typeReference);
    public TypeReference Resolve(TypeReference typeReference, bool includeTypeDefinitions);
    internal TypeResolver Nested(GenericInstanceMethod genericInstanceMethod);
    private TypeReference ResolveGenericParameter(GenericParameter genericParameter);
    private TypeReference HandleOwnerlessInvalidILCode(GenericParameter genericParameter);
    private bool IsDummy();
}
public abstract class Mono.Cecil.TypeSpecification : TypeReference {
    private TypeReference element_type;
    public TypeReference ElementType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public IMetadataScope Scope { get; public set; }
    public ModuleDefinition Module { get; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    internal TypeSpecification(TypeReference type);
    public sealed virtual TypeReference get_ElementType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual ModuleDefinition get_Module();
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public virtual TypeReference GetElementType();
}
internal class Mono.Cecil.TypeSpecTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
public abstract class Mono.Cecil.TypeSystem : object {
    private ModuleDefinition module;
    private TypeReference type_object;
    private TypeReference type_void;
    private TypeReference type_bool;
    private TypeReference type_char;
    private TypeReference type_sbyte;
    private TypeReference type_byte;
    private TypeReference type_int16;
    private TypeReference type_uint16;
    private TypeReference type_int32;
    private TypeReference type_uint32;
    private TypeReference type_int64;
    private TypeReference type_uint64;
    private TypeReference type_single;
    private TypeReference type_double;
    private TypeReference type_intptr;
    private TypeReference type_uintptr;
    private TypeReference type_string;
    private TypeReference type_typedref;
    [ObsoleteAttribute("Use CoreLibrary")]
public IMetadataScope Corlib { get; }
    public IMetadataScope CoreLibrary { get; }
    public TypeReference Object { get; }
    public TypeReference Void { get; }
    public TypeReference Boolean { get; }
    public TypeReference Char { get; }
    public TypeReference SByte { get; }
    public TypeReference Byte { get; }
    public TypeReference Int16 { get; }
    public TypeReference UInt16 { get; }
    public TypeReference Int32 { get; }
    public TypeReference UInt32 { get; }
    public TypeReference Int64 { get; }
    public TypeReference UInt64 { get; }
    public TypeReference Single { get; }
    public TypeReference Double { get; }
    public TypeReference IntPtr { get; }
    public TypeReference UIntPtr { get; }
    public TypeReference String { get; }
    public TypeReference TypedReference { get; }
    private TypeSystem(ModuleDefinition module);
    internal static TypeSystem CreateTypeSystem(ModuleDefinition module);
    internal abstract virtual TypeReference LookupType(string namespace, string name);
    private TypeReference LookupSystemType(TypeReference& reference, string name, ElementType element_type);
    private TypeReference LookupSystemValueType(TypeReference& typeRef, string name, ElementType element_type);
    public IMetadataScope get_Corlib();
    public IMetadataScope get_CoreLibrary();
    public TypeReference get_Object();
    public TypeReference get_Void();
    public TypeReference get_Boolean();
    public TypeReference get_Char();
    public TypeReference get_SByte();
    public TypeReference get_Byte();
    public TypeReference get_Int16();
    public TypeReference get_UInt16();
    public TypeReference get_Int32();
    public TypeReference get_UInt32();
    public TypeReference get_Int64();
    public TypeReference get_UInt64();
    public TypeReference get_Single();
    public TypeReference get_Double();
    public TypeReference get_IntPtr();
    public TypeReference get_UIntPtr();
    public TypeReference get_String();
    public TypeReference get_TypedReference();
}
public enum Mono.Cecil.VariantType : Enum {
    public int value__;
    public static VariantType None;
    public static VariantType I2;
    public static VariantType I4;
    public static VariantType R4;
    public static VariantType R8;
    public static VariantType CY;
    public static VariantType Date;
    public static VariantType BStr;
    public static VariantType Dispatch;
    public static VariantType Error;
    public static VariantType Bool;
    public static VariantType Variant;
    public static VariantType Unknown;
    public static VariantType Decimal;
    public static VariantType I1;
    public static VariantType UI1;
    public static VariantType UI2;
    public static VariantType UI4;
    public static VariantType I8;
    public static VariantType UI8;
    public static VariantType Int;
    public static VariantType UInt;
}
internal class Mono.Cecil.WindowsRuntimeProjections : object {
    private static Version version;
    private static Byte[] contract_pk_token;
    private static Byte[] contract_pk;
    private static Dictionary`2<string, ProjectionInfo> projections;
    private ModuleDefinition module;
    private Version corlib_version;
    private AssemblyNameReference[] virtual_references;
    private static Dictionary`2<string, ProjectionInfo> Projections { get; }
    private AssemblyNameReference[] VirtualReferences { get; }
    public WindowsRuntimeProjections(ModuleDefinition module);
    private static WindowsRuntimeProjections();
    private static Dictionary`2<string, ProjectionInfo> get_Projections();
    private AssemblyNameReference[] get_VirtualReferences();
    public static void Project(TypeDefinition type);
    private static TypeDefinitionTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinition type);
    private static TypeDefinitionTreatment GenerateRedirectionInformation(TypeDefinition type, Collection`1& redirectedMethods, Collection`1& redirectedInterfaces);
    private static void CollectImplementedInterfaces(TypeReference type, HashSet`1<TypeReference> results);
    private static void RedirectInterfaceMethods(TypeReference interfaceType, Collection`1<MethodDefinition> redirectedMethods);
    private static bool IsRedirectedType(TypeReference type);
    private static bool NeedsWindowsRuntimePrefix(TypeDefinition type);
    private static bool IsClrImplementationType(TypeDefinition type);
    public static void ApplyProjection(TypeDefinition type, TypeDefinitionProjection projection);
    public static TypeDefinitionProjection RemoveProjection(TypeDefinition type);
    public static void Project(TypeReference type);
    private static TypeReferenceTreatment GetSpecialTypeReferenceTreatment(TypeReference type);
    private static bool IsAttribute(TypeReference type);
    private static bool IsEnum(TypeReference type);
    public static void ApplyProjection(TypeReference type, TypeReferenceProjection projection);
    public static TypeReferenceProjection RemoveProjection(TypeReference type);
    public static void Project(MethodDefinition method);
    private static MethodDefinitionTreatment GetMethodDefinitionTreatmentFromCustomAttributes(MethodDefinition method);
    public static void ApplyProjection(MethodDefinition method, MethodDefinitionProjection projection);
    public static MethodDefinitionProjection RemoveProjection(MethodDefinition method);
    public static void Project(FieldDefinition field);
    public static void ApplyProjection(FieldDefinition field, FieldDefinitionProjection projection);
    public static FieldDefinitionProjection RemoveProjection(FieldDefinition field);
    private static bool ImplementsRedirectedInterface(MemberReference member);
    public void AddVirtualReferences(Collection`1<AssemblyNameReference> references);
    public void RemoveVirtualReferences(Collection`1<AssemblyNameReference> references);
    private static AssemblyNameReference[] GetAssemblyReferences(AssemblyNameReference corlib);
    private static AssemblyNameReference GetCoreLibrary(Collection`1<AssemblyNameReference> references);
    private AssemblyNameReference GetAssemblyReference(string name);
    public static void Project(ICustomAttributeProvider owner, CustomAttribute attribute);
    private static bool IsWindowsAttributeUsageAttribute(ICustomAttributeProvider owner, CustomAttribute attribute);
    private static bool HasAttribute(TypeDefinition type, string namespace, string name);
    public static void ApplyProjection(CustomAttribute attribute, CustomAttributeValueProjection projection);
    public static CustomAttributeValueProjection RemoveProjection(CustomAttribute attribute);
}
public class Mono.Cecil.WriterParameters : object {
    private Nullable`1<UInt32> timestamp;
    private Stream symbol_stream;
    private ISymbolWriterProvider symbol_writer_provider;
    private bool write_symbols;
    private Byte[] key_blob;
    private string key_container;
    private StrongNameKeyPair key_pair;
    [CompilerGeneratedAttribute]
private bool <DeterministicMvid>k__BackingField;
    public Nullable`1<UInt32> Timestamp { get; public set; }
    public Stream SymbolStream { get; public set; }
    public ISymbolWriterProvider SymbolWriterProvider { get; public set; }
    public bool WriteSymbols { get; public set; }
    public bool HasStrongNameKey { get; }
    public Byte[] StrongNameKeyBlob { get; public set; }
    public string StrongNameKeyContainer { get; public set; }
    public StrongNameKeyPair StrongNameKeyPair { get; public set; }
    public bool DeterministicMvid { get; public set; }
    public Nullable`1<UInt32> get_Timestamp();
    public void set_Timestamp(Nullable`1<UInt32> value);
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolWriterProvider get_SymbolWriterProvider();
    public void set_SymbolWriterProvider(ISymbolWriterProvider value);
    public bool get_WriteSymbols();
    public void set_WriteSymbols(bool value);
    public bool get_HasStrongNameKey();
    public Byte[] get_StrongNameKeyBlob();
    public void set_StrongNameKeyBlob(Byte[] value);
    public string get_StrongNameKeyContainer();
    public void set_StrongNameKeyContainer(string value);
    public StrongNameKeyPair get_StrongNameKeyPair();
    public void set_StrongNameKeyPair(StrongNameKeyPair value);
    [CompilerGeneratedAttribute]
public bool get_DeterministicMvid();
    [CompilerGeneratedAttribute]
public void set_DeterministicMvid(bool value);
}
[DefaultMemberAttribute("Item")]
public class Mono.Collections.Generic.Collection`1 : object {
    internal T[] items;
    internal int size;
    private int version;
    public int Count { get; }
    public T Item { get; public set; }
    public int Capacity { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Collection`1(int capacity);
    public Collection`1(ICollection`1<T> items);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public int get_Capacity();
    public void set_Capacity(int value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    private void CheckIndex(int index);
    private void Shift(int start, int delta);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnSet(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnClear();
    internal virtual void Grow(int desired);
    protected void Resize(int new_size);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
public class Mono.Collections.Generic.ReadOnlyCollection`1 : Collection`1<T> {
    private static ReadOnlyCollection`1<T> empty;
    public static ReadOnlyCollection`1<T> Empty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    public ReadOnlyCollection`1(T[] array);
    public ReadOnlyCollection`1(Collection`1<T> collection);
    public static ReadOnlyCollection`1<T> get_Empty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private void Initialize(T[] items, int size);
    internal virtual void Grow(int desired);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnClear();
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnSet(T item, int index);
}
internal static class Mono.Disposable : object {
    public static Disposable`1<T> Owned(T value);
    public static Disposable`1<T> NotOwned(T value);
}
internal class Mono.Disposable`1 : ValueType {
    internal T value;
    private bool owned;
    public Disposable`1(T value, bool owned);
    public sealed virtual void Dispose();
}
internal static class Mono.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
internal class Mono.MergeSort`1 : object {
    private T[] elements;
    private T[] buffer;
    private IComparer`1<T> comparer;
    private MergeSort`1(T[] elements, IComparer`1<T> comparer);
    public static void Sort(T[] source, IComparer`1<T> comparer);
    public static void Sort(T[] source, int start, int length, IComparer`1<T> comparer);
    private void Sort(int start, int length);
    private void TopDownSplitMerge(T[] a, T[] b, int start, int end);
    private void TopDownMerge(T[] a, T[] b, int start, int middle, int end);
}
internal static class Mono.Security.Cryptography.CryptoConvert : object {
    private static int ToInt32LE(Byte[] bytes, int offset);
    private static UInt32 ToUInt32LE(Byte[] bytes, int offset);
    private static Byte[] GetBytesLE(int val);
    private static Byte[] Trim(Byte[] array);
    private static RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset);
    private static RSA FromCapiPublicKeyBlob(Byte[] blob, int offset);
    public static RSA FromCapiKeyBlob(Byte[] blob);
    public static RSA FromCapiKeyBlob(Byte[] blob, int offset);
    public static Byte[] ToCapiPublicKeyBlob(RSA rsa);
}
