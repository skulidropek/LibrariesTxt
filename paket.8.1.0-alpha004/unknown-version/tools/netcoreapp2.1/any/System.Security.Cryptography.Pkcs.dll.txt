internal static class FxResources.System.Security.Cryptography.Pkcs.SR : object {
}
internal abstract class Internal.Cryptography.DecryptorPal : object {
    [CompilerGeneratedAttribute]
private RecipientInfoCollection <RecipientInfos>k__BackingField;
    public RecipientInfoCollection RecipientInfos { get; }
    internal DecryptorPal(RecipientInfoCollection recipientInfos);
    [CompilerGeneratedAttribute]
public RecipientInfoCollection get_RecipientInfos();
    public abstract virtual ContentInfo TryDecrypt(RecipientInfo recipientInfo, X509Certificate2 cert, X509Certificate2Collection originatorCerts, X509Certificate2Collection extraStore, Exception& exception);
    public abstract virtual void Dispose();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] a);
    internal static HashAlgorithmName GetDigestAlgorithm(Oid oid);
    internal static HashAlgorithmName GetDigestAlgorithm(string oidValue);
    internal static string GetOidFromHashAlgorithm(HashAlgorithmName algName);
    [ExtensionAttribute]
public static Byte[] Resize(Byte[] a, int size);
    public static void RemoveAt(T[]& arr, int idx);
    public static T[] NormalizeSet(T[] setItems, Action`1<Byte[]> encodedValueProcessor);
    internal static Byte[] EncodeContentInfo(T value, string contentType, AsnEncodingRules ruleSet);
    [ExtensionAttribute]
public static CmsRecipientCollection DeepCopy(CmsRecipientCollection recipients);
    [ExtensionAttribute]
public static Byte[] UnicodeToOctetString(string s);
    [ExtensionAttribute]
public static string OctetStringToUnicode(Byte[] octets);
    public static X509Certificate2Collection GetStoreCertificates(StoreName storeName, StoreLocation storeLocation, bool openExistingOnly);
    [ExtensionAttribute]
public static X509Certificate2 TryFindMatchingCertificate(X509Certificate2Collection certs, SubjectIdentifier recipientIdentifier);
    private static bool AreByteArraysEqual(Byte[] ba1, Byte[] ba2);
    [ExtensionAttribute]
private static Byte[] ToSkiBytes(string skiString);
    [ExtensionAttribute]
public static string ToSkiString(Byte[] skiBytes);
    [ExtensionAttribute]
public static string ToBigEndianHex(ReadOnlySpan`1<byte> bytes);
    [ExtensionAttribute]
private static Byte[] ToSerialBytes(string serialString);
    [ExtensionAttribute]
public static string ToSerialString(Byte[] serialBytes);
    private static string ToUpperHexString(ReadOnlySpan`1<byte> ba);
    [ExtensionAttribute]
private static Byte[] UpperHexStringToByteArray(string normalizedString);
    private static byte UpperHexCharToNybble(char c);
    public static Pkcs9AttributeObject CreateBestPkcs9AttributeObjectAvailable(Oid oid, Byte[] encodedAttribute);
    private static T Upgrade(Pkcs9AttributeObject basicAttribute);
    [ExtensionAttribute]
public static Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    [ExtensionAttribute]
internal static Byte[] OneShot(ICryptoTransform transform, Byte[] data);
    [ExtensionAttribute]
internal static Byte[] OneShot(ICryptoTransform transform, Byte[] data, int offset, int length);
    private static ReadOnlyMemory`1<byte> GetSubjectPublicKeyInfo(X509Certificate2 certificate);
}
internal abstract class Internal.Cryptography.KeyAgreeRecipientInfoPal : RecipientInfoPal {
    public DateTime Date { get; }
    public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
    public CryptographicAttributeObject OtherKeyAttribute { get; }
    public abstract virtual DateTime get_Date();
    public abstract virtual SubjectIdentifierOrKey get_OriginatorIdentifierOrKey();
    public abstract virtual CryptographicAttributeObject get_OtherKeyAttribute();
}
internal static class Internal.Cryptography.KeyLengths : object {
    public static int Rc2_40Bit;
    public static int Rc2_56Bit;
    public static int Rc2_64Bit;
    public static int Rc2_128Bit;
    public static int Rc4Max_128Bit;
    public static int Des_64Bit;
    public static int TripleDes_192Bit;
    public static int DefaultKeyLengthForRc2AndRc4;
}
internal abstract class Internal.Cryptography.KeyTransRecipientInfoPal : RecipientInfoPal {
}
internal static class Internal.Cryptography.Oids : object {
    public static string Rc2Cbc;
    public static string Rc4;
    public static string TripleDesCbc;
    public static string DesCbc;
    public static string Aes128Cbc;
    public static string Aes192Cbc;
    public static string Aes256Cbc;
    public static string Rsa;
    public static string RsaOaep;
    public static string RsaPss;
    public static string RsaPkcs1Sha1;
    public static string RsaPkcs1Sha256;
    public static string RsaPkcs1Sha384;
    public static string RsaPkcs1Sha512;
    public static string Esdh;
    public static string SigningTime;
    public static string ContentType;
    public static string DocumentDescription;
    public static string MessageDigest;
    public static string CounterSigner;
    public static string SigningCertificate;
    public static string SigningCertificateV2;
    public static string DocumentName;
    public static string CmsRc2Wrap;
    public static string Cms3DesWrap;
    public static string Pkcs7Data;
    public static string Pkcs7Signed;
    public static string Pkcs7Enveloped;
    public static string Pkcs7SignedEnveloped;
    public static string Pkcs7Hashed;
    public static string Pkcs7Encrypted;
    public static string Md5;
    public static string Sha1;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string DsaPublicKey;
    public static string DsaWithSha1;
    public static string DsaWithSha256;
    public static string DsaWithSha384;
    public static string DsaWithSha512;
    public static string EcPublicKey;
    public static string ECDsaWithSha1;
    public static string ECDsaWithSha256;
    public static string ECDsaWithSha384;
    public static string ECDsaWithSha512;
    public static string Mgf1;
    public static string SubjectKeyIdentifier;
    public static string KeyUsage;
    public static string TstInfo;
    public static string TimeStampingPurpose;
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.AnyOS.AsnHelpers : object {
    [ExtensionAttribute]
internal static SubjectIdentifierOrKey ToSubjectIdentifierOrKey(OriginatorIdentifierOrKeyAsn originator);
    [ExtensionAttribute]
internal static AlgorithmIdentifier ToPresentationObject(AlgorithmIdentifierAsn asn);
}
internal class Internal.Cryptography.Pal.AnyOS.ManagedPkcsPal : PkcsPal {
    private static Byte[] s_invalidEmptyOid;
    private static Byte[] s_rsaPkcsParameters;
    private static Byte[] s_rsaOaepSha1Parameters;
    private static ManagedPkcsPal();
    public virtual void AddCertsFromStoreForDecryption(X509Certificate2Collection certs);
    public virtual Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    public virtual T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent);
    public virtual T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent);
    private T GetPrivateKey(X509Certificate2 certificate);
    private static SymmetricAlgorithm OpenAlgorithm(AlgorithmIdentifierAsn contentEncryptionAlgorithm);
    private static SymmetricAlgorithm OpenAlgorithm(AlgorithmIdentifier algorithmIdentifier);
    private static SymmetricAlgorithm OpenAlgorithm(Oid algorithmIdentifier);
    public virtual Byte[] EncodeOctetString(Byte[] octets);
    public virtual Byte[] DecodeOctetString(Byte[] encodedOctets);
    public virtual Byte[] EncodeUtcTime(DateTime utcTime);
    public virtual DateTime DecodeUtcTime(Byte[] encodedUtcTime);
    public virtual string DecodeOid(Byte[] encodedOid);
    public virtual Oid GetEncodedMessageType(Byte[] encodedMessage);
    public virtual DecryptorPal Decode(Byte[] encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    public virtual Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes);
    private static Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes, Byte[] encryptedContent, Byte[] cek, Byte[] parameterBytes);
    private Byte[] EncryptContent(ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, Byte[]& cek, Byte[]& parameterBytes);
    public virtual Exception CreateRecipientsNotFoundException();
    public virtual Exception CreateRecipientInfosAfterEncryptException();
    public virtual Exception CreateDecryptAfterEncryptException();
    public virtual Exception CreateDecryptTwiceException();
    private static Exception CreateInvalidMessageTypeException();
    private static KeyTransRecipientInfoAsn MakeKtri(Byte[] cek, CmsRecipient recipient, Boolean& v0Recipient);
}
internal abstract class Internal.Cryptography.PkcsPal : object {
    private static PkcsPal s_instance;
    public static PkcsPal Instance { get; }
    private static PkcsPal();
    public abstract virtual Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes);
    public abstract virtual DecryptorPal Decode(Byte[] encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    public abstract virtual Byte[] EncodeOctetString(Byte[] octets);
    public abstract virtual Byte[] DecodeOctetString(Byte[] encodedOctets);
    public abstract virtual Byte[] EncodeUtcTime(DateTime utcTime);
    public abstract virtual DateTime DecodeUtcTime(Byte[] encodedUtcTime);
    public abstract virtual string DecodeOid(Byte[] encodedOid);
    public abstract virtual Oid GetEncodedMessageType(Byte[] encodedMessage);
    public abstract virtual void AddCertsFromStoreForDecryption(X509Certificate2Collection certs);
    public abstract virtual Exception CreateRecipientsNotFoundException();
    public abstract virtual Exception CreateRecipientInfosAfterEncryptException();
    public abstract virtual Exception CreateDecryptAfterEncryptException();
    public abstract virtual Exception CreateDecryptTwiceException();
    public abstract virtual Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    public abstract virtual T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent);
    public abstract virtual T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent);
    public static PkcsPal get_Instance();
}
internal abstract class Internal.Cryptography.RecipientInfoPal : object {
    public Byte[] EncryptedKey { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public int Version { get; }
    public abstract virtual Byte[] get_EncryptedKey();
    public abstract virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public abstract virtual SubjectIdentifier get_RecipientIdentifier();
    public abstract virtual int get_Version();
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.AnyValueAttribute : AsnTypeAttribute {
}
internal class System.Security.Cryptography.Asn1.Asn1Tag : ValueType {
    private static byte ClassMask;
    private static byte ConstructedMask;
    private static byte ControlMask;
    private static byte TagNumberMask;
    internal static Asn1Tag EndOfContents;
    internal static Asn1Tag Boolean;
    internal static Asn1Tag Integer;
    internal static Asn1Tag PrimitiveBitString;
    internal static Asn1Tag ConstructedBitString;
    internal static Asn1Tag PrimitiveOctetString;
    internal static Asn1Tag ConstructedOctetString;
    internal static Asn1Tag Null;
    internal static Asn1Tag ObjectIdentifier;
    internal static Asn1Tag Enumerated;
    internal static Asn1Tag Sequence;
    internal static Asn1Tag SetOf;
    internal static Asn1Tag UtcTime;
    internal static Asn1Tag GeneralizedTime;
    private byte _controlFlags;
    private int _tagValue;
    public TagClass TagClass { get; }
    public bool IsConstructed { get; }
    public int TagValue { get; }
    private Asn1Tag(byte controlFlags, int tagValue);
    public Asn1Tag(UniversalTagNumber universalTagNumber, bool isConstructed);
    public Asn1Tag(TagClass tagClass, int tagValue, bool isConstructed);
    private static Asn1Tag();
    public TagClass get_TagClass();
    public bool get_IsConstructed();
    public int get_TagValue();
    public Asn1Tag AsConstructed();
    public Asn1Tag AsPrimitive();
    public static bool TryParse(ReadOnlySpan`1<byte> source, Asn1Tag& tag, Int32& bytesRead);
    public int CalculateEncodedSize();
    public bool TryWrite(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual bool Equals(Asn1Tag other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Asn1Tag left, Asn1Tag right);
    public static bool op_Inequality(Asn1Tag left, Asn1Tag right);
    public virtual string ToString();
}
internal class System.Security.Cryptography.Asn1.AsnAmbiguousFieldTypeException : AsnSerializationConstraintException {
    public AsnAmbiguousFieldTypeException(FieldInfo fieldInfo, Type ambiguousType);
}
internal static class System.Security.Cryptography.Asn1.AsnCharacterStringEncodings : object {
    private static Encoding s_utf8Encoding;
    private static Encoding s_bmpEncoding;
    private static Encoding s_ia5Encoding;
    private static Encoding s_visibleStringEncoding;
    private static Encoding s_printableStringEncoding;
    private static AsnCharacterStringEncodings();
    internal static Encoding GetEncoding(UniversalTagNumber encodingType);
}
internal abstract class System.Security.Cryptography.Asn1.AsnEncodingRuleAttribute : Attribute {
}
internal enum System.Security.Cryptography.Asn1.AsnEncodingRules : Enum {
    public int value__;
    public static AsnEncodingRules BER;
    public static AsnEncodingRules CER;
    public static AsnEncodingRules DER;
}
internal class System.Security.Cryptography.Asn1.AsnReader : object {
    internal static int MaxCERSegmentSize;
    private static int EndOfContentsEncodedLength;
    private ReadOnlyMemory`1<byte> _data;
    private AsnEncodingRules _ruleSet;
    public bool HasData { get; }
    public AsnReader(ReadOnlyMemory`1<byte> data, AsnEncodingRules ruleSet);
    public bool get_HasData();
    public void ThrowIfNotEmpty();
    public static bool TryPeekTag(ReadOnlySpan`1<byte> source, Asn1Tag& tag, Int32& bytesRead);
    public Asn1Tag PeekTag();
    private static bool TryReadLength(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet, Nullable`1& length, Int32& bytesRead);
    internal Asn1Tag ReadTagAndLength(Nullable`1& contentsLength, Int32& bytesRead);
    private static void ValidateEndOfContents(Asn1Tag tag, Nullable`1<int> length, int headerLength);
    private int SeekEndOfContents(ReadOnlyMemory`1<byte> source);
    public ReadOnlyMemory`1<byte> PeekEncodedValue();
    public ReadOnlyMemory`1<byte> PeekContentBytes();
    public ReadOnlyMemory`1<byte> GetEncodedValue();
    private static bool ReadBooleanValue(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet);
    public bool ReadBoolean();
    public bool ReadBoolean(Asn1Tag expectedTag);
    private ReadOnlyMemory`1<byte> GetIntegerContents(Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int32& headerLength);
    public ReadOnlyMemory`1<byte> GetIntegerBytes();
    public ReadOnlyMemory`1<byte> GetIntegerBytes(Asn1Tag expectedTag);
    public BigInteger GetInteger();
    public BigInteger GetInteger(Asn1Tag expectedTag);
    private bool TryReadSignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int64& value);
    private bool TryReadUnsignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, UInt64& value);
    public bool TryReadInt32(Int32& value);
    public bool TryReadInt32(Asn1Tag expectedTag, Int32& value);
    public bool TryReadUInt32(UInt32& value);
    public bool TryReadUInt32(Asn1Tag expectedTag, UInt32& value);
    public bool TryReadInt64(Int64& value);
    public bool TryReadInt64(Asn1Tag expectedTag, Int64& value);
    public bool TryReadUInt64(UInt64& value);
    public bool TryReadUInt64(Asn1Tag expectedTag, UInt64& value);
    public bool TryReadInt16(Int16& value);
    public bool TryReadInt16(Asn1Tag expectedTag, Int16& value);
    public bool TryReadUInt16(UInt16& value);
    public bool TryReadUInt16(Asn1Tag expectedTag, UInt16& value);
    public bool TryReadInt8(SByte& value);
    public bool TryReadInt8(Asn1Tag expectedTag, SByte& value);
    public bool TryReadUInt8(Byte& value);
    public bool TryReadUInt8(Asn1Tag expectedTag, Byte& value);
    private void ParsePrimitiveBitStringContents(ReadOnlyMemory`1<byte> source, Int32& unusedBitCount, ReadOnlyMemory`1& value, Byte& normalizedLastByte);
    private static void CopyBitStringValue(ReadOnlyMemory`1<byte> value, byte normalizedLastByte, Span`1<byte> destination);
    private int CountConstructedBitString(ReadOnlyMemory`1<byte> source, bool isIndefinite);
    private void CopyConstructedBitString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& unusedBitCount, Int32& bytesRead, Int32& bytesWritten);
    private int ProcessConstructedBitString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, BitStringCopyAction copyAction, bool isIndefinite, Int32& lastUnusedBitCount, Int32& bytesRead);
    private bool TryCopyConstructedBitStringValue(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& unusedBitCount, Int32& bytesRead, Int32& bytesWritten);
    private bool TryGetPrimitiveBitStringValue(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentsLength, Int32& headerLength, Int32& unusedBitCount, ReadOnlyMemory`1& value, Byte& normalizedLastByte);
    public bool TryGetPrimitiveBitStringValue(Int32& unusedBitCount, ReadOnlyMemory`1& contents);
    public bool TryGetPrimitiveBitStringValue(Asn1Tag expectedTag, Int32& unusedBitCount, ReadOnlyMemory`1& value);
    public bool TryCopyBitStringBytes(Span`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten);
    public bool TryCopyBitStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten);
    public TFlagsEnum GetNamedBitListValue();
    public TFlagsEnum GetNamedBitListValue(Asn1Tag expectedTag);
    public Enum GetNamedBitListValue(Type tFlagsEnum);
    public Enum GetNamedBitListValue(Asn1Tag expectedTag, Type tFlagsEnum);
    private static long InterpretNamedBitListReversed(ReadOnlySpan`1<byte> valueSpan);
    public ReadOnlyMemory`1<byte> GetEnumeratedBytes();
    public ReadOnlyMemory`1<byte> GetEnumeratedBytes(Asn1Tag expectedTag);
    public TEnum GetEnumeratedValue();
    public TEnum GetEnumeratedValue(Asn1Tag expectedTag);
    public Enum GetEnumeratedValue(Type tEnum);
    public Enum GetEnumeratedValue(Asn1Tag expectedTag, Type tEnum);
    private bool TryGetPrimitiveOctetStringBytes(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentLength, Int32& headerLength, ReadOnlyMemory`1& contents, UniversalTagNumber universalTagNumber);
    private bool TryGetPrimitiveOctetStringBytes(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, ReadOnlyMemory`1& contents);
    public bool TryGetPrimitiveOctetStringBytes(ReadOnlyMemory`1& contents);
    public bool TryGetPrimitiveOctetStringBytes(Asn1Tag expectedTag, ReadOnlyMemory`1& contents);
    private int CountConstructedOctetString(ReadOnlyMemory`1<byte> source, bool isIndefinite);
    private void CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten);
    private int CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool write, bool isIndefinite, Int32& bytesRead);
    private bool TryCopyConstructedOctetStringContents(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& bytesWritten);
    public void ReadNull();
    public void ReadNull(Asn1Tag expectedTag);
    private static void ReadSubIdentifier(ReadOnlySpan`1<byte> source, Int32& bytesRead, Nullable`1& smallValue, Nullable`1& largeValue);
    private string ReadObjectIdentifierAsString(Asn1Tag expectedTag, Int32& totalBytesRead);
    public string ReadObjectIdentifierAsString();
    public string ReadObjectIdentifierAsString(Asn1Tag expectedTag);
    public Oid ReadObjectIdentifier(bool skipFriendlyName);
    public Oid ReadObjectIdentifier(Asn1Tag expectedTag, bool skipFriendlyName);
    private bool TryCopyCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Span`1<byte> destination, Int32& bytesRead, Int32& bytesWritten);
    private static bool TryCopyCharacterString(ReadOnlySpan`1<byte> source, Span`1<char> destination, Encoding encoding, Int32& charsWritten);
    private string GetCharacterString(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Encoding encoding);
    private bool TryCopyCharacterString(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Encoding encoding, Span`1<char> destination, Int32& charsWritten);
    public bool TryGetPrimitiveCharacterStringBytes(UniversalTagNumber encodingType, ReadOnlyMemory`1& contents);
    public bool TryGetPrimitiveCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber encodingType, ReadOnlyMemory`1& contents);
    public bool TryCopyCharacterStringBytes(UniversalTagNumber encodingType, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber encodingType, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyCharacterString(UniversalTagNumber encodingType, Span`1<char> destination, Int32& charsWritten);
    public bool TryCopyCharacterString(Asn1Tag expectedTag, UniversalTagNumber encodingType, Span`1<char> destination, Int32& charsWritten);
    public string GetCharacterString(UniversalTagNumber encodingType);
    public string GetCharacterString(Asn1Tag expectedTag, UniversalTagNumber encodingType);
    public AsnReader ReadSequence();
    public AsnReader ReadSequence(Asn1Tag expectedTag);
    public AsnReader ReadSetOf(bool skipSortOrderValidation);
    public AsnReader ReadSetOf(Asn1Tag expectedTag, bool skipSortOrderValidation);
    private static int ParseNonNegativeIntAndSlice(ReadOnlySpan`1& data, int bytesToRead);
    private static int ParseNonNegativeInt(ReadOnlySpan`1<byte> data);
    private DateTimeOffset ParseUtcTime(ReadOnlySpan`1<byte> contentOctets, int twoDigitYearMax);
    public DateTimeOffset GetUtcTime(int twoDigitYearMax);
    public DateTimeOffset GetUtcTime(Asn1Tag expectedTag, int twoDigitYearMax);
    private static DateTimeOffset ParseGeneralizedTime(AsnEncodingRules ruleSet, ReadOnlySpan`1<byte> contentOctets, bool disallowFractions);
    public DateTimeOffset GetGeneralizedTime(bool disallowFractions);
    public DateTimeOffset GetGeneralizedTime(Asn1Tag expectedTag, bool disallowFractions);
    private ReadOnlySpan`1<byte> GetOctetStringContents(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Int32& bytesRead, Byte[]& rented, Span`1<byte> tmpSpace);
    private static ReadOnlySpan`1<byte> SliceAtMost(ReadOnlySpan`1<byte> source, int longestPermitted);
    private static ReadOnlySpan`1<byte> Slice(ReadOnlySpan`1<byte> source, int offset, int length);
    private static ReadOnlyMemory`1<byte> Slice(ReadOnlyMemory`1<byte> source, int offset, Nullable`1<int> length);
    private static void CheckEncodingRules(AsnEncodingRules ruleSet);
    private static void CheckExpectedTag(Asn1Tag tag, Asn1Tag expectedTag, UniversalTagNumber tagNumber);
    private static void CheckCharacterStringEncodingType(UniversalTagNumber encodingType);
    [CompilerGeneratedAttribute]
internal static Nullable`1<byte> <ParseGeneralizedTime>g__GetNextState|105_0(byte octet);
}
internal class System.Security.Cryptography.Asn1.AsnSerializationConstraintException : CryptographicException {
    public AsnSerializationConstraintException(string message);
    public AsnSerializationConstraintException(string message, Exception inner);
}
internal static class System.Security.Cryptography.Asn1.AsnSerializer : object {
    private static BindingFlags FieldFlags;
    private static ConcurrentDictionary`2<Type, FieldInfo[]> s_orderedFields;
    private static AsnSerializer();
    private static Deserializer TryOrFail(TryDeserializer`1<T> tryDeserializer);
    private static FieldInfo[] GetOrderedFields(Type typeT);
    private static ChoiceAttribute GetChoiceAttribute(Type typeT);
    private static bool CanBeNull(Type t);
    private static void PopulateChoiceLookup(Dictionary`2<ValueTuple`2<TagClass, int>, LinkedList`1<FieldInfo>> lookup, Type typeT, LinkedList`1<FieldInfo> currentSet);
    private static void SerializeChoice(Type typeT, object value, AsnWriter writer);
    private static object DeserializeChoice(AsnReader reader, Type typeT);
    private static void SerializeCustomType(Type typeT, object value, AsnWriter writer, Asn1Tag tag);
    private static object DeserializeCustomType(AsnReader reader, Type typeT, Asn1Tag expectedTag);
    private static Deserializer ExplicitValueDeserializer(Deserializer valueDeserializer, Asn1Tag expectedTag);
    private static object ExplicitValueDeserializer(AsnReader reader, Deserializer valueDeserializer, Asn1Tag expectedTag);
    private static Deserializer DefaultValueDeserializer(Deserializer valueDeserializer, bool isOptional, Byte[] defaultContents, Nullable`1<Asn1Tag> expectedTag);
    private static object DefaultValueDeserializer(AsnReader reader, Nullable`1<Asn1Tag> expectedTag, Deserializer valueDeserializer, Byte[] defaultContents, bool isOptional);
    private static Serializer GetSerializer(Type typeT, FieldInfo fieldInfo);
    private static Serializer GetSimpleSerializer(Type typeT, FieldInfo fieldInfo, Byte[]& defaultContents, Boolean& isOptional, Nullable`1& explicitTag);
    private static Deserializer GetDeserializer(Type typeT, FieldInfo fieldInfo);
    private static Deserializer GetSimpleDeserializer(Type typeT, FieldInfo fieldInfo, SerializerFieldData& fieldData);
    private static object DefaultValue(Byte[] defaultContents, Deserializer valueDeserializer);
    private static void GetFieldInfo(Type typeT, FieldInfo fieldInfo, SerializerFieldData& serializerFieldData);
    private static Type UnpackIfNullable(Type typeT);
    private static Deserializer GetPrimitiveDeserializer(Type typeT, Asn1Tag tag);
    private static Serializer GetPrimitiveSerializer(Type typeT, Asn1Tag primitiveTag);
    public static T Deserialize(ReadOnlyMemory`1<byte> source, AsnEncodingRules ruleSet);
    public static T Deserialize(ReadOnlyMemory`1<byte> source, AsnEncodingRules ruleSet, Int32& bytesRead);
    public static AsnWriter Serialize(T value, AsnEncodingRules ruleSet);
    public static void Serialize(T value, AsnWriter existingWriter);
}
internal class System.Security.Cryptography.Asn1.AsnSerializerInvalidDefaultException : AsnSerializationConstraintException {
    internal AsnSerializerInvalidDefaultException(Exception innerException);
}
internal abstract class System.Security.Cryptography.Asn1.AsnTypeAttribute : Attribute {
}
internal class System.Security.Cryptography.Asn1.AsnWriter : object {
    private Byte[] _buffer;
    private int _offset;
    private Stack`1<ValueTuple`2<Asn1Tag, int>> _nestingStack;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public AsnWriter(AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public sealed virtual void Dispose();
    private void EnsureWriteCapacity(int pendingCount);
    private void WriteTag(Asn1Tag tag);
    private void WriteLength(int length);
    private static int GetEncodedLengthSubsequentByteCount(int length);
    public void WriteEncodedValue(ReadOnlyMemory`1<byte> preEncodedValue);
    private void WriteEndOfContents();
    public void WriteBoolean(bool value);
    public void WriteBoolean(Asn1Tag tag, bool value);
    private void WriteBooleanCore(Asn1Tag tag, bool value);
    public void WriteInteger(long value);
    public void WriteInteger(ulong value);
    public void WriteInteger(BigInteger value);
    public void WriteInteger(ReadOnlySpan`1<byte> value);
    public void WriteInteger(Asn1Tag tag, long value);
    private void WriteIntegerCore(Asn1Tag tag, long value);
    public void WriteInteger(Asn1Tag tag, ulong value);
    private void WriteNonNegativeIntegerCore(Asn1Tag tag, ulong value);
    public void WriteInteger(Asn1Tag tag, BigInteger value);
    public void WriteInteger(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, BigInteger value);
    public void WriteBitString(ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    public void WriteBitString(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    private void WriteBitStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    private void WriteConstructedCerBitString(Asn1Tag tag, ReadOnlySpan`1<byte> payload, int unusedBitCount);
    public void WriteNamedBitList(object enumValue);
    public void WriteNamedBitList(TEnum enumValue);
    public void WriteNamedBitList(Asn1Tag tag, object enumValue);
    public void WriteNamedBitList(Asn1Tag tag, TEnum enumValue);
    private void WriteNamedBitList(Asn1Tag tag, Type tEnum, object enumValue);
    private void WriteNamedBitList(Asn1Tag tag, ulong integralValue);
    public void WriteOctetString(ReadOnlySpan`1<byte> octetString);
    public void WriteOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteOctetStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteConstructedCerOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> payload);
    public void WriteNull();
    public void WriteNull(Asn1Tag tag);
    private void WriteNullCore(Asn1Tag tag);
    public void WriteObjectIdentifier(Oid oid);
    public void WriteObjectIdentifier(string oidValue);
    public void WriteObjectIdentifier(ReadOnlySpan`1<char> oidValue);
    public void WriteObjectIdentifier(Asn1Tag tag, Oid oid);
    public void WriteObjectIdentifier(Asn1Tag tag, string oidValue);
    public void WriteObjectIdentifier(Asn1Tag tag, ReadOnlySpan`1<char> oidValue);
    private void WriteObjectIdentifierCore(Asn1Tag tag, ReadOnlySpan`1<char> oidValue);
    private static BigInteger ParseSubIdentifier(ReadOnlySpan`1& oidValue);
    private static int AtoI(char c);
    private static int EncodeSubIdentifier(Span`1<byte> dest, BigInteger& subIdentifier);
    public void WriteEnumeratedValue(object enumValue);
    public void WriteEnumeratedValue(TEnum value);
    public void WriteEnumeratedValue(Asn1Tag tag, object enumValue);
    public void WriteEnumeratedValue(Asn1Tag tag, TEnum value);
    private void WriteEnumeratedValue(Asn1Tag tag, Type tEnum, object enumValue);
    public void PushSequence();
    public void PushSequence(Asn1Tag tag);
    private void PushSequenceCore(Asn1Tag tag);
    public void PopSequence();
    public void PopSequence(Asn1Tag tag);
    private void PopSequenceCore(Asn1Tag tag);
    public void PushSetOf();
    public void PushSetOf(Asn1Tag tag);
    private void PushSetOfCore(Asn1Tag tag);
    public void PopSetOf();
    public void PopSetOf(Asn1Tag tag);
    private void PopSetOfCore(Asn1Tag tag);
    public void WriteUtcTime(DateTimeOffset value);
    public void WriteUtcTime(Asn1Tag tag, DateTimeOffset value);
    private void WriteUtcTimeCore(Asn1Tag tag, DateTimeOffset value);
    public void WriteGeneralizedTime(DateTimeOffset value, bool omitFractionalSeconds);
    public void WriteGeneralizedTime(Asn1Tag tag, DateTimeOffset value, bool omitFractionalSeconds);
    private void WriteGeneralizedTimeCore(Asn1Tag tag, DateTimeOffset value, bool omitFractionalSeconds);
    public bool TryEncode(Span`1<byte> dest, Int32& bytesWritten);
    public Byte[] Encode();
    public ReadOnlySpan`1<byte> EncodeAsSpan();
    private void PushTag(Asn1Tag tag);
    private void PopTag(Asn1Tag tag, bool sortContents);
    public void WriteCharacterString(UniversalTagNumber encodingType, string str);
    public void WriteCharacterString(UniversalTagNumber encodingType, ReadOnlySpan`1<char> str);
    public void WriteCharacterString(Asn1Tag tag, UniversalTagNumber encodingType, string str);
    public void WriteCharacterString(Asn1Tag tag, UniversalTagNumber encodingType, ReadOnlySpan`1<char> str);
    private void WriteCharacterStringCore(Asn1Tag tag, Encoding encoding, ReadOnlySpan`1<char> str);
    private void WriteConstructedCerCharacterString(Asn1Tag tag, Encoding encoding, ReadOnlySpan`1<char> str, int size);
    private static void SortContents(Byte[] buffer, int start, int end);
    internal static void Reverse(Span`1<byte> span);
    private static void CheckUniversalTag(Asn1Tag tag, UniversalTagNumber universalTagNumber);
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.BitStringAttribute : AsnTypeAttribute {
}
internal class System.Security.Cryptography.Asn1.BMPEncoding : SpanBasedEncoding {
    protected virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.BMPStringAttribute : AsnTypeAttribute {
}
[AttributeUsageAttribute("12")]
internal class System.Security.Cryptography.Asn1.ChoiceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AllowNull>k__BackingField;
    public bool AllowNull { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowNull();
    [CompilerGeneratedAttribute]
public void set_AllowNull(bool value);
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.DefaultValueAttribute : AsnEncodingRuleAttribute {
    [CompilerGeneratedAttribute]
private Byte[] <EncodedBytes>k__BackingField;
    internal Byte[] EncodedBytes { get; }
    public ReadOnlyMemory`1<byte> EncodedValue { get; }
    public DefaultValueAttribute(Byte[] encodedValue);
    [CompilerGeneratedAttribute]
internal Byte[] get_EncodedBytes();
    public ReadOnlyMemory`1<byte> get_EncodedValue();
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.ExpectedTagAttribute : Attribute {
    [CompilerGeneratedAttribute]
private TagClass <TagClass>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TagValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitTag>k__BackingField;
    public TagClass TagClass { get; }
    public int TagValue { get; }
    public bool ExplicitTag { get; public set; }
    public ExpectedTagAttribute(int tagValue);
    public ExpectedTagAttribute(TagClass tagClass, int tagValue);
    [CompilerGeneratedAttribute]
public TagClass get_TagClass();
    [CompilerGeneratedAttribute]
public int get_TagValue();
    [CompilerGeneratedAttribute]
public bool get_ExplicitTag();
    [CompilerGeneratedAttribute]
public void set_ExplicitTag(bool value);
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.GeneralizedTimeAttribute : AsnTypeAttribute {
    [CompilerGeneratedAttribute]
private bool <DisallowFractions>k__BackingField;
    public bool DisallowFractions { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DisallowFractions();
    [CompilerGeneratedAttribute]
public void set_DisallowFractions(bool value);
}
internal class System.Security.Cryptography.Asn1.IA5Encoding : RestrictedAsciiStringEncoding {
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.IA5StringAttribute : AsnTypeAttribute {
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.IntegerAttribute : AsnTypeAttribute {
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.ObjectIdentifierAttribute : AsnTypeAttribute {
    [CompilerGeneratedAttribute]
private bool <PopulateFriendlyName>k__BackingField;
    public bool PopulateFriendlyName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PopulateFriendlyName();
    [CompilerGeneratedAttribute]
public void set_PopulateFriendlyName(bool value);
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.OctetStringAttribute : AsnTypeAttribute {
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.OptionalValueAttribute : AsnEncodingRuleAttribute {
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.PrintableStringAttribute : AsnTypeAttribute {
}
internal class System.Security.Cryptography.Asn1.PrintableStringEncoding : RestrictedAsciiStringEncoding {
}
internal abstract class System.Security.Cryptography.Asn1.RestrictedAsciiStringEncoding : SpanBasedEncoding {
    private Boolean[] _isAllowed;
    protected RestrictedAsciiStringEncoding(byte minCharAllowed, byte maxCharAllowed);
    protected RestrictedAsciiStringEncoding(IEnumerable`1<char> allowedChars);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    protected virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.SequenceOfAttribute : AsnTypeAttribute {
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.SetOfAttribute : AsnTypeAttribute {
}
internal class System.Security.Cryptography.Asn1.SetOfValueComparer : object {
    [CompilerGeneratedAttribute]
private static SetOfValueComparer <Instance>k__BackingField;
    internal static SetOfValueComparer Instance { get; }
    private static SetOfValueComparer();
    [CompilerGeneratedAttribute]
internal static SetOfValueComparer get_Instance();
    public sealed virtual int Compare(ReadOnlyMemory`1<byte> x, ReadOnlyMemory`1<byte> y);
}
internal abstract class System.Security.Cryptography.Asn1.SpanBasedEncoding : Encoding {
    protected abstract virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected abstract virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
}
internal enum System.Security.Cryptography.Asn1.TagClass : Enum {
    public byte value__;
    public static TagClass Universal;
    public static TagClass Application;
    public static TagClass ContextSpecific;
    public static TagClass Private;
}
internal enum System.Security.Cryptography.Asn1.UniversalTagNumber : Enum {
    public int value__;
    public static UniversalTagNumber EndOfContents;
    public static UniversalTagNumber Boolean;
    public static UniversalTagNumber Integer;
    public static UniversalTagNumber BitString;
    public static UniversalTagNumber OctetString;
    public static UniversalTagNumber Null;
    public static UniversalTagNumber ObjectIdentifier;
    public static UniversalTagNumber ObjectDescriptor;
    public static UniversalTagNumber External;
    public static UniversalTagNumber InstanceOf;
    public static UniversalTagNumber Real;
    public static UniversalTagNumber Enumerated;
    public static UniversalTagNumber Embedded;
    public static UniversalTagNumber UTF8String;
    public static UniversalTagNumber RelativeObjectIdentifier;
    public static UniversalTagNumber Time;
    public static UniversalTagNumber Sequence;
    public static UniversalTagNumber SequenceOf;
    public static UniversalTagNumber Set;
    public static UniversalTagNumber SetOf;
    public static UniversalTagNumber NumericString;
    public static UniversalTagNumber PrintableString;
    public static UniversalTagNumber TeletexString;
    public static UniversalTagNumber T61String;
    public static UniversalTagNumber VideotexString;
    public static UniversalTagNumber IA5String;
    public static UniversalTagNumber UtcTime;
    public static UniversalTagNumber GeneralizedTime;
    public static UniversalTagNumber GraphicString;
    public static UniversalTagNumber VisibleString;
    public static UniversalTagNumber ISO646String;
    public static UniversalTagNumber GeneralString;
    public static UniversalTagNumber UniversalString;
    public static UniversalTagNumber UnrestrictedCharacterString;
    public static UniversalTagNumber BMPString;
    public static UniversalTagNumber Date;
    public static UniversalTagNumber TimeOfDay;
    public static UniversalTagNumber DateTime;
    public static UniversalTagNumber Duration;
    public static UniversalTagNumber ObjectIdentifierIRI;
    public static UniversalTagNumber RelativeObjectIdentifierIRI;
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.UtcTimeAttribute : AsnTypeAttribute {
    [CompilerGeneratedAttribute]
private int <TwoDigitYearMax>k__BackingField;
    public int TwoDigitYearMax { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TwoDigitYearMax();
    [CompilerGeneratedAttribute]
public void set_TwoDigitYearMax(int value);
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.UTF8StringAttribute : AsnTypeAttribute {
}
[AttributeUsageAttribute("256")]
internal class System.Security.Cryptography.Asn1.VisibleStringAttribute : AsnTypeAttribute {
}
internal class System.Security.Cryptography.Asn1.VisibleStringEncoding : RestrictedAsciiStringEncoding {
}
public class System.Security.Cryptography.CryptographicAttributeObject : object {
    [CompilerGeneratedAttribute]
private AsnEncodedDataCollection <Values>k__BackingField;
    private Oid _oid;
    public Oid Oid { get; }
    public AsnEncodedDataCollection Values { get; }
    public CryptographicAttributeObject(Oid oid);
    public CryptographicAttributeObject(Oid oid, AsnEncodedDataCollection values);
    public Oid get_Oid();
    [CompilerGeneratedAttribute]
public AsnEncodedDataCollection get_Values();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.CryptographicAttributeObjectCollection : object {
    private List`1<CryptographicAttributeObject> _list;
    public CryptographicAttributeObject Item { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CryptographicAttributeObjectCollection(CryptographicAttributeObject attribute);
    public int Add(AsnEncodedData asnEncodedData);
    public int Add(CryptographicAttributeObject attribute);
    internal void AddWithoutMerge(CryptographicAttributeObject attribute);
    public void Remove(CryptographicAttributeObject attribute);
    public CryptographicAttributeObject get_Item(int index);
    public sealed virtual int get_Count();
    public CryptographicAttributeObjectEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(CryptographicAttributeObject[] array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
public class System.Security.Cryptography.CryptographicAttributeObjectEnumerator : object {
    private CryptographicAttributeObjectCollection _attributes;
    private int _current;
    public CryptographicAttributeObject Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal CryptographicAttributeObjectEnumerator(CryptographicAttributeObjectCollection attributes);
    public CryptographicAttributeObject get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.Pkcs.AlgorithmIdentifier : object {
    [CompilerGeneratedAttribute]
private Oid <Oid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyLength>k__BackingField;
    public Oid Oid { get; public set; }
    public int KeyLength { get; public set; }
    public AlgorithmIdentifier(Oid oid);
    public AlgorithmIdentifier(Oid oid, int keyLength);
    [CompilerGeneratedAttribute]
public Oid get_Oid();
    [CompilerGeneratedAttribute]
public void set_Oid(Oid value);
    [CompilerGeneratedAttribute]
public int get_KeyLength();
    [CompilerGeneratedAttribute]
public void set_KeyLength(int value);
}
internal class System.Security.Cryptography.Pkcs.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    [ObjectIdentifierAttribute]
public Oid Algorithm;
    [AnyValueAttribute]
[OptionalValueAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    private static AlgorithmIdentifierAsn();
    internal bool Equals(AlgorithmIdentifierAsn& other);
    private static bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters);
}
internal class System.Security.Cryptography.Pkcs.Asn1.AttributeAsn : ValueType {
    public Oid AttrType;
    [AnyValueAttribute]
public ReadOnlyMemory`1<byte> AttrValues;
}
internal class System.Security.Cryptography.Pkcs.Asn1.CadesIssuerSerial : ValueType {
    public GeneralName[] Issuer;
    [IntegerAttribute]
public ReadOnlyMemory`1<byte> SerialNumber;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.CertificateChoiceAsn : ValueType {
    [ExpectedTagAttribute("0", "16")]
[AnyValueAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> Certificate;
}
internal class System.Security.Cryptography.Pkcs.Asn1.ContentInfoAsn : ValueType {
    [ObjectIdentifierAttribute]
public string ContentType;
    [ExpectedTagAttribute("0")]
[AnyValueAttribute]
public ReadOnlyMemory`1<byte> Content;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.DirectoryString : ValueType {
    [ExpectedTagAttribute("0", "20")]
internal Nullable`1<ReadOnlyMemory`1<byte>> TeletexString;
    [PrintableStringAttribute]
internal string PrintableString;
    [ExpectedTagAttribute("0", "28")]
internal Nullable`1<ReadOnlyMemory`1<byte>> UniversalString;
    [UTF8StringAttribute]
internal string Utf8String;
    [BMPStringAttribute]
internal string BMPString;
}
internal class System.Security.Cryptography.Pkcs.Asn1.EdiPartyName : ValueType {
    [OptionalValueAttribute]
internal Nullable`1<DirectoryString> NameAssigner;
    internal DirectoryString PartyName;
}
internal class System.Security.Cryptography.Pkcs.Asn1.EncapsulatedContentInfoAsn : ValueType {
    [ObjectIdentifierAttribute]
public string ContentType;
    [OptionalValueAttribute]
[ExpectedTagAttribute("0")]
[AnyValueAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> Content;
}
internal class System.Security.Cryptography.Pkcs.Asn1.EncryptedContentInfoAsn : ValueType {
    [ObjectIdentifierAttribute]
internal string ContentType;
    internal AlgorithmIdentifierAsn ContentEncryptionAlgorithm;
    [OptionalValueAttribute]
[OctetStringAttribute]
[ExpectedTagAttribute("0")]
internal Nullable`1<ReadOnlyMemory`1<byte>> EncryptedContent;
}
internal class System.Security.Cryptography.Pkcs.Asn1.EnvelopedDataAsn : ValueType {
    public int Version;
    [OptionalValueAttribute]
[ExpectedTagAttribute("0")]
public OriginatorInfoAsn OriginatorInfo;
    [SetOfAttribute]
public RecipientInfoAsn[] RecipientInfos;
    public EncryptedContentInfoAsn EncryptedContentInfo;
    [ExpectedTagAttribute("1")]
[SetOfAttribute]
[OptionalValueAttribute]
public AttributeAsn[] UnprotectedAttributes;
}
internal class System.Security.Cryptography.Pkcs.Asn1.EssCertId : object {
    [OctetStringAttribute]
public ReadOnlyMemory`1<byte> Hash;
    [OptionalValueAttribute]
public Nullable`1<CadesIssuerSerial> IssuerSerial;
}
internal class System.Security.Cryptography.Pkcs.Asn1.EssCertIdV2 : object {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public AlgorithmIdentifierAsn HashAlgorithm;
    [OctetStringAttribute]
public ReadOnlyMemory`1<byte> Hash;
    [OptionalValueAttribute]
public Nullable`1<CadesIssuerSerial> IssuerSerial;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.GeneralName : ValueType {
    [ExpectedTagAttribute("0")]
internal Nullable`1<OtherName> OtherName;
    [ExpectedTagAttribute("1")]
[IA5StringAttribute]
internal string Rfc822Name;
    [ExpectedTagAttribute("2")]
[IA5StringAttribute]
internal string DnsName;
    [ExpectedTagAttribute("3")]
[AnyValueAttribute]
internal Nullable`1<ReadOnlyMemory`1<byte>> X400Address;
    [ExpectedTagAttribute("4")]
[AnyValueAttribute]
internal Nullable`1<ReadOnlyMemory`1<byte>> DirectoryName;
    [ExpectedTagAttribute("5")]
internal Nullable`1<EdiPartyName> EdiPartyName;
    [ExpectedTagAttribute("6")]
[IA5StringAttribute]
internal string Uri;
    [ExpectedTagAttribute("7")]
[OctetStringAttribute]
internal Nullable`1<ReadOnlyMemory`1<byte>> IPAddress;
    [ExpectedTagAttribute("8")]
[ObjectIdentifierAttribute]
internal string RegisteredId;
}
internal class System.Security.Cryptography.Pkcs.Asn1.IssuerAndSerialNumberAsn : ValueType {
    [AnyValueAttribute]
public ReadOnlyMemory`1<byte> Issuer;
    [IntegerAttribute]
public ReadOnlyMemory`1<byte> SerialNumber;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.KeyAgreeRecipientIdentifierAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    [ExpectedTagAttribute("0")]
internal RecipientKeyIdentifier RKeyId;
}
internal class System.Security.Cryptography.Pkcs.Asn1.KeyAgreeRecipientInfoAsn : object {
    internal int Version;
    [ExpectedTagAttribute("0")]
internal OriginatorIdentifierOrKeyAsn Originator;
    [OptionalValueAttribute]
[ExpectedTagAttribute("1")]
[OctetStringAttribute]
internal Nullable`1<ReadOnlyMemory`1<byte>> Ukm;
    internal AlgorithmIdentifierAsn KeyEncryptionAlgorithm;
    internal RecipientEncryptedKeyAsn[] RecipientEncryptedKeys;
}
internal class System.Security.Cryptography.Pkcs.Asn1.KeyTransRecipientInfoAsn : object {
    internal int Version;
    internal RecipientIdentifierAsn Rid;
    internal AlgorithmIdentifierAsn KeyEncryptionAlgorithm;
    [OctetStringAttribute]
internal ReadOnlyMemory`1<byte> EncryptedKey;
}
internal class System.Security.Cryptography.Pkcs.Asn1.MessageImprint : ValueType {
    internal AlgorithmIdentifierAsn HashAlgorithm;
    [OctetStringAttribute]
internal ReadOnlyMemory`1<byte> HashedMessage;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorIdentifierOrKeyAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    [OctetStringAttribute]
[ExpectedTagAttribute("0")]
internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
    [ExpectedTagAttribute("1")]
internal OriginatorPublicKeyAsn OriginatorKey;
}
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorInfoAsn : object {
    [OptionalValueAttribute]
[ExpectedTagAttribute("0")]
[SetOfAttribute]
public CertificateChoiceAsn[] CertificateSet;
    [OptionalValueAttribute]
[ExpectedTagAttribute("1")]
[AnyValueAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> RevocationInfoChoices;
}
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorPublicKeyAsn : object {
    internal AlgorithmIdentifierAsn Algorithm;
    [BitStringAttribute]
internal ReadOnlyMemory`1<byte> PublicKey;
}
internal class System.Security.Cryptography.Pkcs.Asn1.OtherKeyAttributeAsn : ValueType {
    [ObjectIdentifierAttribute]
internal string KeyAttrId;
    [OptionalValueAttribute]
[AnyValueAttribute]
internal Nullable`1<ReadOnlyMemory`1<byte>> KeyAttr;
}
internal class System.Security.Cryptography.Pkcs.Asn1.OtherName : ValueType {
    internal string TypeId;
    [ExpectedTagAttribute("0")]
[AnyValueAttribute]
internal ReadOnlyMemory`1<byte> Value;
}
[FlagsAttribute]
internal enum System.Security.Cryptography.Pkcs.Asn1.PkiFailureInfo : Enum {
    public int value__;
    public static PkiFailureInfo None;
    public static PkiFailureInfo BadAlg;
    public static PkiFailureInfo BadMessageCheck;
    public static PkiFailureInfo BadRequest;
    public static PkiFailureInfo BadTime;
    public static PkiFailureInfo BadCertId;
    public static PkiFailureInfo BadDataFormat;
    public static PkiFailureInfo WrongAuthority;
    public static PkiFailureInfo IncorrectData;
    public static PkiFailureInfo MissingTimeStamp;
    public static PkiFailureInfo BadPop;
    public static PkiFailureInfo CertRevoked;
    public static PkiFailureInfo CertConfirmed;
    public static PkiFailureInfo WrongIntegrity;
    public static PkiFailureInfo BadRecipientNonce;
    public static PkiFailureInfo TimeNotAvailable;
    public static PkiFailureInfo UnacceptedPolicy;
    public static PkiFailureInfo UnacceptedExtension;
    public static PkiFailureInfo AddInfoNotAvailable;
    public static PkiFailureInfo BadSenderNonce;
    public static PkiFailureInfo BadCertTemplate;
    public static PkiFailureInfo SignerNotTrusted;
    public static PkiFailureInfo TransactionIdInUse;
    public static PkiFailureInfo UnsupportedVersion;
    public static PkiFailureInfo NotAuthorized;
    public static PkiFailureInfo SystemUnavail;
    public static PkiFailureInfo SystemFailure;
    public static PkiFailureInfo DuplicateCertReq;
}
internal enum System.Security.Cryptography.Pkcs.Asn1.PkiStatus : Enum {
    public int value__;
    public static PkiStatus Granted;
    public static PkiStatus GrantedWithMods;
    public static PkiStatus Rejection;
    public static PkiStatus Waiting;
    public static PkiStatus RevocationWarning;
    public static PkiStatus RevocationNotification;
    public static PkiStatus KeyUpdateWarning;
}
internal class System.Security.Cryptography.Pkcs.Asn1.PkiStatusInfo : ValueType {
    public int Status;
    [OptionalValueAttribute]
[AnyValueAttribute]
[ExpectedTagAttribute("0", "16")]
public Nullable`1<ReadOnlyMemory`1<byte>> StatusString;
    [OptionalValueAttribute]
public Nullable`1<PkiFailureInfo> FailInfo;
}
internal class System.Security.Cryptography.Pkcs.Asn1.PolicyInformation : ValueType {
    [ObjectIdentifierAttribute]
public string PolicyIdentifier;
    [OptionalValueAttribute]
public PolicyQualifierInfo[] PolicyQualifiers;
}
internal class System.Security.Cryptography.Pkcs.Asn1.PolicyQualifierInfo : ValueType {
    [ObjectIdentifierAttribute]
public string PolicyQualifierId;
    [AnyValueAttribute]
public ReadOnlyMemory`1<byte> Qualifier;
}
internal class System.Security.Cryptography.Pkcs.Asn1.PssParamsAsn : ValueType {
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExpectedTagAttribute("0")]
public AlgorithmIdentifierAsn HashAlgorithm;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExpectedTagAttribute("1")]
public AlgorithmIdentifierAsn MaskGenAlgorithm;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExpectedTagAttribute("2")]
public int SaltLength;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExpectedTagAttribute("3")]
public int TrailerField;
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rc2CbcParameters : ValueType {
    private static Byte[] s_rc2EkbEncoding;
    internal int Rc2Version;
    [OctetStringAttribute]
internal ReadOnlyMemory`1<byte> Iv;
    internal Rc2CbcParameters(ReadOnlyMemory`1<byte> iv, int keySize);
    private static Rc2CbcParameters();
    internal int GetEffectiveKeyBits();
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientEncryptedKeyAsn : ValueType {
    internal KeyAgreeRecipientIdentifierAsn Rid;
    [OctetStringAttribute]
internal ReadOnlyMemory`1<byte> EncryptedKey;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientIdentifierAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    [OctetStringAttribute]
[ExpectedTagAttribute("0")]
internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientInfoAsn : ValueType {
    internal KeyTransRecipientInfoAsn Ktri;
    [ExpectedTagAttribute("1")]
internal KeyAgreeRecipientInfoAsn Kari;
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientKeyIdentifier : object {
    [OctetStringAttribute]
internal ReadOnlyMemory`1<byte> SubjectKeyIdentifier;
    [OptionalValueAttribute]
[GeneralizedTimeAttribute]
internal Nullable`1<DateTimeOffset> Date;
    [OptionalValueAttribute]
internal Nullable`1<OtherKeyAttributeAsn> Other;
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161Accuracy : ValueType {
    [OptionalValueAttribute]
internal Nullable`1<int> Seconds;
    [ExpectedTagAttribute("0")]
[OptionalValueAttribute]
internal Nullable`1<int> Millis;
    [ExpectedTagAttribute("1")]
[OptionalValueAttribute]
internal Nullable`1<int> Micros;
    internal long TotalMicros { get; }
    internal Rfc3161Accuracy(long accuracyInMicroseconds);
    internal long get_TotalMicros();
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TimeStampReq : ValueType {
    public int Version;
    public MessageImprint MessageImprint;
    [OptionalValueAttribute]
public Oid ReqPolicy;
    [OptionalValueAttribute]
[IntegerAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> Nonce;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public bool CertReq;
    [ExpectedTagAttribute("0")]
[OptionalValueAttribute]
internal X509ExtensionAsn[] Extensions;
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TimeStampResp : ValueType {
    public PkiStatusInfo Status;
    [AnyValueAttribute]
[OptionalValueAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> TimeStampToken;
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TstInfo : object {
    internal int Version;
    [ObjectIdentifierAttribute]
internal Oid Policy;
    internal MessageImprint MessageImprint;
    [IntegerAttribute]
internal ReadOnlyMemory`1<byte> SerialNumber;
    [GeneralizedTimeAttribute]
internal DateTimeOffset GenTime;
    [OptionalValueAttribute]
internal Nullable`1<Rfc3161Accuracy> Accuracy;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal bool Ordering;
    [IntegerAttribute]
[OptionalValueAttribute]
internal Nullable`1<ReadOnlyMemory`1<byte>> Nonce;
    [ExpectedTagAttribute("0")]
[OptionalValueAttribute]
internal Nullable`1<GeneralName> Tsa;
    [ExpectedTagAttribute("1")]
[OptionalValueAttribute]
internal X509ExtensionAsn[] Extensions;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.SignedAttributesSet : ValueType {
    [ExpectedTagAttribute("0")]
[SetOfAttribute]
public AttributeAsn[] SignedAttributes;
}
internal class System.Security.Cryptography.Pkcs.Asn1.SignedDataAsn : ValueType {
    public int Version;
    [SetOfAttribute]
public AlgorithmIdentifierAsn[] DigestAlgorithms;
    public EncapsulatedContentInfoAsn EncapContentInfo;
    [OptionalValueAttribute]
[ExpectedTagAttribute("0")]
[SetOfAttribute]
public CertificateChoiceAsn[] CertificateSet;
    [OptionalValueAttribute]
[ExpectedTagAttribute("1")]
[AnyValueAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> RevocationInfoChoices;
    [SetOfAttribute]
public SignerInfoAsn[] SignerInfos;
}
[ChoiceAttribute]
internal class System.Security.Cryptography.Pkcs.Asn1.SignerIdentifierAsn : ValueType {
    public Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    [OctetStringAttribute]
[ExpectedTagAttribute("0")]
public Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
}
internal class System.Security.Cryptography.Pkcs.Asn1.SignerInfoAsn : ValueType {
    public int Version;
    public SignerIdentifierAsn Sid;
    public AlgorithmIdentifierAsn DigestAlgorithm;
    [ExpectedTagAttribute("0")]
[OptionalValueAttribute]
[AnyValueAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> SignedAttributes;
    public AlgorithmIdentifierAsn SignatureAlgorithm;
    [OctetStringAttribute]
public ReadOnlyMemory`1<byte> SignatureValue;
    [ExpectedTagAttribute("1")]
[SetOfAttribute]
[OptionalValueAttribute]
public AttributeAsn[] UnsignedAttributes;
}
internal class System.Security.Cryptography.Pkcs.Asn1.SigningCertificateAsn : ValueType {
    public EssCertId[] Certs;
    [OptionalValueAttribute]
public PolicyInformation[] Policies;
}
internal class System.Security.Cryptography.Pkcs.Asn1.SigningCertificateV2Asn : ValueType {
    public EssCertIdV2[] Certs;
    [OptionalValueAttribute]
public PolicyInformation[] Policies;
}
internal class System.Security.Cryptography.Pkcs.Asn1.X509ExtensionAsn : ValueType {
    [ObjectIdentifierAttribute]
internal string ExtnId;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal bool Critical;
    [OctetStringAttribute]
internal ReadOnlyMemory`1<byte> ExtnValue;
    public X509ExtensionAsn(X509Extension extension, bool copyValue);
}
public class System.Security.Cryptography.Pkcs.CmsRecipient : object {
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <RecipientIdentifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public SubjectIdentifierType RecipientIdentifierType { get; }
    public X509Certificate2 Certificate { get; }
    public CmsRecipient(X509Certificate2 certificate);
    public CmsRecipient(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate);
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_RecipientIdentifierType();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.CmsRecipientCollection : object {
    private List`1<CmsRecipient> _recipients;
    public CmsRecipient Item { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CmsRecipientCollection(CmsRecipient recipient);
    public CmsRecipientCollection(SubjectIdentifierType recipientIdentifierType, X509Certificate2Collection certificates);
    public CmsRecipient get_Item(int index);
    public sealed virtual int get_Count();
    public int Add(CmsRecipient recipient);
    public void Remove(CmsRecipient recipient);
    public CmsRecipientEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(CmsRecipient[] array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
public class System.Security.Cryptography.Pkcs.CmsRecipientEnumerator : object {
    private CmsRecipientCollection _recipients;
    private int _current;
    public CmsRecipient Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal CmsRecipientEnumerator(CmsRecipientCollection recipients);
    public CmsRecipient get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal abstract class System.Security.Cryptography.Pkcs.CmsSignature : object {
    private static Dictionary`2<string, CmsSignature> s_lookup;
    private static CmsSignature();
    private static void PrepareRegistrationRsa(Dictionary`2<string, CmsSignature> lookup);
    private static void PrepareRegistrationDsa(Dictionary`2<string, CmsSignature> lookup);
    private static void PrepareRegistrationECDsa(Dictionary`2<string, CmsSignature> lookup);
    internal abstract virtual bool VerifySignature(ReadOnlySpan`1<byte> valueHash, ReadOnlyMemory`1<byte> signature, string digestAlgorithmOid, HashAlgorithmName digestAlgorithmName, Nullable`1<ReadOnlyMemory`1<byte>> signatureParameters, X509Certificate2 certificate);
    protected abstract virtual bool Sign(ReadOnlySpan`1<byte> dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, bool silent, Oid& signatureAlgorithm, Byte[]& signatureValue);
    internal static CmsSignature Resolve(string signatureAlgorithmOid);
    internal static bool Sign(ReadOnlySpan`1<byte> dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, bool silent, Oid& oid, ReadOnlyMemory`1& signatureValue);
    private static bool DsaDerToIeee(ReadOnlyMemory`1<byte> derSignature, Span`1<byte> ieeeSignature);
    private static Byte[] DsaIeeeToDer(ReadOnlySpan`1<byte> ieeeSignature);
}
public class System.Security.Cryptography.Pkcs.CmsSigner : object {
    private static Oid s_defaultAlgorithm;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private Oid <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509IncludeOption <IncludeOption>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <SignedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <SignerIdentifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <UnsignedAttributes>k__BackingField;
    public X509Certificate2 Certificate { get; public set; }
    public X509Certificate2Collection Certificates { get; private set; }
    public Oid DigestAlgorithm { get; public set; }
    public X509IncludeOption IncludeOption { get; public set; }
    public CryptographicAttributeObjectCollection SignedAttributes { get; private set; }
    public SubjectIdentifierType SignerIdentifierType { get; public set; }
    public CryptographicAttributeObjectCollection UnsignedAttributes { get; private set; }
    public CmsSigner(SubjectIdentifierType signerIdentifierType);
    public CmsSigner(X509Certificate2 certificate);
    public CmsSigner(CspParameters parameters);
    public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate);
    private static CmsSigner();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_Certificates();
    [CompilerGeneratedAttribute]
private void set_Certificates(X509Certificate2Collection value);
    [CompilerGeneratedAttribute]
public Oid get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DigestAlgorithm(Oid value);
    [CompilerGeneratedAttribute]
public X509IncludeOption get_IncludeOption();
    [CompilerGeneratedAttribute]
public void set_IncludeOption(X509IncludeOption value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_SignedAttributes();
    [CompilerGeneratedAttribute]
private void set_SignedAttributes(CryptographicAttributeObjectCollection value);
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_SignerIdentifierType();
    [CompilerGeneratedAttribute]
public void set_SignerIdentifierType(SubjectIdentifierType value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_UnsignedAttributes();
    [CompilerGeneratedAttribute]
private void set_UnsignedAttributes(CryptographicAttributeObjectCollection value);
    internal void CheckCertificateValue();
    internal SignerInfoAsn Sign(ReadOnlyMemory`1<byte> data, string contentTypeOid, bool silent, X509Certificate2Collection& chainCerts);
    internal static List`1<AttributeAsn> BuildAttributes(CryptographicAttributeObjectCollection attributes);
}
public class System.Security.Cryptography.Pkcs.ContentInfo : object {
    [CompilerGeneratedAttribute]
private Oid <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Content>k__BackingField;
    public Oid ContentType { get; }
    public Byte[] Content { get; }
    public ContentInfo(Byte[] content);
    public ContentInfo(Oid contentType, Byte[] content);
    [CompilerGeneratedAttribute]
public Oid get_ContentType();
    [CompilerGeneratedAttribute]
public Byte[] get_Content();
    public static Oid GetContentType(Byte[] encodedMessage);
}
public class System.Security.Cryptography.Pkcs.EnvelopedCms : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentInfo <ContentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <ContentEncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <UnprotectedAttributes>k__BackingField;
    private DecryptorPal _decryptorPal;
    private Byte[] _encodedMessage;
    private LastCall _lastCall;
    public int Version { get; private set; }
    public ContentInfo ContentInfo { get; private set; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; private set; }
    public X509Certificate2Collection Certificates { get; private set; }
    public CryptographicAttributeObjectCollection UnprotectedAttributes { get; private set; }
    public RecipientInfoCollection RecipientInfos { get; }
    public EnvelopedCms(ContentInfo contentInfo);
    public EnvelopedCms(ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    [CompilerGeneratedAttribute]
public ContentInfo get_ContentInfo();
    [CompilerGeneratedAttribute]
private void set_ContentInfo(ContentInfo value);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    [CompilerGeneratedAttribute]
private void set_ContentEncryptionAlgorithm(AlgorithmIdentifier value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_Certificates();
    [CompilerGeneratedAttribute]
private void set_Certificates(X509Certificate2Collection value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_UnprotectedAttributes();
    [CompilerGeneratedAttribute]
private void set_UnprotectedAttributes(CryptographicAttributeObjectCollection value);
    public RecipientInfoCollection get_RecipientInfos();
    public void Encrypt(CmsRecipient recipient);
    public void Encrypt(CmsRecipientCollection recipients);
    public Byte[] Encode();
    public void Decode(Byte[] encodedMessage);
    public void Decrypt();
    public void Decrypt(RecipientInfo recipientInfo);
    public void Decrypt(RecipientInfo recipientInfo, X509Certificate2Collection extraStore);
    public void Decrypt(X509Certificate2Collection extraStore);
    private void DecryptContent(RecipientInfoCollection recipientInfos, X509Certificate2Collection extraStore);
}
public class System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo : RecipientInfo {
    private SubjectIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRecipientIdentifier;
    private AlgorithmIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyEncryptionAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEncryptedKey;
    private SubjectIdentifierOrKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOriginatorIdentifierKey;
    private Nullable`1<DateTime> _lazyDate;
    private CryptographicAttributeObject modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOtherKeyAttribute;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
    public DateTime Date { get; }
    public CryptographicAttributeObject OtherKeyAttribute { get; }
    private KeyAgreeRecipientInfoPal Pal { get; }
    internal KeyAgreeRecipientInfo(KeyAgreeRecipientInfoPal pal);
    public virtual int get_Version();
    public virtual SubjectIdentifier get_RecipientIdentifier();
    public virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public virtual Byte[] get_EncryptedKey();
    public SubjectIdentifierOrKey get_OriginatorIdentifierOrKey();
    public DateTime get_Date();
    public CryptographicAttributeObject get_OtherKeyAttribute();
    private KeyAgreeRecipientInfoPal get_Pal();
}
public class System.Security.Cryptography.Pkcs.KeyTransRecipientInfo : RecipientInfo {
    private SubjectIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRecipientIdentifier;
    private AlgorithmIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyEncryptionAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEncryptedKey;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    private KeyTransRecipientInfoPal Pal { get; }
    internal KeyTransRecipientInfo(KeyTransRecipientInfoPal pal);
    public virtual int get_Version();
    public virtual SubjectIdentifier get_RecipientIdentifier();
    public virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public virtual Byte[] get_EncryptedKey();
    private KeyTransRecipientInfoPal get_Pal();
}
public class System.Security.Cryptography.Pkcs.Pkcs9AttributeObject : AsnEncodedData {
    public Oid Oid { get; }
    public Pkcs9AttributeObject(string oid, Byte[] encodedData);
    public Pkcs9AttributeObject(Oid oid, Byte[] encodedData);
    public Pkcs9AttributeObject(AsnEncodedData asnEncodedData);
    internal Pkcs9AttributeObject(Oid oid);
    public Oid get_Oid();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public class System.Security.Cryptography.Pkcs.Pkcs9ContentType : Pkcs9AttributeObject {
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazyContentType;
    public Oid ContentType { get; }
    public Oid get_ContentType();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Oid Decode(Byte[] rawData);
}
public class System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription : Pkcs9AttributeObject {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDocumentDescription;
    public string DocumentDescription { get; }
    public Pkcs9DocumentDescription(string documentDescription);
    public Pkcs9DocumentDescription(Byte[] encodedDocumentDescription);
    public string get_DocumentDescription();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static string Decode(Byte[] rawData);
    private static Byte[] Encode(string documentDescription);
}
public class System.Security.Cryptography.Pkcs.Pkcs9DocumentName : Pkcs9AttributeObject {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDocumentName;
    public string DocumentName { get; }
    public Pkcs9DocumentName(string documentName);
    public Pkcs9DocumentName(Byte[] encodedDocumentName);
    public string get_DocumentName();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static string Decode(Byte[] rawData);
    private static Byte[] Encode(string documentName);
}
public class System.Security.Cryptography.Pkcs.Pkcs9MessageDigest : Pkcs9AttributeObject {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMessageDigest;
    public Byte[] MessageDigest { get; }
    internal Pkcs9MessageDigest(ReadOnlySpan`1<byte> signatureDigest);
    public Byte[] get_MessageDigest();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] Decode(Byte[] rawData);
}
public class System.Security.Cryptography.Pkcs.Pkcs9SigningTime : Pkcs9AttributeObject {
    private Nullable`1<DateTime> _lazySigningTime;
    public DateTime SigningTime { get; }
    public Pkcs9SigningTime(DateTime signingTime);
    public Pkcs9SigningTime(Byte[] encodedSigningTime);
    public DateTime get_SigningTime();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static DateTime Decode(Byte[] rawData);
    private static Byte[] Encode(DateTime signingTime);
}
public class System.Security.Cryptography.Pkcs.PublicKeyInfo : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <KeyValue>k__BackingField;
    public AlgorithmIdentifier Algorithm { get; }
    public Byte[] KeyValue { get; }
    internal PublicKeyInfo(AlgorithmIdentifier algorithm, Byte[] keyValue);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_Algorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_KeyValue();
}
public abstract class System.Security.Cryptography.Pkcs.RecipientInfo : object {
    [CompilerGeneratedAttribute]
private RecipientInfoType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private RecipientInfoPal <Pal>k__BackingField;
    public RecipientInfoType Type { get; }
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    internal RecipientInfoPal Pal { get; }
    internal RecipientInfo(RecipientInfoType type, RecipientInfoPal pal);
    [CompilerGeneratedAttribute]
public RecipientInfoType get_Type();
    public abstract virtual int get_Version();
    public abstract virtual SubjectIdentifier get_RecipientIdentifier();
    public abstract virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public abstract virtual Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
internal RecipientInfoPal get_Pal();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.RecipientInfoCollection : object {
    private RecipientInfo[] _recipientInfos;
    public RecipientInfo Item { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal RecipientInfoCollection(RecipientInfo recipientInfo);
    internal RecipientInfoCollection(ICollection`1<RecipientInfo> recipientInfos);
    public RecipientInfo get_Item(int index);
    public sealed virtual int get_Count();
    public RecipientInfoEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(RecipientInfo[] array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
public class System.Security.Cryptography.Pkcs.RecipientInfoEnumerator : object {
    private RecipientInfoCollection _recipientInfos;
    private int _current;
    public RecipientInfo Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal RecipientInfoEnumerator(RecipientInfoCollection RecipientInfos);
    public RecipientInfo get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.Pkcs.RecipientInfoType : Enum {
    public int value__;
    public static RecipientInfoType Unknown;
    public static RecipientInfoType KeyTransport;
    public static RecipientInfoType KeyAgreement;
}
internal enum System.Security.Cryptography.Pkcs.Rfc3161RequestResponseStatus : Enum {
    public int value__;
    public static Rfc3161RequestResponseStatus Unknown;
    public static Rfc3161RequestResponseStatus Accepted;
    public static Rfc3161RequestResponseStatus DoesNotParse;
    public static Rfc3161RequestResponseStatus RequestFailed;
    public static Rfc3161RequestResponseStatus HashMismatch;
    public static Rfc3161RequestResponseStatus VersionTooNew;
    public static Rfc3161RequestResponseStatus NonceMismatch;
    public static Rfc3161RequestResponseStatus RequestedCertificatesMissing;
    public static Rfc3161RequestResponseStatus UnexpectedCertificates;
}
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest : object {
    private Byte[] _encodedBytes;
    private Rfc3161TimeStampReq _parsedData;
    public int Version { get; }
    public Oid HashAlgorithmId { get; }
    public Oid RequestedPolicyId { get; }
    public bool RequestSignerCertificate { get; }
    public bool HasExtensions { get; }
    public int get_Version();
    public ReadOnlyMemory`1<byte> GetMessageHash();
    public Oid get_HashAlgorithmId();
    public Oid get_RequestedPolicyId();
    public bool get_RequestSignerCertificate();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetNonce();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    public Rfc3161TimestampToken ProcessResponse(ReadOnlyMemory`1<byte> source, Int32& bytesConsumed);
    private bool ProcessResponse(ReadOnlyMemory`1<byte> source, Rfc3161TimestampToken& token, Rfc3161RequestResponseStatus& status, Int32& bytesConsumed, bool shouldThrow);
    public Byte[] Encode();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public static Rfc3161TimestampRequest CreateFromSignerInfo(SignerInfo signerInfo, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory`1<byte> hash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory`1<byte> hash, Oid hashAlgorithmId, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static bool TryDecode(ReadOnlyMemory`1<byte> encodedBytes, Rfc3161TimestampRequest& request, Int32& bytesConsumed);
    private Rfc3161RequestResponseStatus ValidateResponse(Rfc3161TimestampToken token, bool shouldThrow);
}
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampToken : object {
    private SignedCms _parsedDocument;
    private SignerInfo _signerInfo;
    private EssCertId _essCertId;
    private EssCertIdV2 _essCertIdV2;
    [CompilerGeneratedAttribute]
private Rfc3161TimestampTokenInfo <TokenInfo>k__BackingField;
    public Rfc3161TimestampTokenInfo TokenInfo { get; private set; }
    [CompilerGeneratedAttribute]
public Rfc3161TimestampTokenInfo get_TokenInfo();
    [CompilerGeneratedAttribute]
private void set_TokenInfo(Rfc3161TimestampTokenInfo value);
    public SignedCms AsSignedCms();
    private X509Certificate2 GetSignerCertificate(X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForData(ReadOnlySpan`1<byte> data, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForHash(ReadOnlySpan`1<byte> hash, HashAlgorithmName hashAlgorithm, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForHash(ReadOnlySpan`1<byte> hash, Oid hashAlgorithmId, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForSignerInfo(SignerInfo signerInfo, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    internal bool VerifyHash(ReadOnlySpan`1<byte> hash, string hashAlgorithmId);
    private bool VerifyData(ReadOnlySpan`1<byte> data);
    private static bool CheckCertificate(X509Certificate2 tsaCertificate, SignerInfo signer, EssCertId certId, EssCertIdV2 certId2, Rfc3161TimestampTokenInfo tokenInfo);
    public static bool TryDecode(ReadOnlyMemory`1<byte> source, Rfc3161TimestampToken& token, Int32& bytesConsumed);
    private static bool IssuerAndSerialMatch(CadesIssuerSerial issuerSerial, string issuerDirectoryName, string serialNumber);
    private static bool IssuerAndSerialMatch(CadesIssuerSerial issuerSerial, ReadOnlySpan`1<byte> issuerDirectoryName, ReadOnlySpan`1<byte> serialNumber);
    private static bool CertMatchesIds(X509Certificate2 signerCert, EssCertId certId, EssCertIdV2 certId2);
    private static bool TryGetCertIds(SignerInfo signer, EssCertId& certId, EssCertIdV2& certId2);
}
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo : object {
    private Byte[] _encodedBytes;
    private Rfc3161TstInfo _parsedData;
    private Nullable`1<ReadOnlyMemory`1<byte>> _tsaNameBytes;
    public int Version { get; }
    public Oid PolicyId { get; }
    public Oid HashAlgorithmId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public bool IsOrdering { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampTokenInfo(Oid policyId, Oid hashAlgorithmId, ReadOnlyMemory`1<byte> messageHash, ReadOnlyMemory`1<byte> serialNumber, DateTimeOffset timestamp, Nullable`1<long> accuracyInMicroseconds, bool isOrdering, Nullable`1<ReadOnlyMemory`1<byte>> nonce, Nullable`1<ReadOnlyMemory`1<byte>> tsaName, X509ExtensionCollection extensions);
    private Rfc3161TimestampTokenInfo(Byte[] copiedBytes, Rfc3161TstInfo tstInfo);
    public int get_Version();
    public Oid get_PolicyId();
    public Oid get_HashAlgorithmId();
    public ReadOnlyMemory`1<byte> GetMessageHash();
    public ReadOnlyMemory`1<byte> GetSerialNumber();
    public DateTimeOffset get_Timestamp();
    public Nullable`1<long> get_AccuracyInMicroseconds();
    public bool get_IsOrdering();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetNonce();
    public bool get_HasExtensions();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetTimestampAuthorityName();
    public X509ExtensionCollection GetExtensions();
    public Byte[] Encode();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryDecode(ReadOnlyMemory`1<byte> source, Rfc3161TimestampTokenInfo& timestampTokenInfo, Int32& bytesConsumed);
    private static bool TryDecode(ReadOnlyMemory`1<byte> source, bool ownsMemory, Rfc3161TstInfo& tstInfo, Int32& bytesConsumed, Byte[]& copiedBytes);
    private static Byte[] Encode(Oid policyId, Oid hashAlgorithmId, ReadOnlyMemory`1<byte> messageHash, ReadOnlyMemory`1<byte> serialNumber, DateTimeOffset timestamp, bool isOrdering, Nullable`1<long> accuracyInMicroseconds, Nullable`1<ReadOnlyMemory`1<byte>> nonce, Nullable`1<ReadOnlyMemory`1<byte>> tsaName, X509ExtensionCollection extensions);
}
public class System.Security.Cryptography.Pkcs.SignedCms : object {
    private SignedDataAsn _signedData;
    private bool _hasData;
    private Memory`1<byte> _heldData;
    private Nullable`1<ReadOnlyMemory`1<byte>> _heldContent;
    private bool _hasPkcs7Content;
    private string _contentType;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentInfo <ContentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Detached>k__BackingField;
    private static Oid s_cmsDataOid;
    public int Version { get; private set; }
    public ContentInfo ContentInfo { get; private set; }
    public bool Detached { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public SignerInfoCollection SignerInfos { get; }
    public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo, bool detached);
    public SignedCms(SubjectIdentifierType signerIdentifierType);
    public SignedCms(ContentInfo contentInfo);
    public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo);
    public SignedCms(ContentInfo contentInfo, bool detached);
    private static SignedCms();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    [CompilerGeneratedAttribute]
public ContentInfo get_ContentInfo();
    [CompilerGeneratedAttribute]
private void set_ContentInfo(ContentInfo value);
    [CompilerGeneratedAttribute]
public bool get_Detached();
    [CompilerGeneratedAttribute]
private void set_Detached(bool value);
    public X509Certificate2Collection get_Certificates();
    public SignerInfoCollection get_SignerInfos();
    public Byte[] Encode();
    public void Decode(Byte[] encodedMessage);
    internal void Decode(ReadOnlyMemory`1<byte> encodedMessage);
    internal static ReadOnlyMemory`1<byte> GetContent(ReadOnlyMemory`1<byte> wrappedContent, string contentType);
    public void ComputeSignature();
    public void ComputeSignature(CmsSigner signer);
    public void ComputeSignature(CmsSigner signer, bool silent);
    public void RemoveSignature(int index);
    public void RemoveSignature(SignerInfo signerInfo);
    internal ReadOnlySpan`1<byte> GetHashableContentSpan();
    internal void Reencode();
    private void UpdateMetadata();
    private void ConsiderDigestAddition(AlgorithmIdentifierAsn candidate);
    private void ConsiderDigestRemoval(AlgorithmIdentifierAsn candidate);
    internal void UpdateCertificatesFromAddition(X509Certificate2Collection newCerts);
    public void CheckSignature(bool verifySignatureOnly);
    public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly);
    private static void CheckSignatures(SignerInfoCollection signers, X509Certificate2Collection extraStore, bool verifySignatureOnly);
    public void CheckHash();
    internal SignedDataAsn& GetRawData();
    private static ContentInfo MakeEmptyContentInfo();
}
public class System.Security.Cryptography.Pkcs.SignerInfo : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectIdentifier <SignerIdentifier>k__BackingField;
    private Oid _digestAlgorithm;
    private AttributeAsn[] _signedAttributes;
    private Nullable`1<ReadOnlyMemory`1<byte>> _signedAttributesMemory;
    private Oid _signatureAlgorithm;
    private Nullable`1<ReadOnlyMemory`1<byte>> _signatureAlgorithmParameters;
    private ReadOnlyMemory`1<byte> _signature;
    private AttributeAsn[] _unsignedAttributes;
    private SignedCms _document;
    private X509Certificate2 _signerCertificate;
    private SignerInfo _parentSignerInfo;
    private CryptographicAttributeObjectCollection _parsedSignedAttrs;
    private CryptographicAttributeObjectCollection _parsedUnsignedAttrs;
    public int Version { get; }
    public SubjectIdentifier SignerIdentifier { get; }
    public CryptographicAttributeObjectCollection SignedAttributes { get; }
    public CryptographicAttributeObjectCollection UnsignedAttributes { get; }
    public X509Certificate2 Certificate { get; }
    public SignerInfoCollection CounterSignerInfos { get; }
    public Oid DigestAlgorithm { get; }
    public Oid SignatureAlgorithm { get; }
    internal SignerInfo(SignerInfoAsn& parsedData, SignedCms ownerDocument);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public SubjectIdentifier get_SignerIdentifier();
    public CryptographicAttributeObjectCollection get_SignedAttributes();
    public CryptographicAttributeObjectCollection get_UnsignedAttributes();
    internal ReadOnlyMemory`1<byte> GetSignatureMemory();
    public Byte[] GetSignature();
    public X509Certificate2 get_Certificate();
    public SignerInfoCollection get_CounterSignerInfos();
    public Oid get_DigestAlgorithm();
    public Oid get_SignatureAlgorithm();
    private SignerInfoCollection GetCounterSigners(AttributeAsn[] unsignedAttrs);
    public void ComputeCounterSignature();
    public void ComputeCounterSignature(CmsSigner signer);
    public void RemoveCounterSignature(int index);
    public void RemoveCounterSignature(SignerInfo counterSignerInfo);
    public void CheckSignature(bool verifySignatureOnly);
    public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly);
    public void CheckHash();
    private bool CheckHash(bool compatMode);
    private X509Certificate2 FindSignerCertificate();
    private static X509Certificate2 FindSignerCertificate(SubjectIdentifier signerIdentifier, X509Certificate2Collection extraStore);
    private IncrementalHash PrepareDigest(bool compatMode);
    private void Verify(X509Certificate2Collection extraStore, X509Certificate2 certificate, bool verifySignatureOnly);
    private bool VerifySignature(CmsSignature signatureProcessor, X509Certificate2 certificate, bool compatMode);
    private HashAlgorithmName GetDigestAlgorithm();
    internal static CryptographicAttributeObjectCollection MakeAttributeCollection(AttributeAsn[] attributes);
    private static CryptographicAttributeObject MakeAttribute(AttributeAsn attribute);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.SignerInfoCollection : object {
    private SignerInfo[] _signerInfos;
    public SignerInfo Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal SignerInfoCollection(SignerInfo[] signerInfos);
    internal SignerInfoCollection(SignerInfoAsn[] signedDataSignerInfos, SignedCms ownerDocument);
    public SignerInfo get_Item(int index);
    public sealed virtual int get_Count();
    public SignerInfoEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(SignerInfo[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    internal int FindIndexForSigner(SignerInfo signer);
}
public class System.Security.Cryptography.Pkcs.SignerInfoEnumerator : object {
    private SignerInfoCollection _signerInfos;
    private int _position;
    public SignerInfo Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal SignerInfoEnumerator(SignerInfoCollection signerInfos);
    public SignerInfo get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.Pkcs.SubjectIdentifier : object {
    private static string DummySignerSubjectName;
    internal static Byte[] DummySignerEncodedValue;
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public SubjectIdentifierType Type { get; }
    public object Value { get; }
    internal SubjectIdentifier(SubjectIdentifierType type, object value);
    internal SubjectIdentifier(SignerIdentifierAsn signerIdentifierAsn);
    internal SubjectIdentifier(Nullable`1<IssuerAndSerialNumberAsn> issuerAndSerialNumber, Nullable`1<ReadOnlyMemory`1<byte>> subjectKeyIdentifier);
    private static SubjectIdentifier();
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public class System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey : object {
    [CompilerGeneratedAttribute]
private SubjectIdentifierOrKeyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public SubjectIdentifierOrKeyType Type { get; }
    public object Value { get; }
    internal SubjectIdentifierOrKey(SubjectIdentifierOrKeyType type, object value);
    [CompilerGeneratedAttribute]
public SubjectIdentifierOrKeyType get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public enum System.Security.Cryptography.Pkcs.SubjectIdentifierOrKeyType : Enum {
    public int value__;
    public static SubjectIdentifierOrKeyType Unknown;
    public static SubjectIdentifierOrKeyType IssuerAndSerialNumber;
    public static SubjectIdentifierOrKeyType SubjectKeyIdentifier;
    public static SubjectIdentifierOrKeyType PublicKeyInfo;
}
public enum System.Security.Cryptography.Pkcs.SubjectIdentifierType : Enum {
    public int value__;
    public static SubjectIdentifierType Unknown;
    public static SubjectIdentifierType IssuerAndSerialNumber;
    public static SubjectIdentifierType SubjectKeyIdentifier;
    public static SubjectIdentifierType NoSignature;
}
public class System.Security.Cryptography.Xml.X509IssuerSerial : ValueType {
    [CompilerGeneratedAttribute]
private string <IssuerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerialNumber>k__BackingField;
    public string IssuerName { get; public set; }
    public string SerialNumber { get; public set; }
    internal X509IssuerSerial(string issuerName, string serialNumber);
    [CompilerGeneratedAttribute]
public string get_IssuerName();
    [CompilerGeneratedAttribute]
public void set_IssuerName(string value);
    [CompilerGeneratedAttribute]
public string get_SerialNumber();
    [CompilerGeneratedAttribute]
public void set_SerialNumber(string value);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static Type <ResourceType>k__BackingField;
    private static ResourceManager ResourceManager { get; }
    internal static Type ResourceType { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum { get; }
    internal static string Cryptography_Asn_NamedBitListRequiresFlagsEnum { get; }
    internal static string Cryptography_Asn_NamedBitListValueTooBig { get; }
    internal static string Cryptography_Asn_UniversalValueIsFixed { get; }
    internal static string Cryptography_Asn_UnusedBitCountRange { get; }
    internal static string Cryptography_AsnSerializer_AmbiguousFieldType { get; }
    internal static string Cryptography_AsnSerializer_Choice_AllowNullNonNullable { get; }
    internal static string Cryptography_AsnSerializer_Choice_ConflictingTagMapping { get; }
    internal static string Cryptography_AsnSerializer_Choice_DefaultValueDisallowed { get; }
    internal static string Cryptography_AsnSerializer_Choice_NoChoiceWasMade { get; }
    internal static string Cryptography_AsnSerializer_Choice_NonNullableField { get; }
    internal static string Cryptography_AsnSerializer_Choice_TooManyValues { get; }
    internal static string Cryptography_AsnSerializer_Choice_TypeCycle { get; }
    internal static string Cryptography_AsnSerializer_MultipleAsnTypeAttributes { get; }
    internal static string Cryptography_AsnSerializer_NoJaggedArrays { get; }
    internal static string Cryptography_AsnSerializer_NoMultiDimensionalArrays { get; }
    internal static string Cryptography_AsnSerializer_NoOpenTypes { get; }
    internal static string Cryptography_AsnSerializer_Optional_NonNullableField { get; }
    internal static string Cryptography_AsnSerializer_PopulateFriendlyNameOnString { get; }
    internal static string Cryptography_AsnSerializer_SetValueException { get; }
    internal static string Cryptography_AsnSerializer_SpecificTagChoice { get; }
    internal static string Cryptography_AsnSerializer_UnexpectedTypeForAttribute { get; }
    internal static string Cryptography_AsnSerializer_UtcTimeTwoDigitYearMaxTooSmall { get; }
    internal static string Cryptography_AsnSerializer_UnhandledType { get; }
    internal static string Cryptography_AsnWriter_EncodeUnbalancedStack { get; }
    internal static string Cryptography_AsnWriter_PopWrongTag { get; }
    internal static string Cryptography_BadHashValue { get; }
    internal static string Cryptography_BadSignature { get; }
    internal static string Cryptography_Cms_CannotDetermineSignatureAlgorithm { get; }
    internal static string Cryptography_Cms_IncompleteCertChain { get; }
    internal static string Cryptography_Cms_Invalid_Originator_Identifier_Choice { get; }
    internal static string Cryptography_Cms_Invalid_Subject_Identifier_Type { get; }
    internal static string Cryptography_Cms_InvalidMessageType { get; }
    internal static string Cryptography_Cms_InvalidSignerHashForSignatureAlg { get; }
    internal static string Cryptography_Cms_Key_Agree_Date_Not_Available { get; }
    internal static string Cryptography_Cms_MessageNotEncrypted { get; }
    internal static string Cryptography_Cms_MessageNotSigned { get; }
    internal static string Cryptography_Cms_MissingAuthenticatedAttribute { get; }
    internal static string Cryptography_Cms_NoCounterCounterSigner { get; }
    internal static string Cryptography_Cms_NoRecipients { get; }
    internal static string Cryptography_Cms_NoSignerCert { get; }
    internal static string Cryptography_Cms_NoSignerAtIndex { get; }
    internal static string Cryptography_Cms_RecipientNotFound { get; }
    internal static string Cryptography_Cms_RecipientType_NotSupported { get; }
    internal static string Cryptography_Cms_Sign_Empty_Content { get; }
    internal static string Cryptography_Cms_SignerNotFound { get; }
    internal static string Cryptography_Cms_Signing_RequiresPrivateKey { get; }
    internal static string Cryptography_Cms_TrustFailure { get; }
    internal static string Cryptography_Cms_UnknownAlgorithm { get; }
    internal static string Cryptography_Cms_UnknownKeySpec { get; }
    internal static string Cryptography_Cms_WrongKeyUsage { get; }
    internal static string Cryptography_Pkcs_InvalidSignatureParameters { get; }
    internal static string Cryptography_Pkcs9_AttributeMismatch { get; }
    internal static string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed { get; }
    internal static string Cryptography_Pkcs_PssParametersMissing { get; }
    internal static string Cryptography_Pkcs_PssParametersHashMismatch { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfHashMismatch { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfNotSupported { get; }
    internal static string Cryptography_Pkcs_PssParametersSaltMismatch { get; }
    internal static string Cryptography_TimestampReq_BadNonce { get; }
    internal static string Cryptography_TimestampReq_BadResponse { get; }
    internal static string Cryptography_TimestampReq_Failure { get; }
    internal static string Cryptography_TimestampReq_NoCertFound { get; }
    internal static string Cryptography_TimestampReq_UnexpectedCertFound { get; }
    internal static string InvalidOperation_DuplicateItemNotAllowed { get; }
    internal static string InvalidOperation_WrongOidInAsnCollection { get; }
    internal static string PlatformNotSupported_CryptographyPkcs { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_WriteEncodedValue_OneValueAtATime { get; }
    private static SR();
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [CompilerGeneratedAttribute]
internal static Type get_ResourceType();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum();
    internal static string get_Cryptography_Asn_NamedBitListRequiresFlagsEnum();
    internal static string get_Cryptography_Asn_NamedBitListValueTooBig();
    internal static string get_Cryptography_Asn_UniversalValueIsFixed();
    internal static string get_Cryptography_Asn_UnusedBitCountRange();
    internal static string get_Cryptography_AsnSerializer_AmbiguousFieldType();
    internal static string get_Cryptography_AsnSerializer_Choice_AllowNullNonNullable();
    internal static string get_Cryptography_AsnSerializer_Choice_ConflictingTagMapping();
    internal static string get_Cryptography_AsnSerializer_Choice_DefaultValueDisallowed();
    internal static string get_Cryptography_AsnSerializer_Choice_NoChoiceWasMade();
    internal static string get_Cryptography_AsnSerializer_Choice_NonNullableField();
    internal static string get_Cryptography_AsnSerializer_Choice_TooManyValues();
    internal static string get_Cryptography_AsnSerializer_Choice_TypeCycle();
    internal static string get_Cryptography_AsnSerializer_MultipleAsnTypeAttributes();
    internal static string get_Cryptography_AsnSerializer_NoJaggedArrays();
    internal static string get_Cryptography_AsnSerializer_NoMultiDimensionalArrays();
    internal static string get_Cryptography_AsnSerializer_NoOpenTypes();
    internal static string get_Cryptography_AsnSerializer_Optional_NonNullableField();
    internal static string get_Cryptography_AsnSerializer_PopulateFriendlyNameOnString();
    internal static string get_Cryptography_AsnSerializer_SetValueException();
    internal static string get_Cryptography_AsnSerializer_SpecificTagChoice();
    internal static string get_Cryptography_AsnSerializer_UnexpectedTypeForAttribute();
    internal static string get_Cryptography_AsnSerializer_UtcTimeTwoDigitYearMaxTooSmall();
    internal static string get_Cryptography_AsnSerializer_UnhandledType();
    internal static string get_Cryptography_AsnWriter_EncodeUnbalancedStack();
    internal static string get_Cryptography_AsnWriter_PopWrongTag();
    internal static string get_Cryptography_BadHashValue();
    internal static string get_Cryptography_BadSignature();
    internal static string get_Cryptography_Cms_CannotDetermineSignatureAlgorithm();
    internal static string get_Cryptography_Cms_IncompleteCertChain();
    internal static string get_Cryptography_Cms_Invalid_Originator_Identifier_Choice();
    internal static string get_Cryptography_Cms_Invalid_Subject_Identifier_Type();
    internal static string get_Cryptography_Cms_InvalidMessageType();
    internal static string get_Cryptography_Cms_InvalidSignerHashForSignatureAlg();
    internal static string get_Cryptography_Cms_Key_Agree_Date_Not_Available();
    internal static string get_Cryptography_Cms_MessageNotEncrypted();
    internal static string get_Cryptography_Cms_MessageNotSigned();
    internal static string get_Cryptography_Cms_MissingAuthenticatedAttribute();
    internal static string get_Cryptography_Cms_NoCounterCounterSigner();
    internal static string get_Cryptography_Cms_NoRecipients();
    internal static string get_Cryptography_Cms_NoSignerCert();
    internal static string get_Cryptography_Cms_NoSignerAtIndex();
    internal static string get_Cryptography_Cms_RecipientNotFound();
    internal static string get_Cryptography_Cms_RecipientType_NotSupported();
    internal static string get_Cryptography_Cms_Sign_Empty_Content();
    internal static string get_Cryptography_Cms_SignerNotFound();
    internal static string get_Cryptography_Cms_Signing_RequiresPrivateKey();
    internal static string get_Cryptography_Cms_TrustFailure();
    internal static string get_Cryptography_Cms_UnknownAlgorithm();
    internal static string get_Cryptography_Cms_UnknownKeySpec();
    internal static string get_Cryptography_Cms_WrongKeyUsage();
    internal static string get_Cryptography_Pkcs_InvalidSignatureParameters();
    internal static string get_Cryptography_Pkcs9_AttributeMismatch();
    internal static string get_Cryptography_Pkcs9_MultipleSigningTimeNotAllowed();
    internal static string get_Cryptography_Pkcs_PssParametersMissing();
    internal static string get_Cryptography_Pkcs_PssParametersHashMismatch();
    internal static string get_Cryptography_Pkcs_PssParametersMgfHashMismatch();
    internal static string get_Cryptography_Pkcs_PssParametersMgfNotSupported();
    internal static string get_Cryptography_Pkcs_PssParametersSaltMismatch();
    internal static string get_Cryptography_TimestampReq_BadNonce();
    internal static string get_Cryptography_TimestampReq_BadResponse();
    internal static string get_Cryptography_TimestampReq_Failure();
    internal static string get_Cryptography_TimestampReq_NoCertFound();
    internal static string get_Cryptography_TimestampReq_UnexpectedCertFound();
    internal static string get_InvalidOperation_DuplicateItemNotAllowed();
    internal static string get_InvalidOperation_WrongOidInAsnCollection();
    internal static string get_PlatformNotSupported_CryptographyPkcs();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_WriteEncodedValue_OneValueAtATime();
}
