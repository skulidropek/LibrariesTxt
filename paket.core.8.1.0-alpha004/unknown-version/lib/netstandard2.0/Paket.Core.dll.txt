[ObsoleteAttribute("Please use Fake.Core.Globbing.Glob instead")]
[CompilationMappingAttribute]
public static class Fake.Globbing : object {
    [CompilationMappingAttribute]
internal static Regex driveRegex { get; }
    [ObsoleteAttribute("This is no longer supported, please open an issue if you had a need for it.")]
[CompilationMappingAttribute]
public static ConcurrentDictionary`2<string, Regex> globRegexCache { get; }
    [ObsoleteAttribute("Please use Fake.Core.Globbing.Glob instead")]
public static string normalizePath(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> checkSubDirs(bool absolute, string dir, string root);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> buildPaths(FSharpList`1<string> acc, FSharpList`1<SearchOption> input);
    internal static Regex get_driveRegex();
    internal static string normalizeOutputPath(string p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getRoot(string baseDirectory, string pattern);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> search(string baseDir, string input);
    internal static Regex compileGlobToRegex(string pattern);
    public static ConcurrentDictionary`2<string, Regex> get_globRegexCache();
    [ObsoleteAttribute("Please use Fake.Core.Globbing.Glob instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isMatch(string pattern, string path);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class FSharp.Polyfill.AsyncExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OperationCanceledException getCancelledException(Task completedTask, FSharpFunc`2<Unit, Unit> waitWithAwaiter);
    public static FSharpAsync`1<Tuple`2<a, b>> Async.Parallel.Static(FSharpAsync`1<a> a, FSharpAsync`1<b> b);
    internal static void continuation@43(FSharpFunc`2<T, Unit> cont, FSharpFunc`2<Exception, Unit> econt, Task`1<T> completedTask);
    public static FSharpAsync`1<T> Async.AwaitTaskWithoutAggregate.Static(Task`1<T> task);
    internal static void continuation@58-1(FSharpFunc`2<Unit, Unit> cont, FSharpFunc`2<Exception, Unit> econt, Task completedTask);
    public static FSharpAsync`1<Unit> Async.AwaitTaskWithoutAggregate.Static(Task task);
    internal static void whenFinished@79(object l, FSharpRef`1<bool> finished, FSharpFunc`2<Unit, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<T> Async.awaitTaskWithToken.Static(FSharpFunc`2<Unit, T> fallBack, Task`1<T> item);
    public static FSharpAsync`1<d> Async.StartCatchCancellation.Static(FSharpAsync`1<d> work, FSharpOption`1<CancellationToken> cancellationToken);
    public static Task`1<c> Async.StartAsTaskProperCancel.Static(FSharpAsync`1<c> computation, FSharpOption`1<TaskCreationOptions> taskCreationOptions, FSharpOption`1<CancellationToken> cancellationToken);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<b> Async.map.Static(FSharpFunc`2<a, b> f, a a);
    internal static FSharpAsync`1<Tuple`2<Task`1[], FSharpOption`1<int>>> workNext@147(FSharpFunc`2<T, bool> f, FSharpList`1<Tuple`2<int, FSharpAsync`1<T>>> work, TaskCompletionSource`1[] results, Task`1[] retResults, FSharpList`1<Tuple`2<int, FSharpAsync`1<T>>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Tuple`2<Task`1[], FSharpOption`1<int>>> Async.tryFindSequential.Static(FSharpFunc`2<T, bool> f, IEnumerable`1<FSharpAsync`1<T>> tasks);
    internal static FSharpFunc`2<T, Unit> scont@179(FSharpFunc`2<T, bool> f, FSharpAsync`1[] tasks, FSharpFunc`2<Tuple`2<Task`1[], FSharpOption`1<int>>, Unit> sc, FSharpRef`1<int> currentIndex, FSharpRef`1<int> exnCount, CancellationTokenSource innerCts, TaskCompletionSource`1[] results, Task`1[] retResults, int index);
    internal static FSharpFunc`2<Exception, Unit> econt@189(FSharpFunc`2<Exception, Unit> ec, FSharpRef`1<int> exnCount, CancellationTokenSource innerCts, TaskCompletionSource`1[] results, int index);
    internal static FSharpFunc`2<OperationCanceledException, Unit> ccont@194(FSharpFunc`2<OperationCanceledException, Unit> cc, FSharpRef`1<int> exnCount, CancellationTokenSource innerCts, TaskCompletionSource`1[] results, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Tuple`2<Task`1[], FSharpOption`1<int>>> Async.tryFindParallel.Static(FSharpFunc`2<T, bool> f, IEnumerable`1<FSharpAsync`1<T>> tasks);
}
[CompilationMappingAttribute]
public class FSharp.Polyfill.VolatileBarrier : object {
    [VolatileFieldAttribute]
internal bool isStopped;
    public bool Proceed { get; }
    public bool get_Proceed();
    public void Stop();
}
[CompilationMappingAttribute]
public static class Paket.AddProcess : object {
    internal static GroupName matchGroupName(FSharpOption`1<string> groupName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool notInstalled(ProjectFile project, GroupName groupName, PackageName package);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addToProject(ProjectFile project, GroupName groupName, PackageName package);
    [CompilerGeneratedAttribute]
internal static void add$cont@27(FSharpFunc`2<IEnumerable`1<ProjectFile>, FSharpFunc`2<GroupName, FSharpFunc`2<PackageName, Unit>>> addToProjectsF, string dependenciesFileName, GroupName groupName, PackageName package, string version, InstallerOptions options, bool installAfter, bool runResolver, PackageRequirementKind packageKind, DependenciesFile existingDependenciesFile, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool add(bool installToProjects, FSharpFunc`2<IEnumerable`1<ProjectFile>, FSharpFunc`2<GroupName, FSharpFunc`2<PackageName, Unit>>> addToProjectsF, string dependenciesFileName, GroupName groupName, PackageName package, string version, InstallerOptions options, bool installAfter, bool runResolver, PackageRequirementKind packageKind);
    public static bool AddToProject(string dependenciesFileName, FSharpOption`1<string> groupName, PackageName package, string version, InstallerOptions options, string projectName, bool installAfter, bool runResolver, PackageRequirementKind packageKind);
    public static bool Add(string dependenciesFileName, FSharpOption`1<string> groupName, PackageName package, string version, InstallerOptions options, bool interactive, bool installAfter, bool runResolver, PackageRequirementKind packageKind);
    public static void AddGithub(string dependenciesFileName, FSharpOption`1<string> groupName, string repository, string file, string version, InstallerOptions options);
    public static void AddGit(string dependenciesFileName, FSharpOption`1<string> groupName, string repository, string version, InstallerOptions options);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.AnalyzerLanguage : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AnalyzerLanguage _unique_Any;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AnalyzerLanguage _unique_CSharp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AnalyzerLanguage _unique_FSharp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AnalyzerLanguage _unique_VisualBasic;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static AnalyzerLanguage Any { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAny { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static AnalyzerLanguage CSharp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCSharp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static AnalyzerLanguage FSharp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFSharp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static AnalyzerLanguage VisualBasic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVisualBasic { get; }
    private static AnalyzerLanguage();
    [DynamicDependencyAttribute("2016", "Paket.AnalyzerLanguage")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal AnalyzerLanguage(int _tag);
    [CompilationMappingAttribute]
public static AnalyzerLanguage get_Any();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAny();
    [CompilationMappingAttribute]
public static AnalyzerLanguage get_CSharp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCSharp();
    [CompilationMappingAttribute]
public static AnalyzerLanguage get_FSharp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFSharp();
    [CompilationMappingAttribute]
public static AnalyzerLanguage get_VisualBasic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVisualBasic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AnalyzerLanguage obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static AnalyzerLanguage FromDirectoryName(string str);
    public static AnalyzerLanguage FromDirectory(DirectoryInfo dir);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AnalyzerLanguage obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.AnalyzerLib : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Path@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal AnalyzerLanguage Language@;
    [CompilationMappingAttribute]
public string Path { get; }
    [CompilationMappingAttribute]
public AnalyzerLanguage Language { get; }
    [DynamicDependencyAttribute("1632", "Paket.AnalyzerLib")]
public AnalyzerLib(string path, AnalyzerLanguage language);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public AnalyzerLanguage get_Language();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AnalyzerLib obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static AnalyzerLib FromFile(FileInfo file);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AnalyzerLib obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.AuthService : object {
    public static AuthProvider GetGlobalAuthenticationProvider(string source);
}
[CompilationMappingAttribute]
public static class Paket.BindingRedirects : object {
    internal static string bindingNs { get; }
    internal static string baseConfig { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_bindingNs();
    internal static XContainer ensureAssemblyBinding(XContainer doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XDocument setRedirect(XDocument doc, BindingRedirect bindingRedirect);
    internal static void indentAssemblyBindings(XContainer config);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_baseConfig();
    internal static string createAppConfigInDirectory(string folder);
    internal static void addConfigFileToProject(ProjectFile project);
    internal static bool isMarked@118(XContainer e);
    internal static bool libIsContained@123(IEnumerable`1<string> allKnownLibNames, a e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void applyBindingRedirects(bool isFirstGroup, bool cleanBindingRedirects, IEnumerable`1<string> allKnownLibNames, IEnumerable`1<BindingRedirect> bindingRedirects, ProjectFile projectFile, string configFilePath);
    public static ProjectFile[] findAllReferencesFiles(string root);
    internal static void applyBindingRedirects@170-4(bool isFirstGroup, bool createNewBindingFiles, bool cleanBindingRedirects, IEnumerable`1<string> allKnownLibNames, FSharpFunc`2<ProjectFile, a> bindingRedirects, ProjectFile projectFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void applyBindingRedirectsToFolder(bool isFirstGroup, bool createNewBindingFiles, bool cleanBindingRedirects, string rootPath, IEnumerable`1<string> allKnownLibNames, FSharpFunc`2<ProjectFile, a> bindingRedirects);
    public static FSharpOption`1<string> getPublicKeyToken(AssemblyName assembly);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.BuildAction : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildAction _unique_Compile;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildAction _unique_Content;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildAction _unique_Reference;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildAction _unique_Resource;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildAction _unique_Page;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildAction Compile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCompile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildAction Content { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsContent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildAction Reference { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsReference { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildAction Resource { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsResource { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildAction Page { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPage { get; }
    public static FSharpList`1<string> PaketFileNodeNames { get; }
    private static BuildAction();
    [DynamicDependencyAttribute("2016", "Paket.BuildAction")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal BuildAction(int _tag);
    [CompilationMappingAttribute]
public static BuildAction get_Compile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCompile();
    [CompilationMappingAttribute]
public static BuildAction get_Content();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsContent();
    [CompilationMappingAttribute]
public static BuildAction get_Reference();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsReference();
    [CompilationMappingAttribute]
public static BuildAction get_Resource();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsResource();
    [CompilationMappingAttribute]
public static BuildAction get_Page();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPage();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(BuildAction obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpList`1<string> get_PaketFileNodeNames();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BuildAction obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.BuildMode : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildMode _unique_Debug;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildMode _unique_Release;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BuildMode _unique_NoBuildMode;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildMode Debug { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDebug { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildMode Release { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRelease { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static BuildMode NoBuildMode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoBuildMode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknownBuildMode { get; }
    public string AsString { get; }
    private static BuildMode();
    [DynamicDependencyAttribute("2016", "Paket.BuildMode")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal BuildMode(int _tag);
    [CompilationMappingAttribute]
public static BuildMode get_Debug();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDebug();
    [CompilationMappingAttribute]
public static BuildMode get_Release();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRelease();
    [CompilationMappingAttribute]
public static BuildMode get_NoBuildMode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoBuildMode();
    [CompilationMappingAttribute]
public static BuildMode NewUnknownBuildMode(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknownBuildMode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(BuildMode obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_AsString();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BuildMode obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.Cache : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Location@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<CacheType> CacheType@;
    [CompilationMappingAttribute]
public string Location { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<CacheType> CacheType { get; }
    [DynamicDependencyAttribute("1632", "Paket.Cache")]
public Cache(string location, FSharpOption`1<CacheType> cacheType);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<CacheType> get_CacheType();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Cache obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public Cache BaseOnRoot(string root);
    public static Cache Parse(string line);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Cache obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Paket.CacheExtensions : object {
    public static Nuspec Nuspec.LoadFromCache.Static(PackageName name, SemVerInfo version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string PackageInfo.Folder(PackageInfo x, string root, GroupName groupName);
}
[CompilationMappingAttribute]
public static class Paket.CacheModule : object {
    [CompilationMappingAttribute]
internal static object lockObj { get; }
    [CompilationMappingAttribute]
internal static HashSet`1<Cache> inaccessibleCaches { get; }
    internal static object get_lockObj();
    internal static HashSet`1<Cache> get_inaccessibleCaches();
    [CompilerGeneratedAttribute]
internal static void action@1-2(Cache cache, Unit unitVar0);
    public static void setInaccessible(Cache cache);
    [CompilerGeneratedAttribute]
internal static bool action@1-3(Cache cache, Unit unitVar0);
    public static bool isInaccessible(Cache cache);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.CacheType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CacheType _unique_AllVersions;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CacheType _unique_CurrentVersion;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CacheType AllVersions { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAllVersions { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CacheType CurrentVersion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCurrentVersion { get; }
    private static CacheType();
    [DynamicDependencyAttribute("2016", "Paket.CacheType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CacheType(int _tag);
    [CompilationMappingAttribute]
public static CacheType get_AllVersions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAllVersions();
    [CompilationMappingAttribute]
public static CacheType get_CurrentVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCurrentVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CacheType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CacheType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.CompatibilityProfile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<FrameworkIdentifier, FSharpList`1<Rid>> Supported@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public FSharpMap`2<FrameworkIdentifier, FSharpList`1<Rid>> Supported { get; }
    [DynamicDependencyAttribute("1632", "Paket.CompatibilityProfile")]
public CompatibilityProfile(string name, FSharpMap`2<FrameworkIdentifier, FSharpList`1<Rid>> supported);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpMap`2<FrameworkIdentifier, FSharpList`1<Rid>> get_Supported();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CompatibilityProfile obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompatibilityProfile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.CompileItem : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string SourceFile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string DestinationPath@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string BaseDir@;
    [CompilationMappingAttribute]
public string SourceFile { get; }
    [CompilationMappingAttribute]
public string DestinationPath { get; }
    [CompilationMappingAttribute]
public string BaseDir { get; }
    [DynamicDependencyAttribute("1632", "Paket.CompileItem")]
public CompileItem(string sourceFile, string destinationPath, string baseDir);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_SourceFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_DestinationPath();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_BaseDir();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CompileItem obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompileItem obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.CompleteCoreInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Id@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<SemVerInfo> Version@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Authors@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Description@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool Symbols@;
    [CompilationMappingAttribute]
public string Id { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<SemVerInfo> Version { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> Authors { get; }
    [CompilationMappingAttribute]
public string Description { get; }
    [CompilationMappingAttribute]
public bool Symbols { get; }
    public string PackageFileName { get; }
    public string NuspecFileName { get; }
    [DynamicDependencyAttribute("1632", "Paket.CompleteCoreInfo")]
public CompleteCoreInfo(string id, FSharpOption`1<SemVerInfo> version, FSharpList`1<string> authors, string description, bool symbols);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SemVerInfo> get_Version();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_Authors();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_Symbols();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CompleteCoreInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_PackageFileName();
    public string get_NuspecFileName();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompleteCoreInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.ConfigFile : object {
    internal static string rootElement { get; }
    [CompilationMappingAttribute]
internal static Lazy`1<XmlNode> getCredentialsNode { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Tuple`2<string, string>, FSharpOption`1<Auth>> GetAuthenticationForUrl { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Tuple`2<string, string>, FSharpOption`1<Auth>> cache@54-13 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_rootElement();
    internal static Result`2<XmlNode, DomainMessage> getConfigNode(string nodeName);
    internal static Result`2<Unit, DomainMessage> saveConfigNode(XmlNode node);
    public static string DecryptNuget(string encrypted);
    internal static string readPassword(string message);
    public static Auth getAuthFromNode(XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XmlElement createSourceNode(XmlNode credentialsNode, string source, string nodeName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XmlElement setCredentials(string username, string password, string authType, XmlElement node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XmlElement setToken(string token, XmlElement node);
    public static bool checkCredentials(string url, FSharpOption`1<Auth> cred);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<XmlElement> getSourceNodes(XmlNode credentialsNode, string source, string nodeType);
    internal static Lazy`1<XmlNode> get_getCredentialsNode();
    [CompilerGeneratedAttribute]
internal static XmlNode clo0@1(IEnumerable`1<DomainMessage> msgs);
    public static FSharpFunc`2<Tuple`2<string, string>, FSharpOption`1<Auth>> get_GetAuthenticationForUrl();
    internal static FSharpOption`1<Auth> f@63-9(string source, string tupledArg1);
    internal static ConcurrentDictionary`2<Tuple`2<string, string>, FSharpOption`1<Auth>> get_cache@54-13();
    public static AuthProvider GetAuthenticationProvider(string source);
    public static Result`2<Unit, DomainMessage> AddCredentials(string source, string username, string password, string authType);
    public static Result`2<Unit, DomainMessage> AddToken(string source, string token);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Unit, DomainMessage> askAndAddAuth(string source, string passedUserName, string passedPassword, string authType, bool verify);
}
[CompilationMappingAttribute]
public static class Paket.Constants : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string GitHubUrl;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string DefaultNuGetStream;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string DefaultNuGetV3Stream;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string GitHubReleasesUrl;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string GithubReleaseDownloadUrl;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string LockFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string LocalFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string RestoreHashFile;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string DependenciesFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string PaketFolderName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string BootstrapperFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string PaketFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string TargetsFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string ReferencesFile;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string AccessLockFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string PaketFilesFolderName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string DefaultPackagesFolderName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string SolutionFolderProjectGuid;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string PaketVersionFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string TemplateFile;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string PackagesConfigFile;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string NuGetConfigFile;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string FullProjectSourceFileName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string ProjectDefaultNameSpace;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string ProjectDefaultNameSpaceCore;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string NuGetProtocolVersion;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string GlobalPackagesFolderEnvironmentKey;
    [CompilationMappingAttribute]
public static GroupName MainDependencyGroup { get; }
    [CompilationMappingAttribute]
public static string AppDataFolder { get; }
    [CompilationMappingAttribute]
public static string PaketConfigFolder { get; }
    [CompilationMappingAttribute]
public static string PaketConfigFile { get; }
    [CompilationMappingAttribute]
public static string PaketRestoreHashFilePath { get; }
    [CompilationMappingAttribute]
public static string LocalRootForTempData { get; }
    [CompilationMappingAttribute]
internal static FSharpOption`1<string> arg@1 { get; }
    [CompilationMappingAttribute]
public static string GitRepoCacheFolder { get; }
    [CompilationMappingAttribute]
public static string UserNuGetPackagesFolder { get; }
    [CompilationMappingAttribute]
public static DateTime MagicUnlistingDate { get; }
    [CompilationMappingAttribute]
internal static DateTimeOffset copyOfStruct@125 { get; internal set; }
    [CompilationMappingAttribute]
public static string NuGetCacheFolder { get; }
    private static Constants();
    public static GroupName get_MainDependencyGroup();
    public static FSharpOption`1<string> getEnVar(string variable);
    public static FSharpOption`1<string> getEnvDir(SpecialFolder specialPath);
    public static string get_AppDataFolder();
    public static string get_PaketConfigFolder();
    public static string get_PaketConfigFile();
    public static string get_PaketRestoreHashFilePath();
    public static string get_LocalRootForTempData();
    internal static FSharpOption`1<string> get_arg@1();
    public static string get_GitRepoCacheFolder();
    public static string get_UserNuGetPackagesFolder();
    public static DateTime get_MagicUnlistingDate();
    internal static DateTimeOffset get_copyOfStruct@125();
    internal static void set_copyOfStruct@125(DateTimeOffset value);
    public static string get_NuGetCacheFolder();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class Paket.Core.Common.Aes : object {
    internal static void writePassword@67(string password, CryptoStream cryptoStream);
    internal static Tuple`3<Byte[], Byte[], Byte[]> encryptString(string password);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string decryptBytes(Byte[] encryptedBytes, Byte[] key, Byte[] iv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<AesEncryptedPassword, AesSalt> serialize(Byte[] password, Byte[] key, Byte[] iv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Byte[], Byte[], Byte[]> deserialize(AesEncryptedPassword _arg1, AesSalt aesSalt);
    public static Tuple`2<AesEncryptedPassword, AesSalt> encrypt(PlainTextPassword _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static PlainTextPassword decrypt(AesEncryptedPassword encryptedPassword, AesSalt aesSalt);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Core.Common.AesEncryptedPassword : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string Item { get; }
    [DynamicDependencyAttribute("1632", "Paket.Core.Common.AesEncryptedPassword")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal AesEncryptedPassword(string item);
    [CompilationMappingAttribute]
internal static AesEncryptedPassword NewAesEncryptedPassword(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AesEncryptedPassword obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AesEncryptedPassword obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
internal class Paket.Core.Common.AesIV`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T Item { get; }
    [DynamicDependencyAttribute("1632", "Paket.Core.Common.AesIV`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal AesIV`1(T item);
    [CompilationMappingAttribute]
internal static AesIV`1<T> NewAesIV(T item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AesIV`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AesIV`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
internal class Paket.Core.Common.AesKey`1 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T Item { get; }
    [DynamicDependencyAttribute("1632", "Paket.Core.Common.AesKey`1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal AesKey`1(T item);
    [CompilationMappingAttribute]
internal static AesKey`1<T> NewAesKey(T item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AesKey`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AesKey`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Core.Common.AesSalt : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string Item { get; }
    [DynamicDependencyAttribute("1632", "Paket.Core.Common.AesSalt")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal AesSalt(string item);
    [CompilationMappingAttribute]
internal static AesSalt NewAesSalt(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AesSalt obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AesSalt obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
internal static class Paket.Core.Common.AesSaltModule : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string saltSeparator;
    private static AesSaltModule();
    internal static Tuple`2<AesKey`1<Byte[]>, AesIV`1<Byte[]>> toBytes(AesKey`1<string> _arg1, AesIV`1<string> _arg2);
    internal static AesSalt encode(AesKey`1<Byte[]> _arg1, AesIV`1<Byte[]> _arg2);
    internal static Tuple`2<AesKey`1<string>, AesIV`1<string>> decode(AesSalt _arg1);
    internal static FSharpOption`1<AesSalt> |IsAesSalt|_|(string str);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class Paket.Core.Common.Crypto : object {
    public static Tuple`2<EncryptedPassword, Salt> encrypt(PlainTextPassword plainTextPassword);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static PlainTextPassword decrypt(string password, string salt);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class Paket.Core.Common.DPApi : object {
    public static Tuple`2<DPApiEncryptedPassword, DPApiSalt> encrypt(PlainTextPassword _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static PlainTextPassword decrypt(string encryptedPassword, string salt);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Core.Common.DPApiEncryptedPassword : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string Item { get; }
    [DynamicDependencyAttribute("1632", "Paket.Core.Common.DPApiEncryptedPassword")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DPApiEncryptedPassword(string item);
    [CompilationMappingAttribute]
internal static DPApiEncryptedPassword NewDPApiEncryptedPassword(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DPApiEncryptedPassword obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DPApiEncryptedPassword obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Core.Common.DPApiSalt : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string Item { get; }
    [DynamicDependencyAttribute("1632", "Paket.Core.Common.DPApiSalt")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DPApiSalt(string item);
    [CompilationMappingAttribute]
internal static DPApiSalt NewDPApiSalt(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DPApiSalt obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DPApiSalt obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
internal static class Paket.Core.Common.DPApiSaltModule : object {
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Byte[], Unit> fillRandomBytes { get; }
    [CompilationMappingAttribute]
internal static RandomNumberGenerator provider@113 { get; }
    internal static FSharpFunc`2<Byte[], Unit> get_fillRandomBytes();
    internal static RandomNumberGenerator get_provider@113();
    internal static DPApiSalt encode(Byte[] bytes);
    internal static Byte[] getRandomSalt();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.Core.Common.EncryptedPassword : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDPApi { get; }
    [CompilationMappingAttribute]
public static EncryptedPassword NewAes(AesEncryptedPassword item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAes();
    [CompilationMappingAttribute]
public static EncryptedPassword NewDPApi(DPApiEncryptedPassword item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDPApi();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(EncryptedPassword obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(EncryptedPassword obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Core.Common.PlainTextPassword : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string Item { get; }
    [DynamicDependencyAttribute("1632", "Paket.Core.Common.PlainTextPassword")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PlainTextPassword(string item);
    [CompilationMappingAttribute]
public static PlainTextPassword NewPlainTextPassword(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PlainTextPassword obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PlainTextPassword obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.Core.Common.Salt : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDPApi { get; }
    [CompilationMappingAttribute]
public static Salt NewAes(AesSalt item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAes();
    [CompilationMappingAttribute]
public static Salt NewDPApi(DPApiSalt item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDPApi();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Salt obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Salt obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public enum Paket.CredentialProviderExitCode : Enum {
    public int value__;
    public static CredentialProviderExitCode Success;
    public static CredentialProviderExitCode ProviderNotApplicable;
    public static CredentialProviderExitCode Abort;
}
[CompilationMappingAttribute]
public class Paket.CredentialProviderParameters : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Uri@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool NonInteractive@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsRetry@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal CredentialProviderVerbosity Verbosity@;
    [CompilationMappingAttribute]
public string Uri { get; }
    [CompilationMappingAttribute]
public bool NonInteractive { get; }
    [CompilationMappingAttribute]
public bool IsRetry { get; }
    [CompilationMappingAttribute]
public CredentialProviderVerbosity Verbosity { get; }
    [DynamicDependencyAttribute("1632", "Paket.CredentialProviderParameters")]
public CredentialProviderParameters(string uri, bool nonInteractive, bool isRetry, CredentialProviderVerbosity verbosity);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRetry();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public CredentialProviderVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CredentialProviderParameters obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CredentialProviderParameters obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.CredentialProviderResult : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSuccess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoCredentials { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAbort { get; }
    [CompilationMappingAttribute]
public static CredentialProviderResult NewSuccess(FSharpList`1<UserPassword> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSuccess();
    [CompilationMappingAttribute]
public static CredentialProviderResult NewNoCredentials(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoCredentials();
    [CompilationMappingAttribute]
public static CredentialProviderResult NewAbort(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAbort();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CredentialProviderResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CredentialProviderResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.CredentialProviderResultMessage : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Username@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Password@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Message@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] AuthTypes@;
    [JsonPropertyAttribute("Username")]
[CompilationMappingAttribute]
public string Username { get; }
    [JsonPropertyAttribute("Password")]
[CompilationMappingAttribute]
public string Password { get; }
    [JsonPropertyAttribute("Message")]
[CompilationMappingAttribute]
public string Message { get; }
    [JsonPropertyAttribute("AuthTypes")]
[CompilationMappingAttribute]
public String[] AuthTypes { get; }
    public bool IsValid { get; }
    [DynamicDependencyAttribute("1632", "Paket.CredentialProviderResultMessage")]
public CredentialProviderResultMessage(string username, string password, string message, String[] authTypes);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public String[] get_AuthTypes();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CredentialProviderResultMessage obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CredentialProviderResultMessage obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.CredentialProviders : object {
    public static string patternExe { get; }
    public static string patternDll { get; }
    public static string envVar { get; }
    [CompilationMappingAttribute]
public static string directoryRoot { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Tuple`2<string, AuthType>> availableAuthTypes { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, CredentialProviderResult> _providerCredentialCache { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_patternExe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_patternDll();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_envVar();
    public static string get_directoryRoot();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<string> findAll(string rootPath, IEnumerable`1<string> customPaths, string assemblyPattern, string paketDirectoryAssemblyPattern);
    public static FSharpList`1<string> findPathsFromEnvVar(string key);
    public static FSharpList`1<string> collectProviders();
    public static string formatCommandLine(CredentialProviderParameters args);
    internal static FSharpList`1<Tuple`2<string, AuthType>> get_availableAuthTypes();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CredentialProviderResult callProvider(string provider, CredentialProviderParameters args);
    internal static ConcurrentDictionary`2<string, CredentialProviderResult> get__providerCredentialCache();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getKey(string provider, string source);
    [CompilerGeneratedAttribute]
internal static CredentialProviderResult action@1-1(bool isRetry, string provider, string source, string key, CredentialProviderParameters args, Unit _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CredentialProviderResult handleProvider(bool isRetry, string provider, string source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<UserPassword> GetAuthenticationDirect(string source, bool isRetry);
    public static AuthProvider GetAuthenticationProvider(string source);
}
[CompilationMappingAttribute]
public class Paket.CredentialProviderUnknownStatusException : Exception {
    public CredentialProviderUnknownStatusException(string msg, Exception inner);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.CredentialProviderVerbosity : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CredentialProviderVerbosity _unique_Normal;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CredentialProviderVerbosity _unique_Quiet;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CredentialProviderVerbosity _unique_Detailed;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CredentialProviderVerbosity Normal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNormal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CredentialProviderVerbosity Quiet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsQuiet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CredentialProviderVerbosity Detailed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDetailed { get; }
    private static CredentialProviderVerbosity();
    [DynamicDependencyAttribute("2016", "Paket.CredentialProviderVerbosity")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CredentialProviderVerbosity(int _tag);
    [CompilationMappingAttribute]
public static CredentialProviderVerbosity get_Normal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNormal();
    [CompilationMappingAttribute]
public static CredentialProviderVerbosity get_Quiet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsQuiet();
    [CompilationMappingAttribute]
public static CredentialProviderVerbosity get_Detailed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDetailed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CredentialProviderVerbosity obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CredentialProviderVerbosity obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Paket.CulturesModule : object {
    public static bool isLanguageName(string text);
}
[CompilationMappingAttribute]
public class Paket.Dependencies : object {
    internal string dependenciesFileName;
    public string DependenciesFile { get; }
    public string RootPath { get; }
    internal DirectoryInfo RootDirectory { get; }
    public Dependencies(string dependenciesFileName);
    public static void ClearCache(FSharpOption`1<bool> clearLocalCache);
    public static Dependencies Locate();
    public static FSharpOption`1<Dependencies> TryLocate();
    public LockFile GetLockFile();
    public DependenciesFile GetDependenciesFile();
    public static Dependencies Locate(string path);
    public static FSharpOption`1<Dependencies> TryLocate(string path);
    public static void Init();
    public static void Init(string directory);
    public static void Init(string directory, FSharpList`1<PackageSource> sources, FSharpList`1<string> additional, d downloadBootstrapper);
    public static void ConvertFromNuget(bool force, bool installAfter, bool initAutoRestore, FSharpOption`1<string> credsMigrationMode, FSharpOption`1<DirectoryInfo> directory);
    public void Simplify(bool interactive);
    public string get_DependenciesFile();
    public string get_RootPath();
    internal DirectoryInfo get_RootDirectory();
    internal c Process(FSharpFunc`2<PaketEnv, Result`2<c, DomainMessage>> f);
    public void Add(FSharpOption`1<string> groupName, string package);
    public void Add(string package);
    public void Add(FSharpOption`1<string> groupName, string package, string version);
    public void Add(FSharpOption`1<string> groupName, string package, string version, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, bool interactive, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs);
    public void Add(FSharpOption`1<string> groupName, string package, string version, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, bool interactive, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs, bool runResolver);
    public void Add(FSharpOption`1<string> groupName, string package, string version, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, bool interactive, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs, bool runResolver, PackageRequirementKind packageKind);
    public void AddGithub(FSharpOption`1<string> groupName, string repository, string file);
    public void AddGithub(FSharpOption`1<string> groupName, string repository, string file, string version);
    public void AddGithub(FSharpOption`1<string> groupName, string repository, string file, string version, InstallerOptions options);
    public void AddGit(FSharpOption`1<string> groupName, string repository);
    public void AddGit(FSharpOption`1<string> groupName, string repository, string version);
    public void AddGit(FSharpOption`1<string> groupName, string repository, string version, InstallerOptions options);
    public void AddToProject(FSharpOption`1<string> groupName, string package, string version, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, string projectName, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs);
    public void AddToProject(FSharpOption`1<string> groupName, string package, string version, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, string projectName, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs, bool runResolver);
    public void AddToProject(FSharpOption`1<string> groupName, string package, string version, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, string projectName, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs, bool runResolver, PackageRequirementKind packageKind);
    public void AddCredentials(string source, string username, string password, string authType);
    public void AddCredentials(string source, string username, string password, string authType, bool verify);
    public void AddToken(string source, string token);
    public void Install(bool force);
    public void Install(bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, bool onlyReferenced, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs, bool generateLoadScripts, FSharpList`1<string> providedFrameworks, FSharpList`1<string> providedScriptTypes, FSharpOption`1<string> alternativeProjectRoot);
    internal void Install(InstallerOptions options);
    public static void Install(string dependencies, FSharpOption`1<string> path, FSharpOption`1<bool> force, FSharpOption`1<bool> withBindingRedirects, FSharpOption`1<bool> cleanBindingRedirects, FSharpOption`1<bool> createNewBindingFiles, FSharpOption`1<bool> onlyReferenced, FSharpOption`1<SemVerUpdateMode> semVerUpdateMode, FSharpOption`1<bool> touchAffectedRefs, FSharpOption`1<bool> generateLoadScripts, FSharpOption`1<FSharpList`1<string>> providedFrameworks, FSharpOption`1<FSharpList`1<string>> providedScriptTypes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpList`1<ScriptContent> GenerateLoadScriptData(string paketDependencies, FSharpList`1<string> groups, FSharpList`1<string> frameworks, FSharpList`1<string> scriptTypes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public void GenerateLoadScripts(FSharpList`1<string> groups, FSharpList`1<string> frameworks, FSharpList`1<string> scriptTypes);
    public void Update(bool force);
    public void Update(bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles);
    public void Update(bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs);
    public void UpdateGroup(string groupName, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs);
    public void UpdateFilteredPackages(FSharpOption`1<string> groupName, string package, FSharpOption`1<string> version, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs);
    public void UpdatePackage(FSharpOption`1<string> groupName, string package, FSharpOption`1<string> version, bool force, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs);
    public void UpdatePackage(FSharpOption`1<string> groupName, string package, FSharpOption`1<string> version, bool force, bool withBindingRedirects, bool cleanBindingRedirects, bool createNewBindingFiles, bool installAfter, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs);
    public void Restore(bool ignoreChecks);
    public void Restore();
    public void SimplePackagesRestore();
    public void Restore(FSharpOption`1<string> group, FSharpList`1<string> files, bool ignoreChecks);
    public void Restore(FSharpOption`1<string> group, FSharpList`1<string> files);
    public void Restore(bool force, FSharpOption`1<string> group, FSharpList`1<string> files, bool touchAffectedRefs, bool ignoreChecks, bool failOnChecks, FSharpOption`1<string> targetFramework, FSharpOption`1<string> outputPath);
    public void Restore(bool force, FSharpOption`1<string> group, string project, bool touchAffectedRefs, bool ignoreChecks, bool failOnChecks, FSharpOption`1<string> targetFramework, FSharpOption`1<string> outputPath);
    public void Restore(bool force, FSharpOption`1<string> group, bool onlyReferenced, bool touchAffectedRefs, bool ignoreChecks, bool failOnFailedChecks, FSharpOption`1<string> targetFramework, FSharpOption`1<string> outputPath);
    [ObsoleteAttribute("Use ShowOutdated with the force parameter set to true to get the old behavior")]
public void ShowOutdated(bool strict, bool includePrereleases, FSharpOption`1<string> groupName);
    public void ShowOutdated(bool strict, bool force, bool includePrereleases, FSharpOption`1<string> groupName);
    [ObsoleteAttribute("Use FindOutdated with the force parameter set to true to get the old behavior")]
public FSharpList`1<Tuple`3<string, string, SemVerInfo>> FindOutdated(bool strict, bool includePrereleases, FSharpOption`1<string> groupName);
    public FSharpList`1<Tuple`3<string, string, SemVerInfo>> FindOutdated(bool strict, bool force, bool includePrereleases, FSharpOption`1<string> groupName);
    public void DownloadLatestBootstrapper();
    public void TurnOnAutoRestore();
    public void TurnOffAutoRestore();
    public FSharpOption`1<string> GetInstalledVersion(string packageName);
    public FSharpOption`1<string> GetInstalledVersion(FSharpOption`1<string> groupName, string packageName);
    public FSharpList`1<Tuple`3<string, string, string>> GetInstalledPackages();
    public FSharpMap`2<GroupName, FSharpList`1<PackageSource>> GetSources();
    public FSharpList`1<string> GetDefinedNuGetFeeds();
    public FSharpList`1<Tuple`3<string, string, string>> GetInstalledPackages(ReferencesFile referencesFile);
    public InstallModel GetInstalledPackageModel(FSharpOption`1<string> groupName, string packageName);
    public IEnumerable`1<Library> GetLibraries(FSharpOption`1<string> groupName, string packageName, TargetProfile frameworkIdentifier);
    public FSharpList`1<Tuple`3<string, string, string>> GetDirectDependencies(ReferencesFile referencesFile);
    public FSharpList`1<Tuple`3<string, string, string>> GetDirectDependencies();
    public FSharpList`1<string> GetGroups();
    public FSharpList`1<Tuple`3<string, string, string>> GetDirectDependenciesForPackage(GroupName groupName, string packageName);
    public void Remove(string package);
    public void Remove(FSharpOption`1<string> groupName, string package);
    public void Remove(FSharpOption`1<string> groupName, string package, bool force, bool interactive, bool installAfter);
    public void RemoveFromProject(FSharpOption`1<string> groupName, string package, bool force, string projectName, bool installAfter);
    public void ShowReferencesFor(FSharpList`1<Tuple`2<string, string>> packages);
    public FSharpList`1<string> FindReferencesFor(string package);
    public FSharpList`1<string> FindReferencesFor(string group, string package);
    internal static IEnumerable`1<FSharpAsync`1<String[]>> FindPackagesByNameAsync(IEnumerable`1<PackageSource> sources, string searchTerm, FSharpOption`1<int> maxResults);
    public static FSharpList`1<string> FindPackagesByName(IEnumerable`1<PackageSource> sources, string searchTerm, FSharpOption`1<int> maxResults);
    public static IObservable`1<string> SearchPackagesByName(IEnumerable`1<PackageSource> sources, string searchTerm, FSharpOption`1<CancellationToken> cancellationToken, FSharpOption`1<int> maxResults);
    public IObservable`1<string> SearchPackagesByName(string searchTerm, FSharpOption`1<CancellationToken> cancellationToken, FSharpOption`1<int> maxResults);
    public static String[] FindPackageVersions(string root, IEnumerable`1<PackageSource> sources, string name, FSharpOption`1<int> maxResults, FSharpOption`1<string> alternativeProjectRoot);
    public String[] FindPackageVersions(IEnumerable`1<PackageSource> sources, string name, FSharpOption`1<int> maxResults);
    public FSharpList`1<ProjectFile> FindProjectsFor(string group, string package);
    public void Pack(string outputPath, FSharpOption`1<string> buildConfig, FSharpOption`1<string> buildPlatform, FSharpOption`1<string> version, FSharpOption`1<IEnumerable`1<Tuple`2<string, string>>> specificVersions, FSharpOption`1<string> releaseNotes, FSharpOption`1<string> templateFile, FSharpOption`1<string> workingDir, FSharpOption`1<b> excludedTemplates, FSharpOption`1<bool> lockDependencies, FSharpOption`1<bool> minimumFromLockFile, FSharpOption`1<bool> pinProjectReferences, FSharpOption`1<FSharpOption`1<InterprojectReferencesConstraint>> interprojectReferencesConstraint, FSharpOption`1<bool> symbols, FSharpOption`1<bool> includeReferencedProjects, FSharpOption`1<string> projectUrl);
    public static void Push(string packageFileName, FSharpOption`1<string> url, FSharpOption`1<string> apiKey, FSharpOption`1<string> endPoint, FSharpOption`1<a> paketVersion, FSharpOption`1<int> maxTrials, FSharpOption`1<bool> ignoreConflicts);
    public FSharpList`1<TemplateFile> ListTemplateFiles();
    [ObsoleteAttribute("Use a real references file instead. Note that this overload doesn't take a 'real' references file.")]
public static void FixNuspecs(string referencesFile, FSharpList`1<string> nuspecFileList);
    public static void FixNuspecs(ProjectFile projectFile, ReferencesFile referencesFile, FSharpList`1<string> nuspecFileList);
    [CompilerGeneratedAttribute]
internal FSharpList`1<Tuple`3<string, string, string>> listPackages(IEnumerable`1<KeyValuePair`2<Tuple`2<GroupName, PackageName>, PackageInfo>> packages);
}
[CompilationMappingAttribute]
public class Paket.DependenciesFile : object {
    internal String[] textRepresentation;
    internal FSharpMap`2<GroupName, DependenciesGroup> groups;
    internal string fileName;
    public string FileName { get; }
    public FSharpOption`1<FileInfo> FileInfo { get; }
    public FSharpMap`2<GroupName, DependenciesGroup> Groups { get; }
    public FSharpOption`1<DirectoryInfo> DirectoryInfo { get; }
    public string Directory { get; }
    public String[] Lines { get; }
    public string RootPath { get; }
    public DependenciesFile(string fileName, FSharpMap`2<GroupName, DependenciesGroup> groups, String[] textRepresentation);
    public string get_FileName();
    public FSharpOption`1<FileInfo> get_FileInfo();
    public FSharpMap`2<GroupName, DependenciesGroup> get_Groups();
    public FSharpOption`1<DirectoryInfo> get_DirectoryInfo();
    public string get_Directory();
    public String[] get_Lines();
    public string get_RootPath();
    public FSharpMap`2<PackageName, VersionRequirement> GetDependenciesInGroup(GroupName groupName);
    public string CheckIfPackageExistsInAnyGroup(PackageName packageName);
    public DependenciesFile SimplifyFrameworkRestrictions();
    public DependenciesGroup GetGroup(GroupName groupName);
    public bool HasPackage(GroupName groupName, PackageName name);
    public PackageRequirement GetPackage(GroupName groupName, PackageName name);
    public FSharpOption`1<PackageRequirement> TryGetPackage(GroupName groupName, PackageName name);
    public FSharpMap`2<GroupName, Resolved> Resolve(bool force, FSharpFunc`2<Origin, FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<VersionRestriction, FSharpFunc`2<FSharpOption`1<string>, string>>>>> getSha1, FSharpFunc`2<GetPackageVersionsParameters, FSharpAsync`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getVersionF, FSharpFunc`2<ResolverStrategy, FSharpFunc`2<GetPackageVersionsParameters, FSharpList`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getPreferredVersionF, FSharpFunc`2<GetPackageDetailsParameters, FSharpAsync`1<PackageDetails>> getPackageDetailsF, FSharpFunc`2<FSharpOption`1<PackagesFolderGroupConfig>, FSharpFunc`2<GroupName, FSharpFunc`2<ResolvedPackage, FSharpOption`1<RuntimeGraph>>>> getPackageRuntimeGraph, FSharpMap`2<GroupName, a> groupsToResolve, UpdateMode updateMode);
    internal DependenciesFile AddFrameworkRestriction(GroupName groupName, FrameworkRestriction frameworkRestriction);
    internal DependenciesFile AddResolverStrategyForTransitives(GroupName groupName, FSharpOption`1<ResolverStrategy> strategy);
    internal DependenciesFile AddResolverStrategyForDirectDependencies(GroupName groupName, FSharpOption`1<ResolverStrategy> strategy);
    internal bool InsertGroup(GroupName groupName, List`1<string> list);
    public DependenciesFile AddAdditionalPackage(GroupName groupName, PackageName packageName, VersionRequirement versionRequirement, FSharpOption`1<ResolverStrategy> resolverStrategy, InstallSettings settings, PackageRequirementKind kind, FSharpOption`1<bool> pinDown);
    public DependenciesFile AddAdditionalPackage(GroupName groupName, PackageName packageName, string version, InstallSettings settings, PackageRequirementKind kind);
    public DependenciesFile AddAdditionalPackage(GroupName groupName, PackageName packageName, VersionStrategy vr, InstallSettings settings, PackageRequirementKind kind);
    public DependenciesFile AddFixedPackage(GroupName groupName, PackageName packageName, string version, InstallSettings settings);
    public DependenciesFile AddFixedPackage(GroupName groupName, PackageName packageName, string version);
    public DependenciesFile RemovePackage(GroupName groupName, PackageName packageName);
    public DependenciesFile Add(GroupName groupName, PackageName packageName, VersionRange versionRange, InstallSettings installSettings);
    public DependenciesFile Add(GroupName groupName, PackageName packageName, VersionRange versionRange, InstallSettings installSettings, PackageRequirementKind kind);
    public DependenciesFile Add(GroupName groupName, PackageName packageName, string version);
    public DependenciesFile Add(GroupName groupName, PackageName packageName, string version, InstallSettings installSettings);
    public DependenciesFile Add(GroupName groupName, PackageName packageName, string version, InstallSettings installSettings, PackageRequirementKind kind);
    public DependenciesFile AddGithub(GroupName groupName, string repository);
    public DependenciesFile AddGithub(GroupName groupName, string repository, string file, string version);
    public DependenciesFile AddGit(GroupName groupName, string repository);
    public DependenciesFile AddGit(GroupName groupName, string repository, string version);
    public DependenciesFile Remove(GroupName groupName, PackageName packageName);
    public DependenciesFile UpdatePackageVersion(GroupName groupName, PackageName packageName, string version);
    public DependenciesFile UpdateFilteredPackageVersion(GroupName groupName, PackageFilter packageFilter, string version);
    public virtual string ToString();
    public void Save();
    public static DependenciesFile FromSource(string rootPath, string source);
    public static DependenciesFile FromSource(string source);
    public static DependenciesFile ReadFromFile(string fileName);
    public static FileInfo FindLockfile(string dependenciesFileName);
    public static FileInfo FindLocalfile(string dependenciesFileName);
    public FileInfo FindLockFile();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<string> tryMatchPackageLine(FSharpFunc`2<string, bool> packageNamePredicate, string line);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal bool isPackageLine(string name, string line);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`2<int, int> findGroupBorders(GroupName groupName, List`1<string> textRepresentation);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<int> tryFindPackageLine(GroupName groupName, PackageName packageName);
}
[CompilationMappingAttribute]
public static class Paket.DependenciesFileParser : object {
    [CompilationMappingAttribute]
internal static FSharpList`1<string> operators { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<FSharpList`1<string>> arg@1-4 { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<FSharpList`1<string>> lists@15 { get; }
    internal static FSharpList`1<string> get_operators();
    internal static FSharpList`1<FSharpList`1<string>> get_arg@1-4();
    internal static FSharpList`1<FSharpList`1<string>> get_lists@15();
    public static FSharpChoice`3<Unit, Unit, Unit> |NuGetStrategy|PaketStrategy|NoStrategy|(string text);
    public static FSharpOption`1<ResolverStrategy> parseResolverStrategy(string text);
    public static string twiddle(SemVerInfo minimum);
    [CompilerGeneratedAttribute]
internal static VersionRequirement parseVersionRequirement$cont@80-1(string v2, string v1, FSharpList`1<string> rest, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static VersionRequirement parseVersionRequirement$cont@84-2(string v2, string v1, FSharpList`1<string> rest, Unit unitVar);
    internal static Tuple`2<string, FSharpList`1<string>> splitVersion@96(string text);
    [CompilerGeneratedAttribute]
internal static VersionRequirement parseVersionRequirement$cont@96-3(string text, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static VersionRequirement parseVersionRequirement$cont@62(string text, Unit unitVar);
    public static VersionRequirement parseVersionRequirement(string text);
    internal static FSharpList`1<string> parseDepLine@128(string line, int start, FSharpList`1<string> acc);
    public static String[] parseDependencyLine(string line);
    internal static Tuple`3<string, string, FSharpOption`1<string>> getParts@150(string trimmed, string originTxt, string projectSpec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<a, Tuple`3<string, string, FSharpOption`1<string>>, string, FSharpOption`1<string>> parseGitSource(string trimmed, a origin, string originTxt);
    internal static string removeQueryString@182(string s);
    internal static Tuple`4<Origin, Tuple`3<string, a, FSharpOption`1<string>>, string, b> getParts@167-9(string projectSpec, string fileSpec, a projectName, b authKey);
    internal static Tuple`4<Origin, Tuple`3<string, string, FSharpOption`1<string>>, string, FSharpOption`1<string>> parseHttpSource(string trimmed);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@207-24(ParserOption this, ParserOption obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@207-25(IComparer comp, ParserOption this, ParserOption objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@207-8(IEqualityComparer comp, ParserOption this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@207-11(ParserOption this, ParserOption that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@207-12(ParserOption this, ParserOption obj, Unit unitVar);
    internal static FSharpOption`1<RemoteParserOption> |Remote|_|(string line);
    internal static bool isVersion@245(string text);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`3<string, string, string>> |Package|_|$cont@243(string trimmed, Unit unitVar);
    internal static FSharpOption`1<Tuple`3<string, string, string>> |Package|_|(string line);
    internal static bool isVersion@267-1(string text);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`3<string, string, string>> |CliTool|_|$cont@265(string trimmed, Unit unitVar);
    internal static FSharpOption`1<Tuple`3<string, string, string>> |CliTool|_|(string line);
    internal static FSharpOption`1<string> |ExternalLock|_|(string line);
    internal static FSharpOption`1<string> |Empty|_|(string line);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ParserOption> |ParserOptions|_|$cont@305(string matchValue, Unit unitVar);
    internal static FSharpOption`1<ParserOption> |ParserOptions|_|(string line);
    internal static FSharpOption`1<Tuple`4<Origin, Tuple`3<string, string, FSharpOption`1<string>>, string, FSharpOption`1<string>>> |SourceFile|_|(string line);
    internal static FSharpOption`1<string> |Git|_|(string line);
    internal static FSharpOption`1<string> |Group|_|(string line);
    public static PackageRequirement parsePackage(FSharpList`1<PackageSource> sources, PackageRequirementSource parent, string name, string version, PackageRequirementKind kind, string rest);
    public static PackageRequirement parsePackageLine(FSharpList`1<PackageSource> sources, PackageRequirementSource parent, string line);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InstallOptions parseOptions(DependenciesGroup current, ParserOption options);
    [CompilerGeneratedAttribute]
internal static Tuple`2<int, FSharpList`1<DependenciesGroup>> parseLine$cont@553-2(FSharpList`1<DependenciesGroup> other, DependenciesGroup current, int lineNo, string gitConfig, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<int, FSharpList`1<DependenciesGroup>> parseLine$cont@495-1(string fileName, bool checkDuplicates, string line, FSharpList`1<DependenciesGroup> other, DependenciesGroup current, int lineNo, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<int, FSharpList`1<DependenciesGroup>> parseLine$cont@493(string fileName, bool checkDuplicates, FSharpList`1<DependenciesGroup> state, int lineNo, string line, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, FSharpList`1<DependenciesGroup>> parseLine(string fileName, bool checkDuplicates, int lineNo, FSharpList`1<DependenciesGroup> state, string line);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<string, FSharpMap`2<GroupName, DependenciesGroup>, String[]> parseDependenciesFile(string fileName, bool checkDuplicates, String[] lines);
    public static VersionStrategy parseVersionString(string version);
}
[CompilationMappingAttribute]
public static class Paket.DependenciesFileSerializer : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string formatVersionRange(FSharpOption`1<ResolverStrategy> strategy, VersionRequirement versionRequirement);
    public static string sourceString(string source);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string packageString(PackageRequirementKind kind, a packageName, VersionRequirement versionRequirement, FSharpOption`1<ResolverStrategy> resolverStrategy, InstallSettings settings);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string githubString(string repository, string file, string version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string gitString(string repository, string version);
}
[CompilationMappingAttribute]
public class Paket.DependenciesGroup : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal GroupName Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<PackageSource> Sources@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Cache> Caches@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal InstallOptions Options@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<PackageRequirement> Packages@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> ExternalLocks@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<UnresolvedSource> RemoteFiles@;
    [CompilationMappingAttribute]
public GroupName Name { get; }
    [CompilationMappingAttribute]
public FSharpList`1<PackageSource> Sources { get; }
    [CompilationMappingAttribute]
public FSharpList`1<Cache> Caches { get; }
    [CompilationMappingAttribute]
public InstallOptions Options { get; }
    [CompilationMappingAttribute]
public FSharpList`1<PackageRequirement> Packages { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> ExternalLocks { get; }
    [CompilationMappingAttribute]
public FSharpList`1<UnresolvedSource> RemoteFiles { get; }
    [DynamicDependencyAttribute("1632", "Paket.DependenciesGroup")]
public DependenciesGroup(GroupName name, FSharpList`1<PackageSource> sources, FSharpList`1<Cache> caches, InstallOptions options, FSharpList`1<PackageRequirement> packages, FSharpList`1<string> externalLocks, FSharpList`1<UnresolvedSource> remoteFiles);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public GroupName get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<PackageSource> get_Sources();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Cache> get_Caches();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public InstallOptions get_Options();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<PackageRequirement> get_Packages();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_ExternalLocks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<UnresolvedSource> get_RemoteFiles();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DependenciesGroup obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static DependenciesGroup New(GroupName groupName);
    public DependenciesGroup CombineWith(DependenciesGroup other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DependenciesGroup obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.DependencyCache : object {
    internal LockFile lockFile;
    internal HashSet`1<GroupName> loadedGroups;
    internal ConcurrentDictionary`2<Tuple`2<PackageName, SemVerInfo>, Task`1<Nuspec>> nuspecCache;
    internal ConcurrentDictionary`2<Tuple`2<GroupName, PackageName>, Task`1<InstallModel>> installModelCache;
    internal ConcurrentDictionary`2<GroupName, FSharpList`1<PackageInfo>> orderedGroupCache;
    internal ConcurrentDictionary`2<Tuple`2<GroupName, FrameworkIdentifier>, FSharpList`1<ReferenceType>> orderedGroupReferences;
    internal bool finishedSetup;
    internal FSharpFunc`2<FSharpList`1<PackageInfo>, FSharpList`1<PackageInfo>> getPackageOrderResolvedPackage;
    public LockFile LockFile { get; }
    public DependencyCache(LockFile lockFile);
    public DependencyCache(string dependencyFilePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpList`1<ReferenceType> GetOrderedReferences(GroupName groupName, FrameworkIdentifier framework);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpList`1<FileInfo> GetOrderedPackageReferences(GroupName groupName, PackageName packageName, FrameworkIdentifier framework);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpList`1<string> GetPackageLoadScripts(GroupName groupName, PackageName packageName, a _framework, string scriptTypeExtension);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpList`1<FrameworkReference> GetOrderedFrameworkReferences(GroupName groupName, PackageName packageName, FrameworkIdentifier framework);
    public LockFile get_LockFile();
    public FSharpList`1<InstallModel> InstallModels();
    public FSharpList`1<Task`1<InstallModel>> InstallModelTasks();
    public FSharpList`1<Nuspec> Nuspecs();
    public FSharpList`1<Task`1<Nuspec>> NuspecsTasks();
    public bool StartSetupGroup(GroupName groupName);
    public FSharpAsync`1<Unit> AwaitFinishSetup();
    public bool SetupGroup(GroupName groupName);
    public FSharpMap`2<GroupName, FSharpList`1<PackageInfo>> OrderedGroups();
    public FSharpList`1<PackageInfo> OrderedGroups(GroupName groupName);
    public void ClearLoaded();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpOption`1<InstallModel> InstallModel(GroupName groupName, PackageName packageName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpOption`1<Task`1<InstallModel>> InstallModelTask(GroupName groupName, PackageName packageName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<a>, FSharpSet`1<b>, FSharpList`1<a>> getLeafPackagesGeneric(FSharpFunc`2<a, b> getPackageName, FSharpFunc`2<a, c> getDependencies, FSharpSet`1<b> knownPackages, FSharpList`1<a> openList);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<b> getPackageOrderGeneric(FSharpFunc`2<b, c> getPackageName, FSharpFunc`2<b, d> getDependencies, FSharpList`1<b> packages);
    [CompilerGeneratedAttribute]
internal void loadPackages();
    [CompilerGeneratedAttribute]
internal FSharpList`1<AssemblyDefinition> getDllOrder(FSharpList`1<AssemblyDefinition> dllFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<string> getPackageLoadScriptsWithinPackage(string scriptTypeExtension, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<FileInfo> getDllsWithinPackage(FrameworkIdentifier framework, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<ReferenceType> referencesForGroup(GroupName group, FrameworkIdentifier framework);
}
[CompilationMappingAttribute]
public static class Paket.DependencyChangeDetection : object {
    internal static FSharpList`1<DependencyChangeType> settingsChanged@23(IEnumerable`1<PackageName> transitives, PackageRequirement newRequirement, PackageInfo originalPackage, Unit unitVar0);
    internal static FSharpList`1<DependencyChangeType> getChanges@22(bool strict, a groupName, IEnumerable`1<PackageName> transitives, PackageRequirement newRequirement, PackageInfo originalPackage);
    internal static FSharpFunc`2<IEnumerable`1<PackageName>, FSharpSet`1<Tuple`3<GroupName, PackageName, FSharpList`1<DependencyChangeType>>>> added@51(bool strict, LockFile lockFile, DependenciesFile dependenciesFile, GroupName groupName);
    internal static FSharpFunc`2<IEnumerable`1<PackageName>, FSharpSet`1<Tuple`3<GroupName, PackageName, FSharpList`1<DependencyChangeType>>>> modified@74(bool strict, LockFile lockFile, DependenciesFile dependenciesFile, GroupName groupName);
    public static FSharpSet`1<Tuple`3<GroupName, PackageName, FSharpList`1<DependencyChangeType>>> findNuGetChangesInDependenciesFile(DependenciesFile dependenciesFile, LockFile lockFile, bool strict);
    internal static FSharpSet`1<RemoteFileChange> computeDifference@171(LockFileGroup lockFileGroup, DependenciesGroup dependenciesFileGroup);
    public static FSharpSet`1<Tuple`2<GroupName, RemoteFileChange>> findRemoteFileChangesInDependenciesFile(DependenciesFile dependenciesFile, LockFile lockFile);
    public static FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<SemVerInfo, PackageSource>> GetPreferredNuGetVersions(DependenciesFile dependenciesFile, LockFile lockFile);
    internal static bool hasNuGetChanges@233(FSharpMap`2<GroupName, IEnumerable`1<Tuple`3<GroupName, PackageName, FSharpList`1<DependencyChangeType>>>> nuGetChangesPerGroup, GroupName groupName);
    internal static bool hasRemoteFileChanges@238(FSharpMap`2<GroupName, IEnumerable`1<Tuple`2<GroupName, RemoteFileChange>>> remoteFileChangesPerGroup, GroupName groupName);
    [CompilerGeneratedAttribute]
internal static bool hasChangedSettings$cont@247(LockFile lockFile, GroupName groupName, FSharpOption`1<DependenciesGroup> matchValue, Unit unitVar);
    internal static bool hasChangedSettings@243(LockFile lockFile, DependenciesFile dependenciesFile, GroupName groupName);
    internal static FSharpFunc`2<GroupName, FSharpFunc`2<b, bool>> hasChanges@257(LockFile lockFile, DependenciesFile dependenciesFile, FSharpMap`2<GroupName, IEnumerable`1<Tuple`3<GroupName, PackageName, FSharpList`1<DependencyChangeType>>>> nuGetChangesPerGroup, FSharpMap`2<GroupName, IEnumerable`1<Tuple`2<GroupName, RemoteFileChange>>> remoteFileChangesPerGroup);
    public static Tuple`4<bool, FSharpSet`1<Tuple`3<GroupName, PackageName, FSharpList`1<DependencyChangeType>>>, FSharpSet`1<Tuple`2<GroupName, RemoteFileChange>>, FSharpFunc`2<GroupName, FSharpFunc`2<a, bool>>> GetChanges(DependenciesFile dependenciesFile, LockFile lockFile, bool strict);
}
[CompilationMappingAttribute]
public static class Paket.DependencyModel : object {
    public static FSharpMap`2<PackageName, VersionRequirement> CalcDependenciesForDirectPackages(DependenciesFile dependenciesFile, GroupName groupName, FSharpList`1<PackageName> references);
    public static FSharpMap`2<PackageName, VersionRequirement> CalcDependenciesForReferencesFile(DependenciesFile dependenciesFile, GroupName groupName, string referencesFile);
    public static FSharpMap`2<PackageName, VersionRequirement> CalcDependencies(DependenciesFile dependenciesFile, GroupName groupName, string projectFileName);
}
[CompilationMappingAttribute]
public static class Paket.Domain : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string MainGroup;
    public static PackageName PackageName(string name);
    public static GroupName GroupName(string name);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@121-2(IEqualityComparer comp, DomainMessage this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@121-3(DomainMessage this, DomainMessage that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@121-4(DomainMessage this, DomainMessage obj, Unit unitVar);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.DotNetCoreAppVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoreAppVersion _unique_V1_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoreAppVersion _unique_V1_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoreAppVersion _unique_V2_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoreAppVersion _unique_V2_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoreAppVersion _unique_V2_2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoreAppVersion _unique_V3_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetCoreAppVersion _unique_V3_1;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoreAppVersion V1_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoreAppVersion V1_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoreAppVersion V2_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV2_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoreAppVersion V2_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV2_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoreAppVersion V2_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV2_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoreAppVersion V3_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetCoreAppVersion V3_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3_1 { get; }
    internal int NumKey { get; }
    private static DotNetCoreAppVersion();
    [DynamicDependencyAttribute("2016", "Paket.DotNetCoreAppVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DotNetCoreAppVersion(int _tag);
    [CompilationMappingAttribute]
public static DotNetCoreAppVersion get_V1_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_0();
    [CompilationMappingAttribute]
public static DotNetCoreAppVersion get_V1_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_1();
    [CompilationMappingAttribute]
public static DotNetCoreAppVersion get_V2_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV2_0();
    [CompilationMappingAttribute]
public static DotNetCoreAppVersion get_V2_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV2_1();
    [CompilationMappingAttribute]
public static DotNetCoreAppVersion get_V2_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV2_2();
    [CompilationMappingAttribute]
public static DotNetCoreAppVersion get_V3_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3_0();
    [CompilationMappingAttribute]
public static DotNetCoreAppVersion get_V3_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DotNetCoreAppVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal int get_NumKey();
    internal static DotNetCoreAppVersion FromNum(int num);
    public static FSharpList`1<DotNetCoreAppVersion> op_LessMinusGreater(DotNetCoreAppVersion lower, DotNetCoreAppVersion upper);
    public virtual string ToString();
    public string ShortString();
    public static FSharpOption`1<DotNetCoreAppVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DotNetCoreAppVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.DotNetStandardVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V1_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V1_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V1_2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V1_3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V1_4;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V1_5;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V1_6;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V2_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetStandardVersion _unique_V2_1;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V1_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V1_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V1_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V1_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V1_4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V1_5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V1_6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V2_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV2_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetStandardVersion V2_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV2_1 { get; }
    private static DotNetStandardVersion();
    [DynamicDependencyAttribute("2016", "Paket.DotNetStandardVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DotNetStandardVersion(int _tag);
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V1_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_0();
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V1_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_1();
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V1_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_2();
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V1_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_3();
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V1_4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_4();
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V1_5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_5();
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V1_6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_6();
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V2_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV2_0();
    [CompilationMappingAttribute]
public static DotNetStandardVersion get_V2_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV2_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DotNetStandardVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public string ShortString();
    public static FSharpOption`1<DotNetStandardVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DotNetStandardVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.DotNetUnityVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetUnityVersion _unique_V3_5_Web;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetUnityVersion _unique_V3_5_Micro;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetUnityVersion _unique_V3_5_Subset;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DotNetUnityVersion _unique_V3_5_Full;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetUnityVersion V3_5_Web { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3_5_Web { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetUnityVersion V3_5_Micro { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3_5_Micro { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetUnityVersion V3_5_Subset { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3_5_Subset { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DotNetUnityVersion V3_5_Full { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3_5_Full { get; }
    private static DotNetUnityVersion();
    [DynamicDependencyAttribute("2016", "Paket.DotNetUnityVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DotNetUnityVersion(int _tag);
    [CompilationMappingAttribute]
public static DotNetUnityVersion get_V3_5_Web();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3_5_Web();
    [CompilationMappingAttribute]
public static DotNetUnityVersion get_V3_5_Micro();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3_5_Micro();
    [CompilationMappingAttribute]
public static DotNetUnityVersion get_V3_5_Subset();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3_5_Subset();
    [CompilationMappingAttribute]
public static DotNetUnityVersion get_V3_5_Full();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3_5_Full();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DotNetUnityVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public string ShortString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DotNetUnityVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.FileItem : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal BuildAction BuildAction@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Include@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool WithPaketSubNode@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<CopyToOutputDirectorySettings> CopyToOutputDirectory@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Link@;
    [CompilationMappingAttribute]
public BuildAction BuildAction { get; }
    [CompilationMappingAttribute]
public string Include { get; }
    [CompilationMappingAttribute]
public bool WithPaketSubNode { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<CopyToOutputDirectorySettings> CopyToOutputDirectory { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> Link { get; }
    [DynamicDependencyAttribute("1632", "Paket.FileItem")]
public FileItem(BuildAction buildAction, string include, bool withPaketSubNode, FSharpOption`1<CopyToOutputDirectorySettings> copyToOutputDirectory, FSharpOption`1<string> link);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public BuildAction get_BuildAction();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_WithPaketSubNode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<CopyToOutputDirectorySettings> get_CopyToOutputDirectory();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Link();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FileItem obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FileItem obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.FindOutdated : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DependenciesFile adjustVersionRequirements(bool strict, bool includingPrereleases, DependenciesFile dependenciesFile);
    internal static FSharpFunc`2<a, FSharpFunc`2<b, FSharpList`1<c>>> getPreferredVersionsF@42-1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<FSharpList`1<Tuple`4<GroupName, PackageName, SemVerInfo, SemVerInfo>>, DomainMessage> FindOutdated(bool strict, bool force, bool includingPrereleases, FSharpOption`1<string> groupNameFilter, PaketEnv environment);
    internal static void printOutdated(FSharpList`1<Tuple`4<GroupName, PackageName, a, b>> changed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Unit, DomainMessage> ShowOutdated(bool strict, bool force, bool includingPrereleases, FSharpOption`1<string> groupName, PaketEnv environment);
}
[CompilationMappingAttribute]
public static class Paket.FindReferences : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`2<FSharpList`1<ProjectFile>, DomainMessage> findReferencesFor(GroupName groupName, PackageName package, LockFile lockFile, IEnumerable`1<Tuple`2<ProjectFile, ReferencesFile>> projects);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<FSharpList`1<ProjectFile>, DomainMessage> FindReferencesForPackage(GroupName groupName, PackageName package, PaketEnv environment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Unit, DomainMessage> TouchReferencesOfPackages(FSharpList`1<Tuple`2<GroupName, PackageName>> packages, PaketEnv environment);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Unit, DomainMessage> ShowReferencesFor(IEnumerable`1<Tuple`2<GroupName, PackageName>> packages, PaketEnv environment);
}
[CompilationMappingAttribute]
public static class Paket.FolderScanner : object {
    [CompilationMappingAttribute]
public static IDictionary`2<char, FSharpFunc`2<string, ParseResult`1<object>>> parsers { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<bool>> func1@1-3 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, bool>> func1@1-4 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, bool>, ParseResult`1<bool>> func2@1-5 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<int>> func1@1-6 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, int>> func1@1-7 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> func2@1-6 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<int>> func1@1-9 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, int>> func1@1-10 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> func2@1-7 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<int>> func1@1-12 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<UInt32>> func1@1-13 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, UInt32>> func1@1-14 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, UInt32>, ParseResult`1<UInt32>> func2@1-8 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<ParseResult`1<UInt32>, ParseResult`1<int>> func2@1-9 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<int>> func1@1-16 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<string>> func1@1-17 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<string>> func1@1-18 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<string>> func2@1-10 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<int>> func2@1-11 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> func2@1-12 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<int>> func1@1-19 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<string>> func1@1-20 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<string>> func1@1-21 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<string>> func2@1-13 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<int>> func2@1-14 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> func2@1-15 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<int>> func1@1-22 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> func2@1-16 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<double>> func1@1-24 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, double>> func1@1-25 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> func2@1-17 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<double>> func1@1-27 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, double>> func1@1-28 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> func2@1-18 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<double>> func1@1-30 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, double>> func1@1-31 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> func2@1-19 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<double>> func1@1-33 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, double>> func1@1-34 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> func2@1-20 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<double>> func1@1-36 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, double>> func1@1-37 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> func2@1-21 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<double>> func1@1-39 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<bool, double>> func1@1-40 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> func2@1-22 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<decimal>> func1@1-42 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<bool, decimal>, ParseResult`1<decimal>> func2@1-23 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<char>> func1@1-43 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, ParseResult`1<string>> func1@1-44 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<char>> func2@1-24 { get; }
    [CompilationMappingAttribute]
public static String[] separators { get; }
    [CompilationMappingAttribute]
internal static ICollection`1<char> arg@1-5 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Regex> getRegex { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, Regex> cache@54-16 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Regex> getRegexIgnoreCase { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, Regex> cache@54-17 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<string, FSharpList`1<char>>> getRegexString { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, Tuple`2<string, FSharpList`1<char>>> cache@54-18 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<string, FSharpList`1<Tuple`4<string, string, string, int>>>> retrieveReplacedFormatString { get; }
    [CompilationMappingAttribute]
internal static Regex findSpecifiers@324 { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, Tuple`2<string, FSharpList`1<Tuple`4<string, string, string, int>>>> cache@54-19 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ParseResult`1<a> toParseResult(string error, bool wasSuccess, a result);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ParseResult`1<a> check(string errorMsg, FSharpFunc`2<a, bool> f, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ParseResult`1<b> choose(string errorMsg, FSharpFunc`2<a, FSharpOption`1<b>> f, a x);
    public static Tuple`2<bool, decimal> parseDecimal(string x);
    public static IDictionary`2<char, FSharpFunc`2<string, ParseResult`1<object>>> get_parsers();
    internal static FSharpFunc`2<string, ParseResult`1<bool>> get_func1@1-3();
    internal static FSharpFunc`2<string, Tuple`2<bool, bool>> get_func1@1-4();
    [CompilerGeneratedAttribute]
internal static string func1@1-5(string value);
    internal static FSharpFunc`2<Tuple`2<bool, bool>, ParseResult`1<bool>> get_func2@1-5();
    internal static FSharpFunc`2<string, ParseResult`1<int>> get_func1@1-6();
    internal static FSharpFunc`2<string, Tuple`2<bool, int>> get_func1@1-7();
    [CompilerGeneratedAttribute]
internal static string func1@1-8(string value);
    internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> get_func2@1-6();
    internal static FSharpFunc`2<string, ParseResult`1<int>> get_func1@1-9();
    internal static FSharpFunc`2<string, Tuple`2<bool, int>> get_func1@1-10();
    [CompilerGeneratedAttribute]
internal static string func1@1-11(string value);
    internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> get_func2@1-7();
    internal static FSharpFunc`2<string, ParseResult`1<int>> get_func1@1-12();
    internal static FSharpFunc`2<string, ParseResult`1<UInt32>> get_func1@1-13();
    internal static FSharpFunc`2<string, Tuple`2<bool, UInt32>> get_func1@1-14();
    [CompilerGeneratedAttribute]
internal static string func1@1-15(string value);
    internal static FSharpFunc`2<Tuple`2<bool, UInt32>, ParseResult`1<UInt32>> get_func2@1-8();
    internal static FSharpFunc`2<ParseResult`1<UInt32>, ParseResult`1<int>> get_func2@1-9();
    internal static FSharpFunc`2<string, ParseResult`1<int>> get_func1@1-16();
    internal static FSharpFunc`2<string, ParseResult`1<string>> get_func1@1-17();
    internal static FSharpFunc`2<string, ParseResult`1<string>> get_func1@1-18();
    internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<string>> get_func2@1-10();
    internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<int>> get_func2@1-11();
    internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> get_func2@1-12();
    internal static FSharpFunc`2<string, ParseResult`1<int>> get_func1@1-19();
    internal static FSharpFunc`2<string, ParseResult`1<string>> get_func1@1-20();
    internal static FSharpFunc`2<string, ParseResult`1<string>> get_func1@1-21();
    internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<string>> get_func2@1-13();
    internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<int>> get_func2@1-14();
    internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> get_func2@1-15();
    internal static FSharpFunc`2<string, ParseResult`1<int>> get_func1@1-22();
    [CompilerGeneratedAttribute]
internal static Tuple`2<bool, int> func1@1-23(string x);
    internal static FSharpFunc`2<Tuple`2<bool, int>, ParseResult`1<int>> get_func2@1-16();
    internal static FSharpFunc`2<string, ParseResult`1<double>> get_func1@1-24();
    internal static FSharpFunc`2<string, Tuple`2<bool, double>> get_func1@1-25();
    [CompilerGeneratedAttribute]
internal static string func1@1-26(string value);
    internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> get_func2@1-17();
    internal static FSharpFunc`2<string, ParseResult`1<double>> get_func1@1-27();
    internal static FSharpFunc`2<string, Tuple`2<bool, double>> get_func1@1-28();
    [CompilerGeneratedAttribute]
internal static string func1@1-29(string value);
    internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> get_func2@1-18();
    internal static FSharpFunc`2<string, ParseResult`1<double>> get_func1@1-30();
    internal static FSharpFunc`2<string, Tuple`2<bool, double>> get_func1@1-31();
    [CompilerGeneratedAttribute]
internal static string func1@1-32(string value);
    internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> get_func2@1-19();
    internal static FSharpFunc`2<string, ParseResult`1<double>> get_func1@1-33();
    internal static FSharpFunc`2<string, Tuple`2<bool, double>> get_func1@1-34();
    [CompilerGeneratedAttribute]
internal static string func1@1-35(string value);
    internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> get_func2@1-20();
    internal static FSharpFunc`2<string, ParseResult`1<double>> get_func1@1-36();
    internal static FSharpFunc`2<string, Tuple`2<bool, double>> get_func1@1-37();
    [CompilerGeneratedAttribute]
internal static string func1@1-38(string value);
    internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> get_func2@1-21();
    internal static FSharpFunc`2<string, ParseResult`1<double>> get_func1@1-39();
    internal static FSharpFunc`2<string, Tuple`2<bool, double>> get_func1@1-40();
    [CompilerGeneratedAttribute]
internal static string func1@1-41(string value);
    internal static FSharpFunc`2<Tuple`2<bool, double>, ParseResult`1<double>> get_func2@1-22();
    internal static FSharpFunc`2<string, ParseResult`1<decimal>> get_func1@1-42();
    internal static FSharpFunc`2<Tuple`2<bool, decimal>, ParseResult`1<decimal>> get_func2@1-23();
    internal static FSharpFunc`2<string, ParseResult`1<char>> get_func1@1-43();
    internal static FSharpFunc`2<string, ParseResult`1<string>> get_func1@1-44();
    internal static FSharpFunc`2<ParseResult`1<string>, ParseResult`1<char>> get_func2@1-24();
    public static String[] get_separators();
    internal static ICollection`1<char> get_arg@1-5();
    public static FSharpList`1<char> getFormatters(FSharpList`1<char> xs);
    internal static FSharpFunc`2<string, Regex> get_getRegex();
    internal static ConcurrentDictionary`2<string, Regex> get_cache@54-16();
    internal static FSharpFunc`2<string, Regex> get_getRegexIgnoreCase();
    internal static ConcurrentDictionary`2<string, Regex> get_cache@54-17();
    internal static FSharpFunc`2<string, Tuple`2<string, FSharpList`1<char>>> get_getRegexString();
    [CompilerGeneratedAttribute]
internal static Tuple`2<string, FSharpList`1<char>> f@63-19(string formatString);
    internal static ConcurrentDictionary`2<string, Tuple`2<string, FSharpList`1<char>>> get_cache@54-18();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ScanResult sscanfHelper(ScanOptions opts, PrintfFormat`5<a, b, c, d, t> pf, string s);
    public static t toGenericTuple(Object[] matches);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<t> trySscanf(ScanOptions opts, PrintfFormat`5<a, b, c, d, t> pf, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a handleErrors(string s, ScanResult r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static t sscanf(ScanOptions opts, PrintfFormat`5<a, b, c, d, t> pf, string s);
    internal static FSharpFunc`2<string, Tuple`2<string, FSharpList`1<Tuple`4<string, string, string, int>>>> get_retrieveReplacedFormatString();
    internal static Regex get_findSpecifiers@324();
    [CompilerGeneratedAttribute]
internal static Tuple`2<string, FSharpList`1<Tuple`4<string, string, string, int>>> f@63-20(string formatString);
    internal static ConcurrentDictionary`2<string, Tuple`2<string, FSharpList`1<Tuple`4<string, string, string, int>>>> get_cache@54-19();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ScanResult sscanfExtHelper(Context context, IDictionary`2<string, AdvancedScanner`1<Context>> scannerMap, ScanOptions opts, PrintfFormat`5<a, b, c, d, t> pf, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<t> trySscanfExt(a context, IDictionary`2<string, AdvancedScanner`1<a>> advancedScanners, ScanOptions opts, PrintfFormat`5<b, c, d, e, t> pf, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static t sscanfExt(a context, IDictionary`2<string, AdvancedScanner`1<a>> advancedScanners, ScanOptions opts, PrintfFormat`5<b, c, d, e, t> pf, string s);
}
[CompilationMappingAttribute]
public class Paket.FrameworkAssemblyReference : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string AssemblyName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FrameworkRestrictions FrameworkRestrictions@;
    [CompilationMappingAttribute]
public string AssemblyName { get; }
    [CompilationMappingAttribute]
public FrameworkRestrictions FrameworkRestrictions { get; }
    [DynamicDependencyAttribute("1632", "Paket.FrameworkAssemblyReference")]
public FrameworkAssemblyReference(string assemblyName, FrameworkRestrictions frameworkRestrictions);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FrameworkRestrictions get_FrameworkRestrictions();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FrameworkAssemblyReference obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FrameworkAssemblyReference obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.FrameworkDependentFile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ParsedPlatformPath Path@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UnparsedPackageFile File@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Rid> Runtime@;
    [CompilationMappingAttribute]
public ParsedPlatformPath Path { get; }
    [CompilationMappingAttribute]
public UnparsedPackageFile File { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<Rid> Runtime { get; }
    [DynamicDependencyAttribute("1632", "Paket.FrameworkDependentFile")]
public FrameworkDependentFile(ParsedPlatformPath path, UnparsedPackageFile file, FSharpOption`1<Rid> runtime);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ParsedPlatformPath get_Path();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public UnparsedPackageFile get_File();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Rid> get_Runtime();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FrameworkDependentFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FrameworkDependentFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.FrameworkDetection : object {
    [CompilationMappingAttribute]
public static Lazy`1<FrameworkIdentifier> resolveEnvironmentFramework { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, FSharpOption`1<FrameworkIdentifier>> internalExtract { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, FSharpOption`1<FrameworkIdentifier>> cache@54-3 { get; }
    public static Lazy`1<FrameworkIdentifier> get_resolveEnvironmentFramework();
    internal static FSharpFunc`2<string, FSharpOption`1<FrameworkIdentifier>> get_internalExtract();
    internal static string removeTrailingZeros@1055(string s);
    internal static string simplify@1065(string s);
    internal static FSharpOption`1<string> tryNormalizeVersion@1058(string s);
    internal static FSharpFunc`2<string, FSharpOption`1<a>> |MatchTfm|_|@1088(string tfmStart, FSharpFunc`2<string, FSharpOption`1<a>> tryParseVersion);
    internal static FSharpFunc`2<string, FSharpOption`1<a>> |MatchNetXDashOs|_|@1095(int dotnetVersionX, FSharpFunc`2<string, FSharpOption`1<a>> tryParseSecondPart);
    internal static FSharpFunc`2<string, FSharpOption`1<a>> |MatchNetXDashWindows|_|@1109(int dotnetVersionX, FSharpFunc`2<string, FSharpOption`1<a>> tryParseVersion);
    internal static FSharpFunc`2<FSharpFunc`2<string, FSharpFunc`2<string, FSharpOption`1<a>>>, FSharpFunc`2<string, FSharpOption`1<a>>> |MatchTfms|_|@1124(IEnumerable`1<string> tfmStarts);
    internal static FSharpFunc`2<string, FSharpOption`1<a>> |ModifyMatchTfm|_|@1130(FSharpFunc`2<string, string> f, string tfmStart, FSharpFunc`2<string, FSharpOption`1<a>> tryParseVersion);
    internal static FSharpFunc`2<b, a> Bind@1134(a f);
    internal static FSharpFunc`2<a, FSharpOption`1<Unit>> allowVersions@1152(IEnumerable`1<a> l);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FrameworkIdentifier> f@63-2(string path);
    internal static ConcurrentDictionary`2<string, FSharpOption`1<FrameworkIdentifier>> get_cache@54-3();
    [ObsoleteAttribute("Use PlatformMatching.extractPlatforms instead")]
public static FSharpOption`1<FrameworkIdentifier> Extract(string path);
    public static FSharpOption`1<FrameworkIdentifier> DetectFromPath(string path);
}
[CompilationMappingAttribute]
public static class Paket.FrameworkFolder : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FrameworkFolder`1<b> map(FSharpFunc`2<a, b> f, FrameworkFolder`1<a> l);
}
[CompilationMappingAttribute]
public class Paket.FrameworkFolder`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ParsedPlatformPath Path@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<TargetProfile> Targets@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal T FolderContents@;
    [CompilationMappingAttribute]
public ParsedPlatformPath Path { get; }
    [CompilationMappingAttribute]
public FSharpSet`1<TargetProfile> Targets { get; }
    [CompilationMappingAttribute]
public T FolderContents { get; }
    [DynamicDependencyAttribute("1632", "Paket.FrameworkFolder`1")]
public FrameworkFolder`1(ParsedPlatformPath path, FSharpSet`1<TargetProfile> targets, T folderContents);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ParsedPlatformPath get_Path();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<TargetProfile> get_Targets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T get_FolderContents();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FrameworkFolder`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public IEnumerable`1<FrameworkIdentifier> GetSinglePlatforms();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FrameworkFolder`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.FrameworkIdentifier : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkIdentifier _unique_MonoTouch;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkIdentifier _unique_MonoMac;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkIdentifier _unique_XamarinTV;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkIdentifier _unique_XamarinWatch;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkIdentifier _unique_XamariniOS;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkIdentifier _unique_XamarinMac;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNetFramework { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet5WithOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet5Windows { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet6WithOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet6Windows { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet7WithOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet7Windows { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet8WithOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet8Windows { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet9WithOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNet9Windows { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUAP { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNetStandard { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNetCoreApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNetUnity { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMonoAndroid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkIdentifier MonoTouch { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMonoTouch { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkIdentifier MonoMac { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMonoMac { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNative { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkIdentifier XamarinTV { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXamarinTV { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkIdentifier XamarinWatch { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXamarinWatch { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkIdentifier XamariniOS { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXamariniOS { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkIdentifier XamarinMac { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXamarinMac { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWindows { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWindowsPhone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWindowsPhoneApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSilverlight { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTizen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsXCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnsupported { get; }
    internal FSharpList`1<FrameworkIdentifier> RawSupportedPlatformsTransitive { get; }
    internal FSharpList`1<FrameworkIdentifier> RawSupportedPlatforms { get; }
    private static FrameworkIdentifier();
    [DynamicDependencyAttribute("2016", "Paket.FrameworkIdentifier")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FrameworkIdentifier(int _tag);
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNetFramework(FrameworkVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNetFramework();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet5WithOs(Net5Os item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet5WithOs();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet5Windows(Net5WindowsVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet5Windows();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet6WithOs(Net6Os item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet6WithOs();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet6Windows(Net6WindowsVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet6Windows();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet7WithOs(Net7Os item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet7WithOs();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet7Windows(Net7WindowsVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet7Windows();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet8WithOs(Net8Os item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet8WithOs();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet8Windows(Net8WindowsVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet8Windows();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet9WithOs(Net8Os item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet9WithOs();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNet9Windows(Net8WindowsVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNet9Windows();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewUAP(UAPVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUAP();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNetStandard(DotNetStandardVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNetStandard();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNetCoreApp(DotNetCoreAppVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNetCoreApp();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewDotNetUnity(DotNetUnityVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNetUnity();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewMonoAndroid(MonoAndroidVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMonoAndroid();
    [CompilationMappingAttribute]
public static FrameworkIdentifier get_MonoTouch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMonoTouch();
    [CompilationMappingAttribute]
public static FrameworkIdentifier get_MonoMac();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMonoMac();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewNative(BuildMode item1, Platform item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNative();
    [CompilationMappingAttribute]
public static FrameworkIdentifier get_XamarinTV();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXamarinTV();
    [CompilationMappingAttribute]
public static FrameworkIdentifier get_XamarinWatch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXamarinWatch();
    [CompilationMappingAttribute]
public static FrameworkIdentifier get_XamariniOS();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXamariniOS();
    [CompilationMappingAttribute]
public static FrameworkIdentifier get_XamarinMac();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXamarinMac();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewWindows(WindowsVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWindows();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewWindowsPhone(WindowsPhoneVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWindowsPhone();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewWindowsPhoneApp(WindowsPhoneAppVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWindowsPhoneApp();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewSilverlight(SilverlightVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSilverlight();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewTizen(TizenVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTizen();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewXCode(XCodeVersion item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsXCode();
    [CompilationMappingAttribute]
public static FrameworkIdentifier NewUnsupported(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnsupported();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FrameworkIdentifier obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    internal FSharpList`1<FrameworkIdentifier> get_RawSupportedPlatformsTransitive();
    internal FSharpList`1<FrameworkIdentifier> get_RawSupportedPlatforms();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FrameworkIdentifier obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.FrameworkReference : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Name@;
    [CompilationMappingAttribute]
public string Name { get; }
    [DynamicDependencyAttribute("1632", "Paket.FrameworkReference")]
public FrameworkReference(string name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FrameworkReference obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FrameworkReference obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.FrameworkReferenceModule : object {
    public static FrameworkReference ofName(string n);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.FrameworkVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V1_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V3_5;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_0_3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_5;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_5_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_5_2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_5_3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_6;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_6_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_6_2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_6_3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_7;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_7_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_7_2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_8;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V4_8_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V5;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V6;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V7;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V8;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FrameworkVersion _unique_V9;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V1_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V3_5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3_5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_0_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_0_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_5_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_5_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_5_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_5_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_5_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_5_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_6_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_6_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_6_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_6_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_6_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_6_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_7_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_7_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_7_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_7_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V4_8_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_8_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FrameworkVersion V9 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV9 { get; }
    private static FrameworkVersion();
    [DynamicDependencyAttribute("2016", "Paket.FrameworkVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FrameworkVersion(int _tag);
    [CompilationMappingAttribute]
public static FrameworkVersion get_V1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V1_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1_1();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV2();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V3_5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3_5();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_0_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_0_3();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_5();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_5_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_5_1();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_5_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_5_2();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_5_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_5_3();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_6();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_6_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_6_1();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_6_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_6_2();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_6_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_6_3();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_7();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_7();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_7_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_7_1();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_7_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_7_2();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_8();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V4_8_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_8_1();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV5();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV6();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V7();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8();
    [CompilationMappingAttribute]
public static FrameworkVersion get_V9();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV9();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FrameworkVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public string ShortString();
    public static FSharpOption`1<FrameworkVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FrameworkVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.GarbageCollection : object {
    internal static FSharpFunc`2<DirectoryInfo, FSharpOption`1<ExtractedPackage>> packageInDir@17(GroupName groupName);
    internal static ExtractedPackage[] findGroupPackages@27(GroupName groupName, DirectoryInfo groupDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<ExtractedPackage> discoverDirectExtractedPackages(GroupName groupName, DirectoryInfo groupPackagesDirectory);
    public static void deleteUnusedPackages(LockFile lockFile);
    [CompilerGeneratedAttribute]
internal static void removeOlderVersionsFromCache$cont@121(IEnumerable`1<SemVerInfo> versions, PackageName packageName, DirectoryInfo targetFolder, Unit unitVar);
    public static void removeOlderVersionsFromCache(Cache cache, PackageName packageName, IEnumerable`1<SemVerInfo> versions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void cleanupCaches(DependenciesFile dependenciesFile, LockFile lockFile);
    public static void CleanUp(DependenciesFile dependenciesFile, LockFile lockFile);
}
[CompilationMappingAttribute]
public static class Paket.Git.CommandHelper : object {
    [CompilationMappingAttribute]
public static TimeSpan gitTimeOut { get; public set; }
    internal static string GitPath { get; }
    [CompilationMappingAttribute]
public static string gitPath { get; }
    public static TimeSpan get_gitTimeOut();
    public static void set_gitTimeOut(TimeSpan value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_GitPath();
    public static string get_gitPath();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`3<bool, List`1<string>, string> runGitCommand(string repositoryDir, string command);
    public static a runGitCommandf(PrintfFormat`4<a, Unit, string, FSharpFunc`2<string, Tuple`3<bool, List`1<string>, string>>> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static List`1<string> getGitResult(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void fireAndForgetGitCommand(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool directRunGitCommand(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void gitCommand(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a gitCommandf(string repositoryDir, PrintfFormat`4<a, Unit, string, Unit> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] runFullGitCommand(string repositoryDir, string command);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string runSimpleGitCommand(string repositoryDir, string command);
}
[CompilationMappingAttribute]
public static class Paket.Git.Handling : object {
    public static string paketCheckoutTag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_paketCheckoutTag();
    internal static bool isOperator@15(string operator);
    public static Tuple`7<string, FSharpOption`1<string>, string, GitLinkOrigin, FSharpOption`1<string>, FSharpOption`1<string>, FSharpOption`1<string>> extractUrlParts(string gitConfig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> getHash(string repoFolder, string commitish);
    public static FSharpOption`1<string> getCurrentHash(string repoFolder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getHashFromRemote(string url, string branch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void fetchCache(string repoCacheFolder, string cloneUrl);
    public static void checkForUncommittedChanges(string repoFolder);
    public static void checkForCommitsMadeInDetachedHeadState(string repoFolder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void tagCommitForCheckout(string repoFolder, string commit);
    public static void checkoutTaggedCommit(string repoFolder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void checkoutToPaketFolder(string repoFolder, string cloneUrl, string cacheCloneUrl, string commit);
}
[CompilationMappingAttribute]
public class Paket.InstallerOptions : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool Force@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SemVerUpdateMode SemVerUpdateMode@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal BindingRedirectsSettings Redirects@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> AlternativeProjectRoot@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool CleanBindingRedirects@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool CreateNewBindingFiles@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool OnlyReferenced@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool GenerateLoadScripts@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> ProvidedScriptTypes@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> ProvidedFrameworks@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool TouchAffectedRefs@;
    [CompilationMappingAttribute]
public bool Force { get; }
    [CompilationMappingAttribute]
public SemVerUpdateMode SemVerUpdateMode { get; }
    [CompilationMappingAttribute]
public BindingRedirectsSettings Redirects { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> AlternativeProjectRoot { get; }
    [CompilationMappingAttribute]
public bool CleanBindingRedirects { get; }
    [CompilationMappingAttribute]
public bool CreateNewBindingFiles { get; }
    [CompilationMappingAttribute]
public bool OnlyReferenced { get; }
    [CompilationMappingAttribute]
public bool GenerateLoadScripts { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> ProvidedScriptTypes { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> ProvidedFrameworks { get; }
    [CompilationMappingAttribute]
public bool TouchAffectedRefs { get; }
    public static InstallerOptions Default { get; }
    [DynamicDependencyAttribute("1632", "Paket.InstallerOptions")]
public InstallerOptions(bool force, SemVerUpdateMode semVerUpdateMode, BindingRedirectsSettings redirects, FSharpOption`1<string> alternativeProjectRoot, bool cleanBindingRedirects, bool createNewBindingFiles, bool onlyReferenced, bool generateLoadScripts, FSharpList`1<string> providedScriptTypes, FSharpList`1<string> providedFrameworks, bool touchAffectedRefs);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_Force();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SemVerUpdateMode get_SemVerUpdateMode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public BindingRedirectsSettings get_Redirects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_AlternativeProjectRoot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_CleanBindingRedirects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_CreateNewBindingFiles();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_OnlyReferenced();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_GenerateLoadScripts();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_ProvidedScriptTypes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_ProvidedFrameworks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_TouchAffectedRefs();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InstallerOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static InstallerOptions get_Default();
    public static InstallerOptions CreateLegacyOptions(bool force, BindingRedirectsSettings redirects, bool cleanBindingRedirects, bool createNewBindingFiles, SemVerUpdateMode semVerUpdateMode, bool touchAffectedRefs, bool generateLoadScripts, FSharpList`1<string> providedFrameworks, FSharpList`1<string> providedScriptTypes, FSharpOption`1<string> alternativeProjectRoot);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallerOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.InstallGroup : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal GroupName Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<PackageInstallSettings> NugetPackages@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<RemoteFileReference> RemoteFiles@;
    [CompilationMappingAttribute]
public GroupName Name { get; }
    [CompilationMappingAttribute]
public FSharpList`1<PackageInstallSettings> NugetPackages { get; }
    [CompilationMappingAttribute]
public FSharpList`1<RemoteFileReference> RemoteFiles { get; }
    [DynamicDependencyAttribute("1632", "Paket.InstallGroup")]
public InstallGroup(GroupName name, FSharpList`1<PackageInstallSettings> nugetPackages, FSharpList`1<RemoteFileReference> remoteFiles);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public GroupName get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<PackageInstallSettings> get_NugetPackages();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<RemoteFileReference> get_RemoteFiles();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InstallGroup obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallGroup obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.InstallModel : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal PackageName PackageName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SemVerInfo PackageVersion@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FrameworkFolder`1<ReferenceOrLibraryFolder>> CompileLibFolders@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FrameworkFolder`1<FSharpSet`1<Library>>> CompileRefFolders@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> RuntimeAssemblyFolders@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> RuntimeLibFolders@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<TargetsFolder`1<FSharpSet`1<MsBuildFile>>> TargetsFileFolders@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<AnalyzerLib> Analyzers@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<PackageLoadScript> PackageLoadScripts@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> LicenseUrl@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal InstallModelKind Kind@;
    [CompilationMappingAttribute]
public PackageName PackageName { get; }
    [CompilationMappingAttribute]
public SemVerInfo PackageVersion { get; }
    [CompilationMappingAttribute]
public FSharpList`1<FrameworkFolder`1<ReferenceOrLibraryFolder>> CompileLibFolders { get; }
    [CompilationMappingAttribute]
public FSharpList`1<FrameworkFolder`1<FSharpSet`1<Library>>> CompileRefFolders { get; }
    [CompilationMappingAttribute]
public FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> RuntimeAssemblyFolders { get; }
    [CompilationMappingAttribute]
public FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> RuntimeLibFolders { get; }
    [CompilationMappingAttribute]
public FSharpList`1<TargetsFolder`1<FSharpSet`1<MsBuildFile>>> TargetsFileFolders { get; }
    [CompilationMappingAttribute]
public FSharpList`1<AnalyzerLib> Analyzers { get; }
    [CompilationMappingAttribute]
public FSharpList`1<PackageLoadScript> PackageLoadScripts { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> LicenseUrl { get; }
    [CompilationMappingAttribute]
public InstallModelKind Kind { get; }
    [DynamicDependencyAttribute("1632", "Paket.InstallModel")]
public InstallModel(PackageName packageName, SemVerInfo packageVersion, FSharpList`1<FrameworkFolder`1<ReferenceOrLibraryFolder>> compileLibFolders, FSharpList`1<FrameworkFolder`1<FSharpSet`1<Library>>> compileRefFolders, FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> runtimeAssemblyFolders, FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> runtimeLibFolders, FSharpList`1<TargetsFolder`1<FSharpSet`1<MsBuildFile>>> targetsFileFolders, FSharpList`1<AnalyzerLib> analyzers, FSharpList`1<PackageLoadScript> packageLoadScripts, FSharpOption`1<string> licenseUrl, InstallModelKind kind);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PackageName get_PackageName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SemVerInfo get_PackageVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FrameworkFolder`1<ReferenceOrLibraryFolder>> get_CompileLibFolders();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FrameworkFolder`1<FSharpSet`1<Library>>> get_CompileRefFolders();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> get_RuntimeAssemblyFolders();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> get_RuntimeLibFolders();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<TargetsFolder`1<FSharpSet`1<MsBuildFile>>> get_TargetsFileFolders();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<AnalyzerLib> get_Analyzers();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<PackageLoadScript> get_PackageLoadScripts();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_LicenseUrl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public InstallModelKind get_Kind();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InstallModel obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallModel obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
    public static InstallModel EmptyModel(PackageName packageName, SemVerInfo packageVersion, FSharpOption`1<InstallModelKind> kind);
    [ObsoleteAttribute("usually this should not be used")]
public FSharpList`1<FrameworkFolder`1<ReferenceOrLibraryFolder>> GetReferenceFolders();
    public IEnumerable`1<Library> GetLegacyReferences(TargetProfile target);
    public IEnumerable`1<Library> GetCompileReferences(TargetProfile target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<RuntimeLibrary> GetRuntimeAssemblies(RuntimeGraph graph, Rid rid, TargetProfile target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<RuntimeLibrary> GetRuntimeLibraries(RuntimeGraph graph, Rid rid, TargetProfile target);
    [ObsoleteAttribute("usually this should not be used, use GetLegacyReferences for the full .net and GetCompileReferences for dotnetcore")]
public IEnumerable`1<Library> GetLibReferences(TargetProfile frameworkIdentifier);
    public IEnumerable`1<FileInfo> GetLibReferenceFiles(TargetProfile frameworkIdentifier);
    public IEnumerable`1<Library> GetLegacyAndCompileReferences(TargetProfile target);
    public IEnumerable`1<FileInfo> GetLegacyReferenceFiles(TargetProfile target);
    public IEnumerable`1<FileInfo> GetCompileReferenceFiles(TargetProfile target);
    public IEnumerable`1<FileInfo> GetLegacyAndCompileReferenceFiles(TargetProfile target);
    public IEnumerable`1<MsBuildFile> GetTargetsFiles(TargetProfile target);
    public IEnumerable`1<FrameworkReference> getLegacyFrameworkReferences(TargetProfile target);
    public IEnumerable`1<FrameworkReference> GetAllLegacyFrameworkReferences();
    public IEnumerable`1<Library> GetAllLegacyReferences();
    public FSharpSet`1<string> GetAllLegacyReferenceAndFrameworkReferenceNames();
    public FSharpList`1<FrameworkFolder`1<ReferenceOrLibraryFolder>> CalcLegacyReferencesFolders(FSharpList`1<UnparsedPackageFile> libs);
    public FSharpList`1<FrameworkFolder`1<FSharpSet`1<Library>>> CalcReferencesFolders(FSharpList`1<UnparsedPackageFile> libs);
    public InstallModel AddLibReferences(IEnumerable`1<UnparsedPackageFile> libs, NuspecReferences references);
    public InstallModel AddReferences(IEnumerable`1<UnparsedPackageFile> libs);
    public InstallModel AddAnalyzerFiles(IEnumerable`1<UnparsedPackageFile> analyzerFiles);
    public InstallModel AddPackageLoadScriptFiles(IEnumerable`1<UnparsedPackageFile> packageLoadScriptFiles);
    public InstallModel AddTargetsFiles(string name, FSharpList`1<UnparsedPackageFile> targetsFiles);
    public InstallModel AddTargetsFiles(FSharpList`1<UnparsedPackageFile> targetsFiles);
    public InstallModel AddFrameworkAssemblyReference(FrameworkAssemblyReference reference);
    public InstallModel AddFrameworkAssemblyReferences(IEnumerable`1<FrameworkAssemblyReference> references);
    public InstallModel FilterIgnoreList();
    public InstallModel FilterExcludes(FSharpList`1<string> excludes);
    public InstallModel FilterReferences(FSharpSet`1<string> references);
    public InstallModel ApplyFrameworkRestrictions(FrameworkRestriction restrictions);
    public InstallModel RemoveIfCompletelyEmpty();
    public static InstallModel CreateFromContent(PackageName packageName, SemVerInfo packageVersion, InstallModelKind kind, FrameworkRestriction frameworkRestriction, NuGetPackageContent content);
    [ObsoleteAttribute("use CreateFromContent instead")]
public static InstallModel CreateFromLibs(PackageName packageName, SemVerInfo packageVersion, InstallModelKind kind, FrameworkRestriction frameworkRestriction, IEnumerable`1<UnparsedPackageFile> libs, FSharpList`1<UnparsedPackageFile> targetsFiles, IEnumerable`1<UnparsedPackageFile> analyzerFiles, Nuspec nuspec);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.InstallModelKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InstallModelKind _unique_Package;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InstallModelKind _unique_DotnetCliTool;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InstallModelKind Package { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPackage { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InstallModelKind DotnetCliTool { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotnetCliTool { get; }
    private static InstallModelKind();
    [DynamicDependencyAttribute("2016", "Paket.InstallModelKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InstallModelKind(int _tag);
    [CompilationMappingAttribute]
public static InstallModelKind get_Package();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPackage();
    [CompilationMappingAttribute]
public static InstallModelKind get_DotnetCliTool();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotnetCliTool();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InstallModelKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallModelKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Paket.InstallModelModule : object {
    [CompilationMappingAttribute]
public static IDictionary`2<string, AdvancedScanner`1<UnparsedPackageFile>> scanners { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<AdvancedScanner`1<UnparsedPackageFile>> arg@1-6 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<FSharpList`1<UnparsedPackageFile>, FSharpList`1<FrameworkFolder`1<ReferenceOrLibraryFolder>>> calcLegacyReferenceLibFolders { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<FSharpList`1<UnparsedPackageFile>, FSharpList`1<FrameworkFolder`1<FSharpSet`1<Library>>>> calcReferenceFolders { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<FSharpList`1<UnparsedPackageFile>, FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>>> calcRuntimeAssemblyFolders { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<InstallModel, InstallModel> filterIgnoreList { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel emptyModel(PackageName packageName, SemVerInfo packageVersion, InstallModelKind kind);
    public static IDictionary`2<string, AdvancedScanner`1<UnparsedPackageFile>> get_scanners();
    internal static FSharpList`1<AdvancedScanner`1<UnparsedPackageFile>> get_arg@1-6();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<e> trySscanf(PrintfFormat`5<a, b, c, d, e> pf, UnparsedPackageFile ctx);
    public static FSharpOption`1<FrameworkDependentFile> getCompileRefAssembly(UnparsedPackageFile p);
    public static FSharpOption`1<FrameworkDependentFile> getRuntimeAssembly(UnparsedPackageFile p);
    public static FSharpOption`1<FrameworkDependentFile> getCompileLibAssembly(UnparsedPackageFile p);
    public static FSharpOption`1<FrameworkDependentFile> getRuntimeLibrary(UnparsedPackageFile p);
    public static FSharpOption`1<FrameworkDependentFile> getFrameworkDependentMsbuildFile(UnparsedPackageFile p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<b> getFileFolders(TargetProfile target, IEnumerable`1<FrameworkFolder`1<a>> folderType, FSharpFunc`2<a, IEnumerable`1<b>> choosefn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<b> getFileFoldersByPath(ParsedPlatformPath path, IEnumerable`1<FrameworkFolder`1<a>> folderType, FSharpFunc`2<a, IEnumerable`1<b>> choosefn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<c> getAllFiles(IEnumerable`1<FrameworkFolder`1<a>> folderType, FSharpFunc`2<a, b> choosefn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Library> getLegacyReferences(TargetProfile target, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<FrameworkReference> getLegacyFrameworkReferences(TargetProfile target, InstallModel installModel);
    public static IEnumerable`1<FrameworkReference> getAllLegacyFrameworkReferences(InstallModel installModel);
    public static IEnumerable`1<Library> getAllLegacyReferences(InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Library> getCompileReferences(TargetProfile target, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<MsBuildFile> getTargetsFiles(TargetProfile target, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Library> getLegacyPlatformReferences(TargetProfile frameworkIdentifier, InstallModel installModel);
    public static bool isEmpty(FSharpList`1<FrameworkFolder`1<FSharpSet`1<T>>> lib);
    public static bool isEmpty'(FSharpList`1<TargetsFolder`1<FSharpSet`1<T>>> folders);
    public static InstallModel removeIfCompletelyEmpty(InstallModel this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<FrameworkFolder`1<a>> calcLibFoldersG(a empty, FSharpFunc`2<UnparsedPackageFile, FSharpOption`1<FrameworkDependentFile>> parsePackage, FSharpList`1<UnparsedPackageFile> libs);
    public static FSharpFunc`2<FSharpList`1<UnparsedPackageFile>, FSharpList`1<FrameworkFolder`1<ReferenceOrLibraryFolder>>> get_calcLegacyReferenceLibFolders();
    public static FSharpFunc`2<FSharpList`1<UnparsedPackageFile>, FSharpList`1<FrameworkFolder`1<FSharpSet`1<Library>>>> get_calcReferenceFolders();
    public static FSharpFunc`2<FSharpList`1<UnparsedPackageFile>, FSharpList`1<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>>> get_calcRuntimeAssemblyFolders();
    public static FSharpList`1<FrameworkFolder`1<FSharpSet`1<a>>> calcRuntimeLibraryFolders(FSharpList`1<UnparsedPackageFile> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<FrameworkFolder`1<T>> addFileToFolder(FrameworkFolder`1<T> path, Item file, FSharpList`1<FrameworkFolder`1<T>> folders, FSharpFunc`2<Item, FSharpFunc`2<T, T>> addfn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool fileEndsWith(FrameworkDependentFile f, string endsWith);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InstallModel addPackageLegacyLibFile(NuspecReferences references, FrameworkFolder`1<ReferenceOrLibraryFolder> path, FrameworkDependentFile file, InstallModel this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InstallModel addPackageRefFile(NuspecReferences references, FrameworkFolder`1<FSharpSet`1<Library>> path, FrameworkDependentFile file, InstallModel this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InstallModel addPackageRuntimeAssemblyFile(NuspecReferences references, FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>> path, FrameworkDependentFile file, InstallModel this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InstallModel addPackageRuntimeLibraryFile(NuspecReferences references, FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>> path, FrameworkDependentFile file, InstallModel this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InstallModel addItem(FSharpList`1<a> libs, FSharpFunc`2<a, FSharpOption`1<FrameworkDependentFile>> extract, FSharpFunc`2<FrameworkFolder`1<b>, FSharpFunc`2<FrameworkDependentFile, FSharpFunc`2<InstallModel, InstallModel>>> addFunc, FSharpFunc`2<InstallModel, FSharpList`1<FrameworkFolder`1<b>>> getFolder, InstallModel initialState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel addAnalyzerFiles(IEnumerable`1<UnparsedPackageFile> analyzerFiles, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel addPackageLoadScriptFiles(IEnumerable`1<UnparsedPackageFile> packageLoadScriptFiles, InstallModel installModel);
    public static IEnumerable`1<RuntimeLibrary> getAllRuntimeAssemblies(InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<RuntimeLibrary> getRuntimeAssemblies(RuntimeGraph graph, Rid rid, TargetProfile target, InstallModel installModel);
    public static IEnumerable`1<RuntimeLibrary> getAllRuntimeLibraries(InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<RuntimeLibrary> getRuntimeLibraries(RuntimeGraph graph, Rid rid, TargetProfile target, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<FrameworkFolder`1<T>> mapFolderContents(FSharpFunc`2<T, T> mapfn, FSharpList`1<FrameworkFolder`1<T>> folders);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapCompileLibFolders(FSharpFunc`2<FrameworkFolder`1<ReferenceOrLibraryFolder>, FrameworkFolder`1<ReferenceOrLibraryFolder>> mapfn, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapCompileRefFolders(FSharpFunc`2<FrameworkFolder`1<FSharpSet`1<Library>>, FrameworkFolder`1<FSharpSet`1<Library>>> mapfn, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapRuntimeAssemblyFolders(FSharpFunc`2<FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>, FrameworkFolder`1<FSharpSet`1<RuntimeLibrary>>> mapfn, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapTargetsFileFolders(FSharpFunc`2<TargetsFolder`1<FSharpSet`1<MsBuildFile>>, TargetsFolder`1<FSharpSet`1<MsBuildFile>>> mapfn, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapCompileLibFrameworkReferences(FSharpFunc`2<FSharpSet`1<FrameworkReference>, FSharpSet`1<FrameworkReference>> mapfn, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapCompileLibReferences(FSharpFunc`2<FSharpSet`1<Library>, FSharpSet`1<Library>> mapfn, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapCompileRefFiles(FSharpFunc`2<FSharpSet`1<Library>, FSharpSet`1<Library>> mapfn, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapRuntimeAssemblyFiles(FSharpFunc`2<FSharpSet`1<RuntimeLibrary>, FSharpSet`1<RuntimeLibrary>> mapfn, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel mapTargetsFiles(FSharpFunc`2<FSharpSet`1<MsBuildFile>, FSharpSet`1<MsBuildFile>> mapfn, InstallModel installModel);
    internal static bool referenceApplies@789(FrameworkAssemblyReference reference, FrameworkFolder`1<a> folder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel addFrameworkAssemblyReference(InstallModel installModel, FrameworkAssemblyReference reference);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel addFrameworkAssemblyReferences(IEnumerable`1<FrameworkAssemblyReference> references, InstallModel installModel);
    internal static FSharpFunc`2<string, bool> excluded@813(string e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel filterExcludes(FSharpList`1<string> excludes, InstallModel installModel);
    internal static bool isAssemblyDll@825(Library l);
    internal static bool isNativeDll@828(Library l);
    public static InstallModel filterUnknownFiles(InstallModel installModel);
    public static FSharpFunc`2<InstallModel, InstallModel> get_filterIgnoreList();
    internal static FSharpFunc`2<FrameworkFolder`1<a>, FrameworkFolder`1<a>> applyRestriction@846(FrameworkRestriction restriction);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel applyFrameworkRestrictions(FrameworkRestriction restriction, InstallModel installModel);
    public static FSharpSet`1<MsBuildFile> getRootFiles(FSharpList`1<UnparsedPackageFile> targetsFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel addTargetsFiles(string name, FSharpList`1<UnparsedPackageFile> targetsFiles, InstallModel this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel filterReferences(FSharpSet`1<string> references, InstallModel this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel addLicense(string url, InstallModel model);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel addLibReferences(IEnumerable`1<UnparsedPackageFile> libs, NuspecReferences references, InstallModel installModel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel addNuGetFiles(NuGetPackageContent content, InstallModel model);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel createFromContent(PackageName packageName, SemVerInfo packageVersion, InstallModelKind kind, FrameworkRestriction frameworkRestrictions, NuGetPackageContent content);
    [ObsoleteAttribute("use createFromContent instead")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel createFromLibs(PackageName packageName, SemVerInfo packageVersion, InstallModelKind kind, FrameworkRestriction frameworkRestrictions, IEnumerable`1<UnparsedPackageFile> libs, FSharpList`1<UnparsedPackageFile> targetsFiles, IEnumerable`1<UnparsedPackageFile> analyzerFiles, IEnumerable`1<UnparsedPackageFile> packageLoadScriptFiles, Nuspec nuspec);
}
[CompilationMappingAttribute]
public class Paket.InstallOptions : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool Strict@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<BindingRedirectsSettings> Redirects@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<ResolverStrategy> ResolverStrategyForDirectDependencies@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<ResolverStrategy> ResolverStrategyForTransitives@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal InstallSettings Settings@;
    [CompilationMappingAttribute]
public bool Strict { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<BindingRedirectsSettings> Redirects { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<ResolverStrategy> ResolverStrategyForDirectDependencies { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<ResolverStrategy> ResolverStrategyForTransitives { get; }
    [CompilationMappingAttribute]
public InstallSettings Settings { get; }
    public static InstallOptions Default { get; }
    [DynamicDependencyAttribute("1632", "Paket.InstallOptions")]
public InstallOptions(bool strict, FSharpOption`1<BindingRedirectsSettings> redirects, FSharpOption`1<ResolverStrategy> resolverStrategyForDirectDependencies, FSharpOption`1<ResolverStrategy> resolverStrategyForTransitives, InstallSettings settings);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_Strict();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<BindingRedirectsSettings> get_Redirects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<ResolverStrategy> get_ResolverStrategyForDirectDependencies();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<ResolverStrategy> get_ResolverStrategyForTransitives();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public InstallSettings get_Settings();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InstallOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static InstallOptions get_Default();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.InstallProcess : object {
    [CompilationMappingAttribute]
public static FSharpList`1<FSharpFunc`2<FileInfo, bool>> contentFileIgnoreList { get; }
    [CompilationMappingAttribute]
public static HashSet`1<Tuple`2<string, string>> brokenDeps { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void updatePackagesConfigFile(FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<SemVerInfo, InstallSettings>> model, string packagesConfigFileName);
    [CompilerGeneratedAttribute]
internal static DirectoryInfo findPackageFolder$cont@46(string root, PackageName packageName, GroupName groupName, SemVerInfo version, bool includeVersionInPath, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectoryInfo findPackageFolder(string root, GroupName groupName, PackageName packageName, SemVerInfo version, InstallSettings settings);
    public static FSharpList`1<FSharpFunc`2<FileInfo, bool>> get_contentFileIgnoreList();
    internal static bool onIgnoreList@115(FileInfo fi);
    internal static FSharpList`1<FileInfo> copyDirContents@117(HashSet`1<string> contentFiles, DirectoryInfo fromDir, ContentCopySettings contentCopySettings, Lazy`1<DirectoryInfo> toDir);
    internal static FSharpList`1<Tuple`3<FileInfo, ContentCopySettings, b>> copyContentFiles@114(HashSet`1<string> contentFiles, ProjectFile project, FSharpList`1<Tuple`3<DirectoryInfo, ContentCopySettings, b>> packagesWithContent);
    internal static void removeEmptyDirHierarchy@150(DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void processContentFiles(string root, ProjectFile project, FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<SemVerInfo, InstallSettings>> usedPackages, FSharpList`1<FileItem> gitRemoteItems, a options);
    public static Tuple`2[] CreateModel(FSharpOption`1<string> alternativeProjectRoot, string root, bool force, DependenciesFile dependenciesFile, LockFile lockFile, FSharpSet`1<Tuple`2<GroupName, PackageName>> packages, FSharpMap`2<GroupName, a> updatedGroups);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static value getOrAdd(key key, FSharpFunc`2<key, value> getValue, Dictionary`2<key, value> d);
    public static HashSet`1<Tuple`2<string, string>> get_brokenDeps();
    internal static FSharpOption`1<ReferencesFile> referenceFile@228-1(ProjectFile projectFile);
    internal static FSharpOption`1<ReferencesFile> referenceFile@227(Dictionary`2<ProjectFile, FSharpOption`1<ReferencesFile>> referenceFiles, ProjectFile projectFile);
    internal static void reportBrokenDep@235(string src, string target);
    internal static FSharpSet`1<Tuple`2<PackageName, TargetProfile>> dependencies@234-9(GroupName groupName, FSharpFunc`2<Tuple`3<GroupName, PackageName, string>, a> findDependencies, Dictionary`2<string, FSharpOption`1<ProjectFile>> projectCache, Dictionary`2<ProjectFile, FSharpSet`1<Tuple`2<PackageName, TargetProfile>>> dependencyGraph, Dictionary`2<ProjectFile, FSharpOption`1<ReferencesFile>> referenceFiles, ProjectFile projectFile);
    internal static FSharpOption`1<BindingRedirectsSettings> redirectsFromReference@265(GroupName groupName, FSharpOption`1<ReferencesFile> referenceFile, PackageName packageName);
    internal static bool referencesDifferentProfiles@308(FSharpList`1<TargetProfile> targetProfiles, IEnumerable`1<Tuple`5<ILAssemblyManifest, FSharpOption`1<string>, FSharpList`1<ILAssemblyRef>, FSharpOption`1<BindingRedirectsSettings>, TargetProfile>> assemblies, string assemblyName, FSharpOption`1<Version> assemblyVersion, TargetProfile profile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void applyBindingRedirects(bool isFirstGroup, bool createNewBindingFiles, bool cleanBindingRedirects, string root, GroupName groupName, FSharpFunc`2<Tuple`3<GroupName, PackageName, string>, a> findDependencies, IEnumerable`1<string> allKnownLibNames, Dictionary`2<string, FSharpOption`1<ProjectFile>> projectCache, IEnumerable`1<Tuple`2<InstallModel, FSharpOption`1<BindingRedirectsSettings>>> extractedPackages);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void installForDotnetSDK(string root, ProjectFile project);
    public static void InstallIntoProjects(InstallerOptions options, bool forceTouch, DependenciesFile dependenciesFile, LockFile lockFile, FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> projectsAndReferences, FSharpMap`2<GroupName, a> updatedGroups, FSharpOption`1<FSharpList`1<Tuple`4<GroupName, PackageName, FSharpOption`1<SemVerInfo>, FSharpOption`1<SemVerInfo>>>> touchedPackages);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> clo0@1-4(IEnumerable`1<DomainMessage> msgs);
    public static void Install(InstallerOptions options, bool forceTouch, DependenciesFile dependenciesFile, LockFile lockFile, FSharpMap`2<GroupName, a> updatedGroups, FSharpOption`1<FSharpList`1<Tuple`4<GroupName, PackageName, FSharpOption`1<SemVerInfo>, FSharpOption`1<SemVerInfo>>>> touchedPackages);
}
[CompilationMappingAttribute]
public static class Paket.InterprojectReferencesConstraint : object {
}
[CompilationMappingAttribute]
public static class Paket.KnownAliases : object {
    [CompilationMappingAttribute]
public static FSharpList`1<Tuple`2<string, string>> Data { get; }
    public static FSharpList`1<Tuple`2<string, string>> get_Data();
    public static string normalizeFramework(string path);
}
[CompilationMappingAttribute]
public static class Paket.KnownTargetProfiles : object {
    [CompilationMappingAttribute]
public static FSharpList`1<FrameworkVersion> DotNetFrameworkVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<FrameworkIdentifier> DotNetFrameworkIdentifiers { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNetFrameworkProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net5Os> DotNet5OperatingSystems { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet5WithOsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net5WindowsVersion> DotNet5WindowsVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet5WindowsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net6Os> DotNet6OperatingSystems { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet6WithOsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net6WindowsVersion> DotNet6WindowsVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet6WindowsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net7Os> DotNet7OperatingSystems { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet7WithOsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net7WindowsVersion> DotNet7WindowsVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet7WindowsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net8Os> DotNet8OperatingSystems { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet8WithOsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net8WindowsVersion> DotNet8WindowsVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet8WindowsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net8Os> DotNet9OperatingSystems { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet9WithOsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<Net8WindowsVersion> DotNet9WindowsVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNet9WindowsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<DotNetStandardVersion> DotNetStandardVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNetStandardProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<DotNetCoreAppVersion> DotNetCoreAppVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<DotNetUnityVersion> DotNetUnityVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNetCoreProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<WindowsVersion> WindowsVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> WindowsProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> DotNetUnityProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<SilverlightVersion> SilverlightVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> SilverlightProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<MonoAndroidVersion> MonoAndroidVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> MonoAndroidProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<UAPVersion> UAPVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> UAPProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<WindowsPhoneVersion> WindowsPhoneVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> WindowsPhoneSilverlightProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<WindowsPhoneAppVersion> WindowsPhoneAppVersions { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> WindowsPhoneAppProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<PortableProfileType> AllPortableProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> AllDotNetProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<TargetProfile> AllDotNetStandardAndCoreProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpList`1<FrameworkIdentifier> AllNativeProfiles { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<TargetProfile> AllProfiles { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<TargetProfile> arg@1-3 { get; }
    public static FSharpList`1<FrameworkVersion> get_DotNetFrameworkVersions();
    public static FSharpList`1<FrameworkIdentifier> get_DotNetFrameworkIdentifiers();
    public static FSharpList`1<TargetProfile> get_DotNetFrameworkProfiles();
    public static FSharpList`1<Net5Os> get_DotNet5OperatingSystems();
    public static FSharpList`1<TargetProfile> get_DotNet5WithOsProfiles();
    public static FSharpList`1<Net5WindowsVersion> get_DotNet5WindowsVersions();
    public static FSharpList`1<TargetProfile> get_DotNet5WindowsProfiles();
    public static FSharpList`1<Net6Os> get_DotNet6OperatingSystems();
    public static FSharpList`1<TargetProfile> get_DotNet6WithOsProfiles();
    public static FSharpList`1<Net6WindowsVersion> get_DotNet6WindowsVersions();
    public static FSharpList`1<TargetProfile> get_DotNet6WindowsProfiles();
    public static FSharpList`1<Net7Os> get_DotNet7OperatingSystems();
    public static FSharpList`1<TargetProfile> get_DotNet7WithOsProfiles();
    public static FSharpList`1<Net7WindowsVersion> get_DotNet7WindowsVersions();
    public static FSharpList`1<TargetProfile> get_DotNet7WindowsProfiles();
    public static FSharpList`1<Net8Os> get_DotNet8OperatingSystems();
    public static FSharpList`1<TargetProfile> get_DotNet8WithOsProfiles();
    public static FSharpList`1<Net8WindowsVersion> get_DotNet8WindowsVersions();
    public static FSharpList`1<TargetProfile> get_DotNet8WindowsProfiles();
    public static FSharpList`1<Net8Os> get_DotNet9OperatingSystems();
    public static FSharpList`1<TargetProfile> get_DotNet9WithOsProfiles();
    public static FSharpList`1<Net8WindowsVersion> get_DotNet9WindowsVersions();
    public static FSharpList`1<TargetProfile> get_DotNet9WindowsProfiles();
    public static FSharpList`1<DotNetStandardVersion> get_DotNetStandardVersions();
    public static FSharpList`1<TargetProfile> get_DotNetStandardProfiles();
    public static FSharpList`1<DotNetCoreAppVersion> get_DotNetCoreAppVersions();
    public static FSharpList`1<DotNetUnityVersion> get_DotNetUnityVersions();
    public static FSharpList`1<TargetProfile> get_DotNetCoreProfiles();
    public static FSharpList`1<WindowsVersion> get_WindowsVersions();
    public static FSharpList`1<TargetProfile> get_WindowsProfiles();
    public static FSharpList`1<TargetProfile> get_DotNetUnityProfiles();
    public static FSharpList`1<SilverlightVersion> get_SilverlightVersions();
    public static FSharpList`1<TargetProfile> get_SilverlightProfiles();
    public static FSharpList`1<MonoAndroidVersion> get_MonoAndroidVersions();
    public static FSharpList`1<TargetProfile> get_MonoAndroidProfiles();
    public static FSharpList`1<UAPVersion> get_UAPVersions();
    public static FSharpList`1<TargetProfile> get_UAPProfiles();
    public static FSharpList`1<WindowsPhoneVersion> get_WindowsPhoneVersions();
    public static FSharpList`1<TargetProfile> get_WindowsPhoneSilverlightProfiles();
    public static FSharpList`1<WindowsPhoneAppVersion> get_WindowsPhoneAppVersions();
    public static FSharpList`1<TargetProfile> get_WindowsPhoneAppProfiles();
    public static FSharpList`1<PortableProfileType> get_AllPortableProfiles();
    public static FSharpList`1<TargetProfile> get_AllDotNetProfiles();
    public static FSharpList`1<TargetProfile> get_AllDotNetStandardAndCoreProfiles();
    public static FSharpList`1<FrameworkIdentifier> get_AllNativeProfiles();
    public static bool isSupportedProfile(FrameworkIdentifier profile);
    public static FSharpSet`1<TargetProfile> get_AllProfiles();
    internal static FSharpList`1<TargetProfile> get_arg@1-3();
    public static FSharpOption`1<TargetProfile> TryFindPortableProfile(string name);
    public static TargetProfile FindPortableProfile(string name);
}
[CompilationMappingAttribute]
public static class Paket.LanguageEvaluation : object {
    [CompilationMappingAttribute]
internal static FSharpSet`1<Guid> csharpGuids { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Guid> arg@1-7 { get; }
    [CompilationMappingAttribute]
internal static FSharpSet`1<Guid> vbGuids { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Guid> arg@1-8 { get; }
    [CompilationMappingAttribute]
internal static FSharpSet`1<Guid> fsharpGuids { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Guid> arg@1-9 { get; }
    [CompilationMappingAttribute]
internal static FSharpSet`1<Guid> nemerleGuids { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Guid> arg@1-10 { get; }
    [CompilationMappingAttribute]
internal static FSharpSet`1<Guid> ironPythonGuids { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Guid> arg@1-11 { get; }
    [CompilationMappingAttribute]
internal static FSharpSet`1<Guid> serviceFabric { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<Guid> arg@1-12 { get; }
    internal static FSharpList`1<Guid> extractProjectTypeGuids(XmlDocument projectDocument);
    internal static FSharpSet`1<Guid> get_csharpGuids();
    internal static FSharpList`1<Guid> get_arg@1-7();
    internal static FSharpSet`1<Guid> get_vbGuids();
    internal static FSharpList`1<Guid> get_arg@1-8();
    internal static FSharpSet`1<Guid> get_fsharpGuids();
    internal static FSharpList`1<Guid> get_arg@1-9();
    internal static FSharpSet`1<Guid> get_nemerleGuids();
    internal static FSharpList`1<Guid> get_arg@1-10();
    internal static FSharpSet`1<Guid> get_ironPythonGuids();
    internal static FSharpList`1<Guid> get_arg@1-11();
    internal static FSharpSet`1<Guid> get_serviceFabric();
    internal static FSharpList`1<Guid> get_arg@1-12();
    internal static FSharpOption`1<ProjectLanguage> getGuidLanguage(Guid guid);
    internal static FSharpOption`1<ProjectLanguage> getLanguageFromExtension(string _arg1);
    internal static FSharpOption`1<ProjectLanguage> getLanguageFromFileName(string fileName);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpList`1<a>> cons@155(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProjectLanguage getProjectLanguage(XmlDocument projectDocument, string fileName);
}
[CompilationMappingAttribute]
public class Paket.Library : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Path@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string PathWithinPackage@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public string Path { get; }
    [CompilationMappingAttribute]
public string PathWithinPackage { get; }
    [DynamicDependencyAttribute("1632", "Paket.Library")]
public Library(string name, string path, string pathWithinPackage);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_PathWithinPackage();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Library obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Library obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.LibraryModule : object {
    public static Library ofFile(FrameworkDependentFile f);
}
[CompilationMappingAttribute]
public static class Paket.LoadingScripts : object {
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.LocalFile : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<LocalOverride> _devSourceOverrides;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<LocalOverride> devSourceOverrides { get; }
    [DynamicDependencyAttribute("1632", "Paket.LocalFile")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal LocalFile(FSharpList`1<LocalOverride> _devSourceOverrides);
    [CompilationMappingAttribute]
public static LocalFile NewLocalFile(FSharpList`1<LocalOverride> _devSourceOverrides);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<LocalOverride> get_devSourceOverrides();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(LocalFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LocalFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.LocalFileModule : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<FSharpList`1<string>, Result`2<LocalFile, string>> parse { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, Result`2<FSharpList`1<LocalOverride>, string>> func1@1-49 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<Result`2<LocalOverride, string>>> func1@1-50 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> func1@1-51 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> func1@1-52 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> func1@1-53 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> func1@1-54 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> func2@1-26 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> func2@1-27 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> func2@1-28 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<Result`2<LocalOverride, string>>> func2@1-29 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Result`2<FSharpList`1<LocalOverride>, string>, Result`2<LocalFile, string>> func2@1-31 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<LocalOverride>, LocalFile> f@1-22 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, Result`2<LocalFile, string>> readFile { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, FSharpList`1<string>> func1@1-55 { get; }
    [CompilationMappingAttribute]
public static LocalFile empty { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<string>> |Regex|_|(string pattern, string input);
    public static OverriddenPackage nameGroup(string name, string group);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<string> f@1-21(string source, FSharpList`1<Exception> _arg1);
    internal static Result`2<LocalOverride, string> parseLine(string _arg1);
    public static FSharpFunc`2<FSharpList`1<string>, Result`2<LocalFile, string>> get_parse();
    internal static FSharpFunc`2<FSharpList`1<string>, Result`2<FSharpList`1<LocalOverride>, string>> get_func1@1-49();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<Result`2<LocalOverride, string>>> get_func1@1-50();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> get_func1@1-51();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> get_func1@1-52();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> get_func1@1-53();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> get_func1@1-54();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> get_func2@1-26();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> get_func2@1-27();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<string>> get_func2@1-28();
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpList`1<Result`2<LocalOverride, string>>> get_func2@1-29();
    [CompilerGeneratedAttribute]
internal static Result`2<FSharpList`1<LocalOverride>, string> func2@1-30(FSharpList`1<Result`2<LocalOverride, string>> xs);
    internal static FSharpFunc`2<Result`2<FSharpList`1<LocalOverride>, string>, Result`2<LocalFile, string>> get_func2@1-31();
    internal static FSharpFunc`2<FSharpList`1<LocalOverride>, LocalFile> get_f@1-22();
    public static FSharpFunc`2<string, Result`2<LocalFile, string>> get_readFile();
    internal static FSharpFunc`2<string, FSharpList`1<string>> get_func1@1-55();
    public static LocalFile get_empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<a, ResolvedPackage> overrideResolution(a p, FSharpOption`1<SemVerInfo> v, PackageSource source, FSharpMap`2<a, ResolvedPackage> resolution);
    internal static LocalOverride warning(LocalOverride x);
    internal static PackageSource source@140-3(ResolvedSourceFile remoteFile, string packagesPath, GroupName groupName);
    [CompilerGeneratedAttribute]
internal static LockFile overrideDependency$cont@114(LockFile lockFile, LocalOverride _arg1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static LockFile func2@1-32(LockFile lockFile, LocalOverride _arg1);
    public static FSharpFunc`2<LocalOverride, LockFile> overrideDependency(LockFile lockFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static LockFile overrideLockFile(LocalFile _arg1, LockFile lockFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool overrides(LocalFile _arg1, PackageName package, GroupName group);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.LocalOverride : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLocalSourceOverride { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLocalGitOverride { get; }
    [CompilationMappingAttribute]
public static LocalOverride NewLocalSourceOverride(OverriddenPackage _package, PackageSource _devSource, FSharpOption`1<SemVerInfo> _version);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLocalSourceOverride();
    [CompilationMappingAttribute]
public static LocalOverride NewLocalGitOverride(OverriddenPackage _package, string _gitSource);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLocalGitOverride();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(LocalOverride obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LocalOverride obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.LockFile : object {
    internal FSharpMap`2<GroupName, LockFileGroup> groups;
    internal string fileName@638;
    public FSharpMap`2<GroupName, LockFileGroup> Groups { get; }
    public string FileName { get; }
    public string RootPath { get; }
    public FSharpList`1<Tuple`3<GroupName, PackageName, SemVerInfo>> InstalledPackages { get; }
    public LockFile(string fileName, FSharpMap`2<GroupName, LockFileGroup> groups);
    public FSharpMap`2<GroupName, LockFileGroup> get_Groups();
    public string get_FileName();
    public string get_RootPath();
    public LockFileGroup GetGroup(GroupName groupName);
    public string CheckIfPackageExistsInAnyGroup(PackageName packageName);
    public HashSet`1<Tuple`2<GroupName, PackageName>> GetAllNormalizedDependenciesOf(GroupName groupName, PackageName package, string context);
    public HashSet`1<PackageName> GetAllDependenciesOf(GroupName groupName, PackageName package, string context);
    public FSharpOption`1<HashSet`1<PackageName>> GetAllDependenciesOfSafe(GroupName groupName, PackageName package);
    public Lazy`1<IEnumerable`1<FrameworkIdentifier>> ResolveFrameworksForScriptGeneration();
    public FSharpSet`1<PackageName> GetDirectDependenciesOfSafe(GroupName groupName, PackageName package, string context);
    public FSharpSet`1<PackageName> GetTransitiveDependencies(GroupName groupName);
    public FSharpMap`2<PackageName, PackageInfo> GetTopLevelDependencies(GroupName groupName);
    public FSharpMap`2<Tuple`2<GroupName, PackageName>, PackageInfo> GetGroupedResolution();
    public FSharpMap`2<GroupName, FSharpList`1<PackageInfo>> GetResolvedPackages();
    public virtual string ToString();
    public bool Save();
    public static LockFile LoadFrom(string lockFileName);
    public static LockFile Parse(string lockFileName, String[] lines);
    public Dictionary`2<Tuple`2<GroupName, PackageName>, PackageInstallSettings> GetPackageHull(ReferencesFile referencesFile);
    public FSharpList`1<PackageInstallSettings> GetRemoteReferencedPackages(ReferencesFile referencesFile, InstallGroup installGroup);
    public Tuple`2<FSharpList`1<Tuple`3<Tuple`2<GroupName, PackageName>, PackageInstallSettings, FSharpSet`1<PackageName>>>, FSharpSet`1<ResolvedPackage>> GetOrderedPackageHull(GroupName groupName, ReferencesFile referencesFile, FSharpOption`1<TargetProfile> targetProfileOpt);
    public Tuple`2<FSharpList`1<Tuple`3<Tuple`2<GroupName, PackageName>, PackageInstallSettings, FSharpSet`1<PackageName>>>, FSharpSet`1<ResolvedPackage>> GetOrderedPackageHull(GroupName groupName, ReferencesFile referencesFile);
    public Dictionary`2<Tuple`2<GroupName, PackageName>, PackageInstallSettings> GetPackageHull(GroupName groupName, ReferencesFile referencesFile);
    public FSharpMap`2<Tuple`2<GroupName, PackageName>, FSharpSet`1<PackageName>> GetDependencyLookupTable();
    public Result`2<FSharpSet`1<PackageName>, DomainMessage> GetPackageHullSafe(ReferencesFile referencesFile, GroupName groupName);
    public InstallModel GetInstalledPackageModel(QualifiedPackageName _arg1);
    public FSharpList`1<Tuple`3<GroupName, PackageName, SemVerInfo>> get_InstalledPackages();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<ResolvedSourceFile> tryFindRemoteFile(FSharpList`1<ResolvedSourceFile> remoteFiles, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal ResolvedSourceFile findRemoteFile(string referencesFile, FSharpList`1<ResolvedSourceFile> remoteFiles, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal LockFileGroup findGroup(string referencesFile, GroupName groupName);
}
[CompilationMappingAttribute]
public class Paket.LockFileGroup : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal GroupName Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal InstallOptions Options@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<PackageName, ResolvedPackage> Resolution@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<ResolvedSourceFile> RemoteFiles@;
    [CompilationMappingAttribute]
public GroupName Name { get; }
    [CompilationMappingAttribute]
public InstallOptions Options { get; }
    [CompilationMappingAttribute]
public FSharpMap`2<PackageName, ResolvedPackage> Resolution { get; }
    [CompilationMappingAttribute]
public FSharpList`1<ResolvedSourceFile> RemoteFiles { get; }
    [DynamicDependencyAttribute("1632", "Paket.LockFileGroup")]
public LockFileGroup(GroupName name, InstallOptions options, FSharpMap`2<PackageName, ResolvedPackage> resolution, FSharpList`1<ResolvedSourceFile> remoteFiles);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public GroupName get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public InstallOptions get_Options();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpMap`2<PackageName, ResolvedPackage> get_Resolution();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ResolvedSourceFile> get_RemoteFiles();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(LockFileGroup obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public PackageInfo GetPackage(PackageName name);
    public FSharpOption`1<PackageInfo> TryFind(PackageName name);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LockFileGroup obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.LockFileParser : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@255-30(ParseState this, ParseState obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@255-31(IComparer comp, ParseState this, ParseState objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@255-15(ParseState this, object obj, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@265-32(ParserOption this, ParserOption obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@265-33(IComparer comp, ParserOption this, ParserOption objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@265-10(IEqualityComparer comp, ParserOption this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@265-16(ParserOption this, ParserOption that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@265-17(ParserOption this, ParserOption obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpChoice`7<string, string, Tuple`3<string, string, InstallSettings>, Tuple`2<Origin, string>, string, string, ParserOption> |Remote|NugetPackage|NugetDependency|SourceFile|RepositoryType|Group|InstallOption|$cont@368(string line, string trimmed, Unit unitVar);
    internal static FSharpChoice`7<string, string, Tuple`3<string, string, InstallSettings>, Tuple`2<Origin, string>, string, string, ParserOption> |Remote|NugetPackage|NugetDependency|SourceFile|RepositoryType|Group|InstallOption|(ParseState state, string line);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InstallOptions extractOption(ParseState currentGroup, ParserOption option);
    internal static FSharpFunc`2<string, string> remove@421-1(string textToRemove);
    internal static Tuple`4<string, ResolvedPackageKind, bool, InstallSettings> parsePackage@423-1(string s);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ParseState> Parse$cont@483-3(FSharpFunc`2<string, string> removeBrackets, FSharpList`1<ParseState> otherGroups, ParseState currentGroup, string details, FSharpOption`1<string> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ParseState> Parse$cont@506-4(FSharpList`1<ParseState> otherGroups, ParseState currentGroup, string v, string name, InstallSettings frameworkSettings, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ParseState> Parse$cont@531-6(FSharpFunc`2<string, string> removeBrackets, FSharpList`1<ParseState> otherGroups, ParseState currentGroup, Origin origin, string details, string project, string owner, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ParseState> Parse$cont@566-8(FSharpFunc`2<string, string> removeBrackets, FSharpList`1<ParseState> otherGroups, ParseState currentGroup, string details, string domain, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ParseState> Parse$cont@564-7(FSharpFunc`2<string, string> removeBrackets, FSharpList`1<ParseState> otherGroups, ParseState currentGroup, string details, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ParseState> Parse$cont@527-5(FSharpFunc`2<string, string> removeBrackets, FSharpList`1<ParseState> otherGroups, ParseState currentGroup, Origin origin, string details, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ParseState> Parse$cont@456-2(FSharpFunc`2<string, string> removeBrackets, string line, FSharpList`1<ParseState> otherGroups, ParseState currentGroup, Unit unitVar);
    public static FSharpList`1<ParseState> Parse(IEnumerable`1<string> lockFileLines);
}
[CompilationMappingAttribute]
public static class Paket.LockFileSerializer : object {
    [CompilationMappingAttribute]
public static ConcurrentDictionary`2<string, string> packageNames { get; }
    public static ConcurrentDictionary`2<string, string> get_packageNames();
    public static string writePackageName(PackageName name);
    public static FSharpList`1<string> serializeOptionsAsLines(InstallOptions options);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string serializePackages(InstallOptions options, FSharpMap`2<PackageName, ResolvedPackage> resolved);
    public static string serializeSourceFiles(FSharpList`1<ResolvedSourceFile> files);
}
[CompilationMappingAttribute]
public static class Paket.Logging : object {
    [CompilationMappingAttribute]
public static bool verbose { get; public set; }
    [CompilationMappingAttribute]
public static bool verboseWarnings { get; public set; }
    [CompilationMappingAttribute]
public static FSharpEvent`1<Trace> event { get; }
    [CompilationMappingAttribute]
internal static FSharpRef`1<int> omittedWarnings { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<object, Guid> warnings { get; }
    [CompilationMappingAttribute]
internal static object monitor { get; }
    [CompilationMappingAttribute]
internal static FSharpOption`1<string> logFile { get; internal set; }
    public static bool get_verbose();
    public static void set_verbose(bool value);
    public static bool get_verboseWarnings();
    public static void set_verboseWarnings(bool value);
    public static FSharpEvent`1<Trace> get_event();
    public static void tracen(string s);
    public static a tracefn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static void trace(string s);
    public static a tracef(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static void traceVerbose(string s);
    public static a verbosefn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static void traceError(string s);
    public static void traceWarn(string s);
    public static a traceErrorfn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    public static a traceWarnfn(PrintfFormat`4<a, Unit, string, Unit> fmt);
    internal static FSharpRef`1<int> get_omittedWarnings();
    internal static ConcurrentDictionary`2<object, Guid> get_warnings();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b traceIfNotBefore(FSharpFunc`2<string, Unit> tracer, a key, PrintfFormat`4<b, Unit, string, Unit> fmt);
    public static int getOmittedWarningCount();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b traceWarnIfNotBefore(a key, PrintfFormat`4<b, Unit, string, Unit> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static b traceErrorIfNotBefore(a key, PrintfFormat`4<b, Unit, string, Unit> fmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void traceColored(ConsoleColor color, string s);
    internal static object get_monitor();
    [CompilerGeneratedAttribute]
internal static void action@1(Trace trace, Unit unitVar0);
    public static void traceToConsole(Trace trace);
    internal static FSharpOption`1<string> get_logFile();
    internal static void set_logFile(FSharpOption`1<string> value);
    internal static void traceToFile(Trace trace);
    public static IDisposable setLogFile(string fileName);
    internal static void handleError@140(bool printFirstStack, bool printAggregatedStacks, bool printInnerStacks, ExnType exnType, bool useArrow, int indent, Exception exn, Unit unitVar0);
    internal static void printErrorHelper@139(bool printFirstStack, bool printAggregatedStacks, bool printInnerStacks, string defaultMessage, ExnType exnType, bool useArrow, int indent, Exception exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void printErrorExt(bool printFirstStack, bool printAggregatedStacks, bool printInnerStacks, Exception exn);
    public static void printError(Exception exn);
}
[CompilationMappingAttribute]
public static class Paket.Map : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpMap`2<a, b> merge(FSharpFunc`2<b, FSharpFunc`2<b, b>> f, FSharpMap`2<a, b> m1, FSharpMap`2<a, b> m2);
}
[CompilationMappingAttribute]
public static class Paket.ModuleResolver : object {
    internal static string computeFilePath(string owner, string project, string root, GroupName groupName, string name);
    public static string getVersionRequirement(VersionRestriction version);
    internal static FSharpList`1<ResolvedSourceFile> resolve@107(FSharpFunc`2<ResolvedSourceFile, Tuple`2<FSharpList`1<PackageRequirement>, FSharpList`1<UnresolvedSource>>> getDependencies, FSharpFunc`2<Origin, FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<VersionRestriction, FSharpFunc`2<FSharpOption`1<string>, string>>>>> getSha1, UnresolvedSource file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<ResolvedSourceFile> resolve(FSharpFunc`2<ResolvedSourceFile, Tuple`2<FSharpList`1<PackageRequirement>, FSharpList`1<UnresolvedSource>>> getDependencies, FSharpFunc`2<Origin, FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<VersionRestriction, FSharpFunc`2<FSharpOption`1<string>, string>>>>> getSha1, UnresolvedSource file);
    [CompilerGeneratedAttribute]
internal static int func2@1-2(FSharpList`1<string> source);
    internal static void detectConflicts(FSharpList`1<UnresolvedSource> remoteFiles);
    public static FSharpList`1<ResolvedSourceFile> Resolve(FSharpFunc`2<ResolvedSourceFile, Tuple`2<FSharpList`1<PackageRequirement>, FSharpList`1<UnresolvedSource>>> getDependencies, FSharpFunc`2<Origin, FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<VersionRestriction, FSharpFunc`2<FSharpOption`1<string>, string>>>>> getSha1, FSharpList`1<UnresolvedSource> remoteFiles);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.MonoAndroidVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V2_2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V2_3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V4_0_3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V4_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V4_2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V4_3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V4_4;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V5;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V5_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V6;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V7;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V7_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V8;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V8_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V9;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V10;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V11;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static MonoAndroidVersion _unique_V12;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V2_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV2_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V2_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV2_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V4_0_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_0_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V4_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V4_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V4_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V4_4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4_4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V5_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV5_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V7_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V8_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V9 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV9 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V10 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V11 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV11 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static MonoAndroidVersion V12 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV12 { get; }
    private static MonoAndroidVersion();
    [DynamicDependencyAttribute("2016", "Paket.MonoAndroidVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal MonoAndroidVersion(int _tag);
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV1();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V2_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV2_2();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V2_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV2_3();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V4_0_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_0_3();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V4_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_1();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V4_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_2();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V4_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_3();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V4_4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4_4();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV5();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V5_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV5_1();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV6();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V7();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V7_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7_1();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V8_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8_1();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V9();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV9();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V10();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V11();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV11();
    [CompilationMappingAttribute]
public static MonoAndroidVersion get_V12();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV12();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MonoAndroidVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string ShortString();
    public virtual string ToString();
    public static FSharpOption`1<MonoAndroidVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MonoAndroidVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.MsBuildFile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Path@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public string Path { get; }
    [DynamicDependencyAttribute("1632", "Paket.MsBuildFile")]
public MsBuildFile(string name, string path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MsBuildFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MsBuildFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.MsBuildFileModule : object {
    public static MsBuildFile ofUnparsedPackageFile(UnparsedPackageFile unparsedFile);
    public static MsBuildFile ofFrameworkDependantFile(FrameworkDependentFile f);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Net5Os : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5Os _unique_Android;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5Os _unique_IOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5Os _unique_MacOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5Os _unique_TvOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5Os _unique_WatchOs;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5Os Android { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAndroid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5Os IOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5Os MacOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMacOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5Os TvOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTvOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5Os WatchOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWatchOs { get; }
    private static Net5Os();
    [DynamicDependencyAttribute("2016", "Paket.Net5Os")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Net5Os(int _tag);
    [CompilationMappingAttribute]
public static Net5Os get_Android();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAndroid();
    [CompilationMappingAttribute]
public static Net5Os get_IOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIOs();
    [CompilationMappingAttribute]
public static Net5Os get_MacOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMacOs();
    [CompilationMappingAttribute]
public static Net5Os get_TvOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTvOs();
    [CompilationMappingAttribute]
public static Net5Os get_WatchOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWatchOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Net5Os obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpOption`1<Net5Os> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Net5Os obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Net5WindowsVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5WindowsVersion _unique_V7_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5WindowsVersion _unique_V8_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5WindowsVersion _unique_V10_0_17763_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5WindowsVersion _unique_V10_0_18362_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net5WindowsVersion _unique_V10_0_19041_0;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5WindowsVersion V7_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5WindowsVersion V8_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5WindowsVersion V10_0_17763_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_17763_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5WindowsVersion V10_0_18362_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_18362_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net5WindowsVersion V10_0_19041_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_19041_0 { get; }
    private static Net5WindowsVersion();
    [DynamicDependencyAttribute("2016", "Paket.Net5WindowsVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Net5WindowsVersion(int _tag);
    [CompilationMappingAttribute]
public static Net5WindowsVersion get_V7_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7_0();
    [CompilationMappingAttribute]
public static Net5WindowsVersion get_V8_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8_0();
    [CompilationMappingAttribute]
public static Net5WindowsVersion get_V10_0_17763_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_17763_0();
    [CompilationMappingAttribute]
public static Net5WindowsVersion get_V10_0_18362_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_18362_0();
    [CompilationMappingAttribute]
public static Net5WindowsVersion get_V10_0_19041_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_19041_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Net5WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpOption`1<Net5WindowsVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Net5WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Net6Os : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6Os _unique_Android;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6Os _unique_IOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6Os _unique_MacOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6Os _unique_TvOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6Os _unique_WatchOs;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6Os Android { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAndroid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6Os IOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6Os MacOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMacOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6Os TvOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTvOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6Os WatchOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWatchOs { get; }
    private static Net6Os();
    [DynamicDependencyAttribute("2016", "Paket.Net6Os")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Net6Os(int _tag);
    [CompilationMappingAttribute]
public static Net6Os get_Android();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAndroid();
    [CompilationMappingAttribute]
public static Net6Os get_IOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIOs();
    [CompilationMappingAttribute]
public static Net6Os get_MacOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMacOs();
    [CompilationMappingAttribute]
public static Net6Os get_TvOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTvOs();
    [CompilationMappingAttribute]
public static Net6Os get_WatchOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWatchOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Net6Os obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpOption`1<Net6Os> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Net6Os obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Net6WindowsVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6WindowsVersion _unique_V7_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6WindowsVersion _unique_V8_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6WindowsVersion _unique_V10_0_17763_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6WindowsVersion _unique_V10_0_18362_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net6WindowsVersion _unique_V10_0_19041_0;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6WindowsVersion V7_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6WindowsVersion V8_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6WindowsVersion V10_0_17763_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_17763_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6WindowsVersion V10_0_18362_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_18362_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net6WindowsVersion V10_0_19041_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_19041_0 { get; }
    private static Net6WindowsVersion();
    [DynamicDependencyAttribute("2016", "Paket.Net6WindowsVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Net6WindowsVersion(int _tag);
    [CompilationMappingAttribute]
public static Net6WindowsVersion get_V7_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7_0();
    [CompilationMappingAttribute]
public static Net6WindowsVersion get_V8_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8_0();
    [CompilationMappingAttribute]
public static Net6WindowsVersion get_V10_0_17763_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_17763_0();
    [CompilationMappingAttribute]
public static Net6WindowsVersion get_V10_0_18362_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_18362_0();
    [CompilationMappingAttribute]
public static Net6WindowsVersion get_V10_0_19041_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_19041_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Net6WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpOption`1<Net6WindowsVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Net6WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Net7Os : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7Os _unique_Android;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7Os _unique_IOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7Os _unique_MacOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7Os _unique_TvOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7Os _unique_WatchOs;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7Os Android { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAndroid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7Os IOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7Os MacOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMacOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7Os TvOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTvOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7Os WatchOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWatchOs { get; }
    private static Net7Os();
    [DynamicDependencyAttribute("2016", "Paket.Net7Os")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Net7Os(int _tag);
    [CompilationMappingAttribute]
public static Net7Os get_Android();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAndroid();
    [CompilationMappingAttribute]
public static Net7Os get_IOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIOs();
    [CompilationMappingAttribute]
public static Net7Os get_MacOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMacOs();
    [CompilationMappingAttribute]
public static Net7Os get_TvOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTvOs();
    [CompilationMappingAttribute]
public static Net7Os get_WatchOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWatchOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Net7Os obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpOption`1<Net7Os> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Net7Os obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Net7WindowsVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7WindowsVersion _unique_V7_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7WindowsVersion _unique_V8_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7WindowsVersion _unique_V10_0_17763_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7WindowsVersion _unique_V10_0_18362_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net7WindowsVersion _unique_V10_0_19041_0;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7WindowsVersion V7_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7WindowsVersion V8_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7WindowsVersion V10_0_17763_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_17763_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7WindowsVersion V10_0_18362_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_18362_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net7WindowsVersion V10_0_19041_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_19041_0 { get; }
    private static Net7WindowsVersion();
    [DynamicDependencyAttribute("2016", "Paket.Net7WindowsVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Net7WindowsVersion(int _tag);
    [CompilationMappingAttribute]
public static Net7WindowsVersion get_V7_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7_0();
    [CompilationMappingAttribute]
public static Net7WindowsVersion get_V8_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8_0();
    [CompilationMappingAttribute]
public static Net7WindowsVersion get_V10_0_17763_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_17763_0();
    [CompilationMappingAttribute]
public static Net7WindowsVersion get_V10_0_18362_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_18362_0();
    [CompilationMappingAttribute]
public static Net7WindowsVersion get_V10_0_19041_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_19041_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Net7WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpOption`1<Net7WindowsVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Net7WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Net8Os : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8Os _unique_Android;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8Os _unique_IOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8Os _unique_MacOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8Os _unique_TvOs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8Os _unique_WatchOs;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8Os Android { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAndroid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8Os IOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8Os MacOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMacOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8Os TvOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTvOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8Os WatchOs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWatchOs { get; }
    private static Net8Os();
    [DynamicDependencyAttribute("2016", "Paket.Net8Os")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Net8Os(int _tag);
    [CompilationMappingAttribute]
public static Net8Os get_Android();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAndroid();
    [CompilationMappingAttribute]
public static Net8Os get_IOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIOs();
    [CompilationMappingAttribute]
public static Net8Os get_MacOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMacOs();
    [CompilationMappingAttribute]
public static Net8Os get_TvOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTvOs();
    [CompilationMappingAttribute]
public static Net8Os get_WatchOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWatchOs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Net8Os obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpOption`1<Net8Os> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Net8Os obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Net8WindowsVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8WindowsVersion _unique_V7_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8WindowsVersion _unique_V8_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8WindowsVersion _unique_V10_0_17763_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8WindowsVersion _unique_V10_0_18362_0;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Net8WindowsVersion _unique_V10_0_19041_0;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8WindowsVersion V7_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8WindowsVersion V8_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8WindowsVersion V10_0_17763_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_17763_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8WindowsVersion V10_0_18362_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_18362_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Net8WindowsVersion V10_0_19041_0 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_19041_0 { get; }
    private static Net8WindowsVersion();
    [DynamicDependencyAttribute("2016", "Paket.Net8WindowsVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Net8WindowsVersion(int _tag);
    [CompilationMappingAttribute]
public static Net8WindowsVersion get_V7_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7_0();
    [CompilationMappingAttribute]
public static Net8WindowsVersion get_V8_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8_0();
    [CompilationMappingAttribute]
public static Net8WindowsVersion get_V10_0_17763_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_17763_0();
    [CompilationMappingAttribute]
public static Net8WindowsVersion get_V10_0_18362_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_18362_0();
    [CompilationMappingAttribute]
public static Net8WindowsVersion get_V10_0_19041_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_19041_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Net8WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public static FSharpOption`1<Net8WindowsVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Net8WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Paket.NetUtils : object {
    internal static int requestTimeoutInMs { get; }
    internal static int uploadRequestTimeoutInMs { get; }
    [CompilationMappingAttribute]
internal static bool isRequestEnvVarSet { get; }
    [CompilationMappingAttribute]
public static Lazy`1<FSharpMap`2<string, IWebProxy>> calcEnvProxies { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, IWebProxy> getDefaultProxyFor { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, IWebProxy> cache@54 { get; }
    [CompilationMappingAttribute]
public static bool useDefaultHandler { get; }
    [CompilationMappingAttribute]
internal static string env@346 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Tuple`2<string, FSharpOption`1<Auth>>, HttpMessageHandler> createHttpHandler { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Tuple`2<string, FSharpOption`1<Auth>>, HttpMessageHandler> cache@54-1 { get; }
    [CompilationMappingAttribute]
internal static string paketVersion { get; }
    [CompilationMappingAttribute]
internal static Object[] attrs@411 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<object, FSharpOption`1<string>> chooser@414 { get; }
    [CompilationMappingAttribute]
internal static Object[] source@414 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_requestTimeoutInMs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_uploadRequestTimeoutInMs();
    internal static bool get_isRequestEnvVarSet();
    internal static AuthType parseAuthTypeString(string str);
    public static string normalizeFeedUrl(string source);
    internal static string getEnvValue@73(string name);
    internal static FSharpOption`1<NetworkCredential> getCredentials@83(Uri uri);
    internal static FSharpOption`1<IWebProxy> getProxy@89(String[] bypassList, string scheme);
    public static FSharpMap`2<string, IWebProxy> envProxies();
    public static Lazy`1<FSharpMap`2<string, IWebProxy>> get_calcEnvProxies();
    public static FSharpFunc`2<string, IWebProxy> get_getDefaultProxyFor();
    internal static IWebProxy getDefault@129(Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static IWebProxy f@63(string url);
    internal static ConcurrentDictionary`2<string, IWebProxy> get_cache@54();
    public static FSharpAsync`1<Unit> failIfNoSuccess(HttpResponseMessage resp);
    public static FSharpOption`1<HttpStatusCode> requestStatus(Exception ex);
    public static FSharpOption`1<HttpStatusCode> |RequestStatus|_|(object ex);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<Unit> HttpClient.DownloadFileTaskAsync(HttpClient x, Uri uri, CancellationToken tok, string filePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<Unit> HttpClient.DownloadFileTaskAsync(HttpClient x, string uri, CancellationToken tok, string filePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void HttpClient.DownloadFile(HttpClient x, string uri, string filePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void HttpClient.DownloadFile(HttpClient x, Uri uri, string filePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<string> HttpClient.DownloadStringTaskAsync(HttpClient x, Uri uri, CancellationToken tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<string> HttpClient.DownloadStringTaskAsync(HttpClient x, string uri, CancellationToken tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string HttpClient.DownloadString(HttpClient x, string uri);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string HttpClient.DownloadString(HttpClient x, Uri uri);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<Byte[]> HttpClient.DownloadDataTaskAsync(HttpClient x, Uri uri, CancellationToken tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Task`1<Byte[]> HttpClient.DownloadDataTaskAsync(HttpClient x, string uri, CancellationToken tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] HttpClient.DownloadData(HttpClient x, string uri);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] HttpClient.DownloadData(HttpClient x, Uri uri);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HttpResponseMessage HttpClient.UploadFileAsMultipart(HttpClient x, Uri url, string filename);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addAcceptHeader(HttpClient client, string contentType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addHeader(HttpClient client, string headerKey, string headerVal);
    public static bool get_useDefaultHandler();
    internal static string get_env@346();
    public static HttpMessageHandler createHttpHandlerRaw(string url, FSharpOption`1<Auth> auth);
    public static FSharpFunc`2<Tuple`2<string, FSharpOption`1<Auth>>, HttpMessageHandler> get_createHttpHandler();
    internal static Tuple`2<string, FSharpOption`1<Auth>> getKey@60(string url, FSharpOption`1<Auth> auth);
    internal static ConcurrentDictionary`2<Tuple`2<string, FSharpOption`1<Auth>>, HttpMessageHandler> get_cache@54-1();
    internal static string get_paketVersion();
    internal static Object[] get_attrs@411();
    internal static FSharpFunc`2<object, FSharpOption`1<string>> get_chooser@414();
    internal static Object[] get_source@414();
    public static HttpClient createHttpClient(string url, FSharpOption`1<Auth> auth);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<a> catchHandler@1-1(AuthProvider auth, FSharpFunc`2<FSharpOption`1<Auth>, FSharpAsync`1<a>> doRequest, Exception _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<a> resolveAuth(AuthProvider auth, FSharpFunc`2<FSharpOption`1<Auth>, FSharpAsync`1<a>> doRequest);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-2(string url, Exception exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Unit> downloadFromUrlWithTimeout(AuthProvider auth, string url, FSharpOption`1<TimeSpan> timeout, string filePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<Unit> downloadFromUrl(AuthProvider auth, string url, string filePath);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<string> catchHandler@1-3(string url, Exception exn);
    public static FSharpAsync`1<string> getFromUrl(AuthProvider auth, string url, string contentType);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<string> catchHandler@1-4(string url, Exception exn);
    public static FSharpAsync`1<string> getXmlFromUrl(AuthProvider auth, string url);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<SafeWebResult`1<string>> catchHandler@1-5(string url, int nTries, int iTry, string contentType, FSharpOption`1<Auth> auth, bool canRetry, Uri uri, CancellationToken tok, CancellationTokenSource tokSource, Exception _arg4);
    internal static FSharpAsync`1<SafeWebResult`1<string>> _safeGetFromUrl(FSharpOption`1<Auth> auth, string url, string contentType, int iTry, int nTries);
    public static FSharpAsync`1<SafeWebResult`1<string>> safeGetFromUrl(AuthProvider auth, string url, string contentType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<string, DomainMessage> downloadStringSync(string url, HttpClient client);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Unit, DomainMessage> downloadFileSync(string url, string fileName, HttpClient client);
}
[CompilationMappingAttribute]
public static class Paket.NuGet : object {
    [CompilationMappingAttribute]
public static ConcurrentDictionary`2<PackageSource, string> protocolCache { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NuGetContent ofGivenList(string rootName, IEnumerable`1<string> directories, IEnumerable`1<string> files);
    internal static NuGetContent ofDirectorySlow(string targetFolder);
    internal static NuGetContent readFromDisk@120(string targetFolder, string spec, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void action@1-9(Dictionary`2<string, FSharpList`1<NuGetContent>> folders, string parent, NuGetContent item, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void action@1-10(Dictionary`2<string, FSharpList`1<NuGetContent>> folders, string parent, NuGetContent item, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<NuGetContent, NuGetContent> fixContent@82-1(Dictionary`2<string, FSharpList`1<NuGetContent>> folders, string path);
    [CompilerGeneratedAttribute]
internal static NuGetContent ofDirectory$cont@134(string targetFolder, string spec, Unit unitVar);
    public static NuGetContent ofDirectory(string targetFolder);
    public static NuGetContent createEntry(string content);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<NuGetContent> addContent(string content, FSharpList`1<NuGetContent> contents);
    public static FSharpList`1<NuGetContent> ofFiles(IEnumerable`1<string> filesList);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lazy`1<NuGetPackageContent> GetContentWithNuSpec(Nuspec spec, string dir);
    public static Lazy`1<NuGetPackageContent> GetContent(string dir);
    internal static FSharpFunc`2<NuGetContent, FSharpList`1<UnparsedPackageFile>> collectItems@244(string prefixFull, string prefixInner);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<FSharpList`1<UnparsedPackageFile>> tryFindFolder(string folder, NuGetPackageContent content);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<UnparsedPackageFile> tryFindFile(string file, NuGetPackageContent content);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-22(SemVerInfo version, PackageName packageName, string licenseUrl, bool verboseRequest, Exception exn);
    public static FSharpAsync`1<Unit> DownloadLicense(a root, bool force, PackageName packageName, SemVerInfo version, string licenseUrl, string targetFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnparsedPackageFile[] getFilesMatching(string targetFolder, string searchPattern, string subFolderName, string filesDescriptionForVerbose);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnparsedPackageFile[] getFiles(string targetFolder, string subFolderName, string filesDescriptionForVerbose);
    [ObsoleteAttribute("Use GetContent instead")]
public static UnparsedPackageFile[] GetLibFiles(string targetFolder);
    [ObsoleteAttribute("Use GetContent instead")]
public static UnparsedPackageFile[] GetTargetsFiles(string targetFolder, PackageName pkg);
    [ObsoleteAttribute("Use GetContent instead")]
public static UnparsedPackageFile[] GetAnalyzerFiles(string targetFolder);
    public static NuGetRequestGetVersions tryNuGetV3(AuthProvider auth, string nugetV3Url, PackageName package);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<ODataSearchResult> catchHandler@1-23(GetPackageDetailsParameters parameters, PackageName packageName, SemVerInfo version, bool verboseRequest, NuGetSource nugetSource, bool force, Exception exn);
    internal static FSharpAsync`1<ODataSearchResult> v3AndFallBack@409(GetPackageDetailsParameters parameters, PackageName packageName, SemVerInfo version, bool verboseRequest, NuGetSource nugetSource, bool force);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Tuple`2<FSharpOption`1<Tuple`2<a, NuGetPackageCache>>, FSharpList`1<Exception>>> catchHandler@1-24(bool verboseRequest, FSharpList`1<Exception> errors, a source, FSharpList`1<Tuple`2<a, FSharpAsync`1<ODataSearchResult>>> rest, Exception _arg3);
    internal static FSharpAsync`1<Tuple`2<FSharpOption`1<Tuple`2<a, NuGetPackageCache>>, FSharpList`1<Exception>>> trySelectFirst@432(bool verboseRequest, FSharpList`1<Exception> errors, FSharpList`1<Tuple`2<a, FSharpAsync`1<ODataSearchResult>>> workLeft);
    internal static FSharpAsync`1<Tuple`2<FSharpOption`1<Tuple`2<PackageSource, NuGetPackageCache>>, FSharpList`1<Exception>>> getPackageDetails@430-16(FSharpOption`1<string> alternativeProjectRoot, string root, GetPackageDetailsParameters parameters, FSharpList`1<PackageSource> sources, PackageName packageName, SemVerInfo version, bool verboseRequest, FSharpOption`1<Tuple`2<PackageSource, ODataSearchResult>> inCache, bool force);
    internal static a fallback@491(FSharpList`1<PackageSource> sources, PackageName packageName, SemVerInfo version, FSharpList`1<Exception> errors, Unit unitVar0);
    internal static string encodeURL@511(string url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<PackageDetails> getPackageDetails(FSharpOption`1<string> alternativeProjectRoot, string root, bool force, GetPackageDetailsParameters parameters);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<PackageDetails> catchHandler@1-25(FSharpOption`1<string> alternativeProjectRoot, string root, bool force, GetPackageDetailsParameters parameters, bool verboseRequest, Exception exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<PackageDetails> GetPackageDetails(FSharpOption`1<string> alternativeProjectRoot, string root, bool force, GetPackageDetailsParameters parameters);
    public static ConcurrentDictionary`2<PackageSource, string> get_protocolCache();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NuGetRequestGetVersions getVersionsCached(string key, FSharpFunc`2<Tuple`3<a, b, c>, NuGetRequestGetVersions> f, PackageSource source, a auth, b nugetURL, c package);
    internal static FileInfo getVersionsFailedCacheFileName@592(PackageName packageName, PackageSource source);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpList`1<NuGetRequestGetVersions>> versionResponse$cont@615(FSharpOption`1<string> alternativeProjectRoot, string root, PackageName packageName, PackageSource nugetSource, Unit unitVar);
    internal static FSharpAsync`1<GetVersionRequestResult> trial@591(FSharpOption`1<string> alternativeProjectRoot, string root, PackageName packageName, FSharpList`1<PackageSource> sources, bool force);
    internal static string reportRequests@679(bool verboseRequest, bool withDetails, GetVersionRequestResult trial);
    internal static Exception getException@713(GetVersionRequestResult trial, string message);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpList`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>> GetVersions(bool force, FSharpOption`1<string> alternativeProjectRoot, string root, GetPackageVersionsParameters parameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getLicenseFile(PackageName packageName, SemVerInfo version);
    internal static void ensureDir@814(string fileName);
    internal static bool getFromCache@818(SemVerInfo version, PackageName packageName, string nupkgName, string normalizedNupkgName, string targetFileName, FSharpList`1<Cache> caches);
    internal static bool getFromFallbackFolder@842(SemVerInfo version, PackageName packageName, string targetFileName, Unit unitVar0);
    internal static int getTimeoutOrDefaultValue@910(string registryEntry, int defaultValue);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-26(string targetFileName, Exception _arg11);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<bool> catchHandler@1-27(SemVerInfo version, PackageName packageName, PackageDetails nugetPackage, FSharpRef`1<bool> didDownload, Exception exn);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<bool> catchHandler@1-28(SemVerInfo version, PackageSource source, string root, PackageName packageName, GroupName groupName, bool force, bool downloadLicense, FSharpList`1<Cache> caches, FSharpOption`1<string> alternativeProjectRoot, string nupkgName, string normalizedNupkgName, string targetFileName, FileInfo targetFile, string licenseFileName, int attempt, FSharpRef`1<string> downloadUrl, Exception _arg14);
    internal static FSharpAsync`1<bool> download@852-2(SemVerInfo version, PackageSource source, string root, PackageName packageName, GroupName groupName, bool force, bool downloadLicense, FSharpList`1<Cache> caches, FSharpOption`1<string> alternativeProjectRoot, string nupkgName, string normalizedNupkgName, string targetFileName, FileInfo targetFile, string licenseFileName, bool authenticated, int attempt);
    internal static FSharpAsync`1<Tuple`2<string, string>> downloadAndExtractPackage(FSharpOption`1<string> alternativeProjectRoot, string root, bool isLocalOverride, PackagesFolderGroupConfig config, PackageSource source, FSharpList`1<Cache> caches, GroupName groupName, PackageName packageName, SemVerInfo version, ResolvedPackageKind kind, bool includeVersionInPath, bool downloadLicense, bool force, bool detailed);
    public static FSharpAsync`1<Tuple`2<string, string>> DownloadAndExtractPackage(FSharpOption`1<string> alternativeProjectRoot, string root, bool isLocalOverride, PackagesFolderGroupConfig config, PackageSource source, FSharpList`1<Cache> caches, GroupName groupName, PackageName packageName, SemVerInfo version, ResolvedPackageKind kind, bool includeVersionInPath, bool downloadLicense, bool force, bool detailed);
}
[CompilationMappingAttribute]
public static class Paket.NuGetCache : object {
    [CompilationMappingAttribute]
public static Lazy`1<FSharpOption`1<string>> TryGetFallbackFolderFromHardCodedPath { get; }
    [CompilationMappingAttribute]
internal static VersionFolderPathResolver pathResolver { get; }
    [CompilationMappingAttribute]
internal static ISettings nugetSettings { get; }
    [CompilationMappingAttribute]
internal static ILogger nugetLogger { get; }
    [CompilationMappingAttribute]
internal static LoggerBase b@471 { get; }
    [CompilationMappingAttribute]
internal static ClientPolicyContext signingContext { get; }
    [CompilationMappingAttribute]
internal static PackageExtractionContext extractionContext { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpFunc`2<Unit, FSharpAsync`1<object>>, FSharpFunc`2<FSharpFunc`2<object, bool>, FSharpFunc`2<Tuple`2<NuGetSource, UrlId>, MemoizeAsyncExResult`2<object, bool>>>> tryUrlOrIgnoreI { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<FSharpFunc`2<Unit, FSharpAsync`1<object>>, FSharpFunc`2<object, bool>>, FSharpFunc`2<Tuple`2<NuGetSource, UrlId>, MemoizeAsyncExResult`2<object, bool>>> memoizedIgnoreList@655 { get; }
    public static FileInfo FileInfo(string str);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<NuGetResponseGetVersions> catchHandler@1-8(NuGetRequestGetVersions r, Exception e);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@117-20(NuGetPackageCache this, NuGetPackageCache obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@117-21(NuGetPackageCache this, NuGetPackageCache objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@117-6(IEqualityComparer comp, NuGetPackageCache this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@117-10(NuGetPackageCache this, object obj, IEqualityComparer comp, Unit unitVar);
    public static string normalizeUrl(string url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo getCacheFiles(bool force, string cacheVersion, string nugetURL, PackageName packageName, SemVerInfo version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string GetLicenseFileName(PackageName packageName, SemVerInfo version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string GetPackageFileName(PackageName packageName, SemVerInfo version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isExtracted(DirectoryInfo directory, PackageName packageName, SemVerInfo version);
    public static bool IsPackageVersionExtracted(ResolvedPackagesFolder config, PackageName packageName, SemVerInfo version);
    internal static void cleanup(DirectoryInfo dir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string GetTargetUserFolder(PackageName packageName, SemVerInfo version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string GetTargetUserNupkg(PackageName packageName, SemVerInfo version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string GetTargetUserToolsFolder(PackageName packageName, SemVerInfo version);
    public static Lazy`1<FSharpOption`1<string>> get_TryGetFallbackFolderFromHardCodedPath();
    public static FSharpOption`1<string> TryGetFallbackFolderFromBin();
    public static FSharpOption`1<string> TryGetFallbackFolder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> TryGetFallbackNupkg(PackageName packageName, SemVerInfo version);
    public static string GetPackageUserFolderDir(PackageName packageName, SemVerInfo version, ResolvedPackageKind kind);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ODataSearchResult> tryGetDetailsFromCache$cont@296(PackageName packageName, SemVerInfo version, FileInfo cacheFile, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<ODataSearchResult> tryGetDetailsFromCache(bool force, string nugetURL, PackageName packageName, SemVerInfo version);
    public static FSharpOption`1<Tuple`2<PackageName, SemVerInfo>> parsePackageInfoFromFileName(string fileName);
    internal static bool condition@352(PackageName packageName, SemVerInfo version, string x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<FileInfo> tryFindLocalPackage(string directory, PackageName packageName, SemVerInfo version);
    public static Nuspec getNuSpecFromNupkg(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<NuGetPackageCache>> getCacheDataFromExtractedPackage(PackageName packageName, SemVerInfo version);
    internal static void writeCacheFile@418(bool force, string nugetURL, PackageName packageName, SemVerInfo version, NuGetPackageCache result);
    internal static FSharpAsync`1<ODataSearchResult> getViaWebRequest@434(bool force, string nugetURL, PackageName packageName, SemVerInfo version, FSharpFunc`2<Unit, FSharpAsync`1<ODataSearchResult>> getViaWebRequest, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<ODataSearchResult> getDetailsFromCacheOr(bool force, string nugetURL, PackageName packageName, SemVerInfo version, FSharpFunc`2<Unit, FSharpAsync`1<ODataSearchResult>> getViaWebRequest);
    internal static VersionFolderPathResolver get_pathResolver();
    internal static ISettings get_nugetSettings();
    internal static ILogger get_nugetLogger();
    internal static LoggerBase get_b@471();
    internal static ClientPolicyContext get_signingContext();
    internal static PackageExtractionContext get_extractionContext();
    internal static FSharpAsync`1<Unit> extract@505(SemVerInfo version, PackageName packageName, DirectoryInfo targetFolder, string packageSource, PackageIdentity identity, string nupkgPath);
    public static FSharpAsync`1<string> ExtractPackageToUserFolder(PackageSource source, string downloadedNupkgPath, PackageName packageName, SemVerInfo version, ResolvedPackageKind kind);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-9(string fileName, bool detailed, Exception exn);
    public static FSharpAsync`1<string> ExtractPackage(string fileName, string targetFolder, PackageName packageName, SemVerInfo version, bool detailed);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-10(SemVerInfo version, PackageName packageName, string cacheFileName, Exception exn);
    public static FSharpAsync`1<Unit> CopyLicenseFromCache(ResolvedPackagesFolder config, string cacheFileName, PackageName packageName, SemVerInfo version, bool force);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpOption`1<string>> catchHandler@1-11(string targetFolder, FileInfo targetFile, Exception exn);
    public static FSharpAsync`1<FSharpOption`1<string>> CopyFromCache(ResolvedPackagesFolder config, string cacheFileName, string licenseCacheFile, PackageName packageName, SemVerInfo version, bool force, bool detailed);
    public static void CopyToCache(Cache cache, string fileName, bool force);
    internal static FSharpFunc`2<FSharpFunc`2<Unit, FSharpAsync`1<object>>, FSharpFunc`2<FSharpFunc`2<object, bool>, FSharpFunc`2<Tuple`2<NuGetSource, UrlId>, MemoizeAsyncExResult`2<object, bool>>>> get_tryUrlOrIgnoreI();
    internal static FSharpFunc`2<Tuple`2<FSharpFunc`2<Unit, FSharpAsync`1<object>>, FSharpFunc`2<object, bool>>, FSharpFunc`2<a, FSharpAsync`1<Tuple`2<bool, object>>>> tryUrlOrIgnoreInner@649();
    internal static FSharpFunc`2<Tuple`2<FSharpFunc`2<Unit, FSharpAsync`1<object>>, FSharpFunc`2<object, bool>>, FSharpFunc`2<Tuple`2<NuGetSource, UrlId>, MemoizeAsyncExResult`2<object, bool>>> get_memoizedIgnoreList@655();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MemoizeAsyncExResult`2<a, bool> tryUrlOrIgnore(FSharpFunc`2<Unit, FSharpAsync`1<a>> f, FSharpFunc`2<a, bool> isOk, NuGetSource source, UrlId id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpChoice`2<ODataSearchResult, Exception>> tryAndIgnoreUrl(bool doIgnore, bool doWarn, NuGetSource source, FSharpFunc`2<FSharpChoice`2<ODataSearchResult, Exception>, bool> tryAgain, FSharpFunc`2<string, FSharpAsync`1<FSharpChoice`2<ODataSearchResult, Exception>>> f, FSharpList`1<UrlToTry> urls);
}
[CompilationMappingAttribute]
public static class Paket.NuGetConvert : object {
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<string> func1@1-57(XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> tryGetValue(string key, XmlNode node);
    internal static FSharpList`1<Tuple`2<string, string>> getKeyValueList(XmlNode node);
    internal static FSharpOption`1<Auth> getAuth@92(XmlNode configNode, string key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static PackageRequirement createPackageRequirement(FSharpList`1<PackageSource> sources, string packageName, VersionRequirement versionRequirement, FrameworkRestrictions restrictions, string dependenciesFileName_0, int dependenciesFileName_1);
    internal static bool isFSharpProject(string projectFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`4<string, VersionRequirement, FrameworkRestriction, NugetPackageKind>> addFSharpCoreToDependenciesIfRequired(NugetEnv nugetEnv, FSharpList`1<Tuple`4<string, VersionRequirement, FrameworkRestriction, NugetPackageKind>> packages);
    internal static FSharpList`1<Tuple`2<string, a>> findDistinctPackages@263(FSharpList`1<Tuple`2<string, FSharpList`1<NugetPackage>>> allVersionsGroupped, FSharpFunc`2<FSharpList`1<NugetPackage>, a> selector);
    internal static FSharpFunc`2<PrintfFormat`4<FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<a>, Unit>>, Unit, string, Unit>, Unit> findWarnings@268(FSharpList`1<Tuple`2<string, FSharpList`1<NugetPackage>>> allVersionsGroupped, FSharpFunc`2<FSharpList`1<NugetPackage>, FSharpList`1<a>> searchBy);
    internal static Result`2<DependenciesFile, DomainMessage> read@310-2(string dependenciesFileName, FSharpList`1<Tuple`4<string, VersionRequirement, FrameworkRestriction, NugetPackageKind>> packages, Unit unitVar0);
    internal static void f@1-24(PackageSource tupledArg0, FSharpList`1<DomainMessage> tupledArg1);
    internal static Result`2<DependenciesFile, DomainMessage> create@330(NugetEnv nugetEnv, CredsMigrationMode mode, string dependenciesFileName, FSharpList`1<Tuple`4<string, VersionRequirement, FrameworkRestriction, NugetPackageKind>> packages, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<DependenciesFile, DomainMessage> createDependenciesFileR(DirectoryInfo rootDirectory, NugetEnv nugetEnv, CredsMigrationMode mode);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReferencesFile convertPackagesConfigToReferencesFile(string projectFileName, NugetPackagesConfig packagesConfig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReferencesFile convertDependenciesConfigToReferencesFile(string projectFileName, FSharpList`1<Tuple`2<PackageName, a>> dependencies);
    internal static bool containsFSharpCore@383(ReferencesFile references);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReferencesFile addFSharpCoreToReferencesIfRequired(string projectFileName, ReferencesFile references);
    public static FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> convertProjects(NugetEnv nugetEnv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<PaketEnv, DomainMessage> createPaketEnv(DirectoryInfo rootDirectory, NugetEnv nugetEnv, CredsMigrationMode credsMirationMode);
    public static SolutionFile[] updateSolutions(DirectoryInfo rootDirectory);
    public static Result`2<ConvertResultR, DomainMessage> createResult(DirectoryInfo rootDirectory, NugetEnv nugetEnv, CredsMigrationMode credsMirationMode);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<ConvertResultR, DomainMessage> convertR(DirectoryInfo rootDirectory, bool force, FSharpOption`1<string> credsMigrationMode);
    internal static void remove@480-3(FileInfo fi);
    [CompilerGeneratedAttribute]
internal static void clo0@1-7(IEnumerable`1<DomainMessage> msgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool replaceNuGetWithPaket(bool initAutoRestore, bool installAfter, ConvertResultR result);
}
[CompilationMappingAttribute]
public static class Paket.NuGetLocal : object {
    public static NuGetRequestGetVersions getAllVersionsFromLocalPath(bool isCache, string localNugetPath, PackageName package, FSharpOption`1<string> alternativeProjectRoot, string root);
    internal static bool condition@42-1(PackageName packageName, SemVerInfo version, string x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo findLocalPackage(string directory, PackageName packageName, SemVerInfo version);
    public static string getPackageNameFromLocalFile(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<ODataSearchResult> getDetailsFromLocalNuGetPackage(bool isCache, FSharpOption`1<string> alternativeProjectRoot, string root, string localNuGetPath, PackageName packageName, SemVerInfo version);
}
[CompilationMappingAttribute]
public static class Paket.NuGetV2 : object {
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, bool> tryGetAllVersionsFromNugetODataWithFilterWarnings { get; }
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<XmlNode> func2@1-3(FSharpOption`1<XmlNode> node);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<XmlNode> func2@1-4(FSharpOption`1<XmlNode> node);
    internal static FSharpAsync`1<Tuple`2<bool, String[]>> followODataLinkSafe@24(AuthProvider auth, FSharpSet`1<string> knownVersions, string url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<String[]> followODataLink(AuthProvider auth, string url);
    internal static ConcurrentDictionary`2<string, bool> get_tryGetAllVersionsFromNugetODataWithFilterWarnings();
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<SafeWebResult`1<String[]>> catchHandler@1-15(Exception exn);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<SafeWebResult`1<String[]>> catchHandler@1-14(PackageName package, string nugetURL, AuthProvider auth, string url, Exception exn);
    public static NuGetRequestGetVersions tryGetAllVersionsFromNugetODataWithFilter(AuthProvider auth, string nugetURL, PackageName package);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<SafeWebResult`1<String[]>> catchHandler@1-16(Exception exn);
    public static NuGetRequestGetVersions tryGetAllVersionsFromNugetODataFindById(AuthProvider auth, string nugetURL, PackageName package);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<SafeWebResult`1<String[]>> catchHandler@1-17(Exception exn);
    public static NuGetRequestGetVersions tryGetAllVersionsFromNugetODataFindByIdNewestFirst(AuthProvider auth, string nugetURL, PackageName package);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static XmlDocument getXmlDoc(string url, string raw);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NuGetPackageCache handleODataEntry(string nugetURL, a packageName, b version, XmlNode entry);
    public static ODataSearchResult parseODataListDetails(string url, string nugetURL, PackageName packageName, SemVerInfo version, XmlNode doc);
    public static NuGetPackageCache parseODataEntryDetails(string url, string nugetURL, PackageName packageName, SemVerInfo version, XmlNode doc);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpChoice`2<ODataSearchResult, Exception>> catchHandler@1-18(Exception ex);
    internal static FSharpAsync`1<FSharpChoice`2<ODataSearchResult, Exception>> handleEntryUrl@340(NuGetSource nugetSource, PackageName packageName, SemVerInfo version, string url);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpChoice`2<ODataSearchResult, Exception>> catchHandler@1-19(Exception ex);
    internal static FSharpAsync`1<FSharpChoice`2<ODataSearchResult, Exception>> handleListUrl@354(NuGetSource nugetSource, PackageName packageName, SemVerInfo version, string url);
    internal static FSharpFunc`2<FSharpChoice`2<a, b>, bool> tryAgain@375();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<ODataSearchResult> getDetailsFromNuGetViaODataFast(bool isVersionAssumed, NuGetSource nugetSource, PackageName packageName, SemVerInfo version);
    internal static FSharpOption`1<string> getVersion@394(XmlNode n);
    public static ODataSearchResult parseFindPackagesByIDODataListDetails(a url, string nugetURL, PackageName packageName, SemVerInfo version, XmlNode doc);
    public static FSharpAsync`1<ODataSearchResult> parseFindPackagesByIDODataEntryDetails(string url, NuGetSource nugetSource, PackageName packageName, SemVerInfo version);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<ODataSearchResult> catchHandler@1-20(NuGetSource nugetSource, PackageName packageName, SemVerInfo version, Exception _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<ODataSearchResult> getDetailsFromNuGetViaOData(bool isVersionAssumed, NuGetSource nugetSource, PackageName packageName, SemVerInfo version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<ODataSearchResult> getDetailsFromNuGet(bool force, bool isVersionAssumed, NuGetSource nugetSource, PackageName packageName, SemVerInfo version);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpResult`2<String[], ExceptionDispatchInfo>> catchHandler@1-21(Exception e);
    public static FSharpAsync`1<FSharpResult`2<String[], ExceptionDispatchInfo>> FindPackages(AuthProvider auth, string nugetURL, string packageNamePrefix, a maxResults);
}
[CompilationMappingAttribute]
public static class Paket.NuGetV3 : object {
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<NuGetSource, Task`1<FSharpMap`2<NugetV3ResourceType, string>>> nugetV3Resources { get; }
    [CompilationMappingAttribute]
internal static Random rnd { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, Task`1<FSharpOption`1<string>>> searchDict { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<NuGetSource, PackageName>, FSharpAsync`1<FSharpOption`1<PackageIndex>>> getPackageIndexMemoized { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2<NuGetSource, string>, FSharpAsync`1<PackageIndexPage>> getPackageIndexPageMemoized { get; }
    internal static ConcurrentDictionary`2<NuGetSource, Task`1<FSharpMap`2<NugetV3ResourceType, string>>> get_nugetV3Resources();
    internal static Random get_rnd();
    internal static a pickRandom@121(FSharpList`1<a> urls);
    internal static Task`1<FSharpMap`2<NugetV3ResourceType, string>> getResourcesRaw@64(NuGetSource source, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<string> getNuGetV3Resource(NuGetSource source, NugetV3ResourceType resourceType);
    internal static ConcurrentDictionary`2<string, Task`1<FSharpOption`1<string>>> get_searchDict();
    public static FSharpOption`1<string> calculateNuGet3Path(string nugetUrl);
    public static FSharpOption`1<string> calculateNuGet2Path(string nugetUrl);
    public static Task`1<FSharpOption`1<string>> getSearchAPI(AuthProvider auth, string nugetUrl);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@214-22(NugetV3CatalogIndexItem this, NugetV3CatalogIndexItem obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@214-23(IComparer comp, NugetV3CatalogIndexItem this, NugetV3CatalogIndexItem objTemp, Unit unitVar);
    internal static string normalizeFileName@256(string name);
    internal static string getHostSpecificFileName(string fromUrl);
    internal static DirectoryInfo getCatalogPageDirectory(string basePath, string item);
    internal static FSharpOption`1<NugetV3CatalogPage> getPageFileContent(string pageFileName);
    internal static void setPageFileContent(string pageFileName, string responseData);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NugetV3CatalogPage getCatalogPage(AuthProvider auth, NugetV3CatalogIndexItem item, string basePath, CancellationToken cancel);
    internal static FSharpList`1<string> semVerOrder(FSharpList`1<string> versions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> semVerOrder2(a _arg1, FSharpList`1<string> versions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static NugetV3PackageCatalog getCatalogCursor(string basePath, string serviceUrl);
    public static NugetV3PackageCatalog catalogSemVer2ordered(NugetV3PackageCatalog catalog);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool setCatalogCursor(string basePath, NugetV3PackageCatalog catalog);
    public static String[] extractAutoCompleteVersions(string response);
    public static String[] extractVersions(string response);
    internal static FSharpAsync`1<SafeWebResult`1<String[]>> findAutoCompleteVersionsForPackage(string v3Url, AuthProvider auth, PackageName packageName, bool includingPrereleases, int maxResults);
    public static FSharpAsync`1<SafeWebResult`1<String[]>> FindAutoCompleteVersionsForPackage(string nugetURL, AuthProvider auth, PackageName package, bool includingPrereleases, int maxResults);
    internal static NuGetRequestGetVersions findVersionsForPackage(string v3Url, AuthProvider auth, PackageName packageName);
    public static NuGetRequestGetVersions FindVersionsForPackage(string nugetURL, AuthProvider auth, PackageName package);
    public static String[] extractPackages(string response);
    internal static FSharpAsync`1<FSharpResult`2<String[], ExceptionDispatchInfo>> getPackages(AuthProvider auth, string nugetURL, string packageNamePrefix, int maxResults);
    public static FSharpAsync`1<FSharpResult`2<String[], ExceptionDispatchInfo>> FindPackages(AuthProvider auth, string nugetURL, string packageNamePrefix, int maxResults);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@581-7(IEqualityComparer comp, PackageIndexPage this, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpOption`1<PackageIndex>> getPackageIndexRaw(NuGetSource source, PackageName packageName);
    internal static FSharpFunc`2<Tuple`2<NuGetSource, PackageName>, FSharpAsync`1<FSharpOption`1<PackageIndex>>> get_getPackageIndexMemoized();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<PackageIndex>> getPackageIndex(NuGetSource source, PackageName packageName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<PackageIndexPage> getPackageIndexPageRaw(NuGetSource source, string url);
    internal static FSharpFunc`2<Tuple`2<NuGetSource, string>, FSharpAsync`1<PackageIndexPage>> get_getPackageIndexPageMemoized();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<PackageIndexPage> getPackageIndexPage(NuGetSource source, PackageIndexPage page);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpOption`1<PackageIndexPackage>> catchHandler@1-12(PackageIndexPage page, Exception e);
    internal static FSharpAsync`1<FSharpOption`1<PackageIndexPackage>> tryFindOnPage@654(NuGetSource source, SemVerInfo version, SemVerInfo normalizedVersion, PackageIndexPage page);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<FSharpOption`1<PackageIndexPackage>> catchHandler@1-13(PackageIndex index, Exception e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpOption`1<PackageIndexPackage>> getRelevantPage(NuGetSource source, PackageIndex index, SemVerInfo version);
    internal static ParsedPlatformPath detect@723(PackageName packageName, SemVerInfo version, string x);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<ODataSearchResult> getPackageDetails$cont@718(NuGetSource source, PackageName packageName, SemVerInfo version, FSharpOption`1<PackageIndexPackage> relevantPage, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<ODataSearchResult> getPackageDetails(NuGetSource source, PackageName packageName, SemVerInfo version);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<ODataSearchResult> GetPackageDetails(bool force, NuGetSource source, PackageName packageName, SemVerInfo version);
}
[CompilationMappingAttribute]
internal static class Paket.NupkgWriter : object {
    internal static string nuspecId { get; }
    internal static string corePropsId { get; }
    internal static string contentTypePath { get; }
    [CompilationMappingAttribute]
internal static string corePropsPath { get; }
    internal static string relsPath { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_nuspecId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_corePropsId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_contentTypePath();
    internal static XElement defaultNode@23(XNamespace ns, a extension, b contentType);
    internal static string fType@35(FSharpMap`2<string, string> knownExtensions, string ext);
    internal static XDocument contentTypeDoc(IEnumerable`1<string> fileList);
    internal static void addChildNode@60(XNamespace ns, XElement parent, string name, a value);
    internal static void op_BangBangQmark@69(XNamespace ns, XElement metadataNode, string nodeName, FSharpOption`1<a> strOpt);
    internal static XElement buildFrameworkReferencesNode@74(XNamespace ns, string libName);
    internal static void buildFrameworkReferencesNode@80-1(XNamespace ns, XElement metadataNode, FSharpList`1<string> frameworkAssembliesList);
    internal static XElement buildDependencyNode@87(XNamespace ns, Tuple`2<a, VersionRequirement> tupledArg);
    internal static XElement buildGroupNode@97(XNamespace ns, FSharpOption`1<FrameworkIdentifier> framework, FSharpFunc`2<XElement, Unit> add);
    internal static FSharpList`1<Tuple`2<a, b>> aggregateDependencies@105(FSharpSet`1<a> excludedDependencies, FSharpList`1<Tuple`2<a, b>> dependencyList);
    internal static void buildDependencyNodes@109(XNamespace ns, FSharpTypeFunc buildDependencyNode, FSharpFunc`2<XElement, Unit> add, FSharpList`1<Tuple`2<a, VersionRequirement>> dependencies);
    internal static void buildDependencyNodesByGroup@113(XNamespace ns, FSharpTypeFunc buildDependencyNode, FSharpSet`1<PackageName> excludedDependencies, FSharpFunc`2<XElement, Unit> add, OptionalDependencyGroup dependencyGroup);
    internal static FSharpFunc`2<FSharpList`1<OptionalDependencyGroup>, Unit> buildDependenciesNode@120(XNamespace ns, XElement metadataNode, FSharpTypeFunc buildDependencyNode, FSharpSet`1<PackageName> excludedDependencies);
    internal static XElement buildReferenceNode@132(XNamespace ns, a fileName);
    internal static void buildReferencesNode@137(XNamespace ns, XElement metadataNode, FSharpList`1<a> referenceList);
    internal static XElement buildPackageTypesNode@144(XNamespace ns, a name);
    internal static void buildPackageTypesNode@149-1(XNamespace ns, XElement metadataNode, FSharpList`1<a> packageTypesList);
    internal static XDocument nuspecDoc(CompleteCoreInfo core, OptionalPackagingInfo optional);
    internal static string get_corePropsPath();
    internal static void op_BangBang@222(XElement root, XNamespace ns, string name, a value);
    internal static XDocument corePropsDoc(CompleteCoreInfo core);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_relsPath();
    internal static void r@243(XNamespace ns, XElement root, a type', b target, c id');
    internal static XDocument relsDoc(CompleteCoreInfo core);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void xDocWriter(XDocument xDoc, Stream stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<string, FSharpFunc`2<a, Unit>>> writeNupkg(CompleteCoreInfo core, OptionalPackagingInfo optional);
    internal static string fixRelativePath@275(string p);
    internal static bool isExcluded@299(string outputFolder, FSharpList`1<FSharpFunc`2<string, bool>> exclusions, string p);
    internal static string fakeEscapeProblemChars@315(FSharpList`1<Tuple`2<string, string>> problemChars, string source);
    internal static string unFakeEscapeProblemChars@320(FSharpList`1<Tuple`2<string, string>> problemChars, string source);
    internal static string escapeTarget@325(string target);
    internal static string ensureValidName@303(string target);
    internal static void addEntry@342(ZipArchive zipFile, List`1<string> entries, string path, FSharpFunc`2<Stream, Unit> writerF);
    internal static void addEntryFromFile@349(ZipArchive zipFile, List`1<string> entries, string path, string source);
    internal static string ensureValidTargetName@357(string target);
    internal static void addDir@367(string outputFolder, ZipArchive zipFile, List`1<string> entries, FSharpList`1<FSharpFunc`2<string, bool>> exclusions, string source, string target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string Write(CompleteCoreInfo core, OptionalPackagingInfo optional, string workingDir, string outputDir);
}
[CompilationMappingAttribute]
public class Paket.Nuspec : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal NuspecReferences References@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Lazy`1<FSharpList`1<Tuple`3<PackageName, VersionRequirement, FrameworkRestrictions>>> Dependencies@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string OfficialName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Version@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string LicenseUrl@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDevelopmentDependency@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FrameworkAssemblyReference> FrameworkAssemblyReferences@;
    [CompilationMappingAttribute]
public NuspecReferences References { get; }
    [CompilationMappingAttribute]
public Lazy`1<FSharpList`1<Tuple`3<PackageName, VersionRequirement, FrameworkRestrictions>>> Dependencies { get; }
    [CompilationMappingAttribute]
public string OfficialName { get; }
    [CompilationMappingAttribute]
public string Version { get; }
    [CompilationMappingAttribute]
public string LicenseUrl { get; }
    [CompilationMappingAttribute]
public bool IsDevelopmentDependency { get; }
    [CompilationMappingAttribute]
public FSharpList`1<FrameworkAssemblyReference> FrameworkAssemblyReferences { get; }
    public static Nuspec All { get; }
    [DynamicDependencyAttribute("1632", "Paket.Nuspec")]
public Nuspec(NuspecReferences references, Lazy`1<FSharpList`1<Tuple`3<PackageName, VersionRequirement, FrameworkRestrictions>>> dependencies, string officialName, string version, string licenseUrl, bool isDevelopmentDependency, FSharpList`1<FrameworkAssemblyReference> frameworkAssemblyReferences);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public NuspecReferences get_References();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Lazy`1<FSharpList`1<Tuple`3<PackageName, VersionRequirement, FrameworkRestrictions>>> get_Dependencies();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_OfficialName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_LicenseUrl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDevelopmentDependency();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FrameworkAssemblyReference> get_FrameworkAssemblyReferences();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static Nuspec get_All();
    public static Nuspec Explicit(FSharpList`1<string> references);
    internal static Nuspec Load(string fileName, XmlDocument doc);
    internal static Nuspec Load(string fileName, Stream f);
    internal static Nuspec Load(string fileName, string text);
    public static Nuspec Load(string fileName);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Nuspec obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Paket.NuspecExtensions : object {
    public static Tuple`2<string, XDocument> Nuspec.Create.Static(string Id, string templatePath, LockFile lockFile, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, SemVerInfo> packages);
    [CompilerGeneratedAttribute]
internal static Tuple`2<string, XDocument> FromProject$cont@428(DependenciesFile dependenciesFile, FSharpOption`1<ProjectFile> matchValue, Unit unitVar);
    public static Tuple`2<string, XDocument> Nuspec.FromProject.Static(string projectPath, DependenciesFile dependenciesFile);
}
[CompilationMappingAttribute]
internal static class Paket.NuSpecParserHelper : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<PackageName, VersionRequirement, ParsedPlatformPath>> getDependency(string fileName, XmlNode node);
    internal static FSharpList`1<FrameworkAssemblyReference> getAssemblyRefs(XmlNode node);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.NuspecReferences : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NuspecReferences _unique_All;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NuspecReferences All { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAll { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExplicit { get; }
    private static NuspecReferences();
    [CompilationMappingAttribute]
public static NuspecReferences get_All();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAll();
    [CompilationMappingAttribute]
public static NuspecReferences NewExplicit(FSharpList`1<string> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExplicit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NuspecReferences obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NuspecReferences obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.OptionalDependencyGroup : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FrameworkIdentifier> Framework@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<PackageName, VersionRequirement>> Dependencies@;
    [CompilationMappingAttribute]
public FSharpOption`1<FrameworkIdentifier> Framework { get; }
    [CompilationMappingAttribute]
public FSharpList`1<Tuple`2<PackageName, VersionRequirement>> Dependencies { get; }
    public static OptionalDependencyGroup ForNone { get; }
    [DynamicDependencyAttribute("1632", "Paket.OptionalDependencyGroup")]
public OptionalDependencyGroup(FSharpOption`1<FrameworkIdentifier> framework, FSharpList`1<Tuple`2<PackageName, VersionRequirement>> dependencies);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<FrameworkIdentifier> get_Framework();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Tuple`2<PackageName, VersionRequirement>> get_Dependencies();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OptionalDependencyGroup obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static OptionalDependencyGroup get_ForNone();
    public static OptionalDependencyGroup ForFramework(FSharpOption`1<FrameworkIdentifier> framework);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OptionalDependencyGroup For(FSharpOption`1<FrameworkIdentifier> framework, FSharpList`1<Tuple`2<PackageName, VersionRequirement>> dependencies);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OptionalDependencyGroup obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.OptionalPackagingInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Title@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Owners@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ReleaseNotes@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Summary@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Readme@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Language@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ProjectUrl@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> IconUrl@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> LicenseExpression@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> LicenseUrl@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> RepositoryUrl@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> RepositoryType@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> RepositoryBranch@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> RepositoryCommit@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Copyright@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool RequireLicenseAcceptance@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> Tags@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool DevelopmentDependency@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<OptionalDependencyGroup> DependencyGroups@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<PackageName> ExcludedDependencies@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<GroupName> ExcludedGroups@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> References@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> FrameworkAssemblyReferences@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<string, string>> Files@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> FilesExcluded@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> PackageTypes@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IncludePdbs@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IncludeReferencedProjects@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<InterprojectReferencesConstraint> InterprojectReferencesConstraint@;
    [CompilationMappingAttribute]
public FSharpOption`1<string> Title { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> Owners { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> ReleaseNotes { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> Summary { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> Readme { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> Language { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> ProjectUrl { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> IconUrl { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> LicenseExpression { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> LicenseUrl { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> RepositoryUrl { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> RepositoryType { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> RepositoryBranch { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> RepositoryCommit { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> Copyright { get; }
    [CompilationMappingAttribute]
public bool RequireLicenseAcceptance { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> Tags { get; }
    [CompilationMappingAttribute]
public bool DevelopmentDependency { get; }
    [CompilationMappingAttribute]
public FSharpList`1<OptionalDependencyGroup> DependencyGroups { get; }
    [CompilationMappingAttribute]
public FSharpSet`1<PackageName> ExcludedDependencies { get; }
    [CompilationMappingAttribute]
public FSharpSet`1<GroupName> ExcludedGroups { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> References { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> FrameworkAssemblyReferences { get; }
    [CompilationMappingAttribute]
public FSharpList`1<Tuple`2<string, string>> Files { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> FilesExcluded { get; }
    [CompilationMappingAttribute]
public FSharpList`1<string> PackageTypes { get; }
    [CompilationMappingAttribute]
public bool IncludePdbs { get; }
    [CompilationMappingAttribute]
public bool IncludeReferencedProjects { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<InterprojectReferencesConstraint> InterprojectReferencesConstraint { get; }
    public static OptionalPackagingInfo Empty { get; }
    [DynamicDependencyAttribute("1632", "Paket.OptionalPackagingInfo")]
public OptionalPackagingInfo(FSharpOption`1<string> title, FSharpList`1<string> owners, FSharpOption`1<string> releaseNotes, FSharpOption`1<string> summary, FSharpOption`1<string> readme, FSharpOption`1<string> language, FSharpOption`1<string> projectUrl, FSharpOption`1<string> iconUrl, FSharpOption`1<string> licenseExpression, FSharpOption`1<string> licenseUrl, FSharpOption`1<string> repositoryUrl, FSharpOption`1<string> repositoryType, FSharpOption`1<string> repositoryBranch, FSharpOption`1<string> repositoryCommit, FSharpOption`1<string> copyright, bool requireLicenseAcceptance, FSharpList`1<string> tags, bool developmentDependency, FSharpList`1<OptionalDependencyGroup> dependencyGroups, FSharpSet`1<PackageName> excludedDependencies, FSharpSet`1<GroupName> excludedGroups, FSharpList`1<string> references, FSharpList`1<string> frameworkAssemblyReferences, FSharpList`1<Tuple`2<string, string>> files, FSharpList`1<string> filesExcluded, FSharpList`1<string> packageTypes, bool includePdbs, bool includeReferencedProjects, FSharpOption`1<InterprojectReferencesConstraint> interprojectReferencesConstraint);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Title();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_ReleaseNotes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Summary();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Readme();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Language();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_ProjectUrl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_IconUrl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_LicenseExpression();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_LicenseUrl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_RepositoryUrl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_RepositoryType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_RepositoryBranch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_RepositoryCommit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Copyright();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_Tags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<OptionalDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<PackageName> get_ExcludedDependencies();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<GroupName> get_ExcludedGroups();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_References();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_FrameworkAssemblyReferences();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Tuple`2<string, string>> get_Files();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_FilesExcluded();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_PackageTypes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IncludePdbs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IncludeReferencedProjects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<InterprojectReferencesConstraint> get_InterprojectReferencesConstraint();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OptionalPackagingInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static OptionalPackagingInfo get_Empty();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OptionalPackagingInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.OverriddenPackage : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal PackageName Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal GroupName Group@;
    [CompilationMappingAttribute]
public PackageName Name { get; }
    [CompilationMappingAttribute]
public GroupName Group { get; }
    [DynamicDependencyAttribute("1632", "Paket.OverriddenPackage")]
public OverriddenPackage(PackageName name, GroupName group);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PackageName get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public GroupName get_Group();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OverriddenPackage obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OverriddenPackage obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.PackageInstallSettings : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal PackageName Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal InstallSettings Settings@;
    [CompilationMappingAttribute]
public PackageName Name { get; }
    [CompilationMappingAttribute]
public InstallSettings Settings { get; }
    public bool HasPackageSettings { get; }
    [DynamicDependencyAttribute("1632", "Paket.PackageInstallSettings")]
public PackageInstallSettings(PackageName name, InstallSettings settings);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PackageName get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public InstallSettings get_Settings();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PackageInstallSettings obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static PackageInstallSettings Default(string name);
    public bool get_HasPackageSettings();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PackageInstallSettings obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.PackageLoadScript : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Path@;
    [CompilationMappingAttribute]
public string Path { get; }
    [DynamicDependencyAttribute("1632", "Paket.PackageLoadScript")]
public PackageLoadScript(string path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PackageLoadScript obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static PackageLoadScript FromFile(FileInfo file);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PackageLoadScript obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
internal static class Paket.PackageMetaData : object {
    internal static FSharpChoice`2<Tuple`2<CompleteCoreInfo, OptionalPackagingInfo>, Unit> |CompleteTemplate|IncompleteTemplate|(TemplateFile templateFile);
    internal static FSharpChoice`6<string, string, SemVerInfo, SemVerInfo, string, Unit> |Title|Description|Version|InformationalVersion|Company|Ignore|(string attributeName, string attributeValue);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ProjectCoreInfo getId(Assembly assembly, ProjectCoreInfo md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<SemVerInfo> getVersion(FSharpOption`1<a> versionFromAssembly, IEnumerable`1<Tuple`2<string, string>> attributes);
    internal static FSharpOption`1<FSharpList`1<string>> getAuthors(IEnumerable`1<Tuple`2<string, string>> attributes);
    internal static FSharpOption`1<string> getTitle(IEnumerable`1<Tuple`2<string, string>> attributes);
    internal static FSharpOption`1<string> getDescription(IEnumerable`1<Tuple`2<string, string>> attributes);
    internal static Tuple`4<ILModuleReader, string, FSharpOption`1<Version>, string> readAssembly(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<ILModuleReader, string, FSharpOption`1<Version>, string> readAssemblyFromProjFile(string buildConfig, string buildPlatform, ProjectFile projectFile);
    internal static FSharpList`1<Tuple`2<ILType, object>> getMetaData@87(ILModuleReader assemblyReader, ILCustomAttr inp);
    internal static FSharpList`1<Tuple`2<string, string>> loadAssemblyAttributes(ILModuleReader assemblyReader);
    internal static FSharpChoice`2<CompleteCoreInfo, Unit> |Valid|Invalid|(ProjectCoreInfo md);
    internal static bool isCompatibleWith@116(FrameworkRestrictions fwRestriction, FSharpOption`1<FrameworkIdentifier> fwOption);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<OptionalDependencyGroup> addDependencyToFrameworkGroup(FSharpOption`1<FrameworkIdentifier> framework, FSharpList`1<OptionalDependencyGroup> dependencyGroups, PackageName pkgName, VersionRequirement version, FrameworkRestrictions fwRestriction);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile addDependency(TemplateFile templateFile, PackageName packageName, VersionRequirement dependency_1, FrameworkRestrictions dependency_2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile excludeDependency(TemplateFile templateFile, PackageName exclude);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string toFileWithOutputDirectory(ProjectFile p, string outputDirectory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string toFile(string config, string platform, ProjectFile p, FSharpOption`1<TargetProfile> targetProfile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile addFile(string source, string target, TemplateFile templateFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TargetProfile> findBestDependencyTargetProfile(FSharpList`1<TargetProfile> dependencyTargetProfiles, FSharpOption`1<TargetProfile> targetProfile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getTargetDir(ProjectFile project, FSharpOption`1<a> targetProfile);
    internal static PreReleaseStatus getPreReleaseStatus@242(SemVerInfo v);
    [CompilerGeneratedAttribute]
internal static bool func1@1-58(FSharpSet`1<string> existedSatelliteLanguages, string value);
    [CompilerGeneratedAttribute]
internal static void action@1-12(string lang);
    internal static FSharpList`1<Tuple`3<FSharpOption`1<GroupName>, PackageInstallSettings, FSharpOption`1<a>>> getPackages@389-12(ProjectFile proj);
    internal static bool isDependencyOfAnyOtherDependency@422(LockFile lockFile, FSharpList`1<Tuple`3<FSharpOption`1<GroupName>, PackageInstallSettings, FSharpOption`1<VersionRequirement>>> distinctRefs, PackageName packageName);
    [CompilerGeneratedAttribute]
internal static Tuple`3<PackageInstallSettings, VersionRequirement, FrameworkRestrictions> deps$cont@471(bool minimumFromLockFile, FSharpOption`1<SemVerInfo> version, InterprojectReferencesConstraint interprojectReferencesConstraint, LockFile lockFile, PackageInstallSettings np, VersionRequirement specificVersionRequirement, FrameworkRestrictions noFrameworkRestriction, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<VersionRequirement, FrameworkRestrictions>> dependencyVersionRequirement$cont@512-1(DependenciesFile dependenciesFile, bool minimumFromLockFile, LockFile lockFile, PackageInstallSettings np, PackageRequirement requirement, FSharpOption`1<ResolvedPackage> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<VersionRequirement, FrameworkRestrictions>> dependencyVersionRequirement$cont@503(DependenciesFile dependenciesFile, bool minimumFromLockFile, LockFile lockFile, PackageInstallSettings np, GroupName groupName, FSharpOption`1<DependenciesGroup> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile findDependencies(DependenciesFile dependenciesFile, string config, string platform, TemplateFile template, ProjectFile project, bool lockDependencies, bool minimumFromLockFile, bool pinProjectReferences, FSharpOption`1<InterprojectReferencesConstraint> interprojectReferencesConstraint, FSharpMap`2<string, Tuple`3<Lazy`1<TemplateFile>, ProjectFile, bool>> projectWithTemplates, bool includeReferencedProjects, FSharpOption`1<SemVerInfo> version, PackProcessCache cache);
}
[CompilationMappingAttribute]
public static class Paket.PackageProcess : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> tryGenerateDescription(FSharpOption`1<string> packageId, ProjectOutputType outputType);
    internal static FSharpOption`1<string> tryGenerateDescription@51-2(FSharpOption`1<string> packageId, ProjectOutputType outputType);
    internal static FSharpFunc`2<FSharpOption`1<a>, FSharpOption`1<a>> execIfNone@57(FSharpFunc`2<Unit, FSharpOption`1<a>> f);
    [CompilerGeneratedAttribute]
internal static TemplateFile merge$cont@45-1(FSharpMap`2<string, SemVerInfo> specificVersions, ProjectFile projectFile, TemplateFile templateFile, FSharpOption`1<Version> versionFromAssembly, FSharpList`1<Tuple`2<string, string>> attribs, OptionalPackagingInfo mergedOpt, ProjectCoreInfo md, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static TemplateFile merge$cont@29(string buildConfig, string buildPlatform, FSharpMap`2<string, SemVerInfo> specificVersions, ProjectFile projectFile, TemplateFile templateFile, TemplateFile withVersion, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile merge(string buildConfig, string buildPlatform, FSharpOption`1<SemVerInfo> versionFromAssembly, FSharpMap`2<string, SemVerInfo> specificVersions, ProjectFile projectFile, TemplateFile templateFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile convertToNormal(bool symbols, TemplateFile templateFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile convertToSymbols(ProjectFile projectFile, bool includeReferencedProjects, PackProcessCache cache, TemplateFile templateFile);
    [CompilerGeneratedAttribute]
internal static void clo0@1-8(IEnumerable`1<DomainMessage> msgs);
    [CompilerGeneratedAttribute]
internal static bool willBePacked$cont@178(FSharpOption`1<string> templateFile, TemplateFile templateFile', Unit unitVar);
    internal static Tuple`2<string, Tuple`3<Lazy`1<TemplateFile>, ProjectFile, bool>> mapping@1(FSharpOption`1<string> templateFile, string buildConfig, string buildPlatform, FSharpOption`1<SemVerInfo> version, FSharpMap`2<string, SemVerInfo> specificVersions, HashSet`1<string> allTemplateFiles, ProjectFile projectFile, TemplateFile templateFile');
    internal static IEnumerable`1<TemplateFile> optWithSymbols@186(bool symbols, bool includeReferencedProjects, ProjectFile projectFile, TemplateFile templateFile);
    public static void Pack(string workingDir, DependenciesFile dependenciesFile, string packageOutputPath, FSharpOption`1<string> buildConfig, FSharpOption`1<string> buildPlatform, FSharpOption`1<string> version, IEnumerable`1<Tuple`2<string, string>> specificVersions, FSharpOption`1<string> releaseNotes, FSharpOption`1<string> templateFile, FSharpOption`1<a> excludedTemplates, bool lockDependencies, bool minimumFromLockFile, bool pinProjectReferences, FSharpOption`1<InterprojectReferencesConstraint> interprojectReferencesConstraint, bool symbols, bool includeReferencedProjects, FSharpOption`1<string> projectUrl);
}
[CompilationMappingAttribute]
public static class Paket.PackageResolver : object {
    public static int RequestTimeout { get; }
    public static int WorkerCount { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@20-12(PackageDetails this, PackageDetails obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@20-13(IComparer comp, PackageDetails this, PackageDetails objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-15(ResolvedPackage this, ResolvedPackage obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-14(ResolvedPackage this, ResolvedPackage obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-17(IComparer comp, ResolvedPackage this, ResolvedPackage objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@59-16(IComparer comp, ResolvedPackage this, ResolvedPackage objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@59-5(IEqualityComparer comp, ResolvedPackage this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@59-9(ResolvedPackage this, ResolvedPackage that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@96-18(ResolverStep this, ResolverStep obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@96-19(IComparer comp, ResolverStep this, ResolverStep objTemp, Unit unitVar);
    public static FSharpMap`2<PackageName, ResolvedPackage> cleanupNames(FSharpMap`2<PackageName, ResolvedPackage> model);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isIncludedIn(FSharpSet`1<PackageRequirement> set, PackageRequirement packageRequirement);
    public static FSharpSet`1<PackageRequirement> calcOpenRequirements(ResolvedPackage exploredPackage, FSharpSet`1<PackageName> lockedPackages, FrameworkRestrictions globalFrameworkRestrictions, VersionCache verCache, PackageRequirement currentRequirement, ResolverStep resolverStep);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ResolverStrategy getResolverStrategy(FSharpOption`1<ResolverStrategy> globalStrategyForDirectDependencies, FSharpOption`1<ResolverStrategy> globalStrategyForTransitives, IDictionary`2<PackageName, PackageRequirement> rootDependencies, FSharpSet`1<PackageRequirement> allRequirementsOfCurrentPackage, PackageRequirement currentRequirement);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResolvedPackage updateRestrictions(PackageConfig pkgConfig, ResolvedPackage package);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpResult`2<ResolvedPackage, ExceptionDispatchInfo> explorePackageConfig(FSharpFunc`2<GetPackageDetailsParameters, PackageDetails> getPackageDetailsBlock, PackageConfig pkgConfig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<StackPack, FSharpResult`2<Tuple`2<bool, ResolvedPackage>, ExceptionDispatchInfo>> getExploredPackage(PackageConfig pkgConfig, FSharpFunc`2<GetPackageDetailsParameters, PackageDetails> getPackageDetailsBlock, StackPack stackpack);
    internal static FSharpFunc`2<VersionCache, bool> isInRange@564(PackageRequirement currentRequirement, IDictionary`2<PackageName, PackageRequirement> rootDependencies, FSharpSet`1<PackageRequirement> allRequirementsOfCurrentPackage, FSharpFunc`2<PackageRequirement, PackageRequirement> mapF);
    internal static IEnumerable`1<VersionCache> getSingleVersion@576(PackageRequirement currentRequirement, SemVerInfo v);
    internal static PreReleaseStatus prereleaseStatus@615(PackageRequirement r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<IEnumerable`1<VersionCache>, bool, bool> getCompatibleVersions(ResolverStep currentStep, GroupName groupName, PackageRequirement currentRequirement, IDictionary`2<PackageName, PackageRequirement> rootDependencies, FSharpFunc`2<ResolverStrategy, FSharpFunc`2<GetPackageVersionsParameters, IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getVersionsF, bool globalOverride, FSharpOption`1<ResolverStrategy> globalStrategyForDirectDependencies, FSharpOption`1<ResolverStrategy> globalStrategyForTransitives);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HashSet`1<PackageRequirement> getConflicts(ResolverStep currentStep, PackageRequirement currentRequirement, HashSet`1<Tuple`2<FSharpSet`1<PackageRequirement>, FSharpOption`1<Tuple`2<FSharpList`1<VersionCache>, bool>>>> knownConflicts);
    internal static int boost@678(Dictionary`2<PackageName, int> conflictHistory, PackageRequirement d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PackageRequirement getCurrentRequirement(FSharpOption`1<PackageFilter> packageFilter, FSharpSet`1<PackageRequirement> openRequirements, Dictionary`2<PackageName, int> conflictHistory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<ConflictState, StackPack> boostConflicts(FSharpMap`2<PackageName, Tuple`2<FSharpList`1<VersionCache>, bool>> filteredVersions, PackageRequirement currentRequirement, StackPack stackpack, ConflictState conflictState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<Tuple`2<a, WorkPriority>> selectVersionsToPreload(VersionRequirement verReq, FSharpFunc`2<a, SemVerInfo> f, b versions);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_RequestTimeout();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_WorkerCount();
    internal static a getAndReport@1012(int taskTimeout, FSharpList`1<PackageSource> sources, BlockReason blockReason, ResolverTaskMemory`1<a> mem);
    internal static ResolverTaskMemory`1<PackageDetails> startRequestGetPackageDetails@1047(FSharpFunc`2<GetPackageDetailsParameters, FSharpAsync`1<PackageDetails>> getPackageDetailsRaw, ResolverRequestQueue workerQueue, ConcurrentDictionary`2<Tuple`3<FSharpList`1<PackageSource>, PackageName, SemVerInfo>, ResolverTaskMemory`1<PackageDetails>> startedGetPackageDetailsRequests, GetPackageDetailsParameters details);
    internal static ResolverTaskMemory`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>> startRequestGetVersions@1064(FSharpFunc`2<GetPackageVersionsParameters, FSharpAsync`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getVersionsRaw, ResolverRequestQueue workerQueue, ConcurrentDictionary`2<Tuple`2<FSharpList`1<PackageSource>, PackageName>, ResolverTaskMemory`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> startedGetVersionsRequests, GetPackageVersionsParameters versions);
    internal static IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>> getVersionsBlock@1073(FSharpFunc`2<GetPackageVersionsParameters, FSharpAsync`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getVersionsRaw, FSharpFunc`2<ResolverStrategy, FSharpFunc`2<GetPackageVersionsParameters, FSharpList`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getPreferredVersionsRaw, ResolverRequestQueue workerQueue, int taskTimeout, ConcurrentDictionary`2<Tuple`2<FSharpList`1<PackageSource>, PackageName>, ResolverTaskMemory`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> startedGetVersionsRequests, ResolverStrategy resolverStrategy, GetPackageVersionsParameters versionParams, ResolverStep currentStep);
    [CompilerGeneratedAttribute]
internal static bool fuseConflicts$cont@1120(StackPack stackpack, FSharpMap`2<PackageName, Tuple`2<FSharpList`1<VersionCache>, bool>> filteredVersions, FSharpSet`1<PackageRequirement> conflicts, Unit unitVar);
    internal static StepResult fuseConflicts@1119(StackPack stackpack, PackageRequirement currentRequirement, FSharpMap`2<PackageName, Tuple`2<FSharpList`1<VersionCache>, bool>> filteredVersions, ConflictState currentConflict, FSharpList`1<Tuple`5<ConflictState, ResolverStep, PackageRequirement, IEnumerable`1<VersionCache>, StepFlags>> priorConflictSteps);
    internal static ConflictState resolverTimeout@1133(TimeSpan loopTimeout, DateTime loopTime, ConflictState conflictState, ResolverStep currentStep);
    [CompilerGeneratedAttribute]
internal static StepResult step$cont@1151(StackPack stackpack, StepFlags flags, FSharpList`1<Tuple`5<ConflictState, ResolverStep, PackageRequirement, IEnumerable`1<VersionCache>, StepFlags>> priorConflictSteps, ResolverStep currentStep, ConflictState currentConflict, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool step$cont@1222-2(StackPack stackpack, FSharpMap`2<PackageName, Tuple`2<FSharpList`1<VersionCache>, bool>> filteredVersions, FSharpSet`1<PackageRequirement> conflicts, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<ConflictState, StackPack> step$cont@1222-1(StackPack stackpack, ResolverStep currentStep, PackageRequirement currentRequirement, ConflictState currentConflict, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static StepResult step$cont@1359-3(FrameworkRestrictions globalFrameworkRestrictions, FSharpSet`1<PackageName> lockedPackages, IEnumerable`1<VersionCache> compatibleVersions, FSharpList`1<Tuple`5<ConflictState, ResolverStep, PackageRequirement, IEnumerable`1<VersionCache>, StepFlags>> priorConflictSteps, ResolverStep currentStep, PackageRequirement currentRequirement, VersionCache versionToExplore, ConflictState currentConflict, StackPack stackpack, ResolvedPackage exploredPackage, StepFlags flags, Unit unitVar);
    internal static StepResult step@1131(UpdateMode updateMode, GroupName groupName, FSharpOption`1<ResolverStrategy> globalStrategyForTransitives, FSharpOption`1<ResolverStrategy> globalStrategyForDirectDependencies, FrameworkRestrictions globalFrameworkRestrictions, FSharpFunc`2<GetPackageVersionsParameters, FSharpAsync`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getVersionsRaw, FSharpFunc`2<ResolverStrategy, FSharpFunc`2<GetPackageVersionsParameters, FSharpList`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getPreferredVersionsRaw, FSharpFunc`2<GetPackageDetailsParameters, FSharpAsync`1<PackageDetails>> getPackageDetailsRaw, FSharpSet`1<PackageName> cliToolSettings, ResolverRequestQueue workerQueue, int taskTimeout, TimeSpan loopTimeout, ConcurrentDictionary`2<Tuple`3<FSharpList`1<PackageSource>, PackageName, SemVerInfo>, ResolverTaskMemory`1<PackageDetails>> startedGetPackageDetailsRequests, FSharpFunc`2<GetPackageDetailsParameters, PackageDetails> getPackageDetailsBlock, ConcurrentDictionary`2<Tuple`2<FSharpList`1<PackageSource>, PackageName>, ResolverTaskMemory`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> startedGetVersionsRequests, FSharpOption`1<PackageFilter> packageFilter, IDictionary`2<PackageName, PackageRequirement> rootDependenciesDict, FSharpSet`1<PackageName> lockedPackages, DateTime loopTime, Stage stage, StackPack stackpack, IEnumerable`1<VersionCache> compatibleVersions, StepFlags flags);
    internal static ConflictState tryStep@1446(UpdateMode updateMode, GroupName groupName, FSharpOption`1<ResolverStrategy> globalStrategyForTransitives, FSharpOption`1<ResolverStrategy> globalStrategyForDirectDependencies, FrameworkRestrictions globalFrameworkRestrictions, FSharpFunc`2<GetPackageVersionsParameters, FSharpAsync`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getVersionsRaw, FSharpFunc`2<ResolverStrategy, FSharpFunc`2<GetPackageVersionsParameters, FSharpList`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getPreferredVersionsRaw, FSharpFunc`2<GetPackageDetailsParameters, FSharpAsync`1<PackageDetails>> getPackageDetailsRaw, FSharpSet`1<PackageName> cliToolSettings, ResolverRequestQueue workerQueue, int taskTimeout, TimeSpan loopTimeout, ConcurrentDictionary`2<Tuple`3<FSharpList`1<PackageSource>, PackageName, SemVerInfo>, ResolverTaskMemory`1<PackageDetails>> startedGetPackageDetailsRequests, FSharpFunc`2<GetPackageDetailsParameters, PackageDetails> getPackageDetailsBlock, ConcurrentDictionary`2<Tuple`2<FSharpList`1<PackageSource>, PackageName>, ResolverTaskMemory`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> startedGetVersionsRequests, FSharpOption`1<PackageFilter> packageFilter, IDictionary`2<PackageName, PackageRequirement> rootDependenciesDict, FSharpSet`1<PackageName> lockedPackages, DateTime loopTime, StepResult result);
    public static Resolution Resolve(FSharpFunc`2<GetPackageVersionsParameters, FSharpAsync`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getVersionsRaw, FSharpFunc`2<ResolverStrategy, FSharpFunc`2<GetPackageVersionsParameters, FSharpList`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getPreferredVersionsRaw, FSharpFunc`2<GetPackageDetailsParameters, FSharpAsync`1<PackageDetails>> getPackageDetailsRaw, GroupName groupName, FSharpOption`1<ResolverStrategy> globalStrategyForDirectDependencies, FSharpOption`1<ResolverStrategy> globalStrategyForTransitives, FrameworkRestrictions globalFrameworkRestrictions, FSharpSet`1<PackageRequirement> rootDependencies, UpdateMode updateMode);
}
[CompilationMappingAttribute]
public static class Paket.PackagesConfigFile : object {
    public static FSharpList`1<NugetPackage> Read(string fileName);
    public static string Serialize(IEnumerable`1<NugetPackage> packages);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Save(string fileName, IEnumerable`1<NugetPackage> packages);
}
[CompilationMappingAttribute]
public static class Paket.PackageSources : object {
    [CompilationMappingAttribute]
internal static Regex envVarRegex { get; }
    [CompilationMappingAttribute]
public static Regex userNameRegex { get; }
    [CompilationMappingAttribute]
public static Regex passwordRegex { get; }
    [CompilationMappingAttribute]
public static Regex authTypeRegex { get; }
    [CompilationMappingAttribute]
public static PackageSource DefaultNuGetSource { get; }
    [CompilationMappingAttribute]
public static PackageSource DefaultNuGetV3Source { get; }
    internal static Regex get_envVarRegex();
    public static FSharpOption`1<string> tryParseWindowsStyleNetworkPath(string path);
    public static string RemoveOutsideQuotes(string path);
    public static bool urlSimilarToTfsOrVsts(string url);
    public static bool urlIsNugetGallery(string url);
    public static bool urlIsMyGet(string url);
    public static Regex get_userNameRegex();
    public static Regex get_passwordRegex();
    public static Regex get_authTypeRegex();
    internal static AuthProvider parseAuth(string text, string source);
    internal static void n@183(string url, AuthProvider auth);
    public static PackageSource get_DefaultNuGetSource();
    public static PackageSource get_DefaultNuGetV3Source();
}
[CompilationMappingAttribute]
public class Paket.PackProcessCache : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ConcurrentDictionary`2<string, FSharpList`1<ProjectFile>> ReferencesByProjectFilePath@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ConcurrentDictionary`2<string, FSharpOption`1<ProjectFile>> ProjectFileByPath@;
    [CompilationMappingAttribute]
public ConcurrentDictionary`2<string, FSharpList`1<ProjectFile>> ReferencesByProjectFilePath { get; }
    [CompilationMappingAttribute]
public ConcurrentDictionary`2<string, FSharpOption`1<ProjectFile>> ProjectFileByPath { get; }
    [DynamicDependencyAttribute("1632", "Paket.PackProcessCache")]
public PackProcessCache(ConcurrentDictionary`2<string, FSharpList`1<ProjectFile>> referencesByProjectFilePath, ConcurrentDictionary`2<string, FSharpOption`1<ProjectFile>> projectFileByPath);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ConcurrentDictionary`2<string, FSharpList`1<ProjectFile>> get_ReferencesByProjectFilePath();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ConcurrentDictionary`2<string, FSharpOption`1<ProjectFile>> get_ProjectFileByPath();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PackProcessCache obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.PackProcessCacheModule : object {
    [CompilationMappingAttribute]
public static PackProcessCache empty { get; }
    public static PackProcessCache get_empty();
}
[CompilationMappingAttribute]
public class Paket.PaketEnv : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal DirectoryInfo RootDirectory@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal DependenciesFile DependenciesFile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<LockFile> LockFile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> Projects@;
    [CompilationMappingAttribute]
public DirectoryInfo RootDirectory { get; }
    [CompilationMappingAttribute]
public DependenciesFile DependenciesFile { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<LockFile> LockFile { get; }
    [CompilationMappingAttribute]
public FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> Projects { get; }
    [DynamicDependencyAttribute("1632", "Paket.PaketEnv")]
public PaketEnv(DirectoryInfo rootDirectory, DependenciesFile dependenciesFile, FSharpOption`1<LockFile> lockFile, FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> projects);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DirectoryInfo get_RootDirectory();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DependenciesFile get_DependenciesFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<LockFile> get_LockFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> get_Projects();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PaketEnv obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Paket.PaketEnvModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static PaketEnv create(DirectoryInfo root, DependenciesFile dependenciesFile, FSharpOption`1<LockFile> lockFile, FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> projects);
    public static Result`2<PaketEnv, DomainMessage> fromRootDirectory(DirectoryInfo directory);
    public static FSharpOption`1<DirectoryInfo> locatePaketRootDirectory(DirectoryInfo directory);
    public static Result`2<DirectoryInfo, DomainMessage> ensureNotExists(DirectoryInfo directory);
    public static Result`2<PaketEnv, DomainMessage> ensureNotInStrictMode(PaketEnv environment);
    public static Result`2<LockFile, DomainMessage> ensureLockFileExists(PaketEnv environment);
    [CompilerGeneratedAttribute]
internal static string func1@1-56(PackageSource value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Unit, DomainMessage> initWithContent(FSharpList`1<PackageSource> sources, FSharpList`1<string> additional, DirectoryInfo directory);
    public static Result`2<Unit, DomainMessage> init(DirectoryInfo directory);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.PaketFiles : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJustDependencies { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDependenciesAndLock { get; }
    [CompilationMappingAttribute]
public static PaketFiles NewJustDependencies(DependenciesFile item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJustDependencies();
    [CompilationMappingAttribute]
public static PaketFiles NewDependenciesAndLock(DependenciesFile item1, LockFile item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDependenciesAndLock();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static PaketFiles LocateFromDirectory(DirectoryInfo directory);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PaketFiles obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.Platform : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Platform _unique_Arm;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Platform _unique_X64;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Platform _unique_Win32;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Platform _unique_NoPlatform;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Platform Arm { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArm { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Platform X64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsX64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Platform Win32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWin32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static Platform NoPlatform { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoPlatform { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknownPlatform { get; }
    public string AsString { get; }
    private static Platform();
    [DynamicDependencyAttribute("2016", "Paket.Platform")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Platform(int _tag);
    [CompilationMappingAttribute]
public static Platform get_Arm();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArm();
    [CompilationMappingAttribute]
public static Platform get_X64();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsX64();
    [CompilationMappingAttribute]
public static Platform get_Win32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWin32();
    [CompilationMappingAttribute]
public static Platform get_NoPlatform();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoPlatform();
    [CompilationMappingAttribute]
public static Platform NewUnknownPlatform(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknownPlatform();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Platform obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_AsString();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Platform obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.PlatformMatching : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int MaxPenalty;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int Penalty_Client;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int Penalty_VersionJump;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int Penalty_Netcore;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int Penalty_Portable;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int Penalty_UnsupportedProfile;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static int Penalty_Fallback;
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, FSharpOption`1<ParsedPlatformPath>> extractPlatformsPriv { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, FSharpOption`1<ParsedPlatformPath>> cache@54-7 { get; }
    [CompilationMappingAttribute]
internal static Lazy`1<FSharpFunc`2<Tuple`2<TargetProfile, TargetProfile>, int>> getPlatformPenalty@75 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Tuple`2<TargetProfile, TargetProfile>, int> getPlatformPenalty { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Tuple`2<ParsedPlatformPath, TargetProfile>, int> getPathPenalty { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Tuple`2<ParsedPlatformPath, TargetProfile>, int> cache@54-8 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Tuple`2<TargetProfile, FSharpSet`1<TargetProfile>>, FSharpSet`1<TargetProfile>> collectPlatforms { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Tuple`2<TargetProfile, FSharpSet`1<TargetProfile>>, FSharpSet`1<TargetProfile>> cache@54-9 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Tuple`2<TargetProfile, FSharpSet`1<TargetProfile>>, int> platformsSupport { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Tuple`2<TargetProfile, FSharpSet`1<TargetProfile>>, int> cache@54-10 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<Tuple`2<FSharpList`1<ParsedPlatformPath>, TargetProfile>, FSharpOption`1<ParsedPlatformPath>> findBestMatch { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<Tuple`2<FSharpList`1<ParsedPlatformPath>, TargetProfile>, FSharpOption`1<ParsedPlatformPath>> cache@54-11 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<FSharpList`1<ParsedPlatformPath>, FSharpMap`2<ParsedPlatformPath, FSharpSet`1<TargetProfile>>> getSupportedTargetProfiles { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<FSharpList`1<ParsedPlatformPath>, FSharpMap`2<ParsedPlatformPath, FSharpSet`1<TargetProfile>>> cache@54-12 { get; }
    private static PlatformMatching();
    public static String[] split(string path);
    internal static FSharpFunc`2<string, FSharpOption`1<ParsedPlatformPath>> get_extractPlatformsPriv();
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ParsedPlatformPath> f@63-5(string path);
    internal static ConcurrentDictionary`2<string, FSharpOption`1<ParsedPlatformPath>> get_cache@54-7();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<ParsedPlatformPath> extractPlatforms(bool warn, string path);
    public static ParsedPlatformPath forceExtractPlatforms(string path);
    [CompilerGeneratedAttribute]
internal static int getPlatformPenalty$cont@92(TargetProfile targetPlatform, TargetProfile packagePlatform, Unit unitVar);
    internal static int f@63-6(TargetProfile targetPlatform, TargetProfile packagePlatform);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Tuple`2<TargetProfile, TargetProfile>, int> getPlatformPenalty@75-1();
    internal static Lazy`1<FSharpFunc`2<Tuple`2<TargetProfile, TargetProfile>, int>> get_getPlatformPenalty@75();
    public static FSharpFunc`2<Tuple`2<TargetProfile, TargetProfile>, int> get_getPlatformPenalty();
    public static int getFrameworkPenalty(FrameworkIdentifier fr1, FrameworkIdentifier fr2);
    public static FSharpFunc`2<Tuple`2<ParsedPlatformPath, TargetProfile>, int> get_getPathPenalty();
    internal static int handleEmpty@115(TargetProfile platform, Unit unitVar0);
    internal static int f@63-7(ParsedPlatformPath path, TargetProfile platform);
    internal static ConcurrentDictionary`2<Tuple`2<ParsedPlatformPath, TargetProfile>, int> get_cache@54-8();
    [ObsoleteAttribute("Used in test code, use getPathPenalty instead.")]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int getFrameworkPathPenalty(FSharpList`1<FrameworkIdentifier> fr, ParsedPlatformPath path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int comparePaths(ParsedPlatformPath p1_0, int p1_1, ParsedPlatformPath p2_0, int p2_1);
    public static FSharpFunc`2<Tuple`2<TargetProfile, FSharpSet`1<TargetProfile>>, FSharpSet`1<TargetProfile>> get_collectPlatforms();
    internal static FSharpSet`1<TargetProfile> loop@164-6(FSharpList`1<TargetProfile> acc, TargetProfile framework, FSharpSet`1<TargetProfile> profls);
    internal static ConcurrentDictionary`2<Tuple`2<TargetProfile, FSharpSet`1<TargetProfile>>, FSharpSet`1<TargetProfile>> get_cache@54-9();
    public static FSharpFunc`2<Tuple`2<TargetProfile, FSharpSet`1<TargetProfile>>, int> get_platformsSupport();
    internal static int platformsSupport@174(TargetProfile platform, FSharpSet`1<TargetProfile> platforms);
    internal static ConcurrentDictionary`2<Tuple`2<TargetProfile, FSharpSet`1<TargetProfile>>, int> get_cache@54-10();
    public static FSharpFunc`2<Tuple`2<FSharpList`1<ParsedPlatformPath>, TargetProfile>, FSharpOption`1<ParsedPlatformPath>> get_findBestMatch();
    internal static FSharpOption`1<ParsedPlatformPath> findBestMatch@187(FSharpList`1<ParsedPlatformPath> paths, TargetProfile targetProfile);
    internal static ConcurrentDictionary`2<Tuple`2<FSharpList`1<ParsedPlatformPath>, TargetProfile>, FSharpOption`1<ParsedPlatformPath>> get_cache@54-11();
    public static FSharpFunc`2<FSharpList`1<ParsedPlatformPath>, FSharpMap`2<ParsedPlatformPath, FSharpSet`1<TargetProfile>>> get_getSupportedTargetProfiles();
    [CompilerGeneratedAttribute]
internal static FSharpMap`2<ParsedPlatformPath, FSharpSet`1<TargetProfile>> f@63-8(FSharpList`1<ParsedPlatformPath> paths);
    internal static ConcurrentDictionary`2<FSharpList`1<ParsedPlatformPath>, FSharpMap`2<ParsedPlatformPath, FSharpSet`1<TargetProfile>>> get_cache@54-12();
    [CompilerGeneratedAttribute]
internal static Tuple`2<string, string> getTargetCondition$cont@215(FrameworkIdentifier platform, Unit unitVar);
    public static Tuple`2<string, string> getTargetCondition(TargetProfile target);
    [CompilerGeneratedAttribute]
internal static bool matchF@276(TargetProfile _arg1);
    [CompilerGeneratedAttribute]
internal static bool filterRestF@266(TargetProfile _arg3);
    [CompilerGeneratedAttribute]
internal static bool matchF@276-1(TargetProfile _arg4);
    [CompilerGeneratedAttribute]
internal static bool matchF@276-2(TargetProfile _arg5);
    [CompilerGeneratedAttribute]
internal static bool matchF@276-3(TargetProfile _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getCondition(FSharpOption`1<string> referenceCondition, FSharpSet`1<TargetProfile> targets);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.PortableProfileType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile2;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile4;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile5;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile6;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile7;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile14;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile18;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile19;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile23;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile24;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile31;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile32;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile36;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile37;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile41;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile42;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile44;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile46;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile47;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile49;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile78;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile84;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile88;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile92;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile95;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile96;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile102;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile104;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile111;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile136;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile143;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile147;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile151;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile154;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile157;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile158;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile225;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile240;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile255;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile259;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile328;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile336;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PortableProfileType _unique_Profile344;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnsupportedProfile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile2 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile6 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile14 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile14 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile18 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile18 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile19 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile19 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile23 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile23 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile24 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile24 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile31 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile31 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile36 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile36 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile37 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile37 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile41 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile41 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile42 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile42 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile44 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile44 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile46 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile46 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile47 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile47 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile49 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile49 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile78 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile78 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile84 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile84 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile88 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile88 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile92 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile92 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile95 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile95 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile96 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile96 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile102 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile102 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile104 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile104 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile111 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile111 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile136 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile136 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile143 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile143 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile147 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile147 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile151 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile151 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile154 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile154 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile157 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile157 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile158 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile158 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile225 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile225 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile240 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile240 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile255 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile255 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile259 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile259 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile328 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile328 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile336 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile336 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PortableProfileType Profile344 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProfile344 { get; }
    public bool IsUnsupprted { get; }
    public string ProfileName { get; }
    public FSharpList`1<FrameworkIdentifier> Frameworks { get; }
    public string FolderName { get; }
    private static PortableProfileType();
    [DynamicDependencyAttribute("2016", "Paket.PortableProfileType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PortableProfileType(int _tag);
    [CompilationMappingAttribute]
public static PortableProfileType NewUnsupportedProfile(FSharpList`1<FrameworkIdentifier> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnsupportedProfile();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile2();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile3();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile4();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile5();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile6();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile7();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile7();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile14();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile14();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile18();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile18();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile19();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile19();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile23();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile23();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile24();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile24();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile31();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile31();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile32();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile36();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile36();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile37();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile37();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile41();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile41();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile42();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile42();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile44();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile44();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile46();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile46();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile47();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile47();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile49();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile49();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile78();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile78();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile84();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile84();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile88();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile88();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile92();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile92();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile95();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile95();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile96();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile96();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile102();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile102();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile104();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile104();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile111();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile111();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile136();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile136();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile143();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile143();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile147();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile147();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile151();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile151();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile154();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile154();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile157();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile157();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile158();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile158();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile225();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile225();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile240();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile240();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile255();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile255();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile259();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile259();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile328();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile328();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile336();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile336();
    [CompilationMappingAttribute]
public static PortableProfileType get_Profile344();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProfile344();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PortableProfileType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_IsUnsupprted();
    public string get_ProfileName();
    public FSharpList`1<FrameworkIdentifier> get_Frameworks();
    public string get_FolderName();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PortableProfileType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[CompilationMappingAttribute]
public class Paket.PreRelease : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Origin@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<PreReleaseSegment> Values@;
    [CompilationMappingAttribute]
public string Origin { get; }
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public FSharpList`1<PreReleaseSegment> Values { get; }
    [DynamicDependencyAttribute("1632", "Paket.PreRelease")]
public PreRelease(string origin, string name, FSharpList`1<PreReleaseSegment> values);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Origin();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<PreReleaseSegment> get_Values();
    public static FSharpOption`1<PreRelease> TryParse(string str);
    public bool Equals(PreRelease y);
    public virtual bool Equals(object yobj);
    public virtual string ToString();
    public virtual int GetHashCode();
    public int CompareTo(PreRelease yobj);
    private virtual override int System.IComparable.CompareTo(object yobj);
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.PreReleaseSegment : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAlphaNumeric { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNumeric { get; }
    [CompilationMappingAttribute]
public static PreReleaseSegment NewAlphaNumeric(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAlphaNumeric();
    [CompilationMappingAttribute]
public static PreReleaseSegment NewNumeric(BigInteger item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNumeric();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public int CompareTo(PreReleaseSegment y);
    public virtual int GetHashCode();
    public bool Equals(PreReleaseSegment y);
    public virtual bool Equals(object yobj);
    private virtual override int System.IComparable.CompareTo(object yobj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.PreReleaseStatus : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PreReleaseStatus _unique_No;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PreReleaseStatus _unique_All;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PreReleaseStatus No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PreReleaseStatus All { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAll { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConcrete { get; }
    private static PreReleaseStatus();
    [CompilationMappingAttribute]
public static PreReleaseStatus get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNo();
    [CompilationMappingAttribute]
public static PreReleaseStatus get_All();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAll();
    [CompilationMappingAttribute]
public static PreReleaseStatus NewConcrete(FSharpList`1<string> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConcrete();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PreReleaseStatus obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PreReleaseStatus obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.ProcessHelper : object {
    [CompilationMappingAttribute]
public static string monoArguments { get; public set; }
    [CompilationMappingAttribute]
public static IEnumerable`1<string> pathDirectories { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<string> arg@1-2 { get; }
    [CompilationMappingAttribute]
internal static HashSet`1<Tuple`2<int, DateTime>> startedProcesses { get; }
    public static string get_monoArguments();
    public static void set_monoArguments(string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindFile(IEnumerable`1<string> dirs, string file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findFile(IEnumerable`1<string> dirs, string file);
    public static FSharpOption`1<string> environVarOrNone(string name);
    public static FSharpList`1<string> splitEnvironVar(string name);
    public static bool isValidPath(string path);
    public static IEnumerable`1<string> get_pathDirectories();
    internal static FSharpList`1<string> get_arg@1-2();
    public static FSharpOption`1<string> tryFindFileOnPath(string file);
    public static void platformInfoAction(ProcessStartInfo psi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] appSettings(string key, string fallbackValue);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> tryFindPath(string settingsName, string fallbackValue, string tool);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string findPath(string settingsName, string fallbackValue, string tool);
    internal static HashSet`1<Tuple`2<int, DateTime>> get_startedProcesses();
    public static void start(Process proc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int ExecProcessWithLambdas(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut, bool silent, FSharpFunc`2<string, Unit> errorF, FSharpFunc`2<string, Unit> messageF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProcessResult ExecProcessAndReturnMessages(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF, TimeSpan timeOut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string separated(string delimiter, IEnumerable`1<string> items);
    public static string toLines(IEnumerable`1<string> text);
    public static void fireAndForget(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF);
    public static bool directExec(FSharpFunc`2<ProcessStartInfo, Unit> configProcessStartInfoF);
}
[CompilationMappingAttribute]
public static class Paket.Profile : object {
    [CompilationMappingAttribute]
public static ConcurrentBag`1<Event> events { get; }
    internal static FSharpOption`1<Tuple`2<TimeSpan, Tuple`2<int, EventBoundary[]>>> getNextSpan(int startIndex, EventBoundary[] boundaries);
    public static TimeSpan[] getCoalescedEventTimeSpans(EventBoundary[] boundaries);
    public static ConcurrentBag`1<Event> get_events();
    public static void trackEvent(Category cat);
    public static IDisposable startCategory(Category cat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a startCategoryF(Category cat, FSharpFunc`2<Unit, a> f);
}
[CompilationMappingAttribute]
public class Paket.ProjectCoreInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Id@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<SemVerInfo> Version@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<string>> Authors@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Description@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool Symbols@;
    [CompilationMappingAttribute]
public FSharpOption`1<string> Id { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<SemVerInfo> Version { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<FSharpList`1<string>> Authors { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> Description { get; }
    [CompilationMappingAttribute]
public bool Symbols { get; }
    public static ProjectCoreInfo Empty { get; }
    [DynamicDependencyAttribute("1632", "Paket.ProjectCoreInfo")]
public ProjectCoreInfo(FSharpOption`1<string> id, FSharpOption`1<SemVerInfo> version, FSharpOption`1<FSharpList`1<string>> authors, FSharpOption`1<string> description, bool symbols);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Id();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SemVerInfo> get_Version();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<FSharpList`1<string>> get_Authors();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Description();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_Symbols();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ProjectCoreInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static ProjectCoreInfo get_Empty();
    public CompleteCoreInfo ToCoreInfo(string Id);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProjectCoreInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.ProjectFile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FileName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string OriginalText@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal XmlDocument Document@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal XmlNode ProjectNode@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ProjectLanguage Language@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
public FSharpOption`1<FSharpMap`2<string, string>> DefaultProperties@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
public ConcurrentDictionary`2<FSharpMap`2<string, string>, FSharpMap`2<string, string>> CalculatedProperties@;
    [CompilationMappingAttribute]
public string FileName { get; }
    [CompilationMappingAttribute]
public string OriginalText { get; }
    [CompilationMappingAttribute]
public XmlDocument Document { get; }
    [CompilationMappingAttribute]
public XmlNode ProjectNode { get; }
    [CompilationMappingAttribute]
public ProjectLanguage Language { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<FSharpMap`2<string, string>> DefaultProperties { get; public set; }
    [CompilationMappingAttribute]
public ConcurrentDictionary`2<FSharpMap`2<string, string>, FSharpMap`2<string, string>> CalculatedProperties { get; public set; }
    public string Name { get; }
    public string NameWithoutExtension { get; }
    public ProjectOutputType OutputType { get; }
    public FSharpOption`1<string> BuildOutputTargetFolder { get; }
    public bool AppendTargetFrameworkToOutputPath { get; }
    public bool HasTemplateFile { get; }
    [DynamicDependencyAttribute("1632", "Paket.ProjectFile")]
public ProjectFile(string fileName, string originalText, XmlDocument document, XmlNode projectNode, ProjectLanguage language, FSharpOption`1<FSharpMap`2<string, string>> defaultProperties, ConcurrentDictionary`2<FSharpMap`2<string, string>, FSharpMap`2<string, string>> calculatedProperties);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_OriginalText();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public XmlDocument get_Document();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public XmlNode get_ProjectNode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ProjectLanguage get_Language();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<FSharpMap`2<string, string>> get_DefaultProperties();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ConcurrentDictionary`2<FSharpMap`2<string, string>, FSharpMap`2<string, string>> get_CalculatedProperties();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public void set_DefaultProperties(FSharpOption`1<FSharpMap`2<string, string>> value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public void set_CalculatedProperties(ConcurrentDictionary`2<FSharpMap`2<string, string>, FSharpMap`2<string, string>> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProjectFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpOption`1<string> GetPropertyWithDefaults(string propertyName, FSharpMap`2<string, string> defaultProperties);
    public FSharpOption`1<string> GetProperty(string propertyName);
    public string get_Name();
    public string get_NameWithoutExtension();
    public FSharpList`1<XmlNode> GetCustomReferenceAndFrameworkNodes();
    public XmlElement CreateNode(string name);
    public XmlElement CreateNode(string name, string text);
    public bool DeleteIfEmpty(string name);
    public FSharpList`1<XmlNode> FindPaketNodes(string name);
    public FSharpList`1<string> GetFrameworkAssemblies();
    public void DeletePaketNodes(string name);
    public void UpdateFileItems(FSharpList`1<FileItem> fileItems);
    public void RemoveNugetAnalysers(FSharpList`1<Tuple`2<string, SemVerInfo>> packages);
    public FSharpList`1<XmlNode> GetCustomModelNodes(InstallModel model);
    public void DeleteCustomModelNodes(InstallModel model);
    public XmlContext GenerateXml(InstallModel model, HashSet`1<Tuple`2<TargetProfile, string>> usedFrameworkLibs, FSharpMap`2<string, string> aliases, FSharpOption`1<bool> embedInteropTypes, FSharpOption`1<bool> copyLocal, FSharpOption`1<bool> specificVersion, bool importTargets, d allTargetProfiles, FSharpOption`1<string> referenceCondition);
    public void RemovePaketNodes();
    public void UpdateReferences(FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<a, InstallModel>> completeModel, FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<b, InstallSettings>> directDependencies, FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<c, InstallSettings>> usedPackages);
    public void Save(bool forceTouch);
    public FSharpList`1<FileInfo> GetPaketFileItems();
    public Guid GetProjectGuid();
    public FSharpList`1<ProjectReference> GetInterProjectDependencies();
    public void ReplaceNuGetPackagesFile();
    public void RemoveNuGetTargetsEntries();
    public void RemoveNuGetPackageImportStamp();
    public void RemoveImportAndTargetEntries(FSharpList`1<Tuple`2<string, SemVerInfo>> packages);
    public FSharpList`1<string> GetPackageReferences();
    public FSharpList`1<string> GetCliToolReferences();
    public void RemovePackageReferenceEntries();
    public void RemoveCliToolReferenceEntries();
    public ProjectOutputType get_OutputType();
    public FSharpOption`1<string> get_BuildOutputTargetFolder();
    public bool get_AppendTargetFrameworkToOutputPath();
    public FSharpOption`1<string> GetTargetFrameworkIdentifier();
    public FSharpOption`1<string> GetTargetFrameworkProfile();
    public FSharpList`1<TargetProfile> GetTargetProfiles();
    public void AddImportForPaketTargets(string relativeTargetsPath);
    public void RemoveImportForPaketTargets();
    public BuildAction DetermineBuildAction(string fileName);
    public BuildAction DetermineBuildActionForRemoteItems(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string GetOutputDirectory(string buildConfiguration, string buildPlatform, FSharpOption`1<TargetProfile> targetFramework);
    public string GetAssemblyName();
    public void SetOrCreateAutoGenerateBindingRedirects();
    public static ProjectFile LoadFromStream(string fullName, Stream stream);
    public static ProjectFile LoadFromFile(string fileName);
    public static ProjectFile LoadFromString(string fullName, string text);
    public static FSharpOption`1<ProjectFile> TryLoad(string fileName);
    public static FSharpOption`1<string> FindCorrespondingFile(FileInfo projectFile, string correspondingFile);
    public FSharpOption`1<string> FindCorrespondingFile(string correspondingFile);
    public FSharpOption`1<string> FindReferencesFile();
    public FSharpList`1<string> FindLocalizedLanguageNames();
    public bool HasPackageInstalled(GroupName groupName, PackageName package);
    public static FSharpOption`1<string> FindReferencesFile(FileInfo projectFile);
    public FSharpOption`1<string> FindTemplatesFile();
    public double GetToolsVersion();
    public static ReferencesFile FindOrCreateReferencesFile(FileInfo projectFile);
    public ReferencesFile FindOrCreateReferencesFile();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FileInfo[] SearchAllProjectRelatedFiles(string searchPattern, string folder);
    public static FileInfo[] FindAllProjectFiles(string folder);
    public static ProjectFile[] FindAllProjects(string folder);
    public static FSharpOption`1<ProjectFile> TryFindProject(IEnumerable`1<ProjectFile> projects, string projectName);
    public FSharpList`1<ProjectFile> GetAllInterProjectDependenciesWithoutProjectTemplates(PackProcessCache cache);
    public FSharpList`1<ProjectFile> GetAllInterProjectDependenciesWithProjectTemplates(PackProcessCache cache);
    public bool get_HasTemplateFile();
    public FSharpList`1<ProjectFile> ProjectsWithoutTemplates(FSharpList`1<ProjectFile> projects);
    public FSharpList`1<ProjectFile> ProjectsWithTemplates(FSharpList`1<ProjectFile> projects);
    public FSharpList`1<ProjectFile> GetAllReferencedProjects(bool onlyWithOutput, PackProcessCache cache);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FSharpList`1<ProjectFile> GetProjects(bool includeReferencedProjects, PackProcessCache cache);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<CompileItem> GetCompileItems(bool includeReferencedProjects, PackProcessCache cache);
    public Tuple`2<ProjectCoreInfo, OptionalPackagingInfo> GetTemplateMetadata();
    public FSharpOption`1<FileInfo> TryFindConfigFile();
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
public static class Paket.ProjectFileModule : object {
    [CompilationMappingAttribute]
public static FSharpList`1<string> supportedEndings { get; }
    public static FSharpList`1<string> get_supportedEndings();
    public static bool isSupportedFile(FileInfo fi);
    public static string name(ProjectFile projectFile);
    public static string nameWithoutExtension(ProjectFile projectFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProjectFile loadFromStream(string fullName, Stream stream);
    public static ProjectFile loadFromFile(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ProjectFile loadFromString(string fullName, string text);
    public static FSharpOption`1<ProjectFile> tryLoad(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlElement createNode(string name, ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlElement createNodeSet(string name, string text, ProjectFile project);
    internal static FSharpMap`2<string, string> calculateNew@252(ProjectFile projectFile, Unit unitVar0);
    internal static FSharpMap`2<string, string> getReservedProperties(ProjectFile projectFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<a, b> appendMap(FSharpMap`2<a, b> first, FSharpMap`2<a, b> second);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getPackageIdAttribute(ProjectFile pf, XmlNode node);
    internal static string getPlaceholderValue@297(FSharpMap`2<string, string> data, string name);
    internal static string processPlaceholders@296(FSharpMap`2<string, string> data, string text);
    internal static FSharpOption`1<Tuple`2<string, int>> parseWord@322(StringBuilder data, string input, int index, bool inQuotes);
    internal static bool isCompChar@339(char c);
    internal static FSharpOption`1<Tuple`2<string, int>> parseComparison@338(StringBuilder data, string input, int index);
    internal static FSharpOption`1<Tuple`4<string, string, string, int>> parseCondition@357(StringBuilder data, string input, int index);
    internal static FSharpOption`1<Tuple`2<string, int>> parseAndOr@376(StringBuilder data, string input, int index);
    internal static bool containsMoreText@388(string input, int index);
    internal static FSharpOption`1<FSharpList`1<Tuple`4<FSharpOption`1<string>, string, string, string>>> parseFullCondition@395(FSharpOption`1<FSharpList`1<Tuple`4<FSharpOption`1<string>, string, string, string>>> data, StringBuilder sb, string input, int index);
    internal static bool handleConditions@422(FSharpMap`2<string, string> data, FSharpList`1<Tuple`4<FSharpOption`1<string>, string, string, string>> xs, bool lastCondition);
    internal static bool conditionMatches@457(FSharpMap`2<string, string> data, string condition);
    internal static FSharpMap`2<string, string> addData@465(FSharpMap`2<string, string> data, XmlNode node);
    internal static FSharpMap`2<string, string> handleConditionalElement@477(FSharpFunc`2<FSharpMap`2<string, string>, FSharpFunc`2<XmlNode, FSharpMap`2<string, string>>> handleElement, FSharpMap`2<string, string> data, XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, string> calculatePropertyMap(ProjectFile projectFile, FSharpMap`2<string, string> defaultProperties);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> getPropertyWithDefaults(string propertyName, FSharpMap`2<string, string> defaultProperties, ProjectFile projectFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> getProperty(string propertyName, ProjectFile projectFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool deleteIfEmpty(string name, ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<XmlNode> findNodes(bool paketOnes, string name, ProjectFile project);
    public static FSharpList`1<XmlNode> getCustomReferenceAndFrameworkNodes(ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<XmlNode> findPaketNodes(string name, ProjectFile project);
    public static FSharpList`1<string> getFrameworkAssemblies(ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deletePaketNodes(string name, ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void updateFileItems(FSharpList`1<FileItem> fileItems, ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<XmlNode> getCustomModelNodes(InstallModel model, ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void deleteCustomModelNodes(InstallModel model, ProjectFile project);
    internal static XmlElement createAnalyzersNode@694(ProjectFile project, FSharpList`1<AnalyzerLib> analyzers);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlElement generateAnalyzersXml(InstallModel model, ProjectFile project);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@719-12(IEqualityComparer comp, XmlContext this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@719-25(XmlContext this, XmlContext that, IEqualityComparer comp, Unit unitVar);
    internal static XmlElement createItemGroup@736(FSharpMap`2<string, string> aliases, FSharpOption`1<bool> embedInteropTypes, FSharpOption`1<bool> copyLocal, FSharpOption`1<bool> specificVersion, ProjectFile project, FSharpSet`1<TargetProfile> targets, FSharpList`1<FrameworkReference> frameworkReferences, FSharpList`1<Library> libraries);
    internal static Tuple`2<FSharpSet`1<Tuple`3<string, string, string>>, XmlElement> createPropertyGroup@786(ProjectFile project, FSharpList`1<MsBuildFile> references);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`3<string, XmlElement, bool>> conditions$cont@830(HashSet`1<Tuple`2<TargetProfile, string>> usedFrameworkLibs, FSharpMap`2<string, string> aliases, FSharpOption`1<bool> embedInteropTypes, FSharpOption`1<bool> copyLocal, FSharpOption`1<bool> specificVersion, FSharpOption`1<string> referenceCondition, ProjectFile project, FrameworkFolder`1<ReferenceOrLibraryFolder> libFolder, string condition, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<XmlElement> chooseNodes$cont@884(ProjectFile project, FSharpList`1<Tuple`3<string, XmlElement, bool>> conditions, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlContext generateXml(InstallModel model, HashSet`1<Tuple`2<TargetProfile, string>> usedFrameworkLibs, FSharpMap`2<string, string> aliases, FSharpOption`1<bool> embedInteropTypes, FSharpOption`1<bool> copyLocal, FSharpOption`1<bool> specificVersion, bool importTargets, FSharpOption`1<string> referenceCondition, FSharpSet`1<TargetProfile> allTargetProfiles, ProjectFile project);
    internal static FSharpList`1<XmlNode> getPaketNodes@1029(XmlNode node);
    public static void removePaketNodes(ProjectFile project);
    public static FSharpOption`1<string> getTargetFrameworkIdentifier(ProjectFile project);
    public static FSharpOption`1<string> getTargetFrameworkProfile(ProjectFile project);
    public static FSharpOption`1<string> getTargetFrameworkVersion(ProjectFile project);
    public static FSharpOption`1<string> getTargetFramework(ProjectFile project);
    public static FSharpOption`1<string> getTargetFrameworks(ProjectFile project);
    public static FSharpList`1<string> getTargetFrameworksParsed(ProjectFile project);
    internal static double adjustIfWeHaveSDK@1073(ProjectFile project, double v);
    public static double getToolsVersion(ProjectFile project);
    internal static string prefix@1104-3(ProjectFile project, Unit unitVar0);
    internal static FSharpList`1<TargetProfile> fallback@1103-13(ProjectFile project, Unit unitVar0);
    public static FSharpList`1<TargetProfile> getTargetProfiles(ProjectFile project);
    internal static Tuple`2<int, int> findInsertSpot@1146(ProjectFile project, Unit unitVar0);
    internal static void addProps@1276(ProjectFile project, XmlContext ctx, int iProp, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void updateReferences(FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<a, InstallModel>> completeModel, FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<b, InstallSettings>> directPackages, FSharpMap`2<Tuple`2<GroupName, PackageName>, Tuple`2<c, InstallSettings>> usedPackages, ProjectFile project);
    internal static UTF8Encoding determineEncoding@1307(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void save(bool forceTouch, ProjectFile project);
    public static FSharpList`1<FileInfo> getPaketFileItems(ProjectFile project);
    internal static string forceGetInnerText@1335(XmlNode node, string name);
    public static Guid getProjectGuid(ProjectFile project);
    internal static FSharpOption`1<string> forceGetName@1346(XmlNode node, string name);
    internal static FSharpOption`1<string> forceGetInnerText@1356-1(XmlNode node, string name);
    internal static ProjectReference makePathNode@1377(ProjectFile project, XmlNode node, bool referenceOutputAssembly, string path);
    public static FSharpList`1<ProjectReference> getInterProjectDependencies(ProjectFile project);
    public static void replaceNuGetPackagesFile(ProjectFile project);
    public static void removeNuGetTargetsEntries(ProjectFile project);
    public static void removeNuGetPackageImportStamp(ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void removeImportAndTargetEntries(FSharpList`1<Tuple`2<string, SemVerInfo>> packages, ProjectFile project);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<XmlNode> func1@1-46(XmlNode node);
    public static FSharpList`1<XmlNode> packageReferencesNoPrivateAssets(ProjectFile project);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<XmlNode> func1@1-47(XmlNode node);
    public static FSharpList`1<XmlNode> cliToolsNoPrivateAssets(ProjectFile project);
    public static FSharpList`1<string> getPackageReferences(ProjectFile project);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<string> func1@1-48(XmlNode node);
    public static FSharpList`1<string> getCliReferences(ProjectFile project);
    public static void removePackageReferenceEntries(ProjectFile project);
    public static void removeCliToolReferenceEntries(ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void removeNugetAnalysers(FSharpList`1<Tuple`2<string, SemVerInfo>> packages, ProjectFile project);
    public static ProjectOutputType outputType(ProjectFile project);
    public static FSharpOption`1<string> buildOutputTargetFolder(ProjectFile project);
    public static bool appendTargetFrameworkToOutputPath(ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void addImportForPaketTargets(string relativeTargetsPath, ProjectFile project);
    public static void removeImportForPaketTargets(ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static BuildAction determineBuildAction(string fileName, ProjectFile project);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static BuildAction determineBuildActionForRemoteItems(string fileName, ProjectFile project);
    public static string getAssemblyName(ProjectFile project);
    [CompilerGeneratedAttribute]
internal static string tryNextPlat$cont@1656(string buildPlatform, ProjectFile project, string targetFramework, FSharpList`1<string> attempted, string x, FSharpList`1<string> _arg1, Unit unitVar);
    internal static string tryNextPlat@1638(string buildConfiguration, string buildPlatform, ProjectFile project, string targetFramework, FSharpList`1<string> platforms, FSharpList`1<string> attempted);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string getOutputDirectory(string buildConfiguration, string buildPlatform, FSharpOption`1<TargetProfile> targetProfile, ProjectFile project);
    public static VersionRequirement versionRequirement(XmlNode node);
    public static FSharpList`1<NugetPackage> dotNetCorePackages(ProjectFile projectFile);
    public static FSharpList`1<NugetPackage> cliTools(ProjectFile projectFile);
    public static void setOrCreateAutoGenerateBindingRedirects(ProjectFile project);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.ProjectLanguage : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_Unknown;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_CSharp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_FSharp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_VisualBasic;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_WiX;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_Nemerle;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_CPP;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_IronPython;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_ServiceFabric;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectLanguage _unique_Sql;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage Unknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage CSharp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCSharp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage FSharp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFSharp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage VisualBasic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVisualBasic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage WiX { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWiX { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage Nemerle { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNemerle { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage CPP { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCPP { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage IronPython { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIronPython { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage ServiceFabric { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsServiceFabric { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectLanguage Sql { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSql { get; }
    private static ProjectLanguage();
    [DynamicDependencyAttribute("2016", "Paket.ProjectLanguage")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ProjectLanguage(int _tag);
    [CompilationMappingAttribute]
public static ProjectLanguage get_Unknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknown();
    [CompilationMappingAttribute]
public static ProjectLanguage get_CSharp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCSharp();
    [CompilationMappingAttribute]
public static ProjectLanguage get_FSharp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFSharp();
    [CompilationMappingAttribute]
public static ProjectLanguage get_VisualBasic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVisualBasic();
    [CompilationMappingAttribute]
public static ProjectLanguage get_WiX();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWiX();
    [CompilationMappingAttribute]
public static ProjectLanguage get_Nemerle();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNemerle();
    [CompilationMappingAttribute]
public static ProjectLanguage get_CPP();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCPP();
    [CompilationMappingAttribute]
public static ProjectLanguage get_IronPython();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIronPython();
    [CompilationMappingAttribute]
public static ProjectLanguage get_ServiceFabric();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsServiceFabric();
    [CompilationMappingAttribute]
public static ProjectLanguage get_Sql();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSql();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ProjectLanguage obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProjectLanguage obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.ProjectOutputType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectOutputType _unique_Exe;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ProjectOutputType _unique_Library;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectOutputType Exe { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExe { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ProjectOutputType Library { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLibrary { get; }
    private static ProjectOutputType();
    [DynamicDependencyAttribute("2016", "Paket.ProjectOutputType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ProjectOutputType(int _tag);
    [CompilationMappingAttribute]
public static ProjectOutputType get_Exe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExe();
    [CompilationMappingAttribute]
public static ProjectOutputType get_Library();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLibrary();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ProjectOutputType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProjectOutputType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.ProjectReference : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Path@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string RelativePath@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool ReferenceOutputAssembly@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Guid> GUID@;
    [CompilationMappingAttribute]
public string Path { get; }
    [CompilationMappingAttribute]
public string RelativePath { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> Name { get; }
    [CompilationMappingAttribute]
public bool ReferenceOutputAssembly { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<Guid> GUID { get; }
    [DynamicDependencyAttribute("1632", "Paket.ProjectReference")]
public ProjectReference(string path, string relativePath, FSharpOption`1<string> name, bool referenceOutputAssembly, FSharpOption`1<Guid> gUID);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_RelativePath();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_ReferenceOutputAssembly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Guid> get_GUID();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ProjectReference obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProjectReference obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.PublicAPI : object {
    public static SemVerInfo ParseSemVer(string version);
    public static Task`1<Unit> PreCalculateMaps();
}
[CompilationMappingAttribute]
public static class Paket.Queries : object {
    [CompilationMappingAttribute]
public static Lazy`1<FrameworkIdentifier> resolveEnvironmentFrameworkForScriptGeneration { get; }
    public static LockFile getLockFileFromDependenciesFile(string dependenciesFileName);
    public static FSharpList`1<Tuple`3<string, string, string>> listPackages(IEnumerable`1<KeyValuePair`2<Tuple`2<GroupName, PackageName>, PackageInfo>> packages);
    public static FSharpList`1<Tuple`3<string, string, string>> getAllInstalledPackagesFromLockFile(LockFile lockFile);
    [CompilerGeneratedAttribute]
internal static InstallModel getInstalledPackageModel$cont@25(LockFile lockFile, PackageName packageName, GroupName groupName, FSharpOption`1<LockFileGroup> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InstallModel getInstalledPackageModel(LockFile lockFile, QualifiedPackageName _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RuntimeGraph getRuntimeGraph(LockFile lockFile, GroupName groupName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<Tuple`2<PackageName, VersionRequirement>> getRuntimePackages(Rid rid, LockFile lockFile, GroupName groupName);
    public static Lazy`1<IEnumerable`1<TargetProfile>> resolveFrameworkForScriptGeneration(DependenciesFile dependencies);
    public static Lazy`1<FrameworkIdentifier> get_resolveEnvironmentFrameworkForScriptGeneration();
}
[CompilationMappingAttribute]
public class Paket.ReferenceOrLibraryFolder : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<FrameworkReference> FrameworkReferences@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<Library> Libraries@;
    [CompilationMappingAttribute]
public FSharpSet`1<FrameworkReference> FrameworkReferences { get; }
    [CompilationMappingAttribute]
public FSharpSet`1<Library> Libraries { get; }
    [DynamicDependencyAttribute("1632", "Paket.ReferenceOrLibraryFolder")]
public ReferenceOrLibraryFolder(FSharpSet`1<FrameworkReference> frameworkReferences, FSharpSet`1<Library> libraries);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<FrameworkReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<Library> get_Libraries();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ReferenceOrLibraryFolder obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReferenceOrLibraryFolder obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.ReferenceOrLibraryFolderModule : object {
    [CompilationMappingAttribute]
public static ReferenceOrLibraryFolder empty { get; }
    public static ReferenceOrLibraryFolder get_empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReferenceOrLibraryFolder addLibrary(Library item, ReferenceOrLibraryFolder old);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReferenceOrLibraryFolder addFrameworkReference(FrameworkReference item, ReferenceOrLibraryFolder old);
}
[CompilationMappingAttribute]
public class Paket.ReferencesFile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FileName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<GroupName, InstallGroup> Groups@;
    [CompilationMappingAttribute]
public string FileName { get; }
    [CompilationMappingAttribute]
public FSharpMap`2<GroupName, InstallGroup> Groups { get; }
    public static string DefaultLink { get; }
    [DynamicDependencyAttribute("1632", "Paket.ReferencesFile")]
public ReferencesFile(string fileName, FSharpMap`2<GroupName, InstallGroup> groups);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpMap`2<GroupName, InstallGroup> get_Groups();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ReferencesFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static string get_DefaultLink();
    public static ReferencesFile New(string fileName);
    public static ReferencesFile FromLines(String[] lines);
    public static ReferencesFile FromFile(string fileName);
    public ReferencesFile AddNuGetReference(GroupName groupName, PackageName packageName, bool embedInteropTypes, bool copyLocal, bool specificVersion, bool importTargets, FrameworkRestrictions frameworkRestrictions, bool includeVersionInPath, bool downloadLicense, bool omitContent, FSharpOption`1<BindingRedirectsSettings> createBindingRedirects, string referenceCondition);
    public ReferencesFile AddNuGetReference(GroupName groupName, PackageName packageName);
    public ReferencesFile RemoveNuGetReference(GroupName groupName, PackageName packageName);
    public void Save();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReferencesFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.ReferenceType : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAssembly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFramework { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLoadScript { get; }
    [CompilationMappingAttribute]
public static ReferenceType NewAssembly(FileInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAssembly();
    [CompilationMappingAttribute]
public static ReferenceType NewFramework(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFramework();
    [CompilationMappingAttribute]
public static ReferenceType NewLoadScript(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLoadScript();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReferenceType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.Releases : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`2<Unit, DomainMessage> download(a version, FileInfo file, HttpClient client);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool doesNotExistsOrIsNewer(FileInfo file, SemVerInfo latest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`2<Unit, DomainMessage> downloadLatestVersionOf(FSharpList`1<string> files, string destDir);
    public static Result`2<Unit, DomainMessage> downloadLatestBootstrapperAndTargets(PaketEnv environment);
    public static Result`2<Unit, DomainMessage> downloadLatestTargets(PaketEnv environment);
}
[CompilationMappingAttribute]
public static class Paket.RemoteDownload : object {
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`3<AuthProvider, string, string>, FSharpAsync`1<SafeWebResult`1<string>>> safeGetFromUrlCached { get; }
    internal static FSharpFunc`2<Tuple`3<AuthProvider, string, string>, FSharpAsync`1<SafeWebResult`1<string>>> get_safeGetFromUrlCached();
    internal static FSharpAsync`1<SafeWebResult`1<string>> lookupDocument(AuthProvider auth, string url);
    internal static AuthProvider auth(FSharpOption`1<string> key);
    [CompilerGeneratedAttribute]
internal static string getSHA1OfBranch$cont@75(string project, VersionRestriction versionRestriction, string url, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<string> getSHA1OfBranch(Origin origin, string owner, string project, VersionRestriction versionRestriction, FSharpOption`1<string> authKey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string rawFileUrl(string owner, string project, string branch, string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string rawGistFileUrl(string owner, string project, string fileName);
    internal static FSharpFunc`2<b, FSharpOption`1<Auth>> auth@121-2(ResolvedSourceFile remoteFile, string url);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Tuple`2<string, a>> catchHandler@1-6(FSharpFunc`2<string, a> parserF, Exception _arg2);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<a> downloadDependenciesFile$cont@106(string rootPath, ResolvedSourceFile remoteFile, FSharpFunc`2<string, a> parserF, GroupName groupName, bool force, Unit unitVar);
    public static FSharpAsync`1<a> downloadDependenciesFile(bool force, string rootPath, GroupName groupName, FSharpFunc`2<string, a> parserF, ResolvedSourceFile remoteFile);
    public static void DirectoryCopy(string sourceDirName, string destDirName, bool copySubDirs);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1-7(string tCommand, Exception exn);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> downloadRemoteFiles$cont@196(ResolvedSourceFile remoteFile, string destination, string cloneUrl, Unit unitVar);
    public static FSharpAsync`1<Unit> downloadRemoteFiles(ResolvedSourceFile remoteFile, string destination);
    internal static void download@348(ResolvedSourceFile source, string destination, int trials);
    internal static void action@1-4(bool force, Tuple`2<FileInfo, string> tupledArg0, FSharpList`1<Tuple`2<Tuple`2<string, string>, Tuple`2<string, ResolvedSourceFile>>> sources);
    public static void DownloadSourceFiles(string rootPath, GroupName groupName, bool force, FSharpList`1<ResolvedSourceFile> sourceFiles);
}
[CompilationMappingAttribute]
public class Paket.RemoteFileReference : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Link@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal RemoteFileInstallSettings Settings@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public string Link { get; }
    [CompilationMappingAttribute]
public RemoteFileInstallSettings Settings { get; }
    [DynamicDependencyAttribute("1632", "Paket.RemoteFileReference")]
public RemoteFileReference(string name, string link, RemoteFileInstallSettings settings);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Link();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public RemoteFileInstallSettings get_Settings();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(RemoteFileReference obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RemoteFileReference obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.RemoteUpload : object {
    internal static FSharpOption`1<Uri> |UrlWithEndpoint|_|@12(FSharpOption`1<string> url);
    internal static FSharpOption`1<Uri> |IsUrl|_|@17(FSharpOption`1<string> url);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string GetUrlWithEndpoint(FSharpOption`1<string> url, FSharpOption`1<string> endPoint);
    internal static a tracefnVerbose@33(PrintfFormat`4<a, Unit, string, Unit> m);
    internal static void push@37(int maxTrials, string url, string apiKey, string clientVersion, string packageFileName, bool ignoreConflicts, FSharpTypeFunc tracefnVerbose, int trial);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Push(int maxTrials, string url, string apiKey, string clientVersion, string packageFileName, bool ignoreConflicts);
}
[CompilationMappingAttribute]
public static class Paket.RemoveProcess : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void removePackageFromProject(ProjectFile project, GroupName groupName, PackageName package);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool remove(FSharpFunc`2<ProjectFile[], Unit> removeFromProjects, string dependenciesFileName, FSharpOption`1<string> alternativeProjectRoot, GroupName groupName, PackageName package, bool force, bool installAfter);
    internal static void removeFromSpecifiedProject@60(string projectName, PackageName packageName, GroupName groupName, IEnumerable`1<ProjectFile> projects);
    public static bool RemoveFromProject(string dependenciesFileName, FSharpOption`1<string> groupName, PackageName packageName, bool force, string projectName, bool installAfter);
    internal static void removeFromProjects@78(PackageName packageName, bool interactive, GroupName groupName, IEnumerable`1<ProjectFile> projects);
    public static bool Remove(string dependenciesFileName, FSharpOption`1<string> groupName, PackageName packageName, bool force, bool interactive, bool installAfter);
}
[CompilationMappingAttribute]
public static class Paket.Requirements : object {
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, Tuple`2<FrameworkRestriction, RestrictionParseProblem[]>> parseRestrictions { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<FrameworkRestriction, RestrictionParseProblem[]>> f@63-18 { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, Tuple`2<FrameworkRestriction, RestrictionParseProblem[]>> cache@54-15 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<string, Tuple`2<FrameworkRestriction, RestrictionParseProblem[]>> parseRestrictionsSimplified { get; }
    public static FrameworkRestriction getExplicitRestriction(FrameworkRestrictions frameworkRestrictions);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@630-3(RestrictionParseProblem this, Unit unitVar);
    internal static void handleError@657-14(bool failImmediatly, List`1<RestrictionParseProblem> problems, RestrictionParseProblem p);
    internal static FSharpOption`1<TargetProfile> extractProfile@663(bool failImmediatly, List`1<RestrictionParseProblem> problems, string framework);
    internal static Tuple`2<string, string> frameworkToken@672(string str);
    internal static FSharpFunc`2<string, FSharpOption`1<a>> tryParseFramework@681(bool failImmediatly, List`1<RestrictionParseProblem> problems, IEnumerable`1<FSharpFunc`2<string, FSharpOption`1<a>>> handlers);
    internal static Tuple`2<FSharpOption`1<string>, string> p@695(string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FrameworkRestriction, RestrictionParseProblem[]> parseRestrictionsLegacy(bool failImmediatly, string text);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FrameworkRestriction, string> parseOperator$cont@786(List`1<RestrictionParseProblem> problems, string text, string h, bool isEqualsEquals, bool isSmaller, Unit unitVar);
    internal static Tuple`2<FSharpList`1<FrameworkRestriction>, string> parseOperand@823(bool skipSimplify, List`1<RestrictionParseProblem> problems, string text, FSharpList`1<FrameworkRestriction> cur, string next);
    internal static Tuple`2<FrameworkRestriction, string> parseOperator@763(bool skipSimplify, List`1<RestrictionParseProblem> problems, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FrameworkRestriction, RestrictionParseProblem[]> parseRestrictionsRaw(bool skipSimplify, string text);
    public static FSharpFunc`2<string, Tuple`2<FrameworkRestriction, RestrictionParseProblem[]>> get_parseRestrictions();
    internal static FSharpFunc`2<string, Tuple`2<FrameworkRestriction, RestrictionParseProblem[]>> get_f@63-18();
    internal static ConcurrentDictionary`2<string, Tuple`2<FrameworkRestriction, RestrictionParseProblem[]>> get_cache@54-15();
    internal static FSharpFunc`2<string, Tuple`2<FrameworkRestriction, RestrictionParseProblem[]>> get_parseRestrictionsSimplified();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FrameworkRestrictions filterRestrictions(FrameworkRestrictions list1, FrameworkRestrictions list2);
    public static bool isTargetMatchingRestrictions(FrameworkRestriction restriction, TargetProfile target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpSet`1<TargetProfile> applyRestrictionsToTargets(FrameworkRestriction restriction, FSharpSet`1<TargetProfile> targets);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@909-4(InstallSettings this, InstallSettings obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@909-3(InstallSettings this, InstallSettings obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@909-2(InstallSettings this, InstallSettings obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@909-7(IComparer comp, InstallSettings this, InstallSettings objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@909-6(IComparer comp, InstallSettings this, InstallSettings objTemp, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@909-5(IComparer comp, InstallSettings this, InstallSettings objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@909-5(InstallSettings this, InstallSettings that, IEqualityComparer comp, Unit unitVar);
    internal static FSharpOption`1<string> getPair@1026-1(Dictionary`2<string, string> kvPairs, string key);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@909-6(InstallSettings this, InstallSettings obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1155-8(PackageRequirementSource this, PackageRequirementSource obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1155-9(IComparer comp, PackageRequirementSource this, PackageRequirementSource objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1155-4(IEqualityComparer comp, PackageRequirementSource this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1155-7(PackageRequirementSource this, PackageRequirementSource that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1155-8(PackageRequirementSource this, PackageRequirementSource obj, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<FSharpList`1<Tuple`3<PackageName, a, FrameworkRestrictions>>, AddFrameworkRestrictionWarnings[]> addFrameworkRestrictionsToDependencies(FSharpList`1<Tuple`3<PackageName, a, ParsedPlatformPath>> rawDependencies, FSharpList`1<ParsedPlatformPath> frameworkGroups);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.ResolverStrategy : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ResolverStrategy _unique_Max;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ResolverStrategy _unique_Min;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ResolverStrategy Max { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMax { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ResolverStrategy Min { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMin { get; }
    private static ResolverStrategy();
    [DynamicDependencyAttribute("2016", "Paket.ResolverStrategy")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ResolverStrategy(int _tag);
    [CompilationMappingAttribute]
public static ResolverStrategy get_Max();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMax();
    [CompilationMappingAttribute]
public static ResolverStrategy get_Min();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMin();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ResolverStrategy obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ResolverStrategy obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.RestoreProcess : object {
    [CompilationMappingAttribute]
public static FSharpRef`1<bool> copiedElements { get; }
    [CompilationMappingAttribute]
public static PackageName FSharpCore { get; }
    [CompilationMappingAttribute]
public static FSharpSet`1<PackageName> ImplicitPackages { get; }
    [CompilationMappingAttribute]
internal static FSharpList`1<PackageName> elements@1 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> combineImportTargets(InstallSettings resolvedSettings, PackageInstallSettings packageInstallSettings);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ContentCopySettings> combineOmitContent(InstallSettings resolvedSettings, PackageInstallSettings packageInstallSettings);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> combineCopyLocal(InstallSettings resolvedSettings, PackageInstallSettings packageInstallSettings);
    public static FSharpList`1<Tuple`2<GroupName, PackageName>> FindPackagesNotExtractedYet(string dependenciesFileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CopyToCaches(bool force, IEnumerable`1<Cache> caches, string fileName);
    internal static FSharpAsync`1<Tuple`2<PackageInfo, Lazy`1<NuGetPackageContent>>> downloadAndExtract@65(FSharpList`1<Cache> caches, PackageInfo package, FSharpOption`1<string> alternativeProjectRoot, string root, bool isLocalOverride, PackageSource source, GroupName groupName, SemVerInfo version, bool includeVersionInPath, bool downloadLicense, bool force, bool detailed);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Tuple`2<PackageInfo, Lazy`1<NuGetPackageContent>>> catchHandler@1-30(FSharpList`1<Cache> caches, PackageInfo package, FSharpOption`1<string> alternativeProjectRoot, string root, bool isLocalOverride, PackageSource source, GroupName groupName, SemVerInfo version, bool includeVersionInPath, bool downloadLicense, Exception exn);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Tuple`2<PackageInfo, Lazy`1<NuGetPackageContent>>> catchHandler@1-29(FSharpList`1<Cache> caches, PackageInfo package, FSharpOption`1<string> alternativeProjectRoot, string root, bool isLocalOverride, PackageSource source, GroupName groupName, SemVerInfo version, bool includeVersionInPath, bool downloadLicense, Exception exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<Tuple`2<PackageInfo, Lazy`1<NuGetPackageContent>>> extractPackage(FSharpList`1<Cache> caches, PackageInfo package, FSharpOption`1<string> alternativeProjectRoot, string root, bool isLocalOverride, PackageSource source, GroupName groupName, SemVerInfo version, bool includeVersionInPath, bool downloadLicense, bool force);
    public static FSharpAsync`1<Tuple`2<PackageInfo, Lazy`1<NuGetPackageContent>>> ExtractPackage(FSharpOption`1<string> alternativeProjectRoot, string root, GroupName groupName, FSharpList`1<PackageSource> sources, FSharpList`1<Cache> caches, bool force, PackageInfo package, bool localOverride);
    internal static FSharpAsync`1<Unit> restore(FSharpOption`1<string> alternativeProjectRoot, string root, GroupName groupName, FSharpList`1<PackageSource> sources, FSharpList`1<Cache> caches, bool force, LockFile lockFile, FSharpSet`1<PackageName> packages, FSharpSet`1<PackageName> overriden);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<PackageName> computePackageHull(GroupName groupName, LockFile lockFile, IEnumerable`1<string> referencesFileNames);
    public static Result`2<FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>>, DomainMessage> findAllReferencesFiles(string root);
    public static FSharpRef`1<bool> get_copiedElements();
    internal static Tuple`2<bool, string> loop@192-8(string newContent, FileInfo targetFile, int trials);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, string> saveToFile(string newContent, FileInfo targetFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, string> extractElement(string root, string name);
    public static string extractRestoreTargets(string root);
    public static FSharpAsync`1<Tuple`2<Tuple`2<GroupName, PackageName>, Tuple`2<PackageInfo, InstallModel>>> CreateInstallModel(FSharpOption`1<string> alternativeProjectRoot, string root, GroupName groupName, FSharpList`1<PackageSource> sources, FSharpList`1<Cache> caches, bool force, PackageInfo package);
    public static void createAlternativeNuGetConfig(FileInfo projectFile, DirectoryInfo objDirectory);
    public static PackageName get_FSharpCore();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<bool, string> createPaketPropsFile(LockFile lockFile, IEnumerable`1<ResolvedPackage> cliTools, IEnumerable`1<Tuple`3<Tuple`2<GroupName, PackageName>, PackageInstallSettings, a>> packages, FileInfo fileInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createPaketCLIToolsFile(IEnumerable`1<ResolvedPackage> cliTools, FileInfo fileInfo);
    public static FSharpSet`1<PackageName> get_ImplicitPackages();
    internal static FSharpList`1<PackageName> get_elements@1();
    internal static void loop@492-14(FileInfo oldReferencesFile, TargetProfile targetProfile, string output, FileInfo newFileName, int trials);
    internal static void loop@538-20(ReferencesFile referencesFile, FileInfo paketCachedReferencesFileName, int trials);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void createProjectReferencesFiles(LockFile lockFile, ProjectFile projectFile, ReferencesFile referencesFile, Lazy`1<FSharpMap`2<Tuple`2<GroupName, PackageName>, PackageInfo>> resolved, FSharpMap`2<GroupName, LockFileGroup> groups, FSharpOption`1<string> targetFrameworks, DirectoryInfo objDir);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void CreateScriptsForGroups(LockFile lockFile, FSharpMap`2<GroupName, LockFileGroup> groups);
    public static ReferencesFile FindOrCreateReferencesFile(ProjectFile projectFile);
    public static DirectoryInfo objDirectory(FileInfo projectFileInfo, FSharpOption`1<DirectoryInfo> outputPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReferencesFile RestoreNewSdkProject(LockFile lockFile, Lazy`1<FSharpMap`2<Tuple`2<GroupName, PackageName>, PackageInfo>> resolved, FSharpMap`2<GroupName, LockFileGroup> groups, ProjectFile projectFile, FSharpOption`1<string> targetFrameworks, FSharpOption`1<DirectoryInfo> outputPath);
    internal static string getStringHash(string s);
    internal static Hash getLockFileHashFromContent(string content);
    internal static Hash getLockFileHash(string f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeRestoreCache(string file, RestoreCache _arg1);
    internal static RestoreCache tryReadRestoreCache(string file);
    internal static RestoreCache readRestoreCache(FileInfo lockFileName);
    internal static bool isGitManaged@678(DirectoryInfo folder);
    internal static void writeGitignore(string restoreCacheFile);
    [CompilerGeneratedAttribute]
internal static LocalFile clo0@1-3(IEnumerable`1<string> msgs);
    internal static Tuple`4<FSharpOption`1<RestoreCache>, RestoreCache, Hash, bool> readCache@729(RestoreProjectOptions projectFile, FileInfo lockFileName, bool canCacheRestore, Unit unitVar0);
    public static void Restore(string dependenciesFileName, RestoreProjectOptions projectFile, bool force, FSharpOption`1<GroupName> group, bool ignoreChecks, bool failOnChecks, FSharpOption`1<string> targetFrameworks, FSharpOption`1<string> outputPath, bool skipRestoreTargetsExtraction);
}
[CompilationMappingAttribute]
public class Paket.Rid : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Rid@;
    [CompilationMappingAttribute]
internal string Rid { get; }
    public static Rid Any { get; }
    [DynamicDependencyAttribute("1632", "Paket.Rid")]
internal Rid(string rid);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_Rid();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Rid obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static Rid Of(string s);
    public static Rid Parse(string s);
    public virtual string ToString();
    public static Rid get_Any();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Rid obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.RuntimeDescription : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Rid Rid@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Rid> InheritedRids@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<PackageName, FSharpList`1<Tuple`2<PackageName, VersionRequirement>>> RuntimeDependencies@;
    [CompilationMappingAttribute]
public Rid Rid { get; }
    [CompilationMappingAttribute]
public FSharpList`1<Rid> InheritedRids { get; }
    [CompilationMappingAttribute]
public FSharpMap`2<PackageName, FSharpList`1<Tuple`2<PackageName, VersionRequirement>>> RuntimeDependencies { get; }
    [DynamicDependencyAttribute("1632", "Paket.RuntimeDescription")]
public RuntimeDescription(Rid rid, FSharpList`1<Rid> inheritedRids, FSharpMap`2<PackageName, FSharpList`1<Tuple`2<PackageName, VersionRequirement>>> runtimeDependencies);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Rid get_Rid();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Rid> get_InheritedRids();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpMap`2<PackageName, FSharpList`1<Tuple`2<PackageName, VersionRequirement>>> get_RuntimeDependencies();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(RuntimeDescription obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeDescription obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.RuntimeGraph : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<string, CompatibilityProfile> Supports@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<Rid, RuntimeDescription> Runtimes@;
    [CompilationMappingAttribute]
public FSharpMap`2<string, CompatibilityProfile> Supports { get; }
    [CompilationMappingAttribute]
public FSharpMap`2<Rid, RuntimeDescription> Runtimes { get; }
    public static RuntimeGraph Empty { get; }
    [DynamicDependencyAttribute("1632", "Paket.RuntimeGraph")]
public RuntimeGraph(FSharpMap`2<string, CompatibilityProfile> supports, FSharpMap`2<Rid, RuntimeDescription> runtimes);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpMap`2<string, CompatibilityProfile> get_Supports();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpMap`2<Rid, RuntimeDescription> get_Runtimes();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(RuntimeGraph obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static RuntimeGraph get_Empty();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeGraph obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.RuntimeGraphModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static CompatibilityProfile mergeCompatibility(CompatibilityProfile s1, CompatibilityProfile s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RuntimeDescription mergeDescription(RuntimeDescription d1, RuntimeDescription d2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static RuntimeGraph merge(RuntimeGraph r1, RuntimeGraph r2);
    public static RuntimeGraph mergeSeq(IEnumerable`1<RuntimeGraph> s);
    [CompilerGeneratedAttribute]
internal static bool contains@1-4(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-5(a e, FSharpList`1<a> xs1);
    internal static FSharpList`1<Rid> getListRec@167(RuntimeGraph g, FSharpList`1<Rid> worked, FSharpList`1<Rid> currentList, FSharpList`1<Rid> toInspect);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<Rid> getInheritanceList(Rid rid, RuntimeGraph g);
    public static IEnumerable`1<Rid> getKnownRids(RuntimeGraph g);
    [CompilerGeneratedAttribute]
internal static bool contains@1-6(a e, FSharpList`1<a> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool areCompatible(Rid projectRid, Rid assetRid, RuntimeGraph g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<Tuple`2<PackageName, VersionRequirement>> findRuntimeDependencies(Rid rid, PackageName packageName, RuntimeGraph g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<RuntimeGraph> getRuntimeGraphFromNugetCache(string root, FSharpOption`1<PackagesFolderGroupConfig> config, GroupName groupName, ResolvedPackage package);
}
[CompilationMappingAttribute]
public static class Paket.RuntimeGraphParser : object {
    public static FSharpList`1<CompatibilityProfile> readCompatiblityProfilesJ(JObject json);
    public static FSharpList`1<RuntimeDescription> readRuntimeDescriptionJ(JObject json);
    public static RuntimeGraph readRuntimeGraphJ(JObject json);
    public static RuntimeGraph readRuntimeGraph(string s);
}
[CompilationMappingAttribute]
public class Paket.RuntimeLibrary : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Library Library@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Rid> Rid@;
    [CompilationMappingAttribute]
public Library Library { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<Rid> Rid { get; }
    [DynamicDependencyAttribute("1632", "Paket.RuntimeLibrary")]
public RuntimeLibrary(Library library, FSharpOption`1<Rid> rid);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Library get_Library();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Rid> get_Rid();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(RuntimeLibrary obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeLibrary obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.RuntimeLibraryModule : object {
    public static RuntimeLibrary ofFile(FrameworkDependentFile f);
}
[CompilationMappingAttribute]
public static class Paket.SemVer : object {
    [CompilationMappingAttribute]
internal static Regex validContent { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, SemVerInfo> Parse { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<string, SemVerInfo> cache@54-2 { get; }
    [CompilationMappingAttribute]
public static SemVerInfo Zero { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<String[], String[]> SortVersions { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<String[], String[]> func1@1 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<String[], Tuple`2[]> func1@1-1 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<String[], Tuple`2[]> func1@1-2 { get; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<Tuple`2[], Tuple`2[]> func2@1 { get; }
    internal static FSharpOption`1<int> |Int|_|(string str);
    internal static FSharpOption`1<BigInteger> |Big|_|(string str);
    [CompilerGeneratedAttribute]
internal static bool contains@1(a e, FSharpList`1<a> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> expand(FSharpList`1<char> delimiter, string text);
    internal static Regex get_validContent();
    public static FSharpFunc`2<string, SemVerInfo> get_Parse();
    [CompilerGeneratedAttribute]
internal static Tuple`5<int, int, int, BigInteger, FSharpList`1<string>> Parse$cont@269-1(FSharpList`1<string> fragments, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`5<int, int, int, BigInteger, FSharpList`1<string>> Parse$cont@269(FSharpList`1<string> fragments, Unit unitVar);
    internal static string prerelease@280(FSharpList`1<string> suffix, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static SemVerInfo f@63-1(string version);
    internal static ConcurrentDictionary`2<string, SemVerInfo> get_cache@54-2();
    public static SemVerInfo get_Zero();
    public static FSharpFunc`2<String[], String[]> get_SortVersions();
    internal static FSharpFunc`2<String[], String[]> get_func1@1();
    internal static FSharpFunc`2<String[], Tuple`2[]> get_func1@1-1();
    internal static FSharpFunc`2<String[], Tuple`2[]> get_func1@1-2();
    internal static FSharpFunc`2<Tuple`2[], Tuple`2[]> get_func2@1();
    [CompilerGeneratedAttribute]
internal static String[] func2@1-1(Tuple`2[] array);
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[StructuredFormatDisplayAttribute("{AsString}")]
[CompilationMappingAttribute]
public class Paket.SemVerInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt32 Major@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt32 Minor@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt32 Patch@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<PreRelease> PreRelease@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal BigInteger Build@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string BuildMetaData@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Original@;
    [CompilationMappingAttribute]
public UInt32 Major { get; }
    [CompilationMappingAttribute]
public UInt32 Minor { get; }
    [CompilationMappingAttribute]
public UInt32 Patch { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<PreRelease> PreRelease { get; }
    [CompilationMappingAttribute]
public BigInteger Build { get; }
    [CompilationMappingAttribute]
public string BuildMetaData { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<string> Original { get; }
    public string AsString { get; }
    [DynamicDependencyAttribute("1632", "Paket.SemVerInfo")]
public SemVerInfo(UInt32 major, UInt32 minor, UInt32 patch, FSharpOption`1<PreRelease> preRelease, BigInteger build, string buildMetaData, FSharpOption`1<string> original);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public UInt32 get_Major();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public UInt32 get_Minor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public UInt32 get_Patch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<PreRelease> get_PreRelease();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public BigInteger get_Build();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_BuildMetaData();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Original();
    public string Normalize();
    public string NormalizeToShorter();
    public virtual string ToString();
    public string get_AsString();
    public bool Equals(SemVerInfo y);
    public virtual bool Equals(object yobj);
    public virtual int GetHashCode();
    public int CompareTo(SemVerInfo y);
    private virtual override int System.IComparable.CompareTo(object yobj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.SemVerUpdateMode : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemVerUpdateMode _unique_NoRestriction;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemVerUpdateMode _unique_KeepMajor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemVerUpdateMode _unique_KeepMinor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SemVerUpdateMode _unique_KeepPatch;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemVerUpdateMode NoRestriction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoRestriction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemVerUpdateMode KeepMajor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsKeepMajor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemVerUpdateMode KeepMinor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsKeepMinor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SemVerUpdateMode KeepPatch { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsKeepPatch { get; }
    private static SemVerUpdateMode();
    [DynamicDependencyAttribute("2016", "Paket.SemVerUpdateMode")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SemVerUpdateMode(int _tag);
    [CompilationMappingAttribute]
public static SemVerUpdateMode get_NoRestriction();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoRestriction();
    [CompilationMappingAttribute]
public static SemVerUpdateMode get_KeepMajor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsKeepMajor();
    [CompilationMappingAttribute]
public static SemVerUpdateMode get_KeepMinor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsKeepMinor();
    [CompilationMappingAttribute]
public static SemVerUpdateMode get_KeepPatch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsKeepPatch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SemVerUpdateMode obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SemVerUpdateMode obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.SilverlightVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SilverlightVersion _unique_V3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SilverlightVersion _unique_V4;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SilverlightVersion _unique_V5;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SilverlightVersion V3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SilverlightVersion V4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SilverlightVersion V5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV5 { get; }
    private static SilverlightVersion();
    [DynamicDependencyAttribute("2016", "Paket.SilverlightVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SilverlightVersion(int _tag);
    [CompilationMappingAttribute]
public static SilverlightVersion get_V3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3();
    [CompilationMappingAttribute]
public static SilverlightVersion get_V4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4();
    [CompilationMappingAttribute]
public static SilverlightVersion get_V5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SilverlightVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string ShortString();
    public virtual string ToString();
    public static FSharpOption`1<SilverlightVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SilverlightVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.Simplifier : object {
    internal static Result`2<IEnumerable`1<e>, f> findTransitive(a groupName, FSharpList`1<b> packages, FSharpMap`2<Tuple`2<a, c>, d> flatLookup, FSharpFunc`2<b, c> nameF, FSharpFunc`2<c, f> failureF);
    internal static bool removePackage(a packageName, bool hasPackageSettings, IEnumerable`1<a> transitivePackages, string fileName, bool interactive);
    public static Result`2<DependenciesFile, DomainMessage> simplifyDependenciesFile(DependenciesFile dependenciesFile, GroupName groupName, FSharpMap`2<Tuple`2<GroupName, PackageName>, a> flatLookup, bool interactive);
    public static Result`2<ReferencesFile, DomainMessage> simplifyReferencesFile(ReferencesFile refFile, GroupName groupName, FSharpMap`2<Tuple`2<GroupName, PackageName>, a> flatLookup, bool interactive);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<PaketEnv, PaketEnv> beforeAndAfter(PaketEnv environment, DependenciesFile dependenciesFile, FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> projects);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Tuple`2<PaketEnv, PaketEnv>, DomainMessage> simplify(bool interactive, PaketEnv environment);
    public static void updateEnvironment(PaketEnv before, PaketEnv after);
}
[CompilationMappingAttribute]
public class Paket.SolutionFile : object {
    internal string fileName;
    internal FSharpList`1<string> originalContent;
    internal Encoding originalEncoding;
    internal List`1<string> content;
    internal FSharpList`1<string> projectSectionLines;
    public string FileName { get; }
    public SolutionFile(string fileName);
    public string get_FileName();
    public void RemoveNuGetEntries();
    public void AddPaketFolder(string dependenciesFile, FSharpOption`1<string> lockFile);
    public void Save();
    [CompilerGeneratedAttribute]
internal void removeNugetSlnFolderIfEmpty();
    [CompilerGeneratedAttribute]
internal Tuple`2<int, int> addPaketFolder();
    [CompilerGeneratedAttribute]
internal void addPaketFiles(int paketProjectIndex, int length, string dependenciesFile, FSharpOption`1<string> lockFile);
}
[CompilationMappingAttribute]
public static class Paket.SupportCalculation : object {
    [CompilationMappingAttribute]
internal static FSharpOption`1<ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>>> supportMap { get; internal set; }
    [CompilationMappingAttribute]
internal static FSharpFunc`2<FSharpList`1<FrameworkIdentifier>, TargetProfile> findPortablePriv { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<FSharpList`1<FrameworkIdentifier>, TargetProfile> cache@54-4 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<TargetProfile, FSharpSet`1<TargetProfile>> getSupportedPlatformsTransitive { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<TargetProfile, FSharpSet`1<TargetProfile>> cache@54-5 { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<TargetProfile, FSharpSet`1<TargetProfile>> getPlatformsSupporting { get; }
    [CompilationMappingAttribute]
internal static ConcurrentDictionary`2<TargetProfile, FSharpSet`1<TargetProfile>> cache@54-6 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isSupportedNotEqual(PortableProfileType portable, PortableProfileType other);
    public static FSharpList`1<TargetProfile> getSupported(PortableProfileType portable);
    public static ConcurrentDictionary`2<a, b> ofSeq(IEnumerable`1<Tuple`2<a, b>> s);
    public static IEnumerable`1<Tuple`2<a, b>> toSeq(IEnumerable`1<KeyValuePair`2<a, b>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<PortableProfileType> buildSupportMap(ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>> supportMap, PortableProfileType p);
    [CompilerGeneratedAttribute]
internal static bool contains@1-2(a e, FSharpList`1<a> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-3(a e, FSharpList`1<a> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>> filterMap(int pos, ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>> supportMap);
    public static ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>> optimizeSupportMap(ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>> supportMap);
    internal static FSharpList`1<PortableProfileType> getSupportedPortables(PortableProfileType p);
    public static ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>> createInitialSupportMap();
    internal static FSharpOption`1<ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>>> get_supportMap();
    internal static void set_supportMap(FSharpOption`1<ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>>> value);
    internal static ConcurrentDictionary`2<PortableProfileType, FSharpList`1<PortableProfileType>> getSupportMap();
    public static FSharpList`1<PortableProfileType> getSupportedPreCalculated(PortableProfileType p);
    internal static FSharpFunc`2<FSharpList`1<FrameworkIdentifier>, TargetProfile> get_findPortablePriv();
    [CompilerGeneratedAttribute]
internal static TargetProfile f@63-3(FSharpList`1<FrameworkIdentifier> fws);
    internal static ConcurrentDictionary`2<FSharpList`1<FrameworkIdentifier>, TargetProfile> get_cache@54-4();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TargetProfile findPortable(bool warn, FSharpList`1<FrameworkIdentifier> fws);
    public static FSharpSet`1<TargetProfile> getSupportedPlatforms(TargetProfile x);
    public static FSharpFunc`2<TargetProfile, FSharpSet`1<TargetProfile>> get_getSupportedPlatformsTransitive();
    internal static FSharpSet`1<TargetProfile> findNewPlats@2113-3(FSharpSet`1<TargetProfile> known, FSharpSet`1<TargetProfile> lastStep);
    [CompilerGeneratedAttribute]
internal static FSharpSet`1<TargetProfile> f@63-4(TargetProfile x);
    internal static ConcurrentDictionary`2<TargetProfile, FSharpSet`1<TargetProfile>> get_cache@54-5();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool isSupportedBy(TargetProfile x, TargetProfile y);
    public static FSharpFunc`2<TargetProfile, FSharpSet`1<TargetProfile>> get_getPlatformsSupporting();
    internal static FSharpSet`1<TargetProfile> calculate@2151(TargetProfile x);
    internal static ConcurrentDictionary`2<TargetProfile, FSharpSet`1<TargetProfile>> get_cache@54-6();
}
[CustomEqualityAttribute]
[CustomComparisonAttribute]
[CompilationMappingAttribute]
public class Paket.TargetProfile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TargetProfileRaw RawTargetProfile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string CompareString@;
    [CompilationMappingAttribute]
public TargetProfileRaw RawTargetProfile { get; }
    [CompilationMappingAttribute]
public string CompareString { get; }
    public bool IsUnsupportedPortable { get; }
    public FSharpList`1<FrameworkIdentifier> Frameworks { get; }
    public FSharpSet`1<TargetProfile> PlatformsSupporting { get; }
    public FSharpSet`1<TargetProfile> SupportedPlatformsTransitive { get; }
    public FSharpSet`1<TargetProfile> SupportedPlatforms { get; }
    [DynamicDependencyAttribute("1632", "Paket.TargetProfile")]
public TargetProfile(TargetProfileRaw rawTargetProfile, string compareString);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TargetProfileRaw get_RawTargetProfile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_CompareString();
    public virtual string ToString();
    public bool get_IsUnsupportedPortable();
    public virtual bool Equals(object y);
    public virtual int GetHashCode();
    private virtual override int System.IComparable.CompareTo(object y);
    public FSharpList`1<FrameworkIdentifier> get_Frameworks();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TargetProfile FindPortable(bool warnWhenUnsupported, FSharpList`1<FrameworkIdentifier> fws);
    public FSharpSet`1<TargetProfile> get_PlatformsSupporting();
    public bool IsSupportedBy(TargetProfile y);
    public bool IsAtLeast(TargetProfile y);
    public FSharpSet`1<TargetProfile> get_SupportedPlatformsTransitive();
    public FSharpSet`1<TargetProfile> get_SupportedPlatforms();
    public bool IsSmallerThan(TargetProfile y);
    public bool IsSmallerThanOrEqual(TargetProfile y);
    public bool IsBetween(TargetProfile a, TargetProfile b);
}
[CompilationMappingAttribute]
public static class Paket.TargetProfileModule : object {
    public static FSharpChoice`2<FrameworkIdentifier, PortableProfileType> |SinglePlatform|PortableProfile|(TargetProfile profile);
    public static TargetProfile OfPlatform(TargetProfileRaw p);
    public static TargetProfile SinglePlatform(FrameworkIdentifier s);
    public static TargetProfile PortableProfile(PortableProfileType s);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.TargetProfileRaw : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSinglePlatformP { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPortableProfileP { get; }
    public bool IsUnsupportedPortable { get; }
    [CompilationMappingAttribute]
public static TargetProfileRaw NewSinglePlatformP(FrameworkIdentifier item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSinglePlatformP();
    [CompilationMappingAttribute]
public static TargetProfileRaw NewPortableProfileP(PortableProfileType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPortableProfileP();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TargetProfileRaw obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public bool get_IsUnsupportedPortable();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TargetProfileRaw obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public static class Paket.TargetsFolder : object {
    public static IEnumerable`1<T> getAllFiles(TargetsFolder`1<FSharpSet`1<T>> folder);
    public static bool isEmpty(TargetsFolder`1<FSharpSet`1<a>> folder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TargetsFolder`1<b> map(FSharpFunc`2<a, b> f, TargetsFolder`1<a> folder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TargetsFolder`1<a> mapFrameworkFolders(FSharpFunc`2<FrameworkFolder`1<a>, FrameworkFolder`1<a>> f, TargetsFolder`1<a> folder);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute]
public class Paket.TargetsFolder`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal T RootContents@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FrameworkFolder`1<T>> FrameworkFolders@;
    [CompilationMappingAttribute]
public string Name { get; }
    [CompilationMappingAttribute]
public T RootContents { get; }
    [CompilationMappingAttribute]
public FSharpList`1<FrameworkFolder`1<T>> FrameworkFolders { get; }
    [DynamicDependencyAttribute("1632", "Paket.TargetsFolder`1")]
public TargetsFolder`1(string name, T rootContents, FSharpList`1<FrameworkFolder`1<T>> frameworkFolders);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public T get_RootContents();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FrameworkFolder`1<T>> get_FrameworkFolders();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TargetsFolder`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TargetsFolder`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.TemplateFile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FileName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TemplateFileContents Contents@;
    [CompilationMappingAttribute]
public string FileName { get; }
    [CompilationMappingAttribute]
public TemplateFileContents Contents { get; }
    public bool IncludeReferencedProjects { get; }
    public FSharpOption`1<InterprojectReferencesConstraint> InterprojectReferencesConstraint { get; }
    [DynamicDependencyAttribute("1632", "Paket.TemplateFile")]
public TemplateFile(string fileName, TemplateFileContents contents);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TemplateFileContents get_Contents();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TemplateFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_IncludeReferencedProjects();
    public FSharpOption`1<InterprojectReferencesConstraint> get_InterprojectReferencesConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TemplateFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.TemplateFileContents : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCompleteInfo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProjectInfo { get; }
    [CompilationMappingAttribute]
public static TemplateFileContents NewCompleteInfo(Tuple`2<CompleteCoreInfo, OptionalPackagingInfo> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCompleteInfo();
    [CompilationMappingAttribute]
public static TemplateFileContents NewProjectInfo(ProjectCoreInfo item1, OptionalPackagingInfo item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProjectInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TemplateFileContents obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TemplateFileContents obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute]
[CompilationMappingAttribute]
internal static class Paket.TemplateFileModule : object {
    [CompilationMappingAttribute]
internal static Regex isExclude { get; }
    [CompilationMappingAttribute]
internal static Regex isComment { get; }
    internal static FSharpOption`1<string> tryGetId(TemplateFile templateFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile setVersion(FSharpOption`1<SemVerInfo> version, FSharpMap`2<string, SemVerInfo> specificVersions, TemplateFile templateFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile setReleaseNotes(string releaseNotes, TemplateFile templateFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TemplateFile setProjectUrl(string url, TemplateFile templateFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`2<a, DomainMessage> failP(string file, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`2<PackageConfigType, DomainMessage> parsePackageConfigType(string file, FSharpMap`2<string, string> map);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`2<a, DomainMessage> getId(string file, FSharpMap`2<string, a> map);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`2<FSharpList`1<string>, DomainMessage> getAuthors(string file, FSharpMap`2<string, string> map);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Result`2<a, DomainMessage> getDescription(string file, FSharpMap`2<string, a> map);
    internal static FSharpOption`1<FSharpOption`1<FrameworkIdentifier>> |Framework|_|(string line);
    internal static FSharpOption`1<string> |Empty|_|(string line);
    [CompilerGeneratedAttribute]
internal static SemVerInfo sourceVersion$cont@327(LockFile lockFile, string fileName, PackageName packageName, string requireText, Match m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int segmentCount$cont@365(string line, string fileName, String[] versionParts, Group spec, Unit unitVar);
    internal static string versionReplace@321(FSharpMap`2<string, SemVerInfo> specificVersions, LockFile lockFile, string line, string fileName, FSharpOption`1<SemVerInfo> currentVersion, PackageName packageName, Regex regVersion, string requireText);
    internal static FSharpOption`1<Tuple`2<PackageName, VersionRequirement>> getDependencyByLine(string fileName, LockFile lockFile, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, SemVerInfo> specificVersions, string line, FSharpOption`1<FrameworkIdentifier> framework);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, FSharpList`1<OptionalDependencyGroup>> getDependenciesByTargetFramework(string fileName, LockFile lockFile, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, SemVerInfo> specificVersions, int lineNo, FSharpList`1<OptionalDependencyGroup> state, string line);
    internal static FSharpList`1<OptionalDependencyGroup> getDependencyGroups(string fileName, LockFile lockFile, FSharpMap`2<string, string> info, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, SemVerInfo> specificVersions);
    internal static FSharpList`1<PackageName> getExcludedDependencies(FSharpMap`2<string, string> info);
    internal static FSharpList`1<GroupName> getExcludedGroups(FSharpMap`2<string, string> info);
    internal static Regex get_isExclude();
    internal static Regex get_isComment();
    internal static FSharpList`1<Tuple`2<string, string>> getFiles(FSharpMap`2<string, string> map);
    internal static FSharpList`1<string> getFileExcludes(FSharpMap`2<string, string> map);
    internal static FSharpList`1<string> getReferences(FSharpMap`2<string, string> map);
    internal static FSharpList`1<string> getFrameworkReferences(FSharpMap`2<string, string> map);
    internal static FSharpOption`1<InterprojectReferencesConstraint> getInterprojectReferencesConstraint(FSharpMap`2<string, string> map);
    internal static OptionalPackagingInfo getOptionalInfo(string fileName, LockFile lockFile, FSharpMap`2<string, string> map, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, SemVerInfo> specificVersions);
    internal static FSharpOption`1<SemVerInfo> resolveCurrentVersion@579(FSharpMap`2<string, SemVerInfo> specificVersions, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, string> map, FSharpOption`1<string> id);
    internal static Result`2<TemplateFileContents, DomainMessage> Parse(string file, LockFile lockFile, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, SemVerInfo> specificVersions, Stream contentStream);
    [CompilerGeneratedAttribute]
internal static TemplateFileContents clo0@1-1(IEnumerable`1<DomainMessage> msgs);
    internal static TemplateFile ParseFromFile(string fileName, LockFile lockFile, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, SemVerInfo> specificVersions);
    internal static FSharpList`1<Tuple`2<string, string>> getFiles@629-1(TemplateFile parsed, string root, IEnumerable`1<Tuple`2<string, string>> files);
    internal static TemplateFile ValidateTemplate(TemplateFile parsed);
    internal static TemplateFile Load(string fileName, LockFile lockFile, FSharpOption`1<SemVerInfo> currentVersion, FSharpMap`2<string, SemVerInfo> specificVersions);
    [CompilerGeneratedAttribute]
internal static PackageConfigType clo0@1-2(IEnumerable`1<DomainMessage> msgs);
    internal static bool IsProjectType(string filename);
    internal static IEnumerable`1<string> FindTemplateFiles(string root);
}
[CompilationMappingAttribute]
internal static class Paket.TemplateParser : object {
    [CompilationMappingAttribute]
internal static Regex single { get; }
    [CompilationMappingAttribute]
internal static Regex multi { get; }
    [CompilationMappingAttribute]
internal static Regex comment { get; }
    [CompilationMappingAttribute]
internal static Regex indented { get; }
    internal static Regex get_single();
    internal static Regex get_multi();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string op_BangBang(int i, Match m);
    internal static FSharpOption`1<string> |SingleToken|_|(string line);
    internal static FSharpOption`1<Tuple`2<string, string>> |MultiToken|_|(string line);
    internal static Regex get_comment();
    internal static bool Comment(string line);
    internal static Regex get_indented();
    internal static FSharpOption`1<string> |Indented|_|(string line);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<string, int, FSharpList`1<string>> indentedBlock(FSharpList`1<string> acc, int i, FSharpList`1<string> lines);
    internal static FSharpChoice`2<FSharpMap`2<string, string>, string> inner(ParserState state);
    internal static FSharpChoice`2<FSharpMap`2<string, string>, string> parse(string contents);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.TizenVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TizenVersion _unique_V3;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TizenVersion _unique_V4;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TizenVersion V3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV3 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TizenVersion V4 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV4 { get; }
    private static TizenVersion();
    [DynamicDependencyAttribute("2016", "Paket.TizenVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TizenVersion(int _tag);
    [CompilationMappingAttribute]
public static TizenVersion get_V3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV3();
    [CompilationMappingAttribute]
public static TizenVersion get_V4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TizenVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string ShortString();
    public virtual string ToString();
    public static FSharpOption`1<TizenVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TizenVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.UAPVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UAPVersion _unique_V10;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UAPVersion _unique_V10_0_10240;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UAPVersion _unique_V10_0_14393;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UAPVersion _unique_V10_0_15138;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UAPVersion _unique_V10_0_16299;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UAPVersion _unique_V10_0_16300;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UAPVersion _unique_V10_0_18362;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static UAPVersion _unique_V10_1;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UAPVersion V10 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UAPVersion V10_0_10240 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_10240 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UAPVersion V10_0_14393 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_14393 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UAPVersion V10_0_15138 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_15138 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UAPVersion V10_0_16299 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_16299 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UAPVersion V10_0_16300 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_16300 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UAPVersion V10_0_18362 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_0_18362 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static UAPVersion V10_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10_1 { get; }
    public string NetCoreVersion { get; }
    private static UAPVersion();
    [DynamicDependencyAttribute("2016", "Paket.UAPVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UAPVersion(int _tag);
    [CompilationMappingAttribute]
public static UAPVersion get_V10();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10();
    [CompilationMappingAttribute]
public static UAPVersion get_V10_0_10240();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_10240();
    [CompilationMappingAttribute]
public static UAPVersion get_V10_0_14393();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_14393();
    [CompilationMappingAttribute]
public static UAPVersion get_V10_0_15138();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_15138();
    [CompilationMappingAttribute]
public static UAPVersion get_V10_0_16299();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_16299();
    [CompilationMappingAttribute]
public static UAPVersion get_V10_0_16300();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_16300();
    [CompilationMappingAttribute]
public static UAPVersion get_V10_0_18362();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_0_18362();
    [CompilationMappingAttribute]
public static UAPVersion get_V10_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(UAPVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public string ShortString();
    public string get_NetCoreVersion();
    public static FSharpOption`1<UAPVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UAPVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.UpdateProcess : object {
    internal static DependenciesFile processFile@13(LockFile lockFile, DependenciesFile dependenciesFile, FSharpFunc`2<SemVerInfo, string> createRequirementF);
    internal static string formatPrerelease@30(SemVerInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Tuple`2<LockFile, FSharpMap`2<GroupName, DependenciesGroup>> selectiveUpdate(bool force, FSharpFunc`2<Origin, FSharpFunc`2<string, FSharpFunc`2<string, FSharpFunc`2<VersionRestriction, FSharpFunc`2<FSharpOption`1<string>, string>>>>> getSha1, FSharpFunc`2<GetPackageVersionsParameters, FSharpAsync`1<IEnumerable`1<Tuple`2<SemVerInfo, FSharpList`1<PackageSource>>>>> getVersionsF, FSharpFunc`2<GetPackageDetailsParameters, FSharpAsync`1<PackageDetails>> getPackageDetailsF, FSharpFunc`2<FSharpOption`1<PackagesFolderGroupConfig>, FSharpFunc`2<GroupName, FSharpFunc`2<ResolvedPackage, FSharpOption`1<RuntimeGraph>>>> getRuntimeGraphFromPackage, LockFile lockFile, DependenciesFile dependenciesFile, UpdateMode updateMode, SemVerUpdateMode semVerUpdateMode);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> clo0@1-5(IEnumerable`1<DomainMessage> msgs);
    public static DependenciesFile detectProjectFrameworksForDependenciesFile(DependenciesFile dependenciesFile);
    [CompilerGeneratedAttribute]
internal static void SelectiveUpdate$cont@266(FSharpList`1<Tuple`4<GroupName, PackageName, FSharpOption`1<SemVerInfo>, FSharpOption`1<SemVerInfo>>> touchedPackages, Unit unitVar);
    public static Tuple`4<LockFile, bool, FSharpMap`2<GroupName, DependenciesGroup>, FSharpList`1<Tuple`4<GroupName, PackageName, FSharpOption`1<SemVerInfo>, FSharpOption`1<SemVerInfo>>>> SelectiveUpdate(DependenciesFile dependenciesFile, FSharpOption`1<string> alternativeProjectRoot, UpdateMode updateMode, SemVerUpdateMode semVerUpdateMode, bool force);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`2<ProjectFile, ReferencesFile>> clo0@1-6(IEnumerable`1<DomainMessage> msgs);
    public static bool SmartInstall(DependenciesFile dependenciesFile, UpdateMode updateMode, UpdaterOptions options);
    public static bool UpdatePackage(string dependenciesFileName, GroupName groupName, PackageName packageName, FSharpOption`1<string> newVersion, UpdaterOptions options);
    public static bool UpdateFilteredPackages(string dependenciesFileName, GroupName groupName, string packageName, FSharpOption`1<string> newVersion, UpdaterOptions options);
    public static bool UpdateGroup(string dependenciesFileName, GroupName groupName, UpdaterOptions options);
    public static bool Update(string dependenciesFileName, UpdaterOptions options);
}
[CompilationMappingAttribute]
public class Paket.UpdaterOptions : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal InstallerOptions Common@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool NoInstall@;
    [CompilationMappingAttribute]
public InstallerOptions Common { get; }
    [CompilationMappingAttribute]
public bool NoInstall { get; }
    public static UpdaterOptions Default { get; }
    [DynamicDependencyAttribute("1632", "Paket.UpdaterOptions")]
public UpdaterOptions(InstallerOptions common, bool noInstall);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public InstallerOptions get_Common();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_NoInstall();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(UpdaterOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static UpdaterOptions get_Default();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UpdaterOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute]
public static class Paket.Utils : object {
    public static string acceptXml { get; }
    public static string acceptJson { get; }
    [CompilationMappingAttribute]
public static FSharpFunc`2<string, bool> notNullOrEmpty { get; }
    [CompilationMappingAttribute]
public static string ProgramFiles { get; }
    [CompilationMappingAttribute]
public static string ProgramFilesX86 { get; }
    [CompilationMappingAttribute]
internal static string wow64@241 { get; }
    [CompilationMappingAttribute]
internal static string globalArch@242 { get; }
    [CompilationMappingAttribute]
internal static string arg@1-1 { get; }
    [CompilationMappingAttribute]
internal static string detected@248 { get; }
    [CompilationMappingAttribute]
public static string SystemRoot { get; }
    [CompilationMappingAttribute]
public static bool isMonoRuntime { get; }
    [CompilationMappingAttribute]
public static bool isUnix { get; }
    [CompilationMappingAttribute]
public static bool isMacOS { get; }
    [CompilationMappingAttribute]
public static bool isLinux { get; }
    [CompilationMappingAttribute]
public static bool isWindows { get; }
    [ObsoleteAttribute("use either isMonoRuntime or isUnix, this flag is always false when compiled for NETSTANDARD")]
public static bool isMono { get; }
    [CompilationMappingAttribute]
public static string monoPath { get; }
    [CompilationMappingAttribute]
public static FSharpOption`1<bool> autoAnswer { get; public set; }
    [CompilationMappingAttribute]
public static string dirSeparator { get; }
    [CompilationMappingAttribute]
internal static char copyOfStruct@385-1 { get; internal set; }
    public static b sndOf3(a _arg1, b v, c _arg2);
    public static c thirdOf3(a _arg1, b _arg2, c v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static c rethrowf(FSharpFunc`2<Tuple`2<string, a>, b> f, a inner, PrintfFormat`4<c, Unit, string, d> fmt);
    public static string quote(string str);
    public static bool isNotNull(a x);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_acceptXml();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_acceptJson();
    public static FSharpFunc`2<string, bool> get_notNullOrEmpty();
    public static a force(Lazy`1<a> lz);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool endsWith(string text, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool endsWith$W(FSharpFunc`2<a, FSharpFunc`2<string, bool>> endsWith, string text, a x);
    public static string toLower(a str);
    public static string toLower$W(FSharpFunc`2<a, string> toLower, a str);
    internal static string removeInvalidChars(string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<v> tryGet(k key, a this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<v> tryGet$W(FSharpFunc`2<a, FSharpFunc`2<k, FSharpFunc`2<v&, bool>>> tryGetValue, k key, a this);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<a, b>, FSharpFunc`2<Tuple`2<key, b>, Unit>> memoizeByExt(FSharpFunc`2<a, key> getKey, FSharpFunc`2<a, b> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<a, b> memoizeBy(FSharpFunc`2<a, key> getKey, FSharpFunc`2<a, b> f);
    internal static FSharpFunc`2<a, b> memoize(FSharpFunc`2<a, b> f);
    [CompilerGeneratedAttribute]
internal static FSharpAsync`1<Unit> catchHandler@1(TaskCompletionSource`1<o> tcs, FSharpRef`1<TaskCompletionSource`1<Tuple`2<o, oext>>> tcs_result, Exception exn);
    internal static FSharpFunc`2<iext, FSharpFunc`2<i, MemoizeAsyncExResult`2<oext, o>>> memoizeAsyncEx(FSharpFunc`2<iext, FSharpFunc`2<i, FSharpAsync`1<Tuple`2<o, oext>>>> f);
    internal static FSharpFunc`2<a, FSharpAsync`1<b>> memoizeAsync(FSharpFunc`2<a, FSharpAsync`1<b>> f);
    public static string TimeSpanToReadableString(TimeSpan span);
    public static string GetHomeDirectory();
    public static PathReference normalizeLocalPath(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DirectoryInfo getDirectoryInfoForLocalNuGetFeed(PathReference pathInfo, FSharpOption`1<string> alternativeProjectRoot, string root);
    public static FileInfo FileInfo(string str);
    public static DirectoryInfo DirectoryInfo(string str);
    public static Result`2<Unit, DomainMessage> createDir(string path);
    public static void emptyDir(DirectoryInfo dirInfo);
    public static void deleteDir(DirectoryInfo dirInfo);
    public static void CleanDir(string path);
    public static Encoding getFileEncoding(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string createRelativePath(string root, string path);
    public static string get_ProgramFiles();
    public static string get_ProgramFilesX86();
    internal static string get_wow64@241();
    internal static string get_globalArch@242();
    internal static string get_arg@1-1();
    internal static string get_detected@248();
    public static string get_SystemRoot();
    public static bool get_isMonoRuntime();
    public static bool get_isUnix();
    public static bool get_isMacOS();
    public static bool get_isLinux();
    public static bool get_isWindows();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static bool get_isMono();
    public static string get_monoPath();
    public static bool isMatchingOperatingSystem(FSharpOption`1<string> operatingSystemFilter);
    public static bool isMatchingPlatform(FSharpOption`1<string> operatingSystemFilter);
    public static string normalizeXml(XmlDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Unit, DomainMessage> saveNormalizedXml(string fileName, XmlDocument doc);
    public static FSharpOption`1<bool> get_autoAnswer();
    public static void set_autoAnswer(FSharpOption`1<bool> value);
    public static string readAnswer();
    internal static bool getAnswer@372(string question, Unit unitVar0);
    public static bool askYesNo(string question);
    public static string get_dirSeparator();
    internal static char get_copyOfStruct@385-1();
    internal static void set_copyOfStruct@385-1(char value);
    public static string normalizeHomeDirectory(string path);
    public static string normalizePath(string path);
    public static string windowsPath(string path);
    public static FileInfo[] FindAllFiles(string folder, string pattern);
    internal static string parentPath@438(PackagesFolderGroupConfig x, string root, GroupName groupName, PackageName packageName, a version, bool includeVersionInPath, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void runDotnet(string workingDir, string arguments);
    internal static void acquireLock@478(Process currentProcess, string fileName, string pid, DateTime startTime, TimeSpan timeOut, int trials);
    internal static void releaseLock@518(string fileName, string pid, int trials);
    public static void RunInLockedAccessMode(string lockedFolder, FSharpFunc`2<Unit, bool> lockedAction);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<a> op_PlusPlus(FSharpOption`1<a> x, FSharpOption`1<a> y);
    internal static void add@634(List`1<Tuple`2<string, string>> l, string key, string value);
    internal static bool restHasKey@645(string s, int pos, Unit unitVar0);
    public static Dictionary`2<string, string> parseKeyValuePairs(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`2<Unit, DomainMessage> saveFile(string fileName, string contents);
    public static Result`2<Unit, DomainMessage> removeFile(string fileName);
    public static string normalizeLineEndings(string text);
    internal static string stripComment@701(string text, int pos);
    internal static string remove@704(string text, int startAt);
    public static string removeComment(string text);
    public static string getSha512Stream(Stream stream);
    public static string getSha512File(string filePath);
    public static void fixDatesInArchive(string fileName);
    public static void fixArchive(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void extractZipToDirectory(string zipFileName, string directoryName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void StringBuilder.AddLine(StringBuilder self, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static a StringBuilder.AppendLinef(StringBuilder self, PrintfFormat`4<a, Unit, string, StringBuilder> text);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public abstract class Paket.VersionRange : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMinimum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGreaterThan { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMaximum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLessThan { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSpecific { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOverrideAll { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRange { get; }
    public static FSharpList`1<string> BasicOperators { get; }
    public static FSharpList`1<char> StrategyOperators { get; }
    public bool IsGlobalOverride { get; }
    public PreReleaseStatus GetPreReleaseStatus { get; }
    [DynamicDependencyAttribute("2016", "Paket.VersionRange")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal VersionRange(int _tag);
    [CompilationMappingAttribute]
public static VersionRange NewMinimum(SemVerInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMinimum();
    [CompilationMappingAttribute]
public static VersionRange NewGreaterThan(SemVerInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGreaterThan();
    [CompilationMappingAttribute]
public static VersionRange NewMaximum(SemVerInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMaximum();
    [CompilationMappingAttribute]
public static VersionRange NewLessThan(SemVerInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLessThan();
    [CompilationMappingAttribute]
public static VersionRange NewSpecific(SemVerInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSpecific();
    [CompilationMappingAttribute]
public static VersionRange NewOverrideAll(SemVerInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOverrideAll();
    [CompilationMappingAttribute]
public static VersionRange NewRange(VersionRangeBound _fromB, SemVerInfo _from, SemVerInfo __to, VersionRangeBound __toB);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(VersionRange obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static VersionRange AtLeast(string version);
    public static VersionRange AtMost(string version);
    public static FSharpList`1<string> get_BasicOperators();
    public static FSharpList`1<char> get_StrategyOperators();
    public static VersionRange Exactly(string version);
    public static VersionRange Between(VersionRangeBound lower, SemVerInfo minimum, SemVerInfo maximum, VersionRangeBound upper);
    public static VersionRange Between(VersionRangeBound lower, string version1, string version2, VersionRangeBound upper);
    public static VersionRange Between(string minimum, string maximum);
    public static VersionRange Between(SemVerInfo minimum, SemVerInfo maximum);
    public bool get_IsGlobalOverride();
    public bool IsIncludedIn(VersionRange other);
    public PreReleaseStatus get_GetPreReleaseStatus();
    public bool IsConflicting(VersionRange other);
    public bool IsConflicting(Tuple`3<VersionRange, PreReleaseStatus, PreReleaseStatus> tuple);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VersionRange obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.VersionRangeBound : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static VersionRangeBound _unique_Excluding;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static VersionRangeBound _unique_Including;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static VersionRangeBound Excluding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExcluding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static VersionRangeBound Including { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIncluding { get; }
    private static VersionRangeBound();
    [DynamicDependencyAttribute("2016", "Paket.VersionRangeBound")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal VersionRangeBound(int _tag);
    [CompilationMappingAttribute]
public static VersionRangeBound get_Excluding();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExcluding();
    [CompilationMappingAttribute]
public static VersionRangeBound get_Including();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIncluding();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(VersionRangeBound obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VersionRangeBound obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.VersionRequirement : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal VersionRange item1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreReleaseStatus item2;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public VersionRange Item1 { get; }
    [CompilationMappingAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreReleaseStatus Item2 { get; }
    public VersionRange Range { get; }
    public PreReleaseStatus PreReleases { get; }
    public static VersionRequirement AllReleases { get; }
    public static VersionRequirement NoRestriction { get; }
    [DynamicDependencyAttribute("1632", "Paket.VersionRequirement")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal VersionRequirement(VersionRange item1, PreReleaseStatus item2);
    [CompilationMappingAttribute]
public static VersionRequirement NewVersionRequirement(VersionRange item1, PreReleaseStatus item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public VersionRange get_Item1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreReleaseStatus get_Item2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(VersionRequirement obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool IsInRange(SemVerInfo version, FSharpOption`1<bool> ignorePrerelease);
    public VersionRange get_Range();
    public bool IsConflicting(VersionRequirement other);
    public PreReleaseStatus get_PreReleases();
    public static VersionRequirement get_AllReleases();
    public static VersionRequirement get_NoRestriction();
    public virtual string ToString();
    public static VersionRequirement Parse(string text);
    public static FSharpOption`1<VersionRequirement> TryParse(string text);
    public string FormatInNuGetSyntax();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VersionRequirement obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public class Paket.VersionStrategy : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal VersionRequirement VersionRequirement@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<ResolverStrategy> ResolverStrategy@;
    [CompilationMappingAttribute]
public VersionRequirement VersionRequirement { get; }
    [CompilationMappingAttribute]
public FSharpOption`1<ResolverStrategy> ResolverStrategy { get; }
    [DynamicDependencyAttribute("1632", "Paket.VersionStrategy")]
public VersionStrategy(VersionRequirement versionRequirement, FSharpOption`1<ResolverStrategy> resolverStrategy);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public VersionRequirement get_VersionRequirement();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<ResolverStrategy> get_ResolverStrategy();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(VersionStrategy obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VersionStrategy obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.VSIntegration : object {
    public static Result`2<Unit, DomainMessage> TurnOffAutoRestore(PaketEnv environment);
    public static Result`2<Unit, DomainMessage> TurnOnAutoRestore(PaketEnv environment);
}
[CompilationMappingAttribute]
public static class Paket.Why : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@16-58(LblPathNode`1<a> this, LblPathNode`1<a> obj, Unit unitVar);
    public static IDictionary`2<PackageName, IDictionary`2<PackageName, Tuple`2<VersionRequirement, FrameworkRestrictions>>> depGraph(FSharpMap`2<PackageName, ResolvedPackage> res);
    [CompilerGeneratedAttribute]
internal static void ohWhy$cont@187(WhyOptions options, FSharpMap`2<PackageName, ResolvedPackage> resolution, FSharpList`1<Tuple`2<PackageName, LblPathNode`1<Tuple`2<VersionRequirement, FrameworkRestrictions>>>> chains, Unit unitVar);
    public static void ohWhy(PackageName packageName, FSharpSet`1<PackageName> directDeps, LockFile lockFile, GroupName groupName, string usage, WhyOptions options);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.WindowsPhoneAppVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsPhoneAppVersion _unique_V8_1;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsPhoneAppVersion V8_1 { get; }
    private static WindowsPhoneAppVersion();
    [CompilationMappingAttribute]
public static WindowsPhoneAppVersion get_V8_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(WindowsPhoneAppVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string ShortString();
    public virtual string ToString();
    public static FSharpOption`1<WindowsPhoneAppVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(WindowsPhoneAppVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.WindowsPhoneVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsPhoneVersion _unique_V7;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsPhoneVersion _unique_V7_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsPhoneVersion _unique_V7_5;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsPhoneVersion _unique_V8;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsPhoneVersion _unique_V8_1;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsPhoneVersion V7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsPhoneVersion V7_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsPhoneVersion V7_5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV7_5 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsPhoneVersion V8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsPhoneVersion V8_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8_1 { get; }
    private static WindowsPhoneVersion();
    [DynamicDependencyAttribute("2016", "Paket.WindowsPhoneVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal WindowsPhoneVersion(int _tag);
    [CompilationMappingAttribute]
public static WindowsPhoneVersion get_V7();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7();
    [CompilationMappingAttribute]
public static WindowsPhoneVersion get_V7_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7_1();
    [CompilationMappingAttribute]
public static WindowsPhoneVersion get_V7_5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV7_5();
    [CompilationMappingAttribute]
public static WindowsPhoneVersion get_V8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8();
    [CompilationMappingAttribute]
public static WindowsPhoneVersion get_V8_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(WindowsPhoneVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string ShortString();
    public virtual string ToString();
    public static FSharpOption`1<WindowsPhoneVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(WindowsPhoneVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.WindowsVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsVersion _unique_V8;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsVersion _unique_V8_1;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static WindowsVersion _unique_V10;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsVersion V8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsVersion V8_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV8_1 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static WindowsVersion V10 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10 { get; }
    public string NetCoreVersion { get; }
    private static WindowsVersion();
    [DynamicDependencyAttribute("2016", "Paket.WindowsVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal WindowsVersion(int _tag);
    [CompilationMappingAttribute]
public static WindowsVersion get_V8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8();
    [CompilationMappingAttribute]
public static WindowsVersion get_V8_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV8_1();
    [CompilationMappingAttribute]
public static WindowsVersion get_V10();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_NetCoreVersion();
    public string ShortString();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(WindowsVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute]
public class Paket.XCodeVersion : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static XCodeVersion _unique_V10;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static XCodeVersion _unique_V11;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static XCodeVersion V10 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV10 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static XCodeVersion V11 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsV11 { get; }
    private static XCodeVersion();
    [DynamicDependencyAttribute("2016", "Paket.XCodeVersion")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal XCodeVersion(int _tag);
    [CompilationMappingAttribute]
public static XCodeVersion get_V10();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV10();
    [CompilationMappingAttribute]
public static XCodeVersion get_V11();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsV11();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(XCodeVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public string ShortString();
    public static FSharpOption`1<XCodeVersion> TryParse(string s);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(XCodeVersion obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute]
public static class Paket.Xml : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlElement addAttribute(string name, string value, XmlElement node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlElement addChild(XmlNode child, XmlElement node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool hasAttribute(string name, XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> getAttribute(string name, XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool withAttributeValue(string attributeName, string valueText, XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool withAttributeValueEndsWith(string attributeName, string valueText, XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<string> optGetAttribute(string name, FSharpOption`1<a> node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<XmlNode> getNode(string name, XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<XmlNode> optGetNode(string name, FSharpOption`1<a> node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<XmlNode> getNodes(string name, XmlNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<XmlNode> getDescendants(string name, XmlNode node);
    public static IEnumerable`1<XmlNode> getChildNodes(XmlNode node);
}
[CompilationMappingAttribute]
internal static class ProviderImplementation.AssemblyReader : object {
    [DebuggerBrowsableAttribute("0")]
internal static T258499_32Bytes@ field258500@;
    [DebuggerBrowsableAttribute("0")]
internal static T258545_8Bytes@ field258546@;
    internal static byte et_END { get; }
    internal static byte et_VOID { get; }
    internal static byte et_BOOLEAN { get; }
    internal static byte et_CHAR { get; }
    internal static byte et_I1 { get; }
    internal static byte et_U1 { get; }
    internal static byte et_I2 { get; }
    internal static byte et_U2 { get; }
    internal static byte et_I4 { get; }
    internal static byte et_U4 { get; }
    internal static byte et_I8 { get; }
    internal static byte et_U8 { get; }
    internal static byte et_R4 { get; }
    internal static byte et_R8 { get; }
    internal static byte et_STRING { get; }
    internal static byte et_PTR { get; }
    internal static byte et_BYREF { get; }
    internal static byte et_VALUETYPE { get; }
    internal static byte et_CLASS { get; }
    internal static byte et_VAR { get; }
    internal static byte et_ARRAY { get; }
    internal static byte et_WITH { get; }
    internal static byte et_TYPEDBYREF { get; }
    internal static byte et_I { get; }
    internal static byte et_U { get; }
    internal static byte et_FNPTR { get; }
    internal static byte et_OBJECT { get; }
    internal static byte et_SZARRAY { get; }
    internal static byte et_MVAR { get; }
    internal static byte et_CMOD_REQD { get; }
    internal static byte et_CMOD_OPT { get; }
    internal static byte et_SENTINEL { get; }
    internal static byte et_PINNED { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_FASTCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_STDCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_THISCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_CDECL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_VARARG { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_FIELD { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_LOCAL_SIG { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_PROPERTY { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_GENERICINST { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_GENERIC { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_INSTANCE { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_INSTANCE_EXPLICIT { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindAssemblyRef { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindModuleRef { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindFileRef { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindTypeRef { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindTypeSpec { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindTypeDef { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindPropertyMap { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindEventMap { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindInterfaceImpl { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindNested { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindCustomAttribute { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindDeclSecurity { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindMemberRef { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindStandAloneSig { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindFieldDef { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindFieldRVA { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindFieldMarshal { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindConstant { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindFieldLayout { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindParam { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindMethodDef { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindMethodImpl { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindImplMap { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindMethodSemantics { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindProperty { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindEvent { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindManifestResource { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindClassLayout { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindExportedType { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindAssembly { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindGenericParam_v1_1 { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindGenericParam_v2_0 { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindMethodSpec { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindGenericParamConstraint { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindModule { get; }
    [CompilationMappingAttribute]
internal static ILRowKind kindIllegal { get; }
    internal static string typeNameForGlobalFunctions { get; }
    [CompilationMappingAttribute]
internal static PublicKey EcmaPublicKey { get; }
    [CompilationMappingAttribute]
internal static ILScopeRef EcmaMscorlibScopeRef { get; }
    private static AssemblyReader();
    internal static char convDigit@234(int digit);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@533(ILFieldInit this, ILFieldInit obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@533-1(IComparer comp, ILFieldInit this, ILFieldInit objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@533(IEqualityComparer comp, ILFieldInit this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@533(ILFieldInit this, ILFieldInit that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@533-1(ILFieldInit this, ILFieldInit obj, Unit unitVar);
    internal static ILType[] typesOfILParamsRaw(ILParameter[] ps);
    internal static ILType[] typesOfILParamsList(ILParameter[] ps);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@856-1(IEqualityComparer comp, ILAssemblyManifest this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@856-2(ILAssemblyManifest this, ILAssemblyManifest that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_END();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VOID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BOOLEAN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CHAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_STRING();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_PTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BYREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VALUETYPE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CLASS();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_ARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_WITH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_TYPEDBYREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_FNPTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_SZARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_MVAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CMOD_REQD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CMOD_OPT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_SENTINEL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_PINNED();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_FASTCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_STDCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_THISCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_CDECL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_VARARG();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_FIELD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_LOCAL_SIG();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_PROPERTY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_GENERICINST();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_GENERIC();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_INSTANCE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_INSTANCE_EXPLICIT();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int op_GreaterGreaterGreaterAmp(int x, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int align(int alignment, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int uncodedToken(ILTableName tab, int idx);
    internal static Tuple`2<ILTableName, int> i32ToUncodedToken(int tok);
    internal static TaggedIndex`1<TypeDefOrRefOrSpecTag> uncodedTokenToTypeDefOrRefOrSpec(ILTableName tab, int tok);
    internal static TaggedIndex`1<MethodDefOrRefTag> uncodedTokenToMethodDefOrRef(ILTableName tab, int tok);
    internal static Tuple`2<T, int> |TaggedIndex|(TaggedIndex`1<T> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<a> tokToTaggedIdx(FSharpFunc`2<int, a> f, int nbits, int tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static byte seekReadByte(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] seekReadBytes(ByteFile is, int addr, int len);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadInt32(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ushort seekReadUInt16(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadByteAsInt32(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static long seekReadInt64(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadUInt16AsInt32(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadCompressedUInt32(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static sbyte seekReadSByte(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekCountUtf8String(ByteFile is, int addr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string seekReadUTF8String(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] seekReadBlob(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string seekReadUserString(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] seekReadGuid(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILTableName, int> seekReadUncodedToken(ByteFile is, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<byte, int> sigptrGetByte(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, int> sigptrGetBool(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<sbyte, int> sigptrGetSByte(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ushort, int> sigptrGetUInt16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<short, int> sigptrGetInt16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptrGetInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<UInt32, int> sigptrGetUInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ulong, int> sigptrGetUInt64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<long, int> sigptrGetInt64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<float, int> sigptrGetSingle(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<double, int> sigptrGetDouble(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptrGetZInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<a[], int> sigptrFoldAcc(FSharpFunc`2<Byte[], FSharpFunc`2<int, Tuple`2<a, int>>> f, int n, Byte[] bytes, int sigptr, int i, FSharpList`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<a[], int> sigptrFold(FSharpFunc`2<Byte[], FSharpFunc`2<int, Tuple`2<a, int>>> f, int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Byte[], int> sigptrGetBytes(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptrGetString(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILImageChunk, int> chunk(int sz, int next);
    internal static Tuple`2<ILImageChunk, a> nochunk(a next);
    internal static ILRowKind get_kindAssemblyRef();
    internal static ILRowKind get_kindModuleRef();
    internal static ILRowKind get_kindFileRef();
    internal static ILRowKind get_kindTypeRef();
    internal static ILRowKind get_kindTypeSpec();
    internal static ILRowKind get_kindTypeDef();
    internal static ILRowKind get_kindPropertyMap();
    internal static ILRowKind get_kindEventMap();
    internal static ILRowKind get_kindInterfaceImpl();
    internal static ILRowKind get_kindNested();
    internal static ILRowKind get_kindCustomAttribute();
    internal static ILRowKind get_kindDeclSecurity();
    internal static ILRowKind get_kindMemberRef();
    internal static ILRowKind get_kindStandAloneSig();
    internal static ILRowKind get_kindFieldDef();
    internal static ILRowKind get_kindFieldRVA();
    internal static ILRowKind get_kindFieldMarshal();
    internal static ILRowKind get_kindConstant();
    internal static ILRowKind get_kindFieldLayout();
    internal static ILRowKind get_kindParam();
    internal static ILRowKind get_kindMethodDef();
    internal static ILRowKind get_kindMethodImpl();
    internal static ILRowKind get_kindImplMap();
    internal static ILRowKind get_kindMethodSemantics();
    internal static ILRowKind get_kindProperty();
    internal static ILRowKind get_kindEvent();
    internal static ILRowKind get_kindManifestResource();
    internal static ILRowKind get_kindClassLayout();
    internal static ILRowKind get_kindExportedType();
    internal static ILRowKind get_kindAssembly();
    internal static ILRowKind get_kindGenericParam_v1_1();
    internal static ILRowKind get_kindGenericParam_v2_0();
    internal static ILRowKind get_kindMethodSpec();
    internal static ILRowKind get_kindGenericParamConstraint();
    internal static ILRowKind get_kindModule();
    internal static ILRowKind get_kindIllegal();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hcCompare(TaggedIndex`1<HasConstantTag> _arg2, TaggedIndex`1<HasConstantTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hsCompare(TaggedIndex`1<HasSemanticsTag> _arg2, TaggedIndex`1<HasSemanticsTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hcaCompare(TaggedIndex`1<HasCustomAttributeTag> _arg2, TaggedIndex`1<HasCustomAttributeTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int mfCompare(TaggedIndex`1<MemberForwardedTag> _arg2, TaggedIndex`1<MemberForwardedTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hdsCompare(TaggedIndex`1<HasDeclSecurityTag> _arg2, TaggedIndex`1<HasDeclSecurityTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hfmCompare(TaggedIndex`1<HasFieldMarshalTag> _arg2, TaggedIndex`1<HasFieldMarshalTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int tomdCompare(TaggedIndex`1<TypeOrMethodDefTag> _arg2, TaggedIndex`1<TypeOrMethodDefTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int simpleIndexCompare(int idx1, int idx2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpFunc`2<int, d>, FSharpFunc`2<int, d>> mkCacheInt32(bool lowMem, a _infile, b _nm, c _sz);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpFunc`2<T, d>, FSharpFunc`2<T, d>> mkCacheGeneric(bool lowMem, a _inbase, b _nm, c _sz);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekFindRow(int numRows, FSharpFunc`2<int, bool> rowChooser);
    [CompilerGeneratedAttribute]
internal static c[] seekReadIndexedRows$cont@1535(FSharpFunc`2<int, a> rowReader, FSharpFunc`2<a, c> rowConverter, int numRows, FSharpFunc`2<a, b> keyFunc, FSharpFunc`2<b, int> keyComparer, Unit unitVar);
    internal static c[] seekReadIndexedRows(int numRows, FSharpFunc`2<int, a> rowReader, FSharpFunc`2<a, b> keyFunc, FSharpFunc`2<b, int> keyComparer, bool binaryChop, FSharpFunc`2<a, c> rowConverter);
    internal static FSharpOption`1<c> seekReadOptionalIndexedRow(int info_0, FSharpFunc`2<int, a> info_1, FSharpFunc`2<a, b> info_2, FSharpFunc`2<b, int> info_3, bool info_4, FSharpFunc`2<a, c> info_5);
    internal static c seekReadIndexedRow(int info_0, FSharpFunc`2<int, a> info_1, FSharpFunc`2<a, b> info_2, FSharpFunc`2<b, int> info_3, bool info_4, FSharpFunc`2<a, c> info_5);
    internal static Tuple`2<string, Lazy`1<ILTypeDef>> getName(Lazy`1<ILTypeDef> ltd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILTy(ILBoxity boxed, ILTypeSpec tspec);
    internal static ILType mkILArr1DTy(ILType ty);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_typeNameForGlobalFunctions();
    internal static ILTypeSpec mkILNonGenericTySpec(ILTypeRef tref);
    internal static ILType mkILTypeForGlobalFunctions(ILScopeRef scoref);
    internal static ILMethodSpec mkILMethSpecInTyRaw(ILType typ, ILCallingConv cc, string nm, ILType[] args, ILType rty, ILType[] minst);
    internal static ILFieldSpec mkILFieldSpecInTy(ILType typ, string nm, ILType fty);
    internal static ILType[] mkILFormalGenericArgsRaw(ILGenericParameterDef[] gparams);
    internal static ILTypeSpec mkILTyspec@1646(ILScopeRef systemRuntimeScopeRef, string nsp, string nm);
    internal static ILGlobals mkILGlobals(ILScopeRef systemRuntimeScopeRef);
    internal static int look@1727(ILModuleReader this, int v, string n, int i, int pos);
    internal static FSharpOption`1<Tuple`2<int, int>> look@1763-1(ILModuleReader this, Int32[] name, int i, int pos);
    [CompilerGeneratedAttribute]
internal static int projection@1(ILModuleReader this, ILRowElementKind x);
    internal static Tuple`2<FSharpOption`1<int>, FSharpOption`1<int>> dim@2766(int numSized, Int32[] sizes, int numLoBounded, Int32[] lobounds, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptr_get_byte(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<byte, int> sigptr_get_u8(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, int> sigptr_get_bool(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<sbyte, int> sigptr_get_i8(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ushort, int> sigptr_get_u16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<short, int> sigptr_get_i16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptr_get_i32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<UInt32, int> sigptr_get_u32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<long, int> sigptr_get_i64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ulong, int> sigptr_get_u64(Byte[] bytes, int sigptr);
    internal static float ieee32_of_bits(int x);
    internal static double ieee64_of_bits(long x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<float, int> sigptr_get_ieee32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<double, int> sigptr_get_ieee64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILType, int> decodeCustomAttrElemType(ILGlobals ilg, Byte[] bytes, int sigptr, byte x);
    internal static string grabScopeComponent@3387(ILTypeSigParser x, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptr_get_z_i32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Byte[], int> sigptr_get_bytes(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptr_get_string(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptr_get_serstring(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<string>, int> sigptr_get_serstring_possibly_null(Byte[] bytes, int sigptr);
    internal static FSharpList`1<Tuple`2<ILType, object>> parseElems@3547(ILGlobals ilg, Byte[] bytes, ILType elemTy, FSharpList`1<Tuple`2<ILType, object>> acc, int n, int sigptr);
    internal static Tuple`2<Tuple`2<ILType, object>, int> parseVal@3485(ILGlobals ilg, Byte[] bytes, ILType argty, int sigptr);
    internal static Tuple`2<FSharpList`1<Tuple`2<ILType, object>>, int> parseFixed@3557(ILGlobals ilg, Byte[] bytes, FSharpList`1<ILType> argtys, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<ILType, object>> decodeILCustomAttribData(ILGlobals ilg, ILCustomAttr ca);
    internal static ILModuleReader ILModuleReaderAfterReadingAllBytes(string file, ILGlobals ilGlobals);
    internal static PublicKey get_EcmaPublicKey();
    internal static ILScopeRef get_EcmaMscorlibScopeRef();
}
[CompilationMappingAttribute]
public static class SymlinkUtils : object {
    public static bool isDirectoryLink(string directory);
    public static void delete(string directory);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void makeDirectoryLink(string target, string source);
}
[FlagsAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes All;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
}
[CompilerGeneratedAttribute]
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
private DynamicallyAccessedMemberTypes MemberType@;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
private Type Type@;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicallyAccessedMemberTypes MemberType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Type Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes MemberType, Type Type);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicallyAccessedMemberTypes get_MemberType();
}
[CompilerGeneratedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
