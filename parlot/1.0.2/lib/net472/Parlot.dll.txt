[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.CodePrinter : object {
    public static Func`3<Type, string, string> PrintTypeStripOuterClasses;
    private static string _nonPubStatMethods;
    private static string _nonPubInstMethods;
    private static Char[] _enumValueSeparators;
    public static ObjectToCode DefaultNotRecognizedToCode;
    private static Type[] TypesImplementedByArray;
    private static CodePrinter();
    [ExtensionAttribute]
public static StringBuilder AppendTypeOf(StringBuilder sb, Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static StringBuilder AppendTypeOfList(StringBuilder sb, Type[] types, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
internal static StringBuilder AppendMember(StringBuilder sb, MemberInfo member, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendField(StringBuilder sb, FieldInfo field, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendProperty(StringBuilder sb, PropertyInfo property, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendEnum(StringBuilder sb, TEnum value, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static StringBuilder AppendMethod(StringBuilder sb, MethodInfo method, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder AppendName(StringBuilder sb, string name, string typeCode, T identity, string suffix);
    [ExtensionAttribute]
internal static StringBuilder AppendName(StringBuilder sb, string name, Type type, T identity, string suffix);
    [ExtensionAttribute]
public static string ToCode(Type type, bool stripNamespace, Func`3<Type, string, string> printType, bool printGenericTypeArgs);
    [ExtensionAttribute]
public static string ToCode(bool x);
    [ExtensionAttribute]
public static string ToCode(string x);
    [ExtensionAttribute]
public static string ToEnumValueCode(Type enumType, object x, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static Type[] GetGenericTypeParametersOrArguments(TypeInfo typeInfo);
    [ExtensionAttribute]
public static string ToCommaSeparatedCode(IEnumerable items, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToArrayInitializerCode(IEnumerable items, Type itemType, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
public static string ToCode(object x, ObjectToCode notRecognizedToCode, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdent(StringBuilder sb, int lineIdent);
    [ExtensionAttribute]
internal static StringBuilder NewLine(StringBuilder sb, int lineIdent, int identSpaces);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentExpr(StringBuilder sb, Expression expr, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentArgumentExprs(StringBuilder sb, IReadOnlyList`1<T> exprs, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentArgumentExprs(StringBuilder sb, SmallList2`1<T> exprs, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentCs(StringBuilder sb, Expression expr, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder NewLineIdentCs(StringBuilder sb, Expression expr, EnclosedIn enclosedIn, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    public static int CountLambdas(string code);
}
[FlagsAttribute]
internal enum FastExpressionCompiler.CompilerFlags : Enum {
    public byte value__;
    public static CompilerFlags Default;
    public static CompilerFlags NoInvocationLambdaInlining;
    public static CompilerFlags EnableDelegateDebugInfo;
    public static CompilerFlags ThrowOnNotSupportedExpression;
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ExpressionCompiler : object {
    private static Type[] _closureAsASingleParamType;
    private static Type[][] _closureTypePlusParamTypesPool;
    public static ArrayClosure EmptyArrayClosure;
    public static FieldInfo ArrayClosureArrayField;
    public static FieldInfo ArrayClosureWithNonPassedParamsField;
    private static ConstructorInfo[] _nonPassedParamsArrayClosureCtors;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructor;
    public static ConstructorInfo ArrayClosureWithNonPassedParamsConstructorWithoutConstants;
    [CompilerGeneratedAttribute]
private static Result <NotSupported_RuntimeVariables>k__BackingField;
    public static Result NotSupported_RuntimeVariables { get; private set; }
    private static ExpressionCompiler();
    [ExtensionAttribute]
public static TDelegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static bool CompileFastToIL(LambdaExpression lambdaExpr, ILGenerator il, CompilerFlags flags);
    [ExtensionAttribute]
public static Delegate CompileFast(LambdaExpression lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate CompileSys(Expression`1<TDelegate> lambdaExpr);
    [ExtensionAttribute]
public static Delegate CompileSys(LambdaExpression lambdaExpr);
    [ExtensionAttribute]
public static TDelegate CompileFast(Expression`1<TDelegate> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`1<R> CompileFast(Expression`1<Func`1<R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`2<T1, R> CompileFast(Expression`1<Func`2<T1, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`3<T1, T2, R> CompileFast(Expression`1<Func`3<T1, T2, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`4<T1, T2, T3, R> CompileFast(Expression`1<Func`4<T1, T2, T3, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`5<T1, T2, T3, T4, R> CompileFast(Expression`1<Func`5<T1, T2, T3, T4, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`6<T1, T2, T3, T4, T5, R> CompileFast(Expression`1<Func`6<T1, T2, T3, T4, T5, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, R> CompileFast(Expression`1<Func`7<T1, T2, T3, T4, T5, T6, R>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action CompileFast(Expression`1<Action> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`1<T1> CompileFast(Expression`1<Action`1<T1>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`2<T1, T2> CompileFast(Expression`1<Action`2<T1, T2>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`3<T1, T2, T3> CompileFast(Expression`1<Action`3<T1, T2, T3>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`4<T1, T2, T3, T4> CompileFast(Expression`1<Action`4<T1, T2, T3, T4>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`5<T1, T2, T3, T4, T5> CompileFast(Expression`1<Action`5<T1, T2, T3, T4, T5>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static Action`6<T1, T2, T3, T4, T5, T6> CompileFast(Expression`1<Action`6<T1, T2, T3, T4, T5, T6>> lambdaExpr, bool ifFastFailedReturnNull, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompile(LambdaExpression lambdaExpr, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs);
    [ExtensionAttribute]
public static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ConstantExpression[] closureConstantsExprs, CompilerFlags flags);
    [ExtensionAttribute]
internal static TDelegate TryCompileWithPreCreatedClosure(LambdaExpression lambdaExpr, ClosureInfo& closureInfo, CompilerFlags flags);
    [ExtensionAttribute]
public static TDelegate TryCompileWithoutClosure(LambdaExpression lambdaExpr, CompilerFlags flags);
    private static Delegate CompileNoArgsNew(ConstructorInfo ctor, Type delegateType, Type[] closurePlusParamTypes, Type returnType);
    internal static object TryCompileBoundToFirstClosureParam(Type delegateType, Expression bodyExpr, IReadOnlyList`1<ParameterExpression> paramExprs, Type[] closurePlusParamTypes, Type returnType, CompilerFlags flags);
    private static Type[] RentOrNewClosureTypeToParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    private static void ReturnClosureTypeToParamTypesToPool(Type[] closurePlusParamTypes);
    [ExtensionAttribute]
internal static LabelInfo& GetLabelOrInvokeIndexByTarget(SmallList4`1& labels, object labelTarget, Boolean& found);
    [ExtensionAttribute]
private static Label GetOrDefineLabel(LabelInfo& label, ILGenerator il);
    [CompilerGeneratedAttribute]
public static Result get_NotSupported_RuntimeVariables();
    [CompilerGeneratedAttribute]
private static void set_NotSupported_RuntimeVariables(Result value);
    [ExtensionAttribute]
public static bool TryGetDebugClosureNestedLambdaOrConstant(Delegate parentLambda, Object& item, int itemIndex);
    [ExtensionAttribute]
public static bool TryGetDebugClosureNestedLambda(Delegate parentLambda, int itemIndex, Delegate& d);
    public static bool IsClosureBoundConstant(object value, Type type);
    public static bool TryCollectBoundConstants(ClosureInfo& closure, Expression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    public static Result TryCollectInfo(ClosureInfo& closure, Expression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static Expression CreateInlinedLambdaInvocationExpression(IReadOnlyList`1<Expression> invokeArgs, int invokeArgCount, LambdaExpression lambdaExpr);
    private static bool PropagateNonPassedParamsToOuterLambda(ClosureInfo& closure, NestedLambdaInfo nestedLambda, IReadOnlyList`1<ParameterExpression> paramExprs, IReadOnlyList`1<ParameterExpression> nestedLambdaParamExprs, SmallList`1& nestedNonPassedParams);
    private static bool FindAlreadyCompiledNestedLambdaInfoInLambdas(SmallList`1& nestedLambdas, LambdaExpression lambdaExpr, NestedLambdaInfo& found);
    private static bool TryCompileNestedLambda(ClosureInfo& nestedClosureInfo, NestedLambdaInfo nestedLambdaInfo, CompilerFlags setup);
    [ExtensionAttribute]
public static IDelegateDebugInfo TryGetDebugInfo(D d);
    private static Result TryCollectMemberInitExprConstants(ClosureInfo& closure, MemberInitExpression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static Result TryCollectListInitExprConstants(ClosureInfo& closure, ListInitExpression expr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    private static Result TryCollectTryExprConstants(ClosureInfo& closure, TryExpression tryExpr, IReadOnlyList`1<ParameterExpression> paramExprs, NestedLambdaInfo nestedLambda, SmallList`1& rootNestedLambdas, CompilerFlags flags);
    [ExtensionAttribute]
public static bool IgnoresResult(ParentFlags parent);
    [ExtensionAttribute]
internal static bool EmitPopIfIgnoreResult(ILGenerator il, ParentFlags parent);
    [ExtensionAttribute]
internal static bool TryEmitBoxOf(ILGenerator il, Type sourceType);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.FecHelpers : object {
    [ExtensionAttribute]
public static int GetFirstIndex(IReadOnlyList`1<T> source, T item, TEq eq);
    [ExtensionAttribute]
public static T GetArgument(IReadOnlyList`1<T> source, int index);
    [ExtensionAttribute]
public static ParameterExpression GetParameter(IReadOnlyList`1<ParameterExpression> source, int index);
    [ExtensionAttribute]
public static IReadOnlyList`1<ParameterExpression> ToReadOnlyList(IReadOnlyList`1<ParameterExpression> source);
    [ExtensionAttribute]
public static int GetCount(IReadOnlyList`1<ParameterExpression> p);
    [ExtensionAttribute]
public static int GetCount(IReadOnlyList`1<Expression> p);
}
internal interface FastExpressionCompiler.IDelegateDebugInfo {
    public LambdaExpression Expression { get; }
    public string ExpressionString { get; }
    public string CSharpString { get; }
    public abstract virtual LambdaExpression get_Expression();
    public abstract virtual string get_ExpressionString();
    public abstract virtual string get_CSharpString();
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ILGeneratorHacks : object {
    private static Func`3<ILGenerator, Type, int> _getNextLocalVarIndex;
    private static ILGeneratorHacks();
    internal static int PostInc(Int32& i);
    [ExtensionAttribute]
public static int GetNextLocalVarIndex(ILGenerator il, Type t);
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ILGeneratorTools : object {
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, Type value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, FieldInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, MethodInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, ConstructorInfo value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, Label value);
    [ExtensionAttribute]
public static void DmarkLabel(ILGenerator il, Label value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, byte value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, sbyte value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, short value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, int value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, long value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, float value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, OpCode opcode, double value);
    [ExtensionAttribute]
public static void Demit(ILGenerator il, string value, OpCode opcode);
}
internal class FastExpressionCompiler.ImTools.DefaultEq`1 : ValueType {
    public sealed virtual K GetTombstone();
    public sealed virtual bool Equals(K x, K y);
    public sealed virtual int GetHashCode(K key);
}
internal static class FastExpressionCompiler.ImTools.Hasher : object {
    public static int Combine(int h1, int h2);
}
internal interface FastExpressionCompiler.ImTools.IEq`1 {
    public abstract virtual K GetTombstone();
    public abstract virtual bool Equals(K x, K y);
    public abstract virtual int GetHashCode(K key);
}
internal class FastExpressionCompiler.ImTools.RefEq`1 : ValueType {
    public sealed virtual K GetTombstone();
    public sealed virtual bool Equals(K x, K y);
    public sealed virtual int GetHashCode(K key);
}
internal class FastExpressionCompiler.ImTools.RefEq`2 : ValueType {
    public sealed virtual ValueTuple`2<A, B> GetTombstone();
    public sealed virtual bool Equals(ValueTuple`2<A, B> x, ValueTuple`2<A, B> y);
    public sealed virtual int GetHashCode(ValueTuple`2<A, B> key);
}
internal class FastExpressionCompiler.ImTools.RefEq`3 : ValueType {
    public sealed virtual ValueTuple`3<A, B, C> GetTombstone();
    public sealed virtual bool Equals(ValueTuple`3<A, B, C> x, ValueTuple`3<A, B, C> y);
    public sealed virtual int GetHashCode(ValueTuple`3<A, B, C> key);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.ImTools.SmallList : object {
    internal static int ForLoopCopyCount;
    internal static int DefaultInitialCapacity;
    internal static void Expand(TItem[]& items);
    public static TItem& AddDefaultToNotNullItemsAndGetRef(TItem[]& items, int index);
    public static TItem& AddDefaultAndGetRef(TItem[]& items, int index, int initialCapacity);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList`1& source, int index);
    [ExtensionAttribute]
public static TItem& Add(SmallList`1& source, int initialCapacity);
    [ExtensionAttribute]
public static void Add(SmallList`1& source, TItem& item, int initialCapacity);
    [ExtensionAttribute]
public static int TryGetIndex(TItem[] items, TItem& it, int startIndex, int count, TEq eq, int notFoundResult);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAdd(SmallList`1& source, TItem& item, TEq eq);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList4`1& source, int index);
    [ExtensionAttribute]
public static TItem& GetLastSurePresentItem(SmallList4`1& source);
    [ExtensionAttribute]
public static TItem& NotFound(SmallList4`1& _);
    [ExtensionAttribute]
public static TItem& AddDefaultAndGetRef(SmallList4`1& source);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList4`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAdd(SmallList4`1& source, TItem& item, TEq eq);
    [ExtensionAttribute]
public static TItem& GetSurePresentItemRef(SmallList2`1& source, int index);
    [ExtensionAttribute]
public static TItem& GetLastSurePresentItem(SmallList2`1& source);
    [ExtensionAttribute]
public static TItem& NotFound(SmallList2`1& _);
    [ExtensionAttribute]
public static TItem& AddDefaultAndGetRef(SmallList2`1& source);
    [ExtensionAttribute]
public static int TryGetIndex(SmallList2`1& source, TItem it, TEq eq);
    [ExtensionAttribute]
public static int GetIndexOrAdd(SmallList2`1& source, TItem item, TEq eq);
}
internal class FastExpressionCompiler.ImTools.SmallList`1 : ValueType {
    public T[] Items;
    public int Count;
    public SmallList`1(T[] items, int count);
    public SmallList`1(T[] items);
    public void Pop();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{Count} of {_it0?.ToString()}, {_it1?.ToString()}, ...")]
internal class FastExpressionCompiler.ImTools.SmallList2`1 : ValueType {
    public static int StackCapacity;
    internal static TItem Missing;
    internal int _count;
    internal TItem _it0;
    internal TItem _it1;
    internal TItem[] _rest;
    public int Count { get; }
    public TItem Item { get; }
    public void InitCount(int count);
    public void Populate1(TItem it0);
    public void Populate2(TItem it0, TItem it1);
    public void Populate(TItem it0, TItem it1, TItem[] rest);
    public void Populate(TList items);
    public int get_Count();
    public TItem get_Item(int index);
    public void Add(TItem& item);
    public void AddDefault();
    public void RemoveLastSurePresentItem();
    public TItem[] ToArray();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{Count} of {_it0?.ToString()}, {_it1?.ToString()}, {_it2?.ToString()}, {_it3?.ToString()}, ...")]
internal class FastExpressionCompiler.ImTools.SmallList4`1 : ValueType {
    public static int StackCapacity;
    internal static TItem Missing;
    internal int _count;
    internal TItem _it0;
    internal TItem _it1;
    internal TItem _it2;
    internal TItem _it3;
    internal TItem[] _rest;
    public int Count { get; }
    public TItem Item { get; }
    public int get_Count();
    public void Populate1(TItem it0);
    public void Populate2(TItem it0, TItem it1);
    public void Populate3(TItem it0, TItem it1, TItem it2);
    public void Populate4(TItem it0, TItem it1, TItem it2, TItem it3);
    public void Populate(TItem it0, TItem it1, TItem it2, TItem it3, TItem[] rest);
    public void Populate(TList items);
    public TItem get_Item(int index);
    public void Add(TItem& item);
    public void AddDefault();
    public void RemoveLastSurePresentItem();
    public TItem[] ToArray();
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.ImTools.SmallMap4 : object {
    internal static byte MinFreeCapacityShift;
    internal static byte MinHashesCapacityBitShift;
    public static byte MaxProbeBits;
    internal static byte MaxProbeCount;
    internal static byte ProbeCountShift;
    internal static int HashAndIndexMask;
    public static int StackEntriesCount;
    internal static int MinEntriesCapacity;
    public static SmallMap4`4<K, V, TEq, SingleArrayEntries`3<K, V, TEq>> New(byte capacityBitShift);
    public static string ToB(int x);
    internal static Int32& GetHashRef(Int32[]& start, int distance);
    internal static int GetHash(Int32[]& start, int distance);
    [ExtensionAttribute]
public static V& TryGetValueRef(SmallMap4`4& map, K key, Boolean& found);
    [ExtensionAttribute]
public static bool ContainsKey(SmallMap4`4& map, K key);
    [ExtensionAttribute]
public static V& AddOrGetValueRef(SmallMap4`4& map, K key, Boolean& found);
    [ExtensionAttribute]
private static void AddInitialHashWithoutResizing(SmallMap4`4& map, K key, int index, int indexMask);
    [ExtensionAttribute]
public static V& AddSureAbsentDefaultAndGetRef(SmallMap4`4& map, K key);
    [ExtensionAttribute]
private static V& AddSureAbsentDefaultAndGetRefByHash(SmallMap4`4& map, K key);
    [ExtensionAttribute]
public static Entry`2& GetSurePresentEntryRef(SmallMap4`4& map, int index);
    [ExtensionAttribute]
internal static V& TryGetValueRefByHash(SmallMap4`4& map, K key, Boolean& found);
    [ExtensionAttribute]
private static V& AddOrGetValueRefByHash(SmallMap4`4& map, K key, Boolean& found);
}
[DebuggerDisplayAttribute("{Count} of {_e0}, {_e1}, {_e2}, {_e3}, ...")]
internal class FastExpressionCompiler.ImTools.SmallMap4`4 : ValueType {
    internal static Entry`2<K, V> _missing;
    internal byte _capacityBitShift;
    internal int _count;
    internal Int32[] _packedHashesAndIndexes;
    internal TEntries _entries;
    internal Entry`2<K, V> _e0;
    internal Entry`2<K, V> _e1;
    internal Entry`2<K, V> _e2;
    internal Entry`2<K, V> _e3;
    public int CapacityBitShift { get; }
    public Int32[] PackedHashesAndIndexes { get; }
    public int Count { get; }
    public TEntries Entries { get; }
    public SmallMap4`4(byte capacityBitShift);
    public int get_CapacityBitShift();
    public Int32[] get_PackedHashesAndIndexes();
    public int get_Count();
    public TEntries get_Entries();
    internal int ResizeHashes(int indexMask);
}
internal class FastExpressionCompiler.NotSupportedExpressionException : InvalidOperationException {
    public Result Reason;
    public NotSupportedExpressionException(Result reason);
    public NotSupportedExpressionException(Result reason, string message);
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ToCSharpPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr);
    [ExtensionAttribute]
public static string ToCSharpString(Expression expr, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
public static StringBuilder ToCSharpString(Expression e, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    private static StringBuilder NullConstantOrDefaultToCSharpString(Type exprType, StringBuilder sb, EnclosedIn encloseIn, bool stripNamespace, Func`3<Type, string, string> printType);
    private static StringBuilder InsertTopFFuncDefinitionOnce(StringBuilder sb);
    [ExtensionAttribute]
internal static StringBuilder ToCSharpString(Expression e, StringBuilder sb, EnclosedIn enclosedIn, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode, bool isReturnByRef);
    [ExtensionAttribute]
private static StringBuilder ToCSharpBlock(Expression expr, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToCSharpExpression(Expression expr, StringBuilder sb, EnclosedIn enclosedIn, bool newLineExpr, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder AppendSemicolonOnce(StringBuilder sb);
    [ExtensionAttribute]
internal static StringBuilder AppendLineOnce(StringBuilder sb);
    [ExtensionAttribute]
internal static StringBuilder ToCSharpString(LabelTarget target, StringBuilder sb);
    [ExtensionAttribute]
private static StringBuilder ToCSharpString(IReadOnlyList`1<MemberBinding> bindings, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder BlockToCSharpString(BlockExpression b, StringBuilder sb, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode, bool inTheLastBlock, BinaryExpression blockResultAssignment, bool containerIgnoresResult);
    private static string OperatorToCSharpString(ExpressionType nodeType);
    [CompilerGeneratedAttribute]
internal static void <ToCSharpString>g__PrintPart|6_0(Expression part, <>c__DisplayClass6_0& , <>c__DisplayClass6_1& );
}
[ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static class FastExpressionCompiler.ToExpressionPrinter : object {
    private static string NotSupportedExpression;
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
public static string ToExpressionString(Expression expr, List`1& paramsExprs, List`1& uniqueExprs, List`1& lts, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(Expression expr, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(ParameterExpression pe, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder ToExpressionString(LabelTarget lt, StringBuilder sb, List`1<LabelTarget> labelTargets, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<CatchBlock> bs, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(CatchBlock b, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(IReadOnlyList`1<SwitchCase> items, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(SwitchCase s, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(MemberBinding mb, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
private static StringBuilder ToExpressionString(ElementInit ei, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
    [ExtensionAttribute]
internal static StringBuilder CreateExpressionString(Expression e, StringBuilder sb, List`1<ParameterExpression> paramsExprs, List`1<Expression> uniqueExprs, List`1<LabelTarget> lts, int lineIdent, bool stripNamespace, Func`3<Type, string, string> printType, int identSpaces, ObjectToCode notRecognizedToCode);
}
[ExtensionAttribute]
internal static class FastExpressionCompiler.Tools : object {
    internal static MethodInfo DelegateTargetGetterMethod;
    private static Tools();
    [ExtensionAttribute]
public static Expression AsExpr(object obj);
    [ExtensionAttribute]
public static Expression[] AsExprs(Object[] obj);
    [ExtensionAttribute]
internal static bool IsUnsigned(Type type);
    [ExtensionAttribute]
internal static bool IsPrimitiveWithZeroDefault(Type type);
    [ExtensionAttribute]
internal static bool IsNullable(Type type);
    [ExtensionAttribute]
internal static Type GetUnderlyingNullableTypeOrNull(Type type);
    [ExtensionAttribute]
internal static Type GetUnderlyingNullableTypeUnsafe(Type type);
    [ExtensionAttribute]
public static string GetArithmeticBinaryOperatorMethodName(ExpressionType nodeType);
    [ExtensionAttribute]
internal static bool IsAssignNodeType(ExpressionType nodeType);
    [ExtensionAttribute]
internal static bool IsBlockLike(ExpressionType nodeType);
    [ExtensionAttribute]
internal static bool IsReturnable(ExpressionType nodeType);
    [ExtensionAttribute]
internal static bool IsBlockLikeOrConditional(ExpressionType nodeType);
    [ExtensionAttribute]
internal static Expression StripConvertRecursively(Expression expr);
    [ExtensionAttribute]
internal static bool IsComplexExpression(Expression expr);
    [ExtensionAttribute]
internal static bool IsConstantOrDefault(Expression expr);
    [ExtensionAttribute]
internal static bool IsParamOrConstantOrDefault(Expression expr);
    [ExtensionAttribute]
internal static string GetCSharpName(MemberInfo m);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindMethod(Type type, string methodName);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindDelegateInvokeMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindNullableValueGetterMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo GetNullableHasValueGetterMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static FieldInfo GetNullableValueUnsafeAkaGetValueOrDefaultMethod(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static ConstructorInfo GetNullableConstructor(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static MethodInfo FindConvertOperator(Type type, Type sourceType, Type targetType);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("FastExpressionCompiler is not supported in trimming scenarios.")]
internal static ConstructorInfo FindSingleParamConstructor(Type type, Type paramType);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> xs);
    [ExtensionAttribute]
internal static IList`1<T> AsList(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static bool TryGetIndex(IList`1<T> items, Int32& index, T item, int count, TEq eq);
    public static T[] Empty();
    public static Type[] GetParamTypes(IReadOnlyList`1<ParameterExpression> paramExprs);
    public static Type GetFuncOrActionType(Type returnType);
    public static Type GetFuncOrActionType(Type p, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type returnType);
    public static Type GetFuncOrActionType(Type p0, Type p1, Type p2, Type p3, Type p4, Type p5, Type returnType);
    public static Type GetFuncOrActionType(Type[] paramTypes, Type returnType);
    [ExtensionAttribute]
public static T GetFirst(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T GetFirst(T[] source);
    [CompilerGeneratedAttribute]
internal static Type <GetFuncOrActionType>g__GetAction|40_0(int length);
    [CompilerGeneratedAttribute]
internal static Type <GetFuncOrActionType>g__GetFunc|40_1(int length);
}
internal static class FastExpressionCompiler.Trimming : object {
    public static string Message;
}
internal static class HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static bool IsHexChar(int c);
    public static int FromChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public static class Parlot.Character : object {
    private static ReadOnlySpan`1<byte> _characterData { get; }
    public static bool IsDecimalDigit(char ch);
    public static bool IsInRange(char ch, char min, char max);
    public static bool IsHexDigit(char ch);
    public static bool IsIdentifierStart(char ch);
    public static bool IsIdentifierPart(char ch);
    public static bool IsWhiteSpace(char ch);
    public static bool IsWhiteSpaceOrNewLine(char ch);
    public static bool IsNewLine(char ch);
    [NullableContextAttribute("1")]
public static char ScanHexEscape(string text, int index, Int32& length);
    public static char ScanHexEscape(ReadOnlySpan`1<char> text, Int32& length);
    public static ReadOnlySpan`1<char> DecodeString(ReadOnlySpan`1<char> span);
    [NullableContextAttribute("1")]
public static TextSpan DecodeString(string s);
    public static TextSpan DecodeString(TextSpan span);
    private static int HexValue(char ch);
    private static ReadOnlySpan`1<byte> get__characterData();
}
[FlagsAttribute]
internal enum Parlot.CharacterMask : Enum {
    public byte value__;
    public static CharacterMask None;
    public static CharacterMask IdentifierStart;
    public static CharacterMask IdentifierPart;
    public static CharacterMask WhiteSpace;
    public static CharacterMask WhiteSpaceOrNewLine;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Parlot.CharMap`1 : object {
    private T[] _asciiMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<UInt32, T> _nonAsciiMap;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    public Char[] ExpectedChars { get; private set; }
    [NullableAttribute("2")]
public T Item { get; }
    public CharMap`1(IEnumerable`1<KeyValuePair`2<char, T>> map);
    public void Set(char c, T value);
    [CompilerGeneratedAttribute]
public Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
private void set_ExpectedChars(Char[] value);
    [NullableContextAttribute("2")]
public T get_Item(UInt32 c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Parlot.CharToStringTable : object {
    private static int _size;
    private static String[] _table;
    private static CharToStringTable();
    public static string GetString(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parlot.Compilation.CompilationContext : object {
    private int _number;
    [CompilerGeneratedAttribute]
private ParameterExpression <ParseContext>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ParameterExpression> <GlobalVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <GlobalExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <Lambdas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiscardResult>k__BackingField;
    public ParameterExpression ParseContext { get; }
    public int NextNumber { get; }
    public List`1<ParameterExpression> GlobalVariables { get; }
    public List`1<Expression> GlobalExpressions { get; }
    public List`1<Expression> Lambdas { get; }
    public bool DiscardResult { get; public set; }
    [CompilerGeneratedAttribute]
public ParameterExpression get_ParseContext();
    public int get_NextNumber();
    [CompilerGeneratedAttribute]
public List`1<ParameterExpression> get_GlobalVariables();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_GlobalExpressions();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_Lambdas();
    [CompilerGeneratedAttribute]
public bool get_DiscardResult();
    [CompilerGeneratedAttribute]
public void set_DiscardResult(bool value);
    [NullableContextAttribute("2")]
public CompilationResult CreateCompilationResult(bool defaultSuccess, Expression defaultValue);
    public CompilationResult CreateCompilationResult(Type valueType, bool defaultSuccess, Expression defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
public class Parlot.Compilation.CompilationResult : object {
    [CompilerGeneratedAttribute]
private List`1<ParameterExpression> <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Value>k__BackingField;
    public List`1<ParameterExpression> Variables { get; }
    public List`1<Expression> Body { get; }
    [RequiredMemberAttribute]
public ParameterExpression Success { get; public set; }
    [RequiredMemberAttribute]
public ParameterExpression Value { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ParameterExpression> get_Variables();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_Body();
    [CompilerGeneratedAttribute]
public ParameterExpression get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(ParameterExpression value);
    [CompilerGeneratedAttribute]
public ParameterExpression get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ParameterExpression value);
    public ParameterExpression DeclareVariable(string name, Expression defaultValue);
    public ParameterExpression DeclareVariable(string name, Type type, Expression defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Compilation.CompiledParser`1 : Parser`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ParseContext, ValueTuple`2<bool, T>> _parse;
    [CompilerGeneratedAttribute]
private Parser`1<T> <Source>k__BackingField;
    public Parser`1<T> Source { get; }
    public CompiledParser`1(Func`2<ParseContext, ValueTuple`2<bool, T>> parse, Parser`1<T> source);
    [CompilerGeneratedAttribute]
public Parser`1<T> get_Source();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Parlot.Compilation.ExpressionHelper : object {
    internal static MethodInfo ParserContext_SkipWhiteSpaceMethod;
    internal static MethodInfo ParserContext_WhiteSpaceParser;
    internal static MethodInfo Scanner_ReadText_NoResult;
    internal static MethodInfo Scanner_ReadChar;
    internal static MethodInfo Scanner_ReadDecimal;
    internal static MethodInfo Scanner_ReadDecimalAllArguments;
    internal static MethodInfo Scanner_ReadInteger;
    internal static MethodInfo Scanner_ReadNonWhiteSpace;
    internal static MethodInfo Scanner_ReadNonWhiteSpaceOrNewLine;
    internal static MethodInfo Scanner_SkipWhiteSpace;
    internal static MethodInfo Scanner_SkipWhiteSpaceOrNewLine;
    internal static MethodInfo Scanner_ReadSingleQuotedString;
    internal static MethodInfo Scanner_ReadDoubleQuotedString;
    internal static MethodInfo Scanner_ReadQuotedString;
    internal static MethodInfo Cursor_Advance;
    internal static MethodInfo Cursor_AdvanceNoNewLines;
    internal static MethodInfo Cursor_ResetPosition;
    internal static ConstructorInfo Exception_ToString;
    internal static ConstructorInfo TextSpan_Constructor;
    internal static MethodInfo MemoryExtensions_AsSpan;
    public static Expression`1<Func`4<Cursor, char, char, bool>> CharacterIsInRange;
    private static ExpressionHelper();
    public static Expression ArrayEmpty();
    public static Expression New();
    [ExtensionAttribute]
public static Expression NewTextSpan(CompilationContext _, Expression buffer, Expression offset, Expression count);
    [ExtensionAttribute]
public static MemberExpression Scanner(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Cursor(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Position(CompilationContext context);
    [ExtensionAttribute]
public static Expression ResetPosition(CompilationContext context, Expression position);
    [ExtensionAttribute]
public static MemberExpression Offset(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Offset(CompilationContext _, Expression textPosition);
    [ExtensionAttribute]
public static MemberExpression Current(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Eof(CompilationContext context);
    [ExtensionAttribute]
public static MemberExpression Buffer(CompilationContext context);
    [ExtensionAttribute]
public static Expression ThrowObject(CompilationContext _, Expression o);
    [ExtensionAttribute]
public static Expression ThrowParseException(CompilationContext context, Expression message);
    [ExtensionAttribute]
public static MethodCallExpression ReadSingleQuotedString(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadDoubleQuotedString(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadQuotedString(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadChar(CompilationContext context, char c);
    [ExtensionAttribute]
public static MethodCallExpression ReadDecimal(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadDecimal(CompilationContext context, Expression allowLeadingSign, Expression allowDecimalSeparator, Expression allowGroupSeparator, Expression allowExponent, Expression number, Expression decimalSeparator, Expression groupSeparator);
    [ExtensionAttribute]
public static MethodCallExpression ReadInteger(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadNonWhiteSpace(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression ReadNonWhiteSpaceOrNewLine(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression SkipWhiteSpace(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression SkipWhiteSpaceOrNewLine(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression Advance(CompilationContext context);
    [ExtensionAttribute]
public static MethodCallExpression AdvanceNoNewLine(CompilationContext context, Expression count);
    [ExtensionAttribute]
public static ParameterExpression DeclarePositionVariable(CompilationContext context, CompilationResult result);
    [ExtensionAttribute]
public static ParameterExpression DeclareOffsetVariable(CompilationContext context, CompilationResult result);
    [ExtensionAttribute]
public static MethodCallExpression ParserSkipWhiteSpace(CompilationContext context);
}
[NullableContextAttribute("1")]
public interface Parlot.Compilation.ICompilable {
    public abstract virtual CompilationResult Compile(CompilationContext context);
}
public interface Parlot.Compilation.ICompiledParser {
}
public class Parlot.Cursor : object {
    public static char NullChar;
    private int _textLength;
    private char _current;
    private int _offset;
    private int _line;
    private int _column;
    [NullableAttribute("1")]
private string _buffer;
    [CompilerGeneratedAttribute]
private bool <Eof>k__BackingField;
    public TextPosition Position { get; }
    public ReadOnlySpan`1<char> Span { get; }
    public char Current { get; }
    public int Offset { get; }
    public bool Eof { get; private set; }
    [NullableAttribute("1")]
public string Buffer { get; }
    [NullableContextAttribute("1")]
public Cursor(string buffer, TextPosition& position);
    [NullableContextAttribute("1")]
public Cursor(string buffer);
    public TextPosition get_Position();
    public ReadOnlySpan`1<char> get_Span();
    public void Advance();
    public void Advance(int count);
    public void AdvanceNoNewLines(int offset);
    public void ResetPosition(TextPosition& position);
    private void ResetPositionNotInlined(TextPosition& position);
    public char get_Current();
    public int get_Offset();
    public char PeekNext(int index);
    [CompilerGeneratedAttribute]
public bool get_Eof();
    [CompilerGeneratedAttribute]
private void set_Eof(bool value);
    [NullableContextAttribute("1")]
public string get_Buffer();
    public bool Match(char c);
    public bool MatchAnyOf(ReadOnlySpan`1<char> s);
    public bool Match(ReadOnlySpan`1<char> s);
    public bool Match(ReadOnlySpan`1<char> s, StringComparison comparisonType);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Always`1 : Parser`1<T> {
    private T _value;
    public Always`1(T value);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Between`3 : Parser`1<T> {
    private Parser`1<T> _parser;
    private Parser`1<A> _before;
    private Parser`1<B> _after;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Between`3(Parser`1<A> before, Parser`1<T> parser, Parser`1<B> after);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal class Parlot.Fluent.BigIntegerNumberLiteral : NumberLiteralBase`1<BigInteger> {
    public BigIntegerNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, BigInteger& value);
}
internal class Parlot.Fluent.ByteNumberLiteral : NumberLiteralBase`1<byte> {
    public ByteNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Byte& value);
}
public class Parlot.Fluent.Capture`1 : Parser`1<TextSpan> {
    [NullableAttribute("1")]
private Parser`1<T> _parser;
    [NullableContextAttribute("1")]
public Capture`1(Parser`1<T> parser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    [NullableContextAttribute("1")]
public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.CharLiteral : Parser`1<char> {
    [CompilerGeneratedAttribute]
private char <Char>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public char Char { get; }
    public bool CanSeek { get; }
    [NullableAttribute("1")]
public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public CharLiteral(char c);
    [CompilerGeneratedAttribute]
public char get_Char();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    [NullableContextAttribute("1")]
public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal class Parlot.Fluent.DecimalNumberLiteral : NumberLiteralBase`1<decimal> {
    public DecimalNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Decimal& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Deferred`1 : Parser`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Parser`1<T> <Parser>k__BackingField;
    private bool _initialized;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Closure<T> _closure;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Parser`1<T> Parser { get; public set; }
    public Deferred`1(Func`2<Deferred`1<T>, Parser`1<T>> parser);
    [CompilerGeneratedAttribute]
public Parser`1<T> get_Parser();
    [CompilerGeneratedAttribute]
public void set_Parser(Parser`1<T> value);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Discard`2 : Parser`1<U> {
    private Parser`1<T> _parser;
    private U _value;
    public Discard`2(Parser`1<T> parser, U value);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal class Parlot.Fluent.DoubleNumberLiteral : NumberLiteralBase`1<double> {
    public DoubleNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Double& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Else`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    private T _value;
    public Else`1(Parser`1<T> parser, T value);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.ElseError`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    private string _message;
    public ElseError`1(Parser`1<T> parser, string message);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Eof`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    public Eof`1(Parser`1<T> parser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Error`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    private string _message;
    public Error`1(Parser`1<T> parser, string message);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Error`2 : Parser`1<U> {
    private Parser`1<T> _parser;
    private string _message;
    public Error`2(Parser`1<T> parser, string message);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal class Parlot.Fluent.FloatNumberLiteral : NumberLiteralBase`1<float> {
    public FloatNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Single& value);
}
[ExtensionAttribute]
internal static class Parlot.Fluent.Helpers : object {
    [ExtensionAttribute]
internal static NumberStyles ToNumberStyles(NumberOptions numberOptions);
}
public class Parlot.Fluent.Identifier : Parser`1<TextSpan> {
    [NullableAttribute("1")]
private static MethodInfo _isIdentifierStartMethodInfo;
    [NullableAttribute("1")]
private static MethodInfo _isIdentifierPartMethodInfo;
    [NullableAttribute("2")]
private Func`2<char, bool> _extraStart;
    [NullableAttribute("2")]
private Func`2<char, bool> _extraPart;
    [NullableContextAttribute("2")]
public Identifier(Func`2<char, bool> extraStart, Func`2<char, bool> extraPart);
    private static Identifier();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    [NullableContextAttribute("1")]
public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal class Parlot.Fluent.IntNumberLiteral : NumberLiteralBase`1<int> {
    public IntNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int32& value);
}
[NullableContextAttribute("1")]
public interface Parlot.Fluent.ISkippableSequenceParser {
    public abstract virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parlot.Fluent.LiteralBuilder : object {
    public Parser`1<TextSpan> WhiteSpace(bool includeNewLines);
    public Parser`1<TextSpan> NonWhiteSpace(bool includeNewLines);
    public Parser`1<string> Text(string text, bool caseInsensitive);
    public Parser`1<char> Char(char c);
    public Parser`1<T> Number(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public Parser`1<long> Integer(NumberOptions numberOptions);
    public Parser`1<decimal> Decimal(NumberOptions numberOptions);
    [ObsoleteAttribute("Prefer Number<float>(NumberOptions.Float) instead.")]
public Parser`1<float> Float(NumberOptions numberOptions);
    [ObsoleteAttribute("Prefer Number<double>(NumberOptions.Float) instead.")]
public Parser`1<double> Double(NumberOptions numberOptions);
    public Parser`1<TextSpan> String(StringLiteralQuotes quotes);
    [NullableContextAttribute("2")]
public Parser`1<TextSpan> Identifier(Func`2<char, bool> extraStart, Func`2<char, bool> extraPart);
    public Parser`1<TextSpan> Pattern(Func`2<char, bool> predicate, int minSize, int maxSize);
}
internal class Parlot.Fluent.LongNumberLiteral : NumberLiteralBase`1<long> {
    public LongNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int64& value);
}
public class Parlot.Fluent.NonWhiteSpaceLiteral : Parser`1<TextSpan> {
    private bool _includeNewLines;
    public NonWhiteSpaceLiteral(bool includeNewLines);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    [NullableContextAttribute("1")]
public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Not`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    public Not`1(Parser`1<T> parser);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Parlot.Fluent.NumberLiteralBase`1 : Parser`1<T> {
    private static MethodInfo _defaultTryParseMethodInfo;
    private static MethodInfo _rosToString;
    private char _decimalSeparator;
    private char _groupSeparator;
    private MethodInfo _tryParseMethodInfo;
    private NumberStyles _numberStyles;
    private CultureInfo _culture;
    private bool _allowLeadingSign;
    private bool _allowDecimalSeparator;
    private bool _allowGroupSeparator;
    private bool _allowExponent;
    [NullableContextAttribute("2")]
public NumberLiteralBase`1(NumberOptions numberOptions, char decimalSeparator, char groupSeparator, MethodInfo tryParseMethodInfo);
    private static NumberLiteralBase`1();
    public abstract virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, T& value);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public static class Parlot.Fluent.NumberLiterals : object {
    public static char DefaultDecimalSeparator;
    public static char DefaultGroupSeparator;
    [NullableContextAttribute("1")]
public static Parser`1<T> CreateNumberLiteralParser(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
}
[FlagsAttribute]
public enum Parlot.Fluent.NumberOptions : Enum {
    public int value__;
    public static NumberOptions None;
    public static NumberOptions AllowLeadingSign;
    public static NumberOptions AllowDecimalSeparator;
    public static NumberOptions AllowGroupSeparators;
    public static NumberOptions AllowExponent;
    public static NumberOptions Integer;
    public static NumberOptions Number;
    public static NumberOptions Float;
    public static NumberOptions Any;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.OneOf`1 : Parser`1<T> {
    private Parser`1[] _parsers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal CharMap`1<List`1<Parser`1<T>>> _map;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Parser`1[] Parsers { get; }
    public OneOf`1(Parser`1[] parsers);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public Parser`1[] get_Parsers();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
    [CompilerGeneratedAttribute]
internal static Expression <Compile>g__BinarySwitch|15_2(Expression num, ValueTuple`2[] cases);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.OneOf`3 : Parser`1<T> {
    private Parser`1<A> _parserA;
    private Parser`1<B> _parserB;
    public OneOf`3(Parser`1<A> parserA, Parser`1<B> parserB);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.OneOrMany`1 : Parser`1<IReadOnlyList`1<T>> {
    private Parser`1<T> _parser;
    private static MethodInfo _listAddMethodInfo;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public OneOrMany`1(Parser`1<T> parser);
    private static OneOrMany`1();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parlot.Fluent.ParseContext : object {
    public static int DefaultCompilationThreshold;
    [CompilerGeneratedAttribute]
private int <CompilationThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNewLines>k__BackingField;
    [NullableAttribute("1")]
public Scanner Scanner;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, ParseContext> <OnEnterParser>k__BackingField;
    [CompilerGeneratedAttribute]
private Parser`1<TextSpan> <WhiteSpaceParser>k__BackingField;
    public int CompilationThreshold { get; public set; }
    public bool UseNewLines { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, ParseContext> OnEnterParser { get; public set; }
    public Parser`1<TextSpan> WhiteSpaceParser { get; public set; }
    [NullableContextAttribute("1")]
public ParseContext(Scanner scanner, bool useNewLines);
    [CompilerGeneratedAttribute]
public int get_CompilationThreshold();
    [CompilerGeneratedAttribute]
public void set_CompilationThreshold(int value);
    [CompilerGeneratedAttribute]
public bool get_UseNewLines();
    [CompilerGeneratedAttribute]
private void set_UseNewLines(bool value);
    [CompilerGeneratedAttribute]
public Action`2<object, ParseContext> get_OnEnterParser();
    [CompilerGeneratedAttribute]
public void set_OnEnterParser(Action`2<object, ParseContext> value);
    [CompilerGeneratedAttribute]
public Parser`1<TextSpan> get_WhiteSpaceParser();
    [CompilerGeneratedAttribute]
public void set_WhiteSpaceParser(Parser`1<TextSpan> value);
    public void SkipWhiteSpace();
    [NullableContextAttribute("1")]
public void EnterParser(Parser`1<T> parser);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Parlot.Fluent.Parser`1 : object {
    private static ConstructorInfo _valueTupleConstructor;
    private int _invocations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1 modreq(System.Runtime.CompilerServices.IsVolatile) _compiledParser;
    private static Parser`1();
    public Parser`1<T> Compile();
    public CompilationResult Build(CompilationContext context, bool requireResult);
    private CompilationResult BuildAsNonCompilableParser(CompilationContext context);
    public abstract virtual bool Parse(ParseContext context, ParseResult`1& result);
    public Parser`1<U> Then(Func`2<T, U> conversion);
    public Parser`1<U> Then(Func`3<ParseContext, T, U> conversion);
    public Parser`1<U> Then(U value);
    public Parser`1<U> ThenElse(Func`2<T, U> conversion, U elseValue);
    public Parser`1<U> ThenElse(Func`3<ParseContext, T, U> conversion, U elseValue);
    public Parser`1<U> ThenElse(U value, U elseValue);
    public Parser`1<T> ElseError(string message);
    public Parser`1<T> Error(string message);
    public Parser`1<U> Error(string message);
    public Parser`1<T> When(Func`2<T, bool> predicate);
    public Parser`1<U> Switch(Func`3<ParseContext, T, Parser`1<U>> action);
    public Parser`1<T> Eof();
    [NullableContextAttribute("2")]
public Parser`1<U> Discard();
    public Parser`1<U> Discard(U value);
    public Parser`1<T> Else(T value);
    public T Parse(string text);
    public T Parse(ParseContext context);
    private Parser`1<T> CheckCompiled(ParseContext context);
    public bool TryParse(string text, T& value);
    public bool TryParse(string text, T& value, ParseError& error);
    public bool TryParse(ParseContext context, T& value, ParseError& error);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Parlot.Fluent.Parsers : object {
    [NullableAttribute("1")]
public static LiteralBuilder Literals { get; }
    [NullableAttribute("1")]
public static TermBuilder Terms { get; }
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Sequence`2<T1, T2> And(Parser`1<T1> parser, Parser`1<T2> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Sequence`3<T1, T2, T3> And(Sequence`2<T1, T2> parser, Parser`1<T3> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Sequence`2<T1, T3> And(SequenceAndSkip`2<T1, T2> parser, Parser`1<T3> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Sequence`2<T2, T3> And(SequenceSkipAnd`2<T1, T2> parser, Parser`1<T3> and);
    [ExtensionAttribute]
public static Sequence`4<T1, T2, T3, T4> And(Sequence`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static Sequence`3<T1, T2, T4> And(SequenceAndSkip`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static Sequence`3<T1, T3, T4> And(SequenceSkipAnd`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static Sequence`5<T1, T2, T3, T4, T5> And(Sequence`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static Sequence`4<T1, T2, T3, T5> And(SequenceAndSkip`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static Sequence`4<T1, T2, T4, T5> And(SequenceSkipAnd`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static Sequence`6<T1, T2, T3, T4, T5, T6> And(Sequence`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static Sequence`5<T1, T2, T3, T4, T6> And(SequenceAndSkip`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static Sequence`5<T1, T2, T3, T5, T6> And(SequenceSkipAnd`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static Sequence`7<T1, T2, T3, T4, T5, T6, T7> And(Sequence`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static Sequence`6<T1, T2, T3, T4, T5, T7> And(SequenceAndSkip`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static Sequence`6<T1, T2, T3, T4, T6, T7> And(SequenceSkipAnd`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SequenceAndSkip`2<T1, T2> AndSkip(Parser`1<T1> parser, Parser`1<T2> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SequenceAndSkip`3<T1, T2, T3> AndSkip(Sequence`2<T1, T2> parser, Parser`1<T3> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SequenceAndSkip`2<T1, T3> AndSkip(SequenceAndSkip`2<T1, T2> parser, Parser`1<T3> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SequenceAndSkip`2<T2, T3> AndSkip(SequenceSkipAnd`2<T1, T2> parser, Parser`1<T3> and);
    [ExtensionAttribute]
public static SequenceAndSkip`4<T1, T2, T3, T4> AndSkip(Sequence`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static SequenceAndSkip`3<T1, T2, T4> AndSkip(SequenceAndSkip`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static SequenceAndSkip`3<T1, T3, T4> AndSkip(SequenceSkipAnd`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static SequenceAndSkip`5<T1, T2, T3, T4, T5> AndSkip(Sequence`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static SequenceAndSkip`4<T1, T2, T3, T5> AndSkip(SequenceAndSkip`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static SequenceAndSkip`4<T1, T2, T4, T5> AndSkip(SequenceSkipAnd`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static SequenceAndSkip`6<T1, T2, T3, T4, T5, T6> AndSkip(Sequence`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static SequenceAndSkip`5<T1, T2, T3, T4, T6> AndSkip(SequenceAndSkip`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static SequenceAndSkip`5<T1, T2, T3, T5, T6> AndSkip(SequenceSkipAnd`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static SequenceAndSkip`7<T1, T2, T3, T4, T5, T6, T7> AndSkip(Sequence`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static SequenceAndSkip`6<T1, T2, T3, T4, T5, T7> AndSkip(SequenceAndSkip`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static SequenceAndSkip`6<T1, T2, T3, T4, T6, T7> AndSkip(SequenceSkipAnd`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static SequenceAndSkip`8<T1, T2, T3, T4, T5, T6, T7, T8> AndSkip(Sequence`7<T1, T2, T3, T4, T5, T6, T7> parser, Parser`1<T8> and);
    [ExtensionAttribute]
public static SequenceAndSkip`7<T1, T2, T3, T4, T5, T6, T8> AndSkip(SequenceAndSkip`7<T1, T2, T3, T4, T5, T6, T7> parser, Parser`1<T8> and);
    [ExtensionAttribute]
public static SequenceAndSkip`7<T1, T2, T3, T4, T5, T7, T8> AndSkip(SequenceSkipAnd`7<T1, T2, T3, T4, T5, T6, T7> parser, Parser`1<T8> and);
    [NullableContextAttribute("1")]
public static LiteralBuilder get_Literals();
    [NullableContextAttribute("1")]
public static TermBuilder get_Terms();
    [NullableContextAttribute("1")]
public static Parser`1<IReadOnlyList`1<T>> Separated(Parser`1<U> separator, Parser`1<T> parser);
    [NullableContextAttribute("1")]
public static Parser`1<T> SkipWhiteSpace(Parser`1<T> parser);
    [NullableContextAttribute("1")]
public static Parser`1<T> ZeroOrOne(Parser`1<T> parser, T defaultValue);
    [NullableContextAttribute("1")]
public static Parser`1<T> ZeroOrOne(Parser`1<T> parser);
    [NullableContextAttribute("1")]
public static Parser`1<IReadOnlyList`1<T>> ZeroOrMany(Parser`1<T> parser);
    [NullableContextAttribute("1")]
public static Parser`1<IReadOnlyList`1<T>> OneOrMany(Parser`1<T> parser);
    [NullableContextAttribute("1")]
public static Parser`1<T> Not(Parser`1<T> parser);
    [NullableContextAttribute("1")]
public static Deferred`1<T> Deferred();
    [NullableContextAttribute("1")]
public static Deferred`1<T> Recursive(Func`2<Deferred`1<T>, Parser`1<T>> parser);
    [NullableContextAttribute("1")]
public static Parser`1<T> Between(Parser`1<A> before, Parser`1<T> parser, Parser`1<B> after);
    [NullableContextAttribute("1")]
public static Parser`1<TextSpan> AnyCharBefore(Parser`1<T> parser, bool canBeEmpty, bool failOnEof, bool consumeDelimiter);
    [NullableContextAttribute("1")]
public static Parser`1<TextSpan> Capture(Parser`1<T> parser);
    public static Parser`1<object> Always();
    public static Parser`1<T> Always();
    [NullableContextAttribute("1")]
public static Parser`1<T> Always(T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Parser`1<T> Or(Parser`1<T> parser, Parser`1<T> or);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Parser`1<T> Or(Parser`1<A> parser, Parser`1<B> or);
    [NullableContextAttribute("1")]
public static Parser`1<T> OneOf(Parser`1[] parsers);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SequenceSkipAnd`2<T1, T2> SkipAnd(Parser`1<T1> parser, Parser`1<T2> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SequenceSkipAnd`3<T1, T2, T3> SkipAnd(Sequence`2<T1, T2> parser, Parser`1<T3> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SequenceSkipAnd`2<T1, T3> SkipAnd(SequenceAndSkip`2<T1, T2> parser, Parser`1<T3> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SequenceSkipAnd`2<T2, T3> SkipAnd(SequenceSkipAnd`2<T1, T2> parser, Parser`1<T3> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`4<T1, T2, T3, T4> SkipAnd(Sequence`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`3<T1, T2, T4> SkipAnd(SequenceAndSkip`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`3<T1, T3, T4> SkipAnd(SequenceSkipAnd`3<T1, T2, T3> parser, Parser`1<T4> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`5<T1, T2, T3, T4, T5> SkipAnd(Sequence`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`4<T1, T2, T3, T5> SkipAnd(SequenceAndSkip`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`4<T1, T2, T4, T5> SkipAnd(SequenceSkipAnd`4<T1, T2, T3, T4> parser, Parser`1<T5> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`6<T1, T2, T3, T4, T5, T6> SkipAnd(Sequence`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`5<T1, T2, T3, T4, T6> SkipAnd(SequenceAndSkip`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`5<T1, T2, T3, T5, T6> SkipAnd(SequenceSkipAnd`5<T1, T2, T3, T4, T5> parser, Parser`1<T6> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`7<T1, T2, T3, T4, T5, T6, T7> SkipAnd(Sequence`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`8<T1, T2, T3, T4, T5, T6, T7, T8> SkipAnd(Sequence`7<T1, T2, T3, T4, T5, T6, T7> parser, Parser`1<T8> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`6<T1, T2, T3, T4, T5, T7> SkipAnd(SequenceAndSkip`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [ExtensionAttribute]
public static SequenceSkipAnd`6<T1, T2, T3, T4, T6, T7> SkipAnd(SequenceSkipAnd`6<T1, T2, T3, T4, T5, T6> parser, Parser`1<T7> and);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Parser`1<T> LeftAssociative(Parser`1<T> parser, ValueTuple`2[] list);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Parser`1<T> LeftAssociative(Parser`1<T> parser, ValueTuple`2[] list);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Parser`1<T> RightAssociative(Parser`1<T> parser, ValueTuple`2[] list);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Parser`1<T> RightAssociative(Parser`1<T> parser, ValueTuple`2[] list);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Parser`1<T> Unary(Parser`1<T> parser, ValueTuple`2[] list);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Parser`1<T> Unary(Parser`1<T> parser, ValueTuple`2[] list);
}
public class Parlot.Fluent.PatternLiteral : Parser`1<TextSpan> {
    [NullableAttribute("1")]
private Func`2<char, bool> _predicate;
    private int _minSize;
    private int _maxSize;
    [NullableContextAttribute("1")]
public PatternLiteral(Func`2<char, bool> predicate, int minSize, int maxSize);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    [NullableContextAttribute("1")]
public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal class Parlot.Fluent.SByteNumberLiteral : NumberLiteralBase`1<sbyte> {
    public SByteNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, SByte& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Separated`2 : Parser`1<IReadOnlyList`1<T>> {
    private static MethodInfo _listAddMethodInfo;
    private Parser`1<U> _separator;
    private Parser`1<T> _parser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Separated`2(Parser`1<U> separator, Parser`1<T> parser);
    private static Separated`2();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Sequence`2 : Parser`1<ValueTuple`2<T1, T2>> {
    private Parser`1<T1> _parser1;
    private Parser`1<T2> _parser2;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`2(Parser`1<T1> parser1, Parser`1<T2> parser2);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Sequence`3 : Parser`1<ValueTuple`3<T1, T2, T3>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`2<T1, T2>> _parser;
    private Parser`1<T3> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`3(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Sequence`4 : Parser`1<ValueTuple`4<T1, T2, T3, T4>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`3<T1, T2, T3>> _parser;
    private Parser`1<T4> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`4(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Sequence`5 : Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`4<T1, T2, T3, T4>> _parser;
    private Parser`1<T5> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`5(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Sequence`6 : Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> _parser;
    private Parser`1<T6> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`6(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Sequence`7 : Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> _parser;
    private Parser`1<T7> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public Sequence`7(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceAndSkip`2 : Parser`1<T1> {
    private Parser`1<T1> _parser1;
    private Parser`1<T2> _parser2;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceAndSkip`2(Parser`1<T1> parser1, Parser`1<T2> parser2);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceAndSkip`3 : Parser`1<ValueTuple`2<T1, T2>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`2<T1, T2>> _parser;
    private Parser`1<T3> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceAndSkip`3(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceAndSkip`4 : Parser`1<ValueTuple`3<T1, T2, T3>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`3<T1, T2, T3>> _parser;
    private Parser`1<T4> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceAndSkip`4(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceAndSkip`5 : Parser`1<ValueTuple`4<T1, T2, T3, T4>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`4<T1, T2, T3, T4>> _parser;
    private Parser`1<T5> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceAndSkip`5(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceAndSkip`6 : Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> _parser;
    private Parser`1<T6> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceAndSkip`6(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceAndSkip`7 : Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> _parser;
    private Parser`1<T7> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceAndSkip`7(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceAndSkip`8 : Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> _parser;
    private Parser`1<T8> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceAndSkip`8(Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> parser, Parser`1<T8> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Parlot.Fluent.SequenceCompileHelper : object {
    internal static string SequenceRequired;
    private static SequenceCompileHelper();
    public static CompilationResult CreateSequenceCompileResult(SkippableCompilationResult[] parserCompileResults, CompilationContext context);
    [CompilerGeneratedAttribute]
internal static Type <CreateSequenceCompileResult>g__GetValueTuple|1_2(int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceSkipAnd`2 : Parser`1<T2> {
    private Parser`1<T1> _parser1;
    private Parser`1<T2> _parser2;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceSkipAnd`2(Parser`1<T1> parser1, Parser`1<T2> parser2);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceSkipAnd`3 : Parser`1<ValueTuple`2<T1, T3>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`2<T1, T2>> _parser;
    private Parser`1<T3> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceSkipAnd`3(Parser`1<ValueTuple`2<T1, T2>> parser, Parser`1<T3> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceSkipAnd`4 : Parser`1<ValueTuple`3<T1, T2, T4>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`3<T1, T2, T3>> _parser;
    private Parser`1<T4> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceSkipAnd`4(Parser`1<ValueTuple`3<T1, T2, T3>> parser, Parser`1<T4> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceSkipAnd`5 : Parser`1<ValueTuple`4<T1, T2, T3, T5>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`4<T1, T2, T3, T4>> _parser;
    private Parser`1<T5> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceSkipAnd`5(Parser`1<ValueTuple`4<T1, T2, T3, T4>> parser, Parser`1<T5> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceSkipAnd`6 : Parser`1<ValueTuple`5<T1, T2, T3, T4, T6>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> _parser;
    private Parser`1<T6> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceSkipAnd`6(Parser`1<ValueTuple`5<T1, T2, T3, T4, T5>> parser, Parser`1<T6> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceSkipAnd`7 : Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T7>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> _parser;
    private Parser`1<T7> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceSkipAnd`7(Parser`1<ValueTuple`6<T1, T2, T3, T4, T5, T6>> parser, Parser`1<T7> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SequenceSkipAnd`8 : Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T8>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> _parser;
    private Parser`1<T8> _lastParser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SequenceSkipAnd`8(Parser`1<ValueTuple`7<T1, T2, T3, T4, T5, T6, T7>> parser, Parser`1<T8> lastParser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual SkippableCompilationResult[] BuildSkippableParsers(CompilationContext context);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal class Parlot.Fluent.ShortNumberLiteral : NumberLiteralBase`1<short> {
    public ShortNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int16& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parlot.Fluent.SkippableCompilationResult : object {
    [CompilerGeneratedAttribute]
private CompilationResult <CompilationResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Skip>k__BackingField;
    public CompilationResult CompilationResult { get; public set; }
    public bool Skip { get; public set; }
    public SkippableCompilationResult(CompilationResult compilationResult, bool skip);
    [CompilerGeneratedAttribute]
public CompilationResult get_CompilationResult();
    [CompilerGeneratedAttribute]
public void set_CompilationResult(CompilationResult value);
    [CompilerGeneratedAttribute]
public bool get_Skip();
    [CompilerGeneratedAttribute]
public void set_Skip(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.SkipWhiteSpace`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public SkipWhiteSpace`1(Parser`1<T> parser);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parlot.Fluent.StringLiteral : Parser`1<TextSpan> {
    private static MethodInfo _decodeStringMethodInfo;
    private static Char[] SingleQuotes;
    private static Char[] DoubleQuotes;
    private static Char[] SingleOrDoubleQuotes;
    private StringLiteralQuotes _quotes;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public StringLiteral(StringLiteralQuotes quotes);
    private static StringLiteral();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    [NullableContextAttribute("0")]
public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public enum Parlot.Fluent.StringLiteralQuotes : Enum {
    public int value__;
    public static StringLiteralQuotes Single;
    public static StringLiteralQuotes Double;
    public static StringLiteralQuotes SingleOrDouble;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Switch`2 : Parser`1<U> {
    private static MethodInfo _uParse;
    private Parser`1<T> _previousParser;
    private Func`3<ParseContext, T, Parser`1<U>> _action;
    public Switch`2(Parser`1<T> previousParser, Func`3<ParseContext, T, Parser`1<U>> action);
    private static Switch`2();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parlot.Fluent.TermBuilder : object {
    public Parser`1<TextSpan> NonWhiteSpace(bool includeNewLines);
    public Parser`1<string> Text(string text, bool caseInsensitive);
    public Parser`1<char> Char(char c);
    public Parser`1<T> Number(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public Parser`1<long> Integer(NumberOptions numberOptions);
    public Parser`1<decimal> Decimal(NumberOptions numberOptions);
    [ObsoleteAttribute("Prefer Number<float>(NumberOptions.Float) instead.")]
public Parser`1<float> Float(NumberOptions numberOptions);
    [ObsoleteAttribute("Prefer Number<double>(NumberOptions.Float) instead.")]
public Parser`1<double> Double(NumberOptions numberOptions);
    public Parser`1<TextSpan> String(StringLiteralQuotes quotes);
    [NullableContextAttribute("2")]
public Parser`1<TextSpan> Identifier(Func`2<char, bool> extraStart, Func`2<char, bool> extraPart);
    public Parser`1<TextSpan> Pattern(Func`2<char, bool> predicate, int minSize, int maxSize);
}
public class Parlot.Fluent.TextBefore`1 : Parser`1<TextSpan> {
    [NullableAttribute("1")]
private Parser`1<T> _delimiter;
    private bool _canBeEmpty;
    private bool _failOnEof;
    private bool _consumeDelimiter;
    [NullableContextAttribute("1")]
public TextBefore`1(Parser`1<T> delimiter, bool canBeEmpty, bool failOnEof, bool consumeDelimiter);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    [NullableContextAttribute("1")]
public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.TextLiteral : Parser`1<string> {
    private StringComparison _comparisonType;
    private bool _hasNewLines;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public string Text { get; }
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public TextLiteral(string text, StringComparison comparisonType);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.Then`2 : Parser`1<U> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<T, U> _action1;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<ParseContext, T, U> _action2;
    [NullableAttribute("2")]
private U _value;
    private Parser`1<T> _parser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    private Then`2(Parser`1<T> parser);
    public Then`2(Parser`1<T> parser, Func`2<T, U> action);
    public Then`2(Parser`1<T> parser, Func`3<ParseContext, T, U> action);
    public Then`2(Parser`1<T> parser, U value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
internal class Parlot.Fluent.UIntNumberLiteral : NumberLiteralBase`1<UInt32> {
    public UIntNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt32& value);
}
internal class Parlot.Fluent.ULongNumberLiteral : NumberLiteralBase`1<ulong> {
    public ULongNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt64& value);
}
internal class Parlot.Fluent.UShortNumberLiteral : NumberLiteralBase`1<ushort> {
    public UShortNumberLiteral(NumberOptions numberOptions, char decimalSeparator, char groupSeparator);
    public virtual bool TryParseNumber(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt16& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.When`1 : Parser`1<T> {
    private Func`2<T, bool> _action;
    private Parser`1<T> _parser;
    public When`1(Parser`1<T> parser, Func`2<T, bool> action);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
public class Parlot.Fluent.WhiteSpaceLiteral : Parser`1<TextSpan> {
    private bool _includeNewLines;
    public WhiteSpaceLiteral(bool includeNewLines);
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    [NullableContextAttribute("1")]
public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.ZeroOrMany`1 : Parser`1<IReadOnlyList`1<T>> {
    private static MethodInfo _listAdd;
    private Parser`1<T> _parser;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public ZeroOrMany`1(Parser`1<T> parser);
    private static ZeroOrMany`1();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Parlot.Fluent.ZeroOrOne`1 : Parser`1<T> {
    private Parser`1<T> _parser;
    private T _defaultValue;
    [CompilerGeneratedAttribute]
private bool <CanSeek>k__BackingField;
    [CompilerGeneratedAttribute]
private Char[] <ExpectedChars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipWhitespace>k__BackingField;
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public ZeroOrOne`1(Parser`1<T> parser, T defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanSeek();
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_ExpectedChars();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SkipWhitespace();
    public virtual bool Parse(ParseContext context, ParseResult`1& result);
    public sealed virtual CompilationResult Compile(CompilationContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Parlot.ParseError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private TextPosition <Position>k__BackingField;
    public string Message { get; public set; }
    public TextPosition Position { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public TextPosition get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(TextPosition value);
}
public class Parlot.ParseException : Exception {
    [CompilerGeneratedAttribute]
private TextPosition <Position>k__BackingField;
    public TextPosition Position { get; public set; }
    [NullableContextAttribute("1")]
public ParseException(string message, TextPosition position);
    [CompilerGeneratedAttribute]
public TextPosition get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(TextPosition value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Parlot.ParseResult`1 : ValueType {
    public int Start;
    public int End;
    public T Value;
    public ParseResult`1(int start, int end, T value);
    public void Set(int start, int end, T value);
}
[ExtensionAttribute]
internal static class Parlot.Polyfill : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> Append(IEnumerable`1<T> source, T element);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static string Create(string _, int length, TState state, SpanAction`2<char, TState> action);
}
[NullableContextAttribute("1")]
public interface Parlot.Rewriting.IRewritable`1 {
    public abstract virtual Parser`1<T> Rewrite();
}
[NullableContextAttribute("1")]
public interface Parlot.Rewriting.ISeekable {
    public bool CanSeek { get; }
    public Char[] ExpectedChars { get; }
    public bool SkipWhitespace { get; }
    public abstract virtual bool get_CanSeek();
    public abstract virtual Char[] get_ExpectedChars();
    public abstract virtual bool get_SkipWhitespace();
}
public class Parlot.Scanner : object {
    [NullableAttribute("1")]
public string Buffer;
    [NullableAttribute("1")]
public Cursor Cursor;
    [NullableContextAttribute("1")]
public Scanner(string buffer);
    public bool SkipWhiteSpaceOrNewLine();
    public bool SkipWhiteSpace();
    [NullableContextAttribute("1")]
public bool ReadFirstThenOthers(Func`2<char, bool> first, Func`2<char, bool> other);
    [NullableContextAttribute("1")]
public bool ReadFirstThenOthers(Func`2<char, bool> first, Func`2<char, bool> other, ReadOnlySpan`1& result);
    public bool ReadIdentifier();
    public bool ReadIdentifier(ReadOnlySpan`1& result);
    public bool ReadDecimal();
    public bool ReadDecimal(ReadOnlySpan`1& number);
    public bool ReadDecimal(NumberOptions numberOptions, ReadOnlySpan`1& number, char decimalSeparator, char groupSeparator);
    public bool ReadDecimal(bool allowLeadingSign, bool allowDecimalSeparator, bool allowGroupSeparator, bool allowExponent, ReadOnlySpan`1& number, char decimalSeparator, char groupSeparator);
    public bool ReadInteger();
    public bool ReadInteger(ReadOnlySpan`1& result);
    [NullableContextAttribute("1")]
public bool ReadWhile(Func`2<char, bool> predicate);
    public bool ReadWhile(Func`2<char, bool> predicate, ReadOnlySpan`1& result);
    public bool ReadNonWhiteSpace();
    public bool ReadNonWhiteSpace(ReadOnlySpan`1& result);
    public bool ReadNonWhiteSpaceOrNewLine();
    public bool ReadNonWhiteSpaceOrNewLine(ReadOnlySpan`1& result);
    public bool ReadChar(char c);
    public bool ReadChar(char c, ReadOnlySpan`1& result);
    public bool ReadText(ReadOnlySpan`1<char> text, StringComparison comparisonType);
    public bool ReadText(ReadOnlySpan`1<char> text, StringComparison comparisonType, ReadOnlySpan`1& result);
    [ObsoleteAttribute("Prefer bool ReadAnyOf(ReadOnlySpan<char>, out ReadOnlySpan<char>)")]
public bool ReadAnyOf(ReadOnlySpan`1<char> chars, StringComparison comparisonType, ReadOnlySpan`1& result);
    public bool ReadAnyOf(ReadOnlySpan`1<char> chars, ReadOnlySpan`1& result);
    public bool ReadText(ReadOnlySpan`1<char> text);
    public bool ReadText(ReadOnlySpan`1<char> text, ReadOnlySpan`1& result);
    public bool ReadSingleQuotedString();
    public bool ReadSingleQuotedString(ReadOnlySpan`1& result);
    public bool ReadDoubleQuotedString();
    public bool ReadDoubleQuotedString(ReadOnlySpan`1& result);
    public bool ReadQuotedString();
    public bool ReadQuotedString(ReadOnlySpan`1& result);
    private bool ReadQuotedString(char quoteChar, ReadOnlySpan`1& result);
}
[IsReadOnlyAttribute]
public class Parlot.TextPosition : ValueType {
    public static TextPosition Start;
    public int Offset;
    public int Line;
    public int Column;
    public TextPosition(int offset, int line, int column);
    private static TextPosition();
    public static int op_Subtraction(TextPosition& left, TextPosition& right);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Parlot.TextSpan : ValueType {
    public int Length;
    public int Offset;
    public string Buffer;
    [NullableAttribute("0")]
public ReadOnlySpan`1<char> Span { get; }
    public TextSpan(string value);
    public TextSpan(string buffer, int offset, int count);
    [NullableContextAttribute("0")]
public ReadOnlySpan`1<char> get_Span();
    public virtual string ToString();
    public sealed virtual bool Equals(string other);
    public sealed virtual bool Equals(TextSpan other);
    [NullableContextAttribute("1")]
public static TextSpan op_Implicit(string s);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TextSpan left, TextSpan right);
    public static bool op_Inequality(TextSpan left, TextSpan right);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.ExperimentalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string DiagnosticId { get; }
    [NullableAttribute("2")]
public string UrlFormat { get; public set; }
    public ExperimentalAttribute(string diagnosticId);
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_UrlFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
[AttributeUsageAttribute("32")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("2240")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
private string ToStringFromEnd();
}
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5212")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CollectionBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public Type BuilderType { get; }
    public string MethodName { get; }
    public CollectionBuilderAttribute(Type builderType, string methodName);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
    [CompilerGeneratedAttribute]
public string get_MethodName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiresLocationAttribute : Attribute {
}
[AttributeUsageAttribute("1774")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresPreviewFeaturesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
